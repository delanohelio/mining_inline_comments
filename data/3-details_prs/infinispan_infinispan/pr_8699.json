{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4NzgxNjE1", "number": 8699, "title": "ISPN-11176 Xsite Max Idle", "bodyText": "https://issues.redhat.com/browse/ISPN-11176\nhttps://issues.redhat.com/browse/ISPN-12337", "createdAt": "2020-09-17T16:11:32Z", "url": "https://github.com/infinispan/infinispan/pull/8699", "merged": true, "mergeCommit": {"oid": "a4e5202bb30ece0e3bebb79908bb9fdaa5324099"}, "closed": true, "closedAt": "2020-10-08T14:54:26Z", "author": {"login": "wburns"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdJ2iEDABqjM3Nzk2ODAzNTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdPm_MbgBqjM4NDE1NTYwMDQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a3699a80ba1549bb7d758c97a73496806dae979b", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/a3699a80ba1549bb7d758c97a73496806dae979b", "committedDate": "2020-09-17T16:02:13Z", "message": "ISPN-12337 Clustered Expiration can deadlock with Pessimistic Tx on a non owner"}, "afterCommit": {"oid": "2eb9d8811c5c6b3c12462c24ffb29de70460d51a", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/2eb9d8811c5c6b3c12462c24ffb29de70460d51a", "committedDate": "2020-09-17T19:54:29Z", "message": "ISPN-12337 Clustered Expiration can deadlock with Pessimistic Tx on a non owner"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2eb9d8811c5c6b3c12462c24ffb29de70460d51a", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/2eb9d8811c5c6b3c12462c24ffb29de70460d51a", "committedDate": "2020-09-17T19:54:29Z", "message": "ISPN-12337 Clustered Expiration can deadlock with Pessimistic Tx on a non owner"}, "afterCommit": {"oid": "fada47639ef487654143532eb32e0e84f62f40cc", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/fada47639ef487654143532eb32e0e84f62f40cc", "committedDate": "2020-09-21T14:02:12Z", "message": "ISPN-12337 Clustered Expiration can deadlock with Pessimistic Tx on a non owner"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "898ec5692eef0f14cc9d2123ad4b6d5eecb5d92e", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/898ec5692eef0f14cc9d2123ad4b6d5eecb5d92e", "committedDate": "2020-09-24T04:57:23Z", "message": "ISPN-11176 XSite Max Idle\n\n* Refactor touch to be a visitable command\n* Add Touch logic to interceptors"}, "afterCommit": {"oid": "77ae2bce5a7f84055893424ebca447555505b7d7", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/77ae2bce5a7f84055893424ebca447555505b7d7", "committedDate": "2020-09-24T05:01:33Z", "message": "ISPN-11176 XSite Max Idle\n\n* Refactor touch to be a visitable command\n* Add Touch logic to interceptors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2NTQ1Mjc5", "url": "https://github.com/infinispan/infinispan/pull/8699#pullrequestreview-496545279", "createdAt": "2020-09-25T15:52:06Z", "commit": {"oid": "77ae2bce5a7f84055893424ebca447555505b7d7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNTo1MjowN1rOHYJRxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQxNjowNzoyNVrOHYJ2BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA3OTg3Ng==", "bodyText": "since the method is exposed to users, I would check <0 instead.", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495079876", "createdAt": "2020-09-25T15:52:07Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/cache/impl/CacheImpl.java", "diffHunk": "@@ -1218,6 +1220,24 @@ public String toString() {\n       return \"Cache '\" + name + \"'@\" + (config != null && config.clustering().cacheMode().isClustered() ? getRpcManager().getAddress() : Util.hexIdHashCode(getCacheManager()));\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      return touch(key, -1, touchEvenIfExpired, 0);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n+      return touch(key, segment, touchEvenIfExpired, 0);\n+   }\n+\n+   public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired, long flagBitSet) {\n+      if (segment == -1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77ae2bce5a7f84055893424ebca447555505b7d7"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MDIzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return touch(key, -1, touchEvenIfExpired, 0);\n          \n          \n            \n                  return touch(key, -1, touchEvenIfExpired, EnumUtil.EMPTY_BIT_SET);", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495080238", "createdAt": "2020-09-25T15:52:40Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/cache/impl/CacheImpl.java", "diffHunk": "@@ -1218,6 +1220,24 @@ public String toString() {\n       return \"Cache '\" + name + \"'@\" + (config != null && config.clustering().cacheMode().isClustered() ? getRpcManager().getAddress() : Util.hexIdHashCode(getCacheManager()));\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      return touch(key, -1, touchEvenIfExpired, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77ae2bce5a7f84055893424ebca447555505b7d7"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MDUxMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return touch(key, segment, touchEvenIfExpired, 0);\n          \n          \n            \n                  return touch(key, segment, touchEvenIfExpired, EnumUtil.EMPTY_BIT_SET);", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495080511", "createdAt": "2020-09-25T15:53:07Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/cache/impl/CacheImpl.java", "diffHunk": "@@ -1218,6 +1220,24 @@ public String toString() {\n       return \"Cache '\" + name + \"'@\" + (config != null && config.clustering().cacheMode().isClustered() ? getRpcManager().getAddress() : Util.hexIdHashCode(getCacheManager()));\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      return touch(key, -1, touchEvenIfExpired, 0);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n+      return touch(key, segment, touchEvenIfExpired, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77ae2bce5a7f84055893424ebca447555505b7d7"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MTI3Mw==", "bodyText": "use -1 as  segment?", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495081273", "createdAt": "2020-09-25T15:54:20Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/cache/impl/SimpleCacheImpl.java", "diffHunk": "@@ -390,6 +392,26 @@ public void setAvailability(AvailabilityMode availabilityMode) {\n       throw new UnsupportedOperationException();\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      Objects.requireNonNull(key, NULL_KEYS_NOT_SUPPORTED);\n+      int segment = keyPartitioner.getSegment(key);\n+      return touch(key, segment, touchEvenIfExpired);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77ae2bce5a7f84055893424ebca447555505b7d7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MTU1NA==", "bodyText": "ps. Objects.requireNonNull() isn't required here. the other method checks it.", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495081554", "createdAt": "2020-09-25T15:54:48Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/cache/impl/SimpleCacheImpl.java", "diffHunk": "@@ -390,6 +392,26 @@ public void setAvailability(AvailabilityMode availabilityMode) {\n       throw new UnsupportedOperationException();\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      Objects.requireNonNull(key, NULL_KEYS_NOT_SUPPORTED);\n+      int segment = keyPartitioner.getSegment(key);\n+      return touch(key, segment, touchEvenIfExpired);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MTI3Mw=="}, "originalCommit": {"oid": "77ae2bce5a7f84055893424ebca447555505b7d7"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4Mjk2Nw==", "bodyText": "check if segment is valid?\nofftopic, would be good to have an \"utility\" method like\nint requireValidSegment(Object k, int segment, KeyPartitioner p) {\n  return segment if segement in [0..numSegments] else p.getSegment(k)\n}", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495082967", "createdAt": "2020-09-25T15:57:01Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/cache/impl/SimpleCacheImpl.java", "diffHunk": "@@ -390,6 +392,26 @@ public void setAvailability(AvailabilityMode availabilityMode) {\n       throw new UnsupportedOperationException();\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      Objects.requireNonNull(key, NULL_KEYS_NOT_SUPPORTED);\n+      int segment = keyPartitioner.getSegment(key);\n+      return touch(key, segment, touchEvenIfExpired);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n+      Objects.requireNonNull(key, NULL_KEYS_NOT_SUPPORTED);\n+      InternalCacheEntry<K, V> entry = dataContainer.peek(segment, key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77ae2bce5a7f84055893424ebca447555505b7d7"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4NDczNw==", "bodyText": "question: is the flag bitset used?", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495084737", "createdAt": "2020-09-25T15:59:40Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/commands/CommandsFactoryImpl.java", "diffHunk": "@@ -694,8 +695,8 @@ public CheckTransactionRpcCommand buildCheckTransactionRpcCommand(Collection<Glo\n    }\n \n    @Override\n-   public TouchCommand buildTouchCommand(Object key, int segment) {\n-      return new TouchCommand(cacheName, key, segment);\n+   public TouchCommand buildTouchCommand(Object key, int segment, boolean touchEvenIfExpired, long flagBitSet) {\n+      return new TouchCommand(key, segment, flagBitSet, touchEvenIfExpired);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77ae2bce5a7f84055893424ebca447555505b7d7"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4Nzg3MQ==", "bodyText": "shouldn't be sent to the primary owner?", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495087871", "createdAt": "2020-09-25T16:05:03Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java", "diffHunk": "@@ -257,6 +260,25 @@ private XSiteStatePushCommand newStatePushCommand(List<XSiteState> stateList) {\n       return defaultHandler.cache().clearAsync();\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touchEntry(Object key) {\n+      int segment = clusteringDependentLogic.getCacheTopology().getSegment(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77ae2bce5a7f84055893424ebca447555505b7d7"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4OTE1Nw==", "bodyText": "can you revert this and remove the `componentRegistry' field? I know I'm complaining just to save 8 bytes eh eh", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495089157", "createdAt": "2020-09-25T16:07:25Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java", "diffHunk": "@@ -126,9 +130,8 @@ public ClusteredCacheBackupReceiver(String cacheName) {\n    public void start() {\n       //it would be nice if we could inject bootstrap component\n       //this feels kind hacky but saves 3 fields in this class\n-      ComponentRegistry cr = cache.getAdvancedCache().getComponentRegistry();\n-      TransactionHandler txHandler = new TransactionHandler(cache, cr.getTransactionTable());\n-      defaultHandler = new DefaultHandler(txHandler, cr.getComponent(BlockingManager.class));\n+      TransactionHandler txHandler = new TransactionHandler(cache, componentRegistry.getTransactionTable());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "77ae2bce5a7f84055893424ebca447555505b7d7"}, "originalPosition": 28}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "77ae2bce5a7f84055893424ebca447555505b7d7", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/77ae2bce5a7f84055893424ebca447555505b7d7", "committedDate": "2020-09-24T05:01:33Z", "message": "ISPN-11176 XSite Max Idle\n\n* Refactor touch to be a visitable command\n* Add Touch logic to interceptors"}, "afterCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/405a8b2b22032e146866a8f8dca8515df4882200", "committedDate": "2020-09-28T19:46:46Z", "message": "ISPN-11176 XSite Max Idle\n\n* Refactor touch to be a visitable command\n* Add Touch logic to interceptors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk3ODUyMjYy", "url": "https://github.com/infinispan/infinispan/pull/8699#pullrequestreview-497852262", "createdAt": "2020-09-28T19:59:30Z", "commit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxOTo1OTozMFrOHZNjvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQyMTowNzoxNVrOHZPqAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE5ODU5MQ==", "bodyText": "nit: no longer used. can be removed.", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496198591", "createdAt": "2020-09-28T19:59:30Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java", "diffHunk": "@@ -111,7 +113,7 @@\n    @Inject InvocationContextFactory invocationContextFactory;\n    @Inject RpcManager rpcManager;\n    @Inject ClusteringDependentLogic clusteringDependentLogic;\n-   @Inject ComponentRegistry componentRegistry;\n+   @Inject InternalDataContainer<Object, Object> dataContainer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwMjM2MA==", "bodyText": "is it ok to use 0 as a segment? shouldn't be -1 since 0 is valid? or split the entries per segment.\nAre you plan to use the segment in the future? currently isn't used and could be removed.", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496202360", "createdAt": "2020-09-28T20:07:07Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/container/impl/DefaultDataContainer.java", "diffHunk": "@@ -233,4 +232,10 @@ public void cleanUp() {\n          evictionCache.cleanUp();\n       }\n    }\n+\n+\n+   @Override\n+   public void forEachSegment(ObjIntConsumer<PeekableTouchableMap<K, V>> segmentMapConsumer) {\n+      segmentMapConsumer.accept(entries, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNDgyOA==", "bodyText": "I'm not sure if this is correct. setting isWrite = hasLock will skip the max-idle expiration check. is it intentional?\nIn a pessimisitc transaction, you can lock a key never write to it.", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496204828", "createdAt": "2020-09-28T20:12:03Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/container/impl/EntryFactoryImpl.java", "diffHunk": "@@ -84,7 +85,7 @@ public void init() {\n             }\n          } else if (isOwner || readEntry.isL1Entry()) {\n             if (readEntry.canExpire()) {\n-               CompletionStage<Boolean> expiredStage = expirationManager.handlePossibleExpiration(readEntry, segment, false);\n+               CompletionStage<Boolean> expiredStage = expirationManager.handlePossibleExpiration(readEntry, segment, hasLock);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNTQ0Ng==", "bodyText": "segment=0 here too. same comment as somewhere above :)", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496205446", "createdAt": "2020-09-28T20:13:17Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/container/offheap/OffHeapDataContainer.java", "diffHunk": "@@ -107,4 +108,9 @@ public int sizeIncludingExpired() {\n    public void clear() {\n       map.clear();\n    }\n+\n+   @Override\n+   public void forEachSegment(ObjIntConsumer<PeekableTouchableMap<WrappedBytes, WrappedBytes>> segmentMapConsumer) {\n+      segmentMapConsumer.accept(map, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNjM5MA==", "bodyText": "typo:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               private Map<String, TopologyIracVersion> getVectorFunctiton(Integer s,\n          \n          \n            \n               private Map<String, TopologyIracVersion> getVectorFunction(Integer s,", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496206390", "createdAt": "2020-09-28T20:15:15Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/container/versioning/irac/DefaultIracVersionGenerator.java", "diffHunk": "@@ -112,6 +118,15 @@ public void removeTombstone(Object key) {\n       }\n    }\n \n+   private Map<String, TopologyIracVersion> getVectorFunctiton(Integer s,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwODY5MQ==", "bodyText": "hmm, I thought the cache stored in ComponentRegistry didn't have any encoding...", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496208691", "createdAt": "2020-09-28T20:20:02Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -99,6 +88,9 @@ public void start() {\n                   expWakeUpInt, expWakeUpInt, TimeUnit.MILLISECONDS);\n          }\n       }\n+      // Data container entries are retrieved directly, so we don't need to worry about an encodings\n+      this.cache = AbstractDelegatingCache.unwrapCache(cacheRef.wired()).getAdvancedCache();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxMjYyMQ==", "bodyText": "why? this will trigger unnecessary replication and xsite replications.", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496212621", "createdAt": "2020-09-28T20:27:56Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java", "diffHunk": "@@ -592,8 +593,11 @@ public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredComm\n          } else if (trace) {\n             log.trace(\"Cannot remove entry as its lifespan or value do not match\");\n          }\n-      } else if (trace) {\n-         log.trace(\"Nothing to remove since the entry doesn't exist in the context or it is already removed\");\n+      } else {\n+         if (trace) {\n+            log.trace(\"Nothing to remove since the entry doesn't exist in the context or it is already removed - assume command was successful\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNDI0MQ==", "bodyText": "why returning Boolean.FALSE? it is something I'm not used to seeing very often.", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496214241", "createdAt": "2020-09-28T20:30:59Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java", "diffHunk": "@@ -1115,6 +1119,32 @@ public Object visitReadWriteManyEntriesCommand(InvocationContext ctx, ReadWriteM\n       return returns;\n    }\n \n+   @Override\n+   public Object visitTouchCommand(InvocationContext ctx, TouchCommand command) throws Throwable {\n+      int segment = command.getSegment();\n+      Object key = command.getKey();\n+      InternalCacheEntry<?, ?> ice = dataContainer.peek(segment, key);\n+      if (ice == null) {\n+         if (trace) {\n+            log.tracef(\"Entry was not in the container to touch for key %s\", key);\n+         }\n+         return Boolean.FALSE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNTU0OA==", "bodyText": "I'm wondering if we could invoke touch() directly to avoid multiple gets (get segment map and get key twice)", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496215548", "createdAt": "2020-09-28T20:33:34Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java", "diffHunk": "@@ -1115,6 +1119,32 @@ public Object visitReadWriteManyEntriesCommand(InvocationContext ctx, ReadWriteM\n       return returns;\n    }\n \n+   @Override\n+   public Object visitTouchCommand(InvocationContext ctx, TouchCommand command) throws Throwable {\n+      int segment = command.getSegment();\n+      Object key = command.getKey();\n+      InternalCacheEntry<?, ?> ice = dataContainer.peek(segment, key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNzI1Mg==", "bodyText": "hmmm, I still think it should use the IracMetadata stored in the context's CacheEntry\nEven if \"this key\" isn't changed, the segment version will always move.", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496217252", "createdAt": "2020-09-28T20:36:49Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/interceptors/impl/NonTxIracLocalSiteInterceptor.java", "diffHunk": "@@ -194,7 +189,13 @@ private void visitKey(Object key, WriteCommand command) {\n       if (getOwnership(segment) != Ownership.PRIMARY) {\n          return;\n       }\n-      IracMetadata metadata = iracVersionGenerator.generateNewMetadata(segment);\n+      IracMetadata metadata;\n+      // RemoveExpired should lose to any other conflicting write\n+      if (command instanceof RemoveExpiredCommand) {\n+         metadata = iracVersionGenerator.generateMetadataWithCurrentVersion(segment);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxOTI1OQ==", "bodyText": "Use the handleExpiredReturn field and the rCommand\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                           return invokeNextThenAccept(rCtx, command, this::handleExpiredReturn);\n          \n          \n            \n                           return invokeNextThenAccept(rCtx, rCommand, handleExpiredReturn);", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496219259", "createdAt": "2020-09-28T20:40:44Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java", "diffHunk": "@@ -51,6 +56,38 @@ Object invokeNextAndWaitForCrossSite(TxInvocationContext<?> ctx, VisitableComman\n       return invokeNextThenApply(ctx, command, stage::thenReturn);\n    }\n \n+   @Override\n+   public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredCommand command) {\n+      if (skipXSiteBackup(command) || !command.isMaxIdle()) {\n+         return invokeNext(ctx, command);\n+      }\n+      // Max idle command shouldn't fail as the timestamps are updated on access, however the remote site may have\n+      // a read that we aren't aware of - so we must synchronously remove the entry if expired on the remote site\n+      // and if it isn't expired on the remote site we must update the access time locally here\n+      int segment = command.getSegment();\n+      DistributionInfo dInfo = clusteringDependentLogic.getCacheTopology().getSegmentDistribution(segment);\n+      // Only require primary to check remote site and add to irac queue - If primary dies then a backup will end up\n+      // doing the same as promoted primary - We also don't add tracked up to backup as we don't care if the\n+      // remove expired is lost due to topology change it just will cause another check later but maintain consistency\n+      if (dInfo.isPrimary()) {\n+         CompletionStage<Boolean> expired = iracManager.checkAndTrackExpiration(command.getKey());\n+         return asyncValue(expired).thenApply(ctx, command, (rCtx, rCommand, rv) -> {\n+            if ((Boolean) rv) {\n+               return invokeNextThenAccept(rCtx, command, this::handleExpiredReturn);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxOTM1NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        command.fail();\n          \n          \n            \n                        rCommand.fail();", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496219355", "createdAt": "2020-09-28T20:40:56Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java", "diffHunk": "@@ -51,6 +56,38 @@ Object invokeNextAndWaitForCrossSite(TxInvocationContext<?> ctx, VisitableComman\n       return invokeNextThenApply(ctx, command, stage::thenReturn);\n    }\n \n+   @Override\n+   public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredCommand command) {\n+      if (skipXSiteBackup(command) || !command.isMaxIdle()) {\n+         return invokeNext(ctx, command);\n+      }\n+      // Max idle command shouldn't fail as the timestamps are updated on access, however the remote site may have\n+      // a read that we aren't aware of - so we must synchronously remove the entry if expired on the remote site\n+      // and if it isn't expired on the remote site we must update the access time locally here\n+      int segment = command.getSegment();\n+      DistributionInfo dInfo = clusteringDependentLogic.getCacheTopology().getSegmentDistribution(segment);\n+      // Only require primary to check remote site and add to irac queue - If primary dies then a backup will end up\n+      // doing the same as promoted primary - We also don't add tracked up to backup as we don't care if the\n+      // remove expired is lost due to topology change it just will cause another check later but maintain consistency\n+      if (dInfo.isPrimary()) {\n+         CompletionStage<Boolean> expired = iracManager.checkAndTrackExpiration(command.getKey());\n+         return asyncValue(expired).thenApply(ctx, command, (rCtx, rCommand, rv) -> {\n+            if ((Boolean) rv) {\n+               return invokeNextThenAccept(rCtx, command, this::handleExpiredReturn);\n+            }\n+            command.fail();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxOTYwNw==", "bodyText": "this lambda could be cached", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496219607", "createdAt": "2020-09-28T20:41:27Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java", "diffHunk": "@@ -51,6 +56,38 @@ Object invokeNextAndWaitForCrossSite(TxInvocationContext<?> ctx, VisitableComman\n       return invokeNextThenApply(ctx, command, stage::thenReturn);\n    }\n \n+   @Override\n+   public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredCommand command) {\n+      if (skipXSiteBackup(command) || !command.isMaxIdle()) {\n+         return invokeNext(ctx, command);\n+      }\n+      // Max idle command shouldn't fail as the timestamps are updated on access, however the remote site may have\n+      // a read that we aren't aware of - so we must synchronously remove the entry if expired on the remote site\n+      // and if it isn't expired on the remote site we must update the access time locally here\n+      int segment = command.getSegment();\n+      DistributionInfo dInfo = clusteringDependentLogic.getCacheTopology().getSegmentDistribution(segment);\n+      // Only require primary to check remote site and add to irac queue - If primary dies then a backup will end up\n+      // doing the same as promoted primary - We also don't add tracked up to backup as we don't care if the\n+      // remove expired is lost due to topology change it just will cause another check later but maintain consistency\n+      if (dInfo.isPrimary()) {\n+         CompletionStage<Boolean> expired = iracManager.checkAndTrackExpiration(command.getKey());\n+         return asyncValue(expired).thenApply(ctx, command, (rCtx, rCommand, rv) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMzUxNA==", "bodyText": "unused", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496223514", "createdAt": "2020-09-28T20:49:02Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/xsite/status/DefaultTakeOfflineManager.java", "diffHunk": "@@ -52,6 +56,9 @@\n    @Inject Configuration config;\n    @Inject EventLogManager eventLogManager;\n    @Inject RpcManager rpcManager;\n+   @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR)\n+   @Inject Executor nonBlockingExecutor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMzg1Nw==", "bodyText": "you could have created a touchAll() and avoid some lambdas :)", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496223857", "createdAt": "2020-09-28T20:49:42Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/xsite/status/DefaultTakeOfflineManager.java", "diffHunk": "@@ -197,6 +204,10 @@ public void siteOnline() {\n       @Override\n       public void siteOffline() {\n          getEventLogger().info(EventLogCategory.CLUSTER, MESSAGES.siteOffline(siteName));\n+         log.debug(\"Touching all in memory entries as a site has gone offline\");\n+         long currentTimeMillis = timeService.wallClockTime();\n+         dataContainer.forEachSegment((map, segment) ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNDUxNg==", "bodyText": "is this intentional? couldn't just invoke touch(key, -1, touchEvenIfExpired)", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496224516", "createdAt": "2020-09-28T20:51:01Z", "author": {"login": "pruivo"}, "path": "core/src/test/java/org/infinispan/functional/decorators/FunctionalAdvancedCache.java", "diffHunk": "@@ -282,6 +282,16 @@ public void start() {\n       cache.start();\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n+      return cache.touch(key, segment, touchEvenIfExpired);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNjk5MQ==", "bodyText": "why checking \"k\"?", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496226991", "createdAt": "2020-09-28T20:55:50Z", "author": {"login": "pruivo"}, "path": "core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.infinispan.xsite;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.distribution.MagicKey;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * @author William Burns\n+ * @since 12.0\n+ */\n+@Test(groups = \"xsite\", testName = \"xsite.AsyncBackupExpirationTest\")\n+public class AsyncBackupExpirationTest extends AbstractTwoSitesTest {\n+\n+   private ConfigMode lonConfigMode;\n+   private ConfigMode nycConfigMode;\n+\n+   private static ConfigurationBuilder getConfig(ConfigMode configMode) {\n+      if (configMode == ConfigMode.NON_TX) {\n+         return getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      }\n+      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, true);\n+      switch (configMode) {\n+         case OPTIMISTIC_TX_RC:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.READ_COMMITTED);\n+            break;\n+         case OPTIMISTIC_TX_RR:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);\n+            break;\n+         case PESSIMISTIC_TX:\n+            builder.transaction().lockingMode(LockingMode.PESSIMISTIC);\n+            break;\n+      }\n+      builder.expiration().wakeUpInterval(-1);\n+      return builder;\n+   }\n+\n+   @Override\n+   protected GlobalConfigurationBuilder globalConfigurationBuilderForSite(String siteName) {\n+      return super.globalConfigurationBuilderForSite(siteName);\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<AsyncBackupExpirationTest> tests = new LinkedList<>();\n+      for (ConfigMode lon : ConfigMode.values()) {\n+         for (ConfigMode nyc : ConfigMode.values()) {\n+            tests.add(new AsyncBackupExpirationTest().setLonConfigMode(lon).setNycConfigMode(nyc));\n+         }\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"LON\", \"NYC\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{lonConfigMode, nycConfigMode};\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getNycActiveConfig() {\n+      return getConfig(nycConfigMode);\n+   }\n+\n+   @BeforeMethod\n+   public void ensureSitesOnline() {\n+      // Now we take the backup offline - which should refresh our access times\n+      XSiteAdminOperations adminOperations = extractComponent(cache(LON, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(NYC))) {\n+         adminOperations.bringSiteOnline(NYC);\n+      }\n+\n+      adminOperations = extractComponent(cache(NYC, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(LON))) {\n+         adminOperations.bringSiteOnline(LON);\n+      }\n+   }\n+\n+   public AsyncBackupExpirationTest() {\n+      super.lonBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.nycBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.implicitBackupCache = true;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getLonActiveConfig() {\n+      return getConfig(lonConfigMode);\n+   }\n+\n+   private AsyncBackupExpirationTest setLonConfigMode(ConfigMode configMode) {\n+      this.lonConfigMode = configMode;\n+      return this;\n+   }\n+\n+   private AsyncBackupExpirationTest setNycConfigMode(ConfigMode configMode) {\n+      this.nycConfigMode = configMode;\n+      return this;\n+   }\n+\n+   @DataProvider(name = \"two boolean cross product\")\n+   public Object[][] tx() {\n+      return new Object[][]{\n+            {false, false},\n+            {false, true},\n+            {true, false},\n+            {true, true}\n+      };\n+   }\n+\n+   private ControlledTimeService replaceTimeService() {\n+      ControlledTimeService timeService = new ControlledTimeService();\n+      // Max idle requires all caches to show it as expired to be removed.\n+      for (Cache<?, ?> c : caches(LON)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      for (Cache<?, ?> c : caches(NYC)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      return timeService;\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testExpiredAccess(boolean lifespan, boolean readOnPrimary) throws InterruptedException {\n+      Cache<MagicKey, String> cache = cache(LON, 0);\n+\n+      ControlledTimeService timeService = replaceTimeService();\n+\n+      MagicKey key = readOnPrimary ? new MagicKey(cache) : new MagicKey(cache(LON, 1));\n+      if (lifespan) {\n+         cache.put(key, \"v\", 1, TimeUnit.SECONDS);\n+      } else {\n+         cache.put(key, \"v\", -1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS);\n+      }\n+      eventuallyEquals(\"v\", () -> cache(LON, 0).get(key));\n+      eventuallyEquals(\"v\", () -> cache(LON, 1).get(key));\n+      Cache<Object, Object> backupCache = backup(LON);\n+      assertNull(backupCache.get(\"k\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNzI4Nw==", "bodyText": "shouldn't check if backupCache also returns null?", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496227287", "createdAt": "2020-09-28T20:56:21Z", "author": {"login": "pruivo"}, "path": "core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.infinispan.xsite;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.distribution.MagicKey;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * @author William Burns\n+ * @since 12.0\n+ */\n+@Test(groups = \"xsite\", testName = \"xsite.AsyncBackupExpirationTest\")\n+public class AsyncBackupExpirationTest extends AbstractTwoSitesTest {\n+\n+   private ConfigMode lonConfigMode;\n+   private ConfigMode nycConfigMode;\n+\n+   private static ConfigurationBuilder getConfig(ConfigMode configMode) {\n+      if (configMode == ConfigMode.NON_TX) {\n+         return getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      }\n+      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, true);\n+      switch (configMode) {\n+         case OPTIMISTIC_TX_RC:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.READ_COMMITTED);\n+            break;\n+         case OPTIMISTIC_TX_RR:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);\n+            break;\n+         case PESSIMISTIC_TX:\n+            builder.transaction().lockingMode(LockingMode.PESSIMISTIC);\n+            break;\n+      }\n+      builder.expiration().wakeUpInterval(-1);\n+      return builder;\n+   }\n+\n+   @Override\n+   protected GlobalConfigurationBuilder globalConfigurationBuilderForSite(String siteName) {\n+      return super.globalConfigurationBuilderForSite(siteName);\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<AsyncBackupExpirationTest> tests = new LinkedList<>();\n+      for (ConfigMode lon : ConfigMode.values()) {\n+         for (ConfigMode nyc : ConfigMode.values()) {\n+            tests.add(new AsyncBackupExpirationTest().setLonConfigMode(lon).setNycConfigMode(nyc));\n+         }\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"LON\", \"NYC\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{lonConfigMode, nycConfigMode};\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getNycActiveConfig() {\n+      return getConfig(nycConfigMode);\n+   }\n+\n+   @BeforeMethod\n+   public void ensureSitesOnline() {\n+      // Now we take the backup offline - which should refresh our access times\n+      XSiteAdminOperations adminOperations = extractComponent(cache(LON, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(NYC))) {\n+         adminOperations.bringSiteOnline(NYC);\n+      }\n+\n+      adminOperations = extractComponent(cache(NYC, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(LON))) {\n+         adminOperations.bringSiteOnline(LON);\n+      }\n+   }\n+\n+   public AsyncBackupExpirationTest() {\n+      super.lonBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.nycBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.implicitBackupCache = true;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getLonActiveConfig() {\n+      return getConfig(lonConfigMode);\n+   }\n+\n+   private AsyncBackupExpirationTest setLonConfigMode(ConfigMode configMode) {\n+      this.lonConfigMode = configMode;\n+      return this;\n+   }\n+\n+   private AsyncBackupExpirationTest setNycConfigMode(ConfigMode configMode) {\n+      this.nycConfigMode = configMode;\n+      return this;\n+   }\n+\n+   @DataProvider(name = \"two boolean cross product\")\n+   public Object[][] tx() {\n+      return new Object[][]{\n+            {false, false},\n+            {false, true},\n+            {true, false},\n+            {true, true}\n+      };\n+   }\n+\n+   private ControlledTimeService replaceTimeService() {\n+      ControlledTimeService timeService = new ControlledTimeService();\n+      // Max idle requires all caches to show it as expired to be removed.\n+      for (Cache<?, ?> c : caches(LON)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      for (Cache<?, ?> c : caches(NYC)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      return timeService;\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testExpiredAccess(boolean lifespan, boolean readOnPrimary) throws InterruptedException {\n+      Cache<MagicKey, String> cache = cache(LON, 0);\n+\n+      ControlledTimeService timeService = replaceTimeService();\n+\n+      MagicKey key = readOnPrimary ? new MagicKey(cache) : new MagicKey(cache(LON, 1));\n+      if (lifespan) {\n+         cache.put(key, \"v\", 1, TimeUnit.SECONDS);\n+      } else {\n+         cache.put(key, \"v\", -1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS);\n+      }\n+      eventuallyEquals(\"v\", () -> cache(LON, 0).get(key));\n+      eventuallyEquals(\"v\", () -> cache(LON, 1).get(key));\n+      Cache<Object, Object> backupCache = backup(LON);\n+      assertNull(backupCache.get(\"k\"));\n+      eventuallyEquals(\"v\", () -> backup(LON).get(key));\n+\n+      // Now expire the entry\n+      timeService.advance(TimeUnit.SECONDS.toMillis(2));\n+      assertNull(cache.get(key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNzQ4Ng==", "bodyText": "InterruptedExceptionnever thrown", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496227486", "createdAt": "2020-09-28T20:56:43Z", "author": {"login": "pruivo"}, "path": "core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.infinispan.xsite;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.distribution.MagicKey;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * @author William Burns\n+ * @since 12.0\n+ */\n+@Test(groups = \"xsite\", testName = \"xsite.AsyncBackupExpirationTest\")\n+public class AsyncBackupExpirationTest extends AbstractTwoSitesTest {\n+\n+   private ConfigMode lonConfigMode;\n+   private ConfigMode nycConfigMode;\n+\n+   private static ConfigurationBuilder getConfig(ConfigMode configMode) {\n+      if (configMode == ConfigMode.NON_TX) {\n+         return getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      }\n+      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, true);\n+      switch (configMode) {\n+         case OPTIMISTIC_TX_RC:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.READ_COMMITTED);\n+            break;\n+         case OPTIMISTIC_TX_RR:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);\n+            break;\n+         case PESSIMISTIC_TX:\n+            builder.transaction().lockingMode(LockingMode.PESSIMISTIC);\n+            break;\n+      }\n+      builder.expiration().wakeUpInterval(-1);\n+      return builder;\n+   }\n+\n+   @Override\n+   protected GlobalConfigurationBuilder globalConfigurationBuilderForSite(String siteName) {\n+      return super.globalConfigurationBuilderForSite(siteName);\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<AsyncBackupExpirationTest> tests = new LinkedList<>();\n+      for (ConfigMode lon : ConfigMode.values()) {\n+         for (ConfigMode nyc : ConfigMode.values()) {\n+            tests.add(new AsyncBackupExpirationTest().setLonConfigMode(lon).setNycConfigMode(nyc));\n+         }\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"LON\", \"NYC\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{lonConfigMode, nycConfigMode};\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getNycActiveConfig() {\n+      return getConfig(nycConfigMode);\n+   }\n+\n+   @BeforeMethod\n+   public void ensureSitesOnline() {\n+      // Now we take the backup offline - which should refresh our access times\n+      XSiteAdminOperations adminOperations = extractComponent(cache(LON, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(NYC))) {\n+         adminOperations.bringSiteOnline(NYC);\n+      }\n+\n+      adminOperations = extractComponent(cache(NYC, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(LON))) {\n+         adminOperations.bringSiteOnline(LON);\n+      }\n+   }\n+\n+   public AsyncBackupExpirationTest() {\n+      super.lonBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.nycBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.implicitBackupCache = true;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getLonActiveConfig() {\n+      return getConfig(lonConfigMode);\n+   }\n+\n+   private AsyncBackupExpirationTest setLonConfigMode(ConfigMode configMode) {\n+      this.lonConfigMode = configMode;\n+      return this;\n+   }\n+\n+   private AsyncBackupExpirationTest setNycConfigMode(ConfigMode configMode) {\n+      this.nycConfigMode = configMode;\n+      return this;\n+   }\n+\n+   @DataProvider(name = \"two boolean cross product\")\n+   public Object[][] tx() {\n+      return new Object[][]{\n+            {false, false},\n+            {false, true},\n+            {true, false},\n+            {true, true}\n+      };\n+   }\n+\n+   private ControlledTimeService replaceTimeService() {\n+      ControlledTimeService timeService = new ControlledTimeService();\n+      // Max idle requires all caches to show it as expired to be removed.\n+      for (Cache<?, ?> c : caches(LON)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      for (Cache<?, ?> c : caches(NYC)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      return timeService;\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testExpiredAccess(boolean lifespan, boolean readOnPrimary) throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNzU1Mw==", "bodyText": "InterruptedExceptionnever thrown", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496227553", "createdAt": "2020-09-28T20:56:50Z", "author": {"login": "pruivo"}, "path": "core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.infinispan.xsite;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.distribution.MagicKey;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * @author William Burns\n+ * @since 12.0\n+ */\n+@Test(groups = \"xsite\", testName = \"xsite.AsyncBackupExpirationTest\")\n+public class AsyncBackupExpirationTest extends AbstractTwoSitesTest {\n+\n+   private ConfigMode lonConfigMode;\n+   private ConfigMode nycConfigMode;\n+\n+   private static ConfigurationBuilder getConfig(ConfigMode configMode) {\n+      if (configMode == ConfigMode.NON_TX) {\n+         return getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      }\n+      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, true);\n+      switch (configMode) {\n+         case OPTIMISTIC_TX_RC:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.READ_COMMITTED);\n+            break;\n+         case OPTIMISTIC_TX_RR:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);\n+            break;\n+         case PESSIMISTIC_TX:\n+            builder.transaction().lockingMode(LockingMode.PESSIMISTIC);\n+            break;\n+      }\n+      builder.expiration().wakeUpInterval(-1);\n+      return builder;\n+   }\n+\n+   @Override\n+   protected GlobalConfigurationBuilder globalConfigurationBuilderForSite(String siteName) {\n+      return super.globalConfigurationBuilderForSite(siteName);\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<AsyncBackupExpirationTest> tests = new LinkedList<>();\n+      for (ConfigMode lon : ConfigMode.values()) {\n+         for (ConfigMode nyc : ConfigMode.values()) {\n+            tests.add(new AsyncBackupExpirationTest().setLonConfigMode(lon).setNycConfigMode(nyc));\n+         }\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"LON\", \"NYC\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{lonConfigMode, nycConfigMode};\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getNycActiveConfig() {\n+      return getConfig(nycConfigMode);\n+   }\n+\n+   @BeforeMethod\n+   public void ensureSitesOnline() {\n+      // Now we take the backup offline - which should refresh our access times\n+      XSiteAdminOperations adminOperations = extractComponent(cache(LON, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(NYC))) {\n+         adminOperations.bringSiteOnline(NYC);\n+      }\n+\n+      adminOperations = extractComponent(cache(NYC, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(LON))) {\n+         adminOperations.bringSiteOnline(LON);\n+      }\n+   }\n+\n+   public AsyncBackupExpirationTest() {\n+      super.lonBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.nycBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.implicitBackupCache = true;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getLonActiveConfig() {\n+      return getConfig(lonConfigMode);\n+   }\n+\n+   private AsyncBackupExpirationTest setLonConfigMode(ConfigMode configMode) {\n+      this.lonConfigMode = configMode;\n+      return this;\n+   }\n+\n+   private AsyncBackupExpirationTest setNycConfigMode(ConfigMode configMode) {\n+      this.nycConfigMode = configMode;\n+      return this;\n+   }\n+\n+   @DataProvider(name = \"two boolean cross product\")\n+   public Object[][] tx() {\n+      return new Object[][]{\n+            {false, false},\n+            {false, true},\n+            {true, false},\n+            {true, true}\n+      };\n+   }\n+\n+   private ControlledTimeService replaceTimeService() {\n+      ControlledTimeService timeService = new ControlledTimeService();\n+      // Max idle requires all caches to show it as expired to be removed.\n+      for (Cache<?, ?> c : caches(LON)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      for (Cache<?, ?> c : caches(NYC)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      return timeService;\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testExpiredAccess(boolean lifespan, boolean readOnPrimary) throws InterruptedException {\n+      Cache<MagicKey, String> cache = cache(LON, 0);\n+\n+      ControlledTimeService timeService = replaceTimeService();\n+\n+      MagicKey key = readOnPrimary ? new MagicKey(cache) : new MagicKey(cache(LON, 1));\n+      if (lifespan) {\n+         cache.put(key, \"v\", 1, TimeUnit.SECONDS);\n+      } else {\n+         cache.put(key, \"v\", -1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS);\n+      }\n+      eventuallyEquals(\"v\", () -> cache(LON, 0).get(key));\n+      eventuallyEquals(\"v\", () -> cache(LON, 1).get(key));\n+      Cache<Object, Object> backupCache = backup(LON);\n+      assertNull(backupCache.get(\"k\"));\n+      eventuallyEquals(\"v\", () -> backup(LON).get(key));\n+\n+      // Now expire the entry\n+      timeService.advance(TimeUnit.SECONDS.toMillis(2));\n+      assertNull(cache.get(key));\n+\n+      // TODO: check for the touch command being invoked on the remote site for lifespan = false\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testMaxIdleWithRecentAccess(boolean readFromWrittenSite, boolean readOnAccessedSite) throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzMDYwMA==", "bodyText": "actually, I would inspect the DataContainer to ensure the InternalCacheEntry's lastUsed is the expected value", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496230600", "createdAt": "2020-09-28T21:02:40Z", "author": {"login": "pruivo"}, "path": "core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.infinispan.xsite;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.distribution.MagicKey;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * @author William Burns\n+ * @since 12.0\n+ */\n+@Test(groups = \"xsite\", testName = \"xsite.AsyncBackupExpirationTest\")\n+public class AsyncBackupExpirationTest extends AbstractTwoSitesTest {\n+\n+   private ConfigMode lonConfigMode;\n+   private ConfigMode nycConfigMode;\n+\n+   private static ConfigurationBuilder getConfig(ConfigMode configMode) {\n+      if (configMode == ConfigMode.NON_TX) {\n+         return getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      }\n+      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, true);\n+      switch (configMode) {\n+         case OPTIMISTIC_TX_RC:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.READ_COMMITTED);\n+            break;\n+         case OPTIMISTIC_TX_RR:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);\n+            break;\n+         case PESSIMISTIC_TX:\n+            builder.transaction().lockingMode(LockingMode.PESSIMISTIC);\n+            break;\n+      }\n+      builder.expiration().wakeUpInterval(-1);\n+      return builder;\n+   }\n+\n+   @Override\n+   protected GlobalConfigurationBuilder globalConfigurationBuilderForSite(String siteName) {\n+      return super.globalConfigurationBuilderForSite(siteName);\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<AsyncBackupExpirationTest> tests = new LinkedList<>();\n+      for (ConfigMode lon : ConfigMode.values()) {\n+         for (ConfigMode nyc : ConfigMode.values()) {\n+            tests.add(new AsyncBackupExpirationTest().setLonConfigMode(lon).setNycConfigMode(nyc));\n+         }\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"LON\", \"NYC\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{lonConfigMode, nycConfigMode};\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getNycActiveConfig() {\n+      return getConfig(nycConfigMode);\n+   }\n+\n+   @BeforeMethod\n+   public void ensureSitesOnline() {\n+      // Now we take the backup offline - which should refresh our access times\n+      XSiteAdminOperations adminOperations = extractComponent(cache(LON, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(NYC))) {\n+         adminOperations.bringSiteOnline(NYC);\n+      }\n+\n+      adminOperations = extractComponent(cache(NYC, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(LON))) {\n+         adminOperations.bringSiteOnline(LON);\n+      }\n+   }\n+\n+   public AsyncBackupExpirationTest() {\n+      super.lonBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.nycBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.implicitBackupCache = true;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getLonActiveConfig() {\n+      return getConfig(lonConfigMode);\n+   }\n+\n+   private AsyncBackupExpirationTest setLonConfigMode(ConfigMode configMode) {\n+      this.lonConfigMode = configMode;\n+      return this;\n+   }\n+\n+   private AsyncBackupExpirationTest setNycConfigMode(ConfigMode configMode) {\n+      this.nycConfigMode = configMode;\n+      return this;\n+   }\n+\n+   @DataProvider(name = \"two boolean cross product\")\n+   public Object[][] tx() {\n+      return new Object[][]{\n+            {false, false},\n+            {false, true},\n+            {true, false},\n+            {true, true}\n+      };\n+   }\n+\n+   private ControlledTimeService replaceTimeService() {\n+      ControlledTimeService timeService = new ControlledTimeService();\n+      // Max idle requires all caches to show it as expired to be removed.\n+      for (Cache<?, ?> c : caches(LON)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      for (Cache<?, ?> c : caches(NYC)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      return timeService;\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testExpiredAccess(boolean lifespan, boolean readOnPrimary) throws InterruptedException {\n+      Cache<MagicKey, String> cache = cache(LON, 0);\n+\n+      ControlledTimeService timeService = replaceTimeService();\n+\n+      MagicKey key = readOnPrimary ? new MagicKey(cache) : new MagicKey(cache(LON, 1));\n+      if (lifespan) {\n+         cache.put(key, \"v\", 1, TimeUnit.SECONDS);\n+      } else {\n+         cache.put(key, \"v\", -1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS);\n+      }\n+      eventuallyEquals(\"v\", () -> cache(LON, 0).get(key));\n+      eventuallyEquals(\"v\", () -> cache(LON, 1).get(key));\n+      Cache<Object, Object> backupCache = backup(LON);\n+      assertNull(backupCache.get(\"k\"));\n+      eventuallyEquals(\"v\", () -> backup(LON).get(key));\n+\n+      // Now expire the entry\n+      timeService.advance(TimeUnit.SECONDS.toMillis(2));\n+      assertNull(cache.get(key));\n+\n+      // TODO: check for the touch command being invoked on the remote site for lifespan = false", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzMjk2MQ==", "bodyText": "what does sync/async mean here? the xsite is async only in this class.", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496232961", "createdAt": "2020-09-28T21:07:15Z", "author": {"login": "pruivo"}, "path": "core/src/test/java/org/infinispan/xsite/irac/Irac3SitesConflictTest.java", "diffHunk": "@@ -30,32 +37,159 @@\n    private static final int CLUSTER_SIZE = 3;\n    private final List<ManualIracManager> iracManagerList;\n \n+   private ConfigMode configMode;\n+\n+   public Irac3SitesConflictTest configMode(ConfigMode configMode) {\n+      this.configMode = configMode;\n+      return this;\n+   }\n+\n+   private enum ConfigMode {\n+      NON_TX,\n+      PESSIMISTIC_TX,\n+      OPTIMISTIC_TX_RC,\n+      OPTIMISTIC_TX_RR,\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<Irac3SitesConflictTest> tests = new ArrayList<>();\n+      for (ConfigMode configMode : ConfigMode.values()) {\n+         tests.add(new Irac3SitesConflictTest().configMode(configMode));\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"configMode\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{configMode};\n+   }\n+\n    protected Irac3SitesConflictTest() {\n       this.iracManagerList = new ArrayList<>(N_SITES * CLUSTER_SIZE);\n    }\n \n    public void testPutIfAbsent(Method method) {\n-      doTest(method, TestOperation.PUT_IF_ABSENT);\n+      doTest(method, new TestOperationInterop(TestOperation.PUT_IF_ABSENT));\n    }\n \n    public void testPut(Method method) {\n-      doTest(method, TestOperation.PUT);\n+      doTest(method, new TestOperationInterop(TestOperation.PUT));\n    }\n \n    public void testReplace(Method method) {\n-      doTest(method, TestOperation.REPLACE);\n+      doTest(method, new TestOperationInterop(TestOperation.REPLACE));\n    }\n \n    public void testConditionalReplace(Method method) {\n-      doTest(method, TestOperation.REPLACE_CONDITIONAL);\n+      doTest(method, new TestOperationInterop(TestOperation.REPLACE_CONDITIONAL));\n    }\n \n    public void testRemove(Method method) {\n-      doTest(method, TestOperation.REMOVE);\n+      doTest(method, new TestOperationInterop(TestOperation.REMOVE));\n    }\n \n    public void testConditionalRemove(Method method) {\n-      doTest(method, TestOperation.REMOVE_CONDITIONAL);\n+      doTest(method, new TestOperationInterop(TestOperation.REMOVE_CONDITIONAL));\n+   }\n+\n+   // TODO: need to do this still?\n+   //   public void testMaxIdleExpirationASync(Method method) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "405a8b2b22032e146866a8f8dca8515df4882200"}, "originalPosition": 98}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2f2a9b729608c31b865c2e5c279bfdab32d4e812", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/2f2a9b729608c31b865c2e5c279bfdab32d4e812", "committedDate": "2020-09-29T15:46:45Z", "message": "rework comments"}, "afterCommit": {"oid": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "committedDate": "2020-09-29T15:51:32Z", "message": "rework comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4NzIwMTM5", "url": "https://github.com/infinispan/infinispan/pull/8699#pullrequestreview-498720139", "createdAt": "2020-09-29T17:29:02Z", "commit": {"oid": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzoyOTowMlrOHZ5TUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzo0Mzo0M1rOHZ52hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxNTI4MA==", "bodyText": "can be removed. it is available in super class", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496915280", "createdAt": "2020-09-29T17:29:02Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -70,21 +63,16 @@\n     */\n    private static final int MAX_CONCURRENT_EXPIRATIONS = 100;\n \n-   @Inject protected ComponentRef<AdvancedCache<K, V>> cacheRef;\n    @Inject protected RpcManager rpcManager;\n    @Inject protected DistributionManager distributionManager;\n \n-   protected AdvancedCache<K, V> cache;\n    private Address localAddress;\n    private long timeout;\n    private String cacheName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMjcxNA==", "bodyText": "why do you need to wait for the remote operation? can't you return touchedLocally directly?", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496922714", "createdAt": "2020-09-29T17:41:11Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/interceptors/impl/ClusteringInterceptor.java", "diffHunk": "@@ -34,6 +48,120 @@\n    @Inject protected InternalDataContainer dataContainer;\n    @Inject protected DistributionManager distributionManager;\n \n+   protected LocalizedCacheTopology checkTopologyId(TopologyAffectedCommand command) {\n+      LocalizedCacheTopology cacheTopology = distributionManager.getCacheTopology();\n+      int currentTopologyId = cacheTopology.getTopologyId();\n+      int cmdTopology = command.getTopologyId();\n+      if (command instanceof FlagAffectedCommand && ((((FlagAffectedCommand) command).hasAnyFlag(FlagBitSets.SKIP_OWNERSHIP_CHECK | FlagBitSets.CACHE_MODE_LOCAL)))) {\n+         getLog().tracef(\"Skipping topology check for command %s\", command);\n+         return cacheTopology;\n+      }\n+      if (trace) {\n+         getLog().tracef(\"Current topology %d, command topology %d\", currentTopologyId, cmdTopology);\n+      }\n+      if (cmdTopology >= 0 && currentTopologyId != cmdTopology) {\n+         throw OutdatedTopologyException.RETRY_NEXT_TOPOLOGY;\n+      }\n+      return cacheTopology;\n+   }\n+\n+   private static abstract class AbstractTouchResponseCollector extends ValidResponseCollector<Boolean> {\n+      @Override\n+      protected Boolean addTargetNotFound(Address sender) {\n+         throw OutdatedTopologyException.RETRY_NEXT_TOPOLOGY;\n+      }\n+\n+      @Override\n+      protected Boolean addException(Address sender, Exception exception) {\n+         if (exception instanceof CacheException) {\n+            throw (CacheException) exception;\n+         }\n+         throw new CacheException(exception);\n+      }\n+\n+      @Override\n+      protected final Boolean addValidResponse(Address sender, ValidResponse response) {\n+         return (Boolean) response.getResponseValue();\n+      }\n+\n+      abstract Boolean addBooleanResponse(Address sender, Boolean response);\n+   }\n+\n+   private static class ScatteredTouchResponseCollector extends AbstractTouchResponseCollector {\n+\n+      private static final ScatteredTouchResponseCollector INSTANCE = new ScatteredTouchResponseCollector();\n+\n+      @Override\n+      public Boolean finish() {\n+         // No other node was touched\n+         return Boolean.FALSE;\n+      }\n+\n+      @Override\n+      protected Boolean addBooleanResponse(Address sender, Boolean response) {\n+         if (response == Boolean.TRUE) {\n+            // Return early if any node touched the value - as SCATTERED only exists on a single backup!\n+            // TODO: what if the read was when one of the backups or primary died?\n+            return Boolean.TRUE;\n+         }\n+         return null;\n+      }\n+   }\n+\n+   private static class TouchResponseCollector extends AbstractTouchResponseCollector {\n+\n+      private static final TouchResponseCollector INSTANCE = new TouchResponseCollector();\n+\n+      @Override\n+      public Boolean finish() {\n+         // If all were touched, then the value isn't expired\n+         return Boolean.TRUE;\n+      }\n+\n+      @Override\n+      protected Boolean addBooleanResponse(Address sender, Boolean response) {\n+         if (response == Boolean.FALSE) {\n+            // Return early if any value wasn't touched!\n+            return Boolean.FALSE;\n+         }\n+         return null;\n+      }\n+   }\n+\n+   @Override\n+   public Object visitTouchCommand(InvocationContext ctx, TouchCommand command) throws Throwable {\n+      if (isLocalModeForced(command)) {\n+         return invokeNext(ctx, command);\n+      }\n+      LocalizedCacheTopology cacheTopology = checkTopologyId(command);\n+      DistributionInfo info = cacheTopology.getSegmentDistribution(command.getSegment());\n+\n+      if (info.isPrimary()) {\n+         boolean isScattered = cacheConfiguration.clustering().cacheMode().isScattered();\n+         // Scattered any node could be a backup, so we have to touch all members\n+         List<Address> owners = isScattered ? cacheTopology.getActualMembers() : info.readOwners();\n+         AbstractTouchResponseCollector collector = isScattered ? ScatteredTouchResponseCollector.INSTANCE :\n+               TouchResponseCollector.INSTANCE;\n+         CompletionStage<Boolean> remoteInvocation = rpcManager.invokeCommand(owners, command, collector,\n+               rpcManager.getSyncRpcOptions());\n+         return invokeNextThenApply(ctx, command, (rCtx, rCommand, rValue) -> {\n+            Boolean touchedLocally = (Boolean) rValue;\n+            Boolean collectedResponse = collector.addBooleanResponse(null, touchedLocally);\n+            if (collectedResponse != null) {\n+               return asyncValue(remoteInvocation.thenApply(ignore -> touchedLocally));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNDI5Mw==", "bodyText": "I'm going to take some time to think about this... not 100% convinced eh eh\nalso, you could check iracVersionGenerator.getTombstone(key); before invoking the \"generate\" method", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496924293", "createdAt": "2020-09-29T17:43:43Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/interceptors/impl/NonTxIracLocalSiteInterceptor.java", "diffHunk": "@@ -189,12 +186,26 @@ private boolean skipCommand(InvocationContext ctx, FlagAffectedCommand command)\n     * <p>\n     * The primary owner generates a new {@link IracMetadata} and stores it in the {@link WriteCommand}.\n     */\n-   private void visitKey(Object key, WriteCommand command) {\n+   private void visitKey(InvocationContext ctx, Object key, WriteCommand command) {\n       int segment = getSegment(command, key);\n       if (getOwnership(segment) != Ownership.PRIMARY) {\n          return;\n       }\n-      IracMetadata metadata = iracVersionGenerator.generateNewMetadata(segment);\n+      IracMetadata metadata = null;\n+      // RemoveExpired should lose to any other conflicting write\n+      if (command instanceof RemoveExpiredCommand) {\n+         CacheEntry<?, ?> ce = ctx.lookupEntry(key);\n+         PrivateMetadata pm = ce.getInternalMetadata();\n+         if (pm != null) {\n+            metadata = pm.iracMetadata();\n+         }\n+\n+         if (metadata == null) {\n+            metadata = iracVersionGenerator.generateMetadataWithCurrentVersion(segment);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4"}, "originalPosition": 65}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "committedDate": "2020-09-29T15:51:32Z", "message": "rework comments"}, "afterCommit": {"oid": "294f4f142999a94e8e025ae1b1aea1c89452f429", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/294f4f142999a94e8e025ae1b1aea1c89452f429", "committedDate": "2020-10-01T17:17:46Z", "message": "second review comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "294f4f142999a94e8e025ae1b1aea1c89452f429", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/294f4f142999a94e8e025ae1b1aea1c89452f429", "committedDate": "2020-10-01T17:17:46Z", "message": "second review comments"}, "afterCommit": {"oid": "09e7d55e2cff05fc6c30bab0155fa0f046aabd14", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/09e7d55e2cff05fc6c30bab0155fa0f046aabd14", "committedDate": "2020-10-01T17:19:07Z", "message": "second review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMDU3MzY1", "url": "https://github.com/infinispan/infinispan/pull/8699#pullrequestreview-501057365", "createdAt": "2020-10-02T11:30:05Z", "commit": {"oid": "09e7d55e2cff05fc6c30bab0155fa0f046aabd14"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMTozMDowNVrOHbqQLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMTozMDowNVrOHbqQLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc2NTg3MQ==", "bodyText": "shouldn't touchEvenIfExpired be  false here?", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r498765871", "createdAt": "2020-10-02T11:30:05Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -269,11 +261,11 @@ private void deleteFromStoresAndNotify(K key, V value, Metadata metadata, Privat\n     * or not, that is if it couldn't be touched - we assumed expired (as it was removed in some way).\n     * @param entry the entry to check expiration and touch\n     * @param segment the segment the entry maps to\n+    * @param currentTime the current time in milliseconds\n     * @return whether the entry was expired or not\n     */\n-   protected CompletionStage<Boolean> checkExpiredMaxIdle(InternalCacheEntry entry, int segment) {\n-      TouchCommand touchCommand = cf.running().buildTouchCommand(entry.getKey(), segment);\n-      CompletionStage<Boolean> future = (CompletionStage) touchCommand.invokeAsync(componentRegistry);\n+   protected CompletionStage<Boolean> checkExpiredMaxIdle(InternalCacheEntry entry, int segment, long currentTime) {\n+      CompletionStage<Boolean> future = cache.touch(entry.getKey(), segment, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09e7d55e2cff05fc6c30bab0155fa0f046aabd14"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMDU3NDUy", "url": "https://github.com/infinispan/infinispan/pull/8699#pullrequestreview-501057452", "createdAt": "2020-10-02T11:30:12Z", "commit": {"oid": "09e7d55e2cff05fc6c30bab0155fa0f046aabd14"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMDk4OTAx", "url": "https://github.com/infinispan/infinispan/pull/8699#pullrequestreview-501098901", "createdAt": "2020-10-02T12:41:05Z", "commit": {"oid": "09e7d55e2cff05fc6c30bab0155fa0f046aabd14"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMjo0MTowNVrOHbsFsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMjo0MTowNVrOHbsFsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc5NTk1Mg==", "bodyText": "Actually, the comments are wrong (same comments, in all tests) :) my bad!\nNot sure you notice, but there is a test missing:\npruivo@1cdac79#diff-5932593a9461e5deec52370525a2cf35R144", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r498795952", "createdAt": "2020-10-02T12:41:05Z", "author": {"login": "pruivo"}, "path": "core/src/test/java/org/infinispan/expiration/impl/MaxIdlePessimisticTxTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.infinispan.expiration.impl;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.infinispan.test.TestingUtil.k;\n+import static org.infinispan.test.TestingUtil.replaceComponent;\n+import static org.infinispan.test.TestingUtil.v;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertFalse;\n+import static org.testng.AssertJUnit.assertNull;\n+import static org.testng.AssertJUnit.assertTrue;\n+import static org.testng.AssertJUnit.fail;\n+\n+import java.lang.reflect.Method;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.container.impl.InternalDataContainer;\n+import org.infinispan.context.Flag;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.interceptors.locking.ClusteringDependentLogic;\n+import org.infinispan.test.MultipleCacheManagersTest;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Test to verify clustered max idle in a pessimistic transaction\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+@Test(groups = \"functional\", testName = \"expiration.impl.MaxIdlePessimisticTxTest\")\n+public class MaxIdlePessimisticTxTest extends MultipleCacheManagersTest {\n+\n+   private static final int NUM_NODES = 3;\n+   private static final long MAX_IDLE = 10;\n+   private final ControlledTimeService timeService = new ControlledTimeService();\n+\n+   public void testWriteLock(Method method) throws Exception {\n+      final String key = k(method);\n+      final String value = v(method, 0);\n+      final String value2 = v(method, 1);\n+\n+\n+      Cache<String, String> cache = findNonOwnerCache(key);\n+      cache.put(key, value, -1, TimeUnit.SECONDS, MAX_IDLE, TimeUnit.MILLISECONDS);\n+\n+      long lastWallClock = timeService.wallClockTime();\n+      timeService.advance(MAX_IDLE - 1);\n+\n+      assertNotExpired(key);\n+      assertLastUsed(key, lastWallClock);\n+\n+      cache.getAdvancedCache().getTransactionManager().begin();\n+      assertEquals(value, cache.put(key, value2, -1, TimeUnit.SECONDS, MAX_IDLE, TimeUnit.MILLISECONDS));\n+      assertEquals(value2, cache.get(key));\n+      // rollback the transaction\n+      cache.getAdvancedCache().getTransactionManager().rollback();\n+\n+      lastWallClock = timeService.wallClockTime();\n+      assertNotExpired(key);\n+      assertLastUsed(key, lastWallClock);\n+\n+      // if the tx didn't touch the key, this advance should expire it", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09e7d55e2cff05fc6c30bab0155fa0f046aabd14"}, "originalPosition": 70}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "09e7d55e2cff05fc6c30bab0155fa0f046aabd14", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/09e7d55e2cff05fc6c30bab0155fa0f046aabd14", "committedDate": "2020-10-01T17:19:07Z", "message": "second review comments"}, "afterCommit": {"oid": "e6ea97a47274016c08f1a5e9c83f184ba02a5638", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/e6ea97a47274016c08f1a5e9c83f184ba02a5638", "committedDate": "2020-10-02T14:55:50Z", "message": "fixing hibernate test failures - touch now can delay completion on same thread"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e6ea97a47274016c08f1a5e9c83f184ba02a5638", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/e6ea97a47274016c08f1a5e9c83f184ba02a5638", "committedDate": "2020-10-02T14:55:50Z", "message": "fixing hibernate test failures - touch now can delay completion on same thread"}, "afterCommit": {"oid": "3690b0019376055e1eb1fa8fbe762f1d70f791be", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/3690b0019376055e1eb1fa8fbe762f1d70f791be", "committedDate": "2020-10-02T14:56:30Z", "message": "Comment tweak, add in missing test and fix hibernate tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAxMjM3MzIy", "url": "https://github.com/infinispan/infinispan/pull/8699#pullrequestreview-501237322", "createdAt": "2020-10-02T15:30:51Z", "commit": {"oid": "3690b0019376055e1eb1fa8fbe762f1d70f791be"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f23a1c66f11c1b07bb9f283c358f17b4695c955", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/7f23a1c66f11c1b07bb9f283c358f17b4695c955", "committedDate": "2020-10-05T15:53:50Z", "message": "ISPN-11176 XSite Max Idle\n\n* Implements check other site upon max idle expiration found\n* Refreshes all entry access times upon site loss"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6622335944dee7cc64b17febdf1515c5648434f", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/b6622335944dee7cc64b17febdf1515c5648434f", "committedDate": "2020-10-05T15:53:50Z", "message": "ISPN-12337 Clustered Expiration can deadlock with Pessimistic Tx on a non owner"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e8119e800120347114017874f58eecaa2fc69fa", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/9e8119e800120347114017874f58eecaa2fc69fa", "committedDate": "2020-10-05T17:11:22Z", "message": "ISPN-11176 XSite Max Idle\n\n* Refactor touch to be a visitable command\n* Add Touch logic to interceptors"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3690b0019376055e1eb1fa8fbe762f1d70f791be", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/3690b0019376055e1eb1fa8fbe762f1d70f791be", "committedDate": "2020-10-02T14:56:30Z", "message": "Comment tweak, add in missing test and fix hibernate tests"}, "afterCommit": {"oid": "9e8119e800120347114017874f58eecaa2fc69fa", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/9e8119e800120347114017874f58eecaa2fc69fa", "committedDate": "2020-10-05T17:11:22Z", "message": "ISPN-11176 XSite Max Idle\n\n* Refactor touch to be a visitable command\n* Add Touch logic to interceptors"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 478, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}