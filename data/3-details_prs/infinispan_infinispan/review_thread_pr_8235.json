{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3OTY3MTM2", "number": 8235, "reviewThreads": {"totalCount": 47, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxODozMjo0N1rOD1asig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODowMjozNVrOD3UQ9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3MzM4NTA2OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxODozMjo0N1rOGK2YKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxODozMjo0N1rOGK2YKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDAyOTg2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (commons.length != 1) {\n          \n          \n            \n                  if (commons == null || commons.length != 1) {\n          \n      \n    \n    \n  \n\ncommons can be null if you set the wrong path it can't find the commons.", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r414029865", "createdAt": "2020-04-23T18:32:47Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,470 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Properties targetProperties = getVersionProperties(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetProperties, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Properties targetProperties = getVersionProperties(target);\n+      String version = targetProperties.getProperty(\"infinispan.version\");\n+      String brandName = targetProperties.getProperty(\"infinispan.brand.name\");\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Properties targetProperties, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Properties sourceProperties = getVersionProperties(source);\n+\n+      // Ensure that the brand name coincides\n+      if (!sourceProperties.getProperty(\"infinispan.brand.name\").equals(targetProperties.getProperty(\"infinispan.brand.name\"))) {\n+         throw MSG.patchIncompatibleProduct(sourceProperties.getProperty(\"infinispan.brand.name\"), targetProperties.getProperty(\"infinispan.brand.name\"));\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceProperties.getProperty(\"infinispan.brand.name\"), sourceProperties.getProperty(\"infinispan.version\"), targetProperties.getProperty(\"infinispan.version\"), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else { // Check contents\n+               try {\n+                  if (!compareFileContents(source.resolve(v1File.getVersionedPath()), target.resolve(targetFile.getVersionedPath()))) {\n+                     operations.add(PatchOperation.replace(targetFile.isSoft(), targetFile.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getDigest(), targetFile.getPermissions()));\n+                     addFileToZip(zipfs, target, targetFile);\n+                  }\n+               } catch (IOException e) {\n+                  throw new RuntimeException(e);\n+               }\n+            }\n+         }\n+      });\n+      targetFiles.forEach((k2, targetFile) -> {\n+         if (!v1Files.containsKey(k2)) {\n+            operations.add(PatchOperation.add(targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+            addFileToZip(zipfs, target, targetFile);\n+         }\n+      });\n+\n+      // Write out the JSON patch file\n+      Path patchPath = zipfs.getPath(\"patch-\" + patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion() + \".json\");\n+      try (OutputStream os = Files.newOutputStream(patchPath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writerWithDefaultPrettyPrinter().writeValue(os, patchInfo);\n+      }\n+   }\n+\n+   private Map<Path, ServerFile> getServerFiles(Path base) throws IOException {\n+      Pattern IGNORE = Pattern.compile(\"^(\\\\.patches/|server/data/|server/log/|server/lib/).*$\");\n+      Pattern SOFT_REPLACE_PATTERN = Pattern.compile(\"^server/conf/.*$\");\n+      Map<Path, ServerFile> files = new TreeMap<>();\n+      Files.walkFileTree(base, new SimpleFileVisitor<Path>() {\n+         @Override\n+         public FileVisitResult visitFile(Path oPath, BasicFileAttributes attrs) {\n+            Path rPath = base.relativize(oPath);\n+            String rPathName = rPath.toString();\n+            if (!IGNORE.matcher(rPathName).matches()) {\n+               ServerFile file = new ServerFile(rPath, sha256(oPath), getPermissions(oPath), SOFT_REPLACE_PATTERN.matcher(rPathName).matches());\n+               files.put(file.getUnversionedPath(), file);\n+            }\n+            return FileVisitResult.CONTINUE;\n+         }\n+      });\n+      return files;\n+   }\n+\n+   private static String getPermissions(Path path) {\n+      try {\n+         return PosixFilePermissions.toString(Files.getPosixFilePermissions(path));\n+      } catch (IOException e) {\n+         throw new RuntimeException(e);\n+      }\n+   }\n+\n+   private List<PatchInfo> getPatchInfos(FileSystem zipfs) throws IOException {\n+      List<Path> paths = Files.find(zipfs.getPath(\"/\"), 1,\n+            (p, a) -> a.isRegularFile() && p.getFileName().toString().startsWith(\"patch-\") && p.getFileName().toString().endsWith(\".json\")\n+      ).collect(Collectors.toList());\n+      List<PatchInfo> infos = new ArrayList<>(paths.size());\n+      for (Path path : paths) {\n+         try (InputStream is = Files.newInputStream(path, StandardOpenOption.READ)) {\n+            infos.add(mapper.readValue(is, PatchInfo.class));\n+         }\n+      }\n+      return infos;\n+   }\n+\n+   private Properties getVersionProperties(Path base) throws IOException {\n+      // Load the META-INF/infinispan-version.properties from the lib/infinispan-commons jar\n+      Path lib = base.resolve(\"lib\");\n+      File[] commons = lib.toFile().listFiles((dir, name) -> name.startsWith(\"infinispan-commons-\") && name.endsWith(\".jar\"));\n+      if (commons.length != 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c605dc4b2fd321263528e2a4caf437ab822dc233"}, "originalPosition": 393}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjA1Njc0OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/CliCommand.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMToxNDo1M1rOGMdzNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMTo1NDowMlrOGMfPhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNDM0MA==", "bodyText": "why this change?", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415724340", "createdAt": "2020-04-27T11:14:53Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/CliCommand.java", "diffHunk": "@@ -28,7 +28,7 @@\n    public CommandResult execute(ContextAwareCommandInvocation invocation) throws CommandException {\n       if (help) {\n          invocation.println(invocation.getHelpInfo());\n-         return CommandResult.SUCCESS;\n+         return CommandResult.FAILURE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc0Nzk3NA==", "bodyText": "My mistake. I thought Unix commands returned failures when invoked with the help switch. Instead they all return 0, so I'll revert this.", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415747974", "createdAt": "2020-04-27T11:54:02Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/CliCommand.java", "diffHunk": "@@ -28,7 +28,7 @@\n    public CommandResult execute(ContextAwareCommandInvocation invocation) throws CommandException {\n       if (help) {\n          invocation.println(invocation.getHelpInfo());\n-         return CommandResult.SUCCESS;\n+         return CommandResult.FAILURE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNDM0MA=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjA1ODkzOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Patch.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMToxNTozMFrOGMd0iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzoyNzoxOFrOGMjHqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNDY4Mw==", "bodyText": "print help message?", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415724683", "createdAt": "2020-04-27T11:15:30Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Patch.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.infinispan.cli.commands;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.impl.completer.FileOptionCompleter;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Arguments;\n+import org.aesh.command.option.Option;\n+import org.aesh.io.Resource;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.patching.PatchTool;\n+import org.kohsuke.MetaInfServices;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = Patch.CMD, description = \"Patch operations\", groupCommands = {Patch.Create.class, Patch.Describe.class, Patch.Install.class, Patch.Ls.class, Patch.Rollback.class})\n+public class Patch extends CliCommand {\n+\n+   public static final String CMD = \"patch\";\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation commandInvocation) {\n+      // This command serves only to wrap the sub-commands", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1MDg4OA==", "bodyText": "Only if you call it with -h", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415750888", "createdAt": "2020-04-27T11:58:37Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Patch.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.infinispan.cli.commands;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.impl.completer.FileOptionCompleter;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Arguments;\n+import org.aesh.command.option.Option;\n+import org.aesh.io.Resource;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.patching.PatchTool;\n+import org.kohsuke.MetaInfServices;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = Patch.CMD, description = \"Patch operations\", groupCommands = {Patch.Create.class, Patch.Describe.class, Patch.Install.class, Patch.Ls.class, Patch.Rollback.class})\n+public class Patch extends CliCommand {\n+\n+   public static final String CMD = \"patch\";\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation commandInvocation) {\n+      // This command serves only to wrap the sub-commands", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNDY4Mw=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgxMTQ5OQ==", "bodyText": "Actually, I'll do that", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415811499", "createdAt": "2020-04-27T13:27:18Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Patch.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.infinispan.cli.commands;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.impl.completer.FileOptionCompleter;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Arguments;\n+import org.aesh.command.option.Option;\n+import org.aesh.io.Resource;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.patching.PatchTool;\n+import org.kohsuke.MetaInfServices;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = Patch.CMD, description = \"Patch operations\", groupCommands = {Patch.Create.class, Patch.Describe.class, Patch.Install.class, Patch.Ls.class, Patch.Rollback.class})\n+public class Patch extends CliCommand {\n+\n+   public static final String CMD = \"patch\";\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation commandInvocation) {\n+      // This command serves only to wrap the sub-commands", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNDY4Mw=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjA3MTQzOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Patch.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMToxODozNlrOGMd7ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNToxMzowNlrOGMofIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNjQ5NA==", "bodyText": "exception handling is missing in all subcommands", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415726494", "createdAt": "2020-04-27T11:18:36Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Patch.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.infinispan.cli.commands;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.impl.completer.FileOptionCompleter;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Arguments;\n+import org.aesh.command.option.Option;\n+import org.aesh.io.Resource;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.patching.PatchTool;\n+import org.kohsuke.MetaInfServices;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = Patch.CMD, description = \"Patch operations\", groupCommands = {Patch.Create.class, Patch.Describe.class, Patch.Install.class, Patch.Ls.class, Patch.Rollback.class})\n+public class Patch extends CliCommand {\n+\n+   public static final String CMD = \"patch\";\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation commandInvocation) {\n+      // This command serves only to wrap the sub-commands\n+      return CommandResult.FAILURE;\n+   }\n+\n+   @CommandDefinition(name = Create.CMD, description = \"Creates a patch archive\")\n+   public static class Create extends CliCommand {\n+      public static final String CMD = \"create\";\n+\n+      @Option(defaultValue = \"\", shortName = 'q', description = \"A qualifier for this patch (e.g. `one-off`)\")\n+      String qualifier;\n+\n+      @Arguments(completer = FileOptionCompleter.class, description = \"The path to the patch archive, the path to the target server and one or more paths to the source servers\")\n+      List<Resource> paths;\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+         if (paths.size() < 3) {\n+            throw Messages.MSG.patchCreateArgumentsRequired();\n+         }\n+         PatchTool patchTool = new PatchTool(invocation.getShellOutput(), invocation.getShellError());\n+         try {\n+            Path patch = Paths.get(paths.get(0).getAbsolutePath());\n+            Path target = Paths.get(paths.get(1).getAbsolutePath());\n+            Path sources[] = new Path[paths.size() - 2];\n+            for (int i = 2; i < paths.size(); i++) {\n+               sources[i - 2] = Paths.get(paths.get(i).getAbsolutePath());\n+            }\n+            patchTool.createPatch(qualifier, patch, target, sources);\n+            return CommandResult.SUCCESS;\n+         } catch (IOException e) {\n+            throw new RuntimeException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg5OTQyNA==", "bodyText": "Fixed", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415899424", "createdAt": "2020-04-27T15:13:06Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Patch.java", "diffHunk": "@@ -0,0 +1,177 @@\n+package org.infinispan.cli.commands;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.impl.completer.FileOptionCompleter;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Arguments;\n+import org.aesh.command.option.Option;\n+import org.aesh.io.Resource;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.patching.PatchTool;\n+import org.kohsuke.MetaInfServices;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = Patch.CMD, description = \"Patch operations\", groupCommands = {Patch.Create.class, Patch.Describe.class, Patch.Install.class, Patch.Ls.class, Patch.Rollback.class})\n+public class Patch extends CliCommand {\n+\n+   public static final String CMD = \"patch\";\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation commandInvocation) {\n+      // This command serves only to wrap the sub-commands\n+      return CommandResult.FAILURE;\n+   }\n+\n+   @CommandDefinition(name = Create.CMD, description = \"Creates a patch archive\")\n+   public static class Create extends CliCommand {\n+      public static final String CMD = \"create\";\n+\n+      @Option(defaultValue = \"\", shortName = 'q', description = \"A qualifier for this patch (e.g. `one-off`)\")\n+      String qualifier;\n+\n+      @Arguments(completer = FileOptionCompleter.class, description = \"The path to the patch archive, the path to the target server and one or more paths to the source servers\")\n+      List<Resource> paths;\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+         if (paths.size() < 3) {\n+            throw Messages.MSG.patchCreateArgumentsRequired();\n+         }\n+         PatchTool patchTool = new PatchTool(invocation.getShellOutput(), invocation.getShellError());\n+         try {\n+            Path patch = Paths.get(paths.get(0).getAbsolutePath());\n+            Path target = Paths.get(paths.get(1).getAbsolutePath());\n+            Path sources[] = new Path[paths.size() - 2];\n+            for (int i = 2; i < paths.size(); i++) {\n+               sources[i - 2] = Paths.get(paths.get(i).getAbsolutePath());\n+            }\n+            patchTool.createPatch(qualifier, patch, target, sources);\n+            return CommandResult.SUCCESS;\n+         } catch (IOException e) {\n+            throw new RuntimeException(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcyNjQ5NA=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjA5OTA1OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/logging/Messages.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMToyNDo1NlrOGMeK4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNToxMjo1OVrOGMoerg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczMDQwMw==", "bodyText": "print the errors? org.infinispan.cli.patching.PatchTool#installPatch() isn't printing the error list.", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415730403", "createdAt": "2020-04-27T11:24:56Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/logging/Messages.java", "diffHunk": "@@ -92,4 +95,64 @@\n \n    @Message(\"Invalid resource '%s'\")\n    IllegalArgumentException invalidResource(String name);\n+\n+   @Message(\"No patches installed\")\n+   String patchNoPatchesInstalled();\n+\n+   @Message(\"%s\")\n+   String patchInfo(PatchInfo patchInfo);\n+\n+   @Message(\"The supplied patch cannot be applied to %s %s\")\n+   IllegalStateException patchCannotApply(String brandName, String version);\n+\n+   @Message(\"File %s SHA mismatch. Expected = %s, Actual = %s\")\n+   String patchShaMismatch(Path path, String digest, String sha256);\n+\n+   @Message(\"The following errors were encountered while validating local installation:\")\n+   String patchValidationErrors();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg5OTMxMA==", "bodyText": "Fixed", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415899310", "createdAt": "2020-04-27T15:12:59Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/logging/Messages.java", "diffHunk": "@@ -92,4 +95,64 @@\n \n    @Message(\"Invalid resource '%s'\")\n    IllegalArgumentException invalidResource(String name);\n+\n+   @Message(\"No patches installed\")\n+   String patchNoPatchesInstalled();\n+\n+   @Message(\"%s\")\n+   String patchInfo(PatchInfo patchInfo);\n+\n+   @Message(\"The supplied patch cannot be applied to %s %s\")\n+   IllegalStateException patchCannotApply(String brandName, String version);\n+\n+   @Message(\"File %s SHA mismatch. Expected = %s, Actual = %s\")\n+   String patchShaMismatch(Path path, String digest, String sha256);\n+\n+   @Message(\"The following errors were encountered while validating local installation:\")\n+   String patchValidationErrors();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczMDQwMw=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjEwNzU3OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/logging/Messages.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMToyNjo1OFrOGMePqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDozMDo1NFrOGMmP0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczMTYyNQ==", "bodyText": "maybe add the filename?", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415731625", "createdAt": "2020-04-27T11:26:58Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/logging/Messages.java", "diffHunk": "@@ -92,4 +95,64 @@\n \n    @Message(\"Invalid resource '%s'\")\n    IllegalArgumentException invalidResource(String name);\n+\n+   @Message(\"No patches installed\")\n+   String patchNoPatchesInstalled();\n+\n+   @Message(\"%s\")\n+   String patchInfo(PatchInfo patchInfo);\n+\n+   @Message(\"The supplied patch cannot be applied to %s %s\")\n+   IllegalStateException patchCannotApply(String brandName, String version);\n+\n+   @Message(\"File %s SHA mismatch. Expected = %s, Actual = %s\")\n+   String patchShaMismatch(Path path, String digest, String sha256);\n+\n+   @Message(\"The following errors were encountered while validating local installation:\")\n+   String patchValidationErrors();\n+\n+   @Message(\"No installed patches to roll back\")\n+   IllegalStateException patchNoPatchesInstalledToRollback();\n+\n+   @Message(\"Cannot find the infinispan-commons jar under %s\")\n+   IllegalStateException patchCannotFindCommons(Path lib);\n+\n+   @Message(\"Cannot create patch %s with patches for %s\")\n+   IllegalStateException patchIncompatibleProduct(String localBrand, String patchBrand);\n+\n+   @Message(\"Could not write patches file\")\n+   IllegalStateException patchCannotWritePatchesFile(@Cause IOException e);\n+\n+   @Message(\"Rolled back patch %s\")\n+   String patchRollback(PatchInfo patchInfo);\n+\n+   @Message(\"[Dry run] \")\n+   String patchDryRun();\n+\n+   @Message(\"Backing up '%s' to '%s'\")\n+   String patchBackup(Path from, Path to);\n+\n+   @Message(\"Error while creating patch\")\n+   RuntimeException patchCreateError(@Cause IOException e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTg2MjczOA==", "bodyText": "It's already in the exception message", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415862738", "createdAt": "2020-04-27T14:30:54Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/logging/Messages.java", "diffHunk": "@@ -92,4 +95,64 @@\n \n    @Message(\"Invalid resource '%s'\")\n    IllegalArgumentException invalidResource(String name);\n+\n+   @Message(\"No patches installed\")\n+   String patchNoPatchesInstalled();\n+\n+   @Message(\"%s\")\n+   String patchInfo(PatchInfo patchInfo);\n+\n+   @Message(\"The supplied patch cannot be applied to %s %s\")\n+   IllegalStateException patchCannotApply(String brandName, String version);\n+\n+   @Message(\"File %s SHA mismatch. Expected = %s, Actual = %s\")\n+   String patchShaMismatch(Path path, String digest, String sha256);\n+\n+   @Message(\"The following errors were encountered while validating local installation:\")\n+   String patchValidationErrors();\n+\n+   @Message(\"No installed patches to roll back\")\n+   IllegalStateException patchNoPatchesInstalledToRollback();\n+\n+   @Message(\"Cannot find the infinispan-commons jar under %s\")\n+   IllegalStateException patchCannotFindCommons(Path lib);\n+\n+   @Message(\"Cannot create patch %s with patches for %s\")\n+   IllegalStateException patchIncompatibleProduct(String localBrand, String patchBrand);\n+\n+   @Message(\"Could not write patches file\")\n+   IllegalStateException patchCannotWritePatchesFile(@Cause IOException e);\n+\n+   @Message(\"Rolled back patch %s\")\n+   String patchRollback(PatchInfo patchInfo);\n+\n+   @Message(\"[Dry run] \")\n+   String patchDryRun();\n+\n+   @Message(\"Backing up '%s' to '%s'\")\n+   String patchBackup(Path from, Path to);\n+\n+   @Message(\"Error while creating patch\")\n+   RuntimeException patchCreateError(@Cause IOException e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczMTYyNQ=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjExMDYxOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/logging/Messages.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMToyNzo0MlrOGMeRYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMToyNzo0MlrOGMeRYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczMjA2Ng==", "bodyText": "maybe add the destination path?", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415732066", "createdAt": "2020-04-27T11:27:42Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/logging/Messages.java", "diffHunk": "@@ -92,4 +95,64 @@\n \n    @Message(\"Invalid resource '%s'\")\n    IllegalArgumentException invalidResource(String name);\n+\n+   @Message(\"No patches installed\")\n+   String patchNoPatchesInstalled();\n+\n+   @Message(\"%s\")\n+   String patchInfo(PatchInfo patchInfo);\n+\n+   @Message(\"The supplied patch cannot be applied to %s %s\")\n+   IllegalStateException patchCannotApply(String brandName, String version);\n+\n+   @Message(\"File %s SHA mismatch. Expected = %s, Actual = %s\")\n+   String patchShaMismatch(Path path, String digest, String sha256);\n+\n+   @Message(\"The following errors were encountered while validating local installation:\")\n+   String patchValidationErrors();\n+\n+   @Message(\"No installed patches to roll back\")\n+   IllegalStateException patchNoPatchesInstalledToRollback();\n+\n+   @Message(\"Cannot find the infinispan-commons jar under %s\")\n+   IllegalStateException patchCannotFindCommons(Path lib);\n+\n+   @Message(\"Cannot create patch %s with patches for %s\")\n+   IllegalStateException patchIncompatibleProduct(String localBrand, String patchBrand);\n+\n+   @Message(\"Could not write patches file\")\n+   IllegalStateException patchCannotWritePatchesFile(@Cause IOException e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjEzMDc1OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/patch.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMTozMjozMlrOGMec2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMTozMjozMlrOGMec2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczNTAwMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            *patch install* `patch-file` ['path-to-server']\n          \n          \n            \n            *patch install* `patch-file` [--server `path-to-server`]", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415735000", "createdAt": "2020-04-27T11:32:32Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,90 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* `patch-file` ['path-to-server']", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjEzMjc5OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/patch.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMTozMzowNFrOGMeeAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNToxNDowOVrOGMoifw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczNTI5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            *patch rollback*\n          \n          \n            \n            *patch rollback* [--server `path-to-server`]", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415735299", "createdAt": "2020-04-27T11:33:04Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,90 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* `patch-file` ['path-to-server']\n+\n+*patch describe* 'patch-file'\n+\n+*patch rollback*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTkwMDI4Nw==", "bodyText": "Fixed", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415900287", "createdAt": "2020-04-27T15:14:09Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,90 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* `patch-file` ['path-to-server']\n+\n+*patch describe* 'patch-file'\n+\n+*patch rollback*", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczNTI5OQ=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjEzNjQ2OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/patch.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMTozNDowNFrOGMegGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNToxMzo1MlrOGMohlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczNTgzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            *patch install* `patch-file` ['path-to-server']::\n          \n          \n            \n            *patch install* `patch-file` [--server `path-to-server`]::", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415735834", "createdAt": "2020-04-27T11:34:04Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,90 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* `patch-file` ['path-to-server']\n+\n+*patch describe* 'patch-file'\n+\n+*patch rollback*\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]\n+\n+\n+DESCRIPTION\n+-----------\n+Manage (list, describe, install, rollback, create) ${infinispan.brand.name} server patches.\n+Server patches contain a number of artifacts that upgrade a server in order to resolve issues or add new features and is\n+distributed as a zip archive.\n+A single server patch can be used to upgrade multiple server source versions to a specific target version.\n+\n+\n+COMMAND SYNOPSIS\n+----------------\n+\n+List patches installed on a server\n+\n+*patch ls*::\n+Lists the patches currently installed on a server in order of installation.\n+\n+Install a patch on a server\n+\n+*patch install* `patch-file` ['path-to-server']::", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTkwMDA1Mw==", "bodyText": "Fixed", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415900053", "createdAt": "2020-04-27T15:13:52Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,90 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* `patch-file` ['path-to-server']\n+\n+*patch describe* 'patch-file'\n+\n+*patch rollback*\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]\n+\n+\n+DESCRIPTION\n+-----------\n+Manage (list, describe, install, rollback, create) ${infinispan.brand.name} server patches.\n+Server patches contain a number of artifacts that upgrade a server in order to resolve issues or add new features and is\n+distributed as a zip archive.\n+A single server patch can be used to upgrade multiple server source versions to a specific target version.\n+\n+\n+COMMAND SYNOPSIS\n+----------------\n+\n+List patches installed on a server\n+\n+*patch ls*::\n+Lists the patches currently installed on a server in order of installation.\n+\n+Install a patch on a server\n+\n+*patch install* `patch-file` ['path-to-server']::", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczNTgzNA=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjEzOTUzOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/patch.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMTozNDo1MFrOGMeh1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMTozNDo1MFrOGMeh1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczNjI3Nw==", "bodyText": "--server option is missing", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415736277", "createdAt": "2020-04-27T11:34:50Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,90 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* `patch-file` ['path-to-server']\n+\n+*patch describe* 'patch-file'\n+\n+*patch rollback*\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]\n+\n+\n+DESCRIPTION\n+-----------\n+Manage (list, describe, install, rollback, create) ${infinispan.brand.name} server patches.\n+Server patches contain a number of artifacts that upgrade a server in order to resolve issues or add new features and is\n+distributed as a zip archive.\n+A single server patch can be used to upgrade multiple server source versions to a specific target version.\n+\n+\n+COMMAND SYNOPSIS\n+----------------\n+\n+List patches installed on a server\n+\n+*patch ls*::\n+Lists the patches currently installed on a server in order of installation.\n+\n+Install a patch on a server\n+\n+*patch install* `patch-file` ['path-to-server']::\n+Installs `patch-file` on a server in the current directory.\n+It is possible to specify a path to the server where the patch should be installed.\n+\n+Describe the contents of a patch archive file\n+\n+*patch describe* 'patch-file'::\n+Describes the contents of the specified `patch-file`, i.e. the target version and the list of source versions that are supported.\n+\n+Create a patch file\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]::\n+Creates a patch file\n+\n+Rollback patches\n+\n+*patch rollback*::\n+Rolls back the patch installed last (use the *patch ls* command to show the patches in the order they've been applied)\n+\n+\n+PATCH DESCRIBE OPTIONS\n+----------------------\n+*-v, --verbose*::\n+Shows the content of the patch, including information about individual files\n+\n+\n+PATCH LIST OPTIONS\n+------------------\n+*-v, --verbose*::\n+Shows the content of each installed patch, including information about individual files\n+\n+\n+PATCH CREATE OPTIONS\n+--------------------\n+*-q, --qualifier*='name'::\n+Specifies a description qualifier string for the patch, e.g. `one-off for issue nnnn`\n+\n+\n+PATCH INSTALL OPTIONS\n+---------------------\n+*--dry-run*::\n+Shows the operations that will be performed but doesn't actually apply them\n+\n+\n+PATCH ROLLBACK OPTIONS\n+---------------------\n+*--dry-run*::\n+Shows the operations that will be performed but doesn't actually apply them\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjE0MDQwOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/patch.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMTozNTowM1rOGMeiXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNToxNDowMlrOGMoiGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczNjQxMw==", "bodyText": "--server option is missing", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415736413", "createdAt": "2020-04-27T11:35:03Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,90 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* `patch-file` ['path-to-server']\n+\n+*patch describe* 'patch-file'\n+\n+*patch rollback*\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]\n+\n+\n+DESCRIPTION\n+-----------\n+Manage (list, describe, install, rollback, create) ${infinispan.brand.name} server patches.\n+Server patches contain a number of artifacts that upgrade a server in order to resolve issues or add new features and is\n+distributed as a zip archive.\n+A single server patch can be used to upgrade multiple server source versions to a specific target version.\n+\n+\n+COMMAND SYNOPSIS\n+----------------\n+\n+List patches installed on a server\n+\n+*patch ls*::\n+Lists the patches currently installed on a server in order of installation.\n+\n+Install a patch on a server\n+\n+*patch install* `patch-file` ['path-to-server']::\n+Installs `patch-file` on a server in the current directory.\n+It is possible to specify a path to the server where the patch should be installed.\n+\n+Describe the contents of a patch archive file\n+\n+*patch describe* 'patch-file'::\n+Describes the contents of the specified `patch-file`, i.e. the target version and the list of source versions that are supported.\n+\n+Create a patch file\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]::\n+Creates a patch file\n+\n+Rollback patches\n+\n+*patch rollback*::\n+Rolls back the patch installed last (use the *patch ls* command to show the patches in the order they've been applied)\n+\n+\n+PATCH DESCRIBE OPTIONS\n+----------------------\n+*-v, --verbose*::\n+Shows the content of the patch, including information about individual files\n+\n+\n+PATCH LIST OPTIONS\n+------------------\n+*-v, --verbose*::\n+Shows the content of each installed patch, including information about individual files\n+\n+\n+PATCH CREATE OPTIONS\n+--------------------\n+*-q, --qualifier*='name'::\n+Specifies a description qualifier string for the patch, e.g. `one-off for issue nnnn`\n+\n+\n+PATCH INSTALL OPTIONS\n+---------------------\n+*--dry-run*::\n+Shows the operations that will be performed but doesn't actually apply them\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTkwMDE4NQ==", "bodyText": "Fixed", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415900185", "createdAt": "2020-04-27T15:14:02Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,90 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* `patch-file` ['path-to-server']\n+\n+*patch describe* 'patch-file'\n+\n+*patch rollback*\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]\n+\n+\n+DESCRIPTION\n+-----------\n+Manage (list, describe, install, rollback, create) ${infinispan.brand.name} server patches.\n+Server patches contain a number of artifacts that upgrade a server in order to resolve issues or add new features and is\n+distributed as a zip archive.\n+A single server patch can be used to upgrade multiple server source versions to a specific target version.\n+\n+\n+COMMAND SYNOPSIS\n+----------------\n+\n+List patches installed on a server\n+\n+*patch ls*::\n+Lists the patches currently installed on a server in order of installation.\n+\n+Install a patch on a server\n+\n+*patch install* `patch-file` ['path-to-server']::\n+Installs `patch-file` on a server in the current directory.\n+It is possible to specify a path to the server where the patch should be installed.\n+\n+Describe the contents of a patch archive file\n+\n+*patch describe* 'patch-file'::\n+Describes the contents of the specified `patch-file`, i.e. the target version and the list of source versions that are supported.\n+\n+Create a patch file\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]::\n+Creates a patch file\n+\n+Rollback patches\n+\n+*patch rollback*::\n+Rolls back the patch installed last (use the *patch ls* command to show the patches in the order they've been applied)\n+\n+\n+PATCH DESCRIBE OPTIONS\n+----------------------\n+*-v, --verbose*::\n+Shows the content of the patch, including information about individual files\n+\n+\n+PATCH LIST OPTIONS\n+------------------\n+*-v, --verbose*::\n+Shows the content of each installed patch, including information about individual files\n+\n+\n+PATCH CREATE OPTIONS\n+--------------------\n+*-q, --qualifier*='name'::\n+Specifies a description qualifier string for the patch, e.g. `one-off for issue nnnn`\n+\n+\n+PATCH INSTALL OPTIONS\n+---------------------\n+*--dry-run*::\n+Shows the operations that will be performed but doesn't actually apply them\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczNjQxMw=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjE0MTcyOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/patch.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMTozNToyOFrOGMejNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNToxNDoxOVrOGMoi_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczNjYzMA==", "bodyText": "--server option is missing.", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415736630", "createdAt": "2020-04-27T11:35:28Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,90 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* `patch-file` ['path-to-server']\n+\n+*patch describe* 'patch-file'\n+\n+*patch rollback*\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]\n+\n+\n+DESCRIPTION\n+-----------\n+Manage (list, describe, install, rollback, create) ${infinispan.brand.name} server patches.\n+Server patches contain a number of artifacts that upgrade a server in order to resolve issues or add new features and is\n+distributed as a zip archive.\n+A single server patch can be used to upgrade multiple server source versions to a specific target version.\n+\n+\n+COMMAND SYNOPSIS\n+----------------\n+\n+List patches installed on a server\n+\n+*patch ls*::\n+Lists the patches currently installed on a server in order of installation.\n+\n+Install a patch on a server\n+\n+*patch install* `patch-file` ['path-to-server']::\n+Installs `patch-file` on a server in the current directory.\n+It is possible to specify a path to the server where the patch should be installed.\n+\n+Describe the contents of a patch archive file\n+\n+*patch describe* 'patch-file'::\n+Describes the contents of the specified `patch-file`, i.e. the target version and the list of source versions that are supported.\n+\n+Create a patch file\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]::\n+Creates a patch file\n+\n+Rollback patches\n+\n+*patch rollback*::\n+Rolls back the patch installed last (use the *patch ls* command to show the patches in the order they've been applied)\n+\n+\n+PATCH DESCRIBE OPTIONS\n+----------------------\n+*-v, --verbose*::\n+Shows the content of the patch, including information about individual files\n+\n+\n+PATCH LIST OPTIONS\n+------------------\n+*-v, --verbose*::\n+Shows the content of each installed patch, including information about individual files\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTkwMDQxMg==", "bodyText": "Fixed", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415900412", "createdAt": "2020-04-27T15:14:19Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,90 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* `patch-file` ['path-to-server']\n+\n+*patch describe* 'patch-file'\n+\n+*patch rollback*\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]\n+\n+\n+DESCRIPTION\n+-----------\n+Manage (list, describe, install, rollback, create) ${infinispan.brand.name} server patches.\n+Server patches contain a number of artifacts that upgrade a server in order to resolve issues or add new features and is\n+distributed as a zip archive.\n+A single server patch can be used to upgrade multiple server source versions to a specific target version.\n+\n+\n+COMMAND SYNOPSIS\n+----------------\n+\n+List patches installed on a server\n+\n+*patch ls*::\n+Lists the patches currently installed on a server in order of installation.\n+\n+Install a patch on a server\n+\n+*patch install* `patch-file` ['path-to-server']::\n+Installs `patch-file` on a server in the current directory.\n+It is possible to specify a path to the server where the patch should be installed.\n+\n+Describe the contents of a patch archive file\n+\n+*patch describe* 'patch-file'::\n+Describes the contents of the specified `patch-file`, i.e. the target version and the list of source versions that are supported.\n+\n+Create a patch file\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]::\n+Creates a patch file\n+\n+Rollback patches\n+\n+*patch rollback*::\n+Rolls back the patch installed last (use the *patch ls* command to show the patches in the order they've been applied)\n+\n+\n+PATCH DESCRIBE OPTIONS\n+----------------------\n+*-v, --verbose*::\n+Shows the content of the patch, including information about individual files\n+\n+\n+PATCH LIST OPTIONS\n+------------------\n+*-v, --verbose*::\n+Shows the content of each installed patch, including information about individual files\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTczNjYzMA=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjM0MDE1OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/completers/FileOptionCompleter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjoyMjoxOVrOGMgT7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjoyODowOVrOGMsVMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc2NTQ4Ng==", "bodyText": "unused", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415765486", "createdAt": "2020-04-27T12:22:19Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/completers/FileOptionCompleter.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.infinispan.cli.completers;\n+\n+import org.aesh.command.completer.CompleterInvocation;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class FileOptionCompleter extends org.aesh.command.impl.completer.FileOptionCompleter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk2MjQxNg==", "bodyText": "Removed", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415962416", "createdAt": "2020-04-27T16:28:09Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/completers/FileOptionCompleter.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.infinispan.cli.completers;\n+\n+import org.aesh.command.completer.CompleterInvocation;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class FileOptionCompleter extends org.aesh.command.impl.completer.FileOptionCompleter {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc2NTQ4Ng=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjQwOTg4OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/ServerFile.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjozNzo1NlrOGMg7nA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjoyOToxM1rOGMsYrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3NTY0NA==", "bodyText": "remove?", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415775644", "createdAt": "2020-04-27T12:37:56Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/ServerFile.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.infinispan.cli.patching;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class ServerFile implements Comparable<ServerFile> {\n+   private final Path directory;\n+   private final String filename;\n+   private final String basename;\n+   private final String digest;\n+   private final String permissions;\n+   private final boolean soft;\n+\n+   public ServerFile(Path path, String digest, String permissions, boolean soft) {\n+      this.directory = path.getParent();\n+      this.filename = path.getFileName().toString();\n+      this.basename = basename(filename);\n+      this.digest = digest;\n+      this.permissions = permissions;\n+      this.soft = soft;\n+   }\n+\n+   @Override\n+   public String toString() {\n+      return \"ServerFile{\" +\n+            \"directory=\" + directory +\n+            \", filename='\" + filename + '\\'' +\n+            \", basename='\" + basename + '\\'' +\n+            \", permissions='\" + permissions + '\\'' +\n+            \", soft=\" + soft +\n+            '}';\n+   }\n+\n+   private static String basename(String filename) {\n+      int l = filename.length();\n+      for (int i = 0; i < l; i++) {\n+         char c = filename.charAt(i);\n+         if (c == '-' && i < l - 1) {\n+            c = filename.charAt(i + 1);\n+            if (c >= '0' && c <= '9') {\n+               return filename.substring(0, i);\n+            }\n+         }\n+      }\n+      // Could not obtain an artifact\n+      return filename;\n+   }\n+\n+   public String getFilename() {\n+      return filename;\n+   }\n+\n+   public String getDigest() {\n+      return digest;\n+   }\n+\n+   public String getPermissions() {\n+      return permissions;\n+   }\n+\n+   Path getVersionedPath() {\n+      return directory != null ? directory.resolve(filename) : Paths.get(filename);\n+   }\n+\n+   Path getUnversionedPath() {\n+      return directory != null ? directory.resolve(basename) : Paths.get(basename);\n+   }\n+\n+   public boolean isSoft() {\n+      return soft;\n+   }\n+\n+   @Override\n+   public int compareTo(ServerFile other) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk2MzMwOA==", "bodyText": "Done", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415963308", "createdAt": "2020-04-27T16:29:13Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/ServerFile.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package org.infinispan.cli.patching;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class ServerFile implements Comparable<ServerFile> {\n+   private final Path directory;\n+   private final String filename;\n+   private final String basename;\n+   private final String digest;\n+   private final String permissions;\n+   private final boolean soft;\n+\n+   public ServerFile(Path path, String digest, String permissions, boolean soft) {\n+      this.directory = path.getParent();\n+      this.filename = path.getFileName().toString();\n+      this.basename = basename(filename);\n+      this.digest = digest;\n+      this.permissions = permissions;\n+      this.soft = soft;\n+   }\n+\n+   @Override\n+   public String toString() {\n+      return \"ServerFile{\" +\n+            \"directory=\" + directory +\n+            \", filename='\" + filename + '\\'' +\n+            \", basename='\" + basename + '\\'' +\n+            \", permissions='\" + permissions + '\\'' +\n+            \", soft=\" + soft +\n+            '}';\n+   }\n+\n+   private static String basename(String filename) {\n+      int l = filename.length();\n+      for (int i = 0; i < l; i++) {\n+         char c = filename.charAt(i);\n+         if (c == '-' && i < l - 1) {\n+            c = filename.charAt(i + 1);\n+            if (c >= '0' && c <= '9') {\n+               return filename.substring(0, i);\n+            }\n+         }\n+      }\n+      // Could not obtain an artifact\n+      return filename;\n+   }\n+\n+   public String getFilename() {\n+      return filename;\n+   }\n+\n+   public String getDigest() {\n+      return digest;\n+   }\n+\n+   public String getPermissions() {\n+      return permissions;\n+   }\n+\n+   Path getVersionedPath() {\n+      return directory != null ? directory.resolve(filename) : Paths.get(filename);\n+   }\n+\n+   Path getUnversionedPath() {\n+      return directory != null ? directory.resolve(basename) : Paths.get(basename);\n+   }\n+\n+   public boolean isSoft() {\n+      return soft;\n+   }\n+\n+   @Override\n+   public int compareTo(ServerFile other) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3NTY0NA=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjQ2OTYzOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/test/java/org/infinispan/cli/patching/PatchToolTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjo1MDo0N1rOGMhdvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjoyODozMVrOGMsWew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4NDM4Mg==", "bodyText": "may I suggest o open patch.json and validate if the content is correct?", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415784382", "createdAt": "2020-04-27T12:50:47Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/test/java/org/infinispan/cli/patching/PatchToolTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedWriter;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Collections;\n+import java.util.Properties;\n+\n+import org.infinispan.commons.test.CommonsTestingUtil;\n+import org.infinispan.commons.test.Exceptions;\n+import org.infinispan.commons.util.Util;\n+import org.junit.Test;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchToolTest {\n+\n+   @Test\n+   public void testPatchToolCreate() throws IOException {\n+      Path tmp = Paths.get(CommonsTestingUtil.tmpDirectory(PatchToolTest.class));\n+      Util.recursiveFileRemove(tmp.toFile());\n+      Files.createDirectories(tmp);\n+      Util.recursiveDirectoryCopy(new File(\"target/test-classes/patch\").toPath(), tmp);\n+\n+      // Create the infinispan-commons jars that identify a server's version\n+      Path v1 = tmp.resolve(\"v1\");\n+      createFakeInfinispanCommons(v1, \"Infinispan\", \"1.0.0.Final\");\n+      Path v2 = tmp.resolve(\"v2\");\n+      createFakeInfinispanCommons(v2, \"Infinispan\", \"1.0.1.Final\");\n+      Path v3 = tmp.resolve(\"v3\");\n+      createFakeInfinispanCommons(v3, \"Infinispan\", \"1.1.0.Final\");\n+\n+      ByteArrayOutputStream out = new ByteArrayOutputStream();\n+      ByteArrayOutputStream err = new ByteArrayOutputStream();\n+\n+      PatchTool patchTool = new PatchTool(new PrintStream(out), new PrintStream(err));\n+\n+      // List the installed patches on v1\n+      patchTool.listPatches(v1, false);\n+      assertContains(out, \"No patches installed\");\n+      assertEmpty(err);\n+      out.reset();\n+\n+      // Create a patch zip that can patch v1 and v2 to v3\n+      Path patch = Paths.get(\"target/patch.zip\");\n+      patch.toFile().delete();\n+      patchTool.createPatch(\"\", patch, v3, v1, v2);\n+      assertContains(out, \"Adding \");\n+      assertEmpty(err);\n+      out.reset();\n+\n+      // Attempting to create the patch file again should fail\n+      Exceptions.expectException(FileAlreadyExistsException.class, () -> patchTool.createPatch(\"\", patch, v3, v1, v2));\n+\n+      // Ensure the zip file does not contain the .patches directory IGNOREME.txt files", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk2Mjc0Nw==", "bodyText": "I think it's better to trust patch ls for that", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415962747", "createdAt": "2020-04-27T16:28:31Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/test/java/org/infinispan/cli/patching/PatchToolTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.BufferedWriter;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.util.Collections;\n+import java.util.Properties;\n+\n+import org.infinispan.commons.test.CommonsTestingUtil;\n+import org.infinispan.commons.test.Exceptions;\n+import org.infinispan.commons.util.Util;\n+import org.junit.Test;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchToolTest {\n+\n+   @Test\n+   public void testPatchToolCreate() throws IOException {\n+      Path tmp = Paths.get(CommonsTestingUtil.tmpDirectory(PatchToolTest.class));\n+      Util.recursiveFileRemove(tmp.toFile());\n+      Files.createDirectories(tmp);\n+      Util.recursiveDirectoryCopy(new File(\"target/test-classes/patch\").toPath(), tmp);\n+\n+      // Create the infinispan-commons jars that identify a server's version\n+      Path v1 = tmp.resolve(\"v1\");\n+      createFakeInfinispanCommons(v1, \"Infinispan\", \"1.0.0.Final\");\n+      Path v2 = tmp.resolve(\"v2\");\n+      createFakeInfinispanCommons(v2, \"Infinispan\", \"1.0.1.Final\");\n+      Path v3 = tmp.resolve(\"v3\");\n+      createFakeInfinispanCommons(v3, \"Infinispan\", \"1.1.0.Final\");\n+\n+      ByteArrayOutputStream out = new ByteArrayOutputStream();\n+      ByteArrayOutputStream err = new ByteArrayOutputStream();\n+\n+      PatchTool patchTool = new PatchTool(new PrintStream(out), new PrintStream(err));\n+\n+      // List the installed patches on v1\n+      patchTool.listPatches(v1, false);\n+      assertContains(out, \"No patches installed\");\n+      assertEmpty(err);\n+      out.reset();\n+\n+      // Create a patch zip that can patch v1 and v2 to v3\n+      Path patch = Paths.get(\"target/patch.zip\");\n+      patch.toFile().delete();\n+      patchTool.createPatch(\"\", patch, v3, v1, v2);\n+      assertContains(out, \"Adding \");\n+      assertEmpty(err);\n+      out.reset();\n+\n+      // Attempting to create the patch file again should fail\n+      Exceptions.expectException(FileAlreadyExistsException.class, () -> patchTool.createPatch(\"\", patch, v3, v1, v2));\n+\n+      // Ensure the zip file does not contain the .patches directory IGNOREME.txt files", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4NDM4Mg=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjQ4NzI5OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjo1NDozNVrOGMhoGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjoyODo0MVrOGMsXAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4NzAzNQ==", "bodyText": "print errors?", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415787035", "createdAt": "2020-04-27T12:54:35Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk2Mjg4MQ==", "bodyText": "Fixed", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415962881", "createdAt": "2020-04-27T16:28:41Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4NzAzNQ=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjUwMjMxOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjo1NzoyOVrOGMhwtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjo1NzoyOVrOGMhwtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4OTIzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (installedPatches.size() == 0) {\n          \n          \n            \n                  if (installedPatches.isEmpty()) {", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415789237", "createdAt": "2020-04-27T12:57:29Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjUxNTA1OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzowMDowNlrOGMh4Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzowMDowNlrOGMh4Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5MTExOQ==", "bodyText": "sha256 is null if the file doesn't exist.\nthe install should be aborted.", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415791119", "createdAt": "2020-04-27T13:00:06Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjUxNzc3OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzowMDo0MFrOGMh5qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzowMDo0MFrOGMh5qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5MTUyOQ==", "bodyText": "check for null. sha256 is null if the file doesn't exist", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415791529", "createdAt": "2020-04-27T13:00:40Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjUyNDMxOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzowMTo1OFrOGMh9WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzowMTo1OFrOGMh9WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5MjQ3Mg==", "bodyText": "protect against null (as described above)", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415792472", "createdAt": "2020-04-27T13:01:58Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjUyNzU1OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzowMjo0MlrOGMh_Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzo1NTo0N1rOGMke9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5Mjk2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     return new ArrayList<>();\n          \n          \n            \n                     return Collections.emptyList();", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415792966", "createdAt": "2020-04-27T13:02:42Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzMzg0NQ==", "bodyText": "Nope, because I need to manipulate the list in case of installation.", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415833845", "createdAt": "2020-04-27T13:55:47Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5Mjk2Ng=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 286}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjUzMzA1OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzowMzo1MVrOGMiCfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjoyODo1N1rOGMsX2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5Mzc5MA==", "bodyText": "not sure if the permission is needed.", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415793790", "createdAt": "2020-04-27T13:03:51Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 323}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk2MzA5OA==", "bodyText": "I collect them all :)", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415963098", "createdAt": "2020-04-27T16:28:57Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5Mzc5MA=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 323}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjUzNjc0OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzowNDo0MVrOGMiEmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzo1OToxMlrOGMkp-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5NDMzMA==", "bodyText": "can't you just compare the digest instead of doing a binary check?", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415794330", "createdAt": "2020-04-27T13:04:41Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else { // Check contents\n+               try {\n+                  if (!compareFileContents(source.resolve(v1File.getVersionedPath()), target.resolve(targetFile.getVersionedPath()))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 331}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzNjY2NQ==", "bodyText": "Very stupid of me :)", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415836665", "createdAt": "2020-04-27T13:59:12Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else { // Check contents\n+               try {\n+                  if (!compareFileContents(source.resolve(v1File.getVersionedPath()), target.resolve(targetFile.getVersionedPath()))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5NDMzMA=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 331}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjU2NDc1OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzoxMDoyNlrOGMiUvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzoxMDoyNlrOGMiUvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc5ODQ2Mg==", "bodyText": "unnecessary ;", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415798462", "createdAt": "2020-04-27T13:10:26Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else { // Check contents\n+               try {\n+                  if (!compareFileContents(source.resolve(v1File.getVersionedPath()), target.resolve(targetFile.getVersionedPath()))) {\n+                     operations.add(PatchOperation.replace(targetFile.isSoft(), targetFile.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getDigest(), targetFile.getPermissions()));\n+                     addFileToZip(zipfs, target, targetFile);\n+                  }\n+               } catch (IOException e) {\n+                  throw new RuntimeException(e);\n+               }\n+            }\n+         }\n+      });\n+      targetFiles.forEach((k2, targetFile) -> {\n+         if (!v1Files.containsKey(k2)) {\n+            operations.add(PatchOperation.add(targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+            addFileToZip(zipfs, target, targetFile);\n+         }\n+      });\n+\n+      // Write out the JSON patch file\n+      Path patchPath = zipfs.getPath(\"patch-\" + patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion() + \".json\");\n+      try (OutputStream os = Files.newOutputStream(patchPath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writerWithDefaultPrettyPrinter().writeValue(os, patchInfo);\n+      }\n+   }\n+\n+   private Map<Path, ServerFile> getServerFiles(Path base) throws IOException {\n+      Pattern IGNORE = Pattern.compile(\"^(\\\\.patches/|server/data/|server/log/|server/lib/).*$\");\n+      Pattern SOFT_REPLACE_PATTERN = Pattern.compile(\"^server/conf/.*$\");\n+      Map<Path, ServerFile> files = new TreeMap<>();\n+      Files.walkFileTree(base, new SimpleFileVisitor<Path>() {\n+         @Override\n+         public FileVisitResult visitFile(Path oPath, BasicFileAttributes attrs) {\n+            Path rPath = base.relativize(oPath);\n+            String rPathName = rPath.toString();\n+            if (!IGNORE.matcher(rPathName).matches()) {\n+               ServerFile file = new ServerFile(rPath, sha256(oPath), getPermissions(oPath), SOFT_REPLACE_PATTERN.matcher(rPathName).matches());\n+               files.put(file.getUnversionedPath(), file);\n+            }\n+            return FileVisitResult.CONTINUE;\n+         }\n+      });\n+      return files;\n+   }\n+\n+   private static String getPermissions(Path path) {\n+      try {\n+         return PosixFilePermissions.toString(Files.getPosixFilePermissions(path));\n+      } catch (IOException e) {\n+         throw new RuntimeException(e);\n+      }\n+   }\n+\n+   private List<PatchInfo> getPatchInfos(FileSystem zipfs) throws IOException {\n+      List<Path> paths = Files.find(zipfs.getPath(\"/\"), 1,\n+            (p, a) -> a.isRegularFile() && p.getFileName().toString().startsWith(\"patch-\") && p.getFileName().toString().endsWith(\".json\")\n+      ).collect(Collectors.toList());\n+      List<PatchInfo> infos = new ArrayList<>(paths.size());\n+      for (Path path : paths) {\n+         try (InputStream is = Files.newInputStream(path, StandardOpenOption.READ)) {\n+            infos.add(mapper.readValue(is, PatchInfo.class));\n+         }\n+      }\n+      return infos;\n+   }\n+\n+   private Version getVersion(Path base) throws IOException {\n+      // Load the META-INF/infinispan-version.properties from the lib/infinispan-commons jar\n+      Path lib = base.resolve(\"lib\");\n+      File[] commons = lib.toFile().listFiles((dir, name) -> name.startsWith(\"infinispan-commons-\") && name.endsWith(\".jar\"));\n+      if (commons == null || commons.length != 1) {\n+         throw MSG.patchCannotFindCommons(lib);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + commons[0].toURI().toString());\n+      try (FileSystem zipfs = FileSystems.newFileSystem(jarUri, Collections.emptyMap()); InputStream in = Files.newInputStream(zipfs.getPath(\"META-INF\", \"infinispan-version.properties\"))) {\n+         return Version.from(in);\n+      }\n+   }\n+\n+\n+   private FileSystem getPatchFile(Path patch, boolean create) throws IOException {\n+      if (create && patch.toFile().exists()) {\n+         throw MSG.patchFileAlreadyExists(patch);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + patch.toUri().toString());\n+      return FileSystems.newFileSystem(jarUri, create ? Collections.singletonMap(\"create\", \"true\") : Collections.emptyMap());\n+   }\n+\n+   private FileSystem getPatchFile(Path patch) throws IOException {\n+      return getPatchFile(patch, false);\n+   }\n+\n+   private void addFileToZip(FileSystem zipfs, Path basePath, ServerFile file) {\n+      try {\n+         Path target = zipfs.getPath(file.getVersionedPath().toString());\n+         out.println(MSG.patchCreateAdd(target));\n+         if (target.getParent() != null) {\n+            Files.createDirectories(target.getParent());\n+         }\n+         Files.copy(basePath.resolve(file.getVersionedPath()), target, StandardCopyOption.REPLACE_EXISTING);\n+      } catch (IOException e) {\n+         throw MSG.patchCreateError(e);\n+      }\n+   }\n+\n+   private static boolean compareFileContents(Path path, Path path2) throws IOException {\n+      if (Files.isSameFile(path, path2)) {\n+         return true;\n+      }\n+      byte[] buffer1 = new byte[BUFFER_SIZE];\n+      byte[] buffer2 = new byte[BUFFER_SIZE];\n+      try (InputStream in1 = Files.newInputStream(path);\n+           InputStream in2 = Files.newInputStream(path2);) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 441}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NjU4NzA4OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMzoxNDo0M1rOGMihoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNDowMjoyOVrOGMkz9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwMTc2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        digest.update(buffer);\n          \n          \n            \n                        digest.update(buffer, 0, read);", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415801760", "createdAt": "2020-04-27T13:14:43Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else { // Check contents\n+               try {\n+                  if (!compareFileContents(source.resolve(v1File.getVersionedPath()), target.resolve(targetFile.getVersionedPath()))) {\n+                     operations.add(PatchOperation.replace(targetFile.isSoft(), targetFile.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getDigest(), targetFile.getPermissions()));\n+                     addFileToZip(zipfs, target, targetFile);\n+                  }\n+               } catch (IOException e) {\n+                  throw new RuntimeException(e);\n+               }\n+            }\n+         }\n+      });\n+      targetFiles.forEach((k2, targetFile) -> {\n+         if (!v1Files.containsKey(k2)) {\n+            operations.add(PatchOperation.add(targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+            addFileToZip(zipfs, target, targetFile);\n+         }\n+      });\n+\n+      // Write out the JSON patch file\n+      Path patchPath = zipfs.getPath(\"patch-\" + patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion() + \".json\");\n+      try (OutputStream os = Files.newOutputStream(patchPath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writerWithDefaultPrettyPrinter().writeValue(os, patchInfo);\n+      }\n+   }\n+\n+   private Map<Path, ServerFile> getServerFiles(Path base) throws IOException {\n+      Pattern IGNORE = Pattern.compile(\"^(\\\\.patches/|server/data/|server/log/|server/lib/).*$\");\n+      Pattern SOFT_REPLACE_PATTERN = Pattern.compile(\"^server/conf/.*$\");\n+      Map<Path, ServerFile> files = new TreeMap<>();\n+      Files.walkFileTree(base, new SimpleFileVisitor<Path>() {\n+         @Override\n+         public FileVisitResult visitFile(Path oPath, BasicFileAttributes attrs) {\n+            Path rPath = base.relativize(oPath);\n+            String rPathName = rPath.toString();\n+            if (!IGNORE.matcher(rPathName).matches()) {\n+               ServerFile file = new ServerFile(rPath, sha256(oPath), getPermissions(oPath), SOFT_REPLACE_PATTERN.matcher(rPathName).matches());\n+               files.put(file.getUnversionedPath(), file);\n+            }\n+            return FileVisitResult.CONTINUE;\n+         }\n+      });\n+      return files;\n+   }\n+\n+   private static String getPermissions(Path path) {\n+      try {\n+         return PosixFilePermissions.toString(Files.getPosixFilePermissions(path));\n+      } catch (IOException e) {\n+         throw new RuntimeException(e);\n+      }\n+   }\n+\n+   private List<PatchInfo> getPatchInfos(FileSystem zipfs) throws IOException {\n+      List<Path> paths = Files.find(zipfs.getPath(\"/\"), 1,\n+            (p, a) -> a.isRegularFile() && p.getFileName().toString().startsWith(\"patch-\") && p.getFileName().toString().endsWith(\".json\")\n+      ).collect(Collectors.toList());\n+      List<PatchInfo> infos = new ArrayList<>(paths.size());\n+      for (Path path : paths) {\n+         try (InputStream is = Files.newInputStream(path, StandardOpenOption.READ)) {\n+            infos.add(mapper.readValue(is, PatchInfo.class));\n+         }\n+      }\n+      return infos;\n+   }\n+\n+   private Version getVersion(Path base) throws IOException {\n+      // Load the META-INF/infinispan-version.properties from the lib/infinispan-commons jar\n+      Path lib = base.resolve(\"lib\");\n+      File[] commons = lib.toFile().listFiles((dir, name) -> name.startsWith(\"infinispan-commons-\") && name.endsWith(\".jar\"));\n+      if (commons == null || commons.length != 1) {\n+         throw MSG.patchCannotFindCommons(lib);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + commons[0].toURI().toString());\n+      try (FileSystem zipfs = FileSystems.newFileSystem(jarUri, Collections.emptyMap()); InputStream in = Files.newInputStream(zipfs.getPath(\"META-INF\", \"infinispan-version.properties\"))) {\n+         return Version.from(in);\n+      }\n+   }\n+\n+\n+   private FileSystem getPatchFile(Path patch, boolean create) throws IOException {\n+      if (create && patch.toFile().exists()) {\n+         throw MSG.patchFileAlreadyExists(patch);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + patch.toUri().toString());\n+      return FileSystems.newFileSystem(jarUri, create ? Collections.singletonMap(\"create\", \"true\") : Collections.emptyMap());\n+   }\n+\n+   private FileSystem getPatchFile(Path patch) throws IOException {\n+      return getPatchFile(patch, false);\n+   }\n+\n+   private void addFileToZip(FileSystem zipfs, Path basePath, ServerFile file) {\n+      try {\n+         Path target = zipfs.getPath(file.getVersionedPath().toString());\n+         out.println(MSG.patchCreateAdd(target));\n+         if (target.getParent() != null) {\n+            Files.createDirectories(target.getParent());\n+         }\n+         Files.copy(basePath.resolve(file.getVersionedPath()), target, StandardCopyOption.REPLACE_EXISTING);\n+      } catch (IOException e) {\n+         throw MSG.patchCreateError(e);\n+      }\n+   }\n+\n+   private static boolean compareFileContents(Path path, Path path2) throws IOException {\n+      if (Files.isSameFile(path, path2)) {\n+         return true;\n+      }\n+      byte[] buffer1 = new byte[BUFFER_SIZE];\n+      byte[] buffer2 = new byte[BUFFER_SIZE];\n+      try (InputStream in1 = Files.newInputStream(path);\n+           InputStream in2 = Files.newInputStream(path2);) {\n+         while (true) {\n+            int n1 = in1.read(buffer1);\n+            int n2 = in2.read(buffer2);\n+            if (n1 != n2) {\n+               return false;\n+            }\n+            if (!Arrays.equals(buffer1, buffer2)) {\n+               return false;\n+            }\n+            if (n1 < BUFFER_SIZE) { // EOF and everything is equals\n+               return true;\n+            }\n+         }\n+      }\n+   }\n+\n+   static String sha256(Path path) {\n+      try (InputStream in = Files.newInputStream(path)) {\n+         MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n+         byte[] buffer = new byte[BUFFER_SIZE];\n+         int read = 0;\n+         do {\n+            read = in.read(buffer);\n+            digest.update(buffer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 465}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwNjIxNA==", "bodyText": "I guess you could use the MapByteBuffer directly since the files should be small, and do something like this:\n      try (FileChannel f = (FileChannel) Files.newByteChannel(path, StandardOpenOption.READ)) {\n         MappedByteBuffer byteBuffer = f.map(FileChannel.MapMode.READ_ONLY, 0, f.size());\n         MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n         digest.update(byteBuffer);\n         return Util.toHexString(digest.digest());\n      } catch (IOException | NoSuchAlgorithmException e) {\n         e.printStackTrace();\n      }", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415806214", "createdAt": "2020-04-27T13:20:28Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else { // Check contents\n+               try {\n+                  if (!compareFileContents(source.resolve(v1File.getVersionedPath()), target.resolve(targetFile.getVersionedPath()))) {\n+                     operations.add(PatchOperation.replace(targetFile.isSoft(), targetFile.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getDigest(), targetFile.getPermissions()));\n+                     addFileToZip(zipfs, target, targetFile);\n+                  }\n+               } catch (IOException e) {\n+                  throw new RuntimeException(e);\n+               }\n+            }\n+         }\n+      });\n+      targetFiles.forEach((k2, targetFile) -> {\n+         if (!v1Files.containsKey(k2)) {\n+            operations.add(PatchOperation.add(targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+            addFileToZip(zipfs, target, targetFile);\n+         }\n+      });\n+\n+      // Write out the JSON patch file\n+      Path patchPath = zipfs.getPath(\"patch-\" + patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion() + \".json\");\n+      try (OutputStream os = Files.newOutputStream(patchPath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writerWithDefaultPrettyPrinter().writeValue(os, patchInfo);\n+      }\n+   }\n+\n+   private Map<Path, ServerFile> getServerFiles(Path base) throws IOException {\n+      Pattern IGNORE = Pattern.compile(\"^(\\\\.patches/|server/data/|server/log/|server/lib/).*$\");\n+      Pattern SOFT_REPLACE_PATTERN = Pattern.compile(\"^server/conf/.*$\");\n+      Map<Path, ServerFile> files = new TreeMap<>();\n+      Files.walkFileTree(base, new SimpleFileVisitor<Path>() {\n+         @Override\n+         public FileVisitResult visitFile(Path oPath, BasicFileAttributes attrs) {\n+            Path rPath = base.relativize(oPath);\n+            String rPathName = rPath.toString();\n+            if (!IGNORE.matcher(rPathName).matches()) {\n+               ServerFile file = new ServerFile(rPath, sha256(oPath), getPermissions(oPath), SOFT_REPLACE_PATTERN.matcher(rPathName).matches());\n+               files.put(file.getUnversionedPath(), file);\n+            }\n+            return FileVisitResult.CONTINUE;\n+         }\n+      });\n+      return files;\n+   }\n+\n+   private static String getPermissions(Path path) {\n+      try {\n+         return PosixFilePermissions.toString(Files.getPosixFilePermissions(path));\n+      } catch (IOException e) {\n+         throw new RuntimeException(e);\n+      }\n+   }\n+\n+   private List<PatchInfo> getPatchInfos(FileSystem zipfs) throws IOException {\n+      List<Path> paths = Files.find(zipfs.getPath(\"/\"), 1,\n+            (p, a) -> a.isRegularFile() && p.getFileName().toString().startsWith(\"patch-\") && p.getFileName().toString().endsWith(\".json\")\n+      ).collect(Collectors.toList());\n+      List<PatchInfo> infos = new ArrayList<>(paths.size());\n+      for (Path path : paths) {\n+         try (InputStream is = Files.newInputStream(path, StandardOpenOption.READ)) {\n+            infos.add(mapper.readValue(is, PatchInfo.class));\n+         }\n+      }\n+      return infos;\n+   }\n+\n+   private Version getVersion(Path base) throws IOException {\n+      // Load the META-INF/infinispan-version.properties from the lib/infinispan-commons jar\n+      Path lib = base.resolve(\"lib\");\n+      File[] commons = lib.toFile().listFiles((dir, name) -> name.startsWith(\"infinispan-commons-\") && name.endsWith(\".jar\"));\n+      if (commons == null || commons.length != 1) {\n+         throw MSG.patchCannotFindCommons(lib);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + commons[0].toURI().toString());\n+      try (FileSystem zipfs = FileSystems.newFileSystem(jarUri, Collections.emptyMap()); InputStream in = Files.newInputStream(zipfs.getPath(\"META-INF\", \"infinispan-version.properties\"))) {\n+         return Version.from(in);\n+      }\n+   }\n+\n+\n+   private FileSystem getPatchFile(Path patch, boolean create) throws IOException {\n+      if (create && patch.toFile().exists()) {\n+         throw MSG.patchFileAlreadyExists(patch);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + patch.toUri().toString());\n+      return FileSystems.newFileSystem(jarUri, create ? Collections.singletonMap(\"create\", \"true\") : Collections.emptyMap());\n+   }\n+\n+   private FileSystem getPatchFile(Path patch) throws IOException {\n+      return getPatchFile(patch, false);\n+   }\n+\n+   private void addFileToZip(FileSystem zipfs, Path basePath, ServerFile file) {\n+      try {\n+         Path target = zipfs.getPath(file.getVersionedPath().toString());\n+         out.println(MSG.patchCreateAdd(target));\n+         if (target.getParent() != null) {\n+            Files.createDirectories(target.getParent());\n+         }\n+         Files.copy(basePath.resolve(file.getVersionedPath()), target, StandardCopyOption.REPLACE_EXISTING);\n+      } catch (IOException e) {\n+         throw MSG.patchCreateError(e);\n+      }\n+   }\n+\n+   private static boolean compareFileContents(Path path, Path path2) throws IOException {\n+      if (Files.isSameFile(path, path2)) {\n+         return true;\n+      }\n+      byte[] buffer1 = new byte[BUFFER_SIZE];\n+      byte[] buffer2 = new byte[BUFFER_SIZE];\n+      try (InputStream in1 = Files.newInputStream(path);\n+           InputStream in2 = Files.newInputStream(path2);) {\n+         while (true) {\n+            int n1 = in1.read(buffer1);\n+            int n2 = in2.read(buffer2);\n+            if (n1 != n2) {\n+               return false;\n+            }\n+            if (!Arrays.equals(buffer1, buffer2)) {\n+               return false;\n+            }\n+            if (n1 < BUFFER_SIZE) { // EOF and everything is equals\n+               return true;\n+            }\n+         }\n+      }\n+   }\n+\n+   static String sha256(Path path) {\n+      try (InputStream in = Files.newInputStream(path)) {\n+         MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n+         byte[] buffer = new byte[BUFFER_SIZE];\n+         int read = 0;\n+         do {\n+            read = in.read(buffer);\n+            digest.update(buffer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwMTc2MA=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 465}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgzOTIyMw==", "bodyText": "Nice one", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415839223", "createdAt": "2020-04-27T14:02:29Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.size() == 0) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            err.println(MSG.patchValidationErrors());\n+            return;\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (!sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else { // Check contents\n+               try {\n+                  if (!compareFileContents(source.resolve(v1File.getVersionedPath()), target.resolve(targetFile.getVersionedPath()))) {\n+                     operations.add(PatchOperation.replace(targetFile.isSoft(), targetFile.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getDigest(), targetFile.getPermissions()));\n+                     addFileToZip(zipfs, target, targetFile);\n+                  }\n+               } catch (IOException e) {\n+                  throw new RuntimeException(e);\n+               }\n+            }\n+         }\n+      });\n+      targetFiles.forEach((k2, targetFile) -> {\n+         if (!v1Files.containsKey(k2)) {\n+            operations.add(PatchOperation.add(targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+            addFileToZip(zipfs, target, targetFile);\n+         }\n+      });\n+\n+      // Write out the JSON patch file\n+      Path patchPath = zipfs.getPath(\"patch-\" + patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion() + \".json\");\n+      try (OutputStream os = Files.newOutputStream(patchPath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writerWithDefaultPrettyPrinter().writeValue(os, patchInfo);\n+      }\n+   }\n+\n+   private Map<Path, ServerFile> getServerFiles(Path base) throws IOException {\n+      Pattern IGNORE = Pattern.compile(\"^(\\\\.patches/|server/data/|server/log/|server/lib/).*$\");\n+      Pattern SOFT_REPLACE_PATTERN = Pattern.compile(\"^server/conf/.*$\");\n+      Map<Path, ServerFile> files = new TreeMap<>();\n+      Files.walkFileTree(base, new SimpleFileVisitor<Path>() {\n+         @Override\n+         public FileVisitResult visitFile(Path oPath, BasicFileAttributes attrs) {\n+            Path rPath = base.relativize(oPath);\n+            String rPathName = rPath.toString();\n+            if (!IGNORE.matcher(rPathName).matches()) {\n+               ServerFile file = new ServerFile(rPath, sha256(oPath), getPermissions(oPath), SOFT_REPLACE_PATTERN.matcher(rPathName).matches());\n+               files.put(file.getUnversionedPath(), file);\n+            }\n+            return FileVisitResult.CONTINUE;\n+         }\n+      });\n+      return files;\n+   }\n+\n+   private static String getPermissions(Path path) {\n+      try {\n+         return PosixFilePermissions.toString(Files.getPosixFilePermissions(path));\n+      } catch (IOException e) {\n+         throw new RuntimeException(e);\n+      }\n+   }\n+\n+   private List<PatchInfo> getPatchInfos(FileSystem zipfs) throws IOException {\n+      List<Path> paths = Files.find(zipfs.getPath(\"/\"), 1,\n+            (p, a) -> a.isRegularFile() && p.getFileName().toString().startsWith(\"patch-\") && p.getFileName().toString().endsWith(\".json\")\n+      ).collect(Collectors.toList());\n+      List<PatchInfo> infos = new ArrayList<>(paths.size());\n+      for (Path path : paths) {\n+         try (InputStream is = Files.newInputStream(path, StandardOpenOption.READ)) {\n+            infos.add(mapper.readValue(is, PatchInfo.class));\n+         }\n+      }\n+      return infos;\n+   }\n+\n+   private Version getVersion(Path base) throws IOException {\n+      // Load the META-INF/infinispan-version.properties from the lib/infinispan-commons jar\n+      Path lib = base.resolve(\"lib\");\n+      File[] commons = lib.toFile().listFiles((dir, name) -> name.startsWith(\"infinispan-commons-\") && name.endsWith(\".jar\"));\n+      if (commons == null || commons.length != 1) {\n+         throw MSG.patchCannotFindCommons(lib);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + commons[0].toURI().toString());\n+      try (FileSystem zipfs = FileSystems.newFileSystem(jarUri, Collections.emptyMap()); InputStream in = Files.newInputStream(zipfs.getPath(\"META-INF\", \"infinispan-version.properties\"))) {\n+         return Version.from(in);\n+      }\n+   }\n+\n+\n+   private FileSystem getPatchFile(Path patch, boolean create) throws IOException {\n+      if (create && patch.toFile().exists()) {\n+         throw MSG.patchFileAlreadyExists(patch);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + patch.toUri().toString());\n+      return FileSystems.newFileSystem(jarUri, create ? Collections.singletonMap(\"create\", \"true\") : Collections.emptyMap());\n+   }\n+\n+   private FileSystem getPatchFile(Path patch) throws IOException {\n+      return getPatchFile(patch, false);\n+   }\n+\n+   private void addFileToZip(FileSystem zipfs, Path basePath, ServerFile file) {\n+      try {\n+         Path target = zipfs.getPath(file.getVersionedPath().toString());\n+         out.println(MSG.patchCreateAdd(target));\n+         if (target.getParent() != null) {\n+            Files.createDirectories(target.getParent());\n+         }\n+         Files.copy(basePath.resolve(file.getVersionedPath()), target, StandardCopyOption.REPLACE_EXISTING);\n+      } catch (IOException e) {\n+         throw MSG.patchCreateError(e);\n+      }\n+   }\n+\n+   private static boolean compareFileContents(Path path, Path path2) throws IOException {\n+      if (Files.isSameFile(path, path2)) {\n+         return true;\n+      }\n+      byte[] buffer1 = new byte[BUFFER_SIZE];\n+      byte[] buffer2 = new byte[BUFFER_SIZE];\n+      try (InputStream in1 = Files.newInputStream(path);\n+           InputStream in2 = Files.newInputStream(path2);) {\n+         while (true) {\n+            int n1 = in1.read(buffer1);\n+            int n2 = in2.read(buffer2);\n+            if (n1 != n2) {\n+               return false;\n+            }\n+            if (!Arrays.equals(buffer1, buffer2)) {\n+               return false;\n+            }\n+            if (n1 < BUFFER_SIZE) { // EOF and everything is equals\n+               return true;\n+            }\n+         }\n+      }\n+   }\n+\n+   static String sha256(Path path) {\n+      try (InputStream in = Files.newInputStream(path)) {\n+         MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n+         byte[] buffer = new byte[BUFFER_SIZE];\n+         int read = 0;\n+         do {\n+            read = in.read(buffer);\n+            digest.update(buffer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTgwMTc2MA=="}, "originalCommit": {"oid": "06934bfb7021035ccfd0eceb3c92579cc59063c4"}, "originalPosition": 465}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NzgyODgyOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/CliCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzowMjowMlrOGMt6wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzowMjowMlrOGMt6wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4ODQxNw==", "bodyText": "well, I was expecting a new method in org.infinispan.cli.Context[Impl] with [1]  and just invoke invocation.getContext().new_method(e)... but I guess this works as well :)\nTerminalString error = new TerminalString(Util.getRootCause(e).getLocalizedMessage(), new TerminalColor(Color.RED, Color.DEFAULT, Color.Intensity.BRIGHT));\nshell.writeln(error.toString());", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415988417", "createdAt": "2020-04-27T17:02:02Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/CliCommand.java", "diffHunk": "@@ -30,7 +32,17 @@ public CommandResult execute(ContextAwareCommandInvocation invocation) throws Co\n          invocation.println(invocation.getHelpInfo());\n          return CommandResult.SUCCESS;\n       }\n-      return exec(invocation);\n+      try {\n+         return exec(invocation);\n+      } catch (CommandException e) {\n+         invocation.getShell().writeln(ANSI.YELLOW_TEXT + e.getLocalizedMessage() + ANSI.DEFAULT_TEXT);\n+         return CommandResult.FAILURE;\n+      } catch (Throwable e) {\n+         // These are unhandled, show them in red\n+         Throwable cause = Util.getRootCause(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Nzg0NTM5OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/logging/Messages.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzowNTo0NVrOGMuEnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxOToyODowM1rOGNjjew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5MDk0MA==", "bodyText": "I'm wondering if most of these methods should create a CommandException instead of IllegalStateException since we have descriptive messages... WDYT?\nThe exception class doesn't bring anything useful in this case:\n[disconnected]> patch rollback \njava.lang.IllegalStateException: No installed patches to roll back", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415990940", "createdAt": "2020-04-27T17:05:45Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/logging/Messages.java", "diffHunk": "@@ -92,4 +95,64 @@\n \n    @Message(\"Invalid resource '%s'\")\n    IllegalArgumentException invalidResource(String name);\n+\n+   @Message(\"No patches installed\")\n+   String patchNoPatchesInstalled();\n+\n+   @Message(\"%s\")\n+   String patchInfo(PatchInfo patchInfo);\n+\n+   @Message(\"The supplied patch cannot be applied to %s %s\")\n+   IllegalStateException patchCannotApply(String brandName, String version);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg2NzE5NQ==", "bodyText": "I wanted to keep the PatchTool class clean of aesh classes", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416867195", "createdAt": "2020-04-28T19:28:03Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/logging/Messages.java", "diffHunk": "@@ -92,4 +95,64 @@\n \n    @Message(\"Invalid resource '%s'\")\n    IllegalArgumentException invalidResource(String name);\n+\n+   @Message(\"No patches installed\")\n+   String patchNoPatchesInstalled();\n+\n+   @Message(\"%s\")\n+   String patchInfo(PatchInfo patchInfo);\n+\n+   @Message(\"The supplied patch cannot be applied to %s %s\")\n+   IllegalStateException patchCannotApply(String brandName, String version);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5MDk0MA=="}, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Nzg1MDg4OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/patch.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzowNjo0N1rOGMuHtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzowNjo0N1rOGMuHtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5MTczMw==", "bodyText": "the \"path-to-server\" is set via --server option", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415991733", "createdAt": "2020-04-27T17:06:47Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,100 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* `patch-file`\n+\n+*patch describe* `patch-file`\n+\n+*patch rollback*\n+\n+*patch create* `patch-file` `target-server` `source-server-1` [`source-server-2`...]\n+\n+\n+DESCRIPTION\n+-----------\n+Manage (list, describe, install, rollback, create) ${infinispan.brand.name} server patches.\n+Server patches contain a number of artifacts that upgrade a server in order to resolve issues or add new features and is\n+distributed as a zip archive.\n+A single server patch can be used to upgrade multiple server source versions to a specific target version.\n+\n+\n+COMMAND SYNOPSIS\n+----------------\n+\n+List patches installed on a server\n+\n+*patch ls*::\n+Lists the patches currently installed on a server in order of installation.\n+\n+Install a patch on a server\n+\n+*patch install* `patch-file` ['path-to-server']::", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Nzg4MDA3OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/patch.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoxMzoxOVrOGMuZTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoxMzoxOVrOGMuZTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5NjIzOA==", "bodyText": "the italic isn't working\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            *--server=__path-to-server__*::\n          \n          \n            \n            *--server*='path-to-server'::", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415996238", "createdAt": "2020-04-27T17:13:19Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,100 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* `patch-file`\n+\n+*patch describe* `patch-file`\n+\n+*patch rollback*\n+\n+*patch create* `patch-file` `target-server` `source-server-1` [`source-server-2`...]\n+\n+\n+DESCRIPTION\n+-----------\n+Manage (list, describe, install, rollback, create) ${infinispan.brand.name} server patches.\n+Server patches contain a number of artifacts that upgrade a server in order to resolve issues or add new features and is\n+distributed as a zip archive.\n+A single server patch can be used to upgrade multiple server source versions to a specific target version.\n+\n+\n+COMMAND SYNOPSIS\n+----------------\n+\n+List patches installed on a server\n+\n+*patch ls*::\n+Lists the patches currently installed on a server in order of installation.\n+\n+Install a patch on a server\n+\n+*patch install* `patch-file` ['path-to-server']::\n+Installs `patch-file` on a server in the current directory.\n+It is possible to specify a path to the server where the patch should be installed.\n+\n+Describe the contents of a patch archive file\n+\n+*patch describe* `patch-file`::\n+Describes the contents of the specified `patch-file`, i.e. the target version and the list of source versions that are supported.\n+\n+Create a patch file\n+\n+*patch create* `patch-file` `target-server` `source-server-1` [`source-server-2`...]::\n+Creates a patch file\n+\n+Rollback patches\n+\n+*patch rollback*::\n+Rolls back the patch installed last (use the *patch ls* command to show the patches in the order they've been applied)\n+\n+\n+PATCH DESCRIBE OPTIONS\n+----------------------\n+*-v, --verbose*::\n+Shows the content of the patch, including information about individual files\n+\n+\n+PATCH LIST OPTIONS\n+------------------\n+\n+*--server=__path-to-server__*::", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Nzg4MDk4OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/patch.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoxMzozNFrOGMuZ4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoxMzozNFrOGMuZ4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5NjM4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            *--server=__path-to-server__*::\n          \n          \n            \n            *--server*='path-to-server'::", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415996387", "createdAt": "2020-04-27T17:13:34Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,100 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* `patch-file`\n+\n+*patch describe* `patch-file`\n+\n+*patch rollback*\n+\n+*patch create* `patch-file` `target-server` `source-server-1` [`source-server-2`...]\n+\n+\n+DESCRIPTION\n+-----------\n+Manage (list, describe, install, rollback, create) ${infinispan.brand.name} server patches.\n+Server patches contain a number of artifacts that upgrade a server in order to resolve issues or add new features and is\n+distributed as a zip archive.\n+A single server patch can be used to upgrade multiple server source versions to a specific target version.\n+\n+\n+COMMAND SYNOPSIS\n+----------------\n+\n+List patches installed on a server\n+\n+*patch ls*::\n+Lists the patches currently installed on a server in order of installation.\n+\n+Install a patch on a server\n+\n+*patch install* `patch-file` ['path-to-server']::\n+Installs `patch-file` on a server in the current directory.\n+It is possible to specify a path to the server where the patch should be installed.\n+\n+Describe the contents of a patch archive file\n+\n+*patch describe* `patch-file`::\n+Describes the contents of the specified `patch-file`, i.e. the target version and the list of source versions that are supported.\n+\n+Create a patch file\n+\n+*patch create* `patch-file` `target-server` `source-server-1` [`source-server-2`...]::\n+Creates a patch file\n+\n+Rollback patches\n+\n+*patch rollback*::\n+Rolls back the patch installed last (use the *patch ls* command to show the patches in the order they've been applied)\n+\n+\n+PATCH DESCRIBE OPTIONS\n+----------------------\n+*-v, --verbose*::\n+Shows the content of the patch, including information about individual files\n+\n+\n+PATCH LIST OPTIONS\n+------------------\n+\n+*--server=__path-to-server__*::\n+The path to the server if it is in a different location than the current `ISPN_HOME`\n+\n+*-v, --verbose*::\n+Shows the content of each installed patch, including information about individual files\n+\n+\n+\n+PATCH CREATE OPTIONS\n+--------------------\n+*-q, --qualifier*='name'::\n+Specifies a description qualifier string for the patch, e.g. `one-off for issue nnnn`\n+\n+\n+PATCH INSTALL OPTIONS\n+---------------------\n+*--dry-run*::\n+Shows the operations that will be performed but doesn't actually apply them\n+\n+*--server=__path-to-server__*::\n+The path to the server if it is in a different location than the current `ISPN_HOME`\n+\n+\n+PATCH ROLLBACK OPTIONS\n+---------------------\n+*--dry-run*::\n+Shows the operations that will be performed but doesn't actually apply them\n+\n+*--server=__path-to-server__*::", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4Nzg4MTcxOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/patch.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoxMzo0MlrOGMuaRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoxMzo0MlrOGMuaRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5NjQ4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            *--server=__path-to-server__*::\n          \n          \n            \n            *--server*='path-to-server'::", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415996486", "createdAt": "2020-04-27T17:13:42Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,100 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* `patch-file`\n+\n+*patch describe* `patch-file`\n+\n+*patch rollback*\n+\n+*patch create* `patch-file` `target-server` `source-server-1` [`source-server-2`...]\n+\n+\n+DESCRIPTION\n+-----------\n+Manage (list, describe, install, rollback, create) ${infinispan.brand.name} server patches.\n+Server patches contain a number of artifacts that upgrade a server in order to resolve issues or add new features and is\n+distributed as a zip archive.\n+A single server patch can be used to upgrade multiple server source versions to a specific target version.\n+\n+\n+COMMAND SYNOPSIS\n+----------------\n+\n+List patches installed on a server\n+\n+*patch ls*::\n+Lists the patches currently installed on a server in order of installation.\n+\n+Install a patch on a server\n+\n+*patch install* `patch-file` ['path-to-server']::\n+Installs `patch-file` on a server in the current directory.\n+It is possible to specify a path to the server where the patch should be installed.\n+\n+Describe the contents of a patch archive file\n+\n+*patch describe* `patch-file`::\n+Describes the contents of the specified `patch-file`, i.e. the target version and the list of source versions that are supported.\n+\n+Create a patch file\n+\n+*patch create* `patch-file` `target-server` `source-server-1` [`source-server-2`...]::\n+Creates a patch file\n+\n+Rollback patches\n+\n+*patch rollback*::\n+Rolls back the patch installed last (use the *patch ls* command to show the patches in the order they've been applied)\n+\n+\n+PATCH DESCRIBE OPTIONS\n+----------------------\n+*-v, --verbose*::\n+Shows the content of the patch, including information about individual files\n+\n+\n+PATCH LIST OPTIONS\n+------------------\n+\n+*--server=__path-to-server__*::\n+The path to the server if it is in a different location than the current `ISPN_HOME`\n+\n+*-v, --verbose*::\n+Shows the content of each installed patch, including information about individual files\n+\n+\n+\n+PATCH CREATE OPTIONS\n+--------------------\n+*-q, --qualifier*='name'::\n+Specifies a description qualifier string for the patch, e.g. `one-off for issue nnnn`\n+\n+\n+PATCH INSTALL OPTIONS\n+---------------------\n+*--dry-run*::\n+Shows the operations that will be performed but doesn't actually apply them\n+\n+*--server=__path-to-server__*::", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NzkwMTk0OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/patch.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoxODowMlrOGMumMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoxODowMlrOGMumMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5OTUzNw==", "bodyText": "PATCH CREATE OPTIONS isn't shown. It is because of an extra new line above,", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r415999537", "createdAt": "2020-04-27T17:18:02Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,100 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* `patch-file`\n+\n+*patch describe* `patch-file`\n+\n+*patch rollback*\n+\n+*patch create* `patch-file` `target-server` `source-server-1` [`source-server-2`...]\n+\n+\n+DESCRIPTION\n+-----------\n+Manage (list, describe, install, rollback, create) ${infinispan.brand.name} server patches.\n+Server patches contain a number of artifacts that upgrade a server in order to resolve issues or add new features and is\n+distributed as a zip archive.\n+A single server patch can be used to upgrade multiple server source versions to a specific target version.\n+\n+\n+COMMAND SYNOPSIS\n+----------------\n+\n+List patches installed on a server\n+\n+*patch ls*::\n+Lists the patches currently installed on a server in order of installation.\n+\n+Install a patch on a server\n+\n+*patch install* `patch-file` ['path-to-server']::\n+Installs `patch-file` on a server in the current directory.\n+It is possible to specify a path to the server where the patch should be installed.\n+\n+Describe the contents of a patch archive file\n+\n+*patch describe* `patch-file`::\n+Describes the contents of the specified `patch-file`, i.e. the target version and the list of source versions that are supported.\n+\n+Create a patch file\n+\n+*patch create* `patch-file` `target-server` `source-server-1` [`source-server-2`...]::\n+Creates a patch file\n+\n+Rollback patches\n+\n+*patch rollback*::\n+Rolls back the patch installed last (use the *patch ls* command to show the patches in the order they've been applied)\n+\n+\n+PATCH DESCRIBE OPTIONS\n+----------------------\n+*-v, --verbose*::\n+Shows the content of the patch, including information about individual files\n+\n+\n+PATCH LIST OPTIONS\n+------------------\n+\n+*--server=__path-to-server__*::\n+The path to the server if it is in a different location than the current `ISPN_HOME`\n+\n+*-v, --verbose*::\n+Shows the content of each installed patch, including information about individual files\n+\n+\n+\n+PATCH CREATE OPTIONS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NzkxMTMwOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Patch.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoyMDoxNFrOGMur4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoyMDoxNFrOGMur4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwMDk5NQ==", "bodyText": "nitpick:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Path sources[] = new Path[paths.size() - 2];\n          \n          \n            \n                        Path[] sources = new Path[paths.size() - 2];", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416000995", "createdAt": "2020-04-27T17:20:14Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/commands/Patch.java", "diffHunk": "@@ -0,0 +1,179 @@\n+package org.infinispan.cli.commands;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import org.aesh.command.Command;\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.impl.completer.FileOptionCompleter;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Arguments;\n+import org.aesh.command.option.Option;\n+import org.aesh.io.Resource;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.patching.PatchTool;\n+import org.kohsuke.MetaInfServices;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+@MetaInfServices(Command.class)\n+@GroupCommandDefinition(name = Patch.CMD, description = \"Patch operations\", groupCommands = {Patch.Create.class, Patch.Describe.class, Patch.Install.class, Patch.Ls.class, Patch.Rollback.class})\n+public class Patch extends CliCommand {\n+\n+   public static final String CMD = \"patch\";\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      // This command serves only to wrap the sub-commands\n+      invocation.println(invocation.getHelpInfo());\n+      return CommandResult.SUCCESS;\n+   }\n+\n+   @CommandDefinition(name = Create.CMD, description = \"Creates a patch archive\")\n+   public static class Create extends CliCommand {\n+      public static final String CMD = \"create\";\n+\n+      @Option(defaultValue = \"\", shortName = 'q', description = \"A qualifier for this patch (e.g. `one-off`)\")\n+      String qualifier;\n+\n+      @Arguments(completer = FileOptionCompleter.class, description = \"The path to the patch archive, the path to the target server and one or more paths to the source servers\")\n+      List<Resource> paths;\n+\n+      @Override\n+      public CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         if (paths == null || paths.size() < 3) {\n+            throw Messages.MSG.patchCreateArgumentsRequired();\n+         }\n+         PatchTool patchTool = new PatchTool(invocation.getShellOutput(), invocation.getShellError());\n+         try {\n+            Path patch = Paths.get(paths.get(0).getAbsolutePath());\n+            Path target = Paths.get(paths.get(1).getAbsolutePath());\n+            Path sources[] = new Path[paths.size() - 2];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NzkyMDc5OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoyMjoyM1rOGMuxhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoyMjoyM1rOGMuxhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwMjQzOQ==", "bodyText": "unused", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416002439", "createdAt": "2020-04-27T17:22:23Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,444 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4NzkyMjQwOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoyMjo0NVrOGMuymw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwNzowNjo0M1rOGNFwow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwMjcxNQ==", "bodyText": "not used anymore, but I guess we can keep it... up to you.", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416002715", "createdAt": "2020-04-27T17:22:45Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,444 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM3OTA0Mw==", "bodyText": "Yes, I'm going to use it soon.", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416379043", "createdAt": "2020-04-28T07:06:43Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,444 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAwMjcxNQ=="}, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODAyODAxOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzo0MzowN1rOGMvu9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwNzowNzowOFrOGNFxew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxODE2NQ==", "bodyText": "shouldn't be compared with the \"new\" digest?\nwhat about the files that weren't replaced? The ones created by file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());.", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416018165", "createdAt": "2020-04-27T17:43:07Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,444 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256 != null && sha256.equals(operation.getDigest())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM3OTI1OQ==", "bodyText": "Well spotted. There was also a break missing from this switch.", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416379259", "createdAt": "2020-04-28T07:07:08Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,444 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256 != null && sha256.equals(operation.getDigest())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxODE2NQ=="}, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 238}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODAzNDIxOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzo0NDoyM1rOGMvygA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwNjo0MDozNlrOGNE9SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxOTA3Mg==", "bodyText": "shouldn't the file be \"downgraded\"?", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416019072", "createdAt": "2020-04-27T17:44:23Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,444 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256 != null && sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjM2NTg5Nw==", "bodyText": "Notice that it falls-through to the next case", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416365897", "createdAt": "2020-04-28T06:40:36Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,444 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256 != null && sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAxOTA3Mg=="}, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 249}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODA0ODc4OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzo0NzoxOFrOGMv67Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzo0NzoxOFrOGMv67Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAyMTIyOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                           if (v1File.getDigest() != targetFile.getDigest()) {\n          \n          \n            \n                           if (!v1File.getDigest().equals(targetFile.getDigest())) {", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416021229", "createdAt": "2020-04-27T17:47:18Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,444 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256 != null && sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else { // Check contents\n+               if (v1File.getDigest() != targetFile.getDigest()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 331}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4ODA1NzkyOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzo0OToyM1rOGMwAdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzo0OToyM1rOGMwAdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAyMjY0Nw==", "bodyText": "nitpicl: } else if ... {", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416022647", "createdAt": "2020-04-27T17:49:23Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,444 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256 != null && sha256.equals(operation.getDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else { // Check contents", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9703bf5f43a9d021ff0b4bd6a9f11f00523b6245"}, "originalPosition": 330}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzIyMzIzOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzo0Mjo1N1rOGNfqkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzo0Mjo1N1rOGNfqkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgwMzQ3NA==", "bodyText": "you can use BUFFER_SIZE. it is already defined.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        ByteBuffer bb = ByteBuffer.allocate(4096);\n          \n          \n            \n                        ByteBuffer bb = ByteBuffer.allocate(BUFFER_SIZE);", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416803474", "createdAt": "2020-04-28T17:42:57Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.ByteChannel;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         // Scan the patch to ensure its contents match with the list of operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(zipfs.getPath(operation.getNewPath().toString()));\n+                  if (sha256 == null || !sha256.equals(operation.getNewDigest())) {\n+                     errors.add(MSG.patchCorruptArchive(operation));\n+                  }\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // Scan the server files to ensure that the patch can be installed\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256 != null && sha256.equals(operation.getNewDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+               // We might have created a side-file, remove it\n+               file = target.resolve(operation.getNewPath());\n+               file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+               Files.deleteIfExists(file);\n+               break;\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else if (!v1File.getDigest().equals(targetFile.getDigest())) {\n+               // Check contents\n+               operations.add(PatchOperation.replace(targetFile.isSoft(), targetFile.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            }\n+         }\n+      });\n+      targetFiles.forEach((k2, targetFile) -> {\n+         if (!v1Files.containsKey(k2)) {\n+            operations.add(PatchOperation.add(targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+            addFileToZip(zipfs, target, targetFile);\n+         }\n+      });\n+\n+      // Write out the JSON patch file\n+      Path patchPath = zipfs.getPath(\"patch-\" + patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion() + \".json\");\n+      try (OutputStream os = Files.newOutputStream(patchPath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writerWithDefaultPrettyPrinter().writeValue(os, patchInfo);\n+      }\n+   }\n+\n+   private Map<Path, ServerFile> getServerFiles(Path base) throws IOException {\n+      Pattern IGNORE = Pattern.compile(\"^(\\\\.patches/|server/data/|server/log/|server/lib/).*$\");\n+      Pattern SOFT_REPLACE_PATTERN = Pattern.compile(\"^server/conf/.*$\");\n+      Map<Path, ServerFile> files = new TreeMap<>();\n+      Files.walkFileTree(base, new SimpleFileVisitor<Path>() {\n+         @Override\n+         public FileVisitResult visitFile(Path oPath, BasicFileAttributes attrs) {\n+            Path rPath = base.relativize(oPath);\n+            String rPathName = rPath.toString();\n+            if (!IGNORE.matcher(rPathName).matches()) {\n+               ServerFile file = new ServerFile(rPath, sha256(oPath), getPermissions(oPath), SOFT_REPLACE_PATTERN.matcher(rPathName).matches());\n+               files.put(file.getUnversionedPath(), file);\n+            }\n+            return FileVisitResult.CONTINUE;\n+         }\n+      });\n+      return files;\n+   }\n+\n+   private static String getPermissions(Path path) {\n+      try {\n+         return PosixFilePermissions.toString(Files.getPosixFilePermissions(path));\n+      } catch (IOException e) {\n+         throw new RuntimeException(e);\n+      }\n+   }\n+\n+   private List<PatchInfo> getPatchInfos(FileSystem zipfs) throws IOException {\n+      List<Path> paths = Files.find(zipfs.getPath(\"/\"), 1,\n+            (p, a) -> a.isRegularFile() && p.getFileName().toString().startsWith(\"patch-\") && p.getFileName().toString().endsWith(\".json\")\n+      ).collect(Collectors.toList());\n+      List<PatchInfo> infos = new ArrayList<>(paths.size());\n+      for (Path path : paths) {\n+         try (InputStream is = Files.newInputStream(path, StandardOpenOption.READ)) {\n+            infos.add(mapper.readValue(is, PatchInfo.class));\n+         }\n+      }\n+      return infos;\n+   }\n+\n+   private Version getVersion(Path base) throws IOException {\n+      // Load the META-INF/infinispan-version.properties from the lib/infinispan-commons jar\n+      Path lib = base.resolve(\"lib\");\n+      File[] commons = lib.toFile().listFiles((dir, name) -> name.startsWith(\"infinispan-commons-\") && name.endsWith(\".jar\"));\n+      if (commons == null || commons.length != 1) {\n+         throw MSG.patchCannotFindCommons(lib);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + commons[0].toURI().toString());\n+      try (FileSystem zipfs = FileSystems.newFileSystem(jarUri, Collections.emptyMap()); InputStream in = Files.newInputStream(zipfs.getPath(\"META-INF\", \"infinispan-version.properties\"))) {\n+         return Version.from(in);\n+      }\n+   }\n+\n+\n+   private FileSystem getPatchFile(Path patch, boolean create) throws IOException {\n+      if (create && patch.toFile().exists()) {\n+         throw MSG.patchFileAlreadyExists(patch);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + patch.toUri().toString());\n+      return FileSystems.newFileSystem(jarUri, create ? Collections.singletonMap(\"create\", \"true\") : Collections.emptyMap());\n+   }\n+\n+   private FileSystem getPatchFile(Path patch) throws IOException {\n+      return getPatchFile(patch, false);\n+   }\n+\n+   private void addFileToZip(FileSystem zipfs, Path basePath, ServerFile file) {\n+      try {\n+         Path target = zipfs.getPath(file.getVersionedPath().toString());\n+         out.println(MSG.patchCreateAdd(target));\n+         if (target.getParent() != null) {\n+            Files.createDirectories(target.getParent());\n+         }\n+         Files.copy(basePath.resolve(file.getVersionedPath()), target, StandardCopyOption.REPLACE_EXISTING);\n+      } catch (IOException e) {\n+         throw MSG.patchCreateError(e);\n+      }\n+   }\n+\n+   static String sha256(Path path) {\n+      try (ByteChannel channel = Files.newByteChannel(path, StandardOpenOption.READ)) {\n+         MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n+         if (channel instanceof FileChannel) {\n+            FileChannel fileChannel = (FileChannel) channel;\n+            MappedByteBuffer byteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size());\n+            digest.update(byteBuffer);\n+         } else {\n+            ByteBuffer bb = ByteBuffer.allocate(4096);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed74f7cc9585d72efd96a12ff9de80f311a9c4ee"}, "originalPosition": 462}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzIyNjEzOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzo0Mzo0MVrOGNfsYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzo0Mzo0MVrOGNfsYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgwMzkzOQ==", "bodyText": "I think you need to flip() the buffer before reading again\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                           digest.update(bb.flip());\n          \n          \n            \n                           bb.flip();\n          \n          \n            \n                           digest.update(bb);\n          \n          \n            \n                           bb.flip();", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416803939", "createdAt": "2020-04-28T17:43:41Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.ByteChannel;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         // Scan the patch to ensure its contents match with the list of operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(zipfs.getPath(operation.getNewPath().toString()));\n+                  if (sha256 == null || !sha256.equals(operation.getNewDigest())) {\n+                     errors.add(MSG.patchCorruptArchive(operation));\n+                  }\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // Scan the server files to ensure that the patch can be installed\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256 != null && sha256.equals(operation.getNewDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+               // We might have created a side-file, remove it\n+               file = target.resolve(operation.getNewPath());\n+               file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+               Files.deleteIfExists(file);\n+               break;\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            // Fall through to add the backed-up file\n+            case REMOVE:\n+            case HARD_REPLACE: {\n+               Path file = target.resolve(operation.getPath());\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+               }\n+            }\n+            break;\n+         }\n+      }\n+      if (!dryRun) {\n+         writeInstalledPatches(target, installedPatches);\n+      }\n+      println(dryRun, MSG.patchRollback(patchInfo));\n+   }\n+\n+   private void println(boolean dryRun, String msg) {\n+      if (dryRun) {\n+         out.print(MSG.patchDryRun());\n+      }\n+      out.println(msg);\n+   }\n+\n+   private Path getBackupPath(Path target, PatchInfo patchInfo) {\n+      return target.resolve(PATCHES_DIR).resolve(patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion());\n+   }\n+\n+   private List<PatchInfo> getInstalledPatches(Path target) {\n+      Path patchesFile = target.resolve(PATCHES_DIR).resolve(PATCHES_FILE);\n+      try (InputStream is = Files.newInputStream(patchesFile, StandardOpenOption.READ)) {\n+         JavaType patchInfoList = mapper.getTypeFactory().constructCollectionType(List.class, PatchInfo.class);\n+         return mapper.readValue(is, patchInfoList);\n+      } catch (NoSuchFileException e) {\n+         return new ArrayList<>();\n+      } catch (IOException e) {\n+         throw MSG.patchCannotRead(patchesFile, e);\n+      }\n+   }\n+\n+   private void writeInstalledPatches(Path target, List<PatchInfo> patches) {\n+      try (OutputStream os = Files.newOutputStream(Files.createDirectories(target.resolve(PATCHES_DIR)).resolve(PATCHES_FILE), StandardOpenOption.WRITE, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writeValue(os, patches);\n+      } catch (IOException e) {\n+         throw MSG.patchCannotWritePatchesFile(e);\n+      }\n+   }\n+\n+   private void createSinglePatch(String qualifier, Path source, Path target, Version targetVersion, Map<Path, ServerFile> targetFiles, FileSystem zipfs) throws IOException {\n+      Version sourceVersion = getVersion(source);\n+\n+      // Ensure that the brand name coincides\n+      String sourceBrand = sourceVersion.brandName();\n+      String targetBrand = targetVersion.brandName();\n+      if (!sourceBrand.equals(targetBrand)) {\n+         throw MSG.patchIncompatibleProduct(sourceBrand, targetBrand);\n+      }\n+\n+      if (sourceVersion.version().equals(targetVersion.version())) {\n+         throw MSG.patchServerAndTargetMustBeDifferent(sourceVersion.version());\n+      }\n+\n+      PatchInfo patchInfo = new PatchInfo(sourceBrand, sourceVersion.version(), targetVersion.version(), qualifier);\n+\n+      // Build a list of files in the old version\n+      Map<Path, ServerFile> v1Files = getServerFiles(source);\n+\n+      // Compare the two file lists, generating a list of upgrade instructions\n+      List<PatchOperation> operations = patchInfo.getOperations();\n+      v1Files.forEach((k1, v1File) -> {\n+         if (!targetFiles.containsKey(k1)) {\n+            operations.add(PatchOperation.remove(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions()));\n+         } else {\n+            ServerFile targetFile = targetFiles.get(k1);\n+            if (!v1File.getFilename().equals(targetFile.getFilename())) { // Different filename means upgrade\n+               operations.add(PatchOperation.upgrade(v1File.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            } else if (!v1File.getDigest().equals(targetFile.getDigest())) {\n+               // Check contents\n+               operations.add(PatchOperation.replace(targetFile.isSoft(), targetFile.getVersionedPath(), v1File.getDigest(), v1File.getPermissions(), targetFile.getDigest(), targetFile.getPermissions()));\n+               addFileToZip(zipfs, target, targetFile);\n+            }\n+         }\n+      });\n+      targetFiles.forEach((k2, targetFile) -> {\n+         if (!v1Files.containsKey(k2)) {\n+            operations.add(PatchOperation.add(targetFile.getVersionedPath(), targetFile.getDigest(), targetFile.getPermissions()));\n+            addFileToZip(zipfs, target, targetFile);\n+         }\n+      });\n+\n+      // Write out the JSON patch file\n+      Path patchPath = zipfs.getPath(\"patch-\" + patchInfo.getSourceVersion() + \"_\" + patchInfo.getTargetVersion() + \".json\");\n+      try (OutputStream os = Files.newOutputStream(patchPath, StandardOpenOption.CREATE, StandardOpenOption.TRUNCATE_EXISTING)) {\n+         mapper.writerWithDefaultPrettyPrinter().writeValue(os, patchInfo);\n+      }\n+   }\n+\n+   private Map<Path, ServerFile> getServerFiles(Path base) throws IOException {\n+      Pattern IGNORE = Pattern.compile(\"^(\\\\.patches/|server/data/|server/log/|server/lib/).*$\");\n+      Pattern SOFT_REPLACE_PATTERN = Pattern.compile(\"^server/conf/.*$\");\n+      Map<Path, ServerFile> files = new TreeMap<>();\n+      Files.walkFileTree(base, new SimpleFileVisitor<Path>() {\n+         @Override\n+         public FileVisitResult visitFile(Path oPath, BasicFileAttributes attrs) {\n+            Path rPath = base.relativize(oPath);\n+            String rPathName = rPath.toString();\n+            if (!IGNORE.matcher(rPathName).matches()) {\n+               ServerFile file = new ServerFile(rPath, sha256(oPath), getPermissions(oPath), SOFT_REPLACE_PATTERN.matcher(rPathName).matches());\n+               files.put(file.getUnversionedPath(), file);\n+            }\n+            return FileVisitResult.CONTINUE;\n+         }\n+      });\n+      return files;\n+   }\n+\n+   private static String getPermissions(Path path) {\n+      try {\n+         return PosixFilePermissions.toString(Files.getPosixFilePermissions(path));\n+      } catch (IOException e) {\n+         throw new RuntimeException(e);\n+      }\n+   }\n+\n+   private List<PatchInfo> getPatchInfos(FileSystem zipfs) throws IOException {\n+      List<Path> paths = Files.find(zipfs.getPath(\"/\"), 1,\n+            (p, a) -> a.isRegularFile() && p.getFileName().toString().startsWith(\"patch-\") && p.getFileName().toString().endsWith(\".json\")\n+      ).collect(Collectors.toList());\n+      List<PatchInfo> infos = new ArrayList<>(paths.size());\n+      for (Path path : paths) {\n+         try (InputStream is = Files.newInputStream(path, StandardOpenOption.READ)) {\n+            infos.add(mapper.readValue(is, PatchInfo.class));\n+         }\n+      }\n+      return infos;\n+   }\n+\n+   private Version getVersion(Path base) throws IOException {\n+      // Load the META-INF/infinispan-version.properties from the lib/infinispan-commons jar\n+      Path lib = base.resolve(\"lib\");\n+      File[] commons = lib.toFile().listFiles((dir, name) -> name.startsWith(\"infinispan-commons-\") && name.endsWith(\".jar\"));\n+      if (commons == null || commons.length != 1) {\n+         throw MSG.patchCannotFindCommons(lib);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + commons[0].toURI().toString());\n+      try (FileSystem zipfs = FileSystems.newFileSystem(jarUri, Collections.emptyMap()); InputStream in = Files.newInputStream(zipfs.getPath(\"META-INF\", \"infinispan-version.properties\"))) {\n+         return Version.from(in);\n+      }\n+   }\n+\n+\n+   private FileSystem getPatchFile(Path patch, boolean create) throws IOException {\n+      if (create && patch.toFile().exists()) {\n+         throw MSG.patchFileAlreadyExists(patch);\n+      }\n+      URI jarUri = URI.create(\"jar:\" + patch.toUri().toString());\n+      return FileSystems.newFileSystem(jarUri, create ? Collections.singletonMap(\"create\", \"true\") : Collections.emptyMap());\n+   }\n+\n+   private FileSystem getPatchFile(Path patch) throws IOException {\n+      return getPatchFile(patch, false);\n+   }\n+\n+   private void addFileToZip(FileSystem zipfs, Path basePath, ServerFile file) {\n+      try {\n+         Path target = zipfs.getPath(file.getVersionedPath().toString());\n+         out.println(MSG.patchCreateAdd(target));\n+         if (target.getParent() != null) {\n+            Files.createDirectories(target.getParent());\n+         }\n+         Files.copy(basePath.resolve(file.getVersionedPath()), target, StandardCopyOption.REPLACE_EXISTING);\n+      } catch (IOException e) {\n+         throw MSG.patchCreateError(e);\n+      }\n+   }\n+\n+   static String sha256(Path path) {\n+      try (ByteChannel channel = Files.newByteChannel(path, StandardOpenOption.READ)) {\n+         MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n+         if (channel instanceof FileChannel) {\n+            FileChannel fileChannel = (FileChannel) channel;\n+            MappedByteBuffer byteBuffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, 0, fileChannel.size());\n+            digest.update(byteBuffer);\n+         } else {\n+            ByteBuffer bb = ByteBuffer.allocate(4096);\n+            while (channel.read(bb) != -1) {\n+               digest.update(bb.flip());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed74f7cc9585d72efd96a12ff9de80f311a9c4ee"}, "originalPosition": 464}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzI1ODM3OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/patch.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzo1MTo0MFrOGNgAMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzo1MTo0MFrOGNgAMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgwOTAxMQ==", "bodyText": "Rollback is missing from help patch. A - is missing.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            PATCH ROLLBACK OPTIONS\n          \n          \n            \n            ---------------------\n          \n          \n            \n            PATCH ROLLBACK OPTIONS\n          \n          \n            \n            ----------------------", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416809011", "createdAt": "2020-04-28T17:51:40Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,103 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* 'patch-file'\n+\n+*patch describe* 'patch-file'\n+\n+*patch rollback*\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]\n+\n+\n+DESCRIPTION\n+-----------\n+Manage (list, describe, install, rollback, create) ${infinispan.brand.name} server patches.\n+Server patches contain a number of artifacts that upgrade a server in order to resolve issues or add new features and is\n+distributed as a zip archive.\n+A single server patch can be used to upgrade multiple server source versions to a specific target version.\n+\n+\n+COMMAND SYNOPSIS\n+----------------\n+\n+List patches installed on a server\n+\n+*patch ls*::\n+Lists the patches currently installed on a server in order of installation.\n+\n+Install a patch on a server\n+\n+*patch install* 'patch-file'::\n+Installs 'patch-file' on a server in the current directory.\n+It is possible to specify a path to the server where the patch should be installed.\n+\n+Describe the contents of a patch archive file\n+\n+*patch describe* 'patch-file'::\n+Describes the contents of the specified 'patch-file', i.e. the target version and the list of source versions that are supported.\n+\n+Create a patch file\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]::\n+Creates a patch file\n+\n+Rollback patches\n+\n+*patch rollback*::\n+Rolls back the patch installed last (use the *patch ls* command to show the patches in the order they've been applied)\n+\n+\n+PATCH DESCRIBE OPTIONS\n+----------------------\n+\n+*-v, --verbose*::\n+Shows the content of the patch, including information about individual files\n+\n+\n+PATCH LIST OPTIONS\n+------------------\n+\n+*--server='path-to-server'*::\n+The path to the server if it is in a different location than the current 'ISPN_HOME'\n+\n+*-v, --verbose*::\n+Shows the content of each installed patch, including information about individual files\n+\n+\n+PATCH CREATE OPTIONS\n+--------------------\n+\n+*-q, --qualifier*='name'::\n+Specifies a description qualifier string for the patch, e.g. 'one-off for issue nnnn'\n+\n+\n+PATCH INSTALL OPTIONS\n+---------------------\n+\n+*--dry-run*::\n+Shows the operations that will be performed but doesn't actually apply them\n+\n+*--server='path-to-server'*::\n+The path to the server if it is in a different location than the current 'ISPN_HOME'\n+\n+\n+PATCH ROLLBACK OPTIONS\n+---------------------", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed74f7cc9585d72efd96a12ff9de80f311a9c4ee"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzI1OTc0OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/patch.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzo1MjowM1rOGNgBCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzo1MjowM1rOGNgBCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgwOTIyNw==", "bodyText": "nitpick\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            *--server='path-to-server'*::\n          \n          \n            \n            *--server*='path-to-server'::", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416809227", "createdAt": "2020-04-28T17:52:03Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,103 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* 'patch-file'\n+\n+*patch describe* 'patch-file'\n+\n+*patch rollback*\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]\n+\n+\n+DESCRIPTION\n+-----------\n+Manage (list, describe, install, rollback, create) ${infinispan.brand.name} server patches.\n+Server patches contain a number of artifacts that upgrade a server in order to resolve issues or add new features and is\n+distributed as a zip archive.\n+A single server patch can be used to upgrade multiple server source versions to a specific target version.\n+\n+\n+COMMAND SYNOPSIS\n+----------------\n+\n+List patches installed on a server\n+\n+*patch ls*::\n+Lists the patches currently installed on a server in order of installation.\n+\n+Install a patch on a server\n+\n+*patch install* 'patch-file'::\n+Installs 'patch-file' on a server in the current directory.\n+It is possible to specify a path to the server where the patch should be installed.\n+\n+Describe the contents of a patch archive file\n+\n+*patch describe* 'patch-file'::\n+Describes the contents of the specified 'patch-file', i.e. the target version and the list of source versions that are supported.\n+\n+Create a patch file\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]::\n+Creates a patch file\n+\n+Rollback patches\n+\n+*patch rollback*::\n+Rolls back the patch installed last (use the *patch ls* command to show the patches in the order they've been applied)\n+\n+\n+PATCH DESCRIBE OPTIONS\n+----------------------\n+\n+*-v, --verbose*::\n+Shows the content of the patch, including information about individual files\n+\n+\n+PATCH LIST OPTIONS\n+------------------\n+\n+*--server='path-to-server'*::\n+The path to the server if it is in a different location than the current 'ISPN_HOME'\n+\n+*-v, --verbose*::\n+Shows the content of each installed patch, including information about individual files\n+\n+\n+PATCH CREATE OPTIONS\n+--------------------\n+\n+*-q, --qualifier*='name'::\n+Specifies a description qualifier string for the patch, e.g. 'one-off for issue nnnn'\n+\n+\n+PATCH INSTALL OPTIONS\n+---------------------\n+\n+*--dry-run*::\n+Shows the operations that will be performed but doesn't actually apply them\n+\n+*--server='path-to-server'*::\n+The path to the server if it is in a different location than the current 'ISPN_HOME'\n+\n+\n+PATCH ROLLBACK OPTIONS\n+---------------------\n+\n+*--dry-run*::\n+Shows the operations that will be performed but doesn't actually apply them\n+\n+*--server='path-to-server'*::", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed74f7cc9585d72efd96a12ff9de80f311a9c4ee"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzI2MDE4OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/patch.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzo1MjoxMFrOGNgBSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzo1MjoxMFrOGNgBSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgwOTI5MQ==", "bodyText": "nitpick\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            *--server='path-to-server'*::\n          \n          \n            \n            *--server*='path-to-server'::", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416809291", "createdAt": "2020-04-28T17:52:10Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,103 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* 'patch-file'\n+\n+*patch describe* 'patch-file'\n+\n+*patch rollback*\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]\n+\n+\n+DESCRIPTION\n+-----------\n+Manage (list, describe, install, rollback, create) ${infinispan.brand.name} server patches.\n+Server patches contain a number of artifacts that upgrade a server in order to resolve issues or add new features and is\n+distributed as a zip archive.\n+A single server patch can be used to upgrade multiple server source versions to a specific target version.\n+\n+\n+COMMAND SYNOPSIS\n+----------------\n+\n+List patches installed on a server\n+\n+*patch ls*::\n+Lists the patches currently installed on a server in order of installation.\n+\n+Install a patch on a server\n+\n+*patch install* 'patch-file'::\n+Installs 'patch-file' on a server in the current directory.\n+It is possible to specify a path to the server where the patch should be installed.\n+\n+Describe the contents of a patch archive file\n+\n+*patch describe* 'patch-file'::\n+Describes the contents of the specified 'patch-file', i.e. the target version and the list of source versions that are supported.\n+\n+Create a patch file\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]::\n+Creates a patch file\n+\n+Rollback patches\n+\n+*patch rollback*::\n+Rolls back the patch installed last (use the *patch ls* command to show the patches in the order they've been applied)\n+\n+\n+PATCH DESCRIBE OPTIONS\n+----------------------\n+\n+*-v, --verbose*::\n+Shows the content of the patch, including information about individual files\n+\n+\n+PATCH LIST OPTIONS\n+------------------\n+\n+*--server='path-to-server'*::\n+The path to the server if it is in a different location than the current 'ISPN_HOME'\n+\n+*-v, --verbose*::\n+Shows the content of each installed patch, including information about individual files\n+\n+\n+PATCH CREATE OPTIONS\n+--------------------\n+\n+*-q, --qualifier*='name'::\n+Specifies a description qualifier string for the patch, e.g. 'one-off for issue nnnn'\n+\n+\n+PATCH INSTALL OPTIONS\n+---------------------\n+\n+*--dry-run*::\n+Shows the operations that will be performed but doesn't actually apply them\n+\n+*--server='path-to-server'*::", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed74f7cc9585d72efd96a12ff9de80f311a9c4ee"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzI2MDk4OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/patch.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzo1MjoxOVrOGNgBwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzo1MjoxOVrOGNgBwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgwOTQwOQ==", "bodyText": "nitpick\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            *--server='path-to-server'*::\n          \n          \n            \n            *--server*='path-to-server'::", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416809409", "createdAt": "2020-04-28T17:52:19Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/resources/help/patch.adoc", "diffHunk": "@@ -0,0 +1,103 @@\n+PATCH(1)\n+========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+patch - manages ${infinispan.brand.name} server patches.\n+\n+\n+SYNOPSIS\n+--------\n+*patch ls*\n+\n+*patch install* 'patch-file'\n+\n+*patch describe* 'patch-file'\n+\n+*patch rollback*\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]\n+\n+\n+DESCRIPTION\n+-----------\n+Manage (list, describe, install, rollback, create) ${infinispan.brand.name} server patches.\n+Server patches contain a number of artifacts that upgrade a server in order to resolve issues or add new features and is\n+distributed as a zip archive.\n+A single server patch can be used to upgrade multiple server source versions to a specific target version.\n+\n+\n+COMMAND SYNOPSIS\n+----------------\n+\n+List patches installed on a server\n+\n+*patch ls*::\n+Lists the patches currently installed on a server in order of installation.\n+\n+Install a patch on a server\n+\n+*patch install* 'patch-file'::\n+Installs 'patch-file' on a server in the current directory.\n+It is possible to specify a path to the server where the patch should be installed.\n+\n+Describe the contents of a patch archive file\n+\n+*patch describe* 'patch-file'::\n+Describes the contents of the specified 'patch-file', i.e. the target version and the list of source versions that are supported.\n+\n+Create a patch file\n+\n+*patch create* 'patch-file' 'target-server' 'source-server-1' ['source-server-2'...]::\n+Creates a patch file\n+\n+Rollback patches\n+\n+*patch rollback*::\n+Rolls back the patch installed last (use the *patch ls* command to show the patches in the order they've been applied)\n+\n+\n+PATCH DESCRIBE OPTIONS\n+----------------------\n+\n+*-v, --verbose*::\n+Shows the content of the patch, including information about individual files\n+\n+\n+PATCH LIST OPTIONS\n+------------------\n+\n+*--server='path-to-server'*::", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed74f7cc9585d72efd96a12ff9de80f311a9c4ee"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MzMwMjk1OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODowMjozNVrOGNgb9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxODowMjozNVrOGNgb9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjgxNjExOQ==", "bodyText": "When rollback, the upgraded files are printed twice:\nRolling back file '/tmp/redhat-datagrid-8.0.0-server/lib/protostream-4.4.0.CD20200427-redhat-00001.jar'\nRolling back file '/tmp/redhat-datagrid-8.0.0-server/lib/protostream-4.3.2.Final-redhat-00002.jar'\n\nNot sure if intentional or not.", "url": "https://github.com/infinispan/infinispan/pull/8235#discussion_r416816119", "createdAt": "2020-04-28T18:02:35Z", "author": {"login": "pruivo"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/patching/PatchTool.java", "diffHunk": "@@ -0,0 +1,474 @@\n+package org.infinispan.cli.patching;\n+\n+import static org.infinispan.cli.logging.Messages.MSG;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.PrintStream;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.MappedByteBuffer;\n+import java.nio.channels.ByteChannel;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.Files;\n+import java.nio.file.NoSuchFileException;\n+import java.nio.file.Path;\n+import java.nio.file.SimpleFileVisitor;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.StandardOpenOption;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.commons.util.Version;\n+\n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+\n+/**\n+ * Creates/installs/removes patches\n+ *\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 11.0\n+ **/\n+public class PatchTool {\n+\n+   public static final int BUFFER_SIZE = 8192;\n+   public static final String PATCHES_DIR = \".patches\";\n+   public static final String PATCHES_FILE = \"patches.json\";\n+   private final ObjectMapper mapper;\n+   private final PrintStream out;\n+   private final PrintStream err;\n+\n+   public PatchTool(PrintStream out, PrintStream err) {\n+      this.out = out;\n+      this.err = err;\n+      this.mapper = new ObjectMapper();\n+      SimpleModule module = new SimpleModule();\n+      module.addSerializer(PatchOperation.class, new PatchOperation.PatchOperationSerializer());\n+      module.addDeserializer(PatchOperation.class, new PatchOperation.PatchOperationDeserializer());\n+      this.mapper.registerModule(module);\n+   }\n+\n+   public void createPatch(String qualifier, Path patch, Path target, Path... sources) throws IOException {\n+      // Obtain version information\n+      Version targetVersion = getVersion(target);\n+      // Build a list of files in the target\n+      Map<Path, ServerFile> targetFiles = getServerFiles(target);\n+\n+      // Create the patch zip file\n+      try (FileSystem zipfs = getPatchFile(patch, true)) {\n+         for (Path source : sources) {\n+            createSinglePatch(qualifier, source, target, targetVersion, targetFiles, zipfs);\n+         }\n+      }\n+   }\n+\n+   public void describePatch(Path patch, boolean verbose) throws IOException {\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         getPatchInfos(zipfs).forEach(patchInfo -> {\n+                  out.println(patchInfo);\n+                  if (verbose) {\n+                     patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+                  }\n+               }\n+         );\n+      }\n+   }\n+\n+   public void listPatches(Path target, boolean verbose) {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         out.println(MSG.patchNoPatchesInstalled());\n+      } else {\n+         for (PatchInfo patchInfo : installedPatches) {\n+            out.println(MSG.patchInfo(patchInfo));\n+            if (verbose) {\n+               patchInfo.getOperations().forEach(op -> out.println(\"  \" + op));\n+            }\n+         }\n+      }\n+   }\n+\n+   public void installPatch(Path patch, Path target, boolean dryRun) throws IOException {\n+      // Obtain the target version\n+      Version targetVersion = getVersion(target);\n+      String version = targetVersion.version();\n+      String brandName = targetVersion.brandName();\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      // Open the patch file\n+      try (FileSystem zipfs = getPatchFile(patch)) {\n+         // Iterate the patch json files to find one that matches our version as a source\n+         PatchInfo patchInfo = getPatchInfos(zipfs).stream()\n+               .filter(info -> brandName.equals(info.getBrandName()) && version.equals(info.getSourceVersion()))\n+               .findFirst().orElseThrow(() -> {\n+                  throw MSG.patchCannotApply(brandName, version);\n+               });\n+         // Validate the SHAs of the existing files against the source ones in the patch\n+         List<PatchOperation> operations = patchInfo.getOperations();\n+\n+         // Collect all errors\n+         List<String> errors = new ArrayList<>();\n+         // Scan the patch to ensure its contents match with the list of operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(zipfs.getPath(operation.getNewPath().toString()));\n+                  if (sha256 == null || !sha256.equals(operation.getNewDigest())) {\n+                     errors.add(MSG.patchCorruptArchive(operation));\n+                  }\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // Scan the server files to ensure that the patch can be installed\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+               case SOFT_REPLACE:\n+                  // Ignore adds and soft replaces\n+                  break;\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     errors.add(MSG.patchShaMismatch(operation.getPath(), operation.getDigest(), sha256));\n+                  }\n+                  break;\n+            }\n+         }\n+         if (errors.size() > 0) {\n+            throw MSG.patchValidationErrors(String.join(\"\\n\", errors));\n+         }\n+         // We're good to go, backup the files being removed / replaced\n+         Path backup = getBackupPath(target, patchInfo);\n+         Files.createDirectories(backup);\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case ADD:\n+                  // Ignore adds\n+                  break;\n+               case SOFT_REPLACE:\n+                  // We backup only if the checksum matches (which means we will be replacing a distribution file)\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || !sha256.equals(operation.getDigest())) {\n+                     break;\n+                  }\n+               case REMOVE:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  Path file = backup.resolve(operation.getPath());\n+                  println(dryRun, MSG.patchBackup(target.resolve(operation.getPath()), file));\n+                  if (!dryRun) {\n+                     Files.createDirectories(file.getParent());\n+                     Files.move(target.resolve(operation.getPath()), file);\n+                  }\n+                  break;\n+            }\n+         }\n+         // Now perform the actual operations\n+         for (PatchOperation operation : operations) {\n+            switch (operation.getAction()) {\n+               case REMOVE:\n+                  // Do nothing, the file has already been removed as part of the backup\n+                  break;\n+               case SOFT_REPLACE:\n+                  String sha256 = sha256(target.resolve(operation.getPath()));\n+                  if (sha256 == null || sha256.equals(operation.getDigest())) {\n+                     if (!dryRun) {\n+                        Path file = Files.copy(zipfs.getPath(operation.getNewPath().toString()), target.resolve(operation.getNewPath()));\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  } else {\n+                     // We create a new file by appending the target version to the filename\n+                     if (!dryRun) {\n+                        Path file = target.resolve(operation.getNewPath());\n+                        file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+                        Files.copy(zipfs.getPath(operation.getNewPath().toString()), file);\n+                        Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                     }\n+                  }\n+                  break;\n+               case ADD:\n+               case HARD_REPLACE:\n+               case UPGRADE:\n+                  if (!dryRun) {\n+                     Path file = target.resolve(operation.getNewPath());\n+                     if (file.getParent() != null) {\n+                        Files.createDirectories(file.getParent());\n+                     }\n+                     Files.copy(zipfs.getPath(operation.getNewPath().toString()), file, StandardCopyOption.REPLACE_EXISTING);\n+                     Files.setPosixFilePermissions(file, PosixFilePermissions.fromString(operation.getNewPermissions()));\n+                  }\n+                  break;\n+            }\n+         }\n+         patchInfo.setInstallationDate(new Date());\n+         if (!dryRun) {\n+            installedPatches.add(patchInfo);\n+            writeInstalledPatches(target, installedPatches);\n+         }\n+         println(dryRun, MSG.patchInfo(patchInfo));\n+      }\n+   }\n+\n+   public void rollbackPatch(Path target, boolean dryRun) throws IOException {\n+      List<PatchInfo> installedPatches = getInstalledPatches(target);\n+      if (installedPatches.isEmpty()) {\n+         throw MSG.patchNoPatchesInstalledToRollback();\n+      }\n+      PatchInfo patchInfo = installedPatches.remove(installedPatches.size() - 1);\n+      Path backup = getBackupPath(target, patchInfo);\n+      for (PatchOperation operation : patchInfo.getOperations()) {\n+         switch (operation.getAction()) {\n+            case ADD: {\n+               Path file = target.resolve(operation.getNewPath());\n+               // Remove any added files\n+               println(dryRun, MSG.patchRollbackFile(file));\n+               if (!dryRun) {\n+                  Files.delete(file);\n+               }\n+            }\n+            break;\n+            case SOFT_REPLACE: {\n+               // We only restore if the file hasn't been changed\n+               Path file = target.resolve(operation.getPath());\n+               String sha256 = sha256(file);\n+               if (sha256 != null && sha256.equals(operation.getNewDigest())) {\n+                  println(dryRun, MSG.patchRollbackFile(file));\n+                  if (!dryRun) {\n+                     Files.move(backup.resolve(operation.getPath()), target.resolve(operation.getPath()), StandardCopyOption.REPLACE_EXISTING);\n+                  }\n+               }\n+               // We might have created a side-file, remove it\n+               file = target.resolve(operation.getNewPath());\n+               file = file.getParent().resolve(file.getFileName().toString() + \"-\" + patchInfo.getTargetVersion());\n+               Files.deleteIfExists(file);\n+               break;\n+            }\n+            case UPGRADE: {\n+               Path file = target.resolve(operation.getNewPath());\n+               println(dryRun, MSG.patchRollbackFile(file));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed74f7cc9585d72efd96a12ff9de80f311a9c4ee"}, "originalPosition": 271}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4296, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}