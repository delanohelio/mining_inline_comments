{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5MjI2NjI5", "number": 8500, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDo1Mzo0NlrOEpgz_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxOToxNFrOEpw5ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTY0NjcwOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/BenchmarkOutputFormat.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDo1Mzo0NlrOHbOTPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxMzozNjo1MFrOHdG2uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwNzkwMQ==", "bodyText": "a bit hard to read, we can avoid the timeout.convertTo to be called twice", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r498307901", "createdAt": "2020-10-01T14:53:46Z", "author": {"login": "karesti"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/BenchmarkOutputFormat.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package org.infinispan.cli.benchmark;\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.infra.BenchmarkParams;\n+import org.openjdk.jmh.infra.IterationParams;\n+import org.openjdk.jmh.results.BenchmarkResult;\n+import org.openjdk.jmh.results.IterationResult;\n+import org.openjdk.jmh.results.Result;\n+import org.openjdk.jmh.results.RunResult;\n+import org.openjdk.jmh.results.format.ResultFormatFactory;\n+import org.openjdk.jmh.results.format.ResultFormatType;\n+import org.openjdk.jmh.runner.IterationType;\n+import org.openjdk.jmh.runner.format.OutputFormat;\n+import org.openjdk.jmh.runner.options.TimeValue;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+import org.openjdk.jmh.util.Utils;\n+\n+public class BenchmarkOutputFormat implements OutputFormat {\n+\n+   final VerboseMode verbose;\n+   final PrintStream out;\n+\n+   public BenchmarkOutputFormat(PrintStream out, VerboseMode verbose) {\n+      this.out = out;\n+      this.verbose = verbose;\n+   }\n+\n+   @Override\n+   public void print(String s) {\n+      out.print(s);\n+   }\n+\n+   @Override\n+   public void println(String s) {\n+      out.println(s);\n+   }\n+\n+   @Override\n+   public void flush() {\n+      out.flush();\n+   }\n+\n+   @Override\n+   public void verbosePrintln(String s) {\n+      if (verbose == VerboseMode.EXTRA) {\n+         out.println(s);\n+      }\n+   }\n+\n+   @Override\n+   public void write(int b) {\n+      out.write(b);\n+   }\n+\n+   @Override\n+   public void write(byte[] b) {\n+      out.write(b, 0, b.length);\n+   }\n+\n+   @Override\n+   public void close() {\n+   }\n+\n+   @Override\n+   public void startBenchmark(BenchmarkParams params) {\n+      IterationParams warmup = params.getWarmup();\n+      if (warmup.getCount() > 0) {\n+         out.println(\"# Warmup: \" + warmup.getCount() + \" iterations, \" +\n+               warmup.getTime() + \" each\" +\n+               (warmup.getBatchSize() <= 1 ? \"\" : \", \" + warmup.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Warmup: <none>\");\n+      }\n+\n+      IterationParams measurement = params.getMeasurement();\n+      if (measurement.getCount() > 0) {\n+         out.println(\"# Measurement: \" + measurement.getCount() + \" iterations, \" +\n+               measurement.getTime() + \" each\" +\n+               (measurement.getBatchSize() <= 1 ? \"\" : \", \" + measurement.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Measurement: <none>\");\n+      }\n+\n+      TimeValue timeout = params.getTimeout();\n+      boolean timeoutWarning = (timeout.convertTo(TimeUnit.NANOSECONDS) <= measurement.getTime().convertTo(TimeUnit.NANOSECONDS)) ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ecbade987871fc34d8cc70a8d6725e74807b86"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI4MzA2NA==", "bodyText": "@karesti most of the code in this class is copied from JMH and I'd rather not mess around with it too much in case we need to resynchronize it in the future. Unfortunately subclassing was not an option.", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r500283064", "createdAt": "2020-10-06T13:36:50Z", "author": {"login": "tristantarrant"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/BenchmarkOutputFormat.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package org.infinispan.cli.benchmark;\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.infra.BenchmarkParams;\n+import org.openjdk.jmh.infra.IterationParams;\n+import org.openjdk.jmh.results.BenchmarkResult;\n+import org.openjdk.jmh.results.IterationResult;\n+import org.openjdk.jmh.results.Result;\n+import org.openjdk.jmh.results.RunResult;\n+import org.openjdk.jmh.results.format.ResultFormatFactory;\n+import org.openjdk.jmh.results.format.ResultFormatType;\n+import org.openjdk.jmh.runner.IterationType;\n+import org.openjdk.jmh.runner.format.OutputFormat;\n+import org.openjdk.jmh.runner.options.TimeValue;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+import org.openjdk.jmh.util.Utils;\n+\n+public class BenchmarkOutputFormat implements OutputFormat {\n+\n+   final VerboseMode verbose;\n+   final PrintStream out;\n+\n+   public BenchmarkOutputFormat(PrintStream out, VerboseMode verbose) {\n+      this.out = out;\n+      this.verbose = verbose;\n+   }\n+\n+   @Override\n+   public void print(String s) {\n+      out.print(s);\n+   }\n+\n+   @Override\n+   public void println(String s) {\n+      out.println(s);\n+   }\n+\n+   @Override\n+   public void flush() {\n+      out.flush();\n+   }\n+\n+   @Override\n+   public void verbosePrintln(String s) {\n+      if (verbose == VerboseMode.EXTRA) {\n+         out.println(s);\n+      }\n+   }\n+\n+   @Override\n+   public void write(int b) {\n+      out.write(b);\n+   }\n+\n+   @Override\n+   public void write(byte[] b) {\n+      out.write(b, 0, b.length);\n+   }\n+\n+   @Override\n+   public void close() {\n+   }\n+\n+   @Override\n+   public void startBenchmark(BenchmarkParams params) {\n+      IterationParams warmup = params.getWarmup();\n+      if (warmup.getCount() > 0) {\n+         out.println(\"# Warmup: \" + warmup.getCount() + \" iterations, \" +\n+               warmup.getTime() + \" each\" +\n+               (warmup.getBatchSize() <= 1 ? \"\" : \", \" + warmup.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Warmup: <none>\");\n+      }\n+\n+      IterationParams measurement = params.getMeasurement();\n+      if (measurement.getCount() > 0) {\n+         out.println(\"# Measurement: \" + measurement.getCount() + \" iterations, \" +\n+               measurement.getTime() + \" each\" +\n+               (measurement.getBatchSize() <= 1 ? \"\" : \", \" + measurement.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Measurement: <none>\");\n+      }\n+\n+      TimeValue timeout = params.getTimeout();\n+      boolean timeoutWarning = (timeout.convertTo(TimeUnit.NANOSECONDS) <= measurement.getTime().convertTo(TimeUnit.NANOSECONDS)) ||", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwNzkwMQ=="}, "originalCommit": {"oid": "24ecbade987871fc34d8cc70a8d6725e74807b86"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTY1Njc1OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/BenchmarkOutputFormat.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDo1NTo0M1rOHbOZUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDo1NTo0M1rOHbOZUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwOTQ1OQ==", "bodyText": "too much spaces?", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r498309459", "createdAt": "2020-10-01T14:55:43Z", "author": {"login": "karesti"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/BenchmarkOutputFormat.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package org.infinispan.cli.benchmark;\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.infra.BenchmarkParams;\n+import org.openjdk.jmh.infra.IterationParams;\n+import org.openjdk.jmh.results.BenchmarkResult;\n+import org.openjdk.jmh.results.IterationResult;\n+import org.openjdk.jmh.results.Result;\n+import org.openjdk.jmh.results.RunResult;\n+import org.openjdk.jmh.results.format.ResultFormatFactory;\n+import org.openjdk.jmh.results.format.ResultFormatType;\n+import org.openjdk.jmh.runner.IterationType;\n+import org.openjdk.jmh.runner.format.OutputFormat;\n+import org.openjdk.jmh.runner.options.TimeValue;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+import org.openjdk.jmh.util.Utils;\n+\n+public class BenchmarkOutputFormat implements OutputFormat {\n+\n+   final VerboseMode verbose;\n+   final PrintStream out;\n+\n+   public BenchmarkOutputFormat(PrintStream out, VerboseMode verbose) {\n+      this.out = out;\n+      this.verbose = verbose;\n+   }\n+\n+   @Override\n+   public void print(String s) {\n+      out.print(s);\n+   }\n+\n+   @Override\n+   public void println(String s) {\n+      out.println(s);\n+   }\n+\n+   @Override\n+   public void flush() {\n+      out.flush();\n+   }\n+\n+   @Override\n+   public void verbosePrintln(String s) {\n+      if (verbose == VerboseMode.EXTRA) {\n+         out.println(s);\n+      }\n+   }\n+\n+   @Override\n+   public void write(int b) {\n+      out.write(b);\n+   }\n+\n+   @Override\n+   public void write(byte[] b) {\n+      out.write(b, 0, b.length);\n+   }\n+\n+   @Override\n+   public void close() {\n+   }\n+\n+   @Override\n+   public void startBenchmark(BenchmarkParams params) {\n+      IterationParams warmup = params.getWarmup();\n+      if (warmup.getCount() > 0) {\n+         out.println(\"# Warmup: \" + warmup.getCount() + \" iterations, \" +\n+               warmup.getTime() + \" each\" +\n+               (warmup.getBatchSize() <= 1 ? \"\" : \", \" + warmup.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Warmup: <none>\");\n+      }\n+\n+      IterationParams measurement = params.getMeasurement();\n+      if (measurement.getCount() > 0) {\n+         out.println(\"# Measurement: \" + measurement.getCount() + \" iterations, \" +\n+               measurement.getTime() + \" each\" +\n+               (measurement.getBatchSize() <= 1 ? \"\" : \", \" + measurement.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Measurement: <none>\");\n+      }\n+\n+      TimeValue timeout = params.getTimeout();\n+      boolean timeoutWarning = (timeout.convertTo(TimeUnit.NANOSECONDS) <= measurement.getTime().convertTo(TimeUnit.NANOSECONDS)) ||\n+            (timeout.convertTo(TimeUnit.NANOSECONDS) <= warmup.getTime().convertTo(TimeUnit.NANOSECONDS));\n+      out.println(\"# Timeout: \" + timeout + \" per iteration\" + (timeoutWarning ? \", ***WARNING: The timeout might be too low!***\" : \"\"));\n+\n+      out.print(\"# Threads: \" + params.getThreads() + \" \" + getThreadsString(params.getThreads()));\n+\n+      if (!params.getThreadGroupLabels().isEmpty()) {\n+         int[] tg = params.getThreadGroups();\n+\n+         List<String> labels = new ArrayList<>(params.getThreadGroupLabels());\n+         String[] ss = new String[tg.length];\n+         for (int cnt = 0; cnt < tg.length; cnt++) {\n+            ss[cnt] = tg[cnt] + \"x \\\"\" + labels.get(cnt) + \"\\\"\";\n+         }\n+\n+         int groupCount = params.getThreads() / Utils.sum(tg);\n+         out.print(\" (\" + groupCount + \" \" + getGroupsString(groupCount) + \"; \" + Utils.join(ss, \", \") + \" in each group)\");\n+      }\n+\n+      out.println(params.shouldSynchIterations() ?\n+            \", will synchronize iterations\" :\n+            (params.getMode() == Mode.SingleShotTime) ? \"\" : \", ***WARNING: Synchronize iterations are disabled!***\");\n+\n+\n+      out.println(\"# Benchmark mode: \" + params.getMode().longLabel());\n+      out.println(\"# Benchmark: \" + params.getBenchmark());\n+      if (!params.getParamsKeys().isEmpty()) {\n+         String s = \"\";\n+         boolean isFirst = true;\n+         for (String k : params.getParamsKeys()) {\n+            if (isFirst) {\n+               isFirst = false;\n+            } else {\n+               s += \", \";\n+            }\n+            s += k + \" = \" + params.getParam(k);\n+         }\n+         out.println(\"# Parameters: (\" + s + \")\");\n+      }\n+   }\n+\n+   @Override\n+   public void iteration(BenchmarkParams benchmarkParams, IterationParams params, int iteration) {\n+      switch (params.getType()) {\n+         case WARMUP:\n+            out.print(String.format(\"Warmup    %3d: \", iteration));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ecbade987871fc34d8cc70a8d6725e74807b86"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTY1ODQ5OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/BenchmarkOutputFormat.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDo1NjowNlrOHbOaYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDo1NjowNlrOHbOaYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwOTczMQ==", "bodyText": "why is this 'iteration' instead of 'Measurement' ?", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r498309731", "createdAt": "2020-10-01T14:56:06Z", "author": {"login": "karesti"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/BenchmarkOutputFormat.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package org.infinispan.cli.benchmark;\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.infra.BenchmarkParams;\n+import org.openjdk.jmh.infra.IterationParams;\n+import org.openjdk.jmh.results.BenchmarkResult;\n+import org.openjdk.jmh.results.IterationResult;\n+import org.openjdk.jmh.results.Result;\n+import org.openjdk.jmh.results.RunResult;\n+import org.openjdk.jmh.results.format.ResultFormatFactory;\n+import org.openjdk.jmh.results.format.ResultFormatType;\n+import org.openjdk.jmh.runner.IterationType;\n+import org.openjdk.jmh.runner.format.OutputFormat;\n+import org.openjdk.jmh.runner.options.TimeValue;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+import org.openjdk.jmh.util.Utils;\n+\n+public class BenchmarkOutputFormat implements OutputFormat {\n+\n+   final VerboseMode verbose;\n+   final PrintStream out;\n+\n+   public BenchmarkOutputFormat(PrintStream out, VerboseMode verbose) {\n+      this.out = out;\n+      this.verbose = verbose;\n+   }\n+\n+   @Override\n+   public void print(String s) {\n+      out.print(s);\n+   }\n+\n+   @Override\n+   public void println(String s) {\n+      out.println(s);\n+   }\n+\n+   @Override\n+   public void flush() {\n+      out.flush();\n+   }\n+\n+   @Override\n+   public void verbosePrintln(String s) {\n+      if (verbose == VerboseMode.EXTRA) {\n+         out.println(s);\n+      }\n+   }\n+\n+   @Override\n+   public void write(int b) {\n+      out.write(b);\n+   }\n+\n+   @Override\n+   public void write(byte[] b) {\n+      out.write(b, 0, b.length);\n+   }\n+\n+   @Override\n+   public void close() {\n+   }\n+\n+   @Override\n+   public void startBenchmark(BenchmarkParams params) {\n+      IterationParams warmup = params.getWarmup();\n+      if (warmup.getCount() > 0) {\n+         out.println(\"# Warmup: \" + warmup.getCount() + \" iterations, \" +\n+               warmup.getTime() + \" each\" +\n+               (warmup.getBatchSize() <= 1 ? \"\" : \", \" + warmup.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Warmup: <none>\");\n+      }\n+\n+      IterationParams measurement = params.getMeasurement();\n+      if (measurement.getCount() > 0) {\n+         out.println(\"# Measurement: \" + measurement.getCount() + \" iterations, \" +\n+               measurement.getTime() + \" each\" +\n+               (measurement.getBatchSize() <= 1 ? \"\" : \", \" + measurement.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Measurement: <none>\");\n+      }\n+\n+      TimeValue timeout = params.getTimeout();\n+      boolean timeoutWarning = (timeout.convertTo(TimeUnit.NANOSECONDS) <= measurement.getTime().convertTo(TimeUnit.NANOSECONDS)) ||\n+            (timeout.convertTo(TimeUnit.NANOSECONDS) <= warmup.getTime().convertTo(TimeUnit.NANOSECONDS));\n+      out.println(\"# Timeout: \" + timeout + \" per iteration\" + (timeoutWarning ? \", ***WARNING: The timeout might be too low!***\" : \"\"));\n+\n+      out.print(\"# Threads: \" + params.getThreads() + \" \" + getThreadsString(params.getThreads()));\n+\n+      if (!params.getThreadGroupLabels().isEmpty()) {\n+         int[] tg = params.getThreadGroups();\n+\n+         List<String> labels = new ArrayList<>(params.getThreadGroupLabels());\n+         String[] ss = new String[tg.length];\n+         for (int cnt = 0; cnt < tg.length; cnt++) {\n+            ss[cnt] = tg[cnt] + \"x \\\"\" + labels.get(cnt) + \"\\\"\";\n+         }\n+\n+         int groupCount = params.getThreads() / Utils.sum(tg);\n+         out.print(\" (\" + groupCount + \" \" + getGroupsString(groupCount) + \"; \" + Utils.join(ss, \", \") + \" in each group)\");\n+      }\n+\n+      out.println(params.shouldSynchIterations() ?\n+            \", will synchronize iterations\" :\n+            (params.getMode() == Mode.SingleShotTime) ? \"\" : \", ***WARNING: Synchronize iterations are disabled!***\");\n+\n+\n+      out.println(\"# Benchmark mode: \" + params.getMode().longLabel());\n+      out.println(\"# Benchmark: \" + params.getBenchmark());\n+      if (!params.getParamsKeys().isEmpty()) {\n+         String s = \"\";\n+         boolean isFirst = true;\n+         for (String k : params.getParamsKeys()) {\n+            if (isFirst) {\n+               isFirst = false;\n+            } else {\n+               s += \", \";\n+            }\n+            s += k + \" = \" + params.getParam(k);\n+         }\n+         out.println(\"# Parameters: (\" + s + \")\");\n+      }\n+   }\n+\n+   @Override\n+   public void iteration(BenchmarkParams benchmarkParams, IterationParams params, int iteration) {\n+      switch (params.getType()) {\n+         case WARMUP:\n+            out.print(String.format(\"Warmup    %3d: \", iteration));\n+            break;\n+         case MEASUREMENT:\n+            out.print(String.format(\"Iteration %3d: \", iteration));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ecbade987871fc34d8cc70a8d6725e74807b86"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTY2NjE1OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/BenchmarkOutputFormat.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDo1NzozNlrOHbOfEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNDo1NzozNlrOHbOfEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxMDkyOA==", "bodyText": "there are extra {", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r498310928", "createdAt": "2020-10-01T14:57:36Z", "author": {"login": "karesti"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/BenchmarkOutputFormat.java", "diffHunk": "@@ -0,0 +1,226 @@\n+package org.infinispan.cli.benchmark;\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.infra.BenchmarkParams;\n+import org.openjdk.jmh.infra.IterationParams;\n+import org.openjdk.jmh.results.BenchmarkResult;\n+import org.openjdk.jmh.results.IterationResult;\n+import org.openjdk.jmh.results.Result;\n+import org.openjdk.jmh.results.RunResult;\n+import org.openjdk.jmh.results.format.ResultFormatFactory;\n+import org.openjdk.jmh.results.format.ResultFormatType;\n+import org.openjdk.jmh.runner.IterationType;\n+import org.openjdk.jmh.runner.format.OutputFormat;\n+import org.openjdk.jmh.runner.options.TimeValue;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+import org.openjdk.jmh.util.Utils;\n+\n+public class BenchmarkOutputFormat implements OutputFormat {\n+\n+   final VerboseMode verbose;\n+   final PrintStream out;\n+\n+   public BenchmarkOutputFormat(PrintStream out, VerboseMode verbose) {\n+      this.out = out;\n+      this.verbose = verbose;\n+   }\n+\n+   @Override\n+   public void print(String s) {\n+      out.print(s);\n+   }\n+\n+   @Override\n+   public void println(String s) {\n+      out.println(s);\n+   }\n+\n+   @Override\n+   public void flush() {\n+      out.flush();\n+   }\n+\n+   @Override\n+   public void verbosePrintln(String s) {\n+      if (verbose == VerboseMode.EXTRA) {\n+         out.println(s);\n+      }\n+   }\n+\n+   @Override\n+   public void write(int b) {\n+      out.write(b);\n+   }\n+\n+   @Override\n+   public void write(byte[] b) {\n+      out.write(b, 0, b.length);\n+   }\n+\n+   @Override\n+   public void close() {\n+   }\n+\n+   @Override\n+   public void startBenchmark(BenchmarkParams params) {\n+      IterationParams warmup = params.getWarmup();\n+      if (warmup.getCount() > 0) {\n+         out.println(\"# Warmup: \" + warmup.getCount() + \" iterations, \" +\n+               warmup.getTime() + \" each\" +\n+               (warmup.getBatchSize() <= 1 ? \"\" : \", \" + warmup.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Warmup: <none>\");\n+      }\n+\n+      IterationParams measurement = params.getMeasurement();\n+      if (measurement.getCount() > 0) {\n+         out.println(\"# Measurement: \" + measurement.getCount() + \" iterations, \" +\n+               measurement.getTime() + \" each\" +\n+               (measurement.getBatchSize() <= 1 ? \"\" : \", \" + measurement.getBatchSize() + \" calls per op\"));\n+      } else {\n+         out.println(\"# Measurement: <none>\");\n+      }\n+\n+      TimeValue timeout = params.getTimeout();\n+      boolean timeoutWarning = (timeout.convertTo(TimeUnit.NANOSECONDS) <= measurement.getTime().convertTo(TimeUnit.NANOSECONDS)) ||\n+            (timeout.convertTo(TimeUnit.NANOSECONDS) <= warmup.getTime().convertTo(TimeUnit.NANOSECONDS));\n+      out.println(\"# Timeout: \" + timeout + \" per iteration\" + (timeoutWarning ? \", ***WARNING: The timeout might be too low!***\" : \"\"));\n+\n+      out.print(\"# Threads: \" + params.getThreads() + \" \" + getThreadsString(params.getThreads()));\n+\n+      if (!params.getThreadGroupLabels().isEmpty()) {\n+         int[] tg = params.getThreadGroups();\n+\n+         List<String> labels = new ArrayList<>(params.getThreadGroupLabels());\n+         String[] ss = new String[tg.length];\n+         for (int cnt = 0; cnt < tg.length; cnt++) {\n+            ss[cnt] = tg[cnt] + \"x \\\"\" + labels.get(cnt) + \"\\\"\";\n+         }\n+\n+         int groupCount = params.getThreads() / Utils.sum(tg);\n+         out.print(\" (\" + groupCount + \" \" + getGroupsString(groupCount) + \"; \" + Utils.join(ss, \", \") + \" in each group)\");\n+      }\n+\n+      out.println(params.shouldSynchIterations() ?\n+            \", will synchronize iterations\" :\n+            (params.getMode() == Mode.SingleShotTime) ? \"\" : \", ***WARNING: Synchronize iterations are disabled!***\");\n+\n+\n+      out.println(\"# Benchmark mode: \" + params.getMode().longLabel());\n+      out.println(\"# Benchmark: \" + params.getBenchmark());\n+      if (!params.getParamsKeys().isEmpty()) {\n+         String s = \"\";\n+         boolean isFirst = true;\n+         for (String k : params.getParamsKeys()) {\n+            if (isFirst) {\n+               isFirst = false;\n+            } else {\n+               s += \", \";\n+            }\n+            s += k + \" = \" + params.getParam(k);\n+         }\n+         out.println(\"# Parameters: (\" + s + \")\");\n+      }\n+   }\n+\n+   @Override\n+   public void iteration(BenchmarkParams benchmarkParams, IterationParams params, int iteration) {\n+      switch (params.getType()) {\n+         case WARMUP:\n+            out.print(String.format(\"Warmup    %3d: \", iteration));\n+            break;\n+         case MEASUREMENT:\n+            out.print(String.format(\"Iteration %3d: \", iteration));\n+            break;\n+         default:\n+            throw new IllegalStateException(\"Unknown iteration type: \" + params.getType());\n+      }\n+      out.flush();\n+   }\n+\n+   protected static String getThreadsString(int t) {\n+      if (t > 1) {\n+         return \"threads\";\n+      } else {\n+         return \"thread\";\n+      }\n+   }\n+\n+   protected static String getGroupsString(int g) {\n+      if (g > 1) {\n+         return \"groups\";\n+      } else {\n+         return \"group\";\n+      }\n+   }\n+\n+   @Override\n+   public void iterationResult(BenchmarkParams benchmParams, IterationParams params, int iteration, IterationResult data) {\n+      StringBuilder sb = new StringBuilder();\n+      sb.append(data.getPrimaryResult().toString());\n+\n+      if (params.getType() == IterationType.MEASUREMENT) {\n+         int prefixLen = String.format(\"Iteration %3d: \", iteration).length();\n+\n+         Map<String, Result> secondary = data.getSecondaryResults();\n+         if (!secondary.isEmpty()) {\n+            sb.append(\"\\n\");\n+\n+            int maxKeyLen = 0;\n+            for (Map.Entry<String, Result> res : secondary.entrySet()) {\n+               maxKeyLen = Math.max(maxKeyLen, res.getKey().length());\n+            }\n+\n+            for (Map.Entry<String, Result> res : secondary.entrySet()) {\n+               sb.append(String.format(\"%\" + prefixLen + \"s\", \"\"));\n+               sb.append(String.format(\"  %-\" + (maxKeyLen + 1) + \"s %s\", res.getKey() + \":\", res.getValue()));\n+               sb.append(\"\\n\");\n+            }\n+         }\n+      }\n+\n+      out.print(String.format(\"%s%n\", sb.toString()));\n+      out.flush();\n+   }\n+\n+   @Override\n+   public void endBenchmark(BenchmarkResult result) {\n+      out.println();\n+      if (result != null) {\n+         {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ecbade987871fc34d8cc70a8d6725e74807b86"}, "originalPosition": 197}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTY4NjIzOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/HttpBenchmark.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTowMTo1M1rOHbOriw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTowMTo1M1rOHbOriw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxNDEyMw==", "bodyText": "cm variable name related to cacheManager but the RestClient returns a restClient. I would rename this to avoid confusion with the HotrodBenchmark", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r498314123", "createdAt": "2020-10-01T15:01:53Z", "author": {"login": "karesti"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/HttpBenchmark.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.infinispan.cli.benchmark;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.rest.RestCacheClient;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestEntity;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.RestURI;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+@State(Scope.Thread)\n+public class HttpBenchmark {\n+   private static final long BIG_DELAY_NANOS = TimeUnit.DAYS.toNanos(1);\n+   RestClient cm;\n+   RestCacheClient cache;\n+\n+   @Param(\"http://127.0.0.1\")\n+   public String uri;\n+\n+   @Param(\"benchmark\")\n+   public String cacheName;\n+\n+   @Param(\"\")\n+   public String cacheTemplate;\n+\n+   @Param(\"16\")\n+   public int keySize;\n+\n+   @Param(\"1000\")\n+   public int valueSize;\n+\n+   @Param(\"1000\")\n+   public int keySetSize;\n+\n+   RestEntity value;\n+   List<String> keySet;\n+   AtomicInteger nextIndex;\n+\n+   @Setup\n+   public void setup() {\n+      RestURI uri = RestURI.create(this.uri);\n+      RestClientConfigurationBuilder builder = uri.toConfigurationBuilder();\n+      cm = RestClient.forConfiguration(builder.build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ecbade987871fc34d8cc70a8d6725e74807b86"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExOTY5MjU2OnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/HttpBenchmark.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTowMzoyMVrOHbOvkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxNTowMzoyMVrOHbOvkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxNTE1Mw==", "bodyText": "same here, it's not a cache but the restCacheClient", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r498315153", "createdAt": "2020-10-01T15:03:21Z", "author": {"login": "karesti"}, "path": "cli/cli-client/src/main/java/org/infinispan/cli/benchmark/HttpBenchmark.java", "diffHunk": "@@ -0,0 +1,116 @@\n+package org.infinispan.cli.benchmark;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Random;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.rest.RestCacheClient;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestEntity;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.RestURI;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.commons.CacheException;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.util.Util;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+@State(Scope.Thread)\n+public class HttpBenchmark {\n+   private static final long BIG_DELAY_NANOS = TimeUnit.DAYS.toNanos(1);\n+   RestClient cm;\n+   RestCacheClient cache;\n+\n+   @Param(\"http://127.0.0.1\")\n+   public String uri;\n+\n+   @Param(\"benchmark\")\n+   public String cacheName;\n+\n+   @Param(\"\")\n+   public String cacheTemplate;\n+\n+   @Param(\"16\")\n+   public int keySize;\n+\n+   @Param(\"1000\")\n+   public int valueSize;\n+\n+   @Param(\"1000\")\n+   public int keySetSize;\n+\n+   RestEntity value;\n+   List<String> keySet;\n+   AtomicInteger nextIndex;\n+\n+   @Setup\n+   public void setup() {\n+      RestURI uri = RestURI.create(this.uri);\n+      RestClientConfigurationBuilder builder = uri.toConfigurationBuilder();\n+      cm = RestClient.forConfiguration(builder.build());\n+      cache = cm.cache(cacheName);\n+      if (uncheckedAwait(cache.exists()).getStatus() == 404) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ecbade987871fc34d8cc70a8d6725e74807b86"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjI2NjIxOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/benchmark.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxMzozMVrOHboXsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxMzozMVrOHboXsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNTAyNA==", "bodyText": "@tristantarrant I'm curious about \"the mode is determined by the protocol of the supplied URI.\" How does the protocol determine the mode? Are there some benchmark modes that do not apply for certain protocols?", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r498735024", "createdAt": "2020-10-02T10:13:31Z", "author": {"login": "oraNod"}, "path": "cli/cli-client/src/main/resources/help/benchmark.adoc", "diffHunk": "@@ -0,0 +1,71 @@\n+BENCHMARK(1)\n+============\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+benchmark - runs a performance benchmark against a cache.\n+\n+The benchmark can be performed both for HTTP and for Hot Rod: the mode is determined by the protocol of the supplied URI.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ecbade987871fc34d8cc70a8d6725e74807b86"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjI3NjQxOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/benchmark.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxNzowNVrOHboeDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxNzowNVrOHboeDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNjY1NQ==", "bodyText": "There seems to be no difference in the output when I set different verbosity levels.", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r498736655", "createdAt": "2020-10-02T10:17:05Z", "author": {"login": "oraNod"}, "path": "cli/cli-client/src/main/resources/help/benchmark.adoc", "diffHunk": "@@ -0,0 +1,71 @@\n+BENCHMARK(1)\n+============\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+benchmark - runs a performance benchmark against a cache.\n+\n+The benchmark can be performed both for HTTP and for Hot Rod: the mode is determined by the protocol of the supplied URI.\n+Supported protocols are http, https, hotrod, hotrods. If unspecified it will use the current connection's URI. Hot Rod benchmarks will connect to the entire cluster. HTTP benchmarks will connect only to a single node.\n+The benchmark is performed against an already-existing cache: by using a cache with the desired configuration it is possible to exercise specific features such as persistence, cross-site replication and transactions.\n+\n+\n+SYNOPSIS\n+--------\n+*benchmark* ['OPTIONS'] [`uri`]\n+\n+\n+BENCHMARK OPTIONS\n+-----------------\n+*-f, --forks*='num'::\n+The number of forks to create. Defaults to 0 (don't use forks).\n+\n+*-t, --threads*='num'::\n+The number of threads to create. Defaults to 10.\n+\n+*--cache*='cache'::\n+The name of the cache to use for the benchmark. Defaults to 'benchmark'.\n+\n+**--key-size*='num'::\n+The size of the key. Defaults to 16 bytes.\n+\n+**--value-size*='num'::\n+The size of the value. Defaults to 1000 bytes.\n+\n+**--keyset-size*='num'::\n+The size of the test key set. Defaults to 1000.\n+\n+*--verbosity*=['SILENT', 'NORMAL', 'EXTRA']::\n+How verbose the output should be. One of SILENT, NORMAL, EXTRA. Defaults to NORMAL.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ecbade987871fc34d8cc70a8d6725e74807b86"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjI3OTgyOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/benchmark.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxODozMlrOHbogRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxODozMlrOHbogRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNzIyMg==", "bodyText": "The size unit for the value is byte? \"Sets the size, in bytes, of the key.", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r498737222", "createdAt": "2020-10-02T10:18:32Z", "author": {"login": "oraNod"}, "path": "cli/cli-client/src/main/resources/help/benchmark.adoc", "diffHunk": "@@ -0,0 +1,71 @@\n+BENCHMARK(1)\n+============\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+benchmark - runs a performance benchmark against a cache.\n+\n+The benchmark can be performed both for HTTP and for Hot Rod: the mode is determined by the protocol of the supplied URI.\n+Supported protocols are http, https, hotrod, hotrods. If unspecified it will use the current connection's URI. Hot Rod benchmarks will connect to the entire cluster. HTTP benchmarks will connect only to a single node.\n+The benchmark is performed against an already-existing cache: by using a cache with the desired configuration it is possible to exercise specific features such as persistence, cross-site replication and transactions.\n+\n+\n+SYNOPSIS\n+--------\n+*benchmark* ['OPTIONS'] [`uri`]\n+\n+\n+BENCHMARK OPTIONS\n+-----------------\n+*-f, --forks*='num'::\n+The number of forks to create. Defaults to 0 (don't use forks).\n+\n+*-t, --threads*='num'::\n+The number of threads to create. Defaults to 10.\n+\n+*--cache*='cache'::\n+The name of the cache to use for the benchmark. Defaults to 'benchmark'.\n+\n+**--key-size*='num'::\n+The size of the key. Defaults to 16 bytes.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ecbade987871fc34d8cc70a8d6725e74807b86"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMjI4MjAyOnYy", "diffSide": "RIGHT", "path": "cli/cli-client/src/main/resources/help/benchmark.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxOToxNFrOHbohkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxMDoxOToxNFrOHbohkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczNzU1Mw==", "bodyText": "The time unit is seconds? \"Sets the amount of time, in seconds, that each iteration takes.\"", "url": "https://github.com/infinispan/infinispan/pull/8500#discussion_r498737553", "createdAt": "2020-10-02T10:19:14Z", "author": {"login": "oraNod"}, "path": "cli/cli-client/src/main/resources/help/benchmark.adoc", "diffHunk": "@@ -0,0 +1,71 @@\n+BENCHMARK(1)\n+============\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+benchmark - runs a performance benchmark against a cache.\n+\n+The benchmark can be performed both for HTTP and for Hot Rod: the mode is determined by the protocol of the supplied URI.\n+Supported protocols are http, https, hotrod, hotrods. If unspecified it will use the current connection's URI. Hot Rod benchmarks will connect to the entire cluster. HTTP benchmarks will connect only to a single node.\n+The benchmark is performed against an already-existing cache: by using a cache with the desired configuration it is possible to exercise specific features such as persistence, cross-site replication and transactions.\n+\n+\n+SYNOPSIS\n+--------\n+*benchmark* ['OPTIONS'] [`uri`]\n+\n+\n+BENCHMARK OPTIONS\n+-----------------\n+*-f, --forks*='num'::\n+The number of forks to create. Defaults to 0 (don't use forks).\n+\n+*-t, --threads*='num'::\n+The number of threads to create. Defaults to 10.\n+\n+*--cache*='cache'::\n+The name of the cache to use for the benchmark. Defaults to 'benchmark'.\n+\n+**--key-size*='num'::\n+The size of the key. Defaults to 16 bytes.\n+\n+**--value-size*='num'::\n+The size of the value. Defaults to 1000 bytes.\n+\n+**--keyset-size*='num'::\n+The size of the test key set. Defaults to 1000.\n+\n+*--verbosity*=['SILENT', 'NORMAL', 'EXTRA']::\n+How verbose the output should be. One of SILENT, NORMAL, EXTRA. Defaults to NORMAL.\n+\n+*-c, --count*='num'::\n+The number of measurement iterations to perform. Defaults to 5.\n+\n+*--time*='time'::\n+How long each iteration should take. Defaults to 10s.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24ecbade987871fc34d8cc70a8d6725e74807b86"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4100, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}