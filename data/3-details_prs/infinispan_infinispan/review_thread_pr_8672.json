{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5NzIzNDIy", "number": 8672, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTo0MDowMVrOEimBoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODo0MDozOVrOEnLEeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzEwMDQ5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/ExponentialBackOff.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTo0MDowMVrOHQj_jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwODo0OToxNlrOHX6ynQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyODk3Mw==", "bodyText": "I am not a fan of this. Can we not instead use the TIMEOUT_SCHEDULE_EXECUTOR executor to do this? Or is it required to stay in the invoking thread for preserveOrder ?", "url": "https://github.com/infinispan/infinispan/pull/8672#discussion_r487128973", "createdAt": "2020-09-11T15:40:01Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/ExponentialBackOff.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.infinispan.util;\n+\n+import org.infinispan.commons.util.Experimental;\n+\n+/**\n+ * Interface to implement an exponential back-off algorithm that retries the request based on the result of the remote\n+ * operation.\n+ * <p>\n+ * Currently only used for IRAC, this interface contains 2 methods: {@link #backoffSleep()} which should be invoked if\n+ * the request needs to be retried and {@link #reset()}, invoked when a request is \"successful\", which resets the\n+ * state.\n+ * <p>\n+ * The interface may me changed in the future to include async methods.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+@Experimental\n+public interface ExponentialBackOff {\n+\n+   /**\n+    * Disabled exponential back-off algorithm. It does nothing.\n+    */\n+   ExponentialBackOff NO_OP = new ExponentialBackOff() {\n+      @Override\n+      public void backoffSleep() {\n+         //no-op\n+      }\n+\n+      @Override\n+      public void reset() {\n+         //no-op\n+      }\n+   };\n+\n+   /**\n+    * It blocks the thread for a certain amount of time before retries the request.\n+    * <p>\n+    * The method is blocking and should be invoked when a request needs to be retried. It blocks the thread for a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8689815a1dcb68bed021e6239dff1700926a6d2"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2MDUyNQ==", "bodyText": "this is on the sending. IRAC has a dedicated thread looping through the changed keys. Sleep if fine here since the thread isn't used for anything else.", "url": "https://github.com/infinispan/infinispan/pull/8672#discussion_r487160525", "createdAt": "2020-09-11T16:36:47Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/util/ExponentialBackOff.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.infinispan.util;\n+\n+import org.infinispan.commons.util.Experimental;\n+\n+/**\n+ * Interface to implement an exponential back-off algorithm that retries the request based on the result of the remote\n+ * operation.\n+ * <p>\n+ * Currently only used for IRAC, this interface contains 2 methods: {@link #backoffSleep()} which should be invoked if\n+ * the request needs to be retried and {@link #reset()}, invoked when a request is \"successful\", which resets the\n+ * state.\n+ * <p>\n+ * The interface may me changed in the future to include async methods.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+@Experimental\n+public interface ExponentialBackOff {\n+\n+   /**\n+    * Disabled exponential back-off algorithm. It does nothing.\n+    */\n+   ExponentialBackOff NO_OP = new ExponentialBackOff() {\n+      @Override\n+      public void backoffSleep() {\n+         //no-op\n+      }\n+\n+      @Override\n+      public void reset() {\n+         //no-op\n+      }\n+   };\n+\n+   /**\n+    * It blocks the thread for a certain amount of time before retries the request.\n+    * <p>\n+    * The method is blocking and should be invoked when a request needs to be retried. It blocks the thread for a", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyODk3Mw=="}, "originalCommit": {"oid": "d8689815a1dcb68bed021e6239dff1700926a6d2"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUzMDc0MQ==", "bodyText": "Okay, tbh I was even going to discuss possibly removing the IRAC thread at some point and just submit as needed and/or use the scheduled executor so we don't need an additional thread. However it isn't worth it to do in this PR it seems.", "url": "https://github.com/infinispan/infinispan/pull/8672#discussion_r494530741", "createdAt": "2020-09-24T18:33:52Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/ExponentialBackOff.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.infinispan.util;\n+\n+import org.infinispan.commons.util.Experimental;\n+\n+/**\n+ * Interface to implement an exponential back-off algorithm that retries the request based on the result of the remote\n+ * operation.\n+ * <p>\n+ * Currently only used for IRAC, this interface contains 2 methods: {@link #backoffSleep()} which should be invoked if\n+ * the request needs to be retried and {@link #reset()}, invoked when a request is \"successful\", which resets the\n+ * state.\n+ * <p>\n+ * The interface may me changed in the future to include async methods.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+@Experimental\n+public interface ExponentialBackOff {\n+\n+   /**\n+    * Disabled exponential back-off algorithm. It does nothing.\n+    */\n+   ExponentialBackOff NO_OP = new ExponentialBackOff() {\n+      @Override\n+      public void backoffSleep() {\n+         //no-op\n+      }\n+\n+      @Override\n+      public void reset() {\n+         //no-op\n+      }\n+   };\n+\n+   /**\n+    * It blocks the thread for a certain amount of time before retries the request.\n+    * <p>\n+    * The method is blocking and should be invoked when a request needs to be retried. It blocks the thread for a", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyODk3Mw=="}, "originalCommit": {"oid": "d8689815a1dcb68bed021e6239dff1700926a6d2"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0MjUyNQ==", "bodyText": "My idea is to use the BlockingManager directly. Use one BlockingThread to send the requests (since they may involve persistence) could save some thread spawning. Also, I need to avoid spawning a thread if a batch is in progress. Something like this:\n\nSpawn single BlockThread and block more thread spawning\nSend all the requests and return the thread to BlockingManager\nWhen all requests finish, spawn a BlockThread to handle the replies\na. if not more keys to send, allow thread spawning and return the thread to BlockingManager\nb. else, send the next batch (goto 2)", "url": "https://github.com/infinispan/infinispan/pull/8672#discussion_r494842525", "createdAt": "2020-09-25T08:49:16Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/util/ExponentialBackOff.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.infinispan.util;\n+\n+import org.infinispan.commons.util.Experimental;\n+\n+/**\n+ * Interface to implement an exponential back-off algorithm that retries the request based on the result of the remote\n+ * operation.\n+ * <p>\n+ * Currently only used for IRAC, this interface contains 2 methods: {@link #backoffSleep()} which should be invoked if\n+ * the request needs to be retried and {@link #reset()}, invoked when a request is \"successful\", which resets the\n+ * state.\n+ * <p>\n+ * The interface may me changed in the future to include async methods.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+@Experimental\n+public interface ExponentialBackOff {\n+\n+   /**\n+    * Disabled exponential back-off algorithm. It does nothing.\n+    */\n+   ExponentialBackOff NO_OP = new ExponentialBackOff() {\n+      @Override\n+      public void backoffSleep() {\n+         //no-op\n+      }\n+\n+      @Override\n+      public void reset() {\n+         //no-op\n+      }\n+   };\n+\n+   /**\n+    * It blocks the thread for a certain amount of time before retries the request.\n+    * <p>\n+    * The method is blocking and should be invoked when a request needs to be retried. It blocks the thread for a", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyODk3Mw=="}, "originalCommit": {"oid": "d8689815a1dcb68bed021e6239dff1700926a6d2"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzEwMTk3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/ExponentialBackOff.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTo0MDoyNVrOHQkAeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTo0MDoyNVrOHQkAeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEyOTIwOA==", "bodyText": "I wouldn't mention that it is used by IRAC in the comments.", "url": "https://github.com/infinispan/infinispan/pull/8672#discussion_r487129208", "createdAt": "2020-09-11T15:40:25Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/ExponentialBackOff.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.infinispan.util;\n+\n+import org.infinispan.commons.util.Experimental;\n+\n+/**\n+ * Interface to implement an exponential back-off algorithm that retries the request based on the result of the remote\n+ * operation.\n+ * <p>\n+ * Currently only used for IRAC, this interface contains 2 methods: {@link #backoffSleep()} which should be invoked if", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8689815a1dcb68bed021e6239dff1700926a6d2"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NzExMDY3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/ExponentialBackOffImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTo0Mjo0M1rOHQkFyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxNTo0Mjo0M1rOHQkFyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzEzMDU3MQ==", "bodyText": "Should be able to be package private?", "url": "https://github.com/infinispan/infinispan/pull/8672#discussion_r487130571", "createdAt": "2020-09-11T15:42:43Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/ExponentialBackOffImpl.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.infinispan.util;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * The default {@link ExponentialBackOff} implementation for IRAC (asynchronous cross-site replication).\n+ * <p>\n+ * An exponential back-off implementation with min interval of 500 ms and a maximum of 300'000 ms (5 min). It uses a\n+ * multiplier of 2 (each timeslot will be increase + 100% for each consecutive retry) and the final wait time is\n+ * randomized, +- 50% of the timeslot.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+public class ExponentialBackOffImpl implements ExponentialBackOff {\n+\n+   private static final Log log = LogFactory.getLog(ExponentialBackOffImpl.class);\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   //TODO currently only used by IRAC. If required, make it configurable (those 4 constants) to cover other uses cases.\n+   //multiplier value (2 == +100% per retry)\n+   private static final double MULTIPLIER = 2;\n+   //initial interval value in milliseconds\n+   private static final int INITIAL_INTERVAL_MILLIS = 500;\n+   //maximum back off time in milliseconds (300 seconds == 5 min)\n+   private static final int MAX_INTERVAL_MILLIS = 300_000;\n+   //randomization factor (0.5 == 50% below and 50% above the retry interval).\n+   private static final double RANDOMIZATION_FACTOR = 0.5;\n+\n+   //the current retry timeout. If a retry occurs, it will wait for this time +- RANDOMIZATION_FACTOR (%)\n+   private int currentIntervalMillis;\n+\n+   public ExponentialBackOffImpl() {\n+      this.currentIntervalMillis = INITIAL_INTERVAL_MILLIS;\n+   }\n+\n+   public long nextBackOffMillis() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8689815a1dcb68bed021e6239dff1700926a6d2"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTExMjg5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/util/ExponentialBackOffImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxODo0MDozOVrOHXn_xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwODo0OToyNVrOHX6zIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUzNDU5Nw==", "bodyText": "Maybe include the sleep duration in the trace message.", "url": "https://github.com/infinispan/infinispan/pull/8672#discussion_r494534597", "createdAt": "2020-09-24T18:40:39Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/ExponentialBackOffImpl.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.infinispan.util;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * The default {@link ExponentialBackOff} implementation for IRAC (asynchronous cross-site replication).\n+ * <p>\n+ * An exponential back-off implementation with min interval of 500 ms and a maximum of 300'000 ms (5 min). It uses a\n+ * multiplier of 2 (each timeslot will be increase + 100% for each consecutive retry) and the final wait time is\n+ * randomized, +- 50% of the timeslot.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+public class ExponentialBackOffImpl implements ExponentialBackOff {\n+\n+   private static final Log log = LogFactory.getLog(ExponentialBackOffImpl.class);\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   //TODO currently only used by IRAC. If required, make it configurable (those 4 constants) to cover other uses cases.\n+   //multiplier value (2 == +100% per retry)\n+   private static final double MULTIPLIER = 2;\n+   //initial interval value in milliseconds\n+   private static final int INITIAL_INTERVAL_MILLIS = 500;\n+   //maximum back off time in milliseconds (300 seconds == 5 min)\n+   private static final int MAX_INTERVAL_MILLIS = 300_000;\n+   //randomization factor (0.5 == 50% below and 50% above the retry interval).\n+   private static final double RANDOMIZATION_FACTOR = 0.5;\n+\n+   //the current retry timeout. If a retry occurs, it will wait for this time +- RANDOMIZATION_FACTOR (%)\n+   private int currentIntervalMillis;\n+\n+   public ExponentialBackOffImpl() {\n+      this.currentIntervalMillis = INITIAL_INTERVAL_MILLIS;\n+   }\n+\n+   long nextBackOffMillis() {\n+      //public for unit test purposes.\n+      if (currentIntervalMillis >= MAX_INTERVAL_MILLIS) {\n+         if (trace) {\n+            log.tracef(\"Next backoff time %s ms\", MAX_INTERVAL_MILLIS);\n+         }\n+         return MAX_INTERVAL_MILLIS;\n+      }\n+      int randomIntervalMillis = getRandomValueFromInterval();\n+      incrementCurrentInterval();\n+      if (trace) {\n+         log.tracef(\"Next backoff time %s ms\", randomIntervalMillis);\n+      }\n+      return Math.min(randomIntervalMillis, MAX_INTERVAL_MILLIS);\n+   }\n+\n+   @Override\n+   public void backoffSleep() throws InterruptedException {\n+      if (trace) {\n+         log.trace(\"backing-off...\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84bd7939c7147689216ebab8ad1c3d2f48d08dfe"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDg0MjY1Nw==", "bodyText": "done!", "url": "https://github.com/infinispan/infinispan/pull/8672#discussion_r494842657", "createdAt": "2020-09-25T08:49:25Z", "author": {"login": "pruivo"}, "path": "core/src/main/java/org/infinispan/util/ExponentialBackOffImpl.java", "diffHunk": "@@ -0,0 +1,82 @@\n+package org.infinispan.util;\n+\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * The default {@link ExponentialBackOff} implementation for IRAC (asynchronous cross-site replication).\n+ * <p>\n+ * An exponential back-off implementation with min interval of 500 ms and a maximum of 300'000 ms (5 min). It uses a\n+ * multiplier of 2 (each timeslot will be increase + 100% for each consecutive retry) and the final wait time is\n+ * randomized, +- 50% of the timeslot.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+public class ExponentialBackOffImpl implements ExponentialBackOff {\n+\n+   private static final Log log = LogFactory.getLog(ExponentialBackOffImpl.class);\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   //TODO currently only used by IRAC. If required, make it configurable (those 4 constants) to cover other uses cases.\n+   //multiplier value (2 == +100% per retry)\n+   private static final double MULTIPLIER = 2;\n+   //initial interval value in milliseconds\n+   private static final int INITIAL_INTERVAL_MILLIS = 500;\n+   //maximum back off time in milliseconds (300 seconds == 5 min)\n+   private static final int MAX_INTERVAL_MILLIS = 300_000;\n+   //randomization factor (0.5 == 50% below and 50% above the retry interval).\n+   private static final double RANDOMIZATION_FACTOR = 0.5;\n+\n+   //the current retry timeout. If a retry occurs, it will wait for this time +- RANDOMIZATION_FACTOR (%)\n+   private int currentIntervalMillis;\n+\n+   public ExponentialBackOffImpl() {\n+      this.currentIntervalMillis = INITIAL_INTERVAL_MILLIS;\n+   }\n+\n+   long nextBackOffMillis() {\n+      //public for unit test purposes.\n+      if (currentIntervalMillis >= MAX_INTERVAL_MILLIS) {\n+         if (trace) {\n+            log.tracef(\"Next backoff time %s ms\", MAX_INTERVAL_MILLIS);\n+         }\n+         return MAX_INTERVAL_MILLIS;\n+      }\n+      int randomIntervalMillis = getRandomValueFromInterval();\n+      incrementCurrentInterval();\n+      if (trace) {\n+         log.tracef(\"Next backoff time %s ms\", randomIntervalMillis);\n+      }\n+      return Math.min(randomIntervalMillis, MAX_INTERVAL_MILLIS);\n+   }\n+\n+   @Override\n+   public void backoffSleep() throws InterruptedException {\n+      if (trace) {\n+         log.trace(\"backing-off...\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDUzNDU5Nw=="}, "originalCommit": {"oid": "84bd7939c7147689216ebab8ad1c3d2f48d08dfe"}, "originalPosition": 59}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3929, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}