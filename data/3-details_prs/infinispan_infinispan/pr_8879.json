{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI1ODM4Njk0", "number": 8879, "title": "ISPN-12477 Remove IRAC sender thread", "bodyText": "https://issues.redhat.com/browse/ISPN-12477", "createdAt": "2020-11-23T16:10:39Z", "url": "https://github.com/infinispan/infinispan/pull/8879", "merged": true, "mergeCommit": {"oid": "ddbc81ca89dd12605b9c96e309a46f302040041d"}, "closed": true, "closedAt": "2020-12-09T16:31:28Z", "author": {"login": "pruivo"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdimCXNAFqTU0NDA5MjcxMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkcXtigBqjQwODkyNjA2OTI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MDkyNzEy", "url": "https://github.com/infinispan/infinispan/pull/8879#pullrequestreview-544092712", "createdAt": "2020-12-03T15:40:22Z", "commit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNTo0MDoyMlrOH-izrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNjo0NDo1MFrOH-mKGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0NDA0Nw==", "bodyText": "We should be able to utilize the segment from the command if it is a single key command. Otherwise we will have to calculate the segment for each command. Sadly multi put doesn't yet have this optimization.", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535344047", "createdAt": "2020-12-03T15:40:22Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java", "diffHunk": "@@ -134,4 +146,12 @@ private Object handleClearReturn(InvocationContext ctx, ClearCommand rCommand, O\n          return localTx.getModifications().stream();\n       }\n    }\n+\n+   public Stream<?> keysFromMods(Stream<WriteCommand> modifications) {\n+      return modifications\n+            .filter(WriteCommand::isSuccessful)\n+            .filter(BaseBackupInterceptor::backupToRemoteSite)\n+            .flatMap(BaseBackupInterceptor::keyStream)\n+            .filter(this::isWriteOwner);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0NDg4OQ==", "bodyText": "We again calculate the segment for the key here too. Is there a better way we can share the segment down the line?", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535344889", "createdAt": "2020-12-03T15:41:08Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/interceptors/xsite/OptimisticBackupInterceptor.java", "diffHunk": "@@ -44,13 +44,13 @@ public Object visitCommitCommand(TxInvocationContext ctx, CommitCommand command)\n \n       return invokeNextThenApply(ctx, command, (rCtx, rCommand, rv) -> {\n          //we need to track the keys only after it is applied in the local node!\n-         iracManager.trackKeysFromTransaction(getModificationsFrom(rCommand), rCommand.getGlobalTransaction());\n+         keysFromMods(getModificationsFrom(rCommand)).forEach(key -> iracManager.trackUpdatedKey(getSegment(key), key, rCommand.getGlobalTransaction()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0NTI1Nw==", "bodyText": "Same here about segment being recalculated.", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535345257", "createdAt": "2020-12-03T15:41:29Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/interceptors/xsite/PessimisticBackupInterceptor.java", "diffHunk": "@@ -40,7 +40,8 @@ public Object visitPrepareCommand(TxInvocationContext ctx, PrepareCommand comman\n \n       return invokeNextThenApply(ctx, command, (rCtx, rCommand, rv) -> {\n          //for async, all nodes need to keep track of the updates keys after it is applied locally.\n-         iracManager.trackKeysFromTransaction(Arrays.stream(rCommand.getModifications()), rCommand.getGlobalTransaction());\n+         keysFromMods(Arrays.stream(rCommand.getModifications()))\n+               .forEach(key -> iracManager.trackUpdatedKey(getSegment(key), key, rCommand.getGlobalTransaction()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0NjQ1Mw==", "bodyText": "It seems we can remove backoffSleep now?", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535346453", "createdAt": "2020-12-03T15:42:34Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/ExponentialBackOff.java", "diffHunk": "@@ -50,4 +58,12 @@ public void reset() {\n     */\n    void reset();\n \n+   /**\n+    * Same as {@link #backoffSleep()} but it returns a {@link CompletionStage} which is completed after the back-off", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1MzUyNQ==", "bodyText": "I assume the use of thenCompose(this) is to avoid the lambda allocation?", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535353525", "createdAt": "2020-12-03T15:49:10Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/irac/IracExecutor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.infinispan.xsite.irac;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.util.ExponentialBackOff;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.concurrent.WithinThreadExecutor;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * Executes the \"IRAC\" sending task in a single thread.\n+ * <p>\n+ * This executor makes sure no more than one task is running at the same time. Also, it avoids \"queueing\" multiple tasks\n+ * by queuing at most one. This is possible because the task does the same thing: iterator over pending updates and send\n+ * them to the remote site.\n+ * <p>\n+ * In addition, it iteracts with the {@link ExponentialBackOff} to add delays in case of network failures.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12\n+ */\n+public class IracExecutor implements Function<Void, CompletionStage<Void>> {\n+\n+   private static final Log log = LogFactory.getLog(IracExecutor.class);\n+\n+   private final WrappedRunnable runnable;\n+   private volatile CompletableFuture<Void> lastRunnable;\n+   private volatile Executor executor;\n+   private volatile ExponentialBackOff backOff;\n+   final AtomicBoolean hasPendingRunnable;\n+   private volatile boolean backOffEnabled;\n+\n+\n+   public IracExecutor(Supplier<CompletionStage<Void>> runnable) {\n+      this.runnable = new WrappedRunnable(Objects.requireNonNull(runnable));\n+      this.lastRunnable = CompletableFutures.completedNull();\n+      this.executor = new WithinThreadExecutor();\n+      this.hasPendingRunnable = new AtomicBoolean();\n+   }\n+\n+   public void setExecutor(Executor executor) {\n+      this.executor = Objects.requireNonNull(executor);\n+   }\n+\n+   public void setBackOff(ExponentialBackOff backOff) {\n+      this.backOff = Objects.requireNonNull(backOff);\n+   }\n+\n+   /**\n+    * Executes, in a new thread, or queues the task.\n+    */\n+   public void run() {\n+      if (hasPendingRunnable.compareAndSet(false, true)) {\n+         if (backOffEnabled) {\n+            //noinspection NonAtomicOperationOnVolatileField\n+            lastRunnable = lastRunnable.thenCompose(this).thenComposeAsync(runnable, executor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM1NDc4MA==", "bodyText": "Maybe I am misreading but doesn't this mean you can run another task at the same time if IracExecutor#run is invoked while runnable supplier is being invoked and the stage has not been completed? Or what is the definition of a task in the class javadoc header?", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535354780", "createdAt": "2020-12-03T15:50:13Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/irac/IracExecutor.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package org.infinispan.xsite.irac;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.util.ExponentialBackOff;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.concurrent.WithinThreadExecutor;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+\n+/**\n+ * Executes the \"IRAC\" sending task in a single thread.\n+ * <p>\n+ * This executor makes sure no more than one task is running at the same time. Also, it avoids \"queueing\" multiple tasks\n+ * by queuing at most one. This is possible because the task does the same thing: iterator over pending updates and send\n+ * them to the remote site.\n+ * <p>\n+ * In addition, it iteracts with the {@link ExponentialBackOff} to add delays in case of network failures.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12\n+ */\n+public class IracExecutor implements Function<Void, CompletionStage<Void>> {\n+\n+   private static final Log log = LogFactory.getLog(IracExecutor.class);\n+\n+   private final WrappedRunnable runnable;\n+   private volatile CompletableFuture<Void> lastRunnable;\n+   private volatile Executor executor;\n+   private volatile ExponentialBackOff backOff;\n+   final AtomicBoolean hasPendingRunnable;\n+   private volatile boolean backOffEnabled;\n+\n+\n+   public IracExecutor(Supplier<CompletionStage<Void>> runnable) {\n+      this.runnable = new WrappedRunnable(Objects.requireNonNull(runnable));\n+      this.lastRunnable = CompletableFutures.completedNull();\n+      this.executor = new WithinThreadExecutor();\n+      this.hasPendingRunnable = new AtomicBoolean();\n+   }\n+\n+   public void setExecutor(Executor executor) {\n+      this.executor = Objects.requireNonNull(executor);\n+   }\n+\n+   public void setBackOff(ExponentialBackOff backOff) {\n+      this.backOff = Objects.requireNonNull(backOff);\n+   }\n+\n+   /**\n+    * Executes, in a new thread, or queues the task.\n+    */\n+   public void run() {\n+      if (hasPendingRunnable.compareAndSet(false, true)) {\n+         if (backOffEnabled) {\n+            //noinspection NonAtomicOperationOnVolatileField\n+            lastRunnable = lastRunnable.thenCompose(this).thenComposeAsync(runnable, executor);\n+         } else {\n+            //noinspection NonAtomicOperationOnVolatileField\n+            lastRunnable = lastRunnable.thenComposeAsync(runnable, executor);\n+         }\n+      }\n+   }\n+\n+   public void enableBackOff() {\n+      backOffEnabled = true;\n+   }\n+\n+   public void disableBackOff() {\n+      backOffEnabled = false;\n+      backOff.reset();\n+   }\n+\n+   /**\n+    * Used by {@link CompletableFuture#thenComposeAsync(Function, Executor)}, it adds the {@link ExponentialBackOff}\n+    * delay.\n+    *\n+    * @param unused Unused value.\n+    * @return The {@link CompletionStage} from {@link ExponentialBackOff#asyncBackOff()}.\n+    */\n+   @Override\n+   public CompletionStage<Void> apply(Void unused) {\n+      return backOff.asyncBackOff();\n+   }\n+\n+   private class WrappedRunnable implements Function<Void, CompletionStage<Void>> {\n+      private final Supplier<CompletionStage<Void>> runnable;\n+\n+      private WrappedRunnable(Supplier<CompletionStage<Void>> runnable) {\n+         this.runnable = runnable;\n+      }\n+\n+      /**\n+       * Use by {@link CompletableFuture#thenComposeAsync(Function, Executor)}, executes the task and returns the {@link\n+       * CompletionStage} return by it.\n+       *\n+       * @param unused Unused value.\n+       * @return The {@link CompletionStage} from the task.\n+       */\n+      @Override\n+      public CompletionStage<Void> apply(Void unused) {\n+         hasPendingRunnable.set(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM2MjE3OA==", "bodyText": "This class really reminds me of the AggregateCompletionStage. Is there no way we can use that instead of adding more aggregation logic?", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535362178", "createdAt": "2020-12-03T15:58:54Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/irac/IracResponseCollector.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package org.infinispan.xsite.irac;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.function.BiConsumer;\n+\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.infinispan.xsite.status.DefaultTakeOfflineManager;\n+\n+import net.jcip.annotations.GuardedBy;\n+\n+/**\n+ * A response collector for a single key update.\n+ * <p>\n+ * This class extends {@link CompletableFuture}. It is completed when all sites involved in the updated have replied (or\n+ * timed-out). There are 3 possible outcomes enumerated by {@link Result}.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12\n+ */\n+public class IracResponseCollector extends CompletableFuture<IracResponseCollector.Result> implements BiConsumer<Void, Throwable> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5ODkzOA==", "bodyText": "Can't this be the non blocking executor? Or does something block in DefaultIracManager#run?", "url": "https://github.com/infinispan/infinispan/pull/8879#discussion_r535398938", "createdAt": "2020-12-03T16:44:50Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/irac/DefaultIracManager.java", "diffHunk": "@@ -73,115 +69,66 @@\n  * @since 11.0\n  */\n @Scope(Scopes.NAMED_CACHE)\n-public class DefaultIracManager implements IracManager, Runnable {\n+public class DefaultIracManager implements IracManager {\n \n    private static final Log log = LogFactory.getLog(DefaultIracManager.class);\n    private static final boolean trace = log.isTraceEnabled();\n \n    @Inject RpcManager rpcManager;\n-   @Inject Configuration config;\n    @Inject TakeOfflineManager takeOfflineManager;\n    @Inject ClusteringDependentLogic clusteringDependentLogic;\n    @Inject CommandsFactory commandsFactory;\n    @Inject IracVersionGenerator iracVersionGenerator;\n \n-   private final Map<Object, Object> updatedKeys;\n-   private final Semaphore senderNotifier;\n-   private volatile ExponentialBackOff backOff;\n+   private final Map<Object, State> updatedKeys;\n+   private final Collection<XSiteBackup> asyncBackups;\n+   private final IracExecutor iracExecutor;\n    private volatile boolean hasClear;\n-   private volatile Collection<XSiteBackup> asyncBackups;\n-   private volatile Thread sender;\n-   private volatile boolean running;\n \n-   public DefaultIracManager() {\n+   public DefaultIracManager(Configuration config) {\n       this.updatedKeys = new ConcurrentHashMap<>();\n-      this.senderNotifier = new Semaphore(0);\n-      this.backOff = new ExponentialBackOffImpl();\n+      this.iracExecutor = new IracExecutor(this::run);\n+      this.asyncBackups = asyncBackups(config);\n    }\n \n-   private static Collection<XSiteBackup> asyncBackups(Configuration config, String localSiteName) {\n+   private static Collection<XSiteBackup> asyncBackups(Configuration config) {\n       return config.sites().asyncBackupsStream()\n-            .filter(bc -> !localSiteName.equals(bc.site()))\n             .map(bc -> new XSiteBackup(bc.site(), true, bc.replicationTimeout())) //convert to sync\n             .collect(Collectors.toList());\n    }\n \n-   private static Stream<?> keyStream(WriteCommand command) {\n-      return command.getAffectedKeys().stream();\n-   }\n-\n-   private static boolean backupToRemoteSite(WriteCommand command) {\n-      return !command.hasAnyFlag(FlagBitSets.SKIP_XSITE_BACKUP);\n-   }\n-\n    private static IntSet newIntSet(Address ignored) {\n       return IntSets.mutableEmptySet();\n    }\n \n+   @Inject\n+   public void inject(@ComponentName(KnownComponentNames.TIMEOUT_SCHEDULE_EXECUTOR) ScheduledExecutorService executorService,\n+                      @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR) Executor blockingExecutor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58"}, "originalPosition": 119}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dda8a648db53be74a8f1da359109f8b322779b58", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/dda8a648db53be74a8f1da359109f8b322779b58", "committedDate": "2020-11-23T16:10:04Z", "message": "ISPN-12477 Remove IRAC sender thread"}, "afterCommit": {"oid": "eb4b6894ddbda4743a5888fce41bad28f7bc1f33", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/eb4b6894ddbda4743a5888fce41bad28f7bc1f33", "committedDate": "2020-12-04T16:50:17Z", "message": "ISPN-12477 Remove IRAC sender thread"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NTA5MjIz", "url": "https://github.com/infinispan/infinispan/pull/8879#pullrequestreview-546509223", "createdAt": "2020-12-07T20:27:46Z", "commit": {"oid": "eb4b6894ddbda4743a5888fce41bad28f7bc1f33"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80bb1afd5221e67ddbd7c10781a96a4888fb1173", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/80bb1afd5221e67ddbd7c10781a96a4888fb1173", "committedDate": "2020-12-09T10:24:28Z", "message": "ISPN-12477 Remove IRAC sender thread"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eb4b6894ddbda4743a5888fce41bad28f7bc1f33", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/eb4b6894ddbda4743a5888fce41bad28f7bc1f33", "committedDate": "2020-12-04T16:50:17Z", "message": "ISPN-12477 Remove IRAC sender thread"}, "afterCommit": {"oid": "80bb1afd5221e67ddbd7c10781a96a4888fb1173", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/80bb1afd5221e67ddbd7c10781a96a4888fb1173", "committedDate": "2020-12-09T10:24:28Z", "message": "ISPN-12477 Remove IRAC sender thread"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 310, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}