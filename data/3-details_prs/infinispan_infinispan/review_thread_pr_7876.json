{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczODM1MTM2", "number": 7876, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMToxNzozNFrODe9tpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjowMTowOVrODe-jmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzk0OTgyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/container/impl/DefaultSegmentedDataContainer.java", "isResolved": false, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMToxNzozNFrOFoZZng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNTo0NjozMlrOFoz1iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkwMzUxOA==", "bodyText": "AFAICT the PeekableTouchableMap impls implement Lifecycle, not AutoCloseable, so maybe this code isn't needed at all?", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r377903518", "createdAt": "2020-02-11T21:17:34Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/container/impl/DefaultSegmentedDataContainer.java", "diffHunk": "@@ -234,11 +234,11 @@ public void removeSegments(IntSet segments) {\n \n    private void startNewMap(int segment) {\n       if (maps.get(segment) == null) {\n-         PeekableTouchableContainerMap<K, V> newMap = new PeekableTouchableContainerMap<>(mapSupplier.get());\n+         PeekableTouchableMap<K, InternalCacheEntry<K, V>> newMap = mapSupplier.get();\n          // Just in case of concurrent starts - this shouldn't be possible\n-         if (!maps.compareAndSet(segment, null, newMap) && newMap.delegate() instanceof AutoCloseable) {\n+         if (!maps.compareAndSet(segment, null, newMap) && newMap instanceof AutoCloseable) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzODg4NQ==", "bodyText": "https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/container/offheap/OffHeapConcurrentMap.java#L84 is the one that doesn't.", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r378238885", "createdAt": "2020-02-12T13:09:03Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/container/impl/DefaultSegmentedDataContainer.java", "diffHunk": "@@ -234,11 +234,11 @@ public void removeSegments(IntSet segments) {\n \n    private void startNewMap(int segment) {\n       if (maps.get(segment) == null) {\n-         PeekableTouchableContainerMap<K, V> newMap = new PeekableTouchableContainerMap<>(mapSupplier.get());\n+         PeekableTouchableMap<K, InternalCacheEntry<K, V>> newMap = mapSupplier.get();\n          // Just in case of concurrent starts - this shouldn't be possible\n-         if (!maps.compareAndSet(segment, null, newMap) && newMap.delegate() instanceof AutoCloseable) {\n+         if (!maps.compareAndSet(segment, null, newMap) && newMap instanceof AutoCloseable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkwMzUxOA=="}, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI4Mjc2MA==", "bodyText": "PeekableTouchableContainerMap doesn't implement AutoCloseable either", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r378282760", "createdAt": "2020-02-12T14:25:56Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/container/impl/DefaultSegmentedDataContainer.java", "diffHunk": "@@ -234,11 +234,11 @@ public void removeSegments(IntSet segments) {\n \n    private void startNewMap(int segment) {\n       if (maps.get(segment) == null) {\n-         PeekableTouchableContainerMap<K, V> newMap = new PeekableTouchableContainerMap<>(mapSupplier.get());\n+         PeekableTouchableMap<K, InternalCacheEntry<K, V>> newMap = mapSupplier.get();\n          // Just in case of concurrent starts - this shouldn't be possible\n-         if (!maps.compareAndSet(segment, null, newMap) && newMap.delegate() instanceof AutoCloseable) {\n+         if (!maps.compareAndSet(segment, null, newMap) && newMap instanceof AutoCloseable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkwMzUxOA=="}, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI4NzM1OA==", "bodyText": "Yeah it doesn't need it though, it is all on heap with nothing started :)", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r378287358", "createdAt": "2020-02-12T14:33:09Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/container/impl/DefaultSegmentedDataContainer.java", "diffHunk": "@@ -234,11 +234,11 @@ public void removeSegments(IntSet segments) {\n \n    private void startNewMap(int segment) {\n       if (maps.get(segment) == null) {\n-         PeekableTouchableContainerMap<K, V> newMap = new PeekableTouchableContainerMap<>(mapSupplier.get());\n+         PeekableTouchableMap<K, InternalCacheEntry<K, V>> newMap = mapSupplier.get();\n          // Just in case of concurrent starts - this shouldn't be possible\n-         if (!maps.compareAndSet(segment, null, newMap) && newMap.delegate() instanceof AutoCloseable) {\n+         if (!maps.compareAndSet(segment, null, newMap) && newMap instanceof AutoCloseable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkwMzUxOA=="}, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI4NzY2Ng==", "bodyText": "Unless I am missing a reference somewhere, in which case it would need fixing.", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r378287666", "createdAt": "2020-02-12T14:33:38Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/container/impl/DefaultSegmentedDataContainer.java", "diffHunk": "@@ -234,11 +234,11 @@ public void removeSegments(IntSet segments) {\n \n    private void startNewMap(int segment) {\n       if (maps.get(segment) == null) {\n-         PeekableTouchableContainerMap<K, V> newMap = new PeekableTouchableContainerMap<>(mapSupplier.get());\n+         PeekableTouchableMap<K, InternalCacheEntry<K, V>> newMap = mapSupplier.get();\n          // Just in case of concurrent starts - this shouldn't be possible\n-         if (!maps.compareAndSet(segment, null, newMap) && newMap.delegate() instanceof AutoCloseable) {\n+         if (!maps.compareAndSet(segment, null, newMap) && newMap instanceof AutoCloseable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkwMzUxOA=="}, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyMzI2Ng==", "bodyText": "I'm not saying it needs AutoCloseable, I'm just saying this code is never executed because none of the classes implement AutoCloseable.", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r378323266", "createdAt": "2020-02-12T15:27:22Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/container/impl/DefaultSegmentedDataContainer.java", "diffHunk": "@@ -234,11 +234,11 @@ public void removeSegments(IntSet segments) {\n \n    private void startNewMap(int segment) {\n       if (maps.get(segment) == null) {\n-         PeekableTouchableContainerMap<K, V> newMap = new PeekableTouchableContainerMap<>(mapSupplier.get());\n+         PeekableTouchableMap<K, InternalCacheEntry<K, V>> newMap = mapSupplier.get();\n          // Just in case of concurrent starts - this shouldn't be possible\n-         if (!maps.compareAndSet(segment, null, newMap) && newMap.delegate() instanceof AutoCloseable) {\n+         if (!maps.compareAndSet(segment, null, newMap) && newMap instanceof AutoCloseable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkwMzUxOA=="}, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyNTIxMQ==", "bodyText": "OffHeapConcurrentMap does as I linked, I just accidentally put master instead of 9.4.x\nhttps://github.com/infinispan/infinispan/blob/9.4.x/core/src/main/java/org/infinispan/container/offheap/OffHeapConcurrentMap.java#L33", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r378325211", "createdAt": "2020-02-12T15:30:02Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/container/impl/DefaultSegmentedDataContainer.java", "diffHunk": "@@ -234,11 +234,11 @@ public void removeSegments(IntSet segments) {\n \n    private void startNewMap(int segment) {\n       if (maps.get(segment) == null) {\n-         PeekableTouchableContainerMap<K, V> newMap = new PeekableTouchableContainerMap<>(mapSupplier.get());\n+         PeekableTouchableMap<K, InternalCacheEntry<K, V>> newMap = mapSupplier.get();\n          // Just in case of concurrent starts - this shouldn't be possible\n-         if (!maps.compareAndSet(segment, null, newMap) && newMap.delegate() instanceof AutoCloseable) {\n+         if (!maps.compareAndSet(segment, null, newMap) && newMap instanceof AutoCloseable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkwMzUxOA=="}, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyNTQyNA==", "bodyText": "ah it used to, refactoring at its best.", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r378325424", "createdAt": "2020-02-12T15:30:19Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/container/impl/DefaultSegmentedDataContainer.java", "diffHunk": "@@ -234,11 +234,11 @@ public void removeSegments(IntSet segments) {\n \n    private void startNewMap(int segment) {\n       if (maps.get(segment) == null) {\n-         PeekableTouchableContainerMap<K, V> newMap = new PeekableTouchableContainerMap<>(mapSupplier.get());\n+         PeekableTouchableMap<K, InternalCacheEntry<K, V>> newMap = mapSupplier.get();\n          // Just in case of concurrent starts - this shouldn't be possible\n-         if (!maps.compareAndSet(segment, null, newMap) && newMap.delegate() instanceof AutoCloseable) {\n+         if (!maps.compareAndSet(segment, null, newMap) && newMap instanceof AutoCloseable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkwMzUxOA=="}, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyNTg3Nw==", "bodyText": "It does on master and 10.1.x, but not on 9.4.x is the problem.", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r378325877", "createdAt": "2020-02-12T15:30:54Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/container/impl/DefaultSegmentedDataContainer.java", "diffHunk": "@@ -234,11 +234,11 @@ public void removeSegments(IntSet segments) {\n \n    private void startNewMap(int segment) {\n       if (maps.get(segment) == null) {\n-         PeekableTouchableContainerMap<K, V> newMap = new PeekableTouchableContainerMap<>(mapSupplier.get());\n+         PeekableTouchableMap<K, InternalCacheEntry<K, V>> newMap = mapSupplier.get();\n          // Just in case of concurrent starts - this shouldn't be possible\n-         if (!maps.compareAndSet(segment, null, newMap) && newMap.delegate() instanceof AutoCloseable) {\n+         if (!maps.compareAndSet(segment, null, newMap) && newMap instanceof AutoCloseable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkwMzUxOA=="}, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNjY0OA==", "bodyText": "LOL, I thought I was looking at the master code in my working dir... it took me a second to realize that I had created my task branch from 9.4.x instead of master!", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r378336648", "createdAt": "2020-02-12T15:46:32Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/container/impl/DefaultSegmentedDataContainer.java", "diffHunk": "@@ -234,11 +234,11 @@ public void removeSegments(IntSet segments) {\n \n    private void startNewMap(int segment) {\n       if (maps.get(segment) == null) {\n-         PeekableTouchableContainerMap<K, V> newMap = new PeekableTouchableContainerMap<>(mapSupplier.get());\n+         PeekableTouchableMap<K, InternalCacheEntry<K, V>> newMap = mapSupplier.get();\n          // Just in case of concurrent starts - this shouldn't be possible\n-         if (!maps.compareAndSet(segment, null, newMap) && newMap.delegate() instanceof AutoCloseable) {\n+         if (!maps.compareAndSet(segment, null, newMap) && newMap instanceof AutoCloseable) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkwMzUxOA=="}, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzk1ODEzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/container/offheap/OffHeapConcurrentMap.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMToxOTowNlrOFoZfPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMToxOTowNlrOFoZfPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkwNDk1Nw==", "bodyText": "Comment still says \"it wasn't touched\"", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r377904957", "createdAt": "2020-02-11T21:19:06Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/container/offheap/OffHeapConcurrentMap.java", "diffHunk": "@@ -58,7 +58,7 @@\n    @Override\n    public boolean touchKey(Object key, long currentTimeMillis) {\n       // OFF HEAP does not support max idle in this version - just say it wasn't touched\n-      return false;\n+      return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODA4NzkyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/factories/DataContainerFactory.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjowMTowOVrOFoaxTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNTo0OTo1OVrOFoz-Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyNTk2NQ==", "bodyText": "\ud83d\udc4d\nFor master, the declaration would be simpler if you made PeekableTouchableMap<K, V> implement ConcurrentMap<K, InternalCacheEntry<K, V>>, and the PeekableMap and TouchableMap interfaces also don't seem to be used by themselves:\n1f21b70\nI'd go even further and change the interface name, e.g. DataContainerSegment, so there's no confusion because the V means something else compared to Map.", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r377925965", "createdAt": "2020-02-11T22:01:09Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/factories/DataContainerFactory.java", "diffHunk": "@@ -65,7 +68,8 @@ public Object construct(String componentName) {\n                int addressCount = memoryConfiguration.addressCount();\n                if (shouldSegment) {\n                   int segments = clusteringConfiguration.hash().numSegments();\n-                  Supplier mapSupplier = () -> createAndStartOffHeapConcurrentMap(addressCount, segments);\n+                  Supplier<PeekableTouchableMap<WrappedBytes, InternalCacheEntry<WrappedBytes, WrappedBytes>>>\n+                        mapSupplier = () -> createAndStartOffHeapConcurrentMap(addressCount, segments);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNTY3NA==", "bodyText": "Yeah part of the problem is the disparity between 9.4.x and master. I can try to consolidate them on master better.", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r377935674", "createdAt": "2020-02-11T22:23:24Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/factories/DataContainerFactory.java", "diffHunk": "@@ -65,7 +68,8 @@ public Object construct(String componentName) {\n                int addressCount = memoryConfiguration.addressCount();\n                if (shouldSegment) {\n                   int segments = clusteringConfiguration.hash().numSegments();\n-                  Supplier mapSupplier = () -> createAndStartOffHeapConcurrentMap(addressCount, segments);\n+                  Supplier<PeekableTouchableMap<WrappedBytes, InternalCacheEntry<WrappedBytes, WrappedBytes>>>\n+                        mapSupplier = () -> createAndStartOffHeapConcurrentMap(addressCount, segments);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyNTk2NQ=="}, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyMjI5Nw==", "bodyText": "Yeah one of my issues was that PeekableMap is in commons, I wasn't quite sure about removing it.", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r378322297", "createdAt": "2020-02-12T15:25:52Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/factories/DataContainerFactory.java", "diffHunk": "@@ -65,7 +68,8 @@ public Object construct(String componentName) {\n                int addressCount = memoryConfiguration.addressCount();\n                if (shouldSegment) {\n                   int segments = clusteringConfiguration.hash().numSegments();\n-                  Supplier mapSupplier = () -> createAndStartOffHeapConcurrentMap(addressCount, segments);\n+                  Supplier<PeekableTouchableMap<WrappedBytes, InternalCacheEntry<WrappedBytes, WrappedBytes>>>\n+                        mapSupplier = () -> createAndStartOffHeapConcurrentMap(addressCount, segments);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyNTk2NQ=="}, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNzg4OQ==", "bodyText": "We don't need to remove it immediately, but don't have to keep implementing it either, because the per-segment maps were never exposed.", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r378337889", "createdAt": "2020-02-12T15:48:24Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/factories/DataContainerFactory.java", "diffHunk": "@@ -65,7 +68,8 @@ public Object construct(String componentName) {\n                int addressCount = memoryConfiguration.addressCount();\n                if (shouldSegment) {\n                   int segments = clusteringConfiguration.hash().numSegments();\n-                  Supplier mapSupplier = () -> createAndStartOffHeapConcurrentMap(addressCount, segments);\n+                  Supplier<PeekableTouchableMap<WrappedBytes, InternalCacheEntry<WrappedBytes, WrappedBytes>>>\n+                        mapSupplier = () -> createAndStartOffHeapConcurrentMap(addressCount, segments);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyNTk2NQ=="}, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzODQ4NQ==", "bodyText": "Sure, I can just deprecate it. More than likely no one is using it anyways.", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r378338485", "createdAt": "2020-02-12T15:49:21Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/factories/DataContainerFactory.java", "diffHunk": "@@ -65,7 +68,8 @@ public Object construct(String componentName) {\n                int addressCount = memoryConfiguration.addressCount();\n                if (shouldSegment) {\n                   int segments = clusteringConfiguration.hash().numSegments();\n-                  Supplier mapSupplier = () -> createAndStartOffHeapConcurrentMap(addressCount, segments);\n+                  Supplier<PeekableTouchableMap<WrappedBytes, InternalCacheEntry<WrappedBytes, WrappedBytes>>>\n+                        mapSupplier = () -> createAndStartOffHeapConcurrentMap(addressCount, segments);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyNTk2NQ=="}, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzODkwMw==", "bodyText": "I will do that in master only though.", "url": "https://github.com/infinispan/infinispan/pull/7876#discussion_r378338903", "createdAt": "2020-02-12T15:49:59Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/factories/DataContainerFactory.java", "diffHunk": "@@ -65,7 +68,8 @@ public Object construct(String componentName) {\n                int addressCount = memoryConfiguration.addressCount();\n                if (shouldSegment) {\n                   int segments = clusteringConfiguration.hash().numSegments();\n-                  Supplier mapSupplier = () -> createAndStartOffHeapConcurrentMap(addressCount, segments);\n+                  Supplier<PeekableTouchableMap<WrappedBytes, InternalCacheEntry<WrappedBytes, WrappedBytes>>>\n+                        mapSupplier = () -> createAndStartOffHeapConcurrentMap(addressCount, segments);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyNTk2NQ=="}, "originalCommit": {"oid": "6d716460226f2748dfe134a0db64dd2fd1fb160c"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4462, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}