{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQwMjkwNzg3", "number": 8938, "title": "ISPN-12261 Protocol Management", "bodyText": "https://issues.redhat.com/browse/ISPN-12261", "createdAt": "2020-12-15T14:26:00Z", "url": "https://github.com/infinispan/infinispan/pull/8938", "merged": true, "mergeCommit": {"oid": "537d58b53f058de1ee9e6e975fc99b0e8d4f4c50"}, "closed": true, "closedAt": "2021-02-24T18:08:24Z", "author": {"login": "tristantarrant"}, "timelineItems": {"totalCount": 63, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdms2-vABqjQxMTkxMDYwMzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd9TJgsAFqTU5NzY0OTQzOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8127dfdd412b519532726847276dc61486d9f579", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/8127dfdd412b519532726847276dc61486d9f579", "committedDate": "2020-12-15T14:23:31Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "181df780b61d9b4a3335ca8db4f524f3ca38b687", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/181df780b61d9b4a3335ca8db4f524f3ca38b687", "committedDate": "2020-12-16T11:02:05Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "181df780b61d9b4a3335ca8db4f524f3ca38b687", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/181df780b61d9b4a3335ca8db4f524f3ca38b687", "committedDate": "2020-12-16T11:02:05Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "2408978e15ae1deba20fc08529597f14b4fec2e2", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/2408978e15ae1deba20fc08529597f14b4fec2e2", "committedDate": "2020-12-16T12:40:41Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2408978e15ae1deba20fc08529597f14b4fec2e2", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/2408978e15ae1deba20fc08529597f14b4fec2e2", "committedDate": "2020-12-16T12:40:41Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "3f1b28a1bd71e8b344e342e2005f10d464e757e2", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/3f1b28a1bd71e8b344e342e2005f10d464e757e2", "committedDate": "2020-12-16T12:51:00Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3f1b28a1bd71e8b344e342e2005f10d464e757e2", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/3f1b28a1bd71e8b344e342e2005f10d464e757e2", "committedDate": "2020-12-16T12:51:00Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "6cb122cdc2d048827e3b28ba3b1361b2e98fa378", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/6cb122cdc2d048827e3b28ba3b1361b2e98fa378", "committedDate": "2020-12-16T16:52:18Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6cb122cdc2d048827e3b28ba3b1361b2e98fa378", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/6cb122cdc2d048827e3b28ba3b1361b2e98fa378", "committedDate": "2020-12-16T16:52:18Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "30d4fbf64aa4da7cf717f7bf6ee00f387c217406", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/30d4fbf64aa4da7cf717f7bf6ee00f387c217406", "committedDate": "2020-12-16T20:19:01Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "30d4fbf64aa4da7cf717f7bf6ee00f387c217406", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/30d4fbf64aa4da7cf717f7bf6ee00f387c217406", "committedDate": "2020-12-16T20:19:01Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "a01bb78a64610ff3155c8ce66b7f29397f8d30d7", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/a01bb78a64610ff3155c8ce66b7f29397f8d30d7", "committedDate": "2020-12-21T12:36:16Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a01bb78a64610ff3155c8ce66b7f29397f8d30d7", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/a01bb78a64610ff3155c8ce66b7f29397f8d30d7", "committedDate": "2020-12-21T12:36:16Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "e352773301aaed7019f536c498b37ae2cbbb6ca3", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/e352773301aaed7019f536c498b37ae2cbbb6ca3", "committedDate": "2020-12-21T16:35:51Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9db2241402b35d6617f9252b70f7fb13e2919588", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/9db2241402b35d6617f9252b70f7fb13e2919588", "committedDate": "2020-12-22T08:19:36Z", "message": "WIP"}, "afterCommit": {"oid": "56fcb8b29b563fc34e729682a008950210a4625f", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/56fcb8b29b563fc34e729682a008950210a4625f", "committedDate": "2020-12-22T08:26:52Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5bbb31e9c60b0fbacd20bf38c968310c58c2d4de", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/5bbb31e9c60b0fbacd20bf38c968310c58c2d4de", "committedDate": "2020-12-22T08:40:27Z", "message": "WIP"}, "afterCommit": {"oid": "da7c9a851cd8548afb943a7de7b0791a6d79a692", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/da7c9a851cd8548afb943a7de7b0791a6d79a692", "committedDate": "2020-12-22T08:44:46Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "da7c9a851cd8548afb943a7de7b0791a6d79a692", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/da7c9a851cd8548afb943a7de7b0791a6d79a692", "committedDate": "2020-12-22T08:44:46Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "a2d125f430d2f812627b2d2d6cf89567dcfd86a2", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/a2d125f430d2f812627b2d2d6cf89567dcfd86a2", "committedDate": "2020-12-22T11:13:15Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a2d125f430d2f812627b2d2d6cf89567dcfd86a2", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/a2d125f430d2f812627b2d2d6cf89567dcfd86a2", "committedDate": "2020-12-22T11:13:15Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "2fa0de52b7c0fb0ca6f996f5e088e621c44ef6a9", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/2fa0de52b7c0fb0ca6f996f5e088e621c44ef6a9", "committedDate": "2020-12-22T14:33:18Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2fa0de52b7c0fb0ca6f996f5e088e621c44ef6a9", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/2fa0de52b7c0fb0ca6f996f5e088e621c44ef6a9", "committedDate": "2020-12-22T14:33:18Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "7a444f66bcb5a8416e3b0fd7a46174b2e656f640", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/7a444f66bcb5a8416e3b0fd7a46174b2e656f640", "committedDate": "2020-12-22T17:18:07Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU3OTY0NjEx", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-557964611", "createdAt": "2020-12-23T15:24:51Z", "commit": {"oid": "7a444f66bcb5a8416e3b0fd7a46174b2e656f640"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxNToyNDo1MVrOIKn9SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yM1QxNToyNTo0OFrOIKn_Ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAxMTMzNw==", "bodyText": "replace ALLOW->ACCEPT", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r548011337", "createdAt": "2020-12-23T15:24:51Z", "author": {"login": "wfink"}, "path": "cli/src/main/java/org/infinispan/cli/logging/Messages.java", "diffHunk": "@@ -237,4 +237,7 @@\n \n    @Message(value = \"Confirm the credential: \")\n    String credentialToolCredentialConfirm();\n+\n+   @Message(value = \"Filter rule '%s' is not in the format [ALLOW|REJECT]/{CIDR}\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a444f66bcb5a8416e3b0fd7a46174b2e656f640"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAxMTQ0Mw==", "bodyText": "ALLOW will not work, also the help mention ACCEPT (same as netty) I would use that\nchange it to ACCEPT will work for me if use CLI like this \"server connector ipfilter set REST-rest-default --rules='ACCEPT/192.168.27.50/16'\"", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r548011443", "createdAt": "2020-12-23T15:25:06Z", "author": {"login": "wfink"}, "path": "client/rest-client/src/main/java/org/infinispan/client/rest/IpFilterRule.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package org.infinispan.client.rest;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+public class IpFilterRule {\n+   public enum RuleType {\n+      ALLOW,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a444f66bcb5a8416e3b0fd7a46174b2e656f640"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAxMTY3MA==", "bodyText": "replace ALLOW->ACCEPT", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r548011670", "createdAt": "2020-12-23T15:25:36Z", "author": {"login": "wfink"}, "path": "cli/src/main/java/org/infinispan/cli/commands/rest/Connector.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.infinispan.cli.commands.rest;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.infinispan.cli.activators.ConnectionActivator;\n+import org.infinispan.cli.commands.CliCommand;\n+import org.infinispan.cli.completers.ConnectorCompleter;\n+import org.infinispan.cli.completers.IpFilterRuleCompleter;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.resources.Resource;\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+@GroupCommandDefinition(name = Connector.CMD, description = \"Performs operations on protocol connectors\", activator = ConnectionActivator.class, groupCommands = {Connector.Ls.class, Connector.Describe.class, Connector.Start.class, Connector.Stop.class, Connector.IpFilter.class})\n+public class Connector extends CliCommand {\n+\n+   public static final String CMD = \"connector\";\n+   public static final String TYPE = \"type\";\n+   public static final String NAME = \"name\";\n+\n+   @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+   protected boolean help;\n+\n+   @Override\n+   public boolean isHelp() {\n+      return help;\n+   }\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      // This command serves only to wrap the sub-commands\n+      invocation.println(invocation.getHelpInfo());\n+      return CommandResult.FAILURE;\n+   }\n+\n+   @CommandDefinition(name = \"ls\", description = \"Lists connectors\", activator = ConnectionActivator.class)\n+   public static class Ls extends RestCliCommand {\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorNames();\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"describe\", description = \"Describes a connector\", activator = ConnectionActivator.class)\n+   public static class Describe extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connector(name);\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"start\", description = \"Starts a connector\", activator = ConnectionActivator.class)\n+   public static class Start extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorStart(name);\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"stop\", description = \"Stops a connector\", activator = ConnectionActivator.class)\n+   public static class Stop extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorStop(name);\n+      }\n+   }\n+\n+   @GroupCommandDefinition(name = \"ipfilter\", description = \"Manages connector IP filters\", activator = ConnectionActivator.class, groupCommands = {IpFilter.Ls.class, IpFilter.Clear.class, IpFilter.Set.class})\n+   public static class IpFilter extends CliCommand {\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      protected boolean isHelp() {\n+         return false;\n+      }\n+\n+      @Override\n+      protected CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         return CommandResult.SUCCESS;\n+      }\n+\n+      @CommandDefinition(name = \"ls\", description = \"List all IP filters on a connector\", activator = ConnectionActivator.class)\n+      public static class Ls extends RestCliCommand {\n+\n+         @Argument(required = true, completer = ConnectorCompleter.class)\n+         String name;\n+\n+         @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+         protected boolean help;\n+\n+         @Override\n+         public boolean isHelp() {\n+            return help;\n+         }\n+\n+         @Override\n+         protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+            return client.server().connectorIpFilters(name);\n+         }\n+      }\n+\n+      @CommandDefinition(name = \"clear\", description = \"Removes all IP Filters from a connector\", activator = ConnectionActivator.class)\n+      public static class Clear extends RestCliCommand {\n+\n+         @Argument(required = true, completer = ConnectorCompleter.class)\n+         String name;\n+\n+         @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+         protected boolean help;\n+\n+         @Override\n+         public boolean isHelp() {\n+            return help;\n+         }\n+\n+         @Override\n+         protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+            return client.server().connectorIpFiltersClear(name);\n+         }\n+      }\n+\n+      @CommandDefinition(name = \"set\", description = \"Sets IP Filters on a connector\", activator = ConnectionActivator.class)\n+      public static class Set extends RestCliCommand {\n+\n+         @Argument(required = true, completer = ConnectorCompleter.class)\n+         String name;\n+\n+         @OptionList(description = \"One or more filter rules as \\\"[ALLOW|REJECT]/CIDR\\\"\", completer = IpFilterRuleCompleter.class, required = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a444f66bcb5a8416e3b0fd7a46174b2e656f640"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAxMTc3OA==", "bodyText": "replace ALLOW->ACCEPT", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r548011778", "createdAt": "2020-12-23T15:25:48Z", "author": {"login": "wfink"}, "path": "cli/src/main/java/org/infinispan/cli/completers/IpFilterRuleCompleter.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package org.infinispan.cli.completers;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+public class IpFilterRuleCompleter extends EnumCompleter {\n+\n+   public enum IpFilterType {\n+      ALLOW,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a444f66bcb5a8416e3b0fd7a46174b2e656f640"}, "originalPosition": 10}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7a444f66bcb5a8416e3b0fd7a46174b2e656f640", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/7a444f66bcb5a8416e3b0fd7a46174b2e656f640", "committedDate": "2020-12-22T17:18:07Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "ba24e8bcb3758e745ea3a8704516396b32521515", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/ba24e8bcb3758e745ea3a8704516396b32521515", "committedDate": "2021-01-07T08:52:58Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ba24e8bcb3758e745ea3a8704516396b32521515", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/ba24e8bcb3758e745ea3a8704516396b32521515", "committedDate": "2021-01-07T08:52:58Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "6f1b0acece57a34f3384413dad5a67cfa3b90413", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/6f1b0acece57a34f3384413dad5a67cfa3b90413", "committedDate": "2021-01-07T09:22:22Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYzNjEyMDU0", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-563612054", "createdAt": "2021-01-07T16:05:35Z", "commit": {"oid": "6f1b0acece57a34f3384413dad5a67cfa3b90413"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjowNTozNVrOIPySOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNjowNTozNVrOIPySOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQyMzQxOQ==", "bodyText": "This line will cause a checkstyle error as it is unused", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r553423419", "createdAt": "2021-01-07T16:05:35Z", "author": {"login": "wfink"}, "path": "cli/src/main/java/org/infinispan/cli/commands/CLI.java", "diffHunk": "@@ -39,6 +39,7 @@\n import org.infinispan.cli.commands.rest.Backup;\n import org.infinispan.cli.commands.rest.Cas;\n import org.infinispan.cli.commands.rest.ClearCache;\n+import org.infinispan.cli.commands.rest.Connector;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f1b0acece57a34f3384413dad5a67cfa3b90413"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6f1b0acece57a34f3384413dad5a67cfa3b90413", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/6f1b0acece57a34f3384413dad5a67cfa3b90413", "committedDate": "2021-01-07T09:22:22Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "5794bf693ddb1de3736206d3d5c9fedac106b7f1", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/5794bf693ddb1de3736206d3d5c9fedac106b7f1", "committedDate": "2021-01-07T16:07:13Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2NjU1MDU3", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-566655057", "createdAt": "2021-01-12T20:08:36Z", "commit": {"oid": "bf101e171fee1309245b3bc4934ced4b5ae9c97b"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY4MTgxNDg3", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-568181487", "createdAt": "2021-01-14T12:20:45Z", "commit": {"oid": "bf101e171fee1309245b3bc4934ced4b5ae9c97b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxMjoyMDo0NVrOITiSQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxMjoyNTowOVrOITia9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1NTU4Nw==", "bodyText": "It seems like we have a discrepancy between our xml and CLI.\nThe CLI allows ip-filters  defined per connectors to be updated, however it's not possible to update those defined globally under <endpoints><ip-filter>\nShould we have a root endpoints command/rest endpoint to allow this level of configuration?\nSo the CLI would be as follows:\n$ cli.sh endpoints status hotrod\n$ cli.sh endpoints stop hotrod\n$ cli.sh endpoints start hotrod\n$ cli.sh endpoints ipfilter set .... # global filters\n$ cli.sh endpoints ipfilter --connector=hotrod set .... # hotrod specific filters\n\nI think this would need the rest endpoint to be updated to the following to allow for this flexibility:\n/v2/server/endpoints/ip-filter # global\n/v2/server/endpoints/connectors/{connector}\n/v2/server/endpoints/connectors/{connector}/ip-filter # connector specific\n\nThis would also have the advantage of allowing configuration at the endpoints level to be exposed in the future.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r557355587", "createdAt": "2021-01-14T12:20:45Z", "author": {"login": "ryanemerson"}, "path": "cli/src/main/java/org/infinispan/cli/commands/rest/Connector.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.infinispan.cli.commands.rest;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.infinispan.cli.activators.ConnectionActivator;\n+import org.infinispan.cli.commands.CliCommand;\n+import org.infinispan.cli.completers.ConnectorCompleter;\n+import org.infinispan.cli.completers.IpFilterRuleCompleter;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.resources.Resource;\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+@GroupCommandDefinition(name = Connector.CMD, description = \"Performs operations on protocol connectors\", activator = ConnectionActivator.class, groupCommands = {Connector.Ls.class, Connector.Describe.class, Connector.Start.class, Connector.Stop.class, Connector.IpFilter.class})\n+public class Connector extends CliCommand {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf101e171fee1309245b3bc4934ced4b5ae9c97b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzM1NzgxMg==", "bodyText": "The default infinispan.xml does not have named connectors. Should we update this to:\n         <hotrod-connector name=\"hotrod\"/>\n         <rest-connector name=\"rest\"/>\n\nThis then allows users to disable either connector via the CLI without any additional config.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r557357812", "createdAt": "2021-01-14T12:25:09Z", "author": {"login": "ryanemerson"}, "path": "server/runtime/src/main/server/server/conf/infinispan-local.xml", "diffHunk": "@@ -39,6 +39,10 @@\n       </security>\n \n       <endpoints socket-binding=\"default\" security-realm=\"default\">\n+         <ip-filter>\n+            <reject from=\"172.16.0.0/16\"/>\n+            <accept from=\"127.0.0.0/8\"/>\n+         </ip-filter>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf101e171fee1309245b3bc4934ced4b5ae9c97b"}, "originalPosition": 7}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bf101e171fee1309245b3bc4934ced4b5ae9c97b", "author": {"user": {"login": "oraNod", "name": "Don Naro"}}, "url": "https://github.com/infinispan/infinispan/commit/bf101e171fee1309245b3bc4934ced4b5ae9c97b", "committedDate": "2021-01-12T20:04:48Z", "message": "ISPN-12261 doc edits"}, "afterCommit": {"oid": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/65b1dcdbdbcf70702186b4dfd9ca19f114296b74", "committedDate": "2021-01-29T12:37:48Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwNjA3NDEx", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-580607411", "createdAt": "2021-02-01T17:43:59Z", "commit": {"oid": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxNzo0Mzo1OVrOIdtAOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQxODoxODozNlrOIduXpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAxNjk1Mg==", "bodyText": "shouldn't we fail if null? All invocations of getServerStateManager expect it to be non-null.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568016952", "createdAt": "2021-02-01T17:43:59Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/AbstractProtocolServer.java", "diffHunk": "@@ -100,11 +101,10 @@ public void start(C configuration, EmbeddedCacheManager cacheManager) {\n       this.cacheManager = cacheManager;\n \n       BasicComponentRegistry bcr = SecurityActions.getGlobalComponentRegistry(cacheManager).getComponent(BasicComponentRegistry.class.getName());\n-      cacheIgnore = bcr.getComponent(CacheIgnoreManager.class).running();\n-      if (cacheIgnore == null) {\n-         throw new IllegalStateException(\"CacheIgnoreManager is a required component\");\n+      ComponentRef<ServerStateManager> stateManagerComponentRef = bcr.getComponent(ServerStateManager.class);\n+      if (stateManagerComponentRef != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAyNzQ3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 12.0\n          \n          \n            \n             * @since 12.1", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568027478", "createdAt": "2021-02-01T17:59:52Z", "author": {"login": "pruivo"}, "path": "cli/src/main/java/org/infinispan/cli/commands/rest/Connector.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.infinispan.cli.commands.rest;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.infinispan.cli.activators.ConnectionActivator;\n+import org.infinispan.cli.commands.CliCommand;\n+import org.infinispan.cli.completers.ConnectorCompleter;\n+import org.infinispan.cli.completers.IpFilterRuleCompleter;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.resources.Resource;\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAzMDQ0NA==", "bodyText": "shouldn't be failure? or maybe remove ls command and list the ip filter rules here.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568030444", "createdAt": "2021-02-01T18:04:53Z", "author": {"login": "pruivo"}, "path": "cli/src/main/java/org/infinispan/cli/commands/rest/Connector.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.infinispan.cli.commands.rest;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.infinispan.cli.activators.ConnectionActivator;\n+import org.infinispan.cli.commands.CliCommand;\n+import org.infinispan.cli.completers.ConnectorCompleter;\n+import org.infinispan.cli.completers.IpFilterRuleCompleter;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.resources.Resource;\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+@GroupCommandDefinition(name = Connector.CMD, description = \"Performs operations on protocol connectors\", activator = ConnectionActivator.class, groupCommands = {Connector.Ls.class, Connector.Describe.class, Connector.Start.class, Connector.Stop.class, Connector.IpFilter.class})\n+public class Connector extends CliCommand {\n+\n+   public static final String CMD = \"connector\";\n+   public static final String TYPE = \"type\";\n+   public static final String NAME = \"name\";\n+\n+   @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+   protected boolean help;\n+\n+   @Override\n+   public boolean isHelp() {\n+      return help;\n+   }\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      // This command serves only to wrap the sub-commands\n+      invocation.println(invocation.getHelpInfo());\n+      return CommandResult.FAILURE;\n+   }\n+\n+   @CommandDefinition(name = \"ls\", description = \"Lists connectors\", activator = ConnectionActivator.class)\n+   public static class Ls extends RestCliCommand {\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorNames();\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"describe\", description = \"Describes a connector\", activator = ConnectionActivator.class)\n+   public static class Describe extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connector(name);\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"start\", description = \"Starts a connector\", activator = ConnectionActivator.class)\n+   public static class Start extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorStart(name);\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"stop\", description = \"Stops a connector\", activator = ConnectionActivator.class)\n+   public static class Stop extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorStop(name);\n+      }\n+   }\n+\n+   @GroupCommandDefinition(name = \"ipfilter\", description = \"Manages connector IP filters\", activator = ConnectionActivator.class, groupCommands = {IpFilter.Ls.class, IpFilter.Clear.class, IpFilter.Set.class})\n+   public static class IpFilter extends CliCommand {\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      protected boolean isHelp() {\n+         return false;\n+      }\n+\n+      @Override\n+      protected CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         return CommandResult.SUCCESS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAzMDY3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     return false;\n          \n          \n            \n                     return help;", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568030675", "createdAt": "2021-02-01T18:05:14Z", "author": {"login": "pruivo"}, "path": "cli/src/main/java/org/infinispan/cli/commands/rest/Connector.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.infinispan.cli.commands.rest;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.aesh.command.CommandDefinition;\n+import org.aesh.command.CommandException;\n+import org.aesh.command.CommandResult;\n+import org.aesh.command.GroupCommandDefinition;\n+import org.aesh.command.option.Argument;\n+import org.aesh.command.option.Option;\n+import org.aesh.command.option.OptionList;\n+import org.infinispan.cli.activators.ConnectionActivator;\n+import org.infinispan.cli.commands.CliCommand;\n+import org.infinispan.cli.completers.ConnectorCompleter;\n+import org.infinispan.cli.completers.IpFilterRuleCompleter;\n+import org.infinispan.cli.impl.ContextAwareCommandInvocation;\n+import org.infinispan.cli.logging.Messages;\n+import org.infinispan.cli.resources.Resource;\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+@GroupCommandDefinition(name = Connector.CMD, description = \"Performs operations on protocol connectors\", activator = ConnectionActivator.class, groupCommands = {Connector.Ls.class, Connector.Describe.class, Connector.Start.class, Connector.Stop.class, Connector.IpFilter.class})\n+public class Connector extends CliCommand {\n+\n+   public static final String CMD = \"connector\";\n+   public static final String TYPE = \"type\";\n+   public static final String NAME = \"name\";\n+\n+   @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+   protected boolean help;\n+\n+   @Override\n+   public boolean isHelp() {\n+      return help;\n+   }\n+\n+   @Override\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n+      // This command serves only to wrap the sub-commands\n+      invocation.println(invocation.getHelpInfo());\n+      return CommandResult.FAILURE;\n+   }\n+\n+   @CommandDefinition(name = \"ls\", description = \"Lists connectors\", activator = ConnectionActivator.class)\n+   public static class Ls extends RestCliCommand {\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorNames();\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"describe\", description = \"Describes a connector\", activator = ConnectionActivator.class)\n+   public static class Describe extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connector(name);\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"start\", description = \"Starts a connector\", activator = ConnectionActivator.class)\n+   public static class Start extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorStart(name);\n+      }\n+   }\n+\n+   @CommandDefinition(name = \"stop\", description = \"Stops a connector\", activator = ConnectionActivator.class)\n+   public static class Stop extends RestCliCommand {\n+\n+      @Argument(required = true, completer = ConnectorCompleter.class)\n+      String name;\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      public boolean isHelp() {\n+         return help;\n+      }\n+\n+      @Override\n+      protected CompletionStage<RestResponse> exec(ContextAwareCommandInvocation invocation, RestClient client, Resource resource) {\n+         return client.server().connectorStop(name);\n+      }\n+   }\n+\n+   @GroupCommandDefinition(name = \"ipfilter\", description = \"Manages connector IP filters\", activator = ConnectionActivator.class, groupCommands = {IpFilter.Ls.class, IpFilter.Clear.class, IpFilter.Set.class})\n+   public static class IpFilter extends CliCommand {\n+\n+      @Option(shortName = 'h', hasValue = false, overrideRequired = true)\n+      protected boolean help;\n+\n+      @Override\n+      protected boolean isHelp() {\n+         return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAzMTIzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 12.0\n          \n          \n            \n             * @since 12.1", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568031231", "createdAt": "2021-02-01T18:06:07Z", "author": {"login": "pruivo"}, "path": "cli/src/main/java/org/infinispan/cli/completers/ConnectorCompleter.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package org.infinispan.cli.completers;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+\n+import org.infinispan.cli.Context;\n+import org.infinispan.cli.connection.Connection;\n+\n+/**\n+ * A {@link org.aesh.command.completer.OptionCompleter} for protocol connectors.\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAzMjI5MQ==", "bodyText": "why not using org.infinispan.client.rest.IpFilterRule.RuleType?", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568032291", "createdAt": "2021-02-01T18:07:48Z", "author": {"login": "pruivo"}, "path": "cli/src/main/java/org/infinispan/cli/completers/IpFilterRuleCompleter.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package org.infinispan.cli.completers;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+public class IpFilterRuleCompleter extends EnumCompleter {\n+\n+   public enum IpFilterType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAzMzk4Nw==", "bodyText": "why the container? we don't support multiple containers and the connector has no association with connectors/enpoints.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568033987", "createdAt": "2021-02-01T18:10:22Z", "author": {"login": "pruivo"}, "path": "cli/src/main/java/org/infinispan/cli/connection/Connection.java", "diffHunk": "@@ -73,6 +73,8 @@\n \n    Collection<String> getBackupNames(String container) throws IOException;\n \n+   Collection<String> getConnectorNames(String container) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAzNzExNw==", "bodyText": "I guess this is a bad example. if endpoint-default is stopped, the cli can't connect.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568037117", "createdAt": "2021-02-01T18:15:17Z", "author": {"login": "pruivo"}, "path": "cli/src/main/resources/help/server.adoc", "diffHunk": "@@ -0,0 +1,67 @@\n+SERVER(1)\n+=========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+server - server configuration and state management.\n+\n+\n+DESCRIPTION\n+-----------\n+\n+\n+\n+SYNOPSIS\n+--------\n+*server report*\n+\n+*server connector ls*\n+\n+*server connector describe* 'connector-name'\n+\n+*server connector start* 'connector-name'\n+\n+*server connector stop* 'connector-name'\n+\n+*server connector ipfilter ls* 'connector-name'\n+\n+*server connector ipfilter set* 'connector-name' --rules='[ACCEPT|REJECT]/cidr',...\n+\n+*server connector ipfilter clear* 'connector-name'\n+\n+\n+SERVER CONNECTOR IPFILTER OPTIONS\n+---------------------------------\n+\n+*--rules*='[ACCEPT|REJECT]/cidr',...::\n+One or more IP filtering rules.\n+\n+\n+EXAMPLES\n+--------\n+\n+`server report` +\n+Obtains a server report, including information about network, threads, memory, etc.\n+\n+`server connector ls` +\n+Lists all available connectors on the server.\n+\n+`server connector describe endpoint-default` +\n+Shows information about the specified connector, including host, port, local and global connections, IP filtering rules.\n+\n+`server connector start endpoint-default` +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAzODAwMQ==", "bodyText": "example already exist in line 60. Clear is missing.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568038001", "createdAt": "2021-02-01T18:16:40Z", "author": {"login": "pruivo"}, "path": "cli/src/main/resources/help/server.adoc", "diffHunk": "@@ -0,0 +1,67 @@\n+SERVER(1)\n+=========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+server - server configuration and state management.\n+\n+\n+DESCRIPTION\n+-----------\n+\n+\n+\n+SYNOPSIS\n+--------\n+*server report*\n+\n+*server connector ls*\n+\n+*server connector describe* 'connector-name'\n+\n+*server connector start* 'connector-name'\n+\n+*server connector stop* 'connector-name'\n+\n+*server connector ipfilter ls* 'connector-name'\n+\n+*server connector ipfilter set* 'connector-name' --rules='[ACCEPT|REJECT]/cidr',...\n+\n+*server connector ipfilter clear* 'connector-name'\n+\n+\n+SERVER CONNECTOR IPFILTER OPTIONS\n+---------------------------------\n+\n+*--rules*='[ACCEPT|REJECT]/cidr',...::\n+One or more IP filtering rules.\n+\n+\n+EXAMPLES\n+--------\n+\n+`server report` +\n+Obtains a server report, including information about network, threads, memory, etc.\n+\n+`server connector ls` +\n+Lists all available connectors on the server.\n+\n+`server connector describe endpoint-default` +\n+Shows information about the specified connector, including host, port, local and global connections, IP filtering rules.\n+\n+`server connector start endpoint-default` +\n+Starts a connector so that it can accept connections across the cluster. This operation can only be performed on connectors which are directly bound to a socket.\n+\n+`server connector stop endpoint-default` +\n+Stops a connector dropping all established connections across the cluster. This operation can only be performed on connectors which are directly bound to a socket.\n+\n+`server connector ipfilter ls endpoint-default` +\n+Lists all IP filtering rules active on a connector across the cluster.\n+\n+`server connector ipfilter set endpoint-default --rules=ACCEPT/192.168.0.0/16,REJECT/10.0.0.0/8`\n+Sets IP filtering rules on a connector across the cluster. Replaces all existing rules.\n+\n+`server connector ipfilter ls endpoint-default` +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAzODc5MA==", "bodyText": "wouldn't be a better user experience to create an \"accept\" and \"reject\" command instead? Overwriting all the rules seems a little bit harsh\nps.1 Or make it more like the iptables:\nserver connector ipfilter add my-connect accept|reject 10.0.0.0/8\nserver connector ipfilter delete my-connect accept|reject 10.0.0.0/8\nor (probably too much)\nserver connector ipfilter my-connect -A|-D  -j accept|reject -s 10.0.0.0/8\nps.2 what about moving ipfilter to server's subcommand?\nserver ipfilter my-connector ...", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568038790", "createdAt": "2021-02-01T18:17:49Z", "author": {"login": "pruivo"}, "path": "cli/src/main/resources/help/server.adoc", "diffHunk": "@@ -0,0 +1,67 @@\n+SERVER(1)\n+=========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+server - server configuration and state management.\n+\n+\n+DESCRIPTION\n+-----------\n+\n+\n+\n+SYNOPSIS\n+--------\n+*server report*\n+\n+*server connector ls*\n+\n+*server connector describe* 'connector-name'\n+\n+*server connector start* 'connector-name'\n+\n+*server connector stop* 'connector-name'\n+\n+*server connector ipfilter ls* 'connector-name'\n+\n+*server connector ipfilter set* 'connector-name' --rules='[ACCEPT|REJECT]/cidr',...\n+\n+*server connector ipfilter clear* 'connector-name'\n+\n+\n+SERVER CONNECTOR IPFILTER OPTIONS\n+---------------------------------\n+\n+*--rules*='[ACCEPT|REJECT]/cidr',...::\n+One or more IP filtering rules.\n+\n+\n+EXAMPLES\n+--------\n+\n+`server report` +\n+Obtains a server report, including information about network, threads, memory, etc.\n+\n+`server connector ls` +\n+Lists all available connectors on the server.\n+\n+`server connector describe endpoint-default` +\n+Shows information about the specified connector, including host, port, local and global connections, IP filtering rules.\n+\n+`server connector start endpoint-default` +\n+Starts a connector so that it can accept connections across the cluster. This operation can only be performed on connectors which are directly bound to a socket.\n+\n+`server connector stop endpoint-default` +\n+Stops a connector dropping all established connections across the cluster. This operation can only be performed on connectors which are directly bound to a socket.\n+\n+`server connector ipfilter ls endpoint-default` +\n+Lists all IP filtering rules active on a connector across the cluster.\n+\n+`server connector ipfilter set endpoint-default --rules=ACCEPT/192.168.0.0/16,REJECT/10.0.0.0/8`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODAzOTMzMw==", "bodyText": "description missing", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r568039333", "createdAt": "2021-02-01T18:18:36Z", "author": {"login": "pruivo"}, "path": "cli/src/main/resources/help/server.adoc", "diffHunk": "@@ -0,0 +1,67 @@\n+SERVER(1)\n+=========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+server - server configuration and state management.\n+\n+\n+DESCRIPTION", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65b1dcdbdbcf70702186b4dfd9ca19f114296b74"}, "originalPosition": 11}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a076ab214f9f4629556a2f495304d99a8d1192da", "author": {"user": {"login": "oraNod", "name": "Don Naro"}}, "url": "https://github.com/infinispan/infinispan/commit/a076ab214f9f4629556a2f495304d99a8d1192da", "committedDate": "2021-02-02T09:51:56Z", "message": "doc edits"}, "afterCommit": {"oid": "f476645ce61e3d28725670d9af7a802e05128b6d", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/f476645ce61e3d28725670d9af7a802e05128b6d", "committedDate": "2021-02-02T13:13:01Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f476645ce61e3d28725670d9af7a802e05128b6d", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/f476645ce61e3d28725670d9af7a802e05128b6d", "committedDate": "2021-02-02T13:13:01Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "80223cd5311920a152cae117aa34da458383d002", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/80223cd5311920a152cae117aa34da458383d002", "committedDate": "2021-02-02T13:17:11Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgyMTQ1NzUz", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-582145753", "createdAt": "2021-02-03T09:12:06Z", "commit": {"oid": "80223cd5311920a152cae117aa34da458383d002"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwOToxMjowNlrOIe4BBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwOTo0NDoxMlrOIe5ZUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI0NTk1Ng==", "bodyText": "why not using composition? IMO, there is no reason to copy & maintain this code\npublic final class IpSubnetFilterRule implements IpFilterRule {\n\n   private final IpSubnetFilterRule filterRule;\n   private final String cidr;\n\n   public IpSubnetFilterRule(String cidr, IpFilterRuleType ruleType) {\n      int sep = cidr.indexOf('/');\n      if (sep < 0) {\n         throw new IllegalArgumentException(cidr);\n      }\n      this.filterRule = new IpSubnetFilterRule(cidr.substring(0, sep), Integer.parseInt(cidr.substring(sep + 1)), ruleType);\n      this.cidr = cidr;\n   }", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569245956", "createdAt": "2021-02-03T09:12:06Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/transport/IpSubnetFilterRule.java", "diffHunk": "@@ -0,0 +1,204 @@\n+package org.infinispan.server.core.transport;\n+\n+import java.math.BigInteger;\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.Objects;\n+\n+import io.netty.handler.ipfilter.IpFilterRule;\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SocketUtils;\n+\n+/**\n+ * This differs from Netty's equivalent {@link io.netty.handler.ipfilter.IpSubnetFilterRule} in that it parses CIDR", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80223cd5311920a152cae117aa34da458383d002"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI1NDQzNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * <li>stopped protocol servers</li>\n          \n          \n            \n             * <li>protocol servers</li>", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569254434", "createdAt": "2021-02-03T09:24:31Z", "author": {"login": "pruivo"}, "path": "server/runtime/src/main/java/org/infinispan/server/state/ServerStateManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.infinispan.server.state;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.globalstate.GlobalConfigurationManager;\n+import org.infinispan.globalstate.ScopeFilter;\n+import org.infinispan.globalstate.ScopedState;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.core.ProtocolServer;\n+import org.infinispan.server.core.ServerStateManager;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.infinispan.server.core.transport.Transport;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * Manages cluster-wide server state for a given {@link EmbeddedCacheManager}. This handles:\n+ * <ul>\n+ * <li>ignored caches</li>\n+ * <li>stopped protocol servers</li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80223cd5311920a152cae117aa34da458383d002"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI1NDUyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 10.0\n          \n          \n            \n             * @since 12.1", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569254526", "createdAt": "2021-02-03T09:24:41Z", "author": {"login": "pruivo"}, "path": "server/runtime/src/main/java/org/infinispan/server/state/ServerStateManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.infinispan.server.state;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.globalstate.GlobalConfigurationManager;\n+import org.infinispan.globalstate.ScopeFilter;\n+import org.infinispan.globalstate.ScopedState;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.core.ProtocolServer;\n+import org.infinispan.server.core.ServerStateManager;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.infinispan.server.core.transport.Transport;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * Manages cluster-wide server state for a given {@link EmbeddedCacheManager}. This handles:\n+ * <ul>\n+ * <li>ignored caches</li>\n+ * <li>stopped protocol servers</li>\n+ * <li>ip filters</li>\n+ * </ul>\n+ *\n+ * @since 10.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80223cd5311920a152cae117aa34da458383d002"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI1OTI3Nw==", "bodyText": "can be final", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569259277", "createdAt": "2021-02-03T09:31:07Z", "author": {"login": "pruivo"}, "path": "server/runtime/src/main/java/org/infinispan/server/state/ServerStateManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.infinispan.server.state;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.globalstate.GlobalConfigurationManager;\n+import org.infinispan.globalstate.ScopeFilter;\n+import org.infinispan.globalstate.ScopedState;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.core.ProtocolServer;\n+import org.infinispan.server.core.ServerStateManager;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.infinispan.server.core.transport.Transport;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * Manages cluster-wide server state for a given {@link EmbeddedCacheManager}. This handles:\n+ * <ul>\n+ * <li>ignored caches</li>\n+ * <li>stopped protocol servers</li>\n+ * <li>ip filters</li>\n+ * </ul>\n+ *\n+ * @since 10.0\n+ */\n+public final class ServerStateManagerImpl implements ServerStateManager {\n+   private static final String CONNECTOR_STATE_SCOPE = \"connector-state\";\n+   private static final String CONNECTOR_IPFILTER_SCOPE = \"connector-ipfilter\";\n+   private static final ScopedState IGNORED_CACHES_KEY = new ScopedState(\"ignored-caches\", \"ignored-caches\");\n+\n+   private final EmbeddedCacheManager cacheManager;\n+   private final Server server;\n+   private Cache<ScopedState, Object> cache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80223cd5311920a152cae117aa34da458383d002"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI2MDI5MA==", "bodyText": "fields can be removed. they are only accessed in the contructor.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569260290", "createdAt": "2021-02-03T09:32:37Z", "author": {"login": "pruivo"}, "path": "server/runtime/src/main/java/org/infinispan/server/state/ServerStateManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.infinispan.server.state;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.globalstate.GlobalConfigurationManager;\n+import org.infinispan.globalstate.ScopeFilter;\n+import org.infinispan.globalstate.ScopedState;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.core.ProtocolServer;\n+import org.infinispan.server.core.ServerStateManager;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.infinispan.server.core.transport.Transport;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * Manages cluster-wide server state for a given {@link EmbeddedCacheManager}. This handles:\n+ * <ul>\n+ * <li>ignored caches</li>\n+ * <li>stopped protocol servers</li>\n+ * <li>ip filters</li>\n+ * </ul>\n+ *\n+ * @since 10.0\n+ */\n+public final class ServerStateManagerImpl implements ServerStateManager {\n+   private static final String CONNECTOR_STATE_SCOPE = \"connector-state\";\n+   private static final String CONNECTOR_IPFILTER_SCOPE = \"connector-ipfilter\";\n+   private static final ScopedState IGNORED_CACHES_KEY = new ScopedState(\"ignored-caches\", \"ignored-caches\");\n+\n+   private final EmbeddedCacheManager cacheManager;\n+   private final Server server;\n+   private Cache<ScopedState, Object> cache;\n+   private final IgnoredCaches ignored = new IgnoredCaches();\n+   private final IgnoredCachesListener ignoredCacheListener = new IgnoredCachesListener();\n+   private final ConnectorStateListener connectorStateListener = new ConnectorStateListener();\n+   private final ConnectorIpFilterListener connectorIpFilterListener = new ConnectorIpFilterListener();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80223cd5311920a152cae117aa34da458383d002"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI2MjE3OA==", "bodyText": "since this is stored in a Set, it would be better to implement equals/hashCode", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569262178", "createdAt": "2021-02-03T09:35:25Z", "author": {"login": "pruivo"}, "path": "server/runtime/src/main/java/org/infinispan/server/state/ServerStateManagerImpl.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package org.infinispan.server.state;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.globalstate.GlobalConfigurationManager;\n+import org.infinispan.globalstate.ScopeFilter;\n+import org.infinispan.globalstate.ScopedState;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.core.ProtocolServer;\n+import org.infinispan.server.core.ServerStateManager;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.infinispan.server.core.transport.Transport;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * Manages cluster-wide server state for a given {@link EmbeddedCacheManager}. This handles:\n+ * <ul>\n+ * <li>ignored caches</li>\n+ * <li>stopped protocol servers</li>\n+ * <li>ip filters</li>\n+ * </ul>\n+ *\n+ * @since 10.0\n+ */\n+public final class ServerStateManagerImpl implements ServerStateManager {\n+   private static final String CONNECTOR_STATE_SCOPE = \"connector-state\";\n+   private static final String CONNECTOR_IPFILTER_SCOPE = \"connector-ipfilter\";\n+   private static final ScopedState IGNORED_CACHES_KEY = new ScopedState(\"ignored-caches\", \"ignored-caches\");\n+\n+   private final EmbeddedCacheManager cacheManager;\n+   private final Server server;\n+   private Cache<ScopedState, Object> cache;\n+   private final IgnoredCaches ignored = new IgnoredCaches();\n+   private final IgnoredCachesListener ignoredCacheListener = new IgnoredCachesListener();\n+   private final ConnectorStateListener connectorStateListener = new ConnectorStateListener();\n+   private final ConnectorIpFilterListener connectorIpFilterListener = new ConnectorIpFilterListener();\n+   private volatile boolean hasIgnores;\n+\n+   public ServerStateManagerImpl(Server server, EmbeddedCacheManager cacheManager, GlobalConfigurationManager configurationManager) {\n+      this.server = server;\n+      this.cacheManager = cacheManager;\n+      this.cache = configurationManager.getStateCache();\n+\n+      GlobalComponentRegistry registry = SecurityActions.getGlobalComponentRegistry(cacheManager);\n+      SerializationContextRegistry serializationContextRegistry = registry.getComponent(SerializationContextRegistry.class);\n+      serializationContextRegistry.addContextInitializer(SerializationContextRegistry.MarshallerType.PERSISTENCE, new PersistenceContextInitializerImpl());\n+\n+      updateLocalIgnoredCaches((IgnoredCaches) cache.get(IGNORED_CACHES_KEY));\n+\n+      // Register the listeners which will react on\n+      cache.addListener(ignoredCacheListener, new ScopeFilter(IGNORED_CACHES_KEY.getScope()), null);\n+      cache.addListener(connectorStateListener, new ScopeFilter(CONNECTOR_STATE_SCOPE), null);\n+      cache.addListener(connectorIpFilterListener, new ScopeFilter(CONNECTOR_IPFILTER_SCOPE), null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> unignoreCache(String cacheName) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      synchronized (this) {\n+         ignored.caches.remove(cacheName);\n+         hasIgnores = !ignored.caches.isEmpty();\n+         return cache.putAsync(IGNORED_CACHES_KEY, ignored).thenApply(r -> null);\n+      }\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> ignoreCache(String cacheName) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      synchronized (this) {\n+         ignored.caches.add(cacheName);\n+         hasIgnores = !ignored.caches.isEmpty();\n+         return cache.putAsync(IGNORED_CACHES_KEY, ignored).thenApply(r -> null);\n+      }\n+   }\n+\n+   @Override\n+   public Set<String> getIgnoredCaches() {\n+      return Collections.unmodifiableSet(ignored.caches);\n+   }\n+\n+   @Override\n+   public boolean isCacheIgnored(String cacheName) {\n+      return hasIgnores && ignored.caches.contains(cacheName);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Boolean> connectorStart(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.removeAsync(new ScopedState(CONNECTOR_STATE_SCOPE, name), true).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> connectorStop(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.putAsync(new ScopedState(CONNECTOR_STATE_SCOPE, name), true).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Boolean> connectorStatus(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return CompletableFuture.completedFuture(server.getProtocolServers().get(name).getTransport().isRunning());\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> setConnectorIpFilterRule(String name, Collection<IpSubnetFilterRule> filterRule) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      IpFilterRules ipFilterRules = new IpFilterRules();\n+      filterRule.forEach(r -> ipFilterRules.rules.add(new IpFilterRule(r)));\n+      return cache.putAsync(new ScopedState(CONNECTOR_IPFILTER_SCOPE, name), ipFilterRules).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> clearConnectorIpFilterRules(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.removeAsync(new ScopedState(CONNECTOR_IPFILTER_SCOPE, name)).thenApply(v -> null);\n+   }\n+\n+   private void updateLocalIgnoredCaches(IgnoredCaches ignored) {\n+      if (ignored != null) {\n+         synchronized (this) {\n+            this.ignored.caches.clear();\n+            this.ignored.caches.addAll(ignored.caches);\n+            hasIgnores = !this.ignored.caches.isEmpty();\n+         }\n+      }\n+   }\n+\n+   @Listener(observation = Listener.Observation.POST)\n+   private final class IgnoredCachesListener {\n+      @CacheEntryCreated\n+      public void created(CacheEntryCreatedEvent<ScopedState, IgnoredCaches> e) {\n+         if (!e.isOriginLocal()) {\n+            updateLocalIgnoredCaches(e.getValue());\n+         }\n+      }\n+\n+      @CacheEntryModified\n+      public void modified(CacheEntryModifiedEvent<ScopedState, IgnoredCaches> e) {\n+         if (!e.isOriginLocal()) {\n+            updateLocalIgnoredCaches(e.getValue());\n+         }\n+      }\n+   }\n+\n+   @Listener(observation = Listener.Observation.POST)\n+   private final class ConnectorStateListener {\n+      @CacheEntryCreated\n+      public void created(CacheEntryCreatedEvent<ScopedState, Boolean> e) {\n+         // stop the connector\n+         server.getProtocolServers().get(e.getKey().getName()).getTransport().stop();\n+      }\n+\n+      @CacheEntryRemoved\n+      public void removed(CacheEntryRemovedEvent<ScopedState, Boolean> e) {\n+         // start the connector\n+         server.getProtocolServers().get(e.getKey().getName()).getTransport().start();\n+      }\n+   }\n+\n+   @Listener(observation = Listener.Observation.POST)\n+   private final class ConnectorIpFilterListener {\n+      @CacheEntryCreated\n+      @CacheEntryModified\n+      public CompletionStage<Void> modified(CacheEntryEvent<ScopedState, IpFilterRules> e) {\n+         String connector = e.getKey().getName();\n+         ProtocolServer protocolServer = server.getProtocolServers().get(connector);\n+         List<IpSubnetFilterRule> rules = protocolServer.getConfiguration().ipfilter().rules();\n+         rules.clear();\n+         for (IpFilterRule rule : e.getValue().rules) {\n+            rules.add(new IpSubnetFilterRule(rule.cidr, IpFilterRuleType.valueOf(rule.type)));\n+         }\n+         Transport transport = protocolServer.getTransport();\n+         if (transport != null) {\n+            return transport.applyIpFilterRules(rules).thenApply(v -> {\n+               Server.log.connectorIpFilterSet(connector, rules);\n+               return v;\n+            });\n+         } else {\n+            return CompletableFutures.completedExceptionFuture(Server.log.noConnectorTransport(connector));\n+         }\n+      }\n+\n+      @CacheEntryRemoved\n+      public void removed(CacheEntryRemovedEvent<ScopedState, IpFilterRules> e) {\n+         String connector = e.getKey().getName();\n+         server.getProtocolServers().get(connector).getConfiguration().ipfilter().rules().clear();\n+         Server.log.connectorIpFilterCleared(connector);\n+      }\n+   }\n+\n+   @ProtoTypeId(ProtoStreamTypeIds.IGNORED_CACHES)\n+   static final class IgnoredCaches {\n+\n+      @ProtoField(number = 1, collectionImplementation = HashSet.class)\n+      final Set<String> caches;\n+\n+      IgnoredCaches() {\n+         this(ConcurrentHashMap.newKeySet());\n+      }\n+\n+      @ProtoFactory\n+      IgnoredCaches(Set<String> caches) {\n+         // ProtoStream cannot use KeySetView directly as it does not have a zero args constructor\n+         this.caches = ConcurrentHashMap.newKeySet(caches.size());\n+         this.caches.addAll(caches);\n+      }\n+   }\n+\n+   @ProtoTypeId(ProtoStreamTypeIds.IP_FILTER_RULE)\n+   static final class IpFilterRule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80223cd5311920a152cae117aa34da458383d002"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI2MzA2Mw==", "bodyText": "not used. revert?", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569263063", "createdAt": "2021-02-03T09:36:35Z", "author": {"login": "pruivo"}, "path": "server/runtime/src/main/java/org/infinispan/server/tasks/admin/ServerAdminOperationsHandler.java", "diffHunk": "@@ -14,7 +15,7 @@\n  **/\n public class ServerAdminOperationsHandler extends AdminOperationsHandler {\n \n-   public ServerAdminOperationsHandler(ConfigurationBuilderHolder defaultsHolder) {\n+   public ServerAdminOperationsHandler(Server server, ConfigurationBuilderHolder defaultsHolder) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80223cd5311920a152cae117aa34da458383d002"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI2MzM0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 12.0\n          \n          \n            \n             * @since 12.1", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569263346", "createdAt": "2021-02-03T09:37:00Z", "author": {"login": "pruivo"}, "path": "server/runtime/src/main/java/org/infinispan/server/state/SecurityActions.java", "diffHunk": "@@ -0,0 +1,40 @@\n+package org.infinispan.server.state;\n+\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.security.Security;\n+import org.infinispan.security.actions.GetGlobalComponentRegistryAction;\n+import org.infinispan.security.impl.AuthorizationHelper;\n+\n+/**\n+ * SecurityActions for the org.infinispan.server.state package.\n+ * <p>\n+ * Do not move. Do not change class and method visibility to avoid being called from other {@link\n+ * java.security.CodeSource}s, thus granting privilege escalation to external code.\n+ *\n+ * @author Tristan Tarrant <tristan@infinispan.org>\n+ * @since 12.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80223cd5311920a152cae117aa34da458383d002"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI2MzU2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @since 12.0\n          \n          \n            \n             * @since 12.1", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569263565", "createdAt": "2021-02-03T09:37:18Z", "author": {"login": "pruivo"}, "path": "server/runtime/src/main/java/org/infinispan/server/state/PersistenceContextInitializer.java", "diffHunk": "@@ -0,0 +1,25 @@\n+package org.infinispan.server.state;\n+\n+import org.infinispan.protostream.SerializationContextInitializer;\n+import org.infinispan.protostream.annotations.AutoProtoSchemaBuilder;\n+\n+/**\n+ * Interface used to initialise a {@link org.infinispan.protostream.SerializationContext} using the specified Pojos,\n+ * Marshaller implementations and provided .proto schemas.\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80223cd5311920a152cae117aa34da458383d002"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI2ODU2Mw==", "bodyText": "hmmm... shouldn't copy the rules from template?", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r569268563", "createdAt": "2021-02-03T09:44:12Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/configuration/IpFilterConfigurationBuilder.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package org.infinispan.server.core.configuration;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.infinispan.commons.configuration.Builder;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * IpFilterConfigurationBuilder.\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.0\n+ */\n+public class IpFilterConfigurationBuilder<T extends ProtocolServerConfiguration, S extends ProtocolServerConfigurationChildBuilder<T, S>>\n+      extends AbstractProtocolServerConfigurationChildBuilder<T, S>\n+      implements Builder<IpFilterConfiguration> {\n+\n+   List<IpSubnetFilterRule> rules = new ArrayList<>();\n+\n+   public IpFilterConfigurationBuilder(ProtocolServerConfigurationChildBuilder<T, S> builder) {\n+      super(builder);\n+   }\n+\n+   public IpFilterConfigurationBuilder allowFrom(String rule) {\n+      rules.add(new IpSubnetFilterRule(rule, IpFilterRuleType.ACCEPT));\n+      return this;\n+   }\n+\n+   public IpFilterConfigurationBuilder rejectFrom(String rule) {\n+      rules.add(new IpSubnetFilterRule(rule, IpFilterRuleType.REJECT));\n+      return this;\n+   }\n+\n+   @Override\n+   public void validate() {\n+   }\n+\n+   @Override\n+   public IpFilterConfiguration create() {\n+      return new IpFilterConfiguration(rules);\n+   }\n+\n+   @Override\n+   public IpFilterConfigurationBuilder read(IpFilterConfiguration template) {\n+      return this;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80223cd5311920a152cae117aa34da458383d002"}, "originalPosition": 48}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "80223cd5311920a152cae117aa34da458383d002", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/80223cd5311920a152cae117aa34da458383d002", "committedDate": "2021-02-02T13:17:11Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "e2e61a2f37f9186590143712259e23ef790a0038", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/e2e61a2f37f9186590143712259e23ef790a0038", "committedDate": "2021-02-03T16:28:28Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgzMjAwOTY2", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-583200966", "createdAt": "2021-02-04T09:39:50Z", "commit": {"oid": "e2e61a2f37f9186590143712259e23ef790a0038"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQwOTozOTo1MVrOIfqz5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQwOTo1NjozMFrOIfrkCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA3ODE4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               public IpFilterConfigurationBuilder allowFrom(String rule) {\n          \n          \n            \n               public IpFilterConfigurationBuilder<T, S> allowFrom(String rule) {", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570078181", "createdAt": "2021-02-04T09:39:51Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/configuration/IpFilterConfigurationBuilder.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package org.infinispan.server.core.configuration;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.infinispan.commons.configuration.Builder;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * IpFilterConfigurationBuilder.\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.1\n+ */\n+public class IpFilterConfigurationBuilder<T extends ProtocolServerConfiguration, S extends ProtocolServerConfigurationChildBuilder<T, S>>\n+      extends AbstractProtocolServerConfigurationChildBuilder<T, S>\n+      implements Builder<IpFilterConfiguration> {\n+\n+   List<IpSubnetFilterRule> rules = new ArrayList<>();\n+\n+   public IpFilterConfigurationBuilder(ProtocolServerConfigurationChildBuilder<T, S> builder) {\n+      super(builder);\n+   }\n+\n+   public IpFilterConfigurationBuilder allowFrom(String rule) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2e61a2f37f9186590143712259e23ef790a0038"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA3ODI4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               public IpFilterConfigurationBuilder rejectFrom(String rule) {\n          \n          \n            \n               public IpFilterConfigurationBuilder<T, S> rejectFrom(String rule) {", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570078286", "createdAt": "2021-02-04T09:39:58Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/configuration/IpFilterConfigurationBuilder.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package org.infinispan.server.core.configuration;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.infinispan.commons.configuration.Builder;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * IpFilterConfigurationBuilder.\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.1\n+ */\n+public class IpFilterConfigurationBuilder<T extends ProtocolServerConfiguration, S extends ProtocolServerConfigurationChildBuilder<T, S>>\n+      extends AbstractProtocolServerConfigurationChildBuilder<T, S>\n+      implements Builder<IpFilterConfiguration> {\n+\n+   List<IpSubnetFilterRule> rules = new ArrayList<>();\n+\n+   public IpFilterConfigurationBuilder(ProtocolServerConfigurationChildBuilder<T, S> builder) {\n+      super(builder);\n+   }\n+\n+   public IpFilterConfigurationBuilder allowFrom(String rule) {\n+      rules.add(IpSubnetFilterRule.from(rule, IpFilterRuleType.ACCEPT));\n+      return this;\n+   }\n+\n+   public IpFilterConfigurationBuilder rejectFrom(String rule) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2e61a2f37f9186590143712259e23ef790a0038"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA3ODQzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               public IpFilterConfigurationBuilder read(IpFilterConfiguration template) {\n          \n          \n            \n               public IpFilterConfigurationBuilder<T, S> read(IpFilterConfiguration template) {", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570078430", "createdAt": "2021-02-04T09:40:07Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/configuration/IpFilterConfigurationBuilder.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package org.infinispan.server.core.configuration;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.infinispan.commons.configuration.Builder;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * IpFilterConfigurationBuilder.\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.1\n+ */\n+public class IpFilterConfigurationBuilder<T extends ProtocolServerConfiguration, S extends ProtocolServerConfigurationChildBuilder<T, S>>\n+      extends AbstractProtocolServerConfigurationChildBuilder<T, S>\n+      implements Builder<IpFilterConfiguration> {\n+\n+   List<IpSubnetFilterRule> rules = new ArrayList<>();\n+\n+   public IpFilterConfigurationBuilder(ProtocolServerConfigurationChildBuilder<T, S> builder) {\n+      super(builder);\n+   }\n+\n+   public IpFilterConfigurationBuilder allowFrom(String rule) {\n+      rules.add(IpSubnetFilterRule.from(rule, IpFilterRuleType.ACCEPT));\n+      return this;\n+   }\n+\n+   public IpFilterConfigurationBuilder rejectFrom(String rule) {\n+      rules.add(IpSubnetFilterRule.from(rule, IpFilterRuleType.REJECT));\n+      return this;\n+   }\n+\n+   @Override\n+   public void validate() {\n+   }\n+\n+   @Override\n+   public IpFilterConfiguration create() {\n+      return new IpFilterConfiguration(rules);\n+   }\n+\n+   @Override\n+   public IpFilterConfigurationBuilder read(IpFilterConfiguration template) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2e61a2f37f9186590143712259e23ef790a0038"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA3ODY4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               List<IpSubnetFilterRule> rules = new ArrayList<>();\n          \n          \n            \n               private final List<IpSubnetFilterRule> rules = new ArrayList<>();", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570078685", "createdAt": "2021-02-04T09:40:30Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/configuration/IpFilterConfigurationBuilder.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package org.infinispan.server.core.configuration;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.infinispan.commons.configuration.Builder;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * IpFilterConfigurationBuilder.\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.1\n+ */\n+public class IpFilterConfigurationBuilder<T extends ProtocolServerConfiguration, S extends ProtocolServerConfigurationChildBuilder<T, S>>\n+      extends AbstractProtocolServerConfigurationChildBuilder<T, S>\n+      implements Builder<IpFilterConfiguration> {\n+\n+   List<IpSubnetFilterRule> rules = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2e61a2f37f9186590143712259e23ef790a0038"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA3OTI3MQ==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  this.ipfilter = ipfilter;\n          \n          \n            \n                  this.ipfilter = ipFilter;", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570079271", "createdAt": "2021-02-04T09:41:19Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/configuration/ProtocolServerConfiguration.java", "diffHunk": "@@ -63,10 +63,12 @@ public static AttributeSet attributeDefinitionSet() {\n    protected final AttributeSet attributes;\n \n    protected final SslConfiguration ssl;\n+   protected final IpFilterConfiguration ipfilter;\n \n-   protected ProtocolServerConfiguration(AttributeSet attributes, SslConfiguration ssl) {\n+   protected ProtocolServerConfiguration(AttributeSet attributes, SslConfiguration ssl, IpFilterConfiguration ipfilter) {\n       this.attributes = attributes.checkProtection();\n       this.ssl = ssl;\n+      this.ipfilter = ipfilter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2e61a2f37f9186590143712259e23ef790a0038"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA3OTU0MA==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               public IpFilterConfiguration ipfilter() {\n          \n          \n            \n               public IpFilterConfiguration ipFilter() {", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570079540", "createdAt": "2021-02-04T09:41:43Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/configuration/ProtocolServerConfiguration.java", "diffHunk": "@@ -121,6 +123,10 @@ public SslConfiguration ssl() {\n       return ssl;\n    }\n \n+   public IpFilterConfiguration ipfilter() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2e61a2f37f9186590143712259e23ef790a0038"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA4MDM0MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  this.ipFilter = new IpFilterConfigurationBuilder(this);\n          \n          \n            \n                  this.ipFilter = new IpFilterConfigurationBuilder<>(this);", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570080341", "createdAt": "2021-02-04T09:42:47Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/configuration/ProtocolServerConfigurationBuilder.java", "diffHunk": "@@ -26,10 +26,12 @@\n    private static final Log log = LogFactory.getLog(ProtocolServerConfigurationBuilder.class, Log.class);\n    protected final AttributeSet attributes;\n    protected final SslConfigurationBuilder<T, S> ssl;\n+   protected final IpFilterConfigurationBuilder<T, S> ipFilter;\n \n    protected ProtocolServerConfigurationBuilder(int port, AttributeSet attributes) {\n       this.attributes = attributes;\n       this.ssl = new SslConfigurationBuilder(this);\n+      this.ipFilter = new IpFilterConfigurationBuilder(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2e61a2f37f9186590143712259e23ef790a0038"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA4MDczMg==", "bodyText": "method's name \"should\" be ipFilter IMO\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               public IpFilterConfigurationBuilder ipRules() {\n          \n          \n            \n               public IpFilterConfigurationBuilder<T, S> ipFilter() { {\n          \n      \n    \n    \n  \n\nshould ProtocolServerConfigurationChildBuilder have this method as well?", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570080732", "createdAt": "2021-02-04T09:43:21Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/configuration/ProtocolServerConfigurationBuilder.java", "diffHunk": "@@ -109,6 +111,10 @@ public SslConfigurationBuilder ssl() {\n       return ssl;\n    }\n \n+   public IpFilterConfigurationBuilder ipRules() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2e61a2f37f9186590143712259e23ef790a0038"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA4NDEwNg==", "bodyText": "well, I have a \"smaller\" implementation in mind:\npublic class InfinispanIpSubnetFilterRule implements IpFilterRule {\n\n   private final IpSubnetFilterRule filterRule;\n   private final String cidr;\n\n   public InfinispanIpSubnetFilterRule(String cidr, IpFilterRuleType ruleType) {\n      int sep = cidr.indexOf('/');\n      if (sep < 0) {\n         throw new IllegalArgumentException(cidr);\n      }\n      this.filterRule = new IpSubnetFilterRule(cidr.substring(0, sep), Integer.parseInt(cidr.substring(sep + 1)), ruleType);\n      this.cidr = cidr;\n   }\n\n   public String cidr() {\n      return cidr;\n   }\n\n   @Override\n   public boolean matches(InetSocketAddress inetSocketAddress) {\n      return filterRule.matches(inetSocketAddress);\n   }\n\n   @Override\n   public IpFilterRuleType ruleType() {\n      return filterRule.ruleType();\n   }\n}", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570084106", "createdAt": "2021-02-04T09:47:52Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/transport/IpSubnetFilterRule.java", "diffHunk": "@@ -0,0 +1,189 @@\n+package org.infinispan.server.core.transport;\n+\n+import java.math.BigInteger;\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.util.Objects;\n+\n+import io.netty.handler.ipfilter.IpFilterRule;\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SocketUtils;\n+\n+/**\n+ * This differs from Netty's equivalent {@link io.netty.handler.ipfilter.IpSubnetFilterRule} in that it parses CIDR\n+ * addresses\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.1\n+ */\n+public abstract class IpSubnetFilterRule implements IpFilterRule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2e61a2f37f9186590143712259e23ef790a0038"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA4NTQ0OQ==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               private final RuleBasedIpFilter iprulesHandler;\n          \n          \n            \n               private final RuleBasedIpFilter ipRulesHandler;", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570085449", "createdAt": "2021-02-04T09:49:37Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/transport/NettyChannelInitializer.java", "diffHunk": "@@ -28,19 +28,24 @@\n    protected final NettyTransport transport;\n    protected final ChannelOutboundHandler encoder;\n    protected final ChannelInboundHandler decoder;\n+   private final RuleBasedIpFilter iprulesHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2e61a2f37f9186590143712259e23ef790a0038"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA4NTY1MA==", "bodyText": "shouldn't the ip filter be the first one?", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570085650", "createdAt": "2021-02-04T09:49:53Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/transport/NettyChannelInitializer.java", "diffHunk": "@@ -28,19 +28,24 @@\n    protected final NettyTransport transport;\n    protected final ChannelOutboundHandler encoder;\n    protected final ChannelInboundHandler decoder;\n+   private final RuleBasedIpFilter iprulesHandler;\n+   private final StatsChannelHandler statsHandler;\n \n    public NettyChannelInitializer(ProtocolServer<A> server, NettyTransport transport, ChannelOutboundHandler encoder, ChannelInboundHandler decoder) {\n       this.server = server;\n       this.transport = transport;\n       this.encoder = encoder;\n       this.decoder = decoder;\n+      this.statsHandler = transport != null ? new StatsChannelHandler(transport) : null;\n+      this.iprulesHandler = new RuleBasedIpFilter(server.getConfiguration().ipfilter());\n    }\n \n    @Override\n    public void initializeChannel(Channel ch) throws Exception {\n       ChannelPipeline pipeline = ch.pipeline();\n-      if(transport != null) {\n-         pipeline.addLast(\"stats\", new StatsChannelHandler(transport));\n+      pipeline.addLast(\"iprules\", iprulesHandler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2e61a2f37f9186590143712259e23ef790a0038"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDA5MDUwNA==", "bodyText": "it is duplicated from line 182. remove this one.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570090504", "createdAt": "2021-02-04T09:56:30Z", "author": {"login": "pruivo"}, "path": "server/runtime/src/main/java/org/infinispan/server/Server.java", "diffHunk": "@@ -177,12 +179,13 @@\n    private volatile ComponentStatus status;\n    private ServerConfiguration serverConfiguration;\n    private Extensions extensions;\n-   private CacheIgnoreManager cacheIgnoreManager;\n+   private ServerStateManager serverStateManager;\n    private ScheduledExecutorService scheduler;\n    private TaskManager taskManager;\n    private ServerInitialContextFactoryBuilder initialContextFactoryBuilder;\n    private BlockingManager blockingManager;\n    private BackupManager backupManager;\n+   private ServerStateManager stateManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2e61a2f37f9186590143712259e23ef790a0038"}, "originalPosition": 38}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e2e61a2f37f9186590143712259e23ef790a0038", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/e2e61a2f37f9186590143712259e23ef790a0038", "committedDate": "2021-02-03T16:28:28Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "a97afee7c723090b819040498a361d878f1f7607", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/a97afee7c723090b819040498a361d878f1f7607", "committedDate": "2021-02-04T12:18:07Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a97afee7c723090b819040498a361d878f1f7607", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/a97afee7c723090b819040498a361d878f1f7607", "committedDate": "2021-02-04T12:18:07Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "ecac734d29caa0e086d779c6df22a5a18ff5bb94", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/ecac734d29caa0e086d779c6df22a5a18ff5bb94", "committedDate": "2021-02-05T09:24:35Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ecac734d29caa0e086d779c6df22a5a18ff5bb94", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/ecac734d29caa0e086d779c6df22a5a18ff5bb94", "committedDate": "2021-02-05T09:24:35Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "70e9b0d34ab99bd874ced60f0cbdc1e6ccfd4699", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/70e9b0d34ab99bd874ced60f0cbdc1e6ccfd4699", "committedDate": "2021-02-05T10:02:35Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg0MTU3MjI4", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-584157228", "createdAt": "2021-02-05T09:24:02Z", "commit": {"oid": "a97afee7c723090b819040498a361d878f1f7607"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQwOToyNDowMlrOIgYssw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxMDoyNzoxMVrOIgbFcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDgzMDAwMw==", "bodyText": "revert?", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570830003", "createdAt": "2021-02-05T09:24:02Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/configuration/SniConfiguration.java", "diffHunk": "@@ -9,7 +9,8 @@\n /**\n  * @since 10.0\n  */\n-public class SniConfiguration implements ConfigurationInfo {\n+public class", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a97afee7c723090b819040498a361d878f1f7607"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg0MDg0OQ==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  }).addListener(new ChannelGroupFutureListener() {\n          \n          \n            \n                     @Override\n          \n          \n            \n                     public void operationComplete(ChannelGroupFuture channelFutures) {\n          \n          \n            \n                        closed.complete(null);\n          \n          \n            \n                     }\n          \n          \n            \n                  });\n          \n          \n            \n                  }).addListener((ChannelGroupFutureListener) channelFutures -> closed.complete(null));", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570840849", "createdAt": "2021-02-05T09:41:06Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/transport/NettyTransport.java", "diffHunk": "@@ -276,6 +319,25 @@ public void updateTotalBytesRead(int bytes) {\n       connectionStats.incrementTotalBytesRead(bytes);\n    }\n \n+   @Override\n+   public CompletionStage<Void> applyIpFilterRules(List<IpSubnetFilterRule> rules) {\n+      CompletableFuture<Void> closed = new CompletableFuture<>();\n+      acceptedChannels.close(channel -> {\n+         for (IpFilterRule rule : rules) {\n+            if (rule.matches((InetSocketAddress) channel.remoteAddress())) {\n+               return rule.ruleType() == IpFilterRuleType.REJECT;\n+            }\n+         }\n+         return false;\n+      }).addListener(new ChannelGroupFutureListener() {\n+         @Override\n+         public void operationComplete(ChannelGroupFuture channelFutures) {\n+            closed.complete(null);\n+         }\n+      });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecac734d29caa0e086d779c6df22a5a18ff5bb94"}, "originalPosition": 340}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg0MTM3OQ==", "bodyText": "volatile? group with other fields?", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570841379", "createdAt": "2021-02-05T09:42:01Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/transport/NettyTransport.java", "diffHunk": "@@ -60,14 +84,15 @@ private static boolean isIsLog4jAvailable() {\n       }\n    }\n \n+   private boolean running;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecac734d29caa0e086d779c6df22a5a18ff5bb94"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg0NTQ4NQ==", "bodyText": "I've noticed rules() is a simple ArrayList. You could get a ConcurrentModificationException if you are unlucky and a thread is iteration while other is updating the rules.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570845485", "createdAt": "2021-02-05T09:48:21Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/transport/RuleBasedIpFilter.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.infinispan.server.core.transport;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.infinispan.server.core.configuration.IpFilterConfiguration;\n+import org.infinispan.server.core.logging.Log;\n+\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.ipfilter.AbstractRemoteAddressFilter;\n+import io.netty.handler.ipfilter.IpFilterRule;\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+@Sharable\n+public class RuleBasedIpFilter extends AbstractRemoteAddressFilter<InetSocketAddress> {\n+\n+   private final IpFilterConfiguration rules;\n+\n+   public RuleBasedIpFilter(IpFilterConfiguration rules) {\n+      this.rules = rules;\n+   }\n+\n+   @Override\n+   protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) throws Exception {\n+      for (IpFilterRule rule : rules.rules()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecac734d29caa0e086d779c6df22a5a18ff5bb94"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg0NzQ0Mw==", "bodyText": "remove cacheManagerName and remove the parameter from getServerStateManager().\nIt is not used anywhere, no need to waste CPU cycles for nothing.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570847443", "createdAt": "2021-02-05T09:51:33Z", "author": {"login": "pruivo"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ServerResource.java", "diffHunk": "@@ -91,15 +107,132 @@ public Invocations getInvocations() {\n       DefaultCacheManager cacheManager = invocationHelper.getServer().getCacheManager(cacheManagerName);\n \n       if (cacheManager == null) return notFoundResponseFuture();\n-      CacheIgnoreManager ignoreManager = invocationHelper.getServer().getIgnoreManager(cacheManagerName);\n-      Set<String> ignored = ignoreManager.getIgnoredCaches();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager(cacheManagerName);\n+      Set<String> ignored = serverStateManager.getIgnoredCaches();\n       return asJsonResponseFuture(Json.make(ignored));\n    }\n \n    private CompletionStage<RestResponse> cacheManagers(RestRequest restRequest) {\n       return asJsonResponseFuture(Json.make(invocationHelper.getServer().cacheManagerNames()));\n    }\n \n+   private CompletionStage<RestResponse> connectorStartStop(RestRequest restRequest) {\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder().status(NO_CONTENT);\n+      String connectorName = restRequest.variables().get(\"connector\");\n+\n+      ProtocolServer connector = invocationHelper.getServer().getProtocolServers().get(connectorName);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+      if (connector.getTransport() == null) return completedFuture(builder.status(BAD_REQUEST).entity(\"Connector has no transport\").build());\n+\n+      String cacheManagerName = invocationHelper.getServer().cacheManagerNames().iterator().next();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager(cacheManagerName);\n+\n+      switch (restRequest.getAction()) {\n+         case \"start\":\n+            return serverStateManager.connectorStart(connectorName).thenApply(r -> builder.build());\n+         case \"stop\":\n+            return serverStateManager.connectorStop(connectorName).thenApply(r -> builder.build());\n+      }\n+      return completedFuture(builder.status(BAD_REQUEST).build());\n+   }\n+\n+   private CompletionStage<RestResponse> connectorStatus(RestRequest restRequest) {\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      String connectorName = restRequest.variables().get(\"connector\");\n+\n+      ProtocolServer connector = getProtocolServer(restRequest);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+\n+      String cacheManagerName = invocationHelper.getServer().cacheManagerNames().iterator().next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecac734d29caa0e086d779c6df22a5a18ff5bb94"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg0OTU4MA==", "bodyText": "shouldn't authorization be checked before?\nfollowing the code, I found only serverStateManager.connectorStatus() checks for ADMIN and it is only invoked when there is a Transport.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570849580", "createdAt": "2021-02-05T09:54:59Z", "author": {"login": "pruivo"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ServerResource.java", "diffHunk": "@@ -91,15 +107,132 @@ public Invocations getInvocations() {\n       DefaultCacheManager cacheManager = invocationHelper.getServer().getCacheManager(cacheManagerName);\n \n       if (cacheManager == null) return notFoundResponseFuture();\n-      CacheIgnoreManager ignoreManager = invocationHelper.getServer().getIgnoreManager(cacheManagerName);\n-      Set<String> ignored = ignoreManager.getIgnoredCaches();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager(cacheManagerName);\n+      Set<String> ignored = serverStateManager.getIgnoredCaches();\n       return asJsonResponseFuture(Json.make(ignored));\n    }\n \n    private CompletionStage<RestResponse> cacheManagers(RestRequest restRequest) {\n       return asJsonResponseFuture(Json.make(invocationHelper.getServer().cacheManagerNames()));\n    }\n \n+   private CompletionStage<RestResponse> connectorStartStop(RestRequest restRequest) {\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder().status(NO_CONTENT);\n+      String connectorName = restRequest.variables().get(\"connector\");\n+\n+      ProtocolServer connector = invocationHelper.getServer().getProtocolServers().get(connectorName);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+      if (connector.getTransport() == null) return completedFuture(builder.status(BAD_REQUEST).entity(\"Connector has no transport\").build());\n+\n+      String cacheManagerName = invocationHelper.getServer().cacheManagerNames().iterator().next();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager(cacheManagerName);\n+\n+      switch (restRequest.getAction()) {\n+         case \"start\":\n+            return serverStateManager.connectorStart(connectorName).thenApply(r -> builder.build());\n+         case \"stop\":\n+            return serverStateManager.connectorStop(connectorName).thenApply(r -> builder.build());\n+      }\n+      return completedFuture(builder.status(BAD_REQUEST).build());\n+   }\n+\n+   private CompletionStage<RestResponse> connectorStatus(RestRequest restRequest) {\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      String connectorName = restRequest.variables().get(\"connector\");\n+\n+      ProtocolServer connector = getProtocolServer(restRequest);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecac734d29caa0e086d779c6df22a5a18ff5bb94"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg1MTE3Mw==", "bodyText": "connectorStatus() is non blocking & local only operation.\nActually, it only does transport.isRunning() which you have access here.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570851173", "createdAt": "2021-02-05T09:57:24Z", "author": {"login": "pruivo"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ServerResource.java", "diffHunk": "@@ -91,15 +107,132 @@ public Invocations getInvocations() {\n       DefaultCacheManager cacheManager = invocationHelper.getServer().getCacheManager(cacheManagerName);\n \n       if (cacheManager == null) return notFoundResponseFuture();\n-      CacheIgnoreManager ignoreManager = invocationHelper.getServer().getIgnoreManager(cacheManagerName);\n-      Set<String> ignored = ignoreManager.getIgnoredCaches();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager(cacheManagerName);\n+      Set<String> ignored = serverStateManager.getIgnoredCaches();\n       return asJsonResponseFuture(Json.make(ignored));\n    }\n \n    private CompletionStage<RestResponse> cacheManagers(RestRequest restRequest) {\n       return asJsonResponseFuture(Json.make(invocationHelper.getServer().cacheManagerNames()));\n    }\n \n+   private CompletionStage<RestResponse> connectorStartStop(RestRequest restRequest) {\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder().status(NO_CONTENT);\n+      String connectorName = restRequest.variables().get(\"connector\");\n+\n+      ProtocolServer connector = invocationHelper.getServer().getProtocolServers().get(connectorName);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+      if (connector.getTransport() == null) return completedFuture(builder.status(BAD_REQUEST).entity(\"Connector has no transport\").build());\n+\n+      String cacheManagerName = invocationHelper.getServer().cacheManagerNames().iterator().next();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager(cacheManagerName);\n+\n+      switch (restRequest.getAction()) {\n+         case \"start\":\n+            return serverStateManager.connectorStart(connectorName).thenApply(r -> builder.build());\n+         case \"stop\":\n+            return serverStateManager.connectorStop(connectorName).thenApply(r -> builder.build());\n+      }\n+      return completedFuture(builder.status(BAD_REQUEST).build());\n+   }\n+\n+   private CompletionStage<RestResponse> connectorStatus(RestRequest restRequest) {\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      String connectorName = restRequest.variables().get(\"connector\");\n+\n+      ProtocolServer connector = getProtocolServer(restRequest);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+\n+      String cacheManagerName = invocationHelper.getServer().cacheManagerNames().iterator().next();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager(cacheManagerName);\n+\n+      Json info = Json.object()\n+            .set(\"name\", connectorName)\n+            .set(\"ip-filter-rules\", ipFilterRulesAsJson(connector));\n+      Transport transport = connector.getTransport();\n+      if (transport != null) {\n+         info.set(\"host\", transport.getHostName())\n+               .set(\"port\", transport.getPort())\n+               .set(\"local-connections\", transport.getNumberOfLocalConnections())\n+               .set(\"global-connections\", transport.getNumberOfGlobalConnections())\n+               .set(\"io-threads\", transport.getNumberIOThreads())\n+               .set(\"pending-tasks\", transport.getPendingTasks())\n+               .set(\"total-bytes-read\", transport.getTotalBytesRead())\n+               .set(\"total-bytes-written\", transport.getTotalBytesWritten())\n+               .set(\"send-buffer-size\", transport.getSendBufferSize())\n+               .set(\"receive-buffer-size\", transport.getReceiveBufferSize());\n+         return serverStateManager.connectorStatus(connectorName).thenApply(b -> builder.contentType(APPLICATION_JSON).entity(info.set(\"enabled\", b)).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ecac734d29caa0e086d779c6df22a5a18ff5bb94"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg1MTYyNg==", "bodyText": "ps. manually check authz at the beginning for other connector's related methods?", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570851626", "createdAt": "2021-02-05T09:58:04Z", "author": {"login": "pruivo"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ServerResource.java", "diffHunk": "@@ -91,15 +107,132 @@ public Invocations getInvocations() {\n       DefaultCacheManager cacheManager = invocationHelper.getServer().getCacheManager(cacheManagerName);\n \n       if (cacheManager == null) return notFoundResponseFuture();\n-      CacheIgnoreManager ignoreManager = invocationHelper.getServer().getIgnoreManager(cacheManagerName);\n-      Set<String> ignored = ignoreManager.getIgnoredCaches();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager(cacheManagerName);\n+      Set<String> ignored = serverStateManager.getIgnoredCaches();\n       return asJsonResponseFuture(Json.make(ignored));\n    }\n \n    private CompletionStage<RestResponse> cacheManagers(RestRequest restRequest) {\n       return asJsonResponseFuture(Json.make(invocationHelper.getServer().cacheManagerNames()));\n    }\n \n+   private CompletionStage<RestResponse> connectorStartStop(RestRequest restRequest) {\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder().status(NO_CONTENT);\n+      String connectorName = restRequest.variables().get(\"connector\");\n+\n+      ProtocolServer connector = invocationHelper.getServer().getProtocolServers().get(connectorName);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+      if (connector.getTransport() == null) return completedFuture(builder.status(BAD_REQUEST).entity(\"Connector has no transport\").build());\n+\n+      String cacheManagerName = invocationHelper.getServer().cacheManagerNames().iterator().next();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager(cacheManagerName);\n+\n+      switch (restRequest.getAction()) {\n+         case \"start\":\n+            return serverStateManager.connectorStart(connectorName).thenApply(r -> builder.build());\n+         case \"stop\":\n+            return serverStateManager.connectorStop(connectorName).thenApply(r -> builder.build());\n+      }\n+      return completedFuture(builder.status(BAD_REQUEST).build());\n+   }\n+\n+   private CompletionStage<RestResponse> connectorStatus(RestRequest restRequest) {\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      String connectorName = restRequest.variables().get(\"connector\");\n+\n+      ProtocolServer connector = getProtocolServer(restRequest);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg0OTU4MA=="}, "originalCommit": {"oid": "ecac734d29caa0e086d779c6df22a5a18ff5bb94"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg1NTM2NA==", "bodyText": "find & replace all 12.0 => 12.1?", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570855364", "createdAt": "2021-02-05T10:04:11Z", "author": {"login": "pruivo"}, "path": "server/tests/src/test/resources/configuration/MultiEndpointClusteredServerTest.xml", "diffHunk": "@@ -0,0 +1,25 @@\n+<infinispan\n+        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+        xmlns:xi=\"http://www.w3.org/2001/XInclude\"\n+        xsi:schemaLocation=\"urn:infinispan:config:12.0 https://infinispan.org/schemas/infinispan-config-12.0.xsd", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70e9b0d34ab99bd874ced60f0cbdc1e6ccfd4699"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg1NzQyNg==", "bodyText": "why no returning 200?", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570857426", "createdAt": "2021-02-05T10:07:37Z", "author": {"login": "pruivo"}, "path": "server/tests/src/test/java/org/infinispan/server/functional/ProtocolManagementIT.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package org.infinispan.server.functional;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+\n+import java.io.IOException;\n+import java.net.ConnectException;\n+import java.net.SocketException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.commons.test.Exceptions;\n+import org.infinispan.server.network.NetworkAddress;\n+import org.infinispan.server.test.core.ServerRunMode;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerRuleBuilder;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+public class ProtocolManagementIT {\n+\n+   @ClassRule\n+   public static InfinispanServerRule SERVERS =\n+         InfinispanServerRuleBuilder.config(\"configuration/MultiEndpointClusteredServerTest.xml\")\n+               .runMode(ServerRunMode.EMBEDDED)\n+               .numServers(2)\n+               .property(\"infinispan.bind.address\", \"0.0.0.0\")\n+               .build();\n+\n+   @Rule\n+   public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+   @Test\n+   public void testIpFilter() throws IOException {\n+      NetworkAddress loopback = NetworkAddress.loopback(\"loopback\");\n+      RestClientConfigurationBuilder loopbackBuilder = new RestClientConfigurationBuilder();\n+      loopbackBuilder.addServer().host(loopback.getAddress().getHostAddress()).port(11222);\n+      RestClient loopbackClient = SERVER_TEST.rest().withClientConfiguration(loopbackBuilder).get();\n+      assertEquals(200, sync(loopbackClient.server().connectorNames()).getStatus());\n+\n+      NetworkAddress siteLocal = NetworkAddress.siteLocal(\"sitelocal\");\n+      RestClientConfigurationBuilder siteLocalBuilder0 = new RestClientConfigurationBuilder();\n+      siteLocalBuilder0.addServer().host(siteLocal.getAddress().getHostAddress()).port(11222);\n+      RestClient siteLocalClient0 = SERVER_TEST.rest().withClientConfiguration(siteLocalBuilder0).get();\n+      assertEquals(200, sync(siteLocalClient0.server().connectorNames()).getStatus());\n+\n+      RestClientConfigurationBuilder siteLocalBuilder1 = new RestClientConfigurationBuilder();\n+      siteLocalBuilder1.addServer().host(siteLocal.getAddress().getHostAddress()).port(11322);\n+      RestClient siteLocalClient1 = SERVER_TEST.rest().withClientConfiguration(siteLocalBuilder1).get();\n+      RestResponse response = sync(siteLocalClient1.server().connectorNames());\n+      assertEquals(200, response.getStatus());\n+\n+      List<IpFilterRule> rules = new ArrayList<>();\n+      rules.add(new IpFilterRule(IpFilterRule.RuleType.REJECT, siteLocal.cidr()));\n+      assertEquals(204, sync(loopbackClient.server().connectorIpFilterSet(\"endpoint-default\", rules)).getStatus());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70e9b0d34ab99bd874ced60f0cbdc1e6ccfd4699"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg1ODM5MQ==", "bodyText": "find and replace 12.0 => 12.1 in all new classes? :)", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570858391", "createdAt": "2021-02-05T10:09:04Z", "author": {"login": "pruivo"}, "path": "server/tests/src/test/java/org/infinispan/server/functional/ProtocolManagementIT.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package org.infinispan.server.functional;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+\n+import java.io.IOException;\n+import java.net.ConnectException;\n+import java.net.SocketException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.commons.test.Exceptions;\n+import org.infinispan.server.network.NetworkAddress;\n+import org.infinispan.server.test.core.ServerRunMode;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerRuleBuilder;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70e9b0d34ab99bd874ced60f0cbdc1e6ccfd4699"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg2NzM1MQ==", "bodyText": "ipv6 testing?", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570867351", "createdAt": "2021-02-05T10:24:08Z", "author": {"login": "pruivo"}, "path": "server/core/src/test/java/org/infinispan/server/core/configuration/IpSubnetFilterRuleTest.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package org.infinispan.server.core.configuration;\n+\n+import static org.testng.AssertJUnit.assertFalse;\n+import static org.testng.AssertJUnit.assertTrue;\n+\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.testng.annotations.Test;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+@Test(groups = \"unit\", testName = \"server.configuration.IpSubnetFilterRuleTest\")\n+public class IpSubnetFilterRuleTest {\n+   public void testIpSubnetFilterRule() throws UnknownHostException {\n+      IpSubnetFilterRule rule = new IpSubnetFilterRule(\"192.168.0.0/16\", IpFilterRuleType.ACCEPT);\n+      assertTrue(rule.matches(new InetSocketAddress(InetAddress.getByName(\"192.168.0.1\"), 11222)));\n+      assertFalse(rule.matches(new InetSocketAddress(InetAddress.getByName(\"10.11.12.13\"), 11222)));\n+      rule = new IpSubnetFilterRule(\"/0\", IpFilterRuleType.REJECT);\n+      assertTrue(rule.matches(new InetSocketAddress(InetAddress.getByName(\"192.168.0.1\"), 11222)));\n+      assertTrue(rule.matches(new InetSocketAddress(InetAddress.getByName(\"10.11.12.13\"), 11222)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70e9b0d34ab99bd874ced60f0cbdc1e6ccfd4699"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg2OTEwNg==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class IpFilterRuleCompleter extends EnumCompleter {\n          \n          \n            \n            public class IpFilterRuleCompleter extends EnumCompleter<IpFilterRule.RuleType> {", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570869106", "createdAt": "2021-02-05T10:27:11Z", "author": {"login": "pruivo"}, "path": "cli/src/main/java/org/infinispan/cli/completers/IpFilterRuleCompleter.java", "diffHunk": "@@ -0,0 +1,14 @@\n+package org.infinispan.cli.completers;\n+\n+import org.infinispan.client.rest.IpFilterRule;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.0\n+ **/\n+public class IpFilterRuleCompleter extends EnumCompleter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "70e9b0d34ab99bd874ced60f0cbdc1e6ccfd4699"}, "originalPosition": 9}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "70e9b0d34ab99bd874ced60f0cbdc1e6ccfd4699", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/70e9b0d34ab99bd874ced60f0cbdc1e6ccfd4699", "committedDate": "2021-02-05T10:02:35Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "e20c592825560ae342b939ea66d1654d6d02e432", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/e20c592825560ae342b939ea66d1654d6d02e432", "committedDate": "2021-02-05T10:29:22Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg0MjIxOTEx", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-584221911", "createdAt": "2021-02-05T10:45:45Z", "commit": {"oid": "e20c592825560ae342b939ea66d1654d6d02e432"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxMDo0NTo0NlrOIgbuxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxMDo0ODozOFrOIgb1QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg3OTY4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            {brandname} endpoints and connectors can specify one or more IP filtering rules. Thes\n          \n          \n            \n            \n          \n          \n            \n            \n          \n          \n            \n            \n          \n          \n            \n            e rules specify the type of action\n          \n          \n            \n            {brandname} endpoints and connectors can specify one or more IP filtering rules. These rules specify the type of action", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570879687", "createdAt": "2021-02-05T10:45:46Z", "author": {"login": "pruivo"}, "path": "documentation/src/main/asciidoc/topics/ref_server_ipfilter_cli.adoc", "diffHunk": "@@ -0,0 +1,46 @@\n+[id='server_endpoint_ipfilter_cli-{context}']\n+= {brandname} Server IP Filter\n+\n+{brandname} endpoints and connectors can specify one or more IP filtering rules. Thes\n+\n+\n+\n+e rules specify the type of action", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e20c592825560ae342b939ea66d1654d6d02e432"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg4MTM0NQ==", "bodyText": "the content of this file is the same as documentation/src/main/asciidoc/topics/ref_server_ipfilter.adoc\nyou will end up with sections 4.6.1 & 4.6.2 with the same content.\nis this file updated?\nshouldn't be the CLI commands?", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570881345", "createdAt": "2021-02-05T10:48:38Z", "author": {"login": "pruivo"}, "path": "documentation/src/main/asciidoc/topics/ref_server_ipfilter_cli.adoc", "diffHunk": "@@ -0,0 +1,46 @@\n+[id='server_endpoint_ipfilter_cli-{context}']", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e20c592825560ae342b939ea66d1654d6d02e432"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg0MjM0MTc2", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-584234176", "createdAt": "2021-02-05T11:02:21Z", "commit": {"oid": "e20c592825560ae342b939ea66d1654d6d02e432"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxMTowMjoyMVrOIgcTHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxMTowMjoyMVrOIgcTHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg4ODk4OQ==", "bodyText": "needs a toString() for logging\n[org.infinispan.SECURITY] ISPN005052: Rejected connection from '/192.168.2.100:38462' using rule 'org.infinispan.server.core.transport.IpSubnetFilterRule@40b979ac'", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570888989", "createdAt": "2021-02-05T11:02:21Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/transport/IpSubnetFilterRule.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.infinispan.server.core.transport;\n+\n+import java.net.InetSocketAddress;\n+\n+import io.netty.handler.ipfilter.IpFilterRule;\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+import io.netty.util.internal.ObjectUtil;\n+\n+/**\n+ * This differs from Netty's equivalent {@link io.netty.handler.ipfilter.IpSubnetFilterRule} in that it parses CIDR\n+ * addresses\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.1\n+ */\n+public class IpSubnetFilterRule implements IpFilterRule {\n+   private final io.netty.handler.ipfilter.IpSubnetFilterRule rule;\n+   private final String cidr;\n+\n+   public IpSubnetFilterRule(String cidr, IpFilterRuleType type) {\n+      ObjectUtil.checkNotNull(cidr, \"cidr\");\n+      ObjectUtil.checkNotNull(type, \"type\");\n+\n+      int sep = cidr.indexOf('/');\n+      if (sep < 0) {\n+         throw new IllegalArgumentException(cidr);\n+      }\n+      this.cidr = cidr;\n+      this.rule = new io.netty.handler.ipfilter.IpSubnetFilterRule(cidr.substring(0, sep), Integer.parseInt(cidr.substring(sep + 1)), type);\n+   }\n+\n+   public String cidr() {\n+      return cidr;\n+   }\n+\n+   @Override\n+   public boolean matches(InetSocketAddress inetSocketAddress) {\n+      return rule.matches(inetSocketAddress);\n+   }\n+\n+   @Override\n+   public IpFilterRuleType ruleType() {\n+      return rule.ruleType();\n+   }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e20c592825560ae342b939ea66d1654d6d02e432"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg0MjQ0NjE2", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-584244616", "createdAt": "2021-02-05T11:17:16Z", "commit": {"oid": "e20c592825560ae342b939ea66d1654d6d02e432"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxMToxNzoxNlrOIgcxcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxMToxNzoxNlrOIgcxcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDg5Njc1NA==", "bodyText": "[usability]\nyou should put an empty list instead of removing the entry\nUse case:\n\nconfigure IP-filter in infinispan.xml\nstart server1\nclear IP-filter in server1\nstart server2 (same config as infinispan.xml)\n\nserver2 contains the IP-filter configured in infinispan.xml instead of disabled IP-filter.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r570896754", "createdAt": "2021-02-05T11:17:16Z", "author": {"login": "pruivo"}, "path": "server/runtime/src/main/java/org/infinispan/server/state/ServerStateManagerImpl.java", "diffHunk": "@@ -0,0 +1,284 @@\n+package org.infinispan.server.state;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.factories.GlobalComponentRegistry;\n+import org.infinispan.globalstate.GlobalConfigurationManager;\n+import org.infinispan.globalstate.ScopeFilter;\n+import org.infinispan.globalstate.ScopedState;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.marshall.protostream.impl.SerializationContextRegistry;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.core.ProtocolServer;\n+import org.infinispan.server.core.ServerStateManager;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.infinispan.server.core.transport.Transport;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * Manages cluster-wide server state for a given {@link EmbeddedCacheManager}. This handles:\n+ * <ul>\n+ * <li>ignored caches</li>\n+ * <li>protocol servers</li>\n+ * <li>ip filters</li>\n+ * </ul>\n+ *\n+ * @since 12.1\n+ */\n+public final class ServerStateManagerImpl implements ServerStateManager {\n+   private static final String CONNECTOR_STATE_SCOPE = \"connector-state\";\n+   private static final String CONNECTOR_IPFILTER_SCOPE = \"connector-ipfilter\";\n+   private static final ScopedState IGNORED_CACHES_KEY = new ScopedState(\"ignored-caches\", \"ignored-caches\");\n+\n+   private final EmbeddedCacheManager cacheManager;\n+   private final Server server;\n+   private final Cache<ScopedState, Object> cache;\n+   private final IgnoredCaches ignored = new IgnoredCaches();\n+   private volatile boolean hasIgnores;\n+\n+   public ServerStateManagerImpl(Server server, EmbeddedCacheManager cacheManager, GlobalConfigurationManager configurationManager) {\n+      this.server = server;\n+      this.cacheManager = cacheManager;\n+      this.cache = configurationManager.getStateCache();\n+\n+      GlobalComponentRegistry registry = SecurityActions.getGlobalComponentRegistry(cacheManager);\n+      SerializationContextRegistry serializationContextRegistry = registry.getComponent(SerializationContextRegistry.class);\n+      serializationContextRegistry.addContextInitializer(SerializationContextRegistry.MarshallerType.PERSISTENCE, new PersistenceContextInitializerImpl());\n+\n+      updateLocalIgnoredCaches((IgnoredCaches) cache.get(IGNORED_CACHES_KEY));\n+\n+      // Register the listeners which will react on\n+      cache.addListener(new IgnoredCachesListener(), new ScopeFilter(IGNORED_CACHES_KEY.getScope()), null);\n+      cache.addListener(new ConnectorStateListener(), new ScopeFilter(CONNECTOR_STATE_SCOPE), null);\n+      cache.addListener(new ConnectorIpFilterListener(), new ScopeFilter(CONNECTOR_IPFILTER_SCOPE), null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> unignoreCache(String cacheName) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      synchronized (this) {\n+         ignored.caches.remove(cacheName);\n+         hasIgnores = !ignored.caches.isEmpty();\n+         return cache.putAsync(IGNORED_CACHES_KEY, ignored).thenApply(r -> null);\n+      }\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> ignoreCache(String cacheName) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      synchronized (this) {\n+         ignored.caches.add(cacheName);\n+         hasIgnores = !ignored.caches.isEmpty();\n+         return cache.putAsync(IGNORED_CACHES_KEY, ignored).thenApply(r -> null);\n+      }\n+   }\n+\n+   @Override\n+   public Set<String> getIgnoredCaches() {\n+      return Collections.unmodifiableSet(ignored.caches);\n+   }\n+\n+   @Override\n+   public boolean isCacheIgnored(String cacheName) {\n+      return hasIgnores && ignored.caches.contains(cacheName);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Boolean> connectorStart(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.removeAsync(new ScopedState(CONNECTOR_STATE_SCOPE, name), true).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> connectorStop(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.putAsync(new ScopedState(CONNECTOR_STATE_SCOPE, name), true).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Boolean> connectorStatus(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return CompletableFuture.completedFuture(server.getProtocolServers().get(name).getTransport().isRunning());\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> setConnectorIpFilterRule(String name, Collection<IpSubnetFilterRule> filterRule) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      IpFilterRules ipFilterRules = new IpFilterRules();\n+      filterRule.forEach(r -> ipFilterRules.rules.add(new IpFilterRule(r)));\n+      return cache.putAsync(new ScopedState(CONNECTOR_IPFILTER_SCOPE, name), ipFilterRules).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> clearConnectorIpFilterRules(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.removeAsync(new ScopedState(CONNECTOR_IPFILTER_SCOPE, name)).thenApply(v -> null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e20c592825560ae342b939ea66d1654d6d02e432"}, "originalPosition": 141}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e20c592825560ae342b939ea66d1654d6d02e432", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/e20c592825560ae342b939ea66d1654d6d02e432", "committedDate": "2021-02-05T10:29:22Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "f48ca50d2c04a93cfbc8c8b969885de6b73e2ae0", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/f48ca50d2c04a93cfbc8c8b969885de6b73e2ae0", "committedDate": "2021-02-05T13:49:29Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f48ca50d2c04a93cfbc8c8b969885de6b73e2ae0", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/f48ca50d2c04a93cfbc8c8b969885de6b73e2ae0", "committedDate": "2021-02-05T13:49:29Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "34418711aa48c3bb072f467428f32ad986f42c9a", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/34418711aa48c3bb072f467428f32ad986f42c9a", "committedDate": "2021-02-05T14:00:47Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "34418711aa48c3bb072f467428f32ad986f42c9a", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/34418711aa48c3bb072f467428f32ad986f42c9a", "committedDate": "2021-02-05T14:00:47Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "4311422a4c4acd8f37a79a55f61118d4928888a5", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/4311422a4c4acd8f37a79a55f61118d4928888a5", "committedDate": "2021-02-05T15:12:59Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg0NDMxMDgw", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-584431080", "createdAt": "2021-02-05T15:14:07Z", "commit": {"oid": "34418711aa48c3bb072f467428f32ad986f42c9a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxNToxNToxNVrOIgld_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNVQxNToxNToxNVrOIgld_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTAzOTIyOA==", "bodyText": "can be removed. we no longer remove the key from the cache.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r571039228", "createdAt": "2021-02-05T15:15:15Z", "author": {"login": "pruivo"}, "path": "server/runtime/src/main/java/org/infinispan/server/state/ServerStateManagerImpl.java", "diffHunk": "@@ -0,0 +1,278 @@\n+package org.infinispan.server.state;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.globalstate.GlobalConfigurationManager;\n+import org.infinispan.globalstate.ScopeFilter;\n+import org.infinispan.globalstate.ScopedState;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.core.ProtocolServer;\n+import org.infinispan.server.core.ServerStateManager;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.infinispan.server.core.transport.Transport;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * Manages cluster-wide server state for a given {@link EmbeddedCacheManager}. This handles:\n+ * <ul>\n+ * <li>ignored caches</li>\n+ * <li>protocol servers</li>\n+ * <li>ip filters</li>\n+ * </ul>\n+ *\n+ * @since 12.1\n+ */\n+public final class ServerStateManagerImpl implements ServerStateManager {\n+   private static final String CONNECTOR_STATE_SCOPE = \"connector-state\";\n+   private static final String CONNECTOR_IPFILTER_SCOPE = \"connector-ipfilter\";\n+   private static final ScopedState IGNORED_CACHES_KEY = new ScopedState(\"ignored-caches\", \"ignored-caches\");\n+\n+   private final EmbeddedCacheManager cacheManager;\n+   private final Server server;\n+   private final Cache<ScopedState, Object> cache;\n+   private final IgnoredCaches ignored = new IgnoredCaches();\n+   private volatile boolean hasIgnores;\n+\n+   public ServerStateManagerImpl(Server server, EmbeddedCacheManager cacheManager, GlobalConfigurationManager configurationManager) {\n+      this.server = server;\n+      this.cacheManager = cacheManager;\n+      this.cache = configurationManager.getStateCache();\n+\n+      updateLocalIgnoredCaches((IgnoredCaches) cache.get(IGNORED_CACHES_KEY));\n+\n+      // Register the listeners which will react on\n+      cache.addListener(new IgnoredCachesListener(), new ScopeFilter(IGNORED_CACHES_KEY.getScope()), null);\n+      cache.addListener(new ConnectorStateListener(), new ScopeFilter(CONNECTOR_STATE_SCOPE), null);\n+      cache.addListener(new ConnectorIpFilterListener(), new ScopeFilter(CONNECTOR_IPFILTER_SCOPE), null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> unignoreCache(String cacheName) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      synchronized (this) {\n+         ignored.caches.remove(cacheName);\n+         hasIgnores = !ignored.caches.isEmpty();\n+         return cache.putAsync(IGNORED_CACHES_KEY, ignored).thenApply(r -> null);\n+      }\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> ignoreCache(String cacheName) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      synchronized (this) {\n+         ignored.caches.add(cacheName);\n+         hasIgnores = !ignored.caches.isEmpty();\n+         return cache.putAsync(IGNORED_CACHES_KEY, ignored).thenApply(r -> null);\n+      }\n+   }\n+\n+   @Override\n+   public Set<String> getIgnoredCaches() {\n+      return Collections.unmodifiableSet(ignored.caches);\n+   }\n+\n+   @Override\n+   public boolean isCacheIgnored(String cacheName) {\n+      return hasIgnores && ignored.caches.contains(cacheName);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Boolean> connectorStart(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.removeAsync(new ScopedState(CONNECTOR_STATE_SCOPE, name), true).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> connectorStop(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.putAsync(new ScopedState(CONNECTOR_STATE_SCOPE, name), true).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Boolean> connectorStatus(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return CompletableFuture.completedFuture(server.getProtocolServers().get(name).getTransport().isRunning());\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> setConnectorIpFilterRule(String name, Collection<IpSubnetFilterRule> filterRule) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      IpFilterRules ipFilterRules = new IpFilterRules();\n+      filterRule.forEach(r -> ipFilterRules.rules.add(new IpFilterRule(r)));\n+      return cache.putAsync(new ScopedState(CONNECTOR_IPFILTER_SCOPE, name), ipFilterRules).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> clearConnectorIpFilterRules(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.putAsync(new ScopedState(CONNECTOR_IPFILTER_SCOPE, name), new IpFilterRules()).thenApply(v -> null);\n+   }\n+\n+   private void updateLocalIgnoredCaches(IgnoredCaches ignored) {\n+      if (ignored != null) {\n+         synchronized (this) {\n+            this.ignored.caches.clear();\n+            this.ignored.caches.addAll(ignored.caches);\n+            hasIgnores = !this.ignored.caches.isEmpty();\n+         }\n+      }\n+   }\n+\n+   @Listener(observation = Listener.Observation.POST)\n+   private final class IgnoredCachesListener {\n+      @CacheEntryCreated\n+      public void created(CacheEntryCreatedEvent<ScopedState, IgnoredCaches> e) {\n+         if (!e.isOriginLocal()) {\n+            updateLocalIgnoredCaches(e.getValue());\n+         }\n+      }\n+\n+      @CacheEntryModified\n+      public void modified(CacheEntryModifiedEvent<ScopedState, IgnoredCaches> e) {\n+         if (!e.isOriginLocal()) {\n+            updateLocalIgnoredCaches(e.getValue());\n+         }\n+      }\n+   }\n+\n+   @Listener(observation = Listener.Observation.POST)\n+   private final class ConnectorStateListener {\n+      @CacheEntryCreated\n+      public void created(CacheEntryCreatedEvent<ScopedState, Boolean> e) {\n+         // stop the connector\n+         server.getProtocolServers().get(e.getKey().getName()).getTransport().stop();\n+      }\n+\n+      @CacheEntryRemoved\n+      public void removed(CacheEntryRemovedEvent<ScopedState, Boolean> e) {\n+         // start the connector\n+         server.getProtocolServers().get(e.getKey().getName()).getTransport().start();\n+      }\n+   }\n+\n+   @Listener(observation = Listener.Observation.POST)\n+   private final class ConnectorIpFilterListener {\n+      @CacheEntryCreated\n+      @CacheEntryModified\n+      public CompletionStage<Void> modified(CacheEntryEvent<ScopedState, IpFilterRules> e) {\n+         String connector = e.getKey().getName();\n+         ProtocolServer protocolServer = server.getProtocolServers().get(connector);\n+         List<IpSubnetFilterRule> rules = new ArrayList<>(e.getValue().rules.size());\n+                  for (IpFilterRule rule : e.getValue().rules) {\n+            rules.add(new IpSubnetFilterRule(rule.cidr, IpFilterRuleType.valueOf(rule.type)));\n+         }\n+         protocolServer.getConfiguration().ipFilter().rules(rules);\n+         Transport transport = protocolServer.getTransport();\n+         if (transport != null) {\n+            return transport.applyIpFilterRules(rules).thenApply(v -> {\n+               Server.log.connectorIpFilterSet(connector, rules);\n+               return v;\n+            });\n+         } else {\n+            return CompletableFutures.completedExceptionFuture(Server.log.noConnectorTransport(connector));\n+         }\n+      }\n+\n+      @CacheEntryRemoved\n+      public void removed(CacheEntryRemovedEvent<ScopedState, IpFilterRules> e) {\n+         String connector = e.getKey().getName();\n+         server.getProtocolServers().get(connector).getConfiguration().ipFilter().rules().clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4311422a4c4acd8f37a79a55f61118d4928888a5"}, "originalPosition": 206}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4311422a4c4acd8f37a79a55f61118d4928888a5", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/4311422a4c4acd8f37a79a55f61118d4928888a5", "committedDate": "2021-02-05T15:12:59Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "2525a10bb343d6f110dbb34acfffda31c5ac6a35", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/2525a10bb343d6f110dbb34acfffda31c5ac6a35", "committedDate": "2021-02-05T15:19:13Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2525a10bb343d6f110dbb34acfffda31c5ac6a35", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/2525a10bb343d6f110dbb34acfffda31c5ac6a35", "committedDate": "2021-02-05T15:19:13Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "95a3cf2e49f3b986177aba40713f7ab5668a8abb", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/95a3cf2e49f3b986177aba40713f7ab5668a8abb", "committedDate": "2021-02-09T08:36:09Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "95a3cf2e49f3b986177aba40713f7ab5668a8abb", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/95a3cf2e49f3b986177aba40713f7ab5668a8abb", "committedDate": "2021-02-09T08:36:09Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "4dfc550da0365f1d8ce51d935a1314b8de1a28c3", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/4dfc550da0365f1d8ce51d935a1314b8de1a28c3", "committedDate": "2021-02-09T12:20:25Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg2NzIyMjk0", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-586722294", "createdAt": "2021-02-09T16:10:39Z", "commit": {"oid": "4dfc550da0365f1d8ce51d935a1314b8de1a28c3"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxNjoxMDozOVrOIieYAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wOVQxNjoyMjowMlrOIie6nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzAyMDE2MA==", "bodyText": "IDE says it is not needed anymore", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573020160", "createdAt": "2021-02-09T16:10:39Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/transport/RuleBasedIpFilter.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package org.infinispan.server.core.transport;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.infinispan.server.core.configuration.IpFilterConfiguration;\n+import org.infinispan.server.core.logging.Log;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.ipfilter.IpFilterRule;\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * This class provides the functionality to either accept or reject new {@link Channel}s based on their IP address.\n+ * <p>\n+ * You should inherit from this class if you would like to implement your own IP-based filter. Basically you have to\n+ * implement {@link #accept(ChannelHandlerContext, InetSocketAddress)} to decided whether you want to accept or reject a\n+ * connection from the remote address.\n+ *\n+ * @since 12.1\n+ */\n+@Sharable\n+public class RuleBasedIpFilter extends ChannelInboundHandlerAdapter {\n+   private final IpFilterConfiguration rules;\n+\n+   public RuleBasedIpFilter(IpFilterConfiguration rules) {\n+      this.rules = rules;\n+   }\n+\n+   @Override\n+   public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+      if (evt instanceof ChannelHandoverEvent) {\n+         processRules(ctx);\n+      }\n+   }\n+\n+   protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) throws Exception {\n+      for (IpFilterRule rule : rules.rules()) {\n+         if (rule.matches(remoteAddress)) {\n+            if (rule.ruleType() == IpFilterRuleType.REJECT) {\n+               Log.SECURITY.ipFilterConnectionRejection(remoteAddress, rule);\n+            }\n+            return rule.ruleType() == IpFilterRuleType.ACCEPT;\n+         }\n+      }\n+      return true;\n+   }\n+\n+   @Override\n+   public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+      processRules(ctx);\n+      ctx.fireChannelRegistered();\n+   }\n+\n+   @Override\n+   public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+      if (!processRules(ctx)) {\n+         throw new IllegalStateException(\"cannot determine to accept or reject a channel: \" + ctx.channel());\n+      } else {\n+         ctx.fireChannelActive();\n+      }\n+   }\n+\n+   private boolean processRules(ChannelHandlerContext ctx) throws Exception {\n+      @SuppressWarnings(\"unchecked\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dfc550da0365f1d8ce51d935a1314b8de1a28c3"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzAyMDkwNg==", "bodyText": "nit: move the instance to upper class?", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573020906", "createdAt": "2021-02-09T16:11:33Z", "author": {"login": "pruivo"}, "path": "server/core/src/main/java/org/infinispan/server/core/transport/RuleBasedIpFilter.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package org.infinispan.server.core.transport;\n+\n+import java.net.InetSocketAddress;\n+\n+import org.infinispan.server.core.configuration.IpFilterConfiguration;\n+import org.infinispan.server.core.logging.Log;\n+\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.handler.ipfilter.IpFilterRule;\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * This class provides the functionality to either accept or reject new {@link Channel}s based on their IP address.\n+ * <p>\n+ * You should inherit from this class if you would like to implement your own IP-based filter. Basically you have to\n+ * implement {@link #accept(ChannelHandlerContext, InetSocketAddress)} to decided whether you want to accept or reject a\n+ * connection from the remote address.\n+ *\n+ * @since 12.1\n+ */\n+@Sharable\n+public class RuleBasedIpFilter extends ChannelInboundHandlerAdapter {\n+   private final IpFilterConfiguration rules;\n+\n+   public RuleBasedIpFilter(IpFilterConfiguration rules) {\n+      this.rules = rules;\n+   }\n+\n+   @Override\n+   public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+      if (evt instanceof ChannelHandoverEvent) {\n+         processRules(ctx);\n+      }\n+   }\n+\n+   protected boolean accept(ChannelHandlerContext ctx, InetSocketAddress remoteAddress) throws Exception {\n+      for (IpFilterRule rule : rules.rules()) {\n+         if (rule.matches(remoteAddress)) {\n+            if (rule.ruleType() == IpFilterRuleType.REJECT) {\n+               Log.SECURITY.ipFilterConnectionRejection(remoteAddress, rule);\n+            }\n+            return rule.ruleType() == IpFilterRuleType.ACCEPT;\n+         }\n+      }\n+      return true;\n+   }\n+\n+   @Override\n+   public void channelRegistered(ChannelHandlerContext ctx) throws Exception {\n+      processRules(ctx);\n+      ctx.fireChannelRegistered();\n+   }\n+\n+   @Override\n+   public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+      if (!processRules(ctx)) {\n+         throw new IllegalStateException(\"cannot determine to accept or reject a channel: \" + ctx.channel());\n+      } else {\n+         ctx.fireChannelActive();\n+      }\n+   }\n+\n+   private boolean processRules(ChannelHandlerContext ctx) throws Exception {\n+      @SuppressWarnings(\"unchecked\")\n+      InetSocketAddress remoteAddress = (InetSocketAddress) ctx.channel().remoteAddress();\n+\n+      // If the remote address is not available yet, defer the decision.\n+      if (remoteAddress == null) {\n+         return false;\n+      }\n+\n+      // No need to keep this handler in the pipeline anymore because the decision is going to be made now.\n+      // Also, this will prevent the subsequent events from being handled by this handler.\n+      ctx.pipeline().remove(this);\n+\n+      if (!accept(ctx, remoteAddress)) {\n+         ctx.close();\n+      }\n+\n+      return true;\n+   }\n+\n+   public static class ChannelHandoverEvent {\n+      public static final ChannelHandoverEvent INSTANCE = new ChannelHandoverEvent();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dfc550da0365f1d8ce51d935a1314b8de1a28c3"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzAyNDA2MQ==", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return new SinglePortRouterConfiguration(attributes.protect(), sslConfigurationBuilder.create(), new IpFilterConfiguration(new ArrayList<>()));\n          \n          \n            \n                        return new SinglePortRouterConfiguration(attributes.protect(), sslConfigurationBuilder.create(), new IpFilterConfiguration(Collections.emptyList()));", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573024061", "createdAt": "2021-02-09T16:15:44Z", "author": {"login": "pruivo"}, "path": "server/router/src/main/java/org/infinispan/server/router/configuration/builder/SinglePortRouterBuilder.java", "diffHunk": "@@ -58,7 +55,7 @@ else if (keystorePath != null) {\n             attributes.attribute(ProtocolServerConfiguration.RECV_BUF_SIZE).set(receiveBufferSize);\n             attributes.attribute(ProtocolServerConfiguration.SEND_BUF_SIZE).set(sendBufferSize);\n             attributes.attribute(ProtocolServerConfiguration.WORKER_THREADS).set(1);\n-            return new SinglePortRouterConfiguration(attributes.protect(), sslConfigurationBuilder.create());\n+            return new SinglePortRouterConfiguration(attributes.protect(), sslConfigurationBuilder.create(), new IpFilterConfiguration(new ArrayList<>()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dfc550da0365f1d8ce51d935a1314b8de1a28c3"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzAyODY1MA==", "bodyText": "remove System.out.println()?", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573028650", "createdAt": "2021-02-09T16:21:31Z", "author": {"login": "pruivo"}, "path": "server/tests/src/test/java/org/infinispan/server/functional/ProtocolManagementIT.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package org.infinispan.server.functional;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.io.IOException;\n+import java.net.ConnectException;\n+import java.net.SocketException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+\n+import org.infinispan.client.hotrod.RemoteCacheManager;\n+import org.infinispan.client.hotrod.configuration.ClientIntelligence;\n+import org.infinispan.client.hotrod.configuration.ConfigurationBuilder;\n+import org.infinispan.client.hotrod.exceptions.TransportException;\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.commons.test.Exceptions;\n+import org.infinispan.server.network.NetworkAddress;\n+import org.infinispan.server.test.core.ServerRunMode;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerRuleBuilder;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.1\n+ **/\n+public class ProtocolManagementIT {\n+\n+   @ClassRule\n+   public static InfinispanServerRule SERVERS =\n+         InfinispanServerRuleBuilder.config(\"configuration/MultiEndpointClusteredServerTest.xml\")\n+               .runMode(ServerRunMode.EMBEDDED)\n+               .numServers(2)\n+               .property(\"infinispan.bind.address\", \"0.0.0.0\")\n+               .build();\n+\n+   @Rule\n+   public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+   @Test\n+   public void testIpFilter() throws IOException {\n+      NetworkAddress loopback = NetworkAddress.loopback(\"loopback\");\n+      RestClientConfigurationBuilder loopbackBuilder = new RestClientConfigurationBuilder();\n+      loopbackBuilder.addServer().host(loopback.getAddress().getHostAddress()).port(11222);\n+      RestClient loopbackClient = SERVER_TEST.rest().withClientConfiguration(loopbackBuilder).get();\n+      assertEquals(200, sync(loopbackClient.server().connectorNames()).getStatus());\n+\n+      NetworkAddress siteLocal = NetworkAddress.siteLocal(\"sitelocal\");\n+      RestClientConfigurationBuilder siteLocalBuilder0 = new RestClientConfigurationBuilder();\n+      siteLocalBuilder0.addServer().host(siteLocal.getAddress().getHostAddress()).port(11222);\n+      RestClient siteLocalClient0 = SERVER_TEST.rest().withClientConfiguration(siteLocalBuilder0).get();\n+      assertEquals(200, sync(siteLocalClient0.server().connectorNames()).getStatus());\n+\n+      RestClientConfigurationBuilder siteLocalBuilder1 = new RestClientConfigurationBuilder();\n+      siteLocalBuilder1.addServer().host(siteLocal.getAddress().getHostAddress()).port(11322);\n+      RestClient siteLocalClient1 = SERVER_TEST.rest().withClientConfiguration(siteLocalBuilder1).get();\n+      RestResponse response = sync(siteLocalClient1.server().connectorNames());\n+      System.out.println(response.getBody());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dfc550da0365f1d8ce51d935a1314b8de1a28c3"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MzAyOTAyMw==", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  Exceptions.expectException(TransportException.class, () -> siteLocalRemoteCacheManager.getCacheNames());\n          \n          \n            \n                  Exceptions.expectException(TransportException.class, siteLocalRemoteCacheManager::getCacheNames);", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573029023", "createdAt": "2021-02-09T16:22:02Z", "author": {"login": "pruivo"}, "path": "server/tests/src/test/java/org/infinispan/server/functional/ProtocolManagementIT.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package org.infinispan.server.functional;\n+\n+import static org.infinispan.server.security.Common.sync;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.io.IOException;\n+import java.net.ConnectException;\n+import java.net.SocketException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ExecutionException;\n+\n+import org.infinispan.client.hotrod.RemoteCacheManager;\n+import org.infinispan.client.hotrod.configuration.ClientIntelligence;\n+import org.infinispan.client.hotrod.configuration.ConfigurationBuilder;\n+import org.infinispan.client.hotrod.exceptions.TransportException;\n+import org.infinispan.client.rest.IpFilterRule;\n+import org.infinispan.client.rest.RestClient;\n+import org.infinispan.client.rest.RestResponse;\n+import org.infinispan.client.rest.configuration.RestClientConfigurationBuilder;\n+import org.infinispan.commons.test.Exceptions;\n+import org.infinispan.server.network.NetworkAddress;\n+import org.infinispan.server.test.core.ServerRunMode;\n+import org.infinispan.server.test.junit4.InfinispanServerRule;\n+import org.infinispan.server.test.junit4.InfinispanServerRuleBuilder;\n+import org.infinispan.server.test.junit4.InfinispanServerTestMethodRule;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+\n+/**\n+ * @author Tristan Tarrant &lt;tristan@infinispan.org&gt;\n+ * @since 12.1\n+ **/\n+public class ProtocolManagementIT {\n+\n+   @ClassRule\n+   public static InfinispanServerRule SERVERS =\n+         InfinispanServerRuleBuilder.config(\"configuration/MultiEndpointClusteredServerTest.xml\")\n+               .runMode(ServerRunMode.EMBEDDED)\n+               .numServers(2)\n+               .property(\"infinispan.bind.address\", \"0.0.0.0\")\n+               .build();\n+\n+   @Rule\n+   public InfinispanServerTestMethodRule SERVER_TEST = new InfinispanServerTestMethodRule(SERVERS);\n+\n+   @Test\n+   public void testIpFilter() throws IOException {\n+      NetworkAddress loopback = NetworkAddress.loopback(\"loopback\");\n+      RestClientConfigurationBuilder loopbackBuilder = new RestClientConfigurationBuilder();\n+      loopbackBuilder.addServer().host(loopback.getAddress().getHostAddress()).port(11222);\n+      RestClient loopbackClient = SERVER_TEST.rest().withClientConfiguration(loopbackBuilder).get();\n+      assertEquals(200, sync(loopbackClient.server().connectorNames()).getStatus());\n+\n+      NetworkAddress siteLocal = NetworkAddress.siteLocal(\"sitelocal\");\n+      RestClientConfigurationBuilder siteLocalBuilder0 = new RestClientConfigurationBuilder();\n+      siteLocalBuilder0.addServer().host(siteLocal.getAddress().getHostAddress()).port(11222);\n+      RestClient siteLocalClient0 = SERVER_TEST.rest().withClientConfiguration(siteLocalBuilder0).get();\n+      assertEquals(200, sync(siteLocalClient0.server().connectorNames()).getStatus());\n+\n+      RestClientConfigurationBuilder siteLocalBuilder1 = new RestClientConfigurationBuilder();\n+      siteLocalBuilder1.addServer().host(siteLocal.getAddress().getHostAddress()).port(11322);\n+      RestClient siteLocalClient1 = SERVER_TEST.rest().withClientConfiguration(siteLocalBuilder1).get();\n+      RestResponse response = sync(siteLocalClient1.server().connectorNames());\n+      System.out.println(response.getBody());\n+      assertEquals(200, response.getStatus());\n+\n+      List<IpFilterRule> rules = new ArrayList<>();\n+      rules.add(new IpFilterRule(IpFilterRule.RuleType.REJECT, siteLocal.cidr()));\n+      assertEquals(204, sync(loopbackClient.server().connectorIpFilterSet(\"endpoint-default\", rules)).getStatus());\n+      Exceptions.expectException(RuntimeException.class, ExecutionException.class, SocketException.class, () -> sync(siteLocalClient0.server().connectorNames()));\n+      Exceptions.expectException(RuntimeException.class, ExecutionException.class, SocketException.class, () -> sync(siteLocalClient1.server().connectorNames()));\n+      assertEquals(204, sync(loopbackClient.server().connectorIpFiltersClear(\"endpoint-default\")).getStatus());\n+      assertEquals(200, sync(siteLocalClient0.server().connectorNames()).getStatus());\n+      assertEquals(200, sync(siteLocalClient1.server().connectorNames()).getStatus());\n+\n+      // Apply the filter just on the Hot Rod endpoint\n+      assertEquals(204, sync(loopbackClient.server().connectorIpFilterSet(\"HotRod-hotrod\", rules)).getStatus());\n+      ConfigurationBuilder hotRodSiteLocalBuilder = new ConfigurationBuilder();\n+      hotRodSiteLocalBuilder.addServer().host(siteLocal.getAddress().getHostAddress()).port(11222).clientIntelligence(ClientIntelligence.BASIC);\n+      RemoteCacheManager siteLocalRemoteCacheManager = SERVER_TEST.hotrod().withClientConfiguration(hotRodSiteLocalBuilder).createRemoteCacheManager();\n+      Exceptions.expectException(TransportException.class, () -> siteLocalRemoteCacheManager.getCacheNames());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dfc550da0365f1d8ce51d935a1314b8de1a28c3"}, "originalPosition": 84}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4dfc550da0365f1d8ce51d935a1314b8de1a28c3", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/4dfc550da0365f1d8ce51d935a1314b8de1a28c3", "committedDate": "2021-02-09T12:20:25Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "d42cf755eab86314647f0718e0a8a04d2f2f72a4", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/d42cf755eab86314647f0718e0a8a04d2f2f72a4", "committedDate": "2021-02-10T14:25:54Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d42cf755eab86314647f0718e0a8a04d2f2f72a4", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/d42cf755eab86314647f0718e0a8a04d2f2f72a4", "committedDate": "2021-02-10T14:25:54Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c", "committedDate": "2021-02-10T14:32:32Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg3OTMzNTMx", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-587933531", "createdAt": "2021-02-10T18:42:59Z", "commit": {"oid": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQxODo0MzowMFrOIjZDCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQxOTowNzoyOFrOIjaKQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk4MTQ0OA==", "bodyText": "I guess  This operation can only be performed on connectors which are directly bound to a socket. is no longer valid, right?", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573981448", "createdAt": "2021-02-10T18:43:00Z", "author": {"login": "pruivo"}, "path": "cli/src/main/resources/help/server.adoc", "diffHunk": "@@ -0,0 +1,71 @@\n+SERVER(1)\n+=========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+server - server configuration and state management.\n+\n+\n+DESCRIPTION\n+-----------\n+The *server* command describes and manages server endpoint connectors and retrieves aggregated diagnostic reports about both the server and host.\n+\n+Reports provide details about CPU, memory, open files, network sockets and routing, threads, in addition to configuration and log files.\n+\n+\n+SYNOPSIS\n+--------\n+*server report*\n+\n+*server connector ls*\n+\n+*server connector describe* 'connector-name'\n+\n+*server connector start* 'connector-name'\n+\n+*server connector stop* 'connector-name'\n+\n+*server connector ipfilter ls* 'connector-name'\n+\n+*server connector ipfilter set* 'connector-name' --rules='[ACCEPT|REJECT]/cidr',...\n+\n+*server connector ipfilter clear* 'connector-name'\n+\n+\n+SERVER CONNECTOR IPFILTER OPTIONS\n+---------------------------------\n+\n+*--rules*='[ACCEPT|REJECT]/cidr',...::\n+One or more IP filtering rules.\n+\n+\n+EXAMPLES\n+--------\n+\n+`server report` +\n+Obtains a server report, including information about network, threads, memory, etc.\n+\n+`server connector ls` +\n+Lists all available connectors on the server.\n+\n+`server connector describe endpoint-default` +\n+Shows information about the specified connector, including host, port, local and global connections, IP filtering rules.\n+\n+`server connector stop my-hotrod-connector` +\n+Stops a connector dropping all established connections across the cluster. This operation can only be performed on connectors which are directly bound to a socket.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk4MTY0MQ==", "bodyText": "same for start example below.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573981641", "createdAt": "2021-02-10T18:43:18Z", "author": {"login": "pruivo"}, "path": "cli/src/main/resources/help/server.adoc", "diffHunk": "@@ -0,0 +1,71 @@\n+SERVER(1)\n+=========\n+:doctype: manpage\n+\n+\n+NAME\n+----\n+server - server configuration and state management.\n+\n+\n+DESCRIPTION\n+-----------\n+The *server* command describes and manages server endpoint connectors and retrieves aggregated diagnostic reports about both the server and host.\n+\n+Reports provide details about CPU, memory, open files, network sockets and routing, threads, in addition to configuration and log files.\n+\n+\n+SYNOPSIS\n+--------\n+*server report*\n+\n+*server connector ls*\n+\n+*server connector describe* 'connector-name'\n+\n+*server connector start* 'connector-name'\n+\n+*server connector stop* 'connector-name'\n+\n+*server connector ipfilter ls* 'connector-name'\n+\n+*server connector ipfilter set* 'connector-name' --rules='[ACCEPT|REJECT]/cidr',...\n+\n+*server connector ipfilter clear* 'connector-name'\n+\n+\n+SERVER CONNECTOR IPFILTER OPTIONS\n+---------------------------------\n+\n+*--rules*='[ACCEPT|REJECT]/cidr',...::\n+One or more IP filtering rules.\n+\n+\n+EXAMPLES\n+--------\n+\n+`server report` +\n+Obtains a server report, including information about network, threads, memory, etc.\n+\n+`server connector ls` +\n+Lists all available connectors on the server.\n+\n+`server connector describe endpoint-default` +\n+Shows information about the specified connector, including host, port, local and global connections, IP filtering rules.\n+\n+`server connector stop my-hotrod-connector` +\n+Stops a connector dropping all established connections across the cluster. This operation can only be performed on connectors which are directly bound to a socket.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk4MTQ0OA=="}, "originalCommit": {"oid": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk4NjEwMQ==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  pipeline.addLast(new AccessControlFilter(restServerConfiguration, false));\n          \n          \n            \n                  pipeline.addLast(new AccessControlFilter<>(restServerConfiguration, false));", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573986101", "createdAt": "2021-02-10T18:48:13Z", "author": {"login": "pruivo"}, "path": "server/rest/src/main/java/org/infinispan/rest/ALPNHandler.java", "diffHunk": "@@ -78,9 +80,12 @@ public void configurePipeline(ChannelPipeline pipeline, String protocol) {\n    /**\n     * Configure the handlers that should be used for both HTTP 1.1 and HTTP 2.0\n     */\n-   private void addCommonsHandlers(ChannelPipeline pipeline) {\n+   private void addCommonHandlers(ChannelPipeline pipeline) {\n+      // Handles IP filtering for the HTTP connector\n+      RestServerConfiguration restServerConfiguration = restServer.getConfiguration();\n+      pipeline.addLast(new AccessControlFilter(restServerConfiguration, false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk4OTA0Ng==", "bodyText": "nit: remove extra line", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573989046", "createdAt": "2021-02-10T18:52:07Z", "author": {"login": "pruivo"}, "path": "server/rest/src/main/java/org/infinispan/rest/NettyRestRequest.java", "diffHunk": "@@ -44,10 +45,12 @@\n    private final String path;\n    private final ContentSource contentSource;\n    private final String context;\n+   private final InetSocketAddress remoteAddress;\n    private String action;\n    private Subject subject;\n    private Map<String, String> variables;\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk5MDM0OQ==", "bodyText": "offtopic:\nthere is a bug in setSubject() method. It should be this.subject = principal", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573990349", "createdAt": "2021-02-10T18:54:09Z", "author": {"login": "pruivo"}, "path": "server/rest/src/main/java/org/infinispan/rest/framework/impl/SimpleRequest.java", "diffHunk": "@@ -1,5 +1,6 @@\n package org.infinispan.rest.framework.impl;\n \n+import java.net.InetSocketAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk5NTQzOA==", "bodyText": "suggestion: add the rule to the message?", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573995438", "createdAt": "2021-02-10T19:00:58Z", "author": {"login": "pruivo"}, "path": "server/rest/src/main/java/org/infinispan/rest/resources/ServerResource.java", "diffHunk": "@@ -91,15 +109,142 @@ public Invocations getInvocations() {\n       DefaultCacheManager cacheManager = invocationHelper.getServer().getCacheManager(cacheManagerName);\n \n       if (cacheManager == null) return notFoundResponseFuture();\n-      CacheIgnoreManager ignoreManager = invocationHelper.getServer().getIgnoreManager(cacheManagerName);\n-      Set<String> ignored = ignoreManager.getIgnoredCaches();\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager();\n+      Set<String> ignored = serverStateManager.getIgnoredCaches();\n       return asJsonResponseFuture(Json.make(ignored));\n    }\n \n    private CompletionStage<RestResponse> cacheManagers(RestRequest restRequest) {\n       return asJsonResponseFuture(Json.make(invocationHelper.getServer().cacheManagerNames()));\n    }\n \n+   private CompletionStage<RestResponse> connectorStartStop(RestRequest restRequest) {\n+      SecurityActions.checkPermission(invocationHelper, restRequest, AuthorizationPermission.ADMIN);\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder().status(NO_CONTENT);\n+      String connectorName = restRequest.variables().get(\"connector\");\n+      ProtocolServer connector = invocationHelper.getServer().getProtocolServers().get(connectorName);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager();\n+      switch (restRequest.getAction()) {\n+         case \"start\":\n+            return serverStateManager.connectorStart(connectorName).thenApply(r -> builder.build());\n+         case \"stop\":\n+            if (connector.equals(invocationHelper.getProtocolServer()) || connector.equals(invocationHelper.getProtocolServer().getEnclosingProtocolServer())) {\n+               return completedFuture(builder.status(CONFLICT).entity(\"Connector matches request address\").build());\n+            } else {\n+               return serverStateManager.connectorStop(connectorName).thenApply(r -> builder.build());\n+            }\n+      }\n+      return completedFuture(builder.status(BAD_REQUEST).build());\n+   }\n+\n+   private CompletionStage<RestResponse> connectorStatus(RestRequest restRequest) {\n+      SecurityActions.checkPermission(invocationHelper, restRequest, AuthorizationPermission.ADMIN);\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+      String connectorName = restRequest.variables().get(\"connector\");\n+\n+      ProtocolServer connector = getProtocolServer(restRequest);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager();\n+\n+      Json info = Json.object()\n+            .set(\"name\", connectorName)\n+            .set(\"enabled\", connector.getConfiguration().isEnabled())\n+            .set(\"ip-filter-rules\", ipFilterRulesAsJson(connector));\n+      Transport transport = connector.getTransport();\n+      if (transport != null) {\n+         info.set(\"host\", transport.getHostName())\n+               .set(\"port\", transport.getPort())\n+               .set(\"local-connections\", transport.getNumberOfLocalConnections())\n+               .set(\"global-connections\", transport.getNumberOfGlobalConnections())\n+               .set(\"io-threads\", transport.getNumberIOThreads())\n+               .set(\"pending-tasks\", transport.getPendingTasks())\n+               .set(\"total-bytes-read\", transport.getTotalBytesRead())\n+               .set(\"total-bytes-written\", transport.getTotalBytesWritten())\n+               .set(\"send-buffer-size\", transport.getSendBufferSize())\n+               .set(\"receive-buffer-size\", transport.getReceiveBufferSize());\n+         return serverStateManager.connectorStatus(connectorName).thenApply(b -> builder.contentType(APPLICATION_JSON).entity(info.set(\"enabled\", b)).build());\n+      } else {\n+         return completedFuture(builder.contentType(APPLICATION_JSON).entity(info).build());\n+      }\n+   }\n+\n+   private CompletionStage<RestResponse> connectorIpFilterList(RestRequest restRequest) {\n+      SecurityActions.checkPermission(invocationHelper, restRequest, AuthorizationPermission.ADMIN);\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder();\n+\n+      ProtocolServer connector = getProtocolServer(restRequest);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+\n+      return completedFuture(addEntityAsJson(ipFilterRulesAsJson(connector), builder).build());\n+   }\n+\n+   private Json ipFilterRulesAsJson(ProtocolServer connector) {\n+      Collection<IpSubnetFilterRule> rules = connector.getConfiguration().ipFilter().rules();\n+      Json array = Json.array();\n+      for (IpSubnetFilterRule rule : rules) {\n+         array.add(Json.object().set(\"type\", rule.ruleType().name().toLowerCase()).set(\"from\", rule.cidr()));\n+      }\n+      return array;\n+   }\n+\n+   private ProtocolServer getProtocolServer(RestRequest restRequest) {\n+      String connectorName = restRequest.variables().get(\"connector\");\n+      return invocationHelper.getServer().getProtocolServers().get(connectorName);\n+   }\n+\n+   private CompletionStage<RestResponse> connectorIpFilterClear(RestRequest restRequest) {\n+      SecurityActions.checkPermission(invocationHelper, restRequest, AuthorizationPermission.ADMIN);\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder().status(NO_CONTENT);\n+\n+      String connectorName = restRequest.variables().get(\"connector\");\n+      ProtocolServer connector = invocationHelper.getServer().getProtocolServers().get(connectorName);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+\n+      ServerStateManager serverStateManager = invocationHelper.getServer().getServerStateManager();\n+      return serverStateManager.clearConnectorIpFilterRules(connectorName).thenApply(r -> builder.build());\n+   }\n+\n+   private CompletionStage<RestResponse> listConnectors(RestRequest restRequest) {\n+      SecurityActions.checkPermission(invocationHelper, restRequest, AuthorizationPermission.ADMIN);\n+      return asJsonResponseFuture(Json.make(invocationHelper.getServer().getProtocolServers().keySet()));\n+   }\n+\n+   private CompletionStage<RestResponse> connectorIpFilterSet(RestRequest restRequest) {\n+      SecurityActions.checkPermission(invocationHelper, restRequest, AuthorizationPermission.ADMIN);\n+      NettyRestResponse.Builder builder = new NettyRestResponse.Builder().status(NO_CONTENT);\n+\n+      String connectorName = restRequest.variables().get(\"connector\");\n+      ProtocolServer connector = invocationHelper.getServer().getProtocolServers().get(connectorName);\n+      if (connector == null) return completedFuture(builder.status(NOT_FOUND).build());\n+\n+      Json json = Json.read(restRequest.contents().asString());\n+      if (!json.isArray()) {\n+         return completedFuture(builder.status(BAD_REQUEST).build());\n+      }\n+      List<Json> list = json.asJsonList();\n+      List<IpSubnetFilterRule> rules = new ArrayList<>(list.size());\n+      for (Json o : list) {\n+         if (!o.has(\"type\") || !o.has(\"cidr\")) {\n+            return completedFuture(builder.status(BAD_REQUEST).build());\n+         } else {\n+            rules.add(new IpSubnetFilterRule(o.at(\"cidr\").asString(), IpFilterRuleType.valueOf(o.at(\"type\").asString())));\n+         }\n+      }\n+      // Verify that none of the REJECT rules match the address from which the request was made\n+      if (connector.equals(invocationHelper.getProtocolServer()) || connector.equals(invocationHelper.getProtocolServer().getEnclosingProtocolServer())) {\n+         for (IpSubnetFilterRule rule : rules) {\n+            if (rule.ruleType() == IpFilterRuleType.REJECT && rule.matches(restRequest.getRemoteAddress())) {\n+               return completedFuture(builder.status(CONFLICT).entity(\"Reject rule matches request address\").build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk5NzE2Mw==", "bodyText": "IDE reports this is not used. and it should be used :)", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573997163", "createdAt": "2021-02-10T19:03:37Z", "author": {"login": "pruivo"}, "path": "server/runtime/src/main/java/org/infinispan/server/logging/Log.java", "diffHunk": "@@ -200,4 +202,23 @@\n \n    @Message(value = \"Encryption cannot be configured without a security realm\", id = 80053)\n    CacheConfigurationException encryptionWithoutSecurityRealm();\n+\n+   @LogMessage(level = Logger.Level.INFO)\n+   @Message(value = \"Connector '%s': IP Filter cleared\", id = 80054)\n+   void connectorIpFilterCleared(String connector);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk5NzI3NQ==", "bodyText": "can be removed now :)", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573997275", "createdAt": "2021-02-10T19:03:47Z", "author": {"login": "pruivo"}, "path": "server/runtime/src/main/java/org/infinispan/server/logging/Log.java", "diffHunk": "@@ -200,4 +202,23 @@\n \n    @Message(value = \"Encryption cannot be configured without a security realm\", id = 80053)\n    CacheConfigurationException encryptionWithoutSecurityRealm();\n+\n+   @LogMessage(level = Logger.Level.INFO)\n+   @Message(value = \"Connector '%s': IP Filter cleared\", id = 80054)\n+   void connectorIpFilterCleared(String connector);\n+\n+   @LogMessage(level = Logger.Level.INFO)\n+   @Message(value = \"Connector '%s': IP Filter set: %s\", id = 80055)\n+   void connectorIpFilterSet(String connector, List<IpSubnetFilterRule> rules);\n+\n+   @Message(value = \"Connector '%s' cannot be configured since it has no transport\", id = 80056)\n+   IllegalArgumentException noConnectorTransport(String connector);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Mzk5OTY4Mg==", "bodyText": "can be simplified for the case where rules.isEmpty(): (I think)\n\nset an empty list protocolServer.getConfiguration().ipFilter().rules(Collections.emptyList());\nlog it: log.connectorIpFilterCleared()", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r573999682", "createdAt": "2021-02-10T19:07:28Z", "author": {"login": "pruivo"}, "path": "server/runtime/src/main/java/org/infinispan/server/state/ServerStateManagerImpl.java", "diffHunk": "@@ -0,0 +1,290 @@\n+package org.infinispan.server.state;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.globalstate.GlobalConfigurationManager;\n+import org.infinispan.globalstate.ScopeFilter;\n+import org.infinispan.globalstate.ScopedState;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryCreatedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryModifiedEvent;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryRemovedEvent;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.security.AuthorizationPermission;\n+import org.infinispan.server.Server;\n+import org.infinispan.server.core.ProtocolServer;\n+import org.infinispan.server.core.ServerStateManager;\n+import org.infinispan.server.core.transport.CompositeChannelMatcher;\n+import org.infinispan.server.core.transport.IpFilterRuleChannelMatcher;\n+import org.infinispan.server.core.transport.IpSubnetFilterRule;\n+import org.infinispan.server.core.transport.Transport;\n+\n+import io.netty.handler.ipfilter.IpFilterRuleType;\n+\n+/**\n+ * Manages cluster-wide server state for a given {@link EmbeddedCacheManager}. This handles:\n+ * <ul>\n+ * <li>ignored caches</li>\n+ * <li>protocol servers</li>\n+ * <li>ip filters</li>\n+ * </ul>\n+ *\n+ * @since 12.1\n+ */\n+public final class ServerStateManagerImpl implements ServerStateManager {\n+   private static final String CONNECTOR_STATE_SCOPE = \"connector-state\";\n+   private static final String CONNECTOR_IPFILTER_SCOPE = \"connector-ipfilter\";\n+   private static final ScopedState IGNORED_CACHES_KEY = new ScopedState(\"ignored-caches\", \"ignored-caches\");\n+\n+   private final EmbeddedCacheManager cacheManager;\n+   private final Server server;\n+   private final Cache<ScopedState, Object> cache;\n+   private final IgnoredCaches ignored = new IgnoredCaches();\n+   private volatile boolean hasIgnores;\n+\n+   public ServerStateManagerImpl(Server server, EmbeddedCacheManager cacheManager, GlobalConfigurationManager configurationManager) {\n+      this.server = server;\n+      this.cacheManager = cacheManager;\n+      this.cache = configurationManager.getStateCache();\n+\n+      updateLocalIgnoredCaches((IgnoredCaches) cache.get(IGNORED_CACHES_KEY));\n+\n+      // Register the listeners which will react on\n+      cache.addListener(new IgnoredCachesListener(), new ScopeFilter(IGNORED_CACHES_KEY.getScope()), null);\n+      cache.addListener(new ConnectorStateListener(), new ScopeFilter(CONNECTOR_STATE_SCOPE), null);\n+      cache.addListener(new ConnectorIpFilterListener(), new ScopeFilter(CONNECTOR_IPFILTER_SCOPE), null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> unignoreCache(String cacheName) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      synchronized (this) {\n+         ignored.caches.remove(cacheName);\n+         hasIgnores = !ignored.caches.isEmpty();\n+         return cache.putAsync(IGNORED_CACHES_KEY, ignored).thenApply(r -> null);\n+      }\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> ignoreCache(String cacheName) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      synchronized (this) {\n+         ignored.caches.add(cacheName);\n+         hasIgnores = !ignored.caches.isEmpty();\n+         return cache.putAsync(IGNORED_CACHES_KEY, ignored).thenApply(r -> null);\n+      }\n+   }\n+\n+   @Override\n+   public Set<String> getIgnoredCaches() {\n+      return Collections.unmodifiableSet(ignored.caches);\n+   }\n+\n+   @Override\n+   public boolean isCacheIgnored(String cacheName) {\n+      return hasIgnores && ignored.caches.contains(cacheName);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Boolean> connectorStart(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.removeAsync(new ScopedState(CONNECTOR_STATE_SCOPE, name), true).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> connectorStop(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.putAsync(new ScopedState(CONNECTOR_STATE_SCOPE, name), true).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Boolean> connectorStatus(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return CompletableFuture.completedFuture(server.getProtocolServers().get(name).getTransport().isRunning());\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> setConnectorIpFilterRule(String name, Collection<IpSubnetFilterRule> filterRule) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      IpFilterRules ipFilterRules = new IpFilterRules();\n+      filterRule.forEach(r -> ipFilterRules.rules.add(new IpFilterRule(r)));\n+      return cache.putAsync(new ScopedState(CONNECTOR_IPFILTER_SCOPE, name), ipFilterRules).thenApply(v -> null);\n+   }\n+\n+   @Override\n+   public CompletableFuture<Void> clearConnectorIpFilterRules(String name) {\n+      SecurityActions.checkPermission(cacheManager, AuthorizationPermission.ADMIN);\n+      return cache.putAsync(new ScopedState(CONNECTOR_IPFILTER_SCOPE, name), new IpFilterRules()).thenApply(v -> null);\n+   }\n+\n+   private void updateLocalIgnoredCaches(IgnoredCaches ignored) {\n+      if (ignored != null) {\n+         synchronized (this) {\n+            this.ignored.caches.clear();\n+            this.ignored.caches.addAll(ignored.caches);\n+            hasIgnores = !this.ignored.caches.isEmpty();\n+         }\n+      }\n+   }\n+\n+   private CompletionStage<Void> updateIpFilters(String connector, Collection<IpFilterRule> rules) {\n+      ProtocolServer protocolServer = server.getProtocolServers().get(connector);\n+      List<IpSubnetFilterRule> localRules = new ArrayList<>(rules.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c"}, "originalPosition": 151}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg3OTgzNzMx", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-587983731", "createdAt": "2021-02-10T19:42:07Z", "commit": {"oid": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQxOTo0MjowN1rOIjbjzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMFQxOTo0MjowN1rOIjbjzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NDAyMjYwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return context.getConnection().getConnectorNames();\n          \n          \n            \n                  try {\n          \n          \n            \n                     return context.getConnection().getConnectorNames();\n          \n          \n            \n                  } catch (Exception e) {\n          \n          \n            \n                     return Collections.emptyList();\n          \n          \n            \n                  }\n          \n      \n    \n    \n  \n\nI would put a try-catch block to avoid adding the exception stack trace to the console. Example:\n[pedro-laptop-3-52395@cluster//containers/default]> server connector ipfilter ls java.nio.file.AccessDeniedException: The user is not allowed to access the server resource: ISPN000287: Unauthorized access: subject 'Subject with principal(s): [pedro, RolePrincipal{name='reader'}]' lacks 'ADMIN' permission\n\tat org.infinispan.cli.connection.rest.RestConnection.handleResponseStatus(RestConnection.java:163)\n\tat org.infinispan.cli.connection.rest.RestConnection.parseBody(RestConnection.java:129)\n\tat org.infinispan.cli.connection.rest.RestConnection.getConnectorNames(RestConnection.java:372)", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r574022607", "createdAt": "2021-02-10T19:42:07Z", "author": {"login": "pruivo"}, "path": "cli/src/main/java/org/infinispan/cli/completers/ConnectorCompleter.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package org.infinispan.cli.completers;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+\n+import org.infinispan.cli.Context;\n+\n+/**\n+ * A {@link org.aesh.command.completer.OptionCompleter} for protocol connectors.\n+ *\n+ * @author Tristan Tarrant\n+ * @since 12.1\n+ */\n+public class ConnectorCompleter extends ListCompleter {\n+   @Override\n+   Collection<String> getAvailableItems(Context context) throws IOException {\n+      return context.getConnection().getConnectorNames();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c"}, "originalPosition": 17}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/49a444df9b3fedfe68d7fb2a6ac6a7265aab8c5c", "committedDate": "2021-02-10T14:32:32Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "1792819261e25201c5643ad25e720b9eb30e8c92", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/1792819261e25201c5643ad25e720b9eb30e8c92", "committedDate": "2021-02-11T09:56:07Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg5MzE4NDI3", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-589318427", "createdAt": "2021-02-12T10:02:55Z", "commit": {"oid": "1792819261e25201c5643ad25e720b9eb30e8c92"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMlQxMDowMjo1NVrOIkd8oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xMlQxMDowMjo1NVrOIkd8oA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTExMDMwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Informational Scripting messages. These start from 12500 so as not to overlap with the logging\n          \n          \n            \n             * Informational Rest Server messages. These start from 12500 so as not to overlap with the logging\n          \n      \n    \n    \n  \n\nis there a document with the Message's ids? Some Messages classes have ids, other don't, others have messages with and without id (org.infinispan.util.logging.events.Messages).", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r575110304", "createdAt": "2021-02-12T10:02:55Z", "author": {"login": "pruivo"}, "path": "server/rest/src/main/java/org/infinispan/rest/logging/Messages.java", "diffHunk": "@@ -0,0 +1,22 @@\n+package org.infinispan.rest.logging;\n+\n+import org.jboss.logging.annotations.Message;\n+import org.jboss.logging.annotations.MessageBundle;\n+\n+/**\n+ * Informational Scripting messages. These start from 12500 so as not to overlap with the logging", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1792819261e25201c5643ad25e720b9eb30e8c92"}, "originalPosition": 7}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1792819261e25201c5643ad25e720b9eb30e8c92", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/1792819261e25201c5643ad25e720b9eb30e8c92", "committedDate": "2021-02-11T09:56:07Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "6a3a1ce90502eaa9eb3b3d82e47a299185cf823e", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/6a3a1ce90502eaa9eb3b3d82e47a299185cf823e", "committedDate": "2021-02-17T15:32:56Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6a3a1ce90502eaa9eb3b3d82e47a299185cf823e", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/6a3a1ce90502eaa9eb3b3d82e47a299185cf823e", "committedDate": "2021-02-17T15:32:56Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "cbf47b3e1b397499eb681ca2cda993ea1323bdd8", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/cbf47b3e1b397499eb681ca2cda993ea1323bdd8", "committedDate": "2021-02-18T09:02:25Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cbf47b3e1b397499eb681ca2cda993ea1323bdd8", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/cbf47b3e1b397499eb681ca2cda993ea1323bdd8", "committedDate": "2021-02-18T09:02:25Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "c79ab8be652337c56ac75950b820f86ba2b6c375", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/c79ab8be652337c56ac75950b820f86ba2b6c375", "committedDate": "2021-02-19T07:48:52Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c79ab8be652337c56ac75950b820f86ba2b6c375", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/c79ab8be652337c56ac75950b820f86ba2b6c375", "committedDate": "2021-02-19T07:48:52Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "9e658a0482276de09b9e553e714b5f0aede3b151", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/9e658a0482276de09b9e553e714b5f0aede3b151", "committedDate": "2021-02-19T09:49:24Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0MDQ1NDQ5", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-594045449", "createdAt": "2021-02-19T10:14:24Z", "commit": {"oid": "9e658a0482276de09b9e553e714b5f0aede3b151"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9e658a0482276de09b9e553e714b5f0aede3b151", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/9e658a0482276de09b9e553e714b5f0aede3b151", "committedDate": "2021-02-19T09:49:24Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "12867910bf5bcbbc88e33f4c08bf6c8f17e1b264", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/12867910bf5bcbbc88e33f4c08bf6c8f17e1b264", "committedDate": "2021-02-22T07:23:22Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "12867910bf5bcbbc88e33f4c08bf6c8f17e1b264", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/12867910bf5bcbbc88e33f4c08bf6c8f17e1b264", "committedDate": "2021-02-22T07:23:22Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "678b19cfdbfc8c55c9163081ac11d7bff682d061", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/678b19cfdbfc8c55c9163081ac11d7bff682d061", "committedDate": "2021-02-22T20:47:32Z", "message": "fixup! WIP"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cbd6ae2834cae741aedc24d4fd4fab5107713a5c", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/cbd6ae2834cae741aedc24d4fd4fab5107713a5c", "committedDate": "2021-02-23T10:13:49Z", "message": "WIP"}, "afterCommit": {"oid": "2bed264624caaef64695aecc9a85e0b94128616b", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/2bed264624caaef64695aecc9a85e0b94128616b", "committedDate": "2021-02-23T12:39:12Z", "message": "fixup! WIP"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "380adb566d0b43bc05c8986603e8b6860da3dbb4", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/380adb566d0b43bc05c8986603e8b6860da3dbb4", "committedDate": "2021-02-24T07:51:47Z", "message": "fixup! WIP"}, "afterCommit": {"oid": "1880e0fd956aa084a6f7276720d6c0d5f75caaa6", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/1880e0fd956aa084a6f7276720d6c0d5f75caaa6", "committedDate": "2021-02-24T09:35:28Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1880e0fd956aa084a6f7276720d6c0d5f75caaa6", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/1880e0fd956aa084a6f7276720d6c0d5f75caaa6", "committedDate": "2021-02-24T09:35:28Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "ee1e8eda3c10d22805958d703255ec117a406b32", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/ee1e8eda3c10d22805958d703255ec117a406b32", "committedDate": "2021-02-24T09:46:54Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk3Mjk5MzM0", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-597299334", "createdAt": "2021-02-24T10:00:16Z", "commit": {"oid": "ee1e8eda3c10d22805958d703255ec117a406b32"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNFQxMDowMDoxN1rOIq3fSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNFQxMDo0Mjo1N1rOIq5X6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTgyMDIzNA==", "bodyText": "findAddress() may return null.\nyou may want to throw new IOException(\"No matching addresses found\"); if that is the case.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r581820234", "createdAt": "2021-02-24T10:00:17Z", "author": {"login": "pruivo"}, "path": "server/runtime/src/main/java/org/infinispan/server/network/NetworkAddress.java", "diffHunk": "@@ -97,6 +131,11 @@ public static NetworkAddress matchHost(String name, String regex) throws IOExcep\n       return new NetworkAddress(name, findAddress(a -> a.getHostName().matches(regex)));\n    }\n \n+   public static NetworkAddress match(String name, Predicate<NetworkInterface> ifMatcher, Predicate<InetAddress> addressMatcher) throws IOException {\n+      NetworkInterface networkInterface = findInterface(ifMatcher);\n+      return new NetworkAddress(name, findAddress(networkInterface, addressMatcher));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee1e8eda3c10d22805958d703255ec117a406b32"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTg0Nzk5Mw==", "bodyText": "report() test is missing.", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r581847993", "createdAt": "2021-02-24T10:38:34Z", "author": {"login": "pruivo"}, "path": "server/tests/src/test/java/org/infinispan/server/security/authorization/AbstractAuthorization.java", "diffHunk": "@@ -263,29 +264,50 @@ public void testRestNonAdminsMustNotModifyLoggers() {\n    }\n \n    @Test\n-   public void testRestNonAdminsMustNotObtainReport() {\n+   public void testRestAdminsShoudleBeAbleToAdminServer() {\n+      RestClientConfigurationBuilder adminConfig = restBuilders.get(\"admin\");\n+      assertEquals(204, sync(getServerTest().rest().withClientConfiguration(adminConfig).get().server().connectorStop(\"endpoint-alternate-1\")).getStatus());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee1e8eda3c10d22805958d703255ec117a406b32"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTg1MDExMg==", "bodyText": "nit, all this asserts could be in the single method:\nprivate void checkAdminServer(int status, String user) {\n  RestClientConfigurationBuilder adminConfig = restBuilders.get(user);\n  assertEquals(status, ....);\n  ... \n}", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r581850112", "createdAt": "2021-02-24T10:41:24Z", "author": {"login": "pruivo"}, "path": "server/tests/src/test/java/org/infinispan/server/security/authorization/AbstractAuthorization.java", "diffHunk": "@@ -263,29 +264,50 @@ public void testRestNonAdminsMustNotModifyLoggers() {\n    }\n \n    @Test\n-   public void testRestNonAdminsMustNotObtainReport() {\n+   public void testRestAdminsShoudleBeAbleToAdminServer() {\n+      RestClientConfigurationBuilder adminConfig = restBuilders.get(\"admin\");\n+      assertEquals(204, sync(getServerTest().rest().withClientConfiguration(adminConfig).get().server().connectorStop(\"endpoint-alternate-1\")).getStatus());\n+      assertEquals(204, sync(getServerTest().rest().withClientConfiguration(adminConfig).get().server().connectorStart(\"endpoint-alternate-1\")).getStatus());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee1e8eda3c10d22805958d703255ec117a406b32"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTg1MTExNA==", "bodyText": "ps. maybe ^ can be done in another PR. the ignore cache tests aren't checking if the admin can do the task or not (same for xsite as reported by Katia).\nps2. org.infinispan.server.test.core.Common#assertStatus() could be used instead of asserEquals()  :)", "url": "https://github.com/infinispan/infinispan/pull/8938#discussion_r581851114", "createdAt": "2021-02-24T10:42:57Z", "author": {"login": "pruivo"}, "path": "server/tests/src/test/java/org/infinispan/server/security/authorization/AbstractAuthorization.java", "diffHunk": "@@ -263,29 +264,50 @@ public void testRestNonAdminsMustNotModifyLoggers() {\n    }\n \n    @Test\n-   public void testRestNonAdminsMustNotObtainReport() {\n+   public void testRestAdminsShoudleBeAbleToAdminServer() {\n+      RestClientConfigurationBuilder adminConfig = restBuilders.get(\"admin\");\n+      assertEquals(204, sync(getServerTest().rest().withClientConfiguration(adminConfig).get().server().connectorStop(\"endpoint-alternate-1\")).getStatus());\n+      assertEquals(204, sync(getServerTest().rest().withClientConfiguration(adminConfig).get().server().connectorStart(\"endpoint-alternate-1\")).getStatus());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MTg1MDExMg=="}, "originalCommit": {"oid": "ee1e8eda3c10d22805958d703255ec117a406b32"}, "originalPosition": 22}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ee1e8eda3c10d22805958d703255ec117a406b32", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/ee1e8eda3c10d22805958d703255ec117a406b32", "committedDate": "2021-02-24T09:46:54Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "d4e8175b31c1eb8154816a6ea9199f5895e52c73", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/d4e8175b31c1eb8154816a6ea9199f5895e52c73", "committedDate": "2021-02-24T12:54:20Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3315c371e4024f51b1b14992009505cb99fb700a", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/3315c371e4024f51b1b14992009505cb99fb700a", "committedDate": "2021-02-24T14:09:41Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d4e8175b31c1eb8154816a6ea9199f5895e52c73", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/d4e8175b31c1eb8154816a6ea9199f5895e52c73", "committedDate": "2021-02-24T12:54:20Z", "message": "ISPN-12261 Protocol Management"}, "afterCommit": {"oid": "3315c371e4024f51b1b14992009505cb99fb700a", "author": {"user": {"login": "tristantarrant", "name": "Tristan Tarrant"}}, "url": "https://github.com/infinispan/infinispan/commit/3315c371e4024f51b1b14992009505cb99fb700a", "committedDate": "2021-02-24T14:09:41Z", "message": "ISPN-12261 Protocol Management"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk3NjQ5NDM4", "url": "https://github.com/infinispan/infinispan/pull/8938#pullrequestreview-597649438", "createdAt": "2021-02-24T16:05:12Z", "commit": {"oid": "3315c371e4024f51b1b14992009505cb99fb700a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 240, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}