{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxMzA2ODM3", "number": 8940, "title": "ISPN-11398 Change XSiteStateTransferProviderImpl to be non blocking", "bodyText": "https://issues.redhat.com/browse/ISPN-11398\nDepends on #8935", "createdAt": "2020-12-16T16:56:44Z", "url": "https://github.com/infinispan/infinispan/pull/8940", "merged": true, "mergeCommit": {"oid": "fb9758d35d17ccf83172baa5708a8bb8aa0a66e7"}, "closed": true, "closedAt": "2021-01-20T04:35:46Z", "author": {"login": "pruivo"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdmyIXggBqjQxMjA4MzgyMzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdvdOz5AFqTU2NjQxNzA5NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bcb39ea43a30a29266898daec91622c93f98eda3", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/bcb39ea43a30a29266898daec91622c93f98eda3", "committedDate": "2020-12-16T16:55:37Z", "message": "ISPN-11398 Change XSiteStateTransferProviderImpl to be non blocking"}, "afterCommit": {"oid": "18bb9f284c6f7350114d13a631ee81ae2511ad86", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/18bb9f284c6f7350114d13a631ee81ae2511ad86", "committedDate": "2020-12-16T17:10:35Z", "message": "ISPN-11398 Change XSiteStateTransferProviderImpl to be non blocking"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "18bb9f284c6f7350114d13a631ee81ae2511ad86", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/18bb9f284c6f7350114d13a631ee81ae2511ad86", "committedDate": "2020-12-16T17:10:35Z", "message": "ISPN-11398 Change XSiteStateTransferProviderImpl to be non blocking"}, "afterCommit": {"oid": "6da3f34ce5317e73d6cd48365b37c85ad0e4d899", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/6da3f34ce5317e73d6cd48365b37c85ad0e4d899", "committedDate": "2021-01-06T10:08:37Z", "message": "ISPN-11398 Change XSiteStateTransferProviderImpl to be non blocking"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6da3f34ce5317e73d6cd48365b37c85ad0e4d899", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/6da3f34ce5317e73d6cd48365b37c85ad0e4d899", "committedDate": "2021-01-06T10:08:37Z", "message": "ISPN-11398 Change XSiteStateTransferProviderImpl to be non blocking"}, "afterCommit": {"oid": "86aa26ca2e9d2df66c0f2312dc80db897dd682f3", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/86aa26ca2e9d2df66c0f2312dc80db897dd682f3", "committedDate": "2021-01-06T15:14:17Z", "message": "ISPN-11398 Change XSiteStateTransferProviderImpl to be non blocking"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYyOTM3Mzk5", "url": "https://github.com/infinispan/infinispan/pull/8940#pullrequestreview-562937399", "createdAt": "2021-01-06T18:18:39Z", "commit": {"oid": "86aa26ca2e9d2df66c0f2312dc80db897dd682f3"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODoxODozOVrOIPRQug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQxODoyMjoxNVrOIPRdhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4MjM2Mg==", "bodyText": "Is this executor really needed? I would think the concatMap operation should be non blocking.", "url": "https://github.com/infinispan/infinispan/pull/8940#discussion_r552882362", "createdAt": "2021-01-06T18:18:39Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/statetransfer/SyncProviderState.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package org.infinispan.xsite.statetransfer;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.XSiteStateTransferConfiguration;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.infinispan.xsite.XSiteBackup;\n+\n+import io.reactivex.rxjava3.annotations.NonNull;\n+import io.reactivex.rxjava3.core.Completable;\n+import io.reactivex.rxjava3.core.CompletableObserver;\n+import io.reactivex.rxjava3.core.CompletableSource;\n+import io.reactivex.rxjava3.core.Flowable;\n+import io.reactivex.rxjava3.disposables.Disposable;\n+import io.reactivex.rxjava3.functions.Function;\n+import io.reactivex.rxjava3.functions.Predicate;\n+import net.jcip.annotations.GuardedBy;\n+\n+/**\n+ * A {@link XSiteStateProviderState} for synchronous cross-site replication state transfer.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+public class SyncProviderState implements XSiteStateProviderState {\n+\n+   private static final Log log = LogFactory.getLog(SyncProviderState.class);\n+   private static final AtomicReferenceFieldUpdater<SyncProviderState, OutboundTask> TASK_UPDATER = AtomicReferenceFieldUpdater.newUpdater(SyncProviderState.class, OutboundTask.class, \"task\");\n+\n+   private final XSiteBackup backup;\n+   private final XSiteStateTransferConfiguration configuration;\n+   private volatile OutboundTask task;\n+\n+   private SyncProviderState(XSiteBackup backup, XSiteStateTransferConfiguration configuration) {\n+      this.backup = backup;\n+      this.configuration = configuration;\n+   }\n+\n+   public static SyncProviderState create(BackupConfiguration config) {\n+      XSiteBackup backup = new XSiteBackup(config.site(), true, config.stateTransfer().timeout());\n+      return new SyncProviderState(backup, config.stateTransfer());\n+   }\n+\n+   @Override\n+   public XSiteStatePushTask createPushTask(Address originator, XSiteStateProvider provider) {\n+      OutboundTask newTask = new OutboundTask(originator, provider, this);\n+      return TASK_UPDATER.compareAndSet(this, null, newTask) ? newTask : null;\n+   }\n+\n+   @Override\n+   public void cancelTransfer() {\n+      OutboundTask currentTask = TASK_UPDATER.getAndSet(this, null);\n+      if (currentTask != null) {\n+         currentTask.cancel();\n+      }\n+   }\n+\n+   @Override\n+   public boolean isSending() {\n+      return task != null;\n+   }\n+\n+   @Override\n+   public boolean isOriginatorMissing(Collection<Address> members) {\n+      OutboundTask currentTask = task;\n+      return currentTask != null && !members.contains(currentTask.coordinator);\n+   }\n+\n+   // methods for OutboundTask\n+   void taskFinished() {\n+      TASK_UPDATER.set(this, null);\n+   }\n+\n+   XSiteBackup getBackup() {\n+      return backup;\n+   }\n+\n+   int getChunkSize() {\n+      return configuration.chunkSize();\n+   }\n+\n+   long getWaitTimeMillis() {\n+      return configuration.waitTime();\n+   }\n+\n+   int getMaxRetries() {\n+      return configuration.maxRetries();\n+   }\n+\n+   private static class OutboundTask implements XSiteStatePushTask, Predicate<List<XSiteState>>, Function<List<XSiteState>, CompletableSource>, CompletableObserver {\n+\n+      private final Address coordinator;\n+      private final XSiteStateProvider provider;\n+      private final SyncProviderState state;\n+      private volatile boolean canceled = false;\n+\n+      private OutboundTask(Address coordinator, XSiteStateProvider provider, SyncProviderState state) {\n+         this.coordinator = coordinator;\n+         this.provider = provider;\n+         this.state = state;\n+      }\n+\n+      @Override\n+      public void execute(Flowable<XSiteState> flowable, CompletionStage<Void> delayer) {\n+         //delayer is the cache topology future. we need to ensure the topology id is installed before iterating\n+         delayer.thenRunAsync(() -> flowable\n+                     .buffer(state.getChunkSize())\n+                     .takeUntil(this)\n+                     .concatMapCompletable(this, 1)\n+                     .subscribe(this),\n+               provider.getExecutor());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86aa26ca2e9d2df66c0f2312dc80db897dd682f3"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4MzIxNA==", "bodyText": "Is this throwable logged somewhere?", "url": "https://github.com/infinispan/infinispan/pull/8940#discussion_r552883214", "createdAt": "2021-01-06T18:19:38Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/statetransfer/SyncProviderState.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package org.infinispan.xsite.statetransfer;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.XSiteStateTransferConfiguration;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.infinispan.xsite.XSiteBackup;\n+\n+import io.reactivex.rxjava3.annotations.NonNull;\n+import io.reactivex.rxjava3.core.Completable;\n+import io.reactivex.rxjava3.core.CompletableObserver;\n+import io.reactivex.rxjava3.core.CompletableSource;\n+import io.reactivex.rxjava3.core.Flowable;\n+import io.reactivex.rxjava3.disposables.Disposable;\n+import io.reactivex.rxjava3.functions.Function;\n+import io.reactivex.rxjava3.functions.Predicate;\n+import net.jcip.annotations.GuardedBy;\n+\n+/**\n+ * A {@link XSiteStateProviderState} for synchronous cross-site replication state transfer.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+public class SyncProviderState implements XSiteStateProviderState {\n+\n+   private static final Log log = LogFactory.getLog(SyncProviderState.class);\n+   private static final AtomicReferenceFieldUpdater<SyncProviderState, OutboundTask> TASK_UPDATER = AtomicReferenceFieldUpdater.newUpdater(SyncProviderState.class, OutboundTask.class, \"task\");\n+\n+   private final XSiteBackup backup;\n+   private final XSiteStateTransferConfiguration configuration;\n+   private volatile OutboundTask task;\n+\n+   private SyncProviderState(XSiteBackup backup, XSiteStateTransferConfiguration configuration) {\n+      this.backup = backup;\n+      this.configuration = configuration;\n+   }\n+\n+   public static SyncProviderState create(BackupConfiguration config) {\n+      XSiteBackup backup = new XSiteBackup(config.site(), true, config.stateTransfer().timeout());\n+      return new SyncProviderState(backup, config.stateTransfer());\n+   }\n+\n+   @Override\n+   public XSiteStatePushTask createPushTask(Address originator, XSiteStateProvider provider) {\n+      OutboundTask newTask = new OutboundTask(originator, provider, this);\n+      return TASK_UPDATER.compareAndSet(this, null, newTask) ? newTask : null;\n+   }\n+\n+   @Override\n+   public void cancelTransfer() {\n+      OutboundTask currentTask = TASK_UPDATER.getAndSet(this, null);\n+      if (currentTask != null) {\n+         currentTask.cancel();\n+      }\n+   }\n+\n+   @Override\n+   public boolean isSending() {\n+      return task != null;\n+   }\n+\n+   @Override\n+   public boolean isOriginatorMissing(Collection<Address> members) {\n+      OutboundTask currentTask = task;\n+      return currentTask != null && !members.contains(currentTask.coordinator);\n+   }\n+\n+   // methods for OutboundTask\n+   void taskFinished() {\n+      TASK_UPDATER.set(this, null);\n+   }\n+\n+   XSiteBackup getBackup() {\n+      return backup;\n+   }\n+\n+   int getChunkSize() {\n+      return configuration.chunkSize();\n+   }\n+\n+   long getWaitTimeMillis() {\n+      return configuration.waitTime();\n+   }\n+\n+   int getMaxRetries() {\n+      return configuration.maxRetries();\n+   }\n+\n+   private static class OutboundTask implements XSiteStatePushTask, Predicate<List<XSiteState>>, Function<List<XSiteState>, CompletableSource>, CompletableObserver {\n+\n+      private final Address coordinator;\n+      private final XSiteStateProvider provider;\n+      private final SyncProviderState state;\n+      private volatile boolean canceled = false;\n+\n+      private OutboundTask(Address coordinator, XSiteStateProvider provider, SyncProviderState state) {\n+         this.coordinator = coordinator;\n+         this.provider = provider;\n+         this.state = state;\n+      }\n+\n+      @Override\n+      public void execute(Flowable<XSiteState> flowable, CompletionStage<Void> delayer) {\n+         //delayer is the cache topology future. we need to ensure the topology id is installed before iterating\n+         delayer.thenRunAsync(() -> flowable\n+                     .buffer(state.getChunkSize())\n+                     .takeUntil(this)\n+                     .concatMapCompletable(this, 1)\n+                     .subscribe(this),\n+               provider.getExecutor());\n+\n+      }\n+\n+      public void cancel() {\n+         canceled = true;\n+      }\n+\n+      @Override\n+      public boolean test(List<XSiteState> ignored) {\n+         //Flowable#takeUntil method\n+         return canceled;\n+      }\n+\n+      @Override\n+      public void onSubscribe(@NonNull Disposable d) {\n+\n+      }\n+\n+      @Override\n+      public void onComplete() {\n+         //if canceled, the coordinator already cleanup the resources. There is nothing to be done here.\n+         if (canceled) {\n+            return;\n+         }\n+         provider.notifyStateTransferEnd(state.getBackup().getSiteName(), coordinator, true);\n+         state.taskFinished();\n+      }\n+\n+      @Override\n+      public void onError(@NonNull Throwable e) {\n+         //if canceled, the coordinator already cleanup the resources. There is nothing to be done here.\n+         if (canceled) {\n+            return;\n+         }\n+         provider.notifyStateTransferEnd(state.getBackup().getSiteName(), coordinator, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86aa26ca2e9d2df66c0f2312dc80db897dd682f3"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4NTYzOA==", "bodyText": "Same thing here about the use of the executor, does the RpcManager#invokeXSite method block or something?", "url": "https://github.com/infinispan/infinispan/pull/8940#discussion_r552885638", "createdAt": "2021-01-06T18:22:15Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/statetransfer/SyncProviderState.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package org.infinispan.xsite.statetransfer;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.XSiteStateTransferConfiguration;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.infinispan.xsite.XSiteBackup;\n+\n+import io.reactivex.rxjava3.annotations.NonNull;\n+import io.reactivex.rxjava3.core.Completable;\n+import io.reactivex.rxjava3.core.CompletableObserver;\n+import io.reactivex.rxjava3.core.CompletableSource;\n+import io.reactivex.rxjava3.core.Flowable;\n+import io.reactivex.rxjava3.disposables.Disposable;\n+import io.reactivex.rxjava3.functions.Function;\n+import io.reactivex.rxjava3.functions.Predicate;\n+import net.jcip.annotations.GuardedBy;\n+\n+/**\n+ * A {@link XSiteStateProviderState} for synchronous cross-site replication state transfer.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+public class SyncProviderState implements XSiteStateProviderState {\n+\n+   private static final Log log = LogFactory.getLog(SyncProviderState.class);\n+   private static final AtomicReferenceFieldUpdater<SyncProviderState, OutboundTask> TASK_UPDATER = AtomicReferenceFieldUpdater.newUpdater(SyncProviderState.class, OutboundTask.class, \"task\");\n+\n+   private final XSiteBackup backup;\n+   private final XSiteStateTransferConfiguration configuration;\n+   private volatile OutboundTask task;\n+\n+   private SyncProviderState(XSiteBackup backup, XSiteStateTransferConfiguration configuration) {\n+      this.backup = backup;\n+      this.configuration = configuration;\n+   }\n+\n+   public static SyncProviderState create(BackupConfiguration config) {\n+      XSiteBackup backup = new XSiteBackup(config.site(), true, config.stateTransfer().timeout());\n+      return new SyncProviderState(backup, config.stateTransfer());\n+   }\n+\n+   @Override\n+   public XSiteStatePushTask createPushTask(Address originator, XSiteStateProvider provider) {\n+      OutboundTask newTask = new OutboundTask(originator, provider, this);\n+      return TASK_UPDATER.compareAndSet(this, null, newTask) ? newTask : null;\n+   }\n+\n+   @Override\n+   public void cancelTransfer() {\n+      OutboundTask currentTask = TASK_UPDATER.getAndSet(this, null);\n+      if (currentTask != null) {\n+         currentTask.cancel();\n+      }\n+   }\n+\n+   @Override\n+   public boolean isSending() {\n+      return task != null;\n+   }\n+\n+   @Override\n+   public boolean isOriginatorMissing(Collection<Address> members) {\n+      OutboundTask currentTask = task;\n+      return currentTask != null && !members.contains(currentTask.coordinator);\n+   }\n+\n+   // methods for OutboundTask\n+   void taskFinished() {\n+      TASK_UPDATER.set(this, null);\n+   }\n+\n+   XSiteBackup getBackup() {\n+      return backup;\n+   }\n+\n+   int getChunkSize() {\n+      return configuration.chunkSize();\n+   }\n+\n+   long getWaitTimeMillis() {\n+      return configuration.waitTime();\n+   }\n+\n+   int getMaxRetries() {\n+      return configuration.maxRetries();\n+   }\n+\n+   private static class OutboundTask implements XSiteStatePushTask, Predicate<List<XSiteState>>, Function<List<XSiteState>, CompletableSource>, CompletableObserver {\n+\n+      private final Address coordinator;\n+      private final XSiteStateProvider provider;\n+      private final SyncProviderState state;\n+      private volatile boolean canceled = false;\n+\n+      private OutboundTask(Address coordinator, XSiteStateProvider provider, SyncProviderState state) {\n+         this.coordinator = coordinator;\n+         this.provider = provider;\n+         this.state = state;\n+      }\n+\n+      @Override\n+      public void execute(Flowable<XSiteState> flowable, CompletionStage<Void> delayer) {\n+         //delayer is the cache topology future. we need to ensure the topology id is installed before iterating\n+         delayer.thenRunAsync(() -> flowable\n+                     .buffer(state.getChunkSize())\n+                     .takeUntil(this)\n+                     .concatMapCompletable(this, 1)\n+                     .subscribe(this),\n+               provider.getExecutor());\n+\n+      }\n+\n+      public void cancel() {\n+         canceled = true;\n+      }\n+\n+      @Override\n+      public boolean test(List<XSiteState> ignored) {\n+         //Flowable#takeUntil method\n+         return canceled;\n+      }\n+\n+      @Override\n+      public void onSubscribe(@NonNull Disposable d) {\n+\n+      }\n+\n+      @Override\n+      public void onComplete() {\n+         //if canceled, the coordinator already cleanup the resources. There is nothing to be done here.\n+         if (canceled) {\n+            return;\n+         }\n+         provider.notifyStateTransferEnd(state.getBackup().getSiteName(), coordinator, true);\n+         state.taskFinished();\n+      }\n+\n+      @Override\n+      public void onError(@NonNull Throwable e) {\n+         //if canceled, the coordinator already cleanup the resources. There is nothing to be done here.\n+         if (canceled) {\n+            return;\n+         }\n+         provider.notifyStateTransferEnd(state.getBackup().getSiteName(), coordinator, false);\n+         state.taskFinished();\n+      }\n+\n+      @Override\n+      public CompletableSource apply(List<XSiteState> xSiteStates) {\n+         //Flowable#concatMapCompletable method\n+         XSiteBackup backup = state.getBackup();\n+         //TODO!? can we use xSiteStates directly instead of copying?\n+         XSiteState[] privateBuffer = xSiteStates.toArray(new XSiteState[0]);\n+\n+         if (log.isDebugEnabled()) {\n+            log.debugf(\"Sending chunk to site '%s'. Chunk has %s keys.\", backup.getSiteName(), privateBuffer.length);\n+         }\n+\n+         XSiteStatePushCommand command = provider.getCommandsFactory().buildXSiteStatePushCommand(privateBuffer, backup.getTimeout());\n+         return Completable.fromCompletionStage(new CommandRetry(backup, command, provider, state.getWaitTimeMillis(), state.getMaxRetries()).send());\n+      }\n+   }\n+\n+   private static class CommandRetry extends CompletableFuture<Void> implements java.util.function.BiConsumer<Void, Throwable> {\n+\n+      private final XSiteBackup backup;\n+      private final XSiteStatePushCommand cmd;\n+      private final XSiteStateProvider provider;\n+      private final long waitTimeMillis;\n+      @GuardedBy(\"this\")\n+      private int maxRetries;\n+\n+      private CommandRetry(XSiteBackup backup, XSiteStatePushCommand cmd, XSiteStateProvider provider, long waitTimeMillis, int maxRetries) {\n+         this.backup = backup;\n+         this.cmd = cmd;\n+         this.provider = provider;\n+         this.waitTimeMillis = waitTimeMillis;\n+         this.maxRetries = maxRetries;\n+      }\n+\n+      //method to invoke from other class\n+      CompletionStage<Void> send() {\n+         doSend();\n+         return this;\n+      }\n+\n+      //used in scheduled executor, invokes doSend after the wait time.\n+      void nonBlockingSend() {\n+         provider.getExecutor().execute(this::doSend);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86aa26ca2e9d2df66c0f2312dc80db897dd682f3"}, "originalPosition": 200}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1d50b5cb2f313e93e87311399a9e37a3039866d", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/f1d50b5cb2f313e93e87311399a9e37a3039866d", "committedDate": "2021-01-07T10:03:29Z", "message": "ISPN-11398 Change XSiteStateTransferProviderImpl to be non blocking"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "86aa26ca2e9d2df66c0f2312dc80db897dd682f3", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/86aa26ca2e9d2df66c0f2312dc80db897dd682f3", "committedDate": "2021-01-06T15:14:17Z", "message": "ISPN-11398 Change XSiteStateTransferProviderImpl to be non blocking"}, "afterCommit": {"oid": "f1d50b5cb2f313e93e87311399a9e37a3039866d", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/f1d50b5cb2f313e93e87311399a9e37a3039866d", "committedDate": "2021-01-07T10:03:29Z", "message": "ISPN-11398 Change XSiteStateTransferProviderImpl to be non blocking"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY2NDE3MDk1", "url": "https://github.com/infinispan/infinispan/pull/8940#pullrequestreview-566417095", "createdAt": "2021-01-12T15:55:06Z", "commit": {"oid": "f1d50b5cb2f313e93e87311399a9e37a3039866d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 243, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}