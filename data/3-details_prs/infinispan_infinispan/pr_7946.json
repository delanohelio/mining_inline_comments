{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5NDIzOTg3", "number": 7946, "title": "ISPN-11341 Client requests go to wrong server with binary storage", "bodyText": "https://issues.redhat.com/browse/ISPN-11341", "createdAt": "2020-02-25T08:02:50Z", "url": "https://github.com/infinispan/infinispan/pull/7946", "merged": true, "mergeCommit": {"oid": "a9bb284159d3940a03cb33fb93e0c1c1da4ffa5e"}, "closed": true, "closedAt": "2020-03-02T14:14:55Z", "author": {"login": "gustavonalle"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcHucNkABqjMwNjg1NTc5NTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcJqZVSgFqTM2NzA1NTk5MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "000cf78912227945e82ed4f16e9889ace35432ac", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/000cf78912227945e82ed4f16e9889ace35432ac", "committedDate": "2020-02-25T08:02:03Z", "message": "ISPN-11341 Detect client and server segment mismatch and fallback to tracking only keys"}, "afterCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/dcc248aa4d73439700045e781a8241cc7250ab16", "committedDate": "2020-02-25T09:09:45Z", "message": "ISPN-11341 Detect client and server segment mismatch and fallback to tracking only keys"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NDgxNzYz", "url": "https://github.com/infinispan/infinispan/pull/7946#pullrequestreview-366481763", "createdAt": "2020-02-28T15:30:31Z", "commit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTozMDozMlrOFv460w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTo0MzowOFrOFv5ZmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1OTk1NQ==", "bodyText": "I would add the keys directly to ReplKeyTracker. You are creating a new HashSet here and when you instantiate the ReplKeyTracker.", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385759955", "createdAt": "2020-02-28T15:30:32Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "diffHunk": "@@ -40,20 +42,38 @@ public SegmentKeyTracker(DataFormat dataFormat, SegmentConsistentHash segmentCon\n       segmentStream.forEach(i -> keysPerSegment.set(i, new HashSet<>()));\n    }\n \n+   private Set<WrappedByteArray> drainKeys() {\n+      Set<WrappedByteArray> trackedKeys = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2MDYyOA==", "bodyText": "not sure how this class is used but... can we have an NPE here?\nyou are setting trackSegments before instantiating keyOnlyTracker", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385760628", "createdAt": "2020-02-28T15:31:31Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "diffHunk": "@@ -40,20 +42,38 @@ public SegmentKeyTracker(DataFormat dataFormat, SegmentConsistentHash segmentCon\n       segmentStream.forEach(i -> keysPerSegment.set(i, new HashSet<>()));\n    }\n \n+   private Set<WrappedByteArray> drainKeys() {\n+      Set<WrappedByteArray> trackedKeys = new HashSet<>();\n+      for (int i = 0; i < keysPerSegment.length(); i++) {\n+         Set<WrappedByteArray> keys = keysPerSegment.get(i);\n+         if (keys != null) trackedKeys.addAll(keys);\n+         keysPerSegment.set(i, null);\n+      }\n+\n+      return trackedKeys;\n+   }\n+\n    public boolean track(byte[] key, short status, ClassWhiteList whitelist) {\n+      if (!trackSegments) {\n+         return keyOnlyTracker.track(key, status, whitelist);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2MjQ0Nw==", "bodyText": "nitpick: if (trackeSegments && finishedSegments != null)", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385762447", "createdAt": "2020-02-28T15:34:24Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "diffHunk": "@@ -66,11 +86,13 @@ public boolean track(byte[] key, short status, ClassWhiteList whitelist) {\n    }\n \n    public void segmentsFinished(byte[] finishedSegments) {\n-      if (finishedSegments != null) {\n-         BitSet bitSet = BitSet.valueOf(finishedSegments);\n-         if (trace)\n-            log.tracef(\"Removing completed segments %s\", bitSet);\n-         bitSet.stream().forEach(seg -> keysPerSegment.set(seg, null));\n+      if (trackSegments) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NDA3OQ==", "bodyText": "any reason to use AtomicInteger? a boolean would be enough IMO :)", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385764079", "createdAt": "2020-02-28T15:37:06Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/StorageRoutingTest.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.client.hotrod;\n+\n+import static org.infinispan.configuration.cache.StorageType.BINARY;\n+import static org.infinispan.configuration.cache.StorageType.OBJECT;\n+import static org.infinispan.configuration.cache.StorageType.OFF_HEAP;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.hotrod.test.FixedServerBalancing;\n+import org.infinispan.client.hotrod.test.MultiHotRodServersTest;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.cache.StorageType;\n+import org.infinispan.server.hotrod.HotRodServer;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Tests that the Hot Rod client can correctly route requests to a server using different {@link StorageType}.\n+ *\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\", testName = \"client.hotrod.StorageRoutingTest\")\n+public class StorageRoutingTest extends MultiHotRodServersTest {\n+\n+   private static final int CLUSTER_SIZE = 3;\n+\n+   protected StorageType storageType;\n+   private Object key;\n+\n+   public Object[] factory() {\n+      String stringKey = \"key\";\n+      byte[] byteArrayKey = new byte[]{1, 2, 3};\n+\n+      return new Object[]{\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(byteArrayKey)\n+      };\n+   }\n+\n+   protected String[] parameterNames() {\n+      return new String[]{\"storage\", \"key\"};\n+   }\n+\n+   protected Object[] parameterValues() {\n+      return new Object[]{storageType, key};\n+   }\n+\n+   private StorageRoutingTest withStorageType(StorageType storageType) {\n+      this.storageType = storageType;\n+      return this;\n+   }\n+\n+   private StorageRoutingTest withKey(Object key) {\n+      this.key = key;\n+      return this;\n+   }\n+\n+   @Override\n+   protected void createCacheManagers() throws Throwable {\n+      ConfigurationBuilder cfgBuilder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      cfgBuilder.jmxStatistics().enable();\n+      cfgBuilder.clustering().hash().numOwners(1);\n+      cfgBuilder.memory().storageType(storageType);\n+      createHotRodServers(CLUSTER_SIZE, cfgBuilder);\n+      waitForClusterToForm();\n+   }\n+\n+   @Override\n+   protected org.infinispan.client.hotrod.configuration.ConfigurationBuilder createHotRodClientConfigurationBuilder(HotRodServer hotRodServer) {\n+      org.infinispan.client.hotrod.configuration.ConfigurationBuilder hotRodClientConfigurationBuilder = super.createHotRodClientConfigurationBuilder(hotRodServer);\n+      hotRodClientConfigurationBuilder.balancingStrategy(() -> new FixedServerBalancing(hotRodServer));\n+      return hotRodClientConfigurationBuilder;\n+   }\n+\n+   @Test\n+   public void shouldContactKeyOwnerForPutGet() {\n+      String value = \"value\";\n+      RemoteCache<Object, String> remoteCache = clients.get(0).getCache();\n+      remoteCache.put(key, value);\n+\n+      assertEquals(remoteCache.get(key), \"value\");\n+\n+      assertCorrectServerContacted();\n+   }\n+\n+   private void assertCorrectServerContacted() {\n+      AtomicInteger storedIn = new AtomicInteger(-1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NzgzMw==", "bodyText": "I'm not sure I understand why you use the FixedServerBalancing. Isn't it force the requests to go to this server?", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385767833", "createdAt": "2020-02-28T15:43:08Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/StorageRoutingTest.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.client.hotrod;\n+\n+import static org.infinispan.configuration.cache.StorageType.BINARY;\n+import static org.infinispan.configuration.cache.StorageType.OBJECT;\n+import static org.infinispan.configuration.cache.StorageType.OFF_HEAP;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.hotrod.test.FixedServerBalancing;\n+import org.infinispan.client.hotrod.test.MultiHotRodServersTest;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.cache.StorageType;\n+import org.infinispan.server.hotrod.HotRodServer;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Tests that the Hot Rod client can correctly route requests to a server using different {@link StorageType}.\n+ *\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\", testName = \"client.hotrod.StorageRoutingTest\")\n+public class StorageRoutingTest extends MultiHotRodServersTest {\n+\n+   private static final int CLUSTER_SIZE = 3;\n+\n+   protected StorageType storageType;\n+   private Object key;\n+\n+   public Object[] factory() {\n+      String stringKey = \"key\";\n+      byte[] byteArrayKey = new byte[]{1, 2, 3};\n+\n+      return new Object[]{\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(byteArrayKey)\n+      };\n+   }\n+\n+   protected String[] parameterNames() {\n+      return new String[]{\"storage\", \"key\"};\n+   }\n+\n+   protected Object[] parameterValues() {\n+      return new Object[]{storageType, key};\n+   }\n+\n+   private StorageRoutingTest withStorageType(StorageType storageType) {\n+      this.storageType = storageType;\n+      return this;\n+   }\n+\n+   private StorageRoutingTest withKey(Object key) {\n+      this.key = key;\n+      return this;\n+   }\n+\n+   @Override\n+   protected void createCacheManagers() throws Throwable {\n+      ConfigurationBuilder cfgBuilder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      cfgBuilder.jmxStatistics().enable();\n+      cfgBuilder.clustering().hash().numOwners(1);\n+      cfgBuilder.memory().storageType(storageType);\n+      createHotRodServers(CLUSTER_SIZE, cfgBuilder);\n+      waitForClusterToForm();\n+   }\n+\n+   @Override\n+   protected org.infinispan.client.hotrod.configuration.ConfigurationBuilder createHotRodClientConfigurationBuilder(HotRodServer hotRodServer) {\n+      org.infinispan.client.hotrod.configuration.ConfigurationBuilder hotRodClientConfigurationBuilder = super.createHotRodClientConfigurationBuilder(hotRodServer);\n+      hotRodClientConfigurationBuilder.balancingStrategy(() -> new FixedServerBalancing(hotRodServer));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 78}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/dcc248aa4d73439700045e781a8241cc7250ab16", "committedDate": "2020-02-25T09:09:45Z", "message": "ISPN-11341 Detect client and server segment mismatch and fallback to tracking only keys"}, "afterCommit": {"oid": "5c2141b3c9579d9d378940016183c550a06f0ecf", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/5c2141b3c9579d9d378940016183c550a06f0ecf", "committedDate": "2020-03-02T08:20:26Z", "message": "ISPN-11341 Detect client and server segment mismatch and fallback to tracking only keys"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5c2141b3c9579d9d378940016183c550a06f0ecf", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/5c2141b3c9579d9d378940016183c550a06f0ecf", "committedDate": "2020-03-02T08:20:26Z", "message": "ISPN-11341 Detect client and server segment mismatch and fallback to tracking only keys"}, "afterCommit": {"oid": "ed2dc11d5bb244e5af162eb4e3a1b636ad3d0a03", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/ed2dc11d5bb244e5af162eb4e3a1b636ad3d0a03", "committedDate": "2020-03-02T08:21:30Z", "message": "ISPN-11341 Detect client and server segment mismatch and fallback to tracking only keys"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f2f85a7ab07e47446b897806ed4c9be3c0b9084", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/9f2f85a7ab07e47446b897806ed4c9be3c0b9084", "committedDate": "2020-03-02T09:20:09Z", "message": "ISPN-11341 Reproducer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8db9ae27cafe4810fa905f16b4297887bab92198", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/8db9ae27cafe4810fa905f16b4297887bab92198", "committedDate": "2020-03-02T09:20:09Z", "message": "ISPN-11341 Turn BINARY as a no-op when cache started by the server"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ddcbfe63c0e345b0dd585a5778de00c647ead0a", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/6ddcbfe63c0e345b0dd585a5778de00c647ead0a", "committedDate": "2020-03-02T09:24:39Z", "message": "ISPN-11341 Detect client and server segment mismatch and fallback to tracking only keys"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed2dc11d5bb244e5af162eb4e3a1b636ad3d0a03", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/ed2dc11d5bb244e5af162eb4e3a1b636ad3d0a03", "committedDate": "2020-03-02T08:21:30Z", "message": "ISPN-11341 Detect client and server segment mismatch and fallback to tracking only keys"}, "afterCommit": {"oid": "6ddcbfe63c0e345b0dd585a5778de00c647ead0a", "author": {"user": {"login": "gustavonalle", "name": "Gustavo"}}, "url": "https://github.com/infinispan/infinispan/commit/6ddcbfe63c0e345b0dd585a5778de00c647ead0a", "committedDate": "2020-03-02T09:24:39Z", "message": "ISPN-11341 Detect client and server segment mismatch and fallback to tracking only keys"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3MDU1OTkx", "url": "https://github.com/infinispan/infinispan/pull/7946#pullrequestreview-367055991", "createdAt": "2020-03-02T09:35:05Z", "commit": {"oid": "6ddcbfe63c0e345b0dd585a5778de00c647ead0a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1201, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}