{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4NTk0OTkx", "number": 8750, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwOTozMzoxMlrOErGDTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwOTozOTozMlrOErGNCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNjIzMzcyOnYy", "diffSide": "RIGHT", "path": "documentation/src/main/asciidoc/stories/assembly_marshalling_user_types.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwOTozMzoxMlrOHdqzgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMDowMjoxOVrOHdr6bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg3MjA2NQ==", "bodyText": "This isn't required for protostream, so this should just be linked from the docs of Marshallers that require it, e.g. JavaSerializationMarshaller or JbossUserMarshaller.", "url": "https://github.com/infinispan/infinispan/pull/8750#discussion_r500872065", "createdAt": "2020-10-07T09:33:12Z", "author": {"login": "ryanemerson"}, "path": "documentation/src/main/asciidoc/stories/assembly_marshalling_user_types.adoc", "diffHunk": "@@ -0,0 +1,16 @@\n+[id='marshalling_user_types']\n+:context: marshalling\n+= Marshalling User Types with ProtoStream\n+User types are Java objects that {brandname} does not support out of the box.\n+To marshall user types, you implement the `SerializationContextInitializer`\n+interface to describe your Java objects so that the ProtoStream library can\n+encode them to Protobuf format and {brandname} can transmit and store them.\n+\n+include::{topics}/proc_generating_protostream_sci.adoc[leveloffset=+1]\n+include::{topics}/proc_manually_registering_sci.adoc[leveloffset=+2]\n+include::{topics}/proc_implementing_protostream_sci.adoc[leveloffset=+1]\n+include::{topics}/proc_adding_deserialization_allowlist.adoc[leveloffset=+1]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69b3121b60a78704b5a198a555fb076207a01e9"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg5MDIyMg==", "bodyText": "ah... OK. I thought it was required for all cases where user objects were used. will fix.", "url": "https://github.com/infinispan/infinispan/pull/8750#discussion_r500890222", "createdAt": "2020-10-07T10:02:19Z", "author": {"login": "oraNod"}, "path": "documentation/src/main/asciidoc/stories/assembly_marshalling_user_types.adoc", "diffHunk": "@@ -0,0 +1,16 @@\n+[id='marshalling_user_types']\n+:context: marshalling\n+= Marshalling User Types with ProtoStream\n+User types are Java objects that {brandname} does not support out of the box.\n+To marshall user types, you implement the `SerializationContextInitializer`\n+interface to describe your Java objects so that the ProtoStream library can\n+encode them to Protobuf format and {brandname} can transmit and store them.\n+\n+include::{topics}/proc_generating_protostream_sci.adoc[leveloffset=+1]\n+include::{topics}/proc_manually_registering_sci.adoc[leveloffset=+2]\n+include::{topics}/proc_implementing_protostream_sci.adoc[leveloffset=+1]\n+include::{topics}/proc_adding_deserialization_allowlist.adoc[leveloffset=+1]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg3MjA2NQ=="}, "originalCommit": {"oid": "a69b3121b60a78704b5a198a555fb076207a01e9"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNjI1MDEzOnYy", "diffSide": "RIGHT", "path": "documentation/src/main/asciidoc/topics/proc_implementing_protostream_sci.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwOTozNzoyM1rOHdq9tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMTo0MzoxMlrOHdvPNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg3NDY3OA==", "bodyText": "When manually creating a SCI it's necessary to register it with the configuration as described in Manually Registering Serialization Context Initializers. This is a usability issue until Adrian's new API is available, as it means that if users have to create a single manual SCI for external types, then they also have to register all generated SCIs manually.", "url": "https://github.com/infinispan/infinispan/pull/8750#discussion_r500874678", "createdAt": "2020-10-07T09:37:23Z", "author": {"login": "ryanemerson"}, "path": "documentation/src/main/asciidoc/topics/proc_implementing_protostream_sci.adoc", "diffHunk": "@@ -0,0 +1,56 @@\n+[id='implementing_proto_marshallers']\n+= Manually Implementing Serialization Context Initializers\n+In some cases you might need to manually define Protobuf schemas and implement\n+ProtoStream marshallers. For example, if you cannot modify Java object classes\n+to add annotations.\n+\n+[NOTE]\n+====\n+This method for manually implementing the `SerializationContextInitializer`\n+interface is deprecated.\n+//Adrian to provide details on API change as an alternative. Users can provide annotations in different context to create bridge classes.\n+====\n+\n+.Procedure\n+\n+. Create a Protobuf schema, `.proto` file, that provides a structured\n+representations of the Java objects to marshall.\n++\n+[source,proto]\n+----\n+include::config_examples/library.proto[]\n+----\n++\n+The preceding `.library.proto` file defines an entity (Protobuf message type)\n+named _Book_ that is contained in the _book_sample_ package. _Book_ declares\n+several fields of primitive types and an array (Protobuf repeatable field)\n+named _authors_, which is the _Author_ message type.\n++\n+* You can nest messages but the resulting structure is strictly a tree, never a graph.\n+* Type inheritance is not possible.\n+* Collections are not supported but you can emulate arrays with repeated fields.\n++\n+. Use the `org.infinispan.protostream.MessageMarshaller` interface to implement\n+marshallers for your classes.\n++\n+[source,java]\n+.BookMarshaller.java\n+----\n+include::code_examples/BookMarshaller.java[]\n+----\n++\n+[source,java]\n+.AuthorMarshaller.java\n+----\n+include::code_examples/AuthorMarshaller.java[]\n+----\n++\n+. Create a `SerializationContextInitializer` implementation that registers the\n+`.proto` schema and the ProtoStream marshaller implementations with a\n+`SerializationContext`.\n++\n+[source,java]\n+.ManualSerializationContextInitializer.java\n+----\n+include::code_examples/ManualSerializationContextInitializer.java[]\n+----", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69b3121b60a78704b5a198a555fb076207a01e9"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk0NDY5Mg==", "bodyText": "thanks! fixed.", "url": "https://github.com/infinispan/infinispan/pull/8750#discussion_r500944692", "createdAt": "2020-10-07T11:43:12Z", "author": {"login": "oraNod"}, "path": "documentation/src/main/asciidoc/topics/proc_implementing_protostream_sci.adoc", "diffHunk": "@@ -0,0 +1,56 @@\n+[id='implementing_proto_marshallers']\n+= Manually Implementing Serialization Context Initializers\n+In some cases you might need to manually define Protobuf schemas and implement\n+ProtoStream marshallers. For example, if you cannot modify Java object classes\n+to add annotations.\n+\n+[NOTE]\n+====\n+This method for manually implementing the `SerializationContextInitializer`\n+interface is deprecated.\n+//Adrian to provide details on API change as an alternative. Users can provide annotations in different context to create bridge classes.\n+====\n+\n+.Procedure\n+\n+. Create a Protobuf schema, `.proto` file, that provides a structured\n+representations of the Java objects to marshall.\n++\n+[source,proto]\n+----\n+include::config_examples/library.proto[]\n+----\n++\n+The preceding `.library.proto` file defines an entity (Protobuf message type)\n+named _Book_ that is contained in the _book_sample_ package. _Book_ declares\n+several fields of primitive types and an array (Protobuf repeatable field)\n+named _authors_, which is the _Author_ message type.\n++\n+* You can nest messages but the resulting structure is strictly a tree, never a graph.\n+* Type inheritance is not possible.\n+* Collections are not supported but you can emulate arrays with repeated fields.\n++\n+. Use the `org.infinispan.protostream.MessageMarshaller` interface to implement\n+marshallers for your classes.\n++\n+[source,java]\n+.BookMarshaller.java\n+----\n+include::code_examples/BookMarshaller.java[]\n+----\n++\n+[source,java]\n+.AuthorMarshaller.java\n+----\n+include::code_examples/AuthorMarshaller.java[]\n+----\n++\n+. Create a `SerializationContextInitializer` implementation that registers the\n+`.proto` schema and the ProtoStream marshaller implementations with a\n+`SerializationContext`.\n++\n+[source,java]\n+.ManualSerializationContextInitializer.java\n+----\n+include::code_examples/ManualSerializationContextInitializer.java[]\n+----", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg3NDY3OA=="}, "originalCommit": {"oid": "a69b3121b60a78704b5a198a555fb076207a01e9"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNjI1ODY1OnYy", "diffSide": "RIGHT", "path": "documentation/src/main/asciidoc/stories/assembly_marshaller_implementations.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwOTozOTozMlrOHdrC1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMDowMzozN1rOHdr9XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg3NTk4OQ==", "bodyText": "Is this story included anywhere?", "url": "https://github.com/infinispan/infinispan/pull/8750#discussion_r500875989", "createdAt": "2020-10-07T09:39:32Z", "author": {"login": "ryanemerson"}, "path": "documentation/src/main/asciidoc/stories/assembly_marshaller_implementations.adoc", "diffHunk": "@@ -0,0 +1,17 @@\n+[id='marshaller_implementations']", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a69b3121b60a78704b5a198a555fb076207a01e9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg5MDk3Mw==", "bodyText": "yep. it's nested under the main assembly_marshalling.adoc story.", "url": "https://github.com/infinispan/infinispan/pull/8750#discussion_r500890973", "createdAt": "2020-10-07T10:03:37Z", "author": {"login": "oraNod"}, "path": "documentation/src/main/asciidoc/stories/assembly_marshaller_implementations.adoc", "diffHunk": "@@ -0,0 +1,17 @@\n+[id='marshaller_implementations']", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg3NTk4OQ=="}, "originalCommit": {"oid": "a69b3121b60a78704b5a198a555fb076207a01e9"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3839, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}