{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxMjE4MDE0", "number": 8637, "title": "ISPN-12242 BlockingManager add reentrant blocking scheduler", "bodyText": "https://issues.redhat.com/browse/ISPN-12242", "createdAt": "2020-08-20T20:15:05Z", "url": "https://github.com/infinispan/infinispan/pull/8637", "merged": true, "mergeCommit": {"oid": "6f7b7dd47136a2b88185c4e3d6a89814fbae35ab"}, "closed": true, "closedAt": "2020-08-27T08:13:58Z", "author": {"login": "wburns"}, "timelineItems": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdA2CdsAH2gAyNDcxMjE4MDE0OjQ0YmUwYjUwZDhjMDlhOWFiZGE3ZjgxMzEwZWM4YmY2MDc3NTI3NzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd3aaWbgFqTQ3NzcwMDUzMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "44be0b50d8c09a9abda7f81310ec8bf607752773", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/44be0b50d8c09a9abda7f81310ec8bf607752773", "committedDate": "2020-08-20T20:14:48Z", "message": "ISPN-12242 BlockingManager add reentrant blocking scheduler"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3NzAwNTMz", "url": "https://github.com/infinispan/infinispan/pull/8637#pullrequestreview-477700533", "createdAt": "2020-08-28T12:50:24Z", "commit": {"oid": "44be0b50d8c09a9abda7f81310ec8bf607752773"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMjo1MDoyNFrOHJDa2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNlQwOTowNzozM1rOIg63Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI1NTI1OA==", "bodyText": "IMO this isn't accurate: BlockHound doesn't dictate that this method is blocking, we mark it as blocking in CommonsTestBlockHoundIntegration. I would have preferred something like \"Empty method marked as blocking. BlockHound will throw an exception if this method is called from a non-blocking thread, unless called from an excluded method.\"", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r479255258", "createdAt": "2020-08-28T12:50:24Z", "author": {"login": "danberindei"}, "path": "commons-test/src/main/java/org/infinispan/commons/test/BlockHoundHelper.java", "diffHunk": "@@ -87,4 +87,15 @@ public static Executor ensureNonBlockingExecutor() {\n    public static Executor allowBlockingExecutor() {\n       return BlockHoundHelper::allowBlocking;\n    }\n+\n+   /**\n+    * Helper method that \"blocks\" as dictated by block hound but in actuality does nothing. This is useful to detect", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44be0b50d8c09a9abda7f81310ec8bf607752773"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3MTkzNA==", "bodyText": "I think it would have been better to say \"Wrap a publisher and subscribe to it in a blocking thread. If the returned publisher is subscribed in a non-blocking thread, it will also emit the wrapped publisher's elements on non-blocking threads, otherwise there is no guarantee.\"\nAlthough TBH I'm not sure if it's worth saying anything about the thread where the wrapped publisher's elements are emitted, since the whole point of using this method is that the caller doesn't know/care if it runs in a blocking thread or in a non-blocking thread.", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r479271934", "createdAt": "2020-08-28T13:09:35Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManager.java", "diffHunk": "@@ -174,10 +174,13 @@\n    <V> CompletionStage<V> continueOnNonBlockingThread(CompletionStage<V> delay, Object traceId);\n \n    /**\n-    * Provided a publisher that is known to block when subscribed to, this ensures that the publisher is subscribed\n-    * on the blocking executor and any values published are observed on a non blocking thread. Note that if a\n-    * blocking thread subscribes to the publisher these additional threads are not used and the entire Publisher\n-    * is subscribed and observed on the invoking thread.\n+    * Provided a publisher that is known to block when subscribed to. Thus if the thread that subscribes in a non", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44be0b50d8c09a9abda7f81310ec8bf607752773"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTI3OTY3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * a {@link CompletionStage} with a value of null which completes on a non-blocking thread. This method is designed\n          \n          \n            \n                * a {@link CompletionStage CompletionStage<Void>} which completes on a non-blocking thread. This method is designed\n          \n      \n    \n    \n  \n\nAlso, I'm not sure what qualifies as a side-effect for a publisher, but the one usage of this method has the same behaviour on Subscription.request(), not just on Publisher.subscribe().", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r479279670", "createdAt": "2020-08-28T13:18:04Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManager.java", "diffHunk": "@@ -186,7 +189,8 @@\n \n    /**\n     * Subscribes to the provided blocking publisher using the the blocking executor, ignoring all elements and returning\n-    * a {@link CompletionStage} with a value of null which completes on a non-blocking thread.\n+    * a {@link CompletionStage} with a value of null which completes on a non-blocking thread. This method is designed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44be0b50d8c09a9abda7f81310ec8bf607752773"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM4ODc1Mw==", "bodyText": "BlockingManager thinks the subscribe thread is non-blocking and the blocking executor is actually a mock that doesn't do anything, so I'm not sure how the implementation could make this assert fail.", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r571388753", "createdAt": "2021-02-06T09:03:31Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/util/concurrent/BlockingManagerTest.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.util.concurrent;\n+\n+import static org.testng.AssertJUnit.assertFalse;\n+import static org.testng.AssertJUnit.assertTrue;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+\n+import org.infinispan.commons.test.BlockHoundHelper;\n+import org.infinispan.test.AbstractInfinispanTest;\n+import org.infinispan.test.Mocks;\n+import org.mockito.Mockito;\n+import org.reactivestreams.Publisher;\n+import org.testng.annotations.Test;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+import io.reactivex.rxjava3.processors.AsyncProcessor;\n+import io.reactivex.rxjava3.processors.UnicastProcessor;\n+import io.reactivex.rxjava3.subscribers.TestSubscriber;\n+\n+@Test(groups = \"unit\", testName = \"util.concurrent.BlockingManagerTest\")\n+public class BlockingManagerTest extends AbstractInfinispanTest {\n+   Executor nonBlockingExecutor;\n+   Executor blockingExecutor;\n+\n+   public void initializeMocks() {\n+      nonBlockingExecutor = Mockito.mock(Executor.class, Mockito.withSettings()\n+            .defaultAnswer(Mocks.runWithExecutorAnswer(BlockHoundHelper.ensureNonBlockingExecutor())));\n+      blockingExecutor = Mockito.mock(Executor.class, Mockito.withSettings()\n+            .defaultAnswer(Mocks.runWithExecutorAnswer(BlockHoundHelper.allowBlockingExecutor())));\n+   }\n+\n+   private BlockingManager createBlockingManager(boolean blockingInvocation) {\n+      initializeMocks();\n+\n+      BlockingManagerImpl blockingManager = new BlockingManagerImpl() {\n+         @Override\n+         protected boolean isCurrentThreadBlocking() {\n+            return blockingInvocation;\n+         }\n+      };\n+\n+      blockingManager.nonBlockingExecutor = nonBlockingExecutor;\n+      blockingManager.blockingExecutor = blockingExecutor;\n+      blockingManager.start();\n+\n+      return blockingManager;\n+   }\n+\n+   public void testBlockingPublishToVoidStageInvokedBlockingThread() {\n+      BlockingManager blockingManager = createBlockingManager(true);\n+\n+      CompletionStage<Void> stage = blockingManager.blockingPublisherToVoidStage(Flowable.fromArray(new Object[] { 1, 2, 3 })\n+            .doOnNext(BlockHoundHelper::blockingConsume), null);\n+      assertTrue(CompletionStages.isCompletedSuccessfully(stage));\n+\n+      // We should not have used any executor as we were a blocking thread already\n+      Mockito.verifyZeroInteractions(nonBlockingExecutor, blockingExecutor);\n+   }\n+\n+   public void testBlockingPublishToVoidStageInvokedNonBlockingThread() {\n+      BlockingManager blockingManager = createBlockingManager(false);\n+\n+      CompletionStage<Void> stage = blockingManager.blockingPublisherToVoidStage(Flowable.just(1)\n+            .doOnNext(BlockHoundHelper::blockingConsume), null);\n+      assertTrue(CompletionStages.isCompletedSuccessfully(stage));\n+\n+      Mockito.verify(blockingExecutor).execute(Mockito.any());\n+      Mockito.verifyZeroInteractions(nonBlockingExecutor);\n+   }\n+\n+   public void testBlockingPublishToVoidStageInvokedNonBlockingThreadCompleteAfterSubscribe() {\n+      BlockingManager blockingManager = createBlockingManager(false);\n+\n+      AsyncProcessor<Object> processor = AsyncProcessor.create();\n+\n+      processor.onNext(1);\n+\n+      CompletionStage<Void> stage = blockingManager.blockingPublisherToVoidStage(processor\n+            .doOnNext(BlockHoundHelper::blockingConsume), null);\n+      assertFalse(CompletionStages.isCompletedSuccessfully(stage));\n+\n+      processor.onComplete();\n+\n+      assertTrue(CompletionStages.isCompletedSuccessfully(stage));\n+\n+      Mockito.verify(blockingExecutor).execute(Mockito.any());\n+      Mockito.verify(nonBlockingExecutor).execute(Mockito.any());\n+   }\n+\n+   public void testBlockingPublisherInvokedBlockingThread() {\n+      BlockingManager blockingManager = createBlockingManager(true);\n+\n+      Publisher<Integer> publisher = blockingManager.blockingPublisher(Flowable.just(1)\n+            .doOnNext(BlockHoundHelper::blockingConsume));\n+\n+      TestSubscriber<Integer> subscriber = TestSubscriber.create();\n+      publisher.subscribe(subscriber);\n+\n+      subscriber.assertComplete();\n+\n+      // We should not have used any executor as we were a blocking thread already\n+      Mockito.verifyZeroInteractions(nonBlockingExecutor, blockingExecutor);\n+   }\n+\n+   public void testBlockingPublisherInvokedBlockingThreadCompleteAfterSubscribe() {\n+      BlockingManager blockingManager = createBlockingManager(true);\n+\n+      AsyncProcessor<Integer> processor = AsyncProcessor.create();\n+\n+      processor.onNext(1);\n+\n+      Publisher<Integer> publisher = blockingManager.blockingPublisher(processor\n+            .doOnNext(BlockHoundHelper::blockingConsume));\n+\n+      TestSubscriber<Integer> subscriber = TestSubscriber.create();\n+      publisher.subscribe(subscriber);\n+\n+      subscriber.assertNotComplete();\n+\n+      processor.onComplete();\n+\n+      subscriber.assertComplete();\n+\n+      // We should not have used any executor as we were a blocking thread already for onNext and onComplete is done on\n+      // the invoking thread as it happened after publish\n+      Mockito.verifyZeroInteractions(nonBlockingExecutor, blockingExecutor);\n+   }\n+\n+   public void testBlockingPublisherInvokedNonBlockingThread() {\n+      BlockingManager blockingManager = createBlockingManager(false);\n+\n+      Publisher<Integer> publisher = blockingManager.blockingPublisher(Flowable.just(1)\n+            .doOnNext(BlockHoundHelper::blockingConsume));\n+\n+      TestSubscriber<Integer> subscriber = TestSubscriber.create();\n+      Flowable.fromPublisher(publisher)\n+            // We should observe any value of returned Publisher from `blockingPublisher` on a non blocking thread\n+            .doOnNext(ignore -> assertTrue(BlockHoundHelper.currentThreadRequiresNonBlocking()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44be0b50d8c09a9abda7f81310ec8bf607752773"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MTM4OTcwNg==", "bodyText": "Is there any particular reason for using AsyncProcessor (compared to e.g. UnicastProcess or PublishProcessor) and for calling processor.onNext(1) before subscribing?", "url": "https://github.com/infinispan/infinispan/pull/8637#discussion_r571389706", "createdAt": "2021-02-06T09:07:33Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/util/concurrent/BlockingManagerTest.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package org.infinispan.util.concurrent;\n+\n+import static org.testng.AssertJUnit.assertFalse;\n+import static org.testng.AssertJUnit.assertTrue;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+\n+import org.infinispan.commons.test.BlockHoundHelper;\n+import org.infinispan.test.AbstractInfinispanTest;\n+import org.infinispan.test.Mocks;\n+import org.mockito.Mockito;\n+import org.reactivestreams.Publisher;\n+import org.testng.annotations.Test;\n+\n+import io.reactivex.rxjava3.core.Flowable;\n+import io.reactivex.rxjava3.processors.AsyncProcessor;\n+import io.reactivex.rxjava3.processors.UnicastProcessor;\n+import io.reactivex.rxjava3.subscribers.TestSubscriber;\n+\n+@Test(groups = \"unit\", testName = \"util.concurrent.BlockingManagerTest\")\n+public class BlockingManagerTest extends AbstractInfinispanTest {\n+   Executor nonBlockingExecutor;\n+   Executor blockingExecutor;\n+\n+   public void initializeMocks() {\n+      nonBlockingExecutor = Mockito.mock(Executor.class, Mockito.withSettings()\n+            .defaultAnswer(Mocks.runWithExecutorAnswer(BlockHoundHelper.ensureNonBlockingExecutor())));\n+      blockingExecutor = Mockito.mock(Executor.class, Mockito.withSettings()\n+            .defaultAnswer(Mocks.runWithExecutorAnswer(BlockHoundHelper.allowBlockingExecutor())));\n+   }\n+\n+   private BlockingManager createBlockingManager(boolean blockingInvocation) {\n+      initializeMocks();\n+\n+      BlockingManagerImpl blockingManager = new BlockingManagerImpl() {\n+         @Override\n+         protected boolean isCurrentThreadBlocking() {\n+            return blockingInvocation;\n+         }\n+      };\n+\n+      blockingManager.nonBlockingExecutor = nonBlockingExecutor;\n+      blockingManager.blockingExecutor = blockingExecutor;\n+      blockingManager.start();\n+\n+      return blockingManager;\n+   }\n+\n+   public void testBlockingPublishToVoidStageInvokedBlockingThread() {\n+      BlockingManager blockingManager = createBlockingManager(true);\n+\n+      CompletionStage<Void> stage = blockingManager.blockingPublisherToVoidStage(Flowable.fromArray(new Object[] { 1, 2, 3 })\n+            .doOnNext(BlockHoundHelper::blockingConsume), null);\n+      assertTrue(CompletionStages.isCompletedSuccessfully(stage));\n+\n+      // We should not have used any executor as we were a blocking thread already\n+      Mockito.verifyZeroInteractions(nonBlockingExecutor, blockingExecutor);\n+   }\n+\n+   public void testBlockingPublishToVoidStageInvokedNonBlockingThread() {\n+      BlockingManager blockingManager = createBlockingManager(false);\n+\n+      CompletionStage<Void> stage = blockingManager.blockingPublisherToVoidStage(Flowable.just(1)\n+            .doOnNext(BlockHoundHelper::blockingConsume), null);\n+      assertTrue(CompletionStages.isCompletedSuccessfully(stage));\n+\n+      Mockito.verify(blockingExecutor).execute(Mockito.any());\n+      Mockito.verifyZeroInteractions(nonBlockingExecutor);\n+   }\n+\n+   public void testBlockingPublishToVoidStageInvokedNonBlockingThreadCompleteAfterSubscribe() {\n+      BlockingManager blockingManager = createBlockingManager(false);\n+\n+      AsyncProcessor<Object> processor = AsyncProcessor.create();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44be0b50d8c09a9abda7f81310ec8bf607752773"}, "originalPosition": 75}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 431, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}