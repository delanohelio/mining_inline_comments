{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyNzc0MzQy", "number": 8193, "title": "ISPN-11632 Address comments in ISPN-10457", "bodyText": "https://issues.redhat.com/browse/ISPN-11632", "createdAt": "2020-04-13T18:28:14Z", "url": "https://github.com/infinispan/infinispan/pull/8193", "merged": true, "mergeCommit": {"oid": "84fa89c546fe95886af68db58e85f4145dabcd43"}, "closed": true, "closedAt": "2020-07-31T14:06:49Z", "author": {"login": "wburns"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcdCTnHgBqjMyOTMyOTMwMzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcqOSgPgBqjM0MzQxNTU5MjI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "66ecd6f1c9acffeccd44ca3df97398180d0391df", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/66ecd6f1c9acffeccd44ca3df97398180d0391df", "committedDate": "2020-04-13T18:26:24Z", "message": "ISPN-11632 Address comments in ISPN-10457"}, "afterCommit": {"oid": "9803878003f281ea1cc92ae65955cdc84edf7644", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/9803878003f281ea1cc92ae65955cdc84edf7644", "committedDate": "2020-05-01T14:10:58Z", "message": "ISPN-11632 Address comments in ISPN-10457"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4ODE3OTM2", "url": "https://github.com/infinispan/infinispan/pull/8193#pullrequestreview-428817936", "createdAt": "2020-06-11T11:22:11Z", "commit": {"oid": "9803878003f281ea1cc92ae65955cdc84edf7644"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMToyMjoxMVrOGiZC0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxMjoyNDoxOFrOGiayxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODcxNTA4OA==", "bodyText": "IntelliJ says the type parameters are not needed", "url": "https://github.com/infinispan/infinispan/pull/8193#discussion_r438715088", "createdAt": "2020-06-11T11:22:11Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/filter/CacheFilters.java", "diffHunk": "@@ -51,14 +52,42 @@ private CacheFilters() { }\n     * @param converter the converter to utilize\n     * @param <K> key type\n     * @param <V> value type\n-    * @param <C> convertered value type\n+    * @param <C> converted value type\n     * @return function based on the converter\n     */\n    public static <K, V, C> Function<CacheEntry<K, V>, CacheEntry<K, C>> function(\n            Converter<? super K, ? super V, C> converter) {\n       return new ConverterAsCacheEntryFunction<>(converter);\n    }\n \n+   /**\n+    * Creates a new {@link Function} using the provided filter convert. The {@link KeyValueFilterConverter#filterAndConvert(Object, Object, Metadata)}\n+    * is invoked for every passed in CacheEntry. When a null value is returned from the filter converter instead of\n+    * a null {@link CacheEntry} being returned, we instead return the {@link NullCacheEntry} as a sign of it. This\n+    * allows this {@link Function} to be used in cases when a null value cannot be returned, such as reactive streams.\n+    * <p>\n+    * The {@link #notNullCacheEntryPredicate()} can be used to filter these values if needed.\n+    * @param filterConverter the filter converter to utilize\n+    * @param <K> key type\n+    * @param <V> value type\n+    * @param <C> converted value type\n+    * @return function based on the filter converter\n+    */\n+   public static <K, V, C> Function<CacheEntry<K, V>, CacheEntry<K, C>> converterToFunction(KeyValueFilterConverter<? super K, ? super V, C> filterConverter) {\n+      return new FilterConverterAsCacheEntryFunction<K, V, C>(filterConverter);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9803878003f281ea1cc92ae65955cdc84edf7644"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODczNjQ0Mg==", "bodyText": "Wouldn't something like this also work, while being easier to read?\n      currentStage = currentStage.thenCompose(ignore ->\n            Flowable.fromPublisher(p)\n                  .startWith(Completable.defer(() -> Completable.fromCompletionStage(handler.delayProcessing())))\n                  .filter(ice -> handler.markKeyAsProcessing(ice.getKey()) != QueueingSegmentListener.REMOVED)\n                  .concatMapSingle(ice -> Single.fromCompletionStage(\n                        raiseEventForInitialTransfer(generatedId, ice, l.clustered(), kc, kv)))\n                  // Only request up to 20 at a time\n                  .rebatchRequests(20)\n                  // Ignore the actual values\n                  .ignoreElements()\n                  // Make sure there are no more delays for processing after all the events have been raised\n                  .andThen(Completable.defer(() -> Completable.fromCompletionStage(handler.delayProcessing())))\n                  .toCompletionStage(null)\n      );\nI'm not 100% sure whether startWith is enough, or whether delay is still needed at that step. In any case, please add a short comment to explain what it's doing.", "url": "https://github.com/infinispan/infinispan/pull/8193#discussion_r438736442", "createdAt": "2020-06-11T12:09:19Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/notifications/cachelistener/CacheNotifierImpl.java", "diffHunk": "@@ -1111,36 +1108,36 @@ public boolean isNotificationAllowed(FlagAffectedCommand cmd, List<CacheEntryLis\n    }\n \n    private CompletionStage<Void> handlePublisher(CompletionStage<Void> currentStage,\n-         Queue<IntermediateOperation> intermediateOperations, QueueingSegmentListener<K, V, ? extends Event<K, V>> handler,\n+         Collection<IntermediateOperation<?, ?, ?, ?>> intermediateOperations, QueueingSegmentListener<K, V, ? extends Event<K, V>> handler,\n          UUID generatedId, Listener l, Function<Object, Object> kc, Function<Object, Object> kv) {\n       SegmentCompletionPublisher<CacheEntry<K, V>> publisher = publisherManager.running().entryPublisher(\n             null, null, null, true,\n             // TODO: do we really need EXACTLY_ONCE? AT_LEAST_ONCE should be fine I think\n             DeliveryGuarantee.EXACTLY_ONCE, config.clustering().stateTransfer().chunkSize(),\n             intermediateOperations.isEmpty() ? PublisherTransformers.identity() : new CacheIntermediatePublisher(intermediateOperations));\n \n-      io.reactivex.rxjava3.functions.Function<Object, ? extends Publisher<Void>> itemDelayFunction = ice -> {\n-         CompletionStage<Void> delay = handler.delayProcessing();\n-         if (CompletionStages.isCompletedSuccessfully(delay)) {\n-            return Flowable.empty();\n-         }\n-         return Completable.fromCompletionStage(delay).toFlowable();\n-      };\n+      io.reactivex.rxjava3.functions.Function<Object, ? extends Publisher<Void>> itemDelayFunction = ice ->\n+         RxJavaInterop.voidCompletionStageToFlowable(handler.delayProcessing());\n+\n       Publisher<CacheEntry<K, V>> p = s -> publisher.subscribe(s, handler);\n-      currentStage = Flowable.fromPublisher(p)\n-            .delaySubscription(Completable.fromCompletionStage(currentStage).toFlowable())\n-            .delay(itemDelayFunction)\n-            .filter(ice -> handler.markKeyAsProcessing(ice.getKey()) != QueueingSegmentListener.REMOVED)\n-            .delay(ice -> Completable.fromCompletionStage(raiseEventForInitialTransfer(generatedId, ice, l.clustered(),\n-                  kc, kv)).toFlowable())\n-            // Only request up to 20 at a time\n-            .rebatchRequests(20)\n-            .count()\n-            .toFlowable()\n-            // Make sure there are no more delays for processing after we have retrieved all values\n-            .delay(itemDelayFunction)\n-            .ignoreElements()\n-            .toCompletionStage(null);\n+\n+      currentStage = currentStage.thenCompose(ignore ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9803878003f281ea1cc92ae65955cdc84edf7644"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc0Mzc1MA==", "bodyText": "Please also change the other methods below\nE.g.\n      Flowable<?> innerPublisher = Flowable.fromPublisher(objectPublisher);\n      for (IntermediateOperation<?, ?, ?, ?> intOp : intOps) {\n         innerPublisher = intOp.mapFlowable((Flowable) innerPublisher);\n      }\nstill has 2 unchecked warnings, but IMO it's clearer why those warnings cannot be avoided: because the type system can't express a chain of IntermediateOperations mapping Object -> X -> Y -> ... -> R).", "url": "https://github.com/infinispan/infinispan/pull/8193#discussion_r438743750", "createdAt": "2020-06-11T12:24:18Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/stream/impl/CacheIntermediatePublisher.java", "diffHunk": "@@ -26,9 +25,9 @@\n  * @param <R>\n  */\n public final class CacheIntermediatePublisher<R> implements ModifiedValueFunction<Publisher<Object>, Publisher<R>>, InjectableComponent {\n-   private final Queue<IntermediateOperation> intOps;\n+   private final Iterable<IntermediateOperation<?, ?, ?, ?>> intOps;\n \n-   public CacheIntermediatePublisher(Queue<IntermediateOperation> intOps) {\n+   public CacheIntermediatePublisher(Iterable<IntermediateOperation<?, ?, ?, ?>> intOps) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9803878003f281ea1cc92ae65955cdc84edf7644"}, "originalPosition": 16}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9803878003f281ea1cc92ae65955cdc84edf7644", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/9803878003f281ea1cc92ae65955cdc84edf7644", "committedDate": "2020-05-01T14:10:58Z", "message": "ISPN-11632 Address comments in ISPN-10457"}, "afterCommit": {"oid": "4b4fddcb177c246c1811cdcce75299ba0d5f3d68", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/4b4fddcb177c246c1811cdcce75299ba0d5f3d68", "committedDate": "2020-06-11T13:03:12Z", "message": "ISPN-11632 Address comments in ISPN-10457"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fab93fff2113826cb4f3a8a9f6df2d771502608", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/9fab93fff2113826cb4f3a8a9f6df2d771502608", "committedDate": "2020-06-11T13:29:41Z", "message": "ISPN-11632 Address comments in ISPN-10457"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4b4fddcb177c246c1811cdcce75299ba0d5f3d68", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/4b4fddcb177c246c1811cdcce75299ba0d5f3d68", "committedDate": "2020-06-11T13:03:12Z", "message": "ISPN-11632 Address comments in ISPN-10457"}, "afterCommit": {"oid": "9fab93fff2113826cb4f3a8a9f6df2d771502608", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/9fab93fff2113826cb4f3a8a9f6df2d771502608", "committedDate": "2020-06-11T13:29:41Z", "message": "ISPN-11632 Address comments in ISPN-10457"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 852, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}