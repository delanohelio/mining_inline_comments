{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5NDIzOTg3", "number": 7946, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTozMDozMlrODj2lNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTo0MzowOFrODj25QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTIxMDEyOnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTozMDozMlrOFv460w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwOTozMDoyOFrOFwYnDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1OTk1NQ==", "bodyText": "I would add the keys directly to ReplKeyTracker. You are creating a new HashSet here and when you instantiate the ReplKeyTracker.", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385759955", "createdAt": "2020-02-28T15:30:32Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "diffHunk": "@@ -40,20 +42,38 @@ public SegmentKeyTracker(DataFormat dataFormat, SegmentConsistentHash segmentCon\n       segmentStream.forEach(i -> keysPerSegment.set(i, new HashSet<>()));\n    }\n \n+   private Set<WrappedByteArray> drainKeys() {\n+      Set<WrappedByteArray> trackedKeys = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3MjQ4OA==", "bodyText": "Since you mentioned...I think I can remove this repl tracker altogether", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385772488", "createdAt": "2020-02-28T15:51:01Z", "author": {"login": "gustavonalle"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "diffHunk": "@@ -40,20 +42,38 @@ public SegmentKeyTracker(DataFormat dataFormat, SegmentConsistentHash segmentCon\n       segmentStream.forEach(i -> keysPerSegment.set(i, new HashSet<>()));\n    }\n \n+   private Set<WrappedByteArray> drainKeys() {\n+      Set<WrappedByteArray> trackedKeys = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1OTk1NQ=="}, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjI2NTE1NQ==", "bodyText": "... and you can use keyOnlyTracker directly :) instead of creating a new HashSet.", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r386265155", "createdAt": "2020-03-02T09:01:16Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "diffHunk": "@@ -40,20 +42,38 @@ public SegmentKeyTracker(DataFormat dataFormat, SegmentConsistentHash segmentCon\n       segmentStream.forEach(i -> keysPerSegment.set(i, new HashSet<>()));\n    }\n \n+   private Set<WrappedByteArray> drainKeys() {\n+      Set<WrappedByteArray> trackedKeys = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1OTk1NQ=="}, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjI2NjAzOA==", "bodyText": "sure, forgot to remove it", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r386266038", "createdAt": "2020-03-02T09:03:14Z", "author": {"login": "gustavonalle"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "diffHunk": "@@ -40,20 +42,38 @@ public SegmentKeyTracker(DataFormat dataFormat, SegmentConsistentHash segmentCon\n       segmentStream.forEach(i -> keysPerSegment.set(i, new HashSet<>()));\n    }\n \n+   private Set<WrappedByteArray> drainKeys() {\n+      Set<WrappedByteArray> trackedKeys = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1OTk1NQ=="}, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjI3OTE4MQ==", "bodyText": "changed", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r386279181", "createdAt": "2020-03-02T09:30:28Z", "author": {"login": "gustavonalle"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "diffHunk": "@@ -40,20 +42,38 @@ public SegmentKeyTracker(DataFormat dataFormat, SegmentConsistentHash segmentCon\n       segmentStream.forEach(i -> keysPerSegment.set(i, new HashSet<>()));\n    }\n \n+   private Set<WrappedByteArray> drainKeys() {\n+      Set<WrappedByteArray> trackedKeys = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1OTk1NQ=="}, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTIxNDU4OnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTozMTozMVrOFv49dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTo1NDozM1rOFv5ztQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2MDYyOA==", "bodyText": "not sure how this class is used but... can we have an NPE here?\nyou are setting trackSegments before instantiating keyOnlyTracker", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385760628", "createdAt": "2020-02-28T15:31:31Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "diffHunk": "@@ -40,20 +42,38 @@ public SegmentKeyTracker(DataFormat dataFormat, SegmentConsistentHash segmentCon\n       segmentStream.forEach(i -> keysPerSegment.set(i, new HashSet<>()));\n    }\n \n+   private Set<WrappedByteArray> drainKeys() {\n+      Set<WrappedByteArray> trackedKeys = new HashSet<>();\n+      for (int i = 0; i < keysPerSegment.length(); i++) {\n+         Set<WrappedByteArray> keys = keysPerSegment.get(i);\n+         if (keys != null) trackedKeys.addAll(keys);\n+         keysPerSegment.set(i, null);\n+      }\n+\n+      return trackedKeys;\n+   }\n+\n    public boolean track(byte[] key, short status, ClassWhiteList whitelist) {\n+      if (!trackSegments) {\n+         return keyOnlyTracker.track(key, status, whitelist);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3NDUxNw==", "bodyText": "This class is not supposed to be called by more than 1 thread, it's involved for each iteration result read from the server", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385774517", "createdAt": "2020-02-28T15:54:33Z", "author": {"login": "gustavonalle"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "diffHunk": "@@ -40,20 +42,38 @@ public SegmentKeyTracker(DataFormat dataFormat, SegmentConsistentHash segmentCon\n       segmentStream.forEach(i -> keysPerSegment.set(i, new HashSet<>()));\n    }\n \n+   private Set<WrappedByteArray> drainKeys() {\n+      Set<WrappedByteArray> trackedKeys = new HashSet<>();\n+      for (int i = 0; i < keysPerSegment.length(); i++) {\n+         Set<WrappedByteArray> keys = keysPerSegment.get(i);\n+         if (keys != null) trackedKeys.addAll(keys);\n+         keysPerSegment.set(i, null);\n+      }\n+\n+      return trackedKeys;\n+   }\n+\n    public boolean track(byte[] key, short status, ClassWhiteList whitelist) {\n+      if (!trackSegments) {\n+         return keyOnlyTracker.track(key, status, whitelist);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2MDYyOA=="}, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTIyNjQyOnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTozNDoyNFrOFv5Ejw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTozNDoyNFrOFv5Ejw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2MjQ0Nw==", "bodyText": "nitpick: if (trackeSegments && finishedSegments != null)", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385762447", "createdAt": "2020-02-28T15:34:24Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/iteration/SegmentKeyTracker.java", "diffHunk": "@@ -66,11 +86,13 @@ public boolean track(byte[] key, short status, ClassWhiteList whitelist) {\n    }\n \n    public void segmentsFinished(byte[] finishedSegments) {\n-      if (finishedSegments != null) {\n-         BitSet bitSet = BitSet.valueOf(finishedSegments);\n-         if (trace)\n-            log.tracef(\"Removing completed segments %s\", bitSet);\n-         bitSet.stream().forEach(seg -> keysPerSegment.set(seg, null));\n+      if (trackSegments) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTIzNzMwOnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/StorageRoutingTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTozNzowNlrOFv5K7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTo1NjozNFrOFv54bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NDA3OQ==", "bodyText": "any reason to use AtomicInteger? a boolean would be enough IMO :)", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385764079", "createdAt": "2020-02-28T15:37:06Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/StorageRoutingTest.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.client.hotrod;\n+\n+import static org.infinispan.configuration.cache.StorageType.BINARY;\n+import static org.infinispan.configuration.cache.StorageType.OBJECT;\n+import static org.infinispan.configuration.cache.StorageType.OFF_HEAP;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.hotrod.test.FixedServerBalancing;\n+import org.infinispan.client.hotrod.test.MultiHotRodServersTest;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.cache.StorageType;\n+import org.infinispan.server.hotrod.HotRodServer;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Tests that the Hot Rod client can correctly route requests to a server using different {@link StorageType}.\n+ *\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\", testName = \"client.hotrod.StorageRoutingTest\")\n+public class StorageRoutingTest extends MultiHotRodServersTest {\n+\n+   private static final int CLUSTER_SIZE = 3;\n+\n+   protected StorageType storageType;\n+   private Object key;\n+\n+   public Object[] factory() {\n+      String stringKey = \"key\";\n+      byte[] byteArrayKey = new byte[]{1, 2, 3};\n+\n+      return new Object[]{\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(byteArrayKey)\n+      };\n+   }\n+\n+   protected String[] parameterNames() {\n+      return new String[]{\"storage\", \"key\"};\n+   }\n+\n+   protected Object[] parameterValues() {\n+      return new Object[]{storageType, key};\n+   }\n+\n+   private StorageRoutingTest withStorageType(StorageType storageType) {\n+      this.storageType = storageType;\n+      return this;\n+   }\n+\n+   private StorageRoutingTest withKey(Object key) {\n+      this.key = key;\n+      return this;\n+   }\n+\n+   @Override\n+   protected void createCacheManagers() throws Throwable {\n+      ConfigurationBuilder cfgBuilder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      cfgBuilder.jmxStatistics().enable();\n+      cfgBuilder.clustering().hash().numOwners(1);\n+      cfgBuilder.memory().storageType(storageType);\n+      createHotRodServers(CLUSTER_SIZE, cfgBuilder);\n+      waitForClusterToForm();\n+   }\n+\n+   @Override\n+   protected org.infinispan.client.hotrod.configuration.ConfigurationBuilder createHotRodClientConfigurationBuilder(HotRodServer hotRodServer) {\n+      org.infinispan.client.hotrod.configuration.ConfigurationBuilder hotRodClientConfigurationBuilder = super.createHotRodClientConfigurationBuilder(hotRodServer);\n+      hotRodClientConfigurationBuilder.balancingStrategy(() -> new FixedServerBalancing(hotRodServer));\n+      return hotRodClientConfigurationBuilder;\n+   }\n+\n+   @Test\n+   public void shouldContactKeyOwnerForPutGet() {\n+      String value = \"value\";\n+      RemoteCache<Object, String> remoteCache = clients.get(0).getCache();\n+      remoteCache.put(key, value);\n+\n+      assertEquals(remoteCache.get(key), \"value\");\n+\n+      assertCorrectServerContacted();\n+   }\n+\n+   private void assertCorrectServerContacted() {\n+      AtomicInteger storedIn = new AtomicInteger(-1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3MTY4Nw==", "bodyText": "conciseness only", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385771687", "createdAt": "2020-02-28T15:49:38Z", "author": {"login": "gustavonalle"}, "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/StorageRoutingTest.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.client.hotrod;\n+\n+import static org.infinispan.configuration.cache.StorageType.BINARY;\n+import static org.infinispan.configuration.cache.StorageType.OBJECT;\n+import static org.infinispan.configuration.cache.StorageType.OFF_HEAP;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.hotrod.test.FixedServerBalancing;\n+import org.infinispan.client.hotrod.test.MultiHotRodServersTest;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.cache.StorageType;\n+import org.infinispan.server.hotrod.HotRodServer;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Tests that the Hot Rod client can correctly route requests to a server using different {@link StorageType}.\n+ *\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\", testName = \"client.hotrod.StorageRoutingTest\")\n+public class StorageRoutingTest extends MultiHotRodServersTest {\n+\n+   private static final int CLUSTER_SIZE = 3;\n+\n+   protected StorageType storageType;\n+   private Object key;\n+\n+   public Object[] factory() {\n+      String stringKey = \"key\";\n+      byte[] byteArrayKey = new byte[]{1, 2, 3};\n+\n+      return new Object[]{\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(byteArrayKey)\n+      };\n+   }\n+\n+   protected String[] parameterNames() {\n+      return new String[]{\"storage\", \"key\"};\n+   }\n+\n+   protected Object[] parameterValues() {\n+      return new Object[]{storageType, key};\n+   }\n+\n+   private StorageRoutingTest withStorageType(StorageType storageType) {\n+      this.storageType = storageType;\n+      return this;\n+   }\n+\n+   private StorageRoutingTest withKey(Object key) {\n+      this.key = key;\n+      return this;\n+   }\n+\n+   @Override\n+   protected void createCacheManagers() throws Throwable {\n+      ConfigurationBuilder cfgBuilder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      cfgBuilder.jmxStatistics().enable();\n+      cfgBuilder.clustering().hash().numOwners(1);\n+      cfgBuilder.memory().storageType(storageType);\n+      createHotRodServers(CLUSTER_SIZE, cfgBuilder);\n+      waitForClusterToForm();\n+   }\n+\n+   @Override\n+   protected org.infinispan.client.hotrod.configuration.ConfigurationBuilder createHotRodClientConfigurationBuilder(HotRodServer hotRodServer) {\n+      org.infinispan.client.hotrod.configuration.ConfigurationBuilder hotRodClientConfigurationBuilder = super.createHotRodClientConfigurationBuilder(hotRodServer);\n+      hotRodClientConfigurationBuilder.balancingStrategy(() -> new FixedServerBalancing(hotRodServer));\n+      return hotRodClientConfigurationBuilder;\n+   }\n+\n+   @Test\n+   public void shouldContactKeyOwnerForPutGet() {\n+      String value = \"value\";\n+      RemoteCache<Object, String> remoteCache = clients.get(0).getCache();\n+      remoteCache.put(key, value);\n+\n+      assertEquals(remoteCache.get(key), \"value\");\n+\n+      assertCorrectServerContacted();\n+   }\n+\n+   private void assertCorrectServerContacted() {\n+      AtomicInteger storedIn = new AtomicInteger(-1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NDA3OQ=="}, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3NTcyNQ==", "bodyText": "ah! I missed the last assert assertEquals(storeServer, retrieveServer, ...) just ignore my comment.", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385775725", "createdAt": "2020-02-28T15:56:34Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/StorageRoutingTest.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.client.hotrod;\n+\n+import static org.infinispan.configuration.cache.StorageType.BINARY;\n+import static org.infinispan.configuration.cache.StorageType.OBJECT;\n+import static org.infinispan.configuration.cache.StorageType.OFF_HEAP;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.hotrod.test.FixedServerBalancing;\n+import org.infinispan.client.hotrod.test.MultiHotRodServersTest;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.cache.StorageType;\n+import org.infinispan.server.hotrod.HotRodServer;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Tests that the Hot Rod client can correctly route requests to a server using different {@link StorageType}.\n+ *\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\", testName = \"client.hotrod.StorageRoutingTest\")\n+public class StorageRoutingTest extends MultiHotRodServersTest {\n+\n+   private static final int CLUSTER_SIZE = 3;\n+\n+   protected StorageType storageType;\n+   private Object key;\n+\n+   public Object[] factory() {\n+      String stringKey = \"key\";\n+      byte[] byteArrayKey = new byte[]{1, 2, 3};\n+\n+      return new Object[]{\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(byteArrayKey)\n+      };\n+   }\n+\n+   protected String[] parameterNames() {\n+      return new String[]{\"storage\", \"key\"};\n+   }\n+\n+   protected Object[] parameterValues() {\n+      return new Object[]{storageType, key};\n+   }\n+\n+   private StorageRoutingTest withStorageType(StorageType storageType) {\n+      this.storageType = storageType;\n+      return this;\n+   }\n+\n+   private StorageRoutingTest withKey(Object key) {\n+      this.key = key;\n+      return this;\n+   }\n+\n+   @Override\n+   protected void createCacheManagers() throws Throwable {\n+      ConfigurationBuilder cfgBuilder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      cfgBuilder.jmxStatistics().enable();\n+      cfgBuilder.clustering().hash().numOwners(1);\n+      cfgBuilder.memory().storageType(storageType);\n+      createHotRodServers(CLUSTER_SIZE, cfgBuilder);\n+      waitForClusterToForm();\n+   }\n+\n+   @Override\n+   protected org.infinispan.client.hotrod.configuration.ConfigurationBuilder createHotRodClientConfigurationBuilder(HotRodServer hotRodServer) {\n+      org.infinispan.client.hotrod.configuration.ConfigurationBuilder hotRodClientConfigurationBuilder = super.createHotRodClientConfigurationBuilder(hotRodServer);\n+      hotRodClientConfigurationBuilder.balancingStrategy(() -> new FixedServerBalancing(hotRodServer));\n+      return hotRodClientConfigurationBuilder;\n+   }\n+\n+   @Test\n+   public void shouldContactKeyOwnerForPutGet() {\n+      String value = \"value\";\n+      RemoteCache<Object, String> remoteCache = clients.get(0).getCache();\n+      remoteCache.put(key, value);\n+\n+      assertEquals(remoteCache.get(key), \"value\");\n+\n+      assertCorrectServerContacted();\n+   }\n+\n+   private void assertCorrectServerContacted() {\n+      AtomicInteger storedIn = new AtomicInteger(-1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NDA3OQ=="}, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTI2MTQ0OnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/StorageRoutingTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTo0MzowOFrOFv5ZmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNjowMDo0M1rOFv6Bvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NzgzMw==", "bodyText": "I'm not sure I understand why you use the FixedServerBalancing. Isn't it force the requests to go to this server?", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385767833", "createdAt": "2020-02-28T15:43:08Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/StorageRoutingTest.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.client.hotrod;\n+\n+import static org.infinispan.configuration.cache.StorageType.BINARY;\n+import static org.infinispan.configuration.cache.StorageType.OBJECT;\n+import static org.infinispan.configuration.cache.StorageType.OFF_HEAP;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.hotrod.test.FixedServerBalancing;\n+import org.infinispan.client.hotrod.test.MultiHotRodServersTest;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.cache.StorageType;\n+import org.infinispan.server.hotrod.HotRodServer;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Tests that the Hot Rod client can correctly route requests to a server using different {@link StorageType}.\n+ *\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\", testName = \"client.hotrod.StorageRoutingTest\")\n+public class StorageRoutingTest extends MultiHotRodServersTest {\n+\n+   private static final int CLUSTER_SIZE = 3;\n+\n+   protected StorageType storageType;\n+   private Object key;\n+\n+   public Object[] factory() {\n+      String stringKey = \"key\";\n+      byte[] byteArrayKey = new byte[]{1, 2, 3};\n+\n+      return new Object[]{\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(byteArrayKey)\n+      };\n+   }\n+\n+   protected String[] parameterNames() {\n+      return new String[]{\"storage\", \"key\"};\n+   }\n+\n+   protected Object[] parameterValues() {\n+      return new Object[]{storageType, key};\n+   }\n+\n+   private StorageRoutingTest withStorageType(StorageType storageType) {\n+      this.storageType = storageType;\n+      return this;\n+   }\n+\n+   private StorageRoutingTest withKey(Object key) {\n+      this.key = key;\n+      return this;\n+   }\n+\n+   @Override\n+   protected void createCacheManagers() throws Throwable {\n+      ConfigurationBuilder cfgBuilder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      cfgBuilder.jmxStatistics().enable();\n+      cfgBuilder.clustering().hash().numOwners(1);\n+      cfgBuilder.memory().storageType(storageType);\n+      createHotRodServers(CLUSTER_SIZE, cfgBuilder);\n+      waitForClusterToForm();\n+   }\n+\n+   @Override\n+   protected org.infinispan.client.hotrod.configuration.ConfigurationBuilder createHotRodClientConfigurationBuilder(HotRodServer hotRodServer) {\n+      org.infinispan.client.hotrod.configuration.ConfigurationBuilder hotRodClientConfigurationBuilder = super.createHotRodClientConfigurationBuilder(hotRodServer);\n+      hotRodClientConfigurationBuilder.balancingStrategy(() -> new FixedServerBalancing(hotRodServer));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3MDk4MA==", "bodyText": "I want to have a client connecting to a specific sever to be able to read local statistics and do the test assertions", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385770980", "createdAt": "2020-02-28T15:48:22Z", "author": {"login": "gustavonalle"}, "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/StorageRoutingTest.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.client.hotrod;\n+\n+import static org.infinispan.configuration.cache.StorageType.BINARY;\n+import static org.infinispan.configuration.cache.StorageType.OBJECT;\n+import static org.infinispan.configuration.cache.StorageType.OFF_HEAP;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.hotrod.test.FixedServerBalancing;\n+import org.infinispan.client.hotrod.test.MultiHotRodServersTest;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.cache.StorageType;\n+import org.infinispan.server.hotrod.HotRodServer;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Tests that the Hot Rod client can correctly route requests to a server using different {@link StorageType}.\n+ *\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\", testName = \"client.hotrod.StorageRoutingTest\")\n+public class StorageRoutingTest extends MultiHotRodServersTest {\n+\n+   private static final int CLUSTER_SIZE = 3;\n+\n+   protected StorageType storageType;\n+   private Object key;\n+\n+   public Object[] factory() {\n+      String stringKey = \"key\";\n+      byte[] byteArrayKey = new byte[]{1, 2, 3};\n+\n+      return new Object[]{\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(byteArrayKey)\n+      };\n+   }\n+\n+   protected String[] parameterNames() {\n+      return new String[]{\"storage\", \"key\"};\n+   }\n+\n+   protected Object[] parameterValues() {\n+      return new Object[]{storageType, key};\n+   }\n+\n+   private StorageRoutingTest withStorageType(StorageType storageType) {\n+      this.storageType = storageType;\n+      return this;\n+   }\n+\n+   private StorageRoutingTest withKey(Object key) {\n+      this.key = key;\n+      return this;\n+   }\n+\n+   @Override\n+   protected void createCacheManagers() throws Throwable {\n+      ConfigurationBuilder cfgBuilder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      cfgBuilder.jmxStatistics().enable();\n+      cfgBuilder.clustering().hash().numOwners(1);\n+      cfgBuilder.memory().storageType(storageType);\n+      createHotRodServers(CLUSTER_SIZE, cfgBuilder);\n+      waitForClusterToForm();\n+   }\n+\n+   @Override\n+   protected org.infinispan.client.hotrod.configuration.ConfigurationBuilder createHotRodClientConfigurationBuilder(HotRodServer hotRodServer) {\n+      org.infinispan.client.hotrod.configuration.ConfigurationBuilder hotRodClientConfigurationBuilder = super.createHotRodClientConfigurationBuilder(hotRodServer);\n+      hotRodClientConfigurationBuilder.balancingStrategy(() -> new FixedServerBalancing(hotRodServer));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NzgzMw=="}, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3NjI3MA==", "bodyText": "The test is verifying that, for a certain server, if the entry was both stored and retrieved from it", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385776270", "createdAt": "2020-02-28T15:57:32Z", "author": {"login": "gustavonalle"}, "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/StorageRoutingTest.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.client.hotrod;\n+\n+import static org.infinispan.configuration.cache.StorageType.BINARY;\n+import static org.infinispan.configuration.cache.StorageType.OBJECT;\n+import static org.infinispan.configuration.cache.StorageType.OFF_HEAP;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.hotrod.test.FixedServerBalancing;\n+import org.infinispan.client.hotrod.test.MultiHotRodServersTest;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.cache.StorageType;\n+import org.infinispan.server.hotrod.HotRodServer;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Tests that the Hot Rod client can correctly route requests to a server using different {@link StorageType}.\n+ *\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\", testName = \"client.hotrod.StorageRoutingTest\")\n+public class StorageRoutingTest extends MultiHotRodServersTest {\n+\n+   private static final int CLUSTER_SIZE = 3;\n+\n+   protected StorageType storageType;\n+   private Object key;\n+\n+   public Object[] factory() {\n+      String stringKey = \"key\";\n+      byte[] byteArrayKey = new byte[]{1, 2, 3};\n+\n+      return new Object[]{\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(byteArrayKey)\n+      };\n+   }\n+\n+   protected String[] parameterNames() {\n+      return new String[]{\"storage\", \"key\"};\n+   }\n+\n+   protected Object[] parameterValues() {\n+      return new Object[]{storageType, key};\n+   }\n+\n+   private StorageRoutingTest withStorageType(StorageType storageType) {\n+      this.storageType = storageType;\n+      return this;\n+   }\n+\n+   private StorageRoutingTest withKey(Object key) {\n+      this.key = key;\n+      return this;\n+   }\n+\n+   @Override\n+   protected void createCacheManagers() throws Throwable {\n+      ConfigurationBuilder cfgBuilder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      cfgBuilder.jmxStatistics().enable();\n+      cfgBuilder.clustering().hash().numOwners(1);\n+      cfgBuilder.memory().storageType(storageType);\n+      createHotRodServers(CLUSTER_SIZE, cfgBuilder);\n+      waitForClusterToForm();\n+   }\n+\n+   @Override\n+   protected org.infinispan.client.hotrod.configuration.ConfigurationBuilder createHotRodClientConfigurationBuilder(HotRodServer hotRodServer) {\n+      org.infinispan.client.hotrod.configuration.ConfigurationBuilder hotRodClientConfigurationBuilder = super.createHotRodClientConfigurationBuilder(hotRodServer);\n+      hotRodClientConfigurationBuilder.balancingStrategy(() -> new FixedServerBalancing(hotRodServer));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NzgzMw=="}, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc3ODExMQ==", "bodyText": "makes sense now \ud83d\udc4d", "url": "https://github.com/infinispan/infinispan/pull/7946#discussion_r385778111", "createdAt": "2020-02-28T16:00:43Z", "author": {"login": "pruivo"}, "path": "client/hotrod-client/src/test/java/org/infinispan/client/hotrod/StorageRoutingTest.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package org.infinispan.client.hotrod;\n+\n+import static org.infinispan.configuration.cache.StorageType.BINARY;\n+import static org.infinispan.configuration.cache.StorageType.OBJECT;\n+import static org.infinispan.configuration.cache.StorageType.OFF_HEAP;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertTrue;\n+import static org.testng.Assert.fail;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.infinispan.client.hotrod.test.FixedServerBalancing;\n+import org.infinispan.client.hotrod.test.MultiHotRodServersTest;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.cache.StorageType;\n+import org.infinispan.server.hotrod.HotRodServer;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Tests that the Hot Rod client can correctly route requests to a server using different {@link StorageType}.\n+ *\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\", testName = \"client.hotrod.StorageRoutingTest\")\n+public class StorageRoutingTest extends MultiHotRodServersTest {\n+\n+   private static final int CLUSTER_SIZE = 3;\n+\n+   protected StorageType storageType;\n+   private Object key;\n+\n+   public Object[] factory() {\n+      String stringKey = \"key\";\n+      byte[] byteArrayKey = new byte[]{1, 2, 3};\n+\n+      return new Object[]{\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OBJECT).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(OFF_HEAP).withKey(byteArrayKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(stringKey),\n+            new StorageRoutingTest().withStorageType(BINARY).withKey(byteArrayKey)\n+      };\n+   }\n+\n+   protected String[] parameterNames() {\n+      return new String[]{\"storage\", \"key\"};\n+   }\n+\n+   protected Object[] parameterValues() {\n+      return new Object[]{storageType, key};\n+   }\n+\n+   private StorageRoutingTest withStorageType(StorageType storageType) {\n+      this.storageType = storageType;\n+      return this;\n+   }\n+\n+   private StorageRoutingTest withKey(Object key) {\n+      this.key = key;\n+      return this;\n+   }\n+\n+   @Override\n+   protected void createCacheManagers() throws Throwable {\n+      ConfigurationBuilder cfgBuilder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      cfgBuilder.jmxStatistics().enable();\n+      cfgBuilder.clustering().hash().numOwners(1);\n+      cfgBuilder.memory().storageType(storageType);\n+      createHotRodServers(CLUSTER_SIZE, cfgBuilder);\n+      waitForClusterToForm();\n+   }\n+\n+   @Override\n+   protected org.infinispan.client.hotrod.configuration.ConfigurationBuilder createHotRodClientConfigurationBuilder(HotRodServer hotRodServer) {\n+      org.infinispan.client.hotrod.configuration.ConfigurationBuilder hotRodClientConfigurationBuilder = super.createHotRodClientConfigurationBuilder(hotRodServer);\n+      hotRodClientConfigurationBuilder.balancingStrategy(() -> new FixedServerBalancing(hotRodServer));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc2NzgzMw=="}, "originalCommit": {"oid": "dcc248aa4d73439700045e781a8241cc7250ab16"}, "originalPosition": 78}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4496, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}