{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI0ODkyMDc0", "number": 8405, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozMzozNFrOECLn5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoyMToyMVrOEC5qAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzIzMDQ2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/infinispan/util/PersistenceMockUtil.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozMzozNFrOGeexVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxMzoyNjoxOFrOGfFn3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNDYxMw==", "bodyText": "ContextBuilder as PersistenceMockUtil is not exclusive to InvocationContext?", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r434614613", "createdAt": "2020-06-03T14:33:34Z", "author": {"login": "ryanemerson"}, "path": "core/src/test/java/org/infinispan/util/PersistenceMockUtil.java", "diffHunk": "@@ -41,6 +47,51 @@\n  */\n public class PersistenceMockUtil {\n \n+   public static class Builder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be24dc2231fa8baed421fe4a622b5347481a67a9"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg0MTE3MQ==", "bodyText": "Sorry, I am not sure what you mean here. Are you proposing I move the Builder class somewhere else?", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r434841171", "createdAt": "2020-06-03T20:42:12Z", "author": {"login": "wburns"}, "path": "core/src/test/java/org/infinispan/util/PersistenceMockUtil.java", "diffHunk": "@@ -41,6 +47,51 @@\n  */\n public class PersistenceMockUtil {\n \n+   public static class Builder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNDYxMw=="}, "originalCommit": {"oid": "be24dc2231fa8baed421fe4a622b5347481a67a9"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwNTI3MA==", "bodyText": "Sorry, my message isn't clear in hindsight. I meant shall we rename to class ContextBuilder as the PersistenceMockUtil class is not exclusively used for creating/modifying InvocationContext instances. The name Builder is fine as an inner class that creates an instance of the parent class, e.g. DataFormat.Builder, however that is not the case with  PersistenceMockUtil.Builder. So my thoughts were that renaming the class to PersistenceMockUtil.ContextBuilder or even PersistenceMockUtil.InvocationContextBuilder makes it's purpose more explicit.", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r435105270", "createdAt": "2020-06-04T09:07:46Z", "author": {"login": "ryanemerson"}, "path": "core/src/test/java/org/infinispan/util/PersistenceMockUtil.java", "diffHunk": "@@ -41,6 +47,51 @@\n  */\n public class PersistenceMockUtil {\n \n+   public static class Builder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNDYxMw=="}, "originalCommit": {"oid": "be24dc2231fa8baed421fe4a622b5347481a67a9"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI1MTE2Ng==", "bodyText": "Sounds good. I guess because the class only creates an InvocationContext currently I hadn't thought about the name, but I agree.", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r435251166", "createdAt": "2020-06-04T13:26:18Z", "author": {"login": "wburns"}, "path": "core/src/test/java/org/infinispan/util/PersistenceMockUtil.java", "diffHunk": "@@ -41,6 +47,51 @@\n  */\n public class PersistenceMockUtil {\n \n+   public static class Builder {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNDYxMw=="}, "originalCommit": {"oid": "be24dc2231fa8baed421fe4a622b5347481a67a9"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzIzNzQ1OnYy", "diffSide": "RIGHT", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/internal/RocksDBBlockHoundIntegration.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozNDo1N1rOGee1tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOTowMzozN1rOGe8jfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNTczMw==", "bodyText": "impl package?", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r434615733", "createdAt": "2020-06-03T14:34:57Z", "author": {"login": "ryanemerson"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/internal/RocksDBBlockHoundIntegration.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package org.infinispan.persistence.rocksdb.internal;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be24dc2231fa8baed421fe4a622b5347481a67a9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg0MjAxMQ==", "bodyText": "I personally find it being in a package like internal a bit better as it really isn't an implementation class of the public interfaces. I have just repurposed impl in some modules since it is private. WDYT?", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r434842011", "createdAt": "2020-06-03T20:43:56Z", "author": {"login": "wburns"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/internal/RocksDBBlockHoundIntegration.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package org.infinispan.persistence.rocksdb.internal;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNTczMw=="}, "originalCommit": {"oid": "be24dc2231fa8baed421fe4a622b5347481a67a9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwMjU4OA==", "bodyText": "That's a good point. I hadn't realised that we already used .internal. packages in some places, so let's stick with that.", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r435102588", "createdAt": "2020-06-04T09:03:37Z", "author": {"login": "ryanemerson"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/internal/RocksDBBlockHoundIntegration.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package org.infinispan.persistence.rocksdb.internal;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNTczMw=="}, "originalCommit": {"oid": "be24dc2231fa8baed421fe4a622b5347481a67a9"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzMyMjY3OnYy", "diffSide": "RIGHT", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDo1NDowMlrOGefsfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDo1NDowMlrOGefsfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYyOTc1Ng==", "bodyText": "Missing @ConfiguredBy(RocksDBStoreConfiguration.class)", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r434629756", "createdAt": "2020-06-03T14:54:02Z", "author": {"login": "ryanemerson"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -67,1091 +67,933 @@\n import org.rocksdb.WriteOptions;\n \n import io.reactivex.rxjava3.core.Flowable;\n-\n-@Store\n-@ConfiguredBy(RocksDBStoreConfiguration.class)\n-public class RocksDBStore<K,V> implements SegmentedAdvancedLoadWriteStore<K,V> {\n-    private static final Log log = LogFactory.getLog(RocksDBStore.class, Log.class);\n-    static final String DATABASE_PROPERTY_NAME_WITH_SUFFIX = \"database.\";\n-    static final String COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX = \"data.\";\n-\n-    protected RocksDBStoreConfiguration configuration;\n-    private RocksDB db;\n-    private RocksDB expiredDb;\n-    private InitializationContext ctx;\n-    private TimeService timeService;\n-    private Semaphore semaphore;\n-    private WriteOptions dataWriteOptions;\n-    private RocksDBHandler handler;\n-    private Properties databaseProperties;\n-    private Properties columnFamilyProperties;\n-    private Marshaller marshaller;\n-    private MarshallableEntryFactory<K, V> entryFactory;\n-    private volatile boolean stopped = true;\n-\n-    @Override\n-    public void init(InitializationContext ctx) {\n-        this.configuration = ctx.getConfiguration();\n-        this.ctx = ctx;\n-        this.timeService = ctx.getTimeService();\n-        this.marshaller = ctx.getPersistenceMarshaller();\n-        this.semaphore = new Semaphore(Integer.MAX_VALUE, true);\n-        this.entryFactory = ctx.getMarshallableEntryFactory();\n-        ctx.getPersistenceMarshaller().register(new PersistenceContextInitializerImpl());\n-    }\n-\n-    @Override\n-    public void start() {\n-\n-        AdvancedCache cache = ctx.getCache().getAdvancedCache();\n-        KeyPartitioner keyPartitioner = cache.getComponentRegistry().getComponent(KeyPartitioner.class);\n-        if (configuration.segmented()) {\n-            handler = new SegmentedRocksDBHandler(cache.getCacheConfiguration().clustering().hash().numSegments(),\n-                  keyPartitioner);\n-        } else {\n-            handler = new NonSegmentedRocksDBHandler(keyPartitioner);\n-        }\n-\n-        // Has to be done before we open the database, so we can pass the properties\n-        Properties allProperties = configuration.properties();\n-        for (Map.Entry<Object, Object> entry : allProperties.entrySet()) {\n-            String key = entry.getKey().toString();\n-            if (key.startsWith(DATABASE_PROPERTY_NAME_WITH_SUFFIX)) {\n-                if (databaseProperties == null) {\n-                    databaseProperties = new Properties();\n-                }\n-                databaseProperties.setProperty(key.substring(DATABASE_PROPERTY_NAME_WITH_SUFFIX.length()), entry.getValue().toString());\n-            } else if (key.startsWith(COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX)) {\n-                if (columnFamilyProperties == null) {\n-                    columnFamilyProperties = new Properties();\n-                }\n-                columnFamilyProperties.setProperty(key.substring(COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX.length()), entry.getValue().toString());\n-            }\n-        }\n-\n-        try {\n+import io.reactivex.rxjava3.processors.UnicastProcessor;\n+\n+public class RocksDBStore<K, V> implements NonBlockingStore<K, V> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be24dc2231fa8baed421fe4a622b5347481a67a9"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzQ0NDEyOnYy", "diffSide": "RIGHT", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNToyMDo0MVrOGeg59Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODoxMjo0NFrOGenuhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0OTU4OQ==", "bodyText": "Never called.", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r434649589", "createdAt": "2020-06-03T15:20:41Z", "author": {"login": "ryanemerson"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -67,1091 +67,933 @@\n import org.rocksdb.WriteOptions;\n \n import io.reactivex.rxjava3.core.Flowable;\n-\n-@Store\n-@ConfiguredBy(RocksDBStoreConfiguration.class)\n-public class RocksDBStore<K,V> implements SegmentedAdvancedLoadWriteStore<K,V> {\n-    private static final Log log = LogFactory.getLog(RocksDBStore.class, Log.class);\n-    static final String DATABASE_PROPERTY_NAME_WITH_SUFFIX = \"database.\";\n-    static final String COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX = \"data.\";\n-\n-    protected RocksDBStoreConfiguration configuration;\n-    private RocksDB db;\n-    private RocksDB expiredDb;\n-    private InitializationContext ctx;\n-    private TimeService timeService;\n-    private Semaphore semaphore;\n-    private WriteOptions dataWriteOptions;\n-    private RocksDBHandler handler;\n-    private Properties databaseProperties;\n-    private Properties columnFamilyProperties;\n-    private Marshaller marshaller;\n-    private MarshallableEntryFactory<K, V> entryFactory;\n-    private volatile boolean stopped = true;\n-\n-    @Override\n-    public void init(InitializationContext ctx) {\n-        this.configuration = ctx.getConfiguration();\n-        this.ctx = ctx;\n-        this.timeService = ctx.getTimeService();\n-        this.marshaller = ctx.getPersistenceMarshaller();\n-        this.semaphore = new Semaphore(Integer.MAX_VALUE, true);\n-        this.entryFactory = ctx.getMarshallableEntryFactory();\n-        ctx.getPersistenceMarshaller().register(new PersistenceContextInitializerImpl());\n-    }\n-\n-    @Override\n-    public void start() {\n-\n-        AdvancedCache cache = ctx.getCache().getAdvancedCache();\n-        KeyPartitioner keyPartitioner = cache.getComponentRegistry().getComponent(KeyPartitioner.class);\n-        if (configuration.segmented()) {\n-            handler = new SegmentedRocksDBHandler(cache.getCacheConfiguration().clustering().hash().numSegments(),\n-                  keyPartitioner);\n-        } else {\n-            handler = new NonSegmentedRocksDBHandler(keyPartitioner);\n-        }\n-\n-        // Has to be done before we open the database, so we can pass the properties\n-        Properties allProperties = configuration.properties();\n-        for (Map.Entry<Object, Object> entry : allProperties.entrySet()) {\n-            String key = entry.getKey().toString();\n-            if (key.startsWith(DATABASE_PROPERTY_NAME_WITH_SUFFIX)) {\n-                if (databaseProperties == null) {\n-                    databaseProperties = new Properties();\n-                }\n-                databaseProperties.setProperty(key.substring(DATABASE_PROPERTY_NAME_WITH_SUFFIX.length()), entry.getValue().toString());\n-            } else if (key.startsWith(COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX)) {\n-                if (columnFamilyProperties == null) {\n-                    columnFamilyProperties = new Properties();\n-                }\n-                columnFamilyProperties.setProperty(key.substring(COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX.length()), entry.getValue().toString());\n-            }\n-        }\n-\n-        try {\n+import io.reactivex.rxjava3.processors.UnicastProcessor;\n+\n+public class RocksDBStore<K, V> implements NonBlockingStore<K, V> {\n+   private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass(), Log.class);\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   static final String DATABASE_PROPERTY_NAME_WITH_SUFFIX = \"database.\";\n+   static final String COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX = \"data.\";\n+\n+   protected RocksDBStoreConfiguration configuration;\n+   private RocksDB db;\n+   private RocksDB expiredDb;\n+   private InitializationContext ctx;\n+   private TimeService timeService;\n+   private WriteOptions dataWriteOptions;\n+   private RocksDBHandler handler;\n+   private Properties databaseProperties;\n+   private Properties columnFamilyProperties;\n+   private Marshaller marshaller;\n+   private KeyPartitioner keyPartitioner;\n+   private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+\n+   @Override\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n+      this.configuration = ctx.getConfiguration();\n+      this.ctx = ctx;\n+      this.timeService = ctx.getTimeService();\n+      this.marshaller = ctx.getPersistenceMarshaller();\n+      this.entryFactory = ctx.getMarshallableEntryFactory();\n+      this.blockingManager = ctx.getBlockingManager();\n+      this.keyPartitioner = ctx.getKeyPartitioner();\n+\n+      ctx.getPersistenceMarshaller().register(new PersistenceContextInitializerImpl());\n+\n+      AdvancedCache cache = ctx.getCache().getAdvancedCache();\n+      if (configuration.segmented()) {\n+         handler = new SegmentedRocksDBHandler(cache.getCacheConfiguration().clustering().hash().numSegments());\n+      } else {\n+         handler = new NonSegmentedRocksDBHandler(keyPartitioner);\n+      }\n+\n+      // Has to be done before we open the database, so we can pass the properties\n+      Properties allProperties = configuration.properties();\n+      for (Map.Entry<Object, Object> entry : allProperties.entrySet()) {\n+         String key = entry.getKey().toString();\n+         if (key.startsWith(DATABASE_PROPERTY_NAME_WITH_SUFFIX)) {\n+            if (databaseProperties == null) {\n+               databaseProperties = new Properties();\n+            }\n+            databaseProperties.setProperty(key.substring(DATABASE_PROPERTY_NAME_WITH_SUFFIX.length()), entry.getValue().toString());\n+         } else if (key.startsWith(COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX)) {\n+            if (columnFamilyProperties == null) {\n+               columnFamilyProperties = new Properties();\n+            }\n+            columnFamilyProperties.setProperty(key.substring(COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX.length()), entry.getValue().toString());\n+         }\n+      }\n+\n+      return blockingManager.runBlocking(() -> {\n+         try {\n             db = handler.open(getLocation(), dataDbOptions());\n             expiredDb = openDatabase(getExpirationLocation(), expiredDbOptions());\n-            stopped = false;\n-        } catch (Exception e) {\n+         } catch (Exception e) {\n             throw new CacheConfigurationException(\"Unable to open database\", e);\n-        }\n-    }\n-\n-    private Path getLocation() {\n-        return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.location(), ctx.getCache().getName(), \"data\");\n-    }\n-\n-    private Path getExpirationLocation() {\n-        return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.expiredLocation(), ctx.getCache().getName(), \"expired\");\n-    }\n-\n-    private WriteOptions dataWriteOptions() {\n-        if (dataWriteOptions == null)\n-            dataWriteOptions = new WriteOptions().setDisableWAL(false);\n-        return dataWriteOptions;\n-    }\n-\n-    protected DBOptions dataDbOptions() {\n-        DBOptions dbOptions;\n-        if (databaseProperties != null) {\n-            dbOptions = DBOptions.getDBOptionsFromProps(databaseProperties);\n-            if (dbOptions == null) {\n-                throw log.rocksDBUnknownPropertiesSupplied(databaseProperties.toString());\n-            }\n-        } else {\n-            dbOptions = new DBOptions();\n-        }\n-        return dbOptions\n-              .setCreateIfMissing(true)\n-              // We have to create missing column families on open.\n-              // Otherwise when we start we won't know what column families this database had if any - thus\n-              // we must specify all of them and later remove them.\n-              .setCreateMissingColumnFamilies(true);\n-    }\n-\n-    protected Options expiredDbOptions() {\n-        return new Options()\n-              .setCreateIfMissing(true)\n-              // Make sure keys are sorted by bytes - we use this sorting to remove entries that have expired most recently\n-              .setComparator(BuiltinComparator.BYTEWISE_COMPARATOR);\n-    }\n-\n-    /**\n-     * Creates database if it doesn't exist.\n-     */\n-    protected RocksDB openDatabase(Path location, Options options) throws RocksDBException {\n-        File dir = location.toFile();\n-        dir.mkdirs();\n-        return RocksDB.open(options, location.toString());\n-    }\n-\n-    @Override\n-    public void stop() {\n-        try {\n-            semaphore.acquire(Integer.MAX_VALUE);\n-        } catch (InterruptedException e) {\n-            throw new PersistenceException(\"Cannot acquire semaphore\", e);\n-        }\n-        try {\n-            handler.close();\n-            expiredDb.close();\n-        } finally {\n-            stopped = true;\n-            semaphore.release(Integer.MAX_VALUE);\n-        }\n-    }\n-\n-    @Override\n-    public void destroy() {\n-        stop();\n-        Util.recursiveFileRemove(getLocation().toFile());\n-        Util.recursiveFileRemove(getExpirationLocation().toFile());\n-    }\n-\n-    @Override\n-    public boolean isAvailable() {\n-        return getLocation().toFile().exists() && getExpirationLocation().toFile().exists();\n-    }\n-\n-    @Override\n-    public void clear() {\n-        handler.clear(null);\n-    }\n-\n-    @Override\n-    public void clear(IntSet segments) {\n-        handler.clear(segments);\n-    }\n-\n-    @Override\n-    public int size() {\n-        return handler.size(null);\n-    }\n-\n-    @Override\n-    public int size(IntSet segments) {\n-        return handler.size(segments);\n-    }\n-\n-    @Override\n-    public boolean contains(Object key) {\n-        return handler.contains(-1, key);\n-    }\n-\n-    @Override\n-    public boolean contains(int segment, Object key) {\n-        return handler.contains(segment, key);\n-    }\n-\n-    @Override\n-    public Publisher<K> publishKeys(Predicate<? super K> filter) {\n-        return handler.publishKeys(null, filter);\n-    }\n-\n-    @Override\n-    public Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter) {\n-        return handler.publishKeys(segments, filter);\n-    }\n-\n-    @Override\n-    public Publisher<MarshallableEntry<K, V>> entryPublisher(Predicate<? super K> filter, boolean fetchValue, boolean fetchMetadata) {\n-        return handler.publishEntries(null, filter, fetchValue, fetchMetadata);\n-    }\n-\n-    @Override\n-    public Publisher<MarshallableEntry<K, V>> entryPublisher(IntSet segments, Predicate<? super K> filter,\n-                                                             boolean fetchValue, boolean fetchMetadata) {\n-        return handler.publishEntries(segments, filter, fetchValue, fetchMetadata);\n-    }\n-\n-    @Override\n-    public boolean delete(Object key) {\n-        return handler.delete(-1, key);\n-    }\n-\n-    @Override\n-    public boolean delete(int segment, Object key) {\n-        return handler.delete(segment, key);\n-    }\n-\n-    @Override\n-    public void write(MarshallableEntry entry) {\n-        handler.write(-1, entry);\n-    }\n-\n-    @Override\n-    public void write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-        handler.write(segment, entry);\n-    }\n-\n-    @Override\n-    public MarshallableEntry loadEntry(Object key) {\n-        return handler.load(-1, key);\n-    }\n-\n-    @Override\n-    public MarshallableEntry<K, V> get(int segment, Object key) {\n-        return handler.load(segment, key);\n-    }\n-\n-    @Override\n-    public CompletionStage<Void> bulkUpdate(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-        return handler.writeBatch(publisher);\n-    }\n-\n-    @Override\n-    public void deleteBatch(Iterable<Object> keys) {\n-        handler.deleteBatch(keys);\n-    }\n-\n-    private void putExpireDbData(ExpiryEntry entry) throws InterruptedException, RocksDBException, IOException,\n-       ClassNotFoundException {\n-        final byte[] expiryBytes = marshall(entry.expiry);\n-        final byte[] existingBytes = expiredDb.get(expiryBytes);\n-\n-        if (existingBytes != null) {\n-            // in the case of collision make the value a List ...\n-            final Object existing = unmarshall(existingBytes);\n-            if (existing instanceof ExpiryBucket) {\n-                ((ExpiryBucket) existing).entries.add(entry.keyBytes);\n-                expiredDb.put(expiryBytes, marshall(existing));\n-            } else {\n-                ExpiryBucket bucket = new ExpiryBucket(existingBytes, entry.keyBytes);\n-                expiredDb.put(expiryBytes, marshall(bucket));\n-            }\n-        } else {\n-            expiredDb.put(expiryBytes, entry.keyBytes);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public void purge(Executor executor, PurgeListener purgeListener) {\n-        try {\n-            semaphore.acquire();\n-        } catch (InterruptedException e) {\n-            throw new PersistenceException(\"Cannot acquire semaphore: CacheStore is likely stopped.\", e);\n-        }\n-        try (ReadOptions readOptions = new ReadOptions().setFillCache(false)) {\n-            if (stopped) {\n-                throw new PersistenceException(\"RocksDB is stopped\");\n-            }\n-            long now = ctx.getTimeService().wallClockTime();\n-            RocksIterator iterator = expiredDb.newIterator(readOptions);\n-            if (iterator != null) {\n-                try (RocksIterator it = iterator) {\n-                    List<Long> times = new ArrayList<>();\n-                    List<Object> keys = new ArrayList<>();\n-                    List<byte[]> marshalledKeys = new ArrayList<>();\n-\n-                    for (it.seekToFirst(); it.isValid(); it.next()) {\n-                        Long time = (Long) unmarshall(it.key());\n+         }\n+      }, \"rocksdb-open\");\n+   }\n+\n+   private Path getLocation() {\n+      return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.location(), ctx.getCache().getName(), \"data\");\n+   }\n+\n+   private Path getExpirationLocation() {\n+      return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.expiredLocation(), ctx.getCache().getName(), \"expired\");\n+   }\n+\n+   protected DBOptions dataDbOptions() {\n+      DBOptions dbOptions;\n+      if (databaseProperties != null) {\n+         dbOptions = DBOptions.getDBOptionsFromProps(databaseProperties);\n+         if (dbOptions == null) {\n+            throw log.rocksDBUnknownPropertiesSupplied(databaseProperties.toString());\n+         }\n+      } else {\n+         dbOptions = new DBOptions();\n+      }\n+      return dbOptions\n+            .setCreateIfMissing(true)\n+            // We have to create missing column families on open.\n+            // Otherwise when we start we won't know what column families this database had if any - thus\n+            // we must specify all of them and later remove them.\n+            .setCreateMissingColumnFamilies(true);\n+   }\n+\n+   protected Options expiredDbOptions() {\n+      return new Options()\n+            .setCreateIfMissing(true)\n+            // Make sure keys are sorted by bytes - we use this sorting to remove entries that have expired most recently\n+            .setComparator(BuiltinComparator.BYTEWISE_COMPARATOR);\n+   }\n+\n+   /**\n+    * Creates database if it doesn't exist.\n+    */\n+   protected RocksDB openDatabase(Path location, Options options) throws RocksDBException {\n+      File dir = location.toFile();\n+      dir.mkdirs();\n+      return RocksDB.open(options, location.toString());\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> stop() {\n+      return blockingManager.runBlocking(() -> {\n+         handler.close();\n+         expiredDb.close();\n+      }, \"rocksdb-stop\");\n+   }\n+\n+   @Override\n+   public Set<Characteristic> characteristics() {\n+      return EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION, Characteristic.SEGMENTABLE);\n+   }\n+\n+   @Override\n+   public CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key) {\n+      return handler.load(segment, key);\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n+      return handler.write(segment, entry);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> delete(int segment, Object key) {\n+      return handler.delete(segment, key);\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n+         Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n+      WriteBatch batch = new WriteBatch();\n+      Set<MarshallableEntry<K, V>> expirableEntries = new HashSet<>();\n+      Flowable.fromPublisher(removePublisher)\n+            .subscribe(sp -> {\n+               ColumnFamilyHandle handle = handler.getHandle(sp.getSegment());\n+               Flowable.fromPublisher(sp)\n+                     .subscribe(removed -> batch.delete(handle, marshall(removed)));\n+            });\n+      Flowable.fromPublisher(writePublisher)\n+            .subscribe(sp -> {\n+               ColumnFamilyHandle handle = handler.getHandle(sp.getSegment());\n+               Flowable.fromPublisher(sp)\n+                     .subscribe(me -> {\n+                        batch.put(handle, marshall(me.getKey()), marshall(me.getMarshalledValue()));\n+                        if (me.expiryTime() > -1) {\n+                           expirableEntries.add(me);\n+                        }\n+                     });\n+            });\n+      if (batch.count() <= 0) {\n+         batch.close();\n+         return CompletableFutures.completedNull();\n+      }\n+      return blockingManager.runBlocking(() -> {\n+         try {\n+            db.write(dataWriteOptions(), batch);\n+            for (MarshallableEntry<K, V> me : expirableEntries) {\n+               addNewExpiry(me);\n+            }\n+         } catch (RocksDBException e) {\n+            throw new PersistenceException(e);\n+         }\n+      }, \"rocksdb-batch\").whenComplete((ignore, t) -> batch.close());\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> clear() {\n+      return handler.clear();\n+   }\n+\n+   @Override\n+   public Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter) {\n+      return Flowable.fromPublisher(handler.publishEntries(segments, filter, false))\n+            .map(MarshallableEntry::getKey);\n+   }\n+\n+   @Override\n+   public Publisher<MarshallableEntry<K, V>> publishEntries(IntSet segments, Predicate<? super K> filter, boolean includeValues) {\n+      return handler.publishEntries(segments, filter, includeValues);\n+   }\n+\n+   @Override\n+   public CompletionStage<Long> size(IntSet segments) {\n+      return handler.size(segments);\n+   }\n+\n+   @Override\n+   public CompletionStage<Long> approximateSize(IntSet segments) {\n+      return handler.approximateSize(segments);\n+   }\n+\n+   @Override\n+   public Publisher<MarshallableEntry<K, V>> purgeExpired() {\n+      return Flowable.defer(() -> {\n+         UnicastProcessor<MarshallableEntry<K, V>> processor = UnicastProcessor.create();\n+         blockingManager.runBlocking(() -> {\n+            try (ReadOptions readOptions = new ReadOptions().setFillCache(false)) {\n+               long now = ctx.getTimeService().wallClockTime();\n+               RocksIterator iterator = expiredDb.newIterator(readOptions);\n+               if (iterator != null) {\n+                  try (RocksIterator it = iterator) {\n+                     List<Long> times = new ArrayList<>();\n+                     List<Object> keys = new ArrayList<>();\n+                     List<byte[]> marshalledKeys = new ArrayList<>();\n+\n+                     for (it.seekToFirst(); it.isValid(); it.next()) {\n+                        Long time = unmarshall(it.key());\n                         if (time > now)\n-                            break;\n+                           break;\n                         times.add(time);\n                         byte[] marshalledKey = it.value();\n                         Object key = unmarshall(marshalledKey);\n                         if (key instanceof ExpiryBucket) {\n-                            for (byte[] bytes : ((ExpiryBucket) key).entries) {\n-                                marshalledKeys.add(bytes);\n-                                keys.add(unmarshall(bytes));\n-                            }\n+                           for (byte[] bytes : ((ExpiryBucket) key).entries) {\n+                              marshalledKeys.add(bytes);\n+                              keys.add(unmarshall(bytes));\n+                           }\n                         } else {\n-                            keys.add(key);\n-                            marshalledKeys.add(marshalledKey);\n+                           keys.add(key);\n+                           marshalledKeys.add(marshalledKey);\n                         }\n-                    }\n+                     }\n \n-                    for (Long time : times) {\n+                     for (Long time : times) {\n                         expiredDb.delete(marshall(time));\n-                    }\n+                     }\n \n-                    if (!keys.isEmpty())\n+                     if (!keys.isEmpty())\n                         log.debugf(\"purge (up to) %d entries\", keys.size());\n-                    int count = 0;\n-                    for (int i = 0; i < keys.size(); i++) {\n+                     int count = 0;\n+                     for (int i = 0; i < keys.size(); i++) {\n                         Object key = keys.get(i);\n                         byte[] keyBytes = marshalledKeys.get(i);\n-                        int segment = handler.calculateSegment(key);\n \n-                        ColumnFamilyHandle handle = handler.getHandle(segment);\n+                        ColumnFamilyHandle handle = handler.getHandle(key);\n                         byte[] valueBytes = db.get(handle, keyBytes);\n                         if (valueBytes == null)\n-                            continue;\n+                           continue;\n \n-                        MarshalledValue mv = (MarshalledValue) unmarshall(valueBytes);\n+                        MarshalledValue mv = unmarshall(valueBytes);\n                         if (mv != null) {\n-                            // TODO race condition: the entry could be updated between the get and delete!\n-                            Metadata metadata = (Metadata) unmarshall(MarshallUtil.toByteArray(mv.getMetadataBytes()));\n-                            if (MarshallableEntryImpl.isExpired(metadata, now, mv.getCreated(), mv.getLastUsed())) {\n-                                // somewhat inefficient to FIND then REMOVE...\n-                                db.delete(handle, keyBytes);\n-                                purgeListener.entryPurged(key);\n-                                count++;\n-                            }\n+                           // TODO race condition: the entry could be updated between the get and delete!\n+                           Metadata metadata = unmarshall(MarshallUtil.toByteArray(mv.getMetadataBytes()));\n+                           if (MarshallableEntryImpl.isExpired(metadata, now, mv.getCreated(), mv.getLastUsed())) {\n+                              // somewhat inefficient to FIND then REMOVE... but required if the value is updated\n+                              db.delete(handle, keyBytes);\n+                              processor.onNext(entryFactory.create(key, mv));\n+                              count++;\n+                           }\n                         }\n-                    }\n-                    if (count != 0)\n+                     }\n+                     if (count != 0)\n                         log.debugf(\"purged %d entries\", count);\n-                } catch (Exception e) {\n-                    throw new PersistenceException(e);\n-                } finally {\n-                    readOptions.close();\n-                }\n-            }\n-        } catch (PersistenceException e) {\n-            throw e;\n-        } catch (Exception e) {\n-            throw new PersistenceException(e);\n-        } finally {\n-            semaphore.release();\n-        }\n-    }\n-\n-    @Override\n-    public void addSegments(IntSet segments) {\n-        handler.addSegments(segments);\n-    }\n-\n-    @Override\n-    public void removeSegments(IntSet segments) {\n-        handler.removeSegments(segments);\n-    }\n-\n-    private byte[] marshall(Object entry) throws IOException, InterruptedException {\n-        return marshaller.objectToByteBuffer(entry);\n-    }\n-\n-    private Object unmarshall(byte[] bytes) throws IOException, ClassNotFoundException {\n-        if (bytes == null)\n-            return null;\n-\n-        return marshaller.objectFromByteBuffer(bytes);\n-    }\n-\n-    private MarshallableEntry<K, V> valueToMarshallableEntry(Object key, byte[] valueBytes, boolean fetchMeta) throws IOException, ClassNotFoundException {\n-        MarshalledValue value = (MarshalledValue) unmarshall(valueBytes);\n-        if (value == null) return null;\n-\n-        ByteBuffer metadataBytes = fetchMeta ? value.getMetadataBytes() : null;\n-        return entryFactory.create(key, value.getValueBytes(), metadataBytes, value.getInternalMetadataBytes(), value.getCreated(), value.getLastUsed());\n-    }\n-\n-    private void addNewExpiry(MarshallableEntry entry) throws RocksDBException, IOException, ClassNotFoundException {\n-        long expiry = entry.expiryTime();\n-        long maxIdle = entry.getMetadata().maxIdle();\n-        if (maxIdle > 0) {\n-            // Coding getExpiryTime() for transient entries has the risk of being a moving target\n-            // which could lead to unexpected results, hence, InternalCacheEntry calls are required\n-            expiry = maxIdle + ctx.getTimeService().wallClockTime();\n-        }\n-        try {\n-            byte[] keyBytes = entry.getKeyBytes().copy().getBuf();\n-            putExpireDbData(new ExpiryEntry(expiry, keyBytes));\n-        } catch (InterruptedException e) {\n-            Thread.currentThread().interrupt(); // Restore interruption status\n-        }\n-    }\n-\n-    @ProtoTypeId(ProtoStreamTypeIds.ROCKSDB_EXPIRY_BUCKET)\n-    static final class ExpiryBucket {\n-        @ProtoField(number = 1, collectionImplementation = ArrayList.class)\n-        List<byte[]> entries;\n-\n-        ExpiryBucket(){}\n-\n-        ExpiryBucket(byte[] existingKey, byte[] newKey) {\n-            entries = new ArrayList<>(2);\n-            entries.add(existingKey);\n-            entries.add(newKey);\n-        }\n-    }\n-\n-    private static final class ExpiryEntry {\n-\n-        final long expiry;\n-        final byte[] keyBytes;\n-\n-        ExpiryEntry(long expiry, byte[] keyBytes) {\n-            this.expiry = expiry;\n-            this.keyBytes = keyBytes;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            ExpiryEntry that = (ExpiryEntry) o;\n-            return expiry == that.expiry &&\n-                  Arrays.equals(keyBytes, that.keyBytes);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            int result = Objects.hash(expiry);\n-            result = 31 * result + Arrays.hashCode(keyBytes);\n-            return result;\n-        }\n-    }\n-\n-    private class RocksKeyIterator extends AbstractIterator<K> {\n-        private final RocksIterator it;\n-        private final Predicate<? super K> filter;\n-\n-        public RocksKeyIterator(RocksIterator it, Predicate<? super K> filter) {\n-            this.it = it;\n-            this.filter = filter;\n-        }\n-\n-        @Override\n-        protected K getNext() {\n-            K key = null;\n-            try {\n-                while (key == null && it.isValid()) {\n-                    K testKey = (K) unmarshall(it.key());\n-                    if (filter == null || filter.test(testKey)) {\n-                        key = testKey;\n-                    }\n-                    it.next();\n-                }\n-            } catch (IOException | ClassNotFoundException e) {\n-                throw new CacheException(e);\n-            }\n-            return key;\n-        }\n-    }\n-\n-    private class RocksEntryIterator extends AbstractIterator<MarshallableEntry<K, V>> {\n-        private final RocksIterator it;\n-        private final Predicate<? super K> filter;\n-        private final boolean fetchValue;\n-        private final boolean fetchMetadata;\n-        private final long now;\n-\n-        public RocksEntryIterator(RocksIterator it, Predicate<? super K> filter, boolean fetchValue,\n-              boolean fetchMetadata, long now) {\n-            this.it = it;\n-            this.filter = filter;\n-            this.fetchValue = fetchValue;\n-            this.fetchMetadata = fetchMetadata;\n-            this.now = now;\n-        }\n-\n-        @Override\n-        protected MarshallableEntry<K, V> getNext() {\n-            MarshallableEntry<K, V> entry = null;\n-            try {\n-                while (entry == null && it.isValid()) {\n-                    K key = (K) unmarshall(it.key());\n-                    if (filter == null || filter.test(key)) {\n-                        if (fetchValue || fetchMetadata) {\n-                            MarshallableEntry<K, V> me = valueToMarshallableEntry(key, it.value(), fetchMetadata);\n-                            if (me != null && !me.isExpired(now)) {\n-                                entry = me;\n-                            }\n-                        } else {\n-                            entry = entryFactory.create(key);\n-                        }\n-                    }\n-                    it.next();\n-                }\n-            } catch (IOException | ClassNotFoundException e) {\n-                throw new CacheException(e);\n-            }\n-            return entry;\n-        }\n-    }\n-\n-    private abstract class RocksDBHandler {\n-\n-        abstract RocksDB open(Path location, DBOptions options) throws RocksDBException;\n-\n-        abstract void close();\n-\n-        abstract ColumnFamilyHandle getHandle(int segment);\n-\n-        final ColumnFamilyHandle getHandle(int segment, Object key) {\n-            if (segment < 0) {\n-                segment = calculateSegment(key);\n-            }\n-            return getHandle(segment);\n-        }\n-\n-        abstract int calculateSegment(Object key);\n-\n-        ColumnFamilyDescriptor newDescriptor(byte[] name) {\n-            ColumnFamilyOptions columnFamilyOptions;\n-            if (columnFamilyProperties != null) {\n-                columnFamilyOptions = ColumnFamilyOptions.getColumnFamilyOptionsFromProps(columnFamilyProperties);\n-                if (columnFamilyOptions == null) {\n-                    throw log.rocksDBUnknownPropertiesSupplied(columnFamilyProperties.toString());\n-                }\n+                  } catch (Exception e) {\n+                     throw new PersistenceException(e);\n+                  } finally {\n+                     readOptions.close();\n+                  }\n+               }\n+            }\n+         }, \"rocksdb-purgeExpired\").whenComplete((ignore, t) -> {\n+            if (t != null) {\n+               processor.onError(t);\n             } else {\n-                columnFamilyOptions = new ColumnFamilyOptions();\n-            }\n-            return new ColumnFamilyDescriptor(name,\n-                  columnFamilyOptions.setCompressionType(CompressionType.getCompressionType(configuration.compressionType().toString())));\n-        }\n-\n-        boolean contains(int segment, Object key) {\n-            // This might be able to use RocksDB#keyMayExist - but API is a bit flaky\n-            return load(segment, key) != null;\n-        }\n-\n-        MarshallableEntry<K, V> load(int segment, Object key) {\n-            ColumnFamilyHandle handle = getHandle(segment, key);\n-            if (handle == null) {\n-                log.trace(\"Ignoring load as handle is not currently configured\");\n-                return null;\n-            }\n-            try {\n-                byte[] entryBytes;\n-                semaphore.acquire();\n-                try {\n-                    if (stopped) {\n-                        throw new PersistenceException(\"RocksDB is stopped\");\n-                    }\n-\n-                    entryBytes = db.get(handle, marshall(key));\n-                } finally {\n-                    semaphore.release();\n-                }\n-                MarshallableEntry<K, V> me = valueToMarshallableEntry(key, entryBytes, true);\n-                if (me == null || me.isExpired(timeService.wallClockTime())) {\n-                    return null;\n-                }\n-                return me;\n-            } catch (Exception e) {\n-                throw new PersistenceException(e);\n-            }\n-        }\n-\n-        void write(int segment, MarshallableEntry<? extends K, ? extends V> me) {\n-            Object key = me.getKey();\n-            ColumnFamilyHandle handle = getHandle(segment, key);\n-            if (handle == null) {\n-                log.trace(\"Ignoring write as handle is not currently configured\");\n-                return;\n-            }\n-            try {\n-                byte[] marshalledKey = MarshallUtil.toByteArray(me.getKeyBytes());\n-                byte[] marshalledValue = marshall(me.getMarshalledValue());\n-                semaphore.acquire();\n-                try {\n-                    if (stopped) {\n-                        throw new PersistenceException(\"RocksDB is stopped\");\n-                    }\n-                    db.put(handle, marshalledKey, marshalledValue);\n-                } finally {\n-                    semaphore.release();\n-                }\n-                if (me.expiryTime() > -1) {\n-                    addNewExpiry(me);\n-                }\n-            } catch (Exception e) {\n-                throw new PersistenceException(e);\n-            }\n-        }\n-\n-        boolean delete(int segment, Object key) {\n-            try {\n-                byte[] keyBytes = marshall(key);\n-                semaphore.acquire();\n-                try {\n-                    if (stopped) {\n-                        throw new PersistenceException(\"RocksDB is stopped\");\n-                    }\n-                    if (db.get(getHandle(segment, key), keyBytes) == null) {\n-                        return false;\n-                    }\n-                    db.delete(getHandle(segment, key), keyBytes);\n-                } finally {\n-                    semaphore.release();\n-                }\n-                return true;\n-            } catch (Exception e) {\n-                throw new PersistenceException(e);\n-            }\n-        }\n-\n-        CompletionStage<Void> writeBatch(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-            return Flowable.fromPublisher(publisher)\n-                  .buffer(configuration.maxBatchSize())\n-                  .doOnNext(entries -> {\n-                      WriteBatch batch = new WriteBatch();\n-                      for (MarshallableEntry<? extends K, ? extends V> entry : entries) {\n-                          int segment = calculateSegment(entry.getKey());\n-                          byte[] keyBytes = MarshallUtil.toByteArray(entry.getKeyBytes());\n-                          batch.put(getHandle(segment), keyBytes, marshall(entry.getMarshalledValue()));\n-                      }\n-                      writeBatch(batch);\n-\n-                      // Add metadata only after batch has been written\n-                      for (MarshallableEntry entry : entries) {\n-                          if (entry.expiryTime() > -1)\n-                              addNewExpiry(entry);\n-                      }\n-                  })\n-                  .doOnError(e -> {\n-                      throw new PersistenceException(e);\n-                  })\n-                  .ignoreElements()\n-                  .toCompletionStage(null);\n-        }\n-\n-        void deleteBatch(Iterable<Object> keys) {\n-            try {\n-                int batchSize = 0;\n-                WriteBatch batch = new WriteBatch();\n-                for (Object key : keys) {\n-                    batch.remove(getHandle(calculateSegment(key)), marshall(key));\n-                    batchSize++;\n-\n-                    if (batchSize == configuration.maxBatchSize()) {\n-                        batchSize = 0;\n-                        writeBatch(batch);\n-                        batch = new WriteBatch();\n-                    }\n-                }\n-\n-                if (batchSize != 0)\n-                    writeBatch(batch);\n-            } catch (Exception e) {\n-                throw new PersistenceException(e);\n-            }\n-        }\n-\n-        abstract void clear(IntSet segments);\n-\n-        abstract Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter);\n-\n-        abstract Publisher<MarshallableEntry<K, V>> publishEntries(IntSet segments, Predicate<? super K> filter,\n-                                                                   boolean fetchValue, boolean fetchMetadata);\n+               processor.onComplete();\n+            }\n+         });\n+         return processor;\n+      });\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> addSegments(IntSet segments) {\n+      return handler.addSegments(segments);\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> removeSegments(IntSet segments) {\n+      return handler.removeSegments(segments);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> isAvailable() {\n+      return blockingManager.supplyBlocking(() -> getLocation().toFile().exists() && getExpirationLocation().toFile().exists(),\n+            \"rocksdb-available\");\n+   }\n+\n+   private abstract class RocksDBHandler {\n+\n+      abstract RocksDB open(Path location, DBOptions options) throws RocksDBException;\n+\n+      abstract void close();\n+\n+      abstract ColumnFamilyHandle getHandle(int segment);\n+\n+      abstract ColumnFamilyHandle getHandle(Object key);\n+\n+      ColumnFamilyDescriptor newDescriptor(byte[] name) {\n+         ColumnFamilyOptions columnFamilyOptions;\n+         if (columnFamilyProperties != null) {\n+            columnFamilyOptions = ColumnFamilyOptions.getColumnFamilyOptionsFromProps(columnFamilyProperties);\n+            if (columnFamilyOptions == null) {\n+               throw log.rocksDBUnknownPropertiesSupplied(columnFamilyProperties.toString());\n+            }\n+         } else {\n+            columnFamilyOptions = new ColumnFamilyOptions();\n+         }\n+         return new ColumnFamilyDescriptor(name,\n+               columnFamilyOptions.setCompressionType(CompressionType.getCompressionType(configuration.compressionType().toString())));\n+      }\n+\n+      CompletionStage<Boolean> contains(int segment, Object key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be24dc2231fa8baed421fe4a622b5347481a67a9"}, "originalPosition": 1018}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc2MTM1MQ==", "bodyText": "Fixed, moved this to the actual store method for better visibility.", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r434761351", "createdAt": "2020-06-03T18:12:44Z", "author": {"login": "wburns"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -67,1091 +67,933 @@\n import org.rocksdb.WriteOptions;\n \n import io.reactivex.rxjava3.core.Flowable;\n-\n-@Store\n-@ConfiguredBy(RocksDBStoreConfiguration.class)\n-public class RocksDBStore<K,V> implements SegmentedAdvancedLoadWriteStore<K,V> {\n-    private static final Log log = LogFactory.getLog(RocksDBStore.class, Log.class);\n-    static final String DATABASE_PROPERTY_NAME_WITH_SUFFIX = \"database.\";\n-    static final String COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX = \"data.\";\n-\n-    protected RocksDBStoreConfiguration configuration;\n-    private RocksDB db;\n-    private RocksDB expiredDb;\n-    private InitializationContext ctx;\n-    private TimeService timeService;\n-    private Semaphore semaphore;\n-    private WriteOptions dataWriteOptions;\n-    private RocksDBHandler handler;\n-    private Properties databaseProperties;\n-    private Properties columnFamilyProperties;\n-    private Marshaller marshaller;\n-    private MarshallableEntryFactory<K, V> entryFactory;\n-    private volatile boolean stopped = true;\n-\n-    @Override\n-    public void init(InitializationContext ctx) {\n-        this.configuration = ctx.getConfiguration();\n-        this.ctx = ctx;\n-        this.timeService = ctx.getTimeService();\n-        this.marshaller = ctx.getPersistenceMarshaller();\n-        this.semaphore = new Semaphore(Integer.MAX_VALUE, true);\n-        this.entryFactory = ctx.getMarshallableEntryFactory();\n-        ctx.getPersistenceMarshaller().register(new PersistenceContextInitializerImpl());\n-    }\n-\n-    @Override\n-    public void start() {\n-\n-        AdvancedCache cache = ctx.getCache().getAdvancedCache();\n-        KeyPartitioner keyPartitioner = cache.getComponentRegistry().getComponent(KeyPartitioner.class);\n-        if (configuration.segmented()) {\n-            handler = new SegmentedRocksDBHandler(cache.getCacheConfiguration().clustering().hash().numSegments(),\n-                  keyPartitioner);\n-        } else {\n-            handler = new NonSegmentedRocksDBHandler(keyPartitioner);\n-        }\n-\n-        // Has to be done before we open the database, so we can pass the properties\n-        Properties allProperties = configuration.properties();\n-        for (Map.Entry<Object, Object> entry : allProperties.entrySet()) {\n-            String key = entry.getKey().toString();\n-            if (key.startsWith(DATABASE_PROPERTY_NAME_WITH_SUFFIX)) {\n-                if (databaseProperties == null) {\n-                    databaseProperties = new Properties();\n-                }\n-                databaseProperties.setProperty(key.substring(DATABASE_PROPERTY_NAME_WITH_SUFFIX.length()), entry.getValue().toString());\n-            } else if (key.startsWith(COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX)) {\n-                if (columnFamilyProperties == null) {\n-                    columnFamilyProperties = new Properties();\n-                }\n-                columnFamilyProperties.setProperty(key.substring(COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX.length()), entry.getValue().toString());\n-            }\n-        }\n-\n-        try {\n+import io.reactivex.rxjava3.processors.UnicastProcessor;\n+\n+public class RocksDBStore<K, V> implements NonBlockingStore<K, V> {\n+   private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass(), Log.class);\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   static final String DATABASE_PROPERTY_NAME_WITH_SUFFIX = \"database.\";\n+   static final String COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX = \"data.\";\n+\n+   protected RocksDBStoreConfiguration configuration;\n+   private RocksDB db;\n+   private RocksDB expiredDb;\n+   private InitializationContext ctx;\n+   private TimeService timeService;\n+   private WriteOptions dataWriteOptions;\n+   private RocksDBHandler handler;\n+   private Properties databaseProperties;\n+   private Properties columnFamilyProperties;\n+   private Marshaller marshaller;\n+   private KeyPartitioner keyPartitioner;\n+   private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+\n+   @Override\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n+      this.configuration = ctx.getConfiguration();\n+      this.ctx = ctx;\n+      this.timeService = ctx.getTimeService();\n+      this.marshaller = ctx.getPersistenceMarshaller();\n+      this.entryFactory = ctx.getMarshallableEntryFactory();\n+      this.blockingManager = ctx.getBlockingManager();\n+      this.keyPartitioner = ctx.getKeyPartitioner();\n+\n+      ctx.getPersistenceMarshaller().register(new PersistenceContextInitializerImpl());\n+\n+      AdvancedCache cache = ctx.getCache().getAdvancedCache();\n+      if (configuration.segmented()) {\n+         handler = new SegmentedRocksDBHandler(cache.getCacheConfiguration().clustering().hash().numSegments());\n+      } else {\n+         handler = new NonSegmentedRocksDBHandler(keyPartitioner);\n+      }\n+\n+      // Has to be done before we open the database, so we can pass the properties\n+      Properties allProperties = configuration.properties();\n+      for (Map.Entry<Object, Object> entry : allProperties.entrySet()) {\n+         String key = entry.getKey().toString();\n+         if (key.startsWith(DATABASE_PROPERTY_NAME_WITH_SUFFIX)) {\n+            if (databaseProperties == null) {\n+               databaseProperties = new Properties();\n+            }\n+            databaseProperties.setProperty(key.substring(DATABASE_PROPERTY_NAME_WITH_SUFFIX.length()), entry.getValue().toString());\n+         } else if (key.startsWith(COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX)) {\n+            if (columnFamilyProperties == null) {\n+               columnFamilyProperties = new Properties();\n+            }\n+            columnFamilyProperties.setProperty(key.substring(COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX.length()), entry.getValue().toString());\n+         }\n+      }\n+\n+      return blockingManager.runBlocking(() -> {\n+         try {\n             db = handler.open(getLocation(), dataDbOptions());\n             expiredDb = openDatabase(getExpirationLocation(), expiredDbOptions());\n-            stopped = false;\n-        } catch (Exception e) {\n+         } catch (Exception e) {\n             throw new CacheConfigurationException(\"Unable to open database\", e);\n-        }\n-    }\n-\n-    private Path getLocation() {\n-        return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.location(), ctx.getCache().getName(), \"data\");\n-    }\n-\n-    private Path getExpirationLocation() {\n-        return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.expiredLocation(), ctx.getCache().getName(), \"expired\");\n-    }\n-\n-    private WriteOptions dataWriteOptions() {\n-        if (dataWriteOptions == null)\n-            dataWriteOptions = new WriteOptions().setDisableWAL(false);\n-        return dataWriteOptions;\n-    }\n-\n-    protected DBOptions dataDbOptions() {\n-        DBOptions dbOptions;\n-        if (databaseProperties != null) {\n-            dbOptions = DBOptions.getDBOptionsFromProps(databaseProperties);\n-            if (dbOptions == null) {\n-                throw log.rocksDBUnknownPropertiesSupplied(databaseProperties.toString());\n-            }\n-        } else {\n-            dbOptions = new DBOptions();\n-        }\n-        return dbOptions\n-              .setCreateIfMissing(true)\n-              // We have to create missing column families on open.\n-              // Otherwise when we start we won't know what column families this database had if any - thus\n-              // we must specify all of them and later remove them.\n-              .setCreateMissingColumnFamilies(true);\n-    }\n-\n-    protected Options expiredDbOptions() {\n-        return new Options()\n-              .setCreateIfMissing(true)\n-              // Make sure keys are sorted by bytes - we use this sorting to remove entries that have expired most recently\n-              .setComparator(BuiltinComparator.BYTEWISE_COMPARATOR);\n-    }\n-\n-    /**\n-     * Creates database if it doesn't exist.\n-     */\n-    protected RocksDB openDatabase(Path location, Options options) throws RocksDBException {\n-        File dir = location.toFile();\n-        dir.mkdirs();\n-        return RocksDB.open(options, location.toString());\n-    }\n-\n-    @Override\n-    public void stop() {\n-        try {\n-            semaphore.acquire(Integer.MAX_VALUE);\n-        } catch (InterruptedException e) {\n-            throw new PersistenceException(\"Cannot acquire semaphore\", e);\n-        }\n-        try {\n-            handler.close();\n-            expiredDb.close();\n-        } finally {\n-            stopped = true;\n-            semaphore.release(Integer.MAX_VALUE);\n-        }\n-    }\n-\n-    @Override\n-    public void destroy() {\n-        stop();\n-        Util.recursiveFileRemove(getLocation().toFile());\n-        Util.recursiveFileRemove(getExpirationLocation().toFile());\n-    }\n-\n-    @Override\n-    public boolean isAvailable() {\n-        return getLocation().toFile().exists() && getExpirationLocation().toFile().exists();\n-    }\n-\n-    @Override\n-    public void clear() {\n-        handler.clear(null);\n-    }\n-\n-    @Override\n-    public void clear(IntSet segments) {\n-        handler.clear(segments);\n-    }\n-\n-    @Override\n-    public int size() {\n-        return handler.size(null);\n-    }\n-\n-    @Override\n-    public int size(IntSet segments) {\n-        return handler.size(segments);\n-    }\n-\n-    @Override\n-    public boolean contains(Object key) {\n-        return handler.contains(-1, key);\n-    }\n-\n-    @Override\n-    public boolean contains(int segment, Object key) {\n-        return handler.contains(segment, key);\n-    }\n-\n-    @Override\n-    public Publisher<K> publishKeys(Predicate<? super K> filter) {\n-        return handler.publishKeys(null, filter);\n-    }\n-\n-    @Override\n-    public Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter) {\n-        return handler.publishKeys(segments, filter);\n-    }\n-\n-    @Override\n-    public Publisher<MarshallableEntry<K, V>> entryPublisher(Predicate<? super K> filter, boolean fetchValue, boolean fetchMetadata) {\n-        return handler.publishEntries(null, filter, fetchValue, fetchMetadata);\n-    }\n-\n-    @Override\n-    public Publisher<MarshallableEntry<K, V>> entryPublisher(IntSet segments, Predicate<? super K> filter,\n-                                                             boolean fetchValue, boolean fetchMetadata) {\n-        return handler.publishEntries(segments, filter, fetchValue, fetchMetadata);\n-    }\n-\n-    @Override\n-    public boolean delete(Object key) {\n-        return handler.delete(-1, key);\n-    }\n-\n-    @Override\n-    public boolean delete(int segment, Object key) {\n-        return handler.delete(segment, key);\n-    }\n-\n-    @Override\n-    public void write(MarshallableEntry entry) {\n-        handler.write(-1, entry);\n-    }\n-\n-    @Override\n-    public void write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-        handler.write(segment, entry);\n-    }\n-\n-    @Override\n-    public MarshallableEntry loadEntry(Object key) {\n-        return handler.load(-1, key);\n-    }\n-\n-    @Override\n-    public MarshallableEntry<K, V> get(int segment, Object key) {\n-        return handler.load(segment, key);\n-    }\n-\n-    @Override\n-    public CompletionStage<Void> bulkUpdate(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-        return handler.writeBatch(publisher);\n-    }\n-\n-    @Override\n-    public void deleteBatch(Iterable<Object> keys) {\n-        handler.deleteBatch(keys);\n-    }\n-\n-    private void putExpireDbData(ExpiryEntry entry) throws InterruptedException, RocksDBException, IOException,\n-       ClassNotFoundException {\n-        final byte[] expiryBytes = marshall(entry.expiry);\n-        final byte[] existingBytes = expiredDb.get(expiryBytes);\n-\n-        if (existingBytes != null) {\n-            // in the case of collision make the value a List ...\n-            final Object existing = unmarshall(existingBytes);\n-            if (existing instanceof ExpiryBucket) {\n-                ((ExpiryBucket) existing).entries.add(entry.keyBytes);\n-                expiredDb.put(expiryBytes, marshall(existing));\n-            } else {\n-                ExpiryBucket bucket = new ExpiryBucket(existingBytes, entry.keyBytes);\n-                expiredDb.put(expiryBytes, marshall(bucket));\n-            }\n-        } else {\n-            expiredDb.put(expiryBytes, entry.keyBytes);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public void purge(Executor executor, PurgeListener purgeListener) {\n-        try {\n-            semaphore.acquire();\n-        } catch (InterruptedException e) {\n-            throw new PersistenceException(\"Cannot acquire semaphore: CacheStore is likely stopped.\", e);\n-        }\n-        try (ReadOptions readOptions = new ReadOptions().setFillCache(false)) {\n-            if (stopped) {\n-                throw new PersistenceException(\"RocksDB is stopped\");\n-            }\n-            long now = ctx.getTimeService().wallClockTime();\n-            RocksIterator iterator = expiredDb.newIterator(readOptions);\n-            if (iterator != null) {\n-                try (RocksIterator it = iterator) {\n-                    List<Long> times = new ArrayList<>();\n-                    List<Object> keys = new ArrayList<>();\n-                    List<byte[]> marshalledKeys = new ArrayList<>();\n-\n-                    for (it.seekToFirst(); it.isValid(); it.next()) {\n-                        Long time = (Long) unmarshall(it.key());\n+         }\n+      }, \"rocksdb-open\");\n+   }\n+\n+   private Path getLocation() {\n+      return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.location(), ctx.getCache().getName(), \"data\");\n+   }\n+\n+   private Path getExpirationLocation() {\n+      return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.expiredLocation(), ctx.getCache().getName(), \"expired\");\n+   }\n+\n+   protected DBOptions dataDbOptions() {\n+      DBOptions dbOptions;\n+      if (databaseProperties != null) {\n+         dbOptions = DBOptions.getDBOptionsFromProps(databaseProperties);\n+         if (dbOptions == null) {\n+            throw log.rocksDBUnknownPropertiesSupplied(databaseProperties.toString());\n+         }\n+      } else {\n+         dbOptions = new DBOptions();\n+      }\n+      return dbOptions\n+            .setCreateIfMissing(true)\n+            // We have to create missing column families on open.\n+            // Otherwise when we start we won't know what column families this database had if any - thus\n+            // we must specify all of them and later remove them.\n+            .setCreateMissingColumnFamilies(true);\n+   }\n+\n+   protected Options expiredDbOptions() {\n+      return new Options()\n+            .setCreateIfMissing(true)\n+            // Make sure keys are sorted by bytes - we use this sorting to remove entries that have expired most recently\n+            .setComparator(BuiltinComparator.BYTEWISE_COMPARATOR);\n+   }\n+\n+   /**\n+    * Creates database if it doesn't exist.\n+    */\n+   protected RocksDB openDatabase(Path location, Options options) throws RocksDBException {\n+      File dir = location.toFile();\n+      dir.mkdirs();\n+      return RocksDB.open(options, location.toString());\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> stop() {\n+      return blockingManager.runBlocking(() -> {\n+         handler.close();\n+         expiredDb.close();\n+      }, \"rocksdb-stop\");\n+   }\n+\n+   @Override\n+   public Set<Characteristic> characteristics() {\n+      return EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION, Characteristic.SEGMENTABLE);\n+   }\n+\n+   @Override\n+   public CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key) {\n+      return handler.load(segment, key);\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n+      return handler.write(segment, entry);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> delete(int segment, Object key) {\n+      return handler.delete(segment, key);\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n+         Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n+      WriteBatch batch = new WriteBatch();\n+      Set<MarshallableEntry<K, V>> expirableEntries = new HashSet<>();\n+      Flowable.fromPublisher(removePublisher)\n+            .subscribe(sp -> {\n+               ColumnFamilyHandle handle = handler.getHandle(sp.getSegment());\n+               Flowable.fromPublisher(sp)\n+                     .subscribe(removed -> batch.delete(handle, marshall(removed)));\n+            });\n+      Flowable.fromPublisher(writePublisher)\n+            .subscribe(sp -> {\n+               ColumnFamilyHandle handle = handler.getHandle(sp.getSegment());\n+               Flowable.fromPublisher(sp)\n+                     .subscribe(me -> {\n+                        batch.put(handle, marshall(me.getKey()), marshall(me.getMarshalledValue()));\n+                        if (me.expiryTime() > -1) {\n+                           expirableEntries.add(me);\n+                        }\n+                     });\n+            });\n+      if (batch.count() <= 0) {\n+         batch.close();\n+         return CompletableFutures.completedNull();\n+      }\n+      return blockingManager.runBlocking(() -> {\n+         try {\n+            db.write(dataWriteOptions(), batch);\n+            for (MarshallableEntry<K, V> me : expirableEntries) {\n+               addNewExpiry(me);\n+            }\n+         } catch (RocksDBException e) {\n+            throw new PersistenceException(e);\n+         }\n+      }, \"rocksdb-batch\").whenComplete((ignore, t) -> batch.close());\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> clear() {\n+      return handler.clear();\n+   }\n+\n+   @Override\n+   public Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter) {\n+      return Flowable.fromPublisher(handler.publishEntries(segments, filter, false))\n+            .map(MarshallableEntry::getKey);\n+   }\n+\n+   @Override\n+   public Publisher<MarshallableEntry<K, V>> publishEntries(IntSet segments, Predicate<? super K> filter, boolean includeValues) {\n+      return handler.publishEntries(segments, filter, includeValues);\n+   }\n+\n+   @Override\n+   public CompletionStage<Long> size(IntSet segments) {\n+      return handler.size(segments);\n+   }\n+\n+   @Override\n+   public CompletionStage<Long> approximateSize(IntSet segments) {\n+      return handler.approximateSize(segments);\n+   }\n+\n+   @Override\n+   public Publisher<MarshallableEntry<K, V>> purgeExpired() {\n+      return Flowable.defer(() -> {\n+         UnicastProcessor<MarshallableEntry<K, V>> processor = UnicastProcessor.create();\n+         blockingManager.runBlocking(() -> {\n+            try (ReadOptions readOptions = new ReadOptions().setFillCache(false)) {\n+               long now = ctx.getTimeService().wallClockTime();\n+               RocksIterator iterator = expiredDb.newIterator(readOptions);\n+               if (iterator != null) {\n+                  try (RocksIterator it = iterator) {\n+                     List<Long> times = new ArrayList<>();\n+                     List<Object> keys = new ArrayList<>();\n+                     List<byte[]> marshalledKeys = new ArrayList<>();\n+\n+                     for (it.seekToFirst(); it.isValid(); it.next()) {\n+                        Long time = unmarshall(it.key());\n                         if (time > now)\n-                            break;\n+                           break;\n                         times.add(time);\n                         byte[] marshalledKey = it.value();\n                         Object key = unmarshall(marshalledKey);\n                         if (key instanceof ExpiryBucket) {\n-                            for (byte[] bytes : ((ExpiryBucket) key).entries) {\n-                                marshalledKeys.add(bytes);\n-                                keys.add(unmarshall(bytes));\n-                            }\n+                           for (byte[] bytes : ((ExpiryBucket) key).entries) {\n+                              marshalledKeys.add(bytes);\n+                              keys.add(unmarshall(bytes));\n+                           }\n                         } else {\n-                            keys.add(key);\n-                            marshalledKeys.add(marshalledKey);\n+                           keys.add(key);\n+                           marshalledKeys.add(marshalledKey);\n                         }\n-                    }\n+                     }\n \n-                    for (Long time : times) {\n+                     for (Long time : times) {\n                         expiredDb.delete(marshall(time));\n-                    }\n+                     }\n \n-                    if (!keys.isEmpty())\n+                     if (!keys.isEmpty())\n                         log.debugf(\"purge (up to) %d entries\", keys.size());\n-                    int count = 0;\n-                    for (int i = 0; i < keys.size(); i++) {\n+                     int count = 0;\n+                     for (int i = 0; i < keys.size(); i++) {\n                         Object key = keys.get(i);\n                         byte[] keyBytes = marshalledKeys.get(i);\n-                        int segment = handler.calculateSegment(key);\n \n-                        ColumnFamilyHandle handle = handler.getHandle(segment);\n+                        ColumnFamilyHandle handle = handler.getHandle(key);\n                         byte[] valueBytes = db.get(handle, keyBytes);\n                         if (valueBytes == null)\n-                            continue;\n+                           continue;\n \n-                        MarshalledValue mv = (MarshalledValue) unmarshall(valueBytes);\n+                        MarshalledValue mv = unmarshall(valueBytes);\n                         if (mv != null) {\n-                            // TODO race condition: the entry could be updated between the get and delete!\n-                            Metadata metadata = (Metadata) unmarshall(MarshallUtil.toByteArray(mv.getMetadataBytes()));\n-                            if (MarshallableEntryImpl.isExpired(metadata, now, mv.getCreated(), mv.getLastUsed())) {\n-                                // somewhat inefficient to FIND then REMOVE...\n-                                db.delete(handle, keyBytes);\n-                                purgeListener.entryPurged(key);\n-                                count++;\n-                            }\n+                           // TODO race condition: the entry could be updated between the get and delete!\n+                           Metadata metadata = unmarshall(MarshallUtil.toByteArray(mv.getMetadataBytes()));\n+                           if (MarshallableEntryImpl.isExpired(metadata, now, mv.getCreated(), mv.getLastUsed())) {\n+                              // somewhat inefficient to FIND then REMOVE... but required if the value is updated\n+                              db.delete(handle, keyBytes);\n+                              processor.onNext(entryFactory.create(key, mv));\n+                              count++;\n+                           }\n                         }\n-                    }\n-                    if (count != 0)\n+                     }\n+                     if (count != 0)\n                         log.debugf(\"purged %d entries\", count);\n-                } catch (Exception e) {\n-                    throw new PersistenceException(e);\n-                } finally {\n-                    readOptions.close();\n-                }\n-            }\n-        } catch (PersistenceException e) {\n-            throw e;\n-        } catch (Exception e) {\n-            throw new PersistenceException(e);\n-        } finally {\n-            semaphore.release();\n-        }\n-    }\n-\n-    @Override\n-    public void addSegments(IntSet segments) {\n-        handler.addSegments(segments);\n-    }\n-\n-    @Override\n-    public void removeSegments(IntSet segments) {\n-        handler.removeSegments(segments);\n-    }\n-\n-    private byte[] marshall(Object entry) throws IOException, InterruptedException {\n-        return marshaller.objectToByteBuffer(entry);\n-    }\n-\n-    private Object unmarshall(byte[] bytes) throws IOException, ClassNotFoundException {\n-        if (bytes == null)\n-            return null;\n-\n-        return marshaller.objectFromByteBuffer(bytes);\n-    }\n-\n-    private MarshallableEntry<K, V> valueToMarshallableEntry(Object key, byte[] valueBytes, boolean fetchMeta) throws IOException, ClassNotFoundException {\n-        MarshalledValue value = (MarshalledValue) unmarshall(valueBytes);\n-        if (value == null) return null;\n-\n-        ByteBuffer metadataBytes = fetchMeta ? value.getMetadataBytes() : null;\n-        return entryFactory.create(key, value.getValueBytes(), metadataBytes, value.getInternalMetadataBytes(), value.getCreated(), value.getLastUsed());\n-    }\n-\n-    private void addNewExpiry(MarshallableEntry entry) throws RocksDBException, IOException, ClassNotFoundException {\n-        long expiry = entry.expiryTime();\n-        long maxIdle = entry.getMetadata().maxIdle();\n-        if (maxIdle > 0) {\n-            // Coding getExpiryTime() for transient entries has the risk of being a moving target\n-            // which could lead to unexpected results, hence, InternalCacheEntry calls are required\n-            expiry = maxIdle + ctx.getTimeService().wallClockTime();\n-        }\n-        try {\n-            byte[] keyBytes = entry.getKeyBytes().copy().getBuf();\n-            putExpireDbData(new ExpiryEntry(expiry, keyBytes));\n-        } catch (InterruptedException e) {\n-            Thread.currentThread().interrupt(); // Restore interruption status\n-        }\n-    }\n-\n-    @ProtoTypeId(ProtoStreamTypeIds.ROCKSDB_EXPIRY_BUCKET)\n-    static final class ExpiryBucket {\n-        @ProtoField(number = 1, collectionImplementation = ArrayList.class)\n-        List<byte[]> entries;\n-\n-        ExpiryBucket(){}\n-\n-        ExpiryBucket(byte[] existingKey, byte[] newKey) {\n-            entries = new ArrayList<>(2);\n-            entries.add(existingKey);\n-            entries.add(newKey);\n-        }\n-    }\n-\n-    private static final class ExpiryEntry {\n-\n-        final long expiry;\n-        final byte[] keyBytes;\n-\n-        ExpiryEntry(long expiry, byte[] keyBytes) {\n-            this.expiry = expiry;\n-            this.keyBytes = keyBytes;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            ExpiryEntry that = (ExpiryEntry) o;\n-            return expiry == that.expiry &&\n-                  Arrays.equals(keyBytes, that.keyBytes);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            int result = Objects.hash(expiry);\n-            result = 31 * result + Arrays.hashCode(keyBytes);\n-            return result;\n-        }\n-    }\n-\n-    private class RocksKeyIterator extends AbstractIterator<K> {\n-        private final RocksIterator it;\n-        private final Predicate<? super K> filter;\n-\n-        public RocksKeyIterator(RocksIterator it, Predicate<? super K> filter) {\n-            this.it = it;\n-            this.filter = filter;\n-        }\n-\n-        @Override\n-        protected K getNext() {\n-            K key = null;\n-            try {\n-                while (key == null && it.isValid()) {\n-                    K testKey = (K) unmarshall(it.key());\n-                    if (filter == null || filter.test(testKey)) {\n-                        key = testKey;\n-                    }\n-                    it.next();\n-                }\n-            } catch (IOException | ClassNotFoundException e) {\n-                throw new CacheException(e);\n-            }\n-            return key;\n-        }\n-    }\n-\n-    private class RocksEntryIterator extends AbstractIterator<MarshallableEntry<K, V>> {\n-        private final RocksIterator it;\n-        private final Predicate<? super K> filter;\n-        private final boolean fetchValue;\n-        private final boolean fetchMetadata;\n-        private final long now;\n-\n-        public RocksEntryIterator(RocksIterator it, Predicate<? super K> filter, boolean fetchValue,\n-              boolean fetchMetadata, long now) {\n-            this.it = it;\n-            this.filter = filter;\n-            this.fetchValue = fetchValue;\n-            this.fetchMetadata = fetchMetadata;\n-            this.now = now;\n-        }\n-\n-        @Override\n-        protected MarshallableEntry<K, V> getNext() {\n-            MarshallableEntry<K, V> entry = null;\n-            try {\n-                while (entry == null && it.isValid()) {\n-                    K key = (K) unmarshall(it.key());\n-                    if (filter == null || filter.test(key)) {\n-                        if (fetchValue || fetchMetadata) {\n-                            MarshallableEntry<K, V> me = valueToMarshallableEntry(key, it.value(), fetchMetadata);\n-                            if (me != null && !me.isExpired(now)) {\n-                                entry = me;\n-                            }\n-                        } else {\n-                            entry = entryFactory.create(key);\n-                        }\n-                    }\n-                    it.next();\n-                }\n-            } catch (IOException | ClassNotFoundException e) {\n-                throw new CacheException(e);\n-            }\n-            return entry;\n-        }\n-    }\n-\n-    private abstract class RocksDBHandler {\n-\n-        abstract RocksDB open(Path location, DBOptions options) throws RocksDBException;\n-\n-        abstract void close();\n-\n-        abstract ColumnFamilyHandle getHandle(int segment);\n-\n-        final ColumnFamilyHandle getHandle(int segment, Object key) {\n-            if (segment < 0) {\n-                segment = calculateSegment(key);\n-            }\n-            return getHandle(segment);\n-        }\n-\n-        abstract int calculateSegment(Object key);\n-\n-        ColumnFamilyDescriptor newDescriptor(byte[] name) {\n-            ColumnFamilyOptions columnFamilyOptions;\n-            if (columnFamilyProperties != null) {\n-                columnFamilyOptions = ColumnFamilyOptions.getColumnFamilyOptionsFromProps(columnFamilyProperties);\n-                if (columnFamilyOptions == null) {\n-                    throw log.rocksDBUnknownPropertiesSupplied(columnFamilyProperties.toString());\n-                }\n+                  } catch (Exception e) {\n+                     throw new PersistenceException(e);\n+                  } finally {\n+                     readOptions.close();\n+                  }\n+               }\n+            }\n+         }, \"rocksdb-purgeExpired\").whenComplete((ignore, t) -> {\n+            if (t != null) {\n+               processor.onError(t);\n             } else {\n-                columnFamilyOptions = new ColumnFamilyOptions();\n-            }\n-            return new ColumnFamilyDescriptor(name,\n-                  columnFamilyOptions.setCompressionType(CompressionType.getCompressionType(configuration.compressionType().toString())));\n-        }\n-\n-        boolean contains(int segment, Object key) {\n-            // This might be able to use RocksDB#keyMayExist - but API is a bit flaky\n-            return load(segment, key) != null;\n-        }\n-\n-        MarshallableEntry<K, V> load(int segment, Object key) {\n-            ColumnFamilyHandle handle = getHandle(segment, key);\n-            if (handle == null) {\n-                log.trace(\"Ignoring load as handle is not currently configured\");\n-                return null;\n-            }\n-            try {\n-                byte[] entryBytes;\n-                semaphore.acquire();\n-                try {\n-                    if (stopped) {\n-                        throw new PersistenceException(\"RocksDB is stopped\");\n-                    }\n-\n-                    entryBytes = db.get(handle, marshall(key));\n-                } finally {\n-                    semaphore.release();\n-                }\n-                MarshallableEntry<K, V> me = valueToMarshallableEntry(key, entryBytes, true);\n-                if (me == null || me.isExpired(timeService.wallClockTime())) {\n-                    return null;\n-                }\n-                return me;\n-            } catch (Exception e) {\n-                throw new PersistenceException(e);\n-            }\n-        }\n-\n-        void write(int segment, MarshallableEntry<? extends K, ? extends V> me) {\n-            Object key = me.getKey();\n-            ColumnFamilyHandle handle = getHandle(segment, key);\n-            if (handle == null) {\n-                log.trace(\"Ignoring write as handle is not currently configured\");\n-                return;\n-            }\n-            try {\n-                byte[] marshalledKey = MarshallUtil.toByteArray(me.getKeyBytes());\n-                byte[] marshalledValue = marshall(me.getMarshalledValue());\n-                semaphore.acquire();\n-                try {\n-                    if (stopped) {\n-                        throw new PersistenceException(\"RocksDB is stopped\");\n-                    }\n-                    db.put(handle, marshalledKey, marshalledValue);\n-                } finally {\n-                    semaphore.release();\n-                }\n-                if (me.expiryTime() > -1) {\n-                    addNewExpiry(me);\n-                }\n-            } catch (Exception e) {\n-                throw new PersistenceException(e);\n-            }\n-        }\n-\n-        boolean delete(int segment, Object key) {\n-            try {\n-                byte[] keyBytes = marshall(key);\n-                semaphore.acquire();\n-                try {\n-                    if (stopped) {\n-                        throw new PersistenceException(\"RocksDB is stopped\");\n-                    }\n-                    if (db.get(getHandle(segment, key), keyBytes) == null) {\n-                        return false;\n-                    }\n-                    db.delete(getHandle(segment, key), keyBytes);\n-                } finally {\n-                    semaphore.release();\n-                }\n-                return true;\n-            } catch (Exception e) {\n-                throw new PersistenceException(e);\n-            }\n-        }\n-\n-        CompletionStage<Void> writeBatch(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-            return Flowable.fromPublisher(publisher)\n-                  .buffer(configuration.maxBatchSize())\n-                  .doOnNext(entries -> {\n-                      WriteBatch batch = new WriteBatch();\n-                      for (MarshallableEntry<? extends K, ? extends V> entry : entries) {\n-                          int segment = calculateSegment(entry.getKey());\n-                          byte[] keyBytes = MarshallUtil.toByteArray(entry.getKeyBytes());\n-                          batch.put(getHandle(segment), keyBytes, marshall(entry.getMarshalledValue()));\n-                      }\n-                      writeBatch(batch);\n-\n-                      // Add metadata only after batch has been written\n-                      for (MarshallableEntry entry : entries) {\n-                          if (entry.expiryTime() > -1)\n-                              addNewExpiry(entry);\n-                      }\n-                  })\n-                  .doOnError(e -> {\n-                      throw new PersistenceException(e);\n-                  })\n-                  .ignoreElements()\n-                  .toCompletionStage(null);\n-        }\n-\n-        void deleteBatch(Iterable<Object> keys) {\n-            try {\n-                int batchSize = 0;\n-                WriteBatch batch = new WriteBatch();\n-                for (Object key : keys) {\n-                    batch.remove(getHandle(calculateSegment(key)), marshall(key));\n-                    batchSize++;\n-\n-                    if (batchSize == configuration.maxBatchSize()) {\n-                        batchSize = 0;\n-                        writeBatch(batch);\n-                        batch = new WriteBatch();\n-                    }\n-                }\n-\n-                if (batchSize != 0)\n-                    writeBatch(batch);\n-            } catch (Exception e) {\n-                throw new PersistenceException(e);\n-            }\n-        }\n-\n-        abstract void clear(IntSet segments);\n-\n-        abstract Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter);\n-\n-        abstract Publisher<MarshallableEntry<K, V>> publishEntries(IntSet segments, Predicate<? super K> filter,\n-                                                                   boolean fetchValue, boolean fetchMetadata);\n+               processor.onComplete();\n+            }\n+         });\n+         return processor;\n+      });\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> addSegments(IntSet segments) {\n+      return handler.addSegments(segments);\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> removeSegments(IntSet segments) {\n+      return handler.removeSegments(segments);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> isAvailable() {\n+      return blockingManager.supplyBlocking(() -> getLocation().toFile().exists() && getExpirationLocation().toFile().exists(),\n+            \"rocksdb-available\");\n+   }\n+\n+   private abstract class RocksDBHandler {\n+\n+      abstract RocksDB open(Path location, DBOptions options) throws RocksDBException;\n+\n+      abstract void close();\n+\n+      abstract ColumnFamilyHandle getHandle(int segment);\n+\n+      abstract ColumnFamilyHandle getHandle(Object key);\n+\n+      ColumnFamilyDescriptor newDescriptor(byte[] name) {\n+         ColumnFamilyOptions columnFamilyOptions;\n+         if (columnFamilyProperties != null) {\n+            columnFamilyOptions = ColumnFamilyOptions.getColumnFamilyOptionsFromProps(columnFamilyProperties);\n+            if (columnFamilyOptions == null) {\n+               throw log.rocksDBUnknownPropertiesSupplied(columnFamilyProperties.toString());\n+            }\n+         } else {\n+            columnFamilyOptions = new ColumnFamilyOptions();\n+         }\n+         return new ColumnFamilyDescriptor(name,\n+               columnFamilyOptions.setCompressionType(CompressionType.getCompressionType(configuration.compressionType().toString())));\n+      }\n+\n+      CompletionStage<Boolean> contains(int segment, Object key) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0OTU4OQ=="}, "originalCommit": {"oid": "be24dc2231fa8baed421fe4a622b5347481a67a9"}, "originalPosition": 1018}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzQ3MDU1OnYy", "diffSide": "RIGHT", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNToyNjoyOFrOGehKig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNToyNjoyOFrOGehKig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MzgzNA==", "bodyText": "Never used.", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r434653834", "createdAt": "2020-06-03T15:26:28Z", "author": {"login": "ryanemerson"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -67,1091 +67,933 @@\n import org.rocksdb.WriteOptions;\n \n import io.reactivex.rxjava3.core.Flowable;\n-\n-@Store\n-@ConfiguredBy(RocksDBStoreConfiguration.class)\n-public class RocksDBStore<K,V> implements SegmentedAdvancedLoadWriteStore<K,V> {\n-    private static final Log log = LogFactory.getLog(RocksDBStore.class, Log.class);\n-    static final String DATABASE_PROPERTY_NAME_WITH_SUFFIX = \"database.\";\n-    static final String COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX = \"data.\";\n-\n-    protected RocksDBStoreConfiguration configuration;\n-    private RocksDB db;\n-    private RocksDB expiredDb;\n-    private InitializationContext ctx;\n-    private TimeService timeService;\n-    private Semaphore semaphore;\n-    private WriteOptions dataWriteOptions;\n-    private RocksDBHandler handler;\n-    private Properties databaseProperties;\n-    private Properties columnFamilyProperties;\n-    private Marshaller marshaller;\n-    private MarshallableEntryFactory<K, V> entryFactory;\n-    private volatile boolean stopped = true;\n-\n-    @Override\n-    public void init(InitializationContext ctx) {\n-        this.configuration = ctx.getConfiguration();\n-        this.ctx = ctx;\n-        this.timeService = ctx.getTimeService();\n-        this.marshaller = ctx.getPersistenceMarshaller();\n-        this.semaphore = new Semaphore(Integer.MAX_VALUE, true);\n-        this.entryFactory = ctx.getMarshallableEntryFactory();\n-        ctx.getPersistenceMarshaller().register(new PersistenceContextInitializerImpl());\n-    }\n-\n-    @Override\n-    public void start() {\n-\n-        AdvancedCache cache = ctx.getCache().getAdvancedCache();\n-        KeyPartitioner keyPartitioner = cache.getComponentRegistry().getComponent(KeyPartitioner.class);\n-        if (configuration.segmented()) {\n-            handler = new SegmentedRocksDBHandler(cache.getCacheConfiguration().clustering().hash().numSegments(),\n-                  keyPartitioner);\n-        } else {\n-            handler = new NonSegmentedRocksDBHandler(keyPartitioner);\n-        }\n-\n-        // Has to be done before we open the database, so we can pass the properties\n-        Properties allProperties = configuration.properties();\n-        for (Map.Entry<Object, Object> entry : allProperties.entrySet()) {\n-            String key = entry.getKey().toString();\n-            if (key.startsWith(DATABASE_PROPERTY_NAME_WITH_SUFFIX)) {\n-                if (databaseProperties == null) {\n-                    databaseProperties = new Properties();\n-                }\n-                databaseProperties.setProperty(key.substring(DATABASE_PROPERTY_NAME_WITH_SUFFIX.length()), entry.getValue().toString());\n-            } else if (key.startsWith(COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX)) {\n-                if (columnFamilyProperties == null) {\n-                    columnFamilyProperties = new Properties();\n-                }\n-                columnFamilyProperties.setProperty(key.substring(COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX.length()), entry.getValue().toString());\n-            }\n-        }\n-\n-        try {\n+import io.reactivex.rxjava3.processors.UnicastProcessor;\n+\n+public class RocksDBStore<K, V> implements NonBlockingStore<K, V> {\n+   private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass(), Log.class);\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   static final String DATABASE_PROPERTY_NAME_WITH_SUFFIX = \"database.\";\n+   static final String COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX = \"data.\";\n+\n+   protected RocksDBStoreConfiguration configuration;\n+   private RocksDB db;\n+   private RocksDB expiredDb;\n+   private InitializationContext ctx;\n+   private TimeService timeService;\n+   private WriteOptions dataWriteOptions;\n+   private RocksDBHandler handler;\n+   private Properties databaseProperties;\n+   private Properties columnFamilyProperties;\n+   private Marshaller marshaller;\n+   private KeyPartitioner keyPartitioner;\n+   private MarshallableEntryFactory<K, V> entryFactory;\n+   private BlockingManager blockingManager;\n+\n+   @Override\n+   public CompletionStage<Void> start(InitializationContext ctx) {\n+      this.configuration = ctx.getConfiguration();\n+      this.ctx = ctx;\n+      this.timeService = ctx.getTimeService();\n+      this.marshaller = ctx.getPersistenceMarshaller();\n+      this.entryFactory = ctx.getMarshallableEntryFactory();\n+      this.blockingManager = ctx.getBlockingManager();\n+      this.keyPartitioner = ctx.getKeyPartitioner();\n+\n+      ctx.getPersistenceMarshaller().register(new PersistenceContextInitializerImpl());\n+\n+      AdvancedCache cache = ctx.getCache().getAdvancedCache();\n+      if (configuration.segmented()) {\n+         handler = new SegmentedRocksDBHandler(cache.getCacheConfiguration().clustering().hash().numSegments());\n+      } else {\n+         handler = new NonSegmentedRocksDBHandler(keyPartitioner);\n+      }\n+\n+      // Has to be done before we open the database, so we can pass the properties\n+      Properties allProperties = configuration.properties();\n+      for (Map.Entry<Object, Object> entry : allProperties.entrySet()) {\n+         String key = entry.getKey().toString();\n+         if (key.startsWith(DATABASE_PROPERTY_NAME_WITH_SUFFIX)) {\n+            if (databaseProperties == null) {\n+               databaseProperties = new Properties();\n+            }\n+            databaseProperties.setProperty(key.substring(DATABASE_PROPERTY_NAME_WITH_SUFFIX.length()), entry.getValue().toString());\n+         } else if (key.startsWith(COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX)) {\n+            if (columnFamilyProperties == null) {\n+               columnFamilyProperties = new Properties();\n+            }\n+            columnFamilyProperties.setProperty(key.substring(COLUMN_FAMILY_PROPERTY_NAME_WITH_SUFFIX.length()), entry.getValue().toString());\n+         }\n+      }\n+\n+      return blockingManager.runBlocking(() -> {\n+         try {\n             db = handler.open(getLocation(), dataDbOptions());\n             expiredDb = openDatabase(getExpirationLocation(), expiredDbOptions());\n-            stopped = false;\n-        } catch (Exception e) {\n+         } catch (Exception e) {\n             throw new CacheConfigurationException(\"Unable to open database\", e);\n-        }\n-    }\n-\n-    private Path getLocation() {\n-        return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.location(), ctx.getCache().getName(), \"data\");\n-    }\n-\n-    private Path getExpirationLocation() {\n-        return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.expiredLocation(), ctx.getCache().getName(), \"expired\");\n-    }\n-\n-    private WriteOptions dataWriteOptions() {\n-        if (dataWriteOptions == null)\n-            dataWriteOptions = new WriteOptions().setDisableWAL(false);\n-        return dataWriteOptions;\n-    }\n-\n-    protected DBOptions dataDbOptions() {\n-        DBOptions dbOptions;\n-        if (databaseProperties != null) {\n-            dbOptions = DBOptions.getDBOptionsFromProps(databaseProperties);\n-            if (dbOptions == null) {\n-                throw log.rocksDBUnknownPropertiesSupplied(databaseProperties.toString());\n-            }\n-        } else {\n-            dbOptions = new DBOptions();\n-        }\n-        return dbOptions\n-              .setCreateIfMissing(true)\n-              // We have to create missing column families on open.\n-              // Otherwise when we start we won't know what column families this database had if any - thus\n-              // we must specify all of them and later remove them.\n-              .setCreateMissingColumnFamilies(true);\n-    }\n-\n-    protected Options expiredDbOptions() {\n-        return new Options()\n-              .setCreateIfMissing(true)\n-              // Make sure keys are sorted by bytes - we use this sorting to remove entries that have expired most recently\n-              .setComparator(BuiltinComparator.BYTEWISE_COMPARATOR);\n-    }\n-\n-    /**\n-     * Creates database if it doesn't exist.\n-     */\n-    protected RocksDB openDatabase(Path location, Options options) throws RocksDBException {\n-        File dir = location.toFile();\n-        dir.mkdirs();\n-        return RocksDB.open(options, location.toString());\n-    }\n-\n-    @Override\n-    public void stop() {\n-        try {\n-            semaphore.acquire(Integer.MAX_VALUE);\n-        } catch (InterruptedException e) {\n-            throw new PersistenceException(\"Cannot acquire semaphore\", e);\n-        }\n-        try {\n-            handler.close();\n-            expiredDb.close();\n-        } finally {\n-            stopped = true;\n-            semaphore.release(Integer.MAX_VALUE);\n-        }\n-    }\n-\n-    @Override\n-    public void destroy() {\n-        stop();\n-        Util.recursiveFileRemove(getLocation().toFile());\n-        Util.recursiveFileRemove(getExpirationLocation().toFile());\n-    }\n-\n-    @Override\n-    public boolean isAvailable() {\n-        return getLocation().toFile().exists() && getExpirationLocation().toFile().exists();\n-    }\n-\n-    @Override\n-    public void clear() {\n-        handler.clear(null);\n-    }\n-\n-    @Override\n-    public void clear(IntSet segments) {\n-        handler.clear(segments);\n-    }\n-\n-    @Override\n-    public int size() {\n-        return handler.size(null);\n-    }\n-\n-    @Override\n-    public int size(IntSet segments) {\n-        return handler.size(segments);\n-    }\n-\n-    @Override\n-    public boolean contains(Object key) {\n-        return handler.contains(-1, key);\n-    }\n-\n-    @Override\n-    public boolean contains(int segment, Object key) {\n-        return handler.contains(segment, key);\n-    }\n-\n-    @Override\n-    public Publisher<K> publishKeys(Predicate<? super K> filter) {\n-        return handler.publishKeys(null, filter);\n-    }\n-\n-    @Override\n-    public Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter) {\n-        return handler.publishKeys(segments, filter);\n-    }\n-\n-    @Override\n-    public Publisher<MarshallableEntry<K, V>> entryPublisher(Predicate<? super K> filter, boolean fetchValue, boolean fetchMetadata) {\n-        return handler.publishEntries(null, filter, fetchValue, fetchMetadata);\n-    }\n-\n-    @Override\n-    public Publisher<MarshallableEntry<K, V>> entryPublisher(IntSet segments, Predicate<? super K> filter,\n-                                                             boolean fetchValue, boolean fetchMetadata) {\n-        return handler.publishEntries(segments, filter, fetchValue, fetchMetadata);\n-    }\n-\n-    @Override\n-    public boolean delete(Object key) {\n-        return handler.delete(-1, key);\n-    }\n-\n-    @Override\n-    public boolean delete(int segment, Object key) {\n-        return handler.delete(segment, key);\n-    }\n-\n-    @Override\n-    public void write(MarshallableEntry entry) {\n-        handler.write(-1, entry);\n-    }\n-\n-    @Override\n-    public void write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-        handler.write(segment, entry);\n-    }\n-\n-    @Override\n-    public MarshallableEntry loadEntry(Object key) {\n-        return handler.load(-1, key);\n-    }\n-\n-    @Override\n-    public MarshallableEntry<K, V> get(int segment, Object key) {\n-        return handler.load(segment, key);\n-    }\n-\n-    @Override\n-    public CompletionStage<Void> bulkUpdate(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-        return handler.writeBatch(publisher);\n-    }\n-\n-    @Override\n-    public void deleteBatch(Iterable<Object> keys) {\n-        handler.deleteBatch(keys);\n-    }\n-\n-    private void putExpireDbData(ExpiryEntry entry) throws InterruptedException, RocksDBException, IOException,\n-       ClassNotFoundException {\n-        final byte[] expiryBytes = marshall(entry.expiry);\n-        final byte[] existingBytes = expiredDb.get(expiryBytes);\n-\n-        if (existingBytes != null) {\n-            // in the case of collision make the value a List ...\n-            final Object existing = unmarshall(existingBytes);\n-            if (existing instanceof ExpiryBucket) {\n-                ((ExpiryBucket) existing).entries.add(entry.keyBytes);\n-                expiredDb.put(expiryBytes, marshall(existing));\n-            } else {\n-                ExpiryBucket bucket = new ExpiryBucket(existingBytes, entry.keyBytes);\n-                expiredDb.put(expiryBytes, marshall(bucket));\n-            }\n-        } else {\n-            expiredDb.put(expiryBytes, entry.keyBytes);\n-        }\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public void purge(Executor executor, PurgeListener purgeListener) {\n-        try {\n-            semaphore.acquire();\n-        } catch (InterruptedException e) {\n-            throw new PersistenceException(\"Cannot acquire semaphore: CacheStore is likely stopped.\", e);\n-        }\n-        try (ReadOptions readOptions = new ReadOptions().setFillCache(false)) {\n-            if (stopped) {\n-                throw new PersistenceException(\"RocksDB is stopped\");\n-            }\n-            long now = ctx.getTimeService().wallClockTime();\n-            RocksIterator iterator = expiredDb.newIterator(readOptions);\n-            if (iterator != null) {\n-                try (RocksIterator it = iterator) {\n-                    List<Long> times = new ArrayList<>();\n-                    List<Object> keys = new ArrayList<>();\n-                    List<byte[]> marshalledKeys = new ArrayList<>();\n-\n-                    for (it.seekToFirst(); it.isValid(); it.next()) {\n-                        Long time = (Long) unmarshall(it.key());\n+         }\n+      }, \"rocksdb-open\");\n+   }\n+\n+   private Path getLocation() {\n+      return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.location(), ctx.getCache().getName(), \"data\");\n+   }\n+\n+   private Path getExpirationLocation() {\n+      return getQualifiedLocation(ctx.getGlobalConfiguration(), configuration.expiredLocation(), ctx.getCache().getName(), \"expired\");\n+   }\n+\n+   protected DBOptions dataDbOptions() {\n+      DBOptions dbOptions;\n+      if (databaseProperties != null) {\n+         dbOptions = DBOptions.getDBOptionsFromProps(databaseProperties);\n+         if (dbOptions == null) {\n+            throw log.rocksDBUnknownPropertiesSupplied(databaseProperties.toString());\n+         }\n+      } else {\n+         dbOptions = new DBOptions();\n+      }\n+      return dbOptions\n+            .setCreateIfMissing(true)\n+            // We have to create missing column families on open.\n+            // Otherwise when we start we won't know what column families this database had if any - thus\n+            // we must specify all of them and later remove them.\n+            .setCreateMissingColumnFamilies(true);\n+   }\n+\n+   protected Options expiredDbOptions() {\n+      return new Options()\n+            .setCreateIfMissing(true)\n+            // Make sure keys are sorted by bytes - we use this sorting to remove entries that have expired most recently\n+            .setComparator(BuiltinComparator.BYTEWISE_COMPARATOR);\n+   }\n+\n+   /**\n+    * Creates database if it doesn't exist.\n+    */\n+   protected RocksDB openDatabase(Path location, Options options) throws RocksDBException {\n+      File dir = location.toFile();\n+      dir.mkdirs();\n+      return RocksDB.open(options, location.toString());\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> stop() {\n+      return blockingManager.runBlocking(() -> {\n+         handler.close();\n+         expiredDb.close();\n+      }, \"rocksdb-stop\");\n+   }\n+\n+   @Override\n+   public Set<Characteristic> characteristics() {\n+      return EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION, Characteristic.SEGMENTABLE);\n+   }\n+\n+   @Override\n+   public CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key) {\n+      return handler.load(segment, key);\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n+      return handler.write(segment, entry);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> delete(int segment, Object key) {\n+      return handler.delete(segment, key);\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n+         Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n+      WriteBatch batch = new WriteBatch();\n+      Set<MarshallableEntry<K, V>> expirableEntries = new HashSet<>();\n+      Flowable.fromPublisher(removePublisher)\n+            .subscribe(sp -> {\n+               ColumnFamilyHandle handle = handler.getHandle(sp.getSegment());\n+               Flowable.fromPublisher(sp)\n+                     .subscribe(removed -> batch.delete(handle, marshall(removed)));\n+            });\n+      Flowable.fromPublisher(writePublisher)\n+            .subscribe(sp -> {\n+               ColumnFamilyHandle handle = handler.getHandle(sp.getSegment());\n+               Flowable.fromPublisher(sp)\n+                     .subscribe(me -> {\n+                        batch.put(handle, marshall(me.getKey()), marshall(me.getMarshalledValue()));\n+                        if (me.expiryTime() > -1) {\n+                           expirableEntries.add(me);\n+                        }\n+                     });\n+            });\n+      if (batch.count() <= 0) {\n+         batch.close();\n+         return CompletableFutures.completedNull();\n+      }\n+      return blockingManager.runBlocking(() -> {\n+         try {\n+            db.write(dataWriteOptions(), batch);\n+            for (MarshallableEntry<K, V> me : expirableEntries) {\n+               addNewExpiry(me);\n+            }\n+         } catch (RocksDBException e) {\n+            throw new PersistenceException(e);\n+         }\n+      }, \"rocksdb-batch\").whenComplete((ignore, t) -> batch.close());\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> clear() {\n+      return handler.clear();\n+   }\n+\n+   @Override\n+   public Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter) {\n+      return Flowable.fromPublisher(handler.publishEntries(segments, filter, false))\n+            .map(MarshallableEntry::getKey);\n+   }\n+\n+   @Override\n+   public Publisher<MarshallableEntry<K, V>> publishEntries(IntSet segments, Predicate<? super K> filter, boolean includeValues) {\n+      return handler.publishEntries(segments, filter, includeValues);\n+   }\n+\n+   @Override\n+   public CompletionStage<Long> size(IntSet segments) {\n+      return handler.size(segments);\n+   }\n+\n+   @Override\n+   public CompletionStage<Long> approximateSize(IntSet segments) {\n+      return handler.approximateSize(segments);\n+   }\n+\n+   @Override\n+   public Publisher<MarshallableEntry<K, V>> purgeExpired() {\n+      return Flowable.defer(() -> {\n+         UnicastProcessor<MarshallableEntry<K, V>> processor = UnicastProcessor.create();\n+         blockingManager.runBlocking(() -> {\n+            try (ReadOptions readOptions = new ReadOptions().setFillCache(false)) {\n+               long now = ctx.getTimeService().wallClockTime();\n+               RocksIterator iterator = expiredDb.newIterator(readOptions);\n+               if (iterator != null) {\n+                  try (RocksIterator it = iterator) {\n+                     List<Long> times = new ArrayList<>();\n+                     List<Object> keys = new ArrayList<>();\n+                     List<byte[]> marshalledKeys = new ArrayList<>();\n+\n+                     for (it.seekToFirst(); it.isValid(); it.next()) {\n+                        Long time = unmarshall(it.key());\n                         if (time > now)\n-                            break;\n+                           break;\n                         times.add(time);\n                         byte[] marshalledKey = it.value();\n                         Object key = unmarshall(marshalledKey);\n                         if (key instanceof ExpiryBucket) {\n-                            for (byte[] bytes : ((ExpiryBucket) key).entries) {\n-                                marshalledKeys.add(bytes);\n-                                keys.add(unmarshall(bytes));\n-                            }\n+                           for (byte[] bytes : ((ExpiryBucket) key).entries) {\n+                              marshalledKeys.add(bytes);\n+                              keys.add(unmarshall(bytes));\n+                           }\n                         } else {\n-                            keys.add(key);\n-                            marshalledKeys.add(marshalledKey);\n+                           keys.add(key);\n+                           marshalledKeys.add(marshalledKey);\n                         }\n-                    }\n+                     }\n \n-                    for (Long time : times) {\n+                     for (Long time : times) {\n                         expiredDb.delete(marshall(time));\n-                    }\n+                     }\n \n-                    if (!keys.isEmpty())\n+                     if (!keys.isEmpty())\n                         log.debugf(\"purge (up to) %d entries\", keys.size());\n-                    int count = 0;\n-                    for (int i = 0; i < keys.size(); i++) {\n+                     int count = 0;\n+                     for (int i = 0; i < keys.size(); i++) {\n                         Object key = keys.get(i);\n                         byte[] keyBytes = marshalledKeys.get(i);\n-                        int segment = handler.calculateSegment(key);\n \n-                        ColumnFamilyHandle handle = handler.getHandle(segment);\n+                        ColumnFamilyHandle handle = handler.getHandle(key);\n                         byte[] valueBytes = db.get(handle, keyBytes);\n                         if (valueBytes == null)\n-                            continue;\n+                           continue;\n \n-                        MarshalledValue mv = (MarshalledValue) unmarshall(valueBytes);\n+                        MarshalledValue mv = unmarshall(valueBytes);\n                         if (mv != null) {\n-                            // TODO race condition: the entry could be updated between the get and delete!\n-                            Metadata metadata = (Metadata) unmarshall(MarshallUtil.toByteArray(mv.getMetadataBytes()));\n-                            if (MarshallableEntryImpl.isExpired(metadata, now, mv.getCreated(), mv.getLastUsed())) {\n-                                // somewhat inefficient to FIND then REMOVE...\n-                                db.delete(handle, keyBytes);\n-                                purgeListener.entryPurged(key);\n-                                count++;\n-                            }\n+                           // TODO race condition: the entry could be updated between the get and delete!\n+                           Metadata metadata = unmarshall(MarshallUtil.toByteArray(mv.getMetadataBytes()));\n+                           if (MarshallableEntryImpl.isExpired(metadata, now, mv.getCreated(), mv.getLastUsed())) {\n+                              // somewhat inefficient to FIND then REMOVE... but required if the value is updated\n+                              db.delete(handle, keyBytes);\n+                              processor.onNext(entryFactory.create(key, mv));\n+                              count++;\n+                           }\n                         }\n-                    }\n-                    if (count != 0)\n+                     }\n+                     if (count != 0)\n                         log.debugf(\"purged %d entries\", count);\n-                } catch (Exception e) {\n-                    throw new PersistenceException(e);\n-                } finally {\n-                    readOptions.close();\n-                }\n-            }\n-        } catch (PersistenceException e) {\n-            throw e;\n-        } catch (Exception e) {\n-            throw new PersistenceException(e);\n-        } finally {\n-            semaphore.release();\n-        }\n-    }\n-\n-    @Override\n-    public void addSegments(IntSet segments) {\n-        handler.addSegments(segments);\n-    }\n-\n-    @Override\n-    public void removeSegments(IntSet segments) {\n-        handler.removeSegments(segments);\n-    }\n-\n-    private byte[] marshall(Object entry) throws IOException, InterruptedException {\n-        return marshaller.objectToByteBuffer(entry);\n-    }\n-\n-    private Object unmarshall(byte[] bytes) throws IOException, ClassNotFoundException {\n-        if (bytes == null)\n-            return null;\n-\n-        return marshaller.objectFromByteBuffer(bytes);\n-    }\n-\n-    private MarshallableEntry<K, V> valueToMarshallableEntry(Object key, byte[] valueBytes, boolean fetchMeta) throws IOException, ClassNotFoundException {\n-        MarshalledValue value = (MarshalledValue) unmarshall(valueBytes);\n-        if (value == null) return null;\n-\n-        ByteBuffer metadataBytes = fetchMeta ? value.getMetadataBytes() : null;\n-        return entryFactory.create(key, value.getValueBytes(), metadataBytes, value.getInternalMetadataBytes(), value.getCreated(), value.getLastUsed());\n-    }\n-\n-    private void addNewExpiry(MarshallableEntry entry) throws RocksDBException, IOException, ClassNotFoundException {\n-        long expiry = entry.expiryTime();\n-        long maxIdle = entry.getMetadata().maxIdle();\n-        if (maxIdle > 0) {\n-            // Coding getExpiryTime() for transient entries has the risk of being a moving target\n-            // which could lead to unexpected results, hence, InternalCacheEntry calls are required\n-            expiry = maxIdle + ctx.getTimeService().wallClockTime();\n-        }\n-        try {\n-            byte[] keyBytes = entry.getKeyBytes().copy().getBuf();\n-            putExpireDbData(new ExpiryEntry(expiry, keyBytes));\n-        } catch (InterruptedException e) {\n-            Thread.currentThread().interrupt(); // Restore interruption status\n-        }\n-    }\n-\n-    @ProtoTypeId(ProtoStreamTypeIds.ROCKSDB_EXPIRY_BUCKET)\n-    static final class ExpiryBucket {\n-        @ProtoField(number = 1, collectionImplementation = ArrayList.class)\n-        List<byte[]> entries;\n-\n-        ExpiryBucket(){}\n-\n-        ExpiryBucket(byte[] existingKey, byte[] newKey) {\n-            entries = new ArrayList<>(2);\n-            entries.add(existingKey);\n-            entries.add(newKey);\n-        }\n-    }\n-\n-    private static final class ExpiryEntry {\n-\n-        final long expiry;\n-        final byte[] keyBytes;\n-\n-        ExpiryEntry(long expiry, byte[] keyBytes) {\n-            this.expiry = expiry;\n-            this.keyBytes = keyBytes;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            ExpiryEntry that = (ExpiryEntry) o;\n-            return expiry == that.expiry &&\n-                  Arrays.equals(keyBytes, that.keyBytes);\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            int result = Objects.hash(expiry);\n-            result = 31 * result + Arrays.hashCode(keyBytes);\n-            return result;\n-        }\n-    }\n-\n-    private class RocksKeyIterator extends AbstractIterator<K> {\n-        private final RocksIterator it;\n-        private final Predicate<? super K> filter;\n-\n-        public RocksKeyIterator(RocksIterator it, Predicate<? super K> filter) {\n-            this.it = it;\n-            this.filter = filter;\n-        }\n-\n-        @Override\n-        protected K getNext() {\n-            K key = null;\n-            try {\n-                while (key == null && it.isValid()) {\n-                    K testKey = (K) unmarshall(it.key());\n-                    if (filter == null || filter.test(testKey)) {\n-                        key = testKey;\n-                    }\n-                    it.next();\n-                }\n-            } catch (IOException | ClassNotFoundException e) {\n-                throw new CacheException(e);\n-            }\n-            return key;\n-        }\n-    }\n-\n-    private class RocksEntryIterator extends AbstractIterator<MarshallableEntry<K, V>> {\n-        private final RocksIterator it;\n-        private final Predicate<? super K> filter;\n-        private final boolean fetchValue;\n-        private final boolean fetchMetadata;\n-        private final long now;\n-\n-        public RocksEntryIterator(RocksIterator it, Predicate<? super K> filter, boolean fetchValue,\n-              boolean fetchMetadata, long now) {\n-            this.it = it;\n-            this.filter = filter;\n-            this.fetchValue = fetchValue;\n-            this.fetchMetadata = fetchMetadata;\n-            this.now = now;\n-        }\n-\n-        @Override\n-        protected MarshallableEntry<K, V> getNext() {\n-            MarshallableEntry<K, V> entry = null;\n-            try {\n-                while (entry == null && it.isValid()) {\n-                    K key = (K) unmarshall(it.key());\n-                    if (filter == null || filter.test(key)) {\n-                        if (fetchValue || fetchMetadata) {\n-                            MarshallableEntry<K, V> me = valueToMarshallableEntry(key, it.value(), fetchMetadata);\n-                            if (me != null && !me.isExpired(now)) {\n-                                entry = me;\n-                            }\n-                        } else {\n-                            entry = entryFactory.create(key);\n-                        }\n-                    }\n-                    it.next();\n-                }\n-            } catch (IOException | ClassNotFoundException e) {\n-                throw new CacheException(e);\n-            }\n-            return entry;\n-        }\n-    }\n-\n-    private abstract class RocksDBHandler {\n-\n-        abstract RocksDB open(Path location, DBOptions options) throws RocksDBException;\n-\n-        abstract void close();\n-\n-        abstract ColumnFamilyHandle getHandle(int segment);\n-\n-        final ColumnFamilyHandle getHandle(int segment, Object key) {\n-            if (segment < 0) {\n-                segment = calculateSegment(key);\n-            }\n-            return getHandle(segment);\n-        }\n-\n-        abstract int calculateSegment(Object key);\n-\n-        ColumnFamilyDescriptor newDescriptor(byte[] name) {\n-            ColumnFamilyOptions columnFamilyOptions;\n-            if (columnFamilyProperties != null) {\n-                columnFamilyOptions = ColumnFamilyOptions.getColumnFamilyOptionsFromProps(columnFamilyProperties);\n-                if (columnFamilyOptions == null) {\n-                    throw log.rocksDBUnknownPropertiesSupplied(columnFamilyProperties.toString());\n-                }\n+                  } catch (Exception e) {\n+                     throw new PersistenceException(e);\n+                  } finally {\n+                     readOptions.close();\n+                  }\n+               }\n+            }\n+         }, \"rocksdb-purgeExpired\").whenComplete((ignore, t) -> {\n+            if (t != null) {\n+               processor.onError(t);\n             } else {\n-                columnFamilyOptions = new ColumnFamilyOptions();\n-            }\n-            return new ColumnFamilyDescriptor(name,\n-                  columnFamilyOptions.setCompressionType(CompressionType.getCompressionType(configuration.compressionType().toString())));\n-        }\n-\n-        boolean contains(int segment, Object key) {\n-            // This might be able to use RocksDB#keyMayExist - but API is a bit flaky\n-            return load(segment, key) != null;\n-        }\n-\n-        MarshallableEntry<K, V> load(int segment, Object key) {\n-            ColumnFamilyHandle handle = getHandle(segment, key);\n-            if (handle == null) {\n-                log.trace(\"Ignoring load as handle is not currently configured\");\n-                return null;\n-            }\n-            try {\n-                byte[] entryBytes;\n-                semaphore.acquire();\n-                try {\n-                    if (stopped) {\n-                        throw new PersistenceException(\"RocksDB is stopped\");\n-                    }\n-\n-                    entryBytes = db.get(handle, marshall(key));\n-                } finally {\n-                    semaphore.release();\n-                }\n-                MarshallableEntry<K, V> me = valueToMarshallableEntry(key, entryBytes, true);\n-                if (me == null || me.isExpired(timeService.wallClockTime())) {\n-                    return null;\n-                }\n-                return me;\n-            } catch (Exception e) {\n-                throw new PersistenceException(e);\n-            }\n-        }\n-\n-        void write(int segment, MarshallableEntry<? extends K, ? extends V> me) {\n-            Object key = me.getKey();\n-            ColumnFamilyHandle handle = getHandle(segment, key);\n-            if (handle == null) {\n-                log.trace(\"Ignoring write as handle is not currently configured\");\n-                return;\n-            }\n-            try {\n-                byte[] marshalledKey = MarshallUtil.toByteArray(me.getKeyBytes());\n-                byte[] marshalledValue = marshall(me.getMarshalledValue());\n-                semaphore.acquire();\n-                try {\n-                    if (stopped) {\n-                        throw new PersistenceException(\"RocksDB is stopped\");\n-                    }\n-                    db.put(handle, marshalledKey, marshalledValue);\n-                } finally {\n-                    semaphore.release();\n-                }\n-                if (me.expiryTime() > -1) {\n-                    addNewExpiry(me);\n-                }\n-            } catch (Exception e) {\n-                throw new PersistenceException(e);\n-            }\n-        }\n-\n-        boolean delete(int segment, Object key) {\n-            try {\n-                byte[] keyBytes = marshall(key);\n-                semaphore.acquire();\n-                try {\n-                    if (stopped) {\n-                        throw new PersistenceException(\"RocksDB is stopped\");\n-                    }\n-                    if (db.get(getHandle(segment, key), keyBytes) == null) {\n-                        return false;\n-                    }\n-                    db.delete(getHandle(segment, key), keyBytes);\n-                } finally {\n-                    semaphore.release();\n-                }\n-                return true;\n-            } catch (Exception e) {\n-                throw new PersistenceException(e);\n-            }\n-        }\n-\n-        CompletionStage<Void> writeBatch(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-            return Flowable.fromPublisher(publisher)\n-                  .buffer(configuration.maxBatchSize())\n-                  .doOnNext(entries -> {\n-                      WriteBatch batch = new WriteBatch();\n-                      for (MarshallableEntry<? extends K, ? extends V> entry : entries) {\n-                          int segment = calculateSegment(entry.getKey());\n-                          byte[] keyBytes = MarshallUtil.toByteArray(entry.getKeyBytes());\n-                          batch.put(getHandle(segment), keyBytes, marshall(entry.getMarshalledValue()));\n-                      }\n-                      writeBatch(batch);\n-\n-                      // Add metadata only after batch has been written\n-                      for (MarshallableEntry entry : entries) {\n-                          if (entry.expiryTime() > -1)\n-                              addNewExpiry(entry);\n-                      }\n-                  })\n-                  .doOnError(e -> {\n-                      throw new PersistenceException(e);\n-                  })\n-                  .ignoreElements()\n-                  .toCompletionStage(null);\n-        }\n-\n-        void deleteBatch(Iterable<Object> keys) {\n-            try {\n-                int batchSize = 0;\n-                WriteBatch batch = new WriteBatch();\n-                for (Object key : keys) {\n-                    batch.remove(getHandle(calculateSegment(key)), marshall(key));\n-                    batchSize++;\n-\n-                    if (batchSize == configuration.maxBatchSize()) {\n-                        batchSize = 0;\n-                        writeBatch(batch);\n-                        batch = new WriteBatch();\n-                    }\n-                }\n-\n-                if (batchSize != 0)\n-                    writeBatch(batch);\n-            } catch (Exception e) {\n-                throw new PersistenceException(e);\n-            }\n-        }\n-\n-        abstract void clear(IntSet segments);\n-\n-        abstract Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter);\n-\n-        abstract Publisher<MarshallableEntry<K, V>> publishEntries(IntSet segments, Predicate<? super K> filter,\n-                                                                   boolean fetchValue, boolean fetchMetadata);\n+               processor.onComplete();\n+            }\n+         });\n+         return processor;\n+      });\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> addSegments(IntSet segments) {\n+      return handler.addSegments(segments);\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> removeSegments(IntSet segments) {\n+      return handler.removeSegments(segments);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> isAvailable() {\n+      return blockingManager.supplyBlocking(() -> getLocation().toFile().exists() && getExpirationLocation().toFile().exists(),\n+            \"rocksdb-available\");\n+   }\n+\n+   private abstract class RocksDBHandler {\n+\n+      abstract RocksDB open(Path location, DBOptions options) throws RocksDBException;\n+\n+      abstract void close();\n+\n+      abstract ColumnFamilyHandle getHandle(int segment);\n+\n+      abstract ColumnFamilyHandle getHandle(Object key);\n+\n+      ColumnFamilyDescriptor newDescriptor(byte[] name) {\n+         ColumnFamilyOptions columnFamilyOptions;\n+         if (columnFamilyProperties != null) {\n+            columnFamilyOptions = ColumnFamilyOptions.getColumnFamilyOptionsFromProps(columnFamilyProperties);\n+            if (columnFamilyOptions == null) {\n+               throw log.rocksDBUnknownPropertiesSupplied(columnFamilyProperties.toString());\n+            }\n+         } else {\n+            columnFamilyOptions = new ColumnFamilyOptions();\n+         }\n+         return new ColumnFamilyDescriptor(name,\n+               columnFamilyOptions.setCompressionType(CompressionType.getCompressionType(configuration.compressionType().toString())));\n+      }\n+\n+      CompletionStage<Boolean> contains(int segment, Object key) {\n+         // This might be able to use RocksDB#keyMayExist - but API is a bit flaky\n+         return load(segment, key)\n+               .thenApply(Objects::nonNull);\n+      }\n+\n+      CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key) {\n+         ColumnFamilyHandle handle = getHandle(segment);\n+         if (handle == null) {\n+            log.trace(\"Ignoring load as handle is not currently configured\");\n+            return CompletableFutures.completedNull();\n+         }\n+         try {\n+            CompletionStage<byte[]> entryByteStage = blockingManager.supplyBlocking(() -> {\n+               try {\n+                  return db.get(handle, marshall(key));\n+               } catch (RocksDBException e) {\n+                  throw new CompletionException(e);\n+               }\n+            }, \"rocksdb-load\");\n+            return entryByteStage.thenApply(entryBytes -> {\n+               MarshallableEntry<K, V> me = unmarshallEntry(key, entryBytes);\n+               if (me == null || me.isExpired(timeService.wallClockTime())) {\n+                  return null;\n+               }\n+               return me;\n+            });\n+         } catch (Exception e) {\n+            throw new PersistenceException(e);\n+         }\n+      }\n+\n+      CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> me) {\n+         ColumnFamilyHandle handle = getHandle(segment);\n+         if (handle == null) {\n+            log.trace(\"Ignoring write as handle is not currently configured\");\n+            return CompletableFutures.completedNull();\n+         }\n+         try {\n+            byte[] marshalledKey = MarshallUtil.toByteArray(me.getKeyBytes());\n+            byte[] marshalledValue = marshall(me.getMarshalledValue());\n+            return blockingManager.runBlocking(() -> {\n+               try {\n+                  db.put(handle, marshalledKey, marshalledValue);\n+                  if (me.expiryTime() > -1) {\n+                     addNewExpiry(me);\n+                  }\n+               } catch (RocksDBException e) {\n+                  throw new PersistenceException(e);\n+               }\n+            }, \"rocksdb-write\");\n+\n+         } catch (Exception e) {\n+            throw new PersistenceException(e);\n+         }\n+      }\n+\n+      CompletionStage<Boolean> delete(int segment, Object key) {\n+         try {\n+            byte[] keyBytes = marshall(key);\n+            ColumnFamilyHandle handle = getHandle(segment);\n+            return blockingManager.supplyBlocking(() -> {\n+               try {\n+                  if (db.get(handle, keyBytes) == null) {\n+                     return Boolean.FALSE;\n+                  }\n+                  db.delete(handle, keyBytes);\n+                  return Boolean.TRUE;\n+               } catch (RocksDBException e) {\n+                  throw new PersistenceException(e);\n+               }\n+            }, \"rocksdb-delete\");\n+         } catch (Exception e) {\n+            throw new PersistenceException(e);\n+         }\n+      }\n \n-        int size(IntSet segments) {\n-            CompletionStage<Long> stage = Flowable.fromPublisher(publishKeys(segments, null))\n-                  .count().toCompletionStage();\n+      abstract CompletionStage<Void> clear();\n \n-            long count = CompletionStages.join(stage);\n-            if (count > Integer.MAX_VALUE) {\n-                return Integer.MAX_VALUE;\n-            }\n-            return (int) count;\n-        }\n-\n-        <P> Flowable<P> publish(int segment, Function<RocksIterator, Flowable<P>> function) {\n-            ReadOptions readOptions = new ReadOptions().setFillCache(false);\n-            return Flowable.using(() -> {\n-                semaphore.acquire();\n-                if (stopped) {\n-                    throw new PersistenceException(\"RocksDB is stopped\");\n-                }\n-                return wrapIterator(db, readOptions, segment);\n-            }, iterator -> {\n-                if (iterator == null) {\n-                    return Flowable.empty();\n-                }\n-                iterator.seekToFirst();\n-                return function.apply(iterator);\n-            }, iterator -> {\n-                if (iterator != null) {\n-                    iterator.close();\n-                }\n-                readOptions.close();\n-                semaphore.release();\n-            });\n-        }\n+      abstract Publisher<MarshallableEntry<K, V>> publishEntries(IntSet segments, Predicate<? super K> filter,\n+            boolean fetchValue);\n \n-        abstract RocksIterator wrapIterator(RocksDB db, ReadOptions readOptions, int segment);\n+      CompletionStage<Long> size(IntSet segments) {\n+         return Flowable.fromPublisher(publishKeys(segments, null))\n+               .count().toCompletionStage();\n+      }\n \n-        private void writeBatch(WriteBatch batch) throws InterruptedException, RocksDBException {\n-            semaphore.acquire();\n-            try {\n-                if (stopped)\n-                    throw new PersistenceException(\"RocksDB is stopped\");\n+      abstract CompletionStage<Long> approximateSize(IntSet segments);\n \n-                db.write(dataWriteOptions(), batch);\n-            } finally {\n-                batch.close();\n-                semaphore.release();\n+      <P> Publisher<P> publish(int segment, Function<RocksIterator, Flowable<P>> function) {\n+         ReadOptions readOptions = new ReadOptions().setFillCache(false);\n+         return blockingManager.blockingPublisher(Flowable.using(() -> wrapIterator(db, readOptions, segment), iterator -> {\n+            if (iterator == null) {\n+               return Flowable.<P>empty();\n             }\n-        }\n-\n-        abstract void addSegments(IntSet segments);\n-\n-        abstract void removeSegments(IntSet segments);\n-    }\n-\n-    private final class NonSegmentedRocksDBHandler extends RocksDBHandler {\n-        private final KeyPartitioner keyPartitioner;\n-        private ColumnFamilyHandle defaultColumnFamilyHandle;\n-\n-        public NonSegmentedRocksDBHandler(KeyPartitioner keyPartitioner) {\n-            this.keyPartitioner = keyPartitioner;\n-        }\n-\n-        @Override\n-        ColumnFamilyHandle getHandle(int segment) {\n-            return defaultColumnFamilyHandle;\n-        }\n-\n-        @Override\n-        int calculateSegment(Object key) {\n-            // Segment not used\n-            return 0;\n-        }\n-\n-        @Override\n-        RocksDB open(Path location, DBOptions options) throws RocksDBException {\n-            File dir = location.toFile();\n-            dir.mkdirs();\n-            List<ColumnFamilyHandle> handles = new ArrayList<>(1);\n-            RocksDB rocksDB = RocksDB.open(options, location.toString(),\n-                  Collections.singletonList(newDescriptor(RocksDB.DEFAULT_COLUMN_FAMILY)),\n-                  handles);\n-            defaultColumnFamilyHandle = handles.get(0);\n-            return rocksDB;\n-        }\n-\n-        @Override\n-        void clear(IntSet segments) {\n+            iterator.seekToFirst();\n+            return function.apply(iterator);\n+         }, iterator -> {\n+            if (iterator != null) {\n+               iterator.close();\n+            }\n+            readOptions.close();\n+         }));\n+      }\n+\n+      abstract RocksIterator wrapIterator(RocksDB db, ReadOptions readOptions, int segment);\n+\n+      private void writeBatch(WriteBatch batch) throws RocksDBException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be24dc2231fa8baed421fe4a622b5347481a67a9"}, "originalPosition": 1207}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDYwMzY5OnYy", "diffSide": "RIGHT", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOToyOTowMFrOGfnRDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDowODo1MVrOGf78Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMjM4Mw==", "bodyText": "Performing a full load seems wasteful here, as it means that the value has to be unmarshalled even though it is never used.", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r435802383", "createdAt": "2020-06-05T09:29:00Z", "author": {"login": "ryanemerson"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -187,271 +190,268 @@ protected RocksDB openDatabase(Path location, Options options) throws RocksDBExc\n     }\n \n     @Override\n-    public void stop() {\n-        try {\n-            semaphore.acquire(Integer.MAX_VALUE);\n-        } catch (InterruptedException e) {\n-            throw new PersistenceException(\"Cannot acquire semaphore\", e);\n-        }\n-        try {\n+    public CompletionStage<Void> stop() {\n+        return blockingManager.runBlocking(() -> {\n             handler.close();\n             expiredDb.close();\n-        } finally {\n-            stopped = true;\n-            semaphore.release(Integer.MAX_VALUE);\n-        }\n-    }\n-\n-    @Override\n-    public void destroy() {\n-        stop();\n-        Util.recursiveFileRemove(getLocation().toFile());\n-        Util.recursiveFileRemove(getExpirationLocation().toFile());\n+        }, \"rocksdb-stop\");\n     }\n \n     @Override\n-    public boolean isAvailable() {\n-        return getLocation().toFile().exists() && getExpirationLocation().toFile().exists();\n+    public Set<Characteristic> characteristics() {\n+        return EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION, Characteristic.SEGMENTABLE);\n     }\n \n     @Override\n-    public void clear() {\n-        handler.clear(null);\n+    public CompletionStage<Boolean> isAvailable() {\n+        return blockingManager.supplyBlocking(() -> getLocation().toFile().exists() && getExpirationLocation().toFile().exists(),\n+                \"rocksdb-available\");\n     }\n \n     @Override\n-    public void clear(IntSet segments) {\n-        handler.clear(segments);\n+    public CompletionStage<Void> clear() {\n+        return handler.clear();\n     }\n \n     @Override\n-    public int size() {\n-        return handler.size(null);\n-    }\n-\n-    @Override\n-    public int size(IntSet segments) {\n+    public CompletionStage<Long> size(IntSet segments) {\n         return handler.size(segments);\n     }\n \n     @Override\n-    public boolean contains(Object key) {\n-        return handler.contains(-1, key);\n+    public CompletionStage<Long> approximateSize(IntSet segments) {\n+        return handler.approximateSize(segments);\n     }\n \n     @Override\n-    public boolean contains(int segment, Object key) {\n-        return handler.contains(segment, key);\n-    }\n-\n-    @Override\n-    public Publisher<K> publishKeys(Predicate<? super K> filter) {\n-        return handler.publishKeys(null, filter);\n+    public CompletionStage<Boolean> containsKey(int segment, Object key) {\n+        // This might be able to use RocksDB#keyMayExist - but API is a bit flaky\n+        return load(segment, key)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8e91c3ad807c6bdba1406c83b12f4bf79650577"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MTExNA==", "bodyText": "This is the same as it was prior, but I can see if I can add it easily enough.", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r436141114", "createdAt": "2020-06-05T20:08:51Z", "author": {"login": "wburns"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -187,271 +190,268 @@ protected RocksDB openDatabase(Path location, Options options) throws RocksDBExc\n     }\n \n     @Override\n-    public void stop() {\n-        try {\n-            semaphore.acquire(Integer.MAX_VALUE);\n-        } catch (InterruptedException e) {\n-            throw new PersistenceException(\"Cannot acquire semaphore\", e);\n-        }\n-        try {\n+    public CompletionStage<Void> stop() {\n+        return blockingManager.runBlocking(() -> {\n             handler.close();\n             expiredDb.close();\n-        } finally {\n-            stopped = true;\n-            semaphore.release(Integer.MAX_VALUE);\n-        }\n-    }\n-\n-    @Override\n-    public void destroy() {\n-        stop();\n-        Util.recursiveFileRemove(getLocation().toFile());\n-        Util.recursiveFileRemove(getExpirationLocation().toFile());\n+        }, \"rocksdb-stop\");\n     }\n \n     @Override\n-    public boolean isAvailable() {\n-        return getLocation().toFile().exists() && getExpirationLocation().toFile().exists();\n+    public Set<Characteristic> characteristics() {\n+        return EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION, Characteristic.SEGMENTABLE);\n     }\n \n     @Override\n-    public void clear() {\n-        handler.clear(null);\n+    public CompletionStage<Boolean> isAvailable() {\n+        return blockingManager.supplyBlocking(() -> getLocation().toFile().exists() && getExpirationLocation().toFile().exists(),\n+                \"rocksdb-available\");\n     }\n \n     @Override\n-    public void clear(IntSet segments) {\n-        handler.clear(segments);\n+    public CompletionStage<Void> clear() {\n+        return handler.clear();\n     }\n \n     @Override\n-    public int size() {\n-        return handler.size(null);\n-    }\n-\n-    @Override\n-    public int size(IntSet segments) {\n+    public CompletionStage<Long> size(IntSet segments) {\n         return handler.size(segments);\n     }\n \n     @Override\n-    public boolean contains(Object key) {\n-        return handler.contains(-1, key);\n+    public CompletionStage<Long> approximateSize(IntSet segments) {\n+        return handler.approximateSize(segments);\n     }\n \n     @Override\n-    public boolean contains(int segment, Object key) {\n-        return handler.contains(segment, key);\n-    }\n-\n-    @Override\n-    public Publisher<K> publishKeys(Predicate<? super K> filter) {\n-        return handler.publishKeys(null, filter);\n+    public CompletionStage<Boolean> containsKey(int segment, Object key) {\n+        // This might be able to use RocksDB#keyMayExist - but API is a bit flaky\n+        return load(segment, key)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMjM4Mw=="}, "originalCommit": {"oid": "e8e91c3ad807c6bdba1406c83b12f4bf79650577"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDY0NDk5OnYy", "diffSide": "RIGHT", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTo0MTowNFrOGfnq9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoxMjowMlrOGf8A-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwOTAxMg==", "bodyText": "As publishEntries utilises the RocksEntryIterator we're also unnecessarily unmarshalling the value. In this case I think we can simply add a boolean to the RocksEntryIterator constructor and pass the fetchValue parameter to it.", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r435809012", "createdAt": "2020-06-05T09:41:04Z", "author": {"login": "ryanemerson"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -187,271 +190,268 @@ protected RocksDB openDatabase(Path location, Options options) throws RocksDBExc\n     }\n \n     @Override\n-    public void stop() {\n-        try {\n-            semaphore.acquire(Integer.MAX_VALUE);\n-        } catch (InterruptedException e) {\n-            throw new PersistenceException(\"Cannot acquire semaphore\", e);\n-        }\n-        try {\n+    public CompletionStage<Void> stop() {\n+        return blockingManager.runBlocking(() -> {\n             handler.close();\n             expiredDb.close();\n-        } finally {\n-            stopped = true;\n-            semaphore.release(Integer.MAX_VALUE);\n-        }\n-    }\n-\n-    @Override\n-    public void destroy() {\n-        stop();\n-        Util.recursiveFileRemove(getLocation().toFile());\n-        Util.recursiveFileRemove(getExpirationLocation().toFile());\n+        }, \"rocksdb-stop\");\n     }\n \n     @Override\n-    public boolean isAvailable() {\n-        return getLocation().toFile().exists() && getExpirationLocation().toFile().exists();\n+    public Set<Characteristic> characteristics() {\n+        return EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION, Characteristic.SEGMENTABLE);\n     }\n \n     @Override\n-    public void clear() {\n-        handler.clear(null);\n+    public CompletionStage<Boolean> isAvailable() {\n+        return blockingManager.supplyBlocking(() -> getLocation().toFile().exists() && getExpirationLocation().toFile().exists(),\n+                \"rocksdb-available\");\n     }\n \n     @Override\n-    public void clear(IntSet segments) {\n-        handler.clear(segments);\n+    public CompletionStage<Void> clear() {\n+        return handler.clear();\n     }\n \n     @Override\n-    public int size() {\n-        return handler.size(null);\n-    }\n-\n-    @Override\n-    public int size(IntSet segments) {\n+    public CompletionStage<Long> size(IntSet segments) {\n         return handler.size(segments);\n     }\n \n     @Override\n-    public boolean contains(Object key) {\n-        return handler.contains(-1, key);\n+    public CompletionStage<Long> approximateSize(IntSet segments) {\n+        return handler.approximateSize(segments);\n     }\n \n     @Override\n-    public boolean contains(int segment, Object key) {\n-        return handler.contains(segment, key);\n-    }\n-\n-    @Override\n-    public Publisher<K> publishKeys(Predicate<? super K> filter) {\n-        return handler.publishKeys(null, filter);\n+    public CompletionStage<Boolean> containsKey(int segment, Object key) {\n+        // This might be able to use RocksDB#keyMayExist - but API is a bit flaky\n+        return load(segment, key)\n+                .thenApply(Objects::nonNull);\n     }\n \n     @Override\n     public Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter) {\n-        return handler.publishKeys(segments, filter);\n-    }\n-\n-    @Override\n-    public Publisher<MarshallableEntry<K, V>> entryPublisher(Predicate<? super K> filter, boolean fetchValue, boolean fetchMetadata) {\n-        return handler.publishEntries(null, filter, fetchValue, fetchMetadata);\n+        return Flowable.fromPublisher(handler.publishEntries(segments, filter, false))\n+                .map(MarshallableEntry::getKey);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8e91c3ad807c6bdba1406c83b12f4bf79650577"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MjMzMA==", "bodyText": "I looked closely at this one, unfortunately due to the contract of keyPublisher with expiration and the way values are stored we have to always unmarshall the value to get the metadata, so I just consolidated it.", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r436142330", "createdAt": "2020-06-05T20:12:02Z", "author": {"login": "wburns"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -187,271 +190,268 @@ protected RocksDB openDatabase(Path location, Options options) throws RocksDBExc\n     }\n \n     @Override\n-    public void stop() {\n-        try {\n-            semaphore.acquire(Integer.MAX_VALUE);\n-        } catch (InterruptedException e) {\n-            throw new PersistenceException(\"Cannot acquire semaphore\", e);\n-        }\n-        try {\n+    public CompletionStage<Void> stop() {\n+        return blockingManager.runBlocking(() -> {\n             handler.close();\n             expiredDb.close();\n-        } finally {\n-            stopped = true;\n-            semaphore.release(Integer.MAX_VALUE);\n-        }\n-    }\n-\n-    @Override\n-    public void destroy() {\n-        stop();\n-        Util.recursiveFileRemove(getLocation().toFile());\n-        Util.recursiveFileRemove(getExpirationLocation().toFile());\n+        }, \"rocksdb-stop\");\n     }\n \n     @Override\n-    public boolean isAvailable() {\n-        return getLocation().toFile().exists() && getExpirationLocation().toFile().exists();\n+    public Set<Characteristic> characteristics() {\n+        return EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION, Characteristic.SEGMENTABLE);\n     }\n \n     @Override\n-    public void clear() {\n-        handler.clear(null);\n+    public CompletionStage<Boolean> isAvailable() {\n+        return blockingManager.supplyBlocking(() -> getLocation().toFile().exists() && getExpirationLocation().toFile().exists(),\n+                \"rocksdb-available\");\n     }\n \n     @Override\n-    public void clear(IntSet segments) {\n-        handler.clear(segments);\n+    public CompletionStage<Void> clear() {\n+        return handler.clear();\n     }\n \n     @Override\n-    public int size() {\n-        return handler.size(null);\n-    }\n-\n-    @Override\n-    public int size(IntSet segments) {\n+    public CompletionStage<Long> size(IntSet segments) {\n         return handler.size(segments);\n     }\n \n     @Override\n-    public boolean contains(Object key) {\n-        return handler.contains(-1, key);\n+    public CompletionStage<Long> approximateSize(IntSet segments) {\n+        return handler.approximateSize(segments);\n     }\n \n     @Override\n-    public boolean contains(int segment, Object key) {\n-        return handler.contains(segment, key);\n-    }\n-\n-    @Override\n-    public Publisher<K> publishKeys(Predicate<? super K> filter) {\n-        return handler.publishKeys(null, filter);\n+    public CompletionStage<Boolean> containsKey(int segment, Object key) {\n+        // This might be able to use RocksDB#keyMayExist - but API is a bit flaky\n+        return load(segment, key)\n+                .thenApply(Objects::nonNull);\n     }\n \n     @Override\n     public Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter) {\n-        return handler.publishKeys(segments, filter);\n-    }\n-\n-    @Override\n-    public Publisher<MarshallableEntry<K, V>> entryPublisher(Predicate<? super K> filter, boolean fetchValue, boolean fetchMetadata) {\n-        return handler.publishEntries(null, filter, fetchValue, fetchMetadata);\n+        return Flowable.fromPublisher(handler.publishEntries(segments, filter, false))\n+                .map(MarshallableEntry::getKey);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwOTAxMg=="}, "originalCommit": {"oid": "e8e91c3ad807c6bdba1406c83b12f4bf79650577"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDY1NjEzOnYy", "diffSide": "RIGHT", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTo0NDowM1rOGfnxuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwOTo1MTowNFrOGgWt4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgxMDc0NQ==", "bodyText": "I missed this before, but I don't think boolean includeValues should be part of the publishEntries parameters. If you don't require the value, then you should just utilise publishKeys.\nProbably irrelavant now, but boolean includeValues has no Javadocs in the interface.", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r435810745", "createdAt": "2020-06-05T09:44:03Z", "author": {"login": "ryanemerson"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -187,271 +190,268 @@ protected RocksDB openDatabase(Path location, Options options) throws RocksDBExc\n     }\n \n     @Override\n-    public void stop() {\n-        try {\n-            semaphore.acquire(Integer.MAX_VALUE);\n-        } catch (InterruptedException e) {\n-            throw new PersistenceException(\"Cannot acquire semaphore\", e);\n-        }\n-        try {\n+    public CompletionStage<Void> stop() {\n+        return blockingManager.runBlocking(() -> {\n             handler.close();\n             expiredDb.close();\n-        } finally {\n-            stopped = true;\n-            semaphore.release(Integer.MAX_VALUE);\n-        }\n-    }\n-\n-    @Override\n-    public void destroy() {\n-        stop();\n-        Util.recursiveFileRemove(getLocation().toFile());\n-        Util.recursiveFileRemove(getExpirationLocation().toFile());\n+        }, \"rocksdb-stop\");\n     }\n \n     @Override\n-    public boolean isAvailable() {\n-        return getLocation().toFile().exists() && getExpirationLocation().toFile().exists();\n+    public Set<Characteristic> characteristics() {\n+        return EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION, Characteristic.SEGMENTABLE);\n     }\n \n     @Override\n-    public void clear() {\n-        handler.clear(null);\n+    public CompletionStage<Boolean> isAvailable() {\n+        return blockingManager.supplyBlocking(() -> getLocation().toFile().exists() && getExpirationLocation().toFile().exists(),\n+                \"rocksdb-available\");\n     }\n \n     @Override\n-    public void clear(IntSet segments) {\n-        handler.clear(segments);\n+    public CompletionStage<Void> clear() {\n+        return handler.clear();\n     }\n \n     @Override\n-    public int size() {\n-        return handler.size(null);\n-    }\n-\n-    @Override\n-    public int size(IntSet segments) {\n+    public CompletionStage<Long> size(IntSet segments) {\n         return handler.size(segments);\n     }\n \n     @Override\n-    public boolean contains(Object key) {\n-        return handler.contains(-1, key);\n+    public CompletionStage<Long> approximateSize(IntSet segments) {\n+        return handler.approximateSize(segments);\n     }\n \n     @Override\n-    public boolean contains(int segment, Object key) {\n-        return handler.contains(segment, key);\n-    }\n-\n-    @Override\n-    public Publisher<K> publishKeys(Predicate<? super K> filter) {\n-        return handler.publishKeys(null, filter);\n+    public CompletionStage<Boolean> containsKey(int segment, Object key) {\n+        // This might be able to use RocksDB#keyMayExist - but API is a bit flaky\n+        return load(segment, key)\n+                .thenApply(Objects::nonNull);\n     }\n \n     @Override\n     public Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter) {\n-        return handler.publishKeys(segments, filter);\n-    }\n-\n-    @Override\n-    public Publisher<MarshallableEntry<K, V>> entryPublisher(Predicate<? super K> filter, boolean fetchValue, boolean fetchMetadata) {\n-        return handler.publishEntries(null, filter, fetchValue, fetchMetadata);\n+        return Flowable.fromPublisher(handler.publishEntries(segments, filter, false))\n+                .map(MarshallableEntry::getKey);\n     }\n \n     @Override\n-    public Publisher<MarshallableEntry<K, V>> entryPublisher(IntSet segments, Predicate<? super K> filter,\n-                                                             boolean fetchValue, boolean fetchMetadata) {\n-        return handler.publishEntries(segments, filter, fetchValue, fetchMetadata);\n+    public Publisher<MarshallableEntry<K, V>> publishEntries(IntSet segments, Predicate<? super K> filter, boolean includeValues) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8e91c3ad807c6bdba1406c83b12f4bf79650577"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MjYyMg==", "bodyText": "You can use publishEntries with includeValues as false to get the metadata still (although  most stores may still return the value).", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r436142622", "createdAt": "2020-06-05T20:12:45Z", "author": {"login": "wburns"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -187,271 +190,268 @@ protected RocksDB openDatabase(Path location, Options options) throws RocksDBExc\n     }\n \n     @Override\n-    public void stop() {\n-        try {\n-            semaphore.acquire(Integer.MAX_VALUE);\n-        } catch (InterruptedException e) {\n-            throw new PersistenceException(\"Cannot acquire semaphore\", e);\n-        }\n-        try {\n+    public CompletionStage<Void> stop() {\n+        return blockingManager.runBlocking(() -> {\n             handler.close();\n             expiredDb.close();\n-        } finally {\n-            stopped = true;\n-            semaphore.release(Integer.MAX_VALUE);\n-        }\n-    }\n-\n-    @Override\n-    public void destroy() {\n-        stop();\n-        Util.recursiveFileRemove(getLocation().toFile());\n-        Util.recursiveFileRemove(getExpirationLocation().toFile());\n+        }, \"rocksdb-stop\");\n     }\n \n     @Override\n-    public boolean isAvailable() {\n-        return getLocation().toFile().exists() && getExpirationLocation().toFile().exists();\n+    public Set<Characteristic> characteristics() {\n+        return EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION, Characteristic.SEGMENTABLE);\n     }\n \n     @Override\n-    public void clear() {\n-        handler.clear(null);\n+    public CompletionStage<Boolean> isAvailable() {\n+        return blockingManager.supplyBlocking(() -> getLocation().toFile().exists() && getExpirationLocation().toFile().exists(),\n+                \"rocksdb-available\");\n     }\n \n     @Override\n-    public void clear(IntSet segments) {\n-        handler.clear(segments);\n+    public CompletionStage<Void> clear() {\n+        return handler.clear();\n     }\n \n     @Override\n-    public int size() {\n-        return handler.size(null);\n-    }\n-\n-    @Override\n-    public int size(IntSet segments) {\n+    public CompletionStage<Long> size(IntSet segments) {\n         return handler.size(segments);\n     }\n \n     @Override\n-    public boolean contains(Object key) {\n-        return handler.contains(-1, key);\n+    public CompletionStage<Long> approximateSize(IntSet segments) {\n+        return handler.approximateSize(segments);\n     }\n \n     @Override\n-    public boolean contains(int segment, Object key) {\n-        return handler.contains(segment, key);\n-    }\n-\n-    @Override\n-    public Publisher<K> publishKeys(Predicate<? super K> filter) {\n-        return handler.publishKeys(null, filter);\n+    public CompletionStage<Boolean> containsKey(int segment, Object key) {\n+        // This might be able to use RocksDB#keyMayExist - but API is a bit flaky\n+        return load(segment, key)\n+                .thenApply(Objects::nonNull);\n     }\n \n     @Override\n     public Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter) {\n-        return handler.publishKeys(segments, filter);\n-    }\n-\n-    @Override\n-    public Publisher<MarshallableEntry<K, V>> entryPublisher(Predicate<? super K> filter, boolean fetchValue, boolean fetchMetadata) {\n-        return handler.publishEntries(null, filter, fetchValue, fetchMetadata);\n+        return Flowable.fromPublisher(handler.publishEntries(segments, filter, false))\n+                .map(MarshallableEntry::getKey);\n     }\n \n     @Override\n-    public Publisher<MarshallableEntry<K, V>> entryPublisher(IntSet segments, Predicate<? super K> filter,\n-                                                             boolean fetchValue, boolean fetchMetadata) {\n-        return handler.publishEntries(segments, filter, fetchValue, fetchMetadata);\n+    public Publisher<MarshallableEntry<K, V>> publishEntries(IntSet segments, Predicate<? super K> filter, boolean includeValues) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgxMDc0NQ=="}, "originalCommit": {"oid": "e8e91c3ad807c6bdba1406c83b12f4bf79650577"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjU3OTgxMQ==", "bodyText": "Ok, in that case publishEntries is still missing the JavDoc for the includeValues parameter. As part of the main javadocs \"body\" I think you should include your explanation of why !includeValues is useful and that some stores may still return the value in MarshallableEntry.", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r436579811", "createdAt": "2020-06-08T09:51:04Z", "author": {"login": "ryanemerson"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -187,271 +190,268 @@ protected RocksDB openDatabase(Path location, Options options) throws RocksDBExc\n     }\n \n     @Override\n-    public void stop() {\n-        try {\n-            semaphore.acquire(Integer.MAX_VALUE);\n-        } catch (InterruptedException e) {\n-            throw new PersistenceException(\"Cannot acquire semaphore\", e);\n-        }\n-        try {\n+    public CompletionStage<Void> stop() {\n+        return blockingManager.runBlocking(() -> {\n             handler.close();\n             expiredDb.close();\n-        } finally {\n-            stopped = true;\n-            semaphore.release(Integer.MAX_VALUE);\n-        }\n-    }\n-\n-    @Override\n-    public void destroy() {\n-        stop();\n-        Util.recursiveFileRemove(getLocation().toFile());\n-        Util.recursiveFileRemove(getExpirationLocation().toFile());\n+        }, \"rocksdb-stop\");\n     }\n \n     @Override\n-    public boolean isAvailable() {\n-        return getLocation().toFile().exists() && getExpirationLocation().toFile().exists();\n+    public Set<Characteristic> characteristics() {\n+        return EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION, Characteristic.SEGMENTABLE);\n     }\n \n     @Override\n-    public void clear() {\n-        handler.clear(null);\n+    public CompletionStage<Boolean> isAvailable() {\n+        return blockingManager.supplyBlocking(() -> getLocation().toFile().exists() && getExpirationLocation().toFile().exists(),\n+                \"rocksdb-available\");\n     }\n \n     @Override\n-    public void clear(IntSet segments) {\n-        handler.clear(segments);\n+    public CompletionStage<Void> clear() {\n+        return handler.clear();\n     }\n \n     @Override\n-    public int size() {\n-        return handler.size(null);\n-    }\n-\n-    @Override\n-    public int size(IntSet segments) {\n+    public CompletionStage<Long> size(IntSet segments) {\n         return handler.size(segments);\n     }\n \n     @Override\n-    public boolean contains(Object key) {\n-        return handler.contains(-1, key);\n+    public CompletionStage<Long> approximateSize(IntSet segments) {\n+        return handler.approximateSize(segments);\n     }\n \n     @Override\n-    public boolean contains(int segment, Object key) {\n-        return handler.contains(segment, key);\n-    }\n-\n-    @Override\n-    public Publisher<K> publishKeys(Predicate<? super K> filter) {\n-        return handler.publishKeys(null, filter);\n+    public CompletionStage<Boolean> containsKey(int segment, Object key) {\n+        // This might be able to use RocksDB#keyMayExist - but API is a bit flaky\n+        return load(segment, key)\n+                .thenApply(Objects::nonNull);\n     }\n \n     @Override\n     public Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter) {\n-        return handler.publishKeys(segments, filter);\n-    }\n-\n-    @Override\n-    public Publisher<MarshallableEntry<K, V>> entryPublisher(Predicate<? super K> filter, boolean fetchValue, boolean fetchMetadata) {\n-        return handler.publishEntries(null, filter, fetchValue, fetchMetadata);\n+        return Flowable.fromPublisher(handler.publishEntries(segments, filter, false))\n+                .map(MarshallableEntry::getKey);\n     }\n \n     @Override\n-    public Publisher<MarshallableEntry<K, V>> entryPublisher(IntSet segments, Predicate<? super K> filter,\n-                                                             boolean fetchValue, boolean fetchMetadata) {\n-        return handler.publishEntries(segments, filter, fetchValue, fetchMetadata);\n+    public Publisher<MarshallableEntry<K, V>> publishEntries(IntSet segments, Predicate<? super K> filter, boolean includeValues) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgxMDc0NQ=="}, "originalCommit": {"oid": "e8e91c3ad807c6bdba1406c83b12f4bf79650577"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDY4Mjk1OnYy", "diffSide": "RIGHT", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTo1Mjo0OFrOGfoDhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTo1Mjo0OFrOGfoDhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgxNTMwMQ==", "bodyText": "Nitpick, but IMO it's better to return early if it's not valid to reduce nesting.\n    if (!iterator.isValid())\n        return null;", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r435815301", "createdAt": "2020-06-05T09:52:48Z", "author": {"login": "ryanemerson"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -187,271 +190,268 @@ protected RocksDB openDatabase(Path location, Options options) throws RocksDBExc\n     }\n \n     @Override\n-    public void stop() {\n-        try {\n-            semaphore.acquire(Integer.MAX_VALUE);\n-        } catch (InterruptedException e) {\n-            throw new PersistenceException(\"Cannot acquire semaphore\", e);\n-        }\n-        try {\n+    public CompletionStage<Void> stop() {\n+        return blockingManager.runBlocking(() -> {\n             handler.close();\n             expiredDb.close();\n-        } finally {\n-            stopped = true;\n-            semaphore.release(Integer.MAX_VALUE);\n-        }\n-    }\n-\n-    @Override\n-    public void destroy() {\n-        stop();\n-        Util.recursiveFileRemove(getLocation().toFile());\n-        Util.recursiveFileRemove(getExpirationLocation().toFile());\n+        }, \"rocksdb-stop\");\n     }\n \n     @Override\n-    public boolean isAvailable() {\n-        return getLocation().toFile().exists() && getExpirationLocation().toFile().exists();\n+    public Set<Characteristic> characteristics() {\n+        return EnumSet.of(Characteristic.BULK_READ, Characteristic.EXPIRATION, Characteristic.SEGMENTABLE);\n     }\n \n     @Override\n-    public void clear() {\n-        handler.clear(null);\n+    public CompletionStage<Boolean> isAvailable() {\n+        return blockingManager.supplyBlocking(() -> getLocation().toFile().exists() && getExpirationLocation().toFile().exists(),\n+                \"rocksdb-available\");\n     }\n \n     @Override\n-    public void clear(IntSet segments) {\n-        handler.clear(segments);\n+    public CompletionStage<Void> clear() {\n+        return handler.clear();\n     }\n \n     @Override\n-    public int size() {\n-        return handler.size(null);\n-    }\n-\n-    @Override\n-    public int size(IntSet segments) {\n+    public CompletionStage<Long> size(IntSet segments) {\n         return handler.size(segments);\n     }\n \n     @Override\n-    public boolean contains(Object key) {\n-        return handler.contains(-1, key);\n+    public CompletionStage<Long> approximateSize(IntSet segments) {\n+        return handler.approximateSize(segments);\n     }\n \n     @Override\n-    public boolean contains(int segment, Object key) {\n-        return handler.contains(segment, key);\n-    }\n-\n-    @Override\n-    public Publisher<K> publishKeys(Predicate<? super K> filter) {\n-        return handler.publishKeys(null, filter);\n+    public CompletionStage<Boolean> containsKey(int segment, Object key) {\n+        // This might be able to use RocksDB#keyMayExist - but API is a bit flaky\n+        return load(segment, key)\n+                .thenApply(Objects::nonNull);\n     }\n \n     @Override\n     public Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter) {\n-        return handler.publishKeys(segments, filter);\n-    }\n-\n-    @Override\n-    public Publisher<MarshallableEntry<K, V>> entryPublisher(Predicate<? super K> filter, boolean fetchValue, boolean fetchMetadata) {\n-        return handler.publishEntries(null, filter, fetchValue, fetchMetadata);\n+        return Flowable.fromPublisher(handler.publishEntries(segments, filter, false))\n+                .map(MarshallableEntry::getKey);\n     }\n \n     @Override\n-    public Publisher<MarshallableEntry<K, V>> entryPublisher(IntSet segments, Predicate<? super K> filter,\n-                                                             boolean fetchValue, boolean fetchMetadata) {\n-        return handler.publishEntries(segments, filter, fetchValue, fetchMetadata);\n+    public Publisher<MarshallableEntry<K, V>> publishEntries(IntSet segments, Predicate<? super K> filter, boolean includeValues) {\n+        return handler.publishEntries(segments, filter, includeValues);\n     }\n \n     @Override\n-    public boolean delete(Object key) {\n-        return handler.delete(-1, key);\n-    }\n-\n-    @Override\n-    public boolean delete(int segment, Object key) {\n+    public CompletionStage<Boolean> delete(int segment, Object key) {\n         return handler.delete(segment, key);\n     }\n \n     @Override\n-    public void write(MarshallableEntry entry) {\n-        handler.write(-1, entry);\n-    }\n-\n-    @Override\n-    public void write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-        handler.write(segment, entry);\n+    public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n+        return handler.write(segment, entry);\n     }\n \n     @Override\n-    public MarshallableEntry loadEntry(Object key) {\n-        return handler.load(-1, key);\n-    }\n-\n-    @Override\n-    public MarshallableEntry<K, V> get(int segment, Object key) {\n+    public CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key) {\n         return handler.load(segment, key);\n     }\n \n     @Override\n-    public CompletionStage<Void> bulkUpdate(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-        return handler.writeBatch(publisher);\n+    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n+            Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n+        WriteBatch batch = new WriteBatch();\n+        Set<MarshallableEntry<K, V>> expirableEntries = new HashSet<>();\n+        Flowable.fromPublisher(removePublisher)\n+                .subscribe(sp -> {\n+                    ColumnFamilyHandle handle = handler.getHandle(sp.getSegment());\n+                    Flowable.fromPublisher(sp)\n+                            .subscribe(removed -> batch.delete(handle, marshall(removed)));\n+                });\n+        Flowable.fromPublisher(writePublisher)\n+                .subscribe(sp -> {\n+                    ColumnFamilyHandle handle = handler.getHandle(sp.getSegment());\n+                    Flowable.fromPublisher(sp)\n+                            .subscribe(me -> {\n+                                batch.put(handle, marshall(me.getKey()), marshall(me.getMarshalledValue()));\n+                                if (me.expiryTime() > -1) {\n+                                    expirableEntries.add(me);\n+                                }\n+                            });\n+                });\n+        if (batch.count() <= 0) {\n+            batch.close();\n+            return CompletableFutures.completedNull();\n+        }\n+        return blockingManager.runBlocking(() -> {\n+            try {\n+                db.write(dataWriteOptions(), batch);\n+                for (MarshallableEntry<K, V> me : expirableEntries) {\n+                    addNewExpiry(me);\n+                }\n+            } catch (RocksDBException e) {\n+                throw new PersistenceException(e);\n+            }\n+        }, \"rocksdb-batch\").whenComplete((ignore, t) -> batch.close());\n     }\n \n     @Override\n-    public void deleteBatch(Iterable<Object> keys) {\n-        handler.deleteBatch(keys);\n+    public Publisher<MarshallableEntry<K, V>> purgeExpired() {\n+        Publisher<List<MarshallableEntry<K, V>>> purgedBatches = blockingManager.blockingPublisher(Flowable.defer(() -> {\n+            // We check expiration based on time of subscription only\n+            long now = timeService.wallClockTime();\n+            return actualPurgeExpired(now)\n+                    // We return a buffer of expired entries emitted to the non blocking thread\n+                    // This prevents waking up the non blocking thread for every entry as they will most likely be\n+                    // consumed much faster than emission (since each emission performs a get and remove)\n+                    .buffer(16);\n+        }));\n+\n+        return Flowable.fromPublisher(purgedBatches)\n+                .concatMap(Flowable::fromIterable);\n     }\n \n-    private void putExpireDbData(ExpiryEntry entry) throws InterruptedException, RocksDBException, IOException,\n-       ClassNotFoundException {\n-        final byte[] expiryBytes = marshall(entry.expiry);\n-        final byte[] existingBytes = expiredDb.get(expiryBytes);\n-\n-        if (existingBytes != null) {\n-            // in the case of collision make the value a List ...\n-            final Object existing = unmarshall(existingBytes);\n-            if (existing instanceof ExpiryBucket) {\n-                ((ExpiryBucket) existing).entries.add(entry.keyBytes);\n-                expiredDb.put(expiryBytes, marshall(existing));\n+    private Flowable<MarshallableEntry<K, V>> actualPurgeExpired(long now) {\n+        // The following flowable is responsible for emitting entries that have expired from expiredDb and removing the\n+        // given entries\n+        Flowable<byte[]> expiredFlowable = Flowable.using(() -> {\n+            ReadOptions readOptions = new ReadOptions().setFillCache(false);\n+            return new AbstractMap.SimpleImmutableEntry<>(readOptions, expiredDb.newIterator(readOptions));\n+        }, entry -> {\n+            if (entry.getValue() == null) {\n+                return Flowable.empty();\n+            }\n+            RocksIterator iterator = entry.getValue();\n+            iterator.seekToFirst();\n+\n+            return Flowable.fromIterable(() ->\n+                    new AbstractIterator<byte[]>() {\n+                        @Override\n+                        protected byte[] getNext() {\n+                            if (iterator.isValid()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8e91c3ad807c6bdba1406c83b12f4bf79650577"}, "originalPosition": 361}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNDc3MjQ4OnYy", "diffSide": "RIGHT", "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxMDoyMToyMVrOGfo8hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoxNjo1MlrOGf8Ibw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyOTg5NA==", "bodyText": "For a segmented store there is no need to unmarshall all of the keys during the size calculation. Instead we can just return a  \"empty\" MarshalledEntry instance from RocksEntryIterator in order for count() to still be utilised.", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r435829894", "createdAt": "2020-06-05T10:21:21Z", "author": {"login": "ryanemerson"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -594,161 +549,92 @@ ColumnFamilyDescriptor newDescriptor(byte[] name) {\n                   columnFamilyOptions.setCompressionType(CompressionType.getCompressionType(configuration.compressionType().toString())));\n         }\n \n-        boolean contains(int segment, Object key) {\n-            // This might be able to use RocksDB#keyMayExist - but API is a bit flaky\n-            return load(segment, key) != null;\n-        }\n-\n-        MarshallableEntry<K, V> load(int segment, Object key) {\n-            ColumnFamilyHandle handle = getHandle(segment, key);\n+        CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key) {\n+            ColumnFamilyHandle handle = getHandle(segment);\n             if (handle == null) {\n                 log.trace(\"Ignoring load as handle is not currently configured\");\n-                return null;\n+                return CompletableFutures.completedNull();\n             }\n             try {\n-                byte[] entryBytes;\n-                semaphore.acquire();\n-                try {\n-                    if (stopped) {\n-                        throw new PersistenceException(\"RocksDB is stopped\");\n+                CompletionStage<byte[]> entryByteStage = blockingManager.supplyBlocking(() -> {\n+                    try {\n+                        return db.get(handle, marshall(key));\n+                    } catch (RocksDBException e) {\n+                        throw new CompletionException(e);\n                     }\n-\n-                    entryBytes = db.get(handle, marshall(key));\n-                } finally {\n-                    semaphore.release();\n-                }\n-                MarshallableEntry<K, V> me = valueToMarshallableEntry(key, entryBytes, true);\n-                if (me == null || me.isExpired(timeService.wallClockTime())) {\n-                    return null;\n-                }\n-                return me;\n+                }, \"rocksdb-load\");\n+                return entryByteStage.thenApply(entryBytes -> {\n+                    MarshallableEntry<K, V> me = unmarshallEntry(key, entryBytes);\n+                    if (me == null || me.isExpired(timeService.wallClockTime())) {\n+                        return null;\n+                    }\n+                    return me;\n+                });\n             } catch (Exception e) {\n                 throw new PersistenceException(e);\n             }\n         }\n \n-        void write(int segment, MarshallableEntry<? extends K, ? extends V> me) {\n-            Object key = me.getKey();\n-            ColumnFamilyHandle handle = getHandle(segment, key);\n+        CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> me) {\n+            ColumnFamilyHandle handle = getHandle(segment);\n             if (handle == null) {\n                 log.trace(\"Ignoring write as handle is not currently configured\");\n-                return;\n+                return CompletableFutures.completedNull();\n             }\n             try {\n                 byte[] marshalledKey = MarshallUtil.toByteArray(me.getKeyBytes());\n                 byte[] marshalledValue = marshall(me.getMarshalledValue());\n-                semaphore.acquire();\n-                try {\n-                    if (stopped) {\n-                        throw new PersistenceException(\"RocksDB is stopped\");\n+                return blockingManager.runBlocking(() -> {\n+                    try {\n+                        db.put(handle, marshalledKey, marshalledValue);\n+                        if (me.expiryTime() > -1) {\n+                            addNewExpiry(me);\n+                        }\n+                    } catch (RocksDBException e) {\n+                        throw new PersistenceException(e);\n                     }\n-                    db.put(handle, marshalledKey, marshalledValue);\n-                } finally {\n-                    semaphore.release();\n-                }\n-                if (me.expiryTime() > -1) {\n-                    addNewExpiry(me);\n-                }\n-            } catch (Exception e) {\n-                throw new PersistenceException(e);\n-            }\n-        }\n+                }, \"rocksdb-write\");\n \n-        boolean delete(int segment, Object key) {\n-            try {\n-                byte[] keyBytes = marshall(key);\n-                semaphore.acquire();\n-                try {\n-                    if (stopped) {\n-                        throw new PersistenceException(\"RocksDB is stopped\");\n-                    }\n-                    if (db.get(getHandle(segment, key), keyBytes) == null) {\n-                        return false;\n-                    }\n-                    db.delete(getHandle(segment, key), keyBytes);\n-                } finally {\n-                    semaphore.release();\n-                }\n-                return true;\n             } catch (Exception e) {\n                 throw new PersistenceException(e);\n             }\n         }\n \n-        CompletionStage<Void> writeBatch(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-            return Flowable.fromPublisher(publisher)\n-                  .buffer(configuration.maxBatchSize())\n-                  .doOnNext(entries -> {\n-                      WriteBatch batch = new WriteBatch();\n-                      for (MarshallableEntry<? extends K, ? extends V> entry : entries) {\n-                          int segment = calculateSegment(entry.getKey());\n-                          byte[] keyBytes = MarshallUtil.toByteArray(entry.getKeyBytes());\n-                          batch.put(getHandle(segment), keyBytes, marshall(entry.getMarshalledValue()));\n-                      }\n-                      writeBatch(batch);\n-\n-                      // Add metadata only after batch has been written\n-                      for (MarshallableEntry entry : entries) {\n-                          if (entry.expiryTime() > -1)\n-                              addNewExpiry(entry);\n-                      }\n-                  })\n-                  .doOnError(e -> {\n-                      throw new PersistenceException(e);\n-                  })\n-                  .ignoreElements()\n-                  .toCompletionStage(null);\n-        }\n-\n-        void deleteBatch(Iterable<Object> keys) {\n+        CompletionStage<Boolean> delete(int segment, Object key) {\n             try {\n-                int batchSize = 0;\n-                WriteBatch batch = new WriteBatch();\n-                for (Object key : keys) {\n-                    batch.remove(getHandle(calculateSegment(key)), marshall(key));\n-                    batchSize++;\n-\n-                    if (batchSize == configuration.maxBatchSize()) {\n-                        batchSize = 0;\n-                        writeBatch(batch);\n-                        batch = new WriteBatch();\n+                byte[] keyBytes = marshall(key);\n+                ColumnFamilyHandle handle = getHandle(segment);\n+                return blockingManager.supplyBlocking(() -> {\n+                    try {\n+                        if (db.get(handle, keyBytes) == null) {\n+                            return Boolean.FALSE;\n+                        }\n+                        db.delete(handle, keyBytes);\n+                        return Boolean.TRUE;\n+                    } catch (RocksDBException e) {\n+                        throw new PersistenceException(e);\n                     }\n-                }\n-\n-                if (batchSize != 0)\n-                    writeBatch(batch);\n+                }, \"rocksdb-delete\");\n             } catch (Exception e) {\n                 throw new PersistenceException(e);\n             }\n         }\n \n-        abstract void clear(IntSet segments);\n-\n-        abstract Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter);\n+        abstract CompletionStage<Void> clear();\n \n         abstract Publisher<MarshallableEntry<K, V>> publishEntries(IntSet segments, Predicate<? super K> filter,\n-                                                                   boolean fetchValue, boolean fetchMetadata);\n-\n-        int size(IntSet segments) {\n-            CompletionStage<Long> stage = Flowable.fromPublisher(publishKeys(segments, null))\n-                  .count().toCompletionStage();\n+                boolean fetchValue);\n \n-            long count = CompletionStages.join(stage);\n-            if (count > Integer.MAX_VALUE) {\n-                return Integer.MAX_VALUE;\n-            }\n-            return (int) count;\n+        CompletionStage<Long> size(IntSet segments) {\n+            return Flowable.fromPublisher(publishKeys(segments, null))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8e91c3ad807c6bdba1406c83b12f4bf79650577"}, "originalPosition": 878}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NDIzOQ==", "bodyText": "Unfortunately, expiration rears its ugly head again (we need to get at the metadata for expiration) - and at that point we require unmarshalling the value - so I don't think it is worth wasting code to not unmarshall the key.\nThis is one reason I was very glad to add in the approximateSize method (which won't work for non shared non segmented stores - shared or segmented should always work).", "url": "https://github.com/infinispan/infinispan/pull/8405#discussion_r436144239", "createdAt": "2020-06-05T20:16:52Z", "author": {"login": "wburns"}, "path": "persistence/rocksdb/src/main/java/org/infinispan/persistence/rocksdb/RocksDBStore.java", "diffHunk": "@@ -594,161 +549,92 @@ ColumnFamilyDescriptor newDescriptor(byte[] name) {\n                   columnFamilyOptions.setCompressionType(CompressionType.getCompressionType(configuration.compressionType().toString())));\n         }\n \n-        boolean contains(int segment, Object key) {\n-            // This might be able to use RocksDB#keyMayExist - but API is a bit flaky\n-            return load(segment, key) != null;\n-        }\n-\n-        MarshallableEntry<K, V> load(int segment, Object key) {\n-            ColumnFamilyHandle handle = getHandle(segment, key);\n+        CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key) {\n+            ColumnFamilyHandle handle = getHandle(segment);\n             if (handle == null) {\n                 log.trace(\"Ignoring load as handle is not currently configured\");\n-                return null;\n+                return CompletableFutures.completedNull();\n             }\n             try {\n-                byte[] entryBytes;\n-                semaphore.acquire();\n-                try {\n-                    if (stopped) {\n-                        throw new PersistenceException(\"RocksDB is stopped\");\n+                CompletionStage<byte[]> entryByteStage = blockingManager.supplyBlocking(() -> {\n+                    try {\n+                        return db.get(handle, marshall(key));\n+                    } catch (RocksDBException e) {\n+                        throw new CompletionException(e);\n                     }\n-\n-                    entryBytes = db.get(handle, marshall(key));\n-                } finally {\n-                    semaphore.release();\n-                }\n-                MarshallableEntry<K, V> me = valueToMarshallableEntry(key, entryBytes, true);\n-                if (me == null || me.isExpired(timeService.wallClockTime())) {\n-                    return null;\n-                }\n-                return me;\n+                }, \"rocksdb-load\");\n+                return entryByteStage.thenApply(entryBytes -> {\n+                    MarshallableEntry<K, V> me = unmarshallEntry(key, entryBytes);\n+                    if (me == null || me.isExpired(timeService.wallClockTime())) {\n+                        return null;\n+                    }\n+                    return me;\n+                });\n             } catch (Exception e) {\n                 throw new PersistenceException(e);\n             }\n         }\n \n-        void write(int segment, MarshallableEntry<? extends K, ? extends V> me) {\n-            Object key = me.getKey();\n-            ColumnFamilyHandle handle = getHandle(segment, key);\n+        CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> me) {\n+            ColumnFamilyHandle handle = getHandle(segment);\n             if (handle == null) {\n                 log.trace(\"Ignoring write as handle is not currently configured\");\n-                return;\n+                return CompletableFutures.completedNull();\n             }\n             try {\n                 byte[] marshalledKey = MarshallUtil.toByteArray(me.getKeyBytes());\n                 byte[] marshalledValue = marshall(me.getMarshalledValue());\n-                semaphore.acquire();\n-                try {\n-                    if (stopped) {\n-                        throw new PersistenceException(\"RocksDB is stopped\");\n+                return blockingManager.runBlocking(() -> {\n+                    try {\n+                        db.put(handle, marshalledKey, marshalledValue);\n+                        if (me.expiryTime() > -1) {\n+                            addNewExpiry(me);\n+                        }\n+                    } catch (RocksDBException e) {\n+                        throw new PersistenceException(e);\n                     }\n-                    db.put(handle, marshalledKey, marshalledValue);\n-                } finally {\n-                    semaphore.release();\n-                }\n-                if (me.expiryTime() > -1) {\n-                    addNewExpiry(me);\n-                }\n-            } catch (Exception e) {\n-                throw new PersistenceException(e);\n-            }\n-        }\n+                }, \"rocksdb-write\");\n \n-        boolean delete(int segment, Object key) {\n-            try {\n-                byte[] keyBytes = marshall(key);\n-                semaphore.acquire();\n-                try {\n-                    if (stopped) {\n-                        throw new PersistenceException(\"RocksDB is stopped\");\n-                    }\n-                    if (db.get(getHandle(segment, key), keyBytes) == null) {\n-                        return false;\n-                    }\n-                    db.delete(getHandle(segment, key), keyBytes);\n-                } finally {\n-                    semaphore.release();\n-                }\n-                return true;\n             } catch (Exception e) {\n                 throw new PersistenceException(e);\n             }\n         }\n \n-        CompletionStage<Void> writeBatch(Publisher<MarshallableEntry<? extends K, ? extends V>> publisher) {\n-            return Flowable.fromPublisher(publisher)\n-                  .buffer(configuration.maxBatchSize())\n-                  .doOnNext(entries -> {\n-                      WriteBatch batch = new WriteBatch();\n-                      for (MarshallableEntry<? extends K, ? extends V> entry : entries) {\n-                          int segment = calculateSegment(entry.getKey());\n-                          byte[] keyBytes = MarshallUtil.toByteArray(entry.getKeyBytes());\n-                          batch.put(getHandle(segment), keyBytes, marshall(entry.getMarshalledValue()));\n-                      }\n-                      writeBatch(batch);\n-\n-                      // Add metadata only after batch has been written\n-                      for (MarshallableEntry entry : entries) {\n-                          if (entry.expiryTime() > -1)\n-                              addNewExpiry(entry);\n-                      }\n-                  })\n-                  .doOnError(e -> {\n-                      throw new PersistenceException(e);\n-                  })\n-                  .ignoreElements()\n-                  .toCompletionStage(null);\n-        }\n-\n-        void deleteBatch(Iterable<Object> keys) {\n+        CompletionStage<Boolean> delete(int segment, Object key) {\n             try {\n-                int batchSize = 0;\n-                WriteBatch batch = new WriteBatch();\n-                for (Object key : keys) {\n-                    batch.remove(getHandle(calculateSegment(key)), marshall(key));\n-                    batchSize++;\n-\n-                    if (batchSize == configuration.maxBatchSize()) {\n-                        batchSize = 0;\n-                        writeBatch(batch);\n-                        batch = new WriteBatch();\n+                byte[] keyBytes = marshall(key);\n+                ColumnFamilyHandle handle = getHandle(segment);\n+                return blockingManager.supplyBlocking(() -> {\n+                    try {\n+                        if (db.get(handle, keyBytes) == null) {\n+                            return Boolean.FALSE;\n+                        }\n+                        db.delete(handle, keyBytes);\n+                        return Boolean.TRUE;\n+                    } catch (RocksDBException e) {\n+                        throw new PersistenceException(e);\n                     }\n-                }\n-\n-                if (batchSize != 0)\n-                    writeBatch(batch);\n+                }, \"rocksdb-delete\");\n             } catch (Exception e) {\n                 throw new PersistenceException(e);\n             }\n         }\n \n-        abstract void clear(IntSet segments);\n-\n-        abstract Publisher<K> publishKeys(IntSet segments, Predicate<? super K> filter);\n+        abstract CompletionStage<Void> clear();\n \n         abstract Publisher<MarshallableEntry<K, V>> publishEntries(IntSet segments, Predicate<? super K> filter,\n-                                                                   boolean fetchValue, boolean fetchMetadata);\n-\n-        int size(IntSet segments) {\n-            CompletionStage<Long> stage = Flowable.fromPublisher(publishKeys(segments, null))\n-                  .count().toCompletionStage();\n+                boolean fetchValue);\n \n-            long count = CompletionStages.join(stage);\n-            if (count > Integer.MAX_VALUE) {\n-                return Integer.MAX_VALUE;\n-            }\n-            return (int) count;\n+        CompletionStage<Long> size(IntSet segments) {\n+            return Flowable.fromPublisher(publishKeys(segments, null))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgyOTg5NA=="}, "originalCommit": {"oid": "e8e91c3ad807c6bdba1406c83b12f4bf79650577"}, "originalPosition": 878}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4130, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}