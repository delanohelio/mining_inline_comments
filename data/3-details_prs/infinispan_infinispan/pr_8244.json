{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4Njg5NDgx", "number": 8244, "title": "ISPN-2634 Implement cross-site replication based on IRAC", "bodyText": "https://issues.redhat.com/browse/ISPN-2634", "createdAt": "2020-04-24T18:00:18Z", "url": "https://github.com/infinispan/infinispan/pull/8244", "merged": true, "mergeCommit": {"oid": "84f3366ba7ad99410842203d625878bed77c69cb"}, "closed": true, "closedAt": "2020-05-12T09:12:47Z", "author": {"login": "pruivo"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcbroTxgBqjMyNzQ3NzUwNTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgTsv-ABqjMzMjQxNTI5MzE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "302457bade2bf0d3ac1bb1387b34f4c8e334214b", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/302457bade2bf0d3ac1bb1387b34f4c8e334214b", "committedDate": "2020-04-24T17:58:55Z", "message": "ISPN-2634 Implement cross-site replication based on IRAC"}, "afterCommit": {"oid": "a59fa035003a1614d2fb5e3c0b36694fe1c2f54b", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/a59fa035003a1614d2fb5e3c0b36694fe1c2f54b", "committedDate": "2020-04-27T09:11:41Z", "message": "ISPN-2634 Implement cross-site replication based on IRAC"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "19ba38c52c700c7f52bb8c9134930fd42f6b8ca1", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/19ba38c52c700c7f52bb8c9134930fd42f6b8ca1", "committedDate": "2020-04-27T14:04:55Z", "message": "remove unused import"}, "afterCommit": {"oid": "70e1955da45b4de0dd036c6610fd72be7e58c909", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/70e1955da45b4de0dd036c6610fd72be7e58c909", "committedDate": "2020-04-27T18:07:37Z", "message": "ISPN-2634 Implement cross-site replication based on IRAC"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "70e1955da45b4de0dd036c6610fd72be7e58c909", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/70e1955da45b4de0dd036c6610fd72be7e58c909", "committedDate": "2020-04-27T18:07:37Z", "message": "ISPN-2634 Implement cross-site replication based on IRAC"}, "afterCommit": {"oid": "6115acb7fd71c2637860da553caad57573763a60", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/6115acb7fd71c2637860da553caad57573763a60", "committedDate": "2020-05-04T13:06:29Z", "message": "ISPN-2634 Implement cross-site replication based on IRAC"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "78823b48f4d1a77bfb50170e7f794d1032778983", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/78823b48f4d1a77bfb50170e7f794d1032778983", "committedDate": "2020-05-04T15:42:37Z", "message": "Add server integration test for IRAC"}, "afterCommit": {"oid": "fd8474898f65645f9c66493f7acb2e177d7b5f2b", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/fd8474898f65645f9c66493f7acb2e177d7b5f2b", "committedDate": "2020-05-06T18:16:13Z", "message": "Add server integration test for IRAC"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd8474898f65645f9c66493f7acb2e177d7b5f2b", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/fd8474898f65645f9c66493f7acb2e177d7b5f2b", "committedDate": "2020-05-06T18:16:13Z", "message": "Add server integration test for IRAC"}, "afterCommit": {"oid": "c51b5445e53a13a794bcb6ac70abac6f12231255", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/c51b5445e53a13a794bcb6ac70abac6f12231255", "committedDate": "2020-05-06T18:18:45Z", "message": "Add server integration test for IRAC"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2ODU4ODU0", "url": "https://github.com/infinispan/infinispan/pull/8244#pullrequestreview-406858854", "createdAt": "2020-05-06T18:01:39Z", "commit": {"oid": "78823b48f4d1a77bfb50170e7f794d1032778983"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxODowMTo0MFrOGRe_yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQyMDoxNjo1NFrOGRjzFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk4NjgyNQ==", "bodyText": "Recently the approach has been to inject this into the component that would normally be causing the notification. So in this case StateTransferManagerImpl could directly invoke a method on the IracVersionGenerator component.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r420986825", "createdAt": "2020-05-06T18:01:40Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/container/versioning/irac/DefaultIracVersionGenerator.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package org.infinispan.container.versioning.irac;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.factories.annotations.Inject;\n+import org.infinispan.factories.annotations.Start;\n+import org.infinispan.factories.annotations.Stop;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.CacheNotifier;\n+import org.infinispan.notifications.cachelistener.annotation.TopologyChanged;\n+import org.infinispan.notifications.cachelistener.event.TopologyChangedEvent;\n+import org.infinispan.remoting.transport.Transport;\n+\n+/**\n+ * Default implementation of {@link IracVersionGenerator}.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@Listener\n+@Scope(Scopes.NAMED_CACHE)\n+public class DefaultIracVersionGenerator implements IracVersionGenerator {\n+\n+   private final Map<Integer, Map<String, TopologyIracVersion>> segmentVersion;\n+   private final Map<Object, IracMetadata> tombstone;\n+   @Inject CacheNotifier<?, ?> cacheNotifier;\n+   @Inject Transport transport;\n+   private String localSite;\n+   private volatile int topologyId;\n+\n+   public DefaultIracVersionGenerator() {\n+      this.segmentVersion = new ConcurrentHashMap<>();\n+      this.tombstone = new ConcurrentHashMap<>();\n+   }\n+\n+   @Start\n+   @Override\n+   public void start() {\n+      transport.checkCrossSiteAvailable();\n+      localSite = transport.localSiteName();\n+      cacheNotifier.removeListener(this);\n+      cacheNotifier.addListener(this);\n+   }\n+\n+   @Stop\n+   @Override\n+   public void stop() {\n+      cacheNotifier.removeListener(this);\n+   }\n+\n+   @Override\n+   public IracMetadata generateNewMetadata(int segment) {\n+      Map<String, TopologyIracVersion> v = segmentVersion.compute(segment, this::generateNewVectorFunction);\n+      return new IracMetadata(localSite, new IracEntryVersion(v));\n+   }\n+\n+   @Override\n+   public void updateVersion(int segment, IracEntryVersion remoteVersion) {\n+      segmentVersion.merge(segment, remoteVersion.toMap(), this::mergeVectorsFunction);\n+   }\n+\n+   @TopologyChanged\n+   public void onTopologyChange(TopologyChangedEvent<?, ?> tce) {\n+      topologyId = tce.getNewTopologyId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78823b48f4d1a77bfb50170e7f794d1032778983"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDk5OTg4Mw==", "bodyText": "Maybe we should short circuit if we ever get back CONFLICT?", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r420999883", "createdAt": "2020-05-06T18:23:22Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/container/versioning/irac/IracEntryVersion.java", "diffHunk": "@@ -0,0 +1,307 @@\n+package org.infinispan.container.versioning.irac;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.container.versioning.InequalVersionComparisonResult;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.protostream.descriptors.Type;\n+\n+/**\n+ * An entry version for the IRAC algorithm (async cross site replication).\n+ * <p>\n+ * It is represented as a vector clock where each site keeps it version.\n+ * <p>\n+ * The site version is composed as a pair (topology id, version).\n+ *\n+ * @author Pedro Ruivo\n+ * @see TopologyIracVersion\n+ * @since 11.0\n+ */\n+@ProtoTypeId(ProtoStreamTypeIds.IRAC_VERSION)\n+public class IracEntryVersion {\n+\n+   private final Map<String, TopologyIracVersion> vectorClock;\n+\n+   public IracEntryVersion(Map<String, TopologyIracVersion> vectorClock) {\n+      this.vectorClock = Objects.requireNonNull(vectorClock);\n+   }\n+\n+   @ProtoFactory\n+   static IracEntryVersion protostreamFactory(List<MapEntry> entries) {\n+      Map<String, TopologyIracVersion> vectorClock = entries.stream()\n+            .collect(Collectors.toMap(mapEntry -> mapEntry.site, mapEntry -> mapEntry.version));\n+      return new IracEntryVersion(vectorClock);\n+   }\n+\n+   /**\n+    * Converts this instance to a {@link Map}.\n+    * <p>\n+    * The map cannot be modified!.\n+    *\n+    * @return The {@link Map} representation of this version.\n+    */\n+   public Map<String, TopologyIracVersion> toMap() {\n+      return Collections.unmodifiableMap(vectorClock);\n+   }\n+\n+   /**\n+    * Iterates over all entries of this version as pairs (site name, site version).\n+    *\n+    * @param consumer The {@link BiConsumer}.\n+    */\n+   public void forEach(BiConsumer<String, TopologyIracVersion> consumer) {\n+      vectorClock.forEach(consumer);\n+   }\n+\n+   /**\n+    * Compares this instance with another {@link IracEntryVersion} instance.\n+    * @param other The other {@link IracEntryVersion} instance.\n+    * @return A {@link InequalVersionComparisonResult} instance with the compare result.\n+    */\n+   public InequalVersionComparisonResult compareTo(IracEntryVersion other) {\n+      VectorClock vectorClock = new VectorClock();\n+      this.forEach(vectorClock::setOurs);\n+      other.forEach(vectorClock::setTheirs);\n+\n+      Merger merger = Merger.NONE;\n+      for (VersionCompare v : vectorClock.values()) {\n+         merger = merger.accept(v);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b5445e53a13a794bcb6ac70abac6f12231255"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMTI5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Removes the tombstone for {@code key} if it didn't changed.\n          \n          \n            \n                * Removes the tombstone for {@code key} if the metadata matches.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421001291", "createdAt": "2020-05-06T18:25:45Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/container/versioning/irac/IracVersionGenerator.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package org.infinispan.container.versioning.irac;\n+\n+import org.infinispan.commons.api.Lifecycle;\n+import org.infinispan.metadata.impl.IracMetadata;\n+\n+/**\n+ * A version generator for the IRAC protocol.\n+ * <p>\n+ * It also stores the tombstone from the keys removed.\n+ * <p>\n+ * The version is segment based and the new version is also after than the previous one.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+public interface IracVersionGenerator extends Lifecycle {\n+\n+   /**\n+    * Generator a new {@link IracMetadata} for a given {@code segment}.\n+    * <p>\n+    * The {@link IracEntryVersion} created is always higher than the previous one for the same {@code segment}.\n+    *\n+    * @param segment The segment.\n+    * @return The {@link IracMetadata} created.\n+    */\n+   IracMetadata generateNewMetadata(int segment);\n+\n+   /**\n+    * Updates the version for the {@code segment} with a new {@code remoteVersion} seen.\n+    * <p>\n+    * This method should merge both the current version internally stored and the {@code remoteVersion} to achieve an\n+    * {@link IracEntryVersion} higher than both.\n+    *\n+    * @param segment       The segment.\n+    * @param remoteVersion The remote {@link IracEntryVersion} received.\n+    */\n+   void updateVersion(int segment, IracEntryVersion remoteVersion);\n+\n+   /**\n+    * Stores a tombstone for a key removed.\n+    * <p>\n+    * It overwrites any existing tombstone.\n+    *\n+    * @param key      The key.\n+    * @param metadata The {@link IracMetadata}.\n+    */\n+   void storeTombstone(Object key, IracMetadata metadata);\n+\n+   /**\n+    * Same as {@link #storeTombstone(Object, IracMetadata)} but it doesn't overwrite an existing tombstone.\n+    *\n+    * @param key      The key.\n+    * @param metadata The {@link IracMetadata}.\n+    */\n+   void storeTombstoneIfAbsent(Object key, IracMetadata metadata);\n+\n+   /**\n+    * Returns the tombstone associated to the {@code key} or {@code null} if it doesn't exist.\n+    *\n+    * @param key The key.\n+    * @return The tombstone.\n+    */\n+   IracMetadata getTombstone(Object key);\n+\n+   /**\n+    * Removes the tombstone for {@code key} if it didn't changed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b5445e53a13a794bcb6ac70abac6f12231255"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMTU1NA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421001554", "createdAt": "2020-05-06T18:26:10Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/container/versioning/irac/NoOpIracVersionGenerator.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package org.infinispan.container.versioning.irac;\n+\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.metadata.impl.IracMetadata;\n+\n+/**\n+ * A no-op implementation of {@link IracVersionGenerator} for caches without asynchronous remote site backups.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@Scope(Scopes.NAMED_CACHE)\n+public class NoOpIracVersionGenerator implements IracVersionGenerator {\n+\n+   private static final NoOpIracVersionGenerator INSTANCE = new NoOpIracVersionGenerator();\n+\n+   private NoOpIracVersionGenerator() {\n+   }\n+\n+   public static NoOpIracVersionGenerator getInstance() {\n+      return INSTANCE;\n+   }\n+\n+   @Override\n+   public IracMetadata generateNewMetadata(int segment) {\n+      throw new IllegalStateException(); //if we don't have IRAC enabled, this shouldn't be invoked.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b5445e53a13a794bcb6ac70abac6f12231255"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwMzEyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (cacheMode.isClustered()) {\n          \n          \n            \n                  if (Configurations.isIracEnabled() && cacheMode.isClustered()) {", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421003124", "createdAt": "2020-05-06T18:28:52Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/factories/InterceptorChainFactory.java", "diffHunk": "@@ -300,6 +319,22 @@ private AsyncInterceptorChain buildInterceptorChain() {\n             //Nothing...\n       }\n \n+      if (cacheMode.isClustered()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b5445e53a13a794bcb6ac70abac6f12231255"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwNTk5Ng==", "bodyText": "I too originally liked this idea, but it is not a good one sadly. The JVM cannot optimize away the trace calls if it is like this. I would just make it a static final variable in this class for now.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421005996", "createdAt": "2020-05-06T18:33:36Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/interceptors/impl/AbstractIracLocalSiteInterceptor.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package org.infinispan.interceptors.impl;\n+\n+import java.util.stream.Stream;\n+\n+import org.infinispan.commands.FlagAffectedCommand;\n+import org.infinispan.commands.write.WriteCommand;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.container.versioning.irac.IracVersionGenerator;\n+import org.infinispan.context.InvocationContext;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.context.impl.LocalTxInvocationContext;\n+import org.infinispan.context.impl.RemoteTxInvocationContext;\n+import org.infinispan.distribution.DistributionInfo;\n+import org.infinispan.distribution.LocalizedCacheTopology;\n+import org.infinispan.distribution.Ownership;\n+import org.infinispan.factories.annotations.Inject;\n+import org.infinispan.interceptors.DDAsyncInterceptor;\n+import org.infinispan.interceptors.locking.ClusteringDependentLogic;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.xsite.irac.IracUtils;\n+\n+/**\n+ * A {@link DDAsyncInterceptor} with common code for all the IRAC related interceptors.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+public abstract class AbstractIracLocalSiteInterceptor extends DDAsyncInterceptor {\n+\n+   @Inject ClusteringDependentLogic clusteringDependentLogic;\n+   @Inject IracVersionGenerator iracVersionGenerator;\n+\n+   protected static boolean isNormalWriteCommand(WriteCommand command) {\n+      return !command.hasAnyFlag(FlagBitSets.IRAC_UPDATE);\n+   }\n+\n+   protected static boolean isIracState(FlagAffectedCommand command) {\n+      return command.hasAnyFlag(FlagBitSets.IRAC_STATE);\n+   }\n+\n+   static LocalTxInvocationContext asLocalTxInvocationContext(InvocationContext ctx) {\n+      assert ctx.isOriginLocal();\n+      assert ctx.isInTxScope();\n+      return (LocalTxInvocationContext) ctx;\n+   }\n+\n+   static RemoteTxInvocationContext asRemoteTxInvocationContext(InvocationContext ctx) {\n+      assert !ctx.isOriginLocal();\n+      assert ctx.isInTxScope();\n+      return (RemoteTxInvocationContext) ctx;\n+   }\n+\n+   abstract boolean isTraceEnabled();\n+\n+   abstract Log getLog();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b5445e53a13a794bcb6ac70abac6f12231255"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAwODUyMg==", "bodyText": "We can't have these as DEBUG messages as they would be quite spammy.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421008522", "createdAt": "2020-05-06T18:37:36Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/irac/IracUtils.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package org.infinispan.xsite.irac;\n+\n+import static org.infinispan.metadata.impl.PrivateMetadata.getBuilder;\n+\n+import org.infinispan.commands.write.DataWriteCommand;\n+import org.infinispan.commands.write.WriteCommand;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.container.versioning.irac.IracVersionGenerator;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.util.logging.Log;\n+\n+/**\n+ * Utility methods related to IRAC (async Cross-Site Replication)\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+public final class IracUtils {\n+\n+   private IracUtils() {\n+\n+   }\n+\n+   private static void logIracMetadataAssociated(Log log, Object key, IracMetadata metadata) {\n+      if (log.isDebugEnabled()) {\n+         log.debugf(\"[IRAC] IracMetadata %s associated with key '%s'\", metadata, key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b5445e53a13a794bcb6ac70abac6f12231255"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAyMzk5Mw==", "bodyText": "So to be clear if there are conflicting writes we take the site which is higher lexigraphically for now? As long as it is consistent between all the sites, I am fine. Just wanted to clarify.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421023993", "createdAt": "2020-05-06T19:03:10Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/interceptors/impl/AbstractIracRemoteSiteInterceptor.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package org.infinispan.interceptors.impl;\n+\n+import org.infinispan.commands.write.DataWriteCommand;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.container.versioning.irac.IracEntryVersion;\n+import org.infinispan.context.InvocationContext;\n+import org.infinispan.interceptors.AsyncInterceptorChain;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.xsite.irac.IracUtils;\n+\n+/**\n+ * An IRAC related interceptor that that handles the requests from the remote site.\n+ * <p>\n+ * This class contains only the common code and it is always present in the {@link AsyncInterceptorChain} because the\n+ * cache has no knowledge if it is a backup from others site or not.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+public abstract class AbstractIracRemoteSiteInterceptor extends AbstractIracLocalSiteInterceptor {\n+\n+   /**\n+    * Invoked on the primary owner, it validates if the remote site update is valid or not.\n+    * <p>\n+    * It also performs a conflict resolution if a conflict is found.\n+    */\n+   protected void validateOnPrimary(InvocationContext ctx, DataWriteCommand command,\n+         @SuppressWarnings(\"unused\") Object rv) {\n+      final Object key = command.getKey();\n+      CacheEntry<?, ?> entry = ctx.lookupEntry(key);\n+      IracMetadata remoteMetadata = IracUtils.getIracMetadataFromCommand(command, key);\n+      IracMetadata localMetadata = IracUtils.getIracMetadata(entry, iracVersionGenerator);\n+\n+      if (localMetadata == null) {\n+         localMetadata = iracVersionGenerator.getTombstone(key);\n+      }\n+\n+      assert remoteMetadata != null;\n+\n+      iracVersionGenerator.updateVersion(getSegment(key), remoteMetadata.getVersion());\n+\n+      if (localMetadata != null) {\n+         validateAndSetMetadata(entry, command, localMetadata, remoteMetadata);\n+      } else {\n+         setIracMetadata(entry, remoteMetadata);\n+      }\n+   }\n+\n+   /**\n+    * Invoked by backup owners, it make sure the entry has the same version as set by the primary owner.\n+    */\n+   protected void setIracMetadataForOwner(InvocationContext ctx, DataWriteCommand command,\n+         @SuppressWarnings(\"unused\") Object rv) {\n+      final Object key = command.getKey();\n+      IracMetadata metadata = IracUtils.getIracMetadataFromCommand(command, key);\n+      assert metadata != null;\n+      iracVersionGenerator.updateVersion(getSegment(key), metadata.getVersion());\n+      setIracMetadata(ctx.lookupEntry(key), metadata);\n+   }\n+\n+   private void validateAndSetMetadata(CacheEntry<?, ?> entry, DataWriteCommand command,\n+         IracMetadata localMetadata, IracMetadata remoteMetadata) {\n+      if (isTraceEnabled()) {\n+         getLog().tracef(\"[IRAC] Comparing local and remote metadata: %s and %s\", localMetadata, remoteMetadata);\n+      }\n+      IracEntryVersion localVersion = localMetadata.getVersion();\n+      IracEntryVersion remoteVersion = remoteMetadata.getVersion();\n+      switch (remoteVersion.compareTo(localVersion)) {\n+         case CONFLICTING:\n+            resolveConflict(entry, command, localMetadata, remoteMetadata);\n+            return;\n+         case EQUAL:\n+         case BEFORE:\n+            IracUtils.discardUpdate(getLog(), entry, command, remoteMetadata);\n+            return;\n+      }\n+      setIracMetadata(entry, remoteMetadata);\n+   }\n+\n+\n+   private void resolveConflict(CacheEntry<?, ?> entry, DataWriteCommand command, IracMetadata localMetadata,\n+         IracMetadata remoteMetadata) {\n+      if (isTraceEnabled()) {\n+         getLog().tracef(\"[IRAC] Conflict found between local and remote metadata: %s and %s\", localMetadata,\n+               remoteMetadata);\n+      }\n+      //same site? conflict?\n+      assert !localMetadata.getSite().equals(remoteMetadata.getSite());\n+      if (localMetadata.getSite().compareTo(remoteMetadata.getSite()) < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b5445e53a13a794bcb6ac70abac6f12231255"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAyNzU1Ng==", "bodyText": "You can use SegmentSpecificCommand#extractSegment here to retrieve the segment from commands that have a single key.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421027556", "createdAt": "2020-05-06T19:09:08Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/interceptors/impl/NonTxIracLocalSiteInterceptor.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.infinispan.interceptors.impl;\n+\n+import org.infinispan.commands.FlagAffectedCommand;\n+import org.infinispan.commands.functional.ReadWriteKeyCommand;\n+import org.infinispan.commands.functional.ReadWriteKeyValueCommand;\n+import org.infinispan.commands.functional.ReadWriteManyCommand;\n+import org.infinispan.commands.functional.ReadWriteManyEntriesCommand;\n+import org.infinispan.commands.functional.WriteOnlyKeyCommand;\n+import org.infinispan.commands.functional.WriteOnlyKeyValueCommand;\n+import org.infinispan.commands.functional.WriteOnlyManyCommand;\n+import org.infinispan.commands.functional.WriteOnlyManyEntriesCommand;\n+import org.infinispan.commands.tx.CommitCommand;\n+import org.infinispan.commands.tx.PrepareCommand;\n+import org.infinispan.commands.tx.RollbackCommand;\n+import org.infinispan.commands.write.ComputeCommand;\n+import org.infinispan.commands.write.ComputeIfAbsentCommand;\n+import org.infinispan.commands.write.DataWriteCommand;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commands.write.PutMapCommand;\n+import org.infinispan.commands.write.RemoveCommand;\n+import org.infinispan.commands.write.RemoveExpiredCommand;\n+import org.infinispan.commands.write.ReplaceCommand;\n+import org.infinispan.commands.write.WriteCommand;\n+import org.infinispan.context.InvocationContext;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.context.impl.TxInvocationContext;\n+import org.infinispan.distribution.Ownership;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.infinispan.xsite.irac.IracUtils;\n+\n+/**\n+ * Interceptor used by IRAC for non transactional caches to handle the local site updates.\n+ * <p>\n+ * The primary owner job is to generate a new {@link IracMetadata} for the write and store in the {@link WriteCommand}.\n+ * If the command is successful, the {@link IracMetadata} is stored in the context entry.\n+ * <p>\n+ * The backup owners just handle the updates from the primary owner and extract the {@link IracMetadata} to stored in\n+ * the context entry.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+public class NonTxIracLocalSiteInterceptor extends AbstractIracLocalSiteInterceptor {\n+\n+   private static final Log log = LogFactory.getLog(NonTxIracLocalSiteInterceptor.class);\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   @Override\n+   public Object visitPutKeyValueCommand(InvocationContext ctx, PutKeyValueCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @Override\n+   public Object visitRemoveCommand(InvocationContext ctx, RemoveCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @Override\n+   public Object visitReplaceCommand(InvocationContext ctx, ReplaceCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @Override\n+   public Object visitComputeIfAbsentCommand(InvocationContext ctx, ComputeIfAbsentCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @Override\n+   public Object visitComputeCommand(InvocationContext ctx, ComputeCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @Override\n+   public Object visitPutMapCommand(InvocationContext ctx, PutMapCommand command) {\n+      return visitWriteCommand(ctx, command);\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitPrepareCommand(TxInvocationContext ctx, PrepareCommand command) {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitCommitCommand(TxInvocationContext ctx, CommitCommand command) {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitRollbackCommand(TxInvocationContext ctx, RollbackCommand command) {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitWriteOnlyKeyCommand(InvocationContext ctx, WriteOnlyKeyCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitReadWriteKeyValueCommand(InvocationContext ctx, ReadWriteKeyValueCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitReadWriteKeyCommand(InvocationContext ctx, ReadWriteKeyCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitWriteOnlyManyEntriesCommand(InvocationContext ctx, WriteOnlyManyEntriesCommand command) {\n+      return visitWriteCommand(ctx, command);\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitWriteOnlyKeyValueCommand(InvocationContext ctx, WriteOnlyKeyValueCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitWriteOnlyManyCommand(InvocationContext ctx, WriteOnlyManyCommand command) {\n+      return visitWriteCommand(ctx, command);\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitReadWriteManyCommand(InvocationContext ctx, ReadWriteManyCommand command) {\n+      return visitWriteCommand(ctx, command);\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitReadWriteManyEntriesCommand(InvocationContext ctx, ReadWriteManyEntriesCommand command) {\n+      return visitWriteCommand(ctx, command);\n+   }\n+\n+   @Override\n+   public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @Override\n+   boolean isTraceEnabled() {\n+      return trace;\n+   }\n+\n+   @Override\n+   Log getLog() {\n+      return log;\n+   }\n+\n+   private Object visitDataWriteCommand(InvocationContext ctx, DataWriteCommand command) {\n+      final Object key = command.getKey();\n+      if (isIracState(command)) { //all the state transfer/preload is done via put commands.\n+         setMetadataToCacheEntry(ctx.lookupEntry(key), IracUtils.getIracMetadataFromCommand(command, key));\n+         return invokeNext(ctx, command);\n+      }\n+      if (skipCommand(ctx, command)) {\n+         return invokeNext(ctx, command);\n+      }\n+      visitKey(key, command);\n+      return invokeNextAndFinally(ctx, command, this::handleDataWriteCommand);\n+   }\n+\n+   private Object visitWriteCommand(InvocationContext ctx, WriteCommand command) {\n+      if (skipCommand(ctx, command)) {\n+         return invokeNext(ctx, command);\n+      }\n+      for (Object key : command.getAffectedKeys()) {\n+         visitKey(key, command);\n+      }\n+      return invokeNextAndFinally(ctx, command, this::handleWriteCommand);\n+   }\n+\n+   private boolean skipCommand(InvocationContext ctx, FlagAffectedCommand command) {\n+      return ctx.isInTxScope() || command.hasAnyFlag(FlagBitSets.IRAC_UPDATE);\n+   }\n+\n+   /**\n+    * Visits the {@link WriteCommand} before executing it.\n+    * <p>\n+    * The primary owner generates a new {@link IracMetadata} and stores it in the {@link WriteCommand}.\n+    */\n+   private void visitKey(Object key, WriteCommand command) {\n+      int segment = getSegment(key);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b5445e53a13a794bcb6ac70abac6f12231255"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMDQ1NA==", "bodyText": "I would say just store the actual Map directly and instead return the map wrapped by an unmodifiable map. Otherwise we will have extra allocations on every operation for the unmodifiable wrappers internally when they aren't needed.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421030454", "createdAt": "2020-05-06T19:14:04Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/container/versioning/irac/DefaultIracVersionGenerator.java", "diffHunk": "@@ -0,0 +1,131 @@\n+package org.infinispan.container.versioning.irac;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.infinispan.factories.annotations.Inject;\n+import org.infinispan.factories.annotations.Start;\n+import org.infinispan.factories.annotations.Stop;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.CacheNotifier;\n+import org.infinispan.notifications.cachelistener.annotation.TopologyChanged;\n+import org.infinispan.notifications.cachelistener.event.TopologyChangedEvent;\n+import org.infinispan.remoting.transport.Transport;\n+\n+/**\n+ * Default implementation of {@link IracVersionGenerator}.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@Listener\n+@Scope(Scopes.NAMED_CACHE)\n+public class DefaultIracVersionGenerator implements IracVersionGenerator {\n+\n+   private final Map<Integer, Map<String, TopologyIracVersion>> segmentVersion;\n+   private final Map<Object, IracMetadata> tombstone;\n+   @Inject CacheNotifier<?, ?> cacheNotifier;\n+   @Inject Transport transport;\n+   private String localSite;\n+   private volatile int topologyId;\n+\n+   public DefaultIracVersionGenerator() {\n+      this.segmentVersion = new ConcurrentHashMap<>();\n+      this.tombstone = new ConcurrentHashMap<>();\n+   }\n+\n+   @Start\n+   @Override\n+   public void start() {\n+      transport.checkCrossSiteAvailable();\n+      localSite = transport.localSiteName();\n+      cacheNotifier.removeListener(this);\n+      cacheNotifier.addListener(this);\n+   }\n+\n+   @Stop\n+   @Override\n+   public void stop() {\n+      cacheNotifier.removeListener(this);\n+   }\n+\n+   @Override\n+   public IracMetadata generateNewMetadata(int segment) {\n+      Map<String, TopologyIracVersion> v = segmentVersion.compute(segment, this::generateNewVectorFunction);\n+      return new IracMetadata(localSite, new IracEntryVersion(v));\n+   }\n+\n+   @Override\n+   public void updateVersion(int segment, IracEntryVersion remoteVersion) {\n+      segmentVersion.merge(segment, remoteVersion.toMap(), this::mergeVectorsFunction);\n+   }\n+\n+   @TopologyChanged\n+   public void onTopologyChange(TopologyChangedEvent<?, ?> tce) {\n+      topologyId = tce.getNewTopologyId();\n+   }\n+\n+   @Override\n+   public void storeTombstone(Object key, IracMetadata metadata) {\n+      tombstone.put(key, metadata);\n+   }\n+\n+   @Override\n+   public void storeTombstoneIfAbsent(Object key, IracMetadata metadata) {\n+      if (metadata == null) {\n+         return;\n+      }\n+      tombstone.putIfAbsent(key, metadata);\n+   }\n+\n+   @Override\n+   public IracMetadata getTombstone(Object key) {\n+      return tombstone.get(key);\n+   }\n+\n+   @Override\n+   public void removeTombstone(Object key, IracMetadata iracMetadata) {\n+      if (iracMetadata == null) {\n+         return;\n+      }\n+      tombstone.remove(key, iracMetadata);\n+   }\n+\n+   @Override\n+   public void removeTombstone(Object key) {\n+      tombstone.remove(key);\n+   }\n+\n+   private Map<String, TopologyIracVersion> generateNewVectorFunction(Integer s,\n+         Map<String, TopologyIracVersion> versions) {\n+      if (versions == null) {\n+         return Collections.singletonMap(localSite, TopologyIracVersion.newVersion(topologyId));\n+      } else {\n+         Map<String, TopologyIracVersion> copy = new HashMap<>(versions);\n+         copy.compute(localSite, this::incrementVersionFunction);\n+         return Collections.unmodifiableMap(copy);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b5445e53a13a794bcb6ac70abac6f12231255"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTAzMjM5NA==", "bodyText": "Debug here should be trace as well.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421032394", "createdAt": "2020-05-06T19:17:38Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/interceptors/impl/NonTxIracLocalSiteInterceptor.java", "diffHunk": "@@ -0,0 +1,248 @@\n+package org.infinispan.interceptors.impl;\n+\n+import org.infinispan.commands.FlagAffectedCommand;\n+import org.infinispan.commands.functional.ReadWriteKeyCommand;\n+import org.infinispan.commands.functional.ReadWriteKeyValueCommand;\n+import org.infinispan.commands.functional.ReadWriteManyCommand;\n+import org.infinispan.commands.functional.ReadWriteManyEntriesCommand;\n+import org.infinispan.commands.functional.WriteOnlyKeyCommand;\n+import org.infinispan.commands.functional.WriteOnlyKeyValueCommand;\n+import org.infinispan.commands.functional.WriteOnlyManyCommand;\n+import org.infinispan.commands.functional.WriteOnlyManyEntriesCommand;\n+import org.infinispan.commands.tx.CommitCommand;\n+import org.infinispan.commands.tx.PrepareCommand;\n+import org.infinispan.commands.tx.RollbackCommand;\n+import org.infinispan.commands.write.ComputeCommand;\n+import org.infinispan.commands.write.ComputeIfAbsentCommand;\n+import org.infinispan.commands.write.DataWriteCommand;\n+import org.infinispan.commands.write.PutKeyValueCommand;\n+import org.infinispan.commands.write.PutMapCommand;\n+import org.infinispan.commands.write.RemoveCommand;\n+import org.infinispan.commands.write.RemoveExpiredCommand;\n+import org.infinispan.commands.write.ReplaceCommand;\n+import org.infinispan.commands.write.WriteCommand;\n+import org.infinispan.context.InvocationContext;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.context.impl.TxInvocationContext;\n+import org.infinispan.distribution.Ownership;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.infinispan.xsite.irac.IracUtils;\n+\n+/**\n+ * Interceptor used by IRAC for non transactional caches to handle the local site updates.\n+ * <p>\n+ * The primary owner job is to generate a new {@link IracMetadata} for the write and store in the {@link WriteCommand}.\n+ * If the command is successful, the {@link IracMetadata} is stored in the context entry.\n+ * <p>\n+ * The backup owners just handle the updates from the primary owner and extract the {@link IracMetadata} to stored in\n+ * the context entry.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+public class NonTxIracLocalSiteInterceptor extends AbstractIracLocalSiteInterceptor {\n+\n+   private static final Log log = LogFactory.getLog(NonTxIracLocalSiteInterceptor.class);\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   @Override\n+   public Object visitPutKeyValueCommand(InvocationContext ctx, PutKeyValueCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @Override\n+   public Object visitRemoveCommand(InvocationContext ctx, RemoveCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @Override\n+   public Object visitReplaceCommand(InvocationContext ctx, ReplaceCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @Override\n+   public Object visitComputeIfAbsentCommand(InvocationContext ctx, ComputeIfAbsentCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @Override\n+   public Object visitComputeCommand(InvocationContext ctx, ComputeCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @Override\n+   public Object visitPutMapCommand(InvocationContext ctx, PutMapCommand command) {\n+      return visitWriteCommand(ctx, command);\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitPrepareCommand(TxInvocationContext ctx, PrepareCommand command) {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitCommitCommand(TxInvocationContext ctx, CommitCommand command) {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitRollbackCommand(TxInvocationContext ctx, RollbackCommand command) {\n+      throw new UnsupportedOperationException();\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitWriteOnlyKeyCommand(InvocationContext ctx, WriteOnlyKeyCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitReadWriteKeyValueCommand(InvocationContext ctx, ReadWriteKeyValueCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitReadWriteKeyCommand(InvocationContext ctx, ReadWriteKeyCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitWriteOnlyManyEntriesCommand(InvocationContext ctx, WriteOnlyManyEntriesCommand command) {\n+      return visitWriteCommand(ctx, command);\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitWriteOnlyKeyValueCommand(InvocationContext ctx, WriteOnlyKeyValueCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitWriteOnlyManyCommand(InvocationContext ctx, WriteOnlyManyCommand command) {\n+      return visitWriteCommand(ctx, command);\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitReadWriteManyCommand(InvocationContext ctx, ReadWriteManyCommand command) {\n+      return visitWriteCommand(ctx, command);\n+   }\n+\n+   @SuppressWarnings(\"rawtypes\")\n+   @Override\n+   public Object visitReadWriteManyEntriesCommand(InvocationContext ctx, ReadWriteManyEntriesCommand command) {\n+      return visitWriteCommand(ctx, command);\n+   }\n+\n+   @Override\n+   public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredCommand command) {\n+      return visitDataWriteCommand(ctx, command);\n+   }\n+\n+   @Override\n+   boolean isTraceEnabled() {\n+      return trace;\n+   }\n+\n+   @Override\n+   Log getLog() {\n+      return log;\n+   }\n+\n+   private Object visitDataWriteCommand(InvocationContext ctx, DataWriteCommand command) {\n+      final Object key = command.getKey();\n+      if (isIracState(command)) { //all the state transfer/preload is done via put commands.\n+         setMetadataToCacheEntry(ctx.lookupEntry(key), IracUtils.getIracMetadataFromCommand(command, key));\n+         return invokeNext(ctx, command);\n+      }\n+      if (skipCommand(ctx, command)) {\n+         return invokeNext(ctx, command);\n+      }\n+      visitKey(key, command);\n+      return invokeNextAndFinally(ctx, command, this::handleDataWriteCommand);\n+   }\n+\n+   private Object visitWriteCommand(InvocationContext ctx, WriteCommand command) {\n+      if (skipCommand(ctx, command)) {\n+         return invokeNext(ctx, command);\n+      }\n+      for (Object key : command.getAffectedKeys()) {\n+         visitKey(key, command);\n+      }\n+      return invokeNextAndFinally(ctx, command, this::handleWriteCommand);\n+   }\n+\n+   private boolean skipCommand(InvocationContext ctx, FlagAffectedCommand command) {\n+      return ctx.isInTxScope() || command.hasAnyFlag(FlagBitSets.IRAC_UPDATE);\n+   }\n+\n+   /**\n+    * Visits the {@link WriteCommand} before executing it.\n+    * <p>\n+    * The primary owner generates a new {@link IracMetadata} and stores it in the {@link WriteCommand}.\n+    */\n+   private void visitKey(Object key, WriteCommand command) {\n+      int segment = getSegment(key);\n+      if (getOwnership(segment) != Ownership.PRIMARY) {\n+         return;\n+      }\n+      IracMetadata metadata = iracVersionGenerator.generateNewMetadata(segment);\n+      if (log.isDebugEnabled()) {\n+         log.debugf(\"[IRAC] New metadata for key '%s' is %s\", key, metadata);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b5445e53a13a794bcb6ac70abac6f12231255"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA0NzgxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Sets the {@code key} as changed byt the {@code lockOwner}.\n          \n          \n            \n                * Sets the {@code key} as changed by the {@code lockOwner}.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421047817", "createdAt": "2020-05-06T19:45:15Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/irac/IracManager.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package org.infinispan.xsite.irac;\n+\n+import java.util.Collection;\n+import java.util.stream.Stream;\n+\n+import org.infinispan.commands.write.WriteCommand;\n+import org.infinispan.commons.util.IntSet;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.topology.CacheTopology;\n+import org.infinispan.transaction.xa.GlobalTransaction;\n+\n+/**\n+ * It manages the keys changed in the local cluster and sends to all asynchronous backup configured.\n+ * <p>\n+ * The {@code lockOwner} is the last command (or transaction) who updated the key. It is used to detect conflicting\n+ * local updates while sending to the remote backups (sites).\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@Scope(Scopes.NAMED_CACHE)\n+public interface IracManager {\n+\n+   /**\n+    * Sets the {@code key} as changed byt the {@code lockOwner}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b5445e53a13a794bcb6ac70abac6f12231255"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1ODc0OQ==", "bodyText": "This method should be replaced by a reference to EntryLoader#loadAndStoreInDataContainer such as https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/container/entries/VersionedRepeatableReadEntry.java#L98", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421058749", "createdAt": "2020-05-06T20:04:33Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/irac/DefaultIracManager.java", "diffHunk": "@@ -0,0 +1,501 @@\n+package org.infinispan.xsite.irac;\n+\n+import static org.infinispan.util.concurrent.CompletableFutures.completedExceptionFuture;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Semaphore;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.irac.IracCleanupKeyCommand;\n+import org.infinispan.commands.remote.CacheRpcCommand;\n+import org.infinispan.commands.write.WriteCommand;\n+import org.infinispan.commons.util.IntSet;\n+import org.infinispan.commons.util.IntSets;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.container.DataContainer;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.container.impl.InternalDataContainer;\n+import org.infinispan.container.impl.InternalEntryFactory;\n+import org.infinispan.container.versioning.irac.IracVersionGenerator;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.DistributionInfo;\n+import org.infinispan.factories.annotations.Inject;\n+import org.infinispan.factories.annotations.Start;\n+import org.infinispan.factories.annotations.Stop;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.interceptors.locking.ClusteringDependentLogic;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.persistence.PersistenceUtil;\n+import org.infinispan.persistence.manager.PersistenceManager;\n+import org.infinispan.remoting.inboundhandler.DeliverOrder;\n+import org.infinispan.remoting.rpc.RpcManager;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.remoting.transport.Transport;\n+import org.infinispan.remoting.transport.XSiteResponse;\n+import org.infinispan.topology.CacheTopology;\n+import org.infinispan.transaction.xa.GlobalTransaction;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.infinispan.xsite.XSiteBackup;\n+import org.infinispan.xsite.XSiteReplicateCommand;\n+import org.infinispan.xsite.status.SiteState;\n+import org.infinispan.xsite.status.TakeOfflineManager;\n+\n+/**\n+ * Default implementation of {@link IracManager}.\n+ * <p>\n+ * It tracks the keys updated by this site and sends them, periodically, to the configured remote sites.\n+ * <p>\n+ * The primary owner coordinates everything. It sends the updates request to the remote site and coordinates the local\n+ * site backup owners. After sending the updates to the remote site, it sends a cleanup request to the local site backup\n+ * owners\n+ * <p>\n+ * The backup owners only keeps a backup list of the tracked keys.\n+ * <p>\n+ * On topology change, the updated keys list is replicate to the new owner(s). Also, if a segment is being transferred\n+ * (i.e. the primary owner isn't a write and read owner), no updates to the remote site is sent since, most likely, the\n+ * node doesn't have the most up-to-date value.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@Scope(Scopes.NAMED_CACHE)\n+public class DefaultIracManager implements IracManager, Runnable {\n+\n+   private static final Log log = LogFactory.getLog(DefaultIracManager.class);\n+   private static final boolean trace = log.isTraceEnabled();\n+   private static final CompletableFuture<Void> IGNORE_KEY_SEND = completedExceptionFuture(new Exception(\"Ignore update\"));\n+\n+   @Inject RpcManager rpcManager;\n+   @Inject Configuration config;\n+   @Inject TakeOfflineManager takeOfflineManager;\n+   @Inject ClusteringDependentLogic clusteringDependentLogic;\n+   @Inject InternalDataContainer<Object, Object> dataContainer;\n+   @Inject PersistenceManager persistenceManager;\n+   @Inject CommandsFactory commandsFactory;\n+   @Inject IracVersionGenerator iracVersionGenerator;\n+\n+   private final Map<Object, Object> updatedKeys;\n+   private final Semaphore senderNotifier;\n+   private volatile boolean hasClear;\n+   private volatile Collection<XSiteBackup> asyncBackups;\n+   private volatile Thread sender;\n+   private volatile boolean running;\n+\n+   public DefaultIracManager() {\n+      this.updatedKeys = new ConcurrentHashMap<>();\n+      this.senderNotifier = new Semaphore(0);\n+   }\n+\n+   private static Collection<XSiteBackup> asyncBackups(Collection<BackupConfiguration> config, String localSiteName) {\n+      return config.stream()\n+            .filter(BackupConfiguration::isAsyncBackup)\n+            .filter(bc -> !localSiteName.equals(bc.site()))\n+            .map(bc -> new XSiteBackup(bc.site(), true, bc.replicationTimeout())) //convert to sync\n+            .collect(Collectors.toList());\n+   }\n+\n+   private static Stream<?> keyStream(WriteCommand command) {\n+      return command.getAffectedKeys().stream();\n+   }\n+\n+   private static boolean backupToRemoteSite(WriteCommand command) {\n+      return !command.hasAnyFlag(FlagBitSets.SKIP_XSITE_BACKUP);\n+   }\n+\n+   private static IntSet newIntSet(Address ignored) {\n+      return IntSets.mutableEmptySet();\n+   }\n+\n+   @Start\n+   public void start() {\n+      Transport transport = rpcManager.getTransport();\n+      transport.checkCrossSiteAvailable();\n+      String localSiteName = transport.localSiteName();\n+      asyncBackups = asyncBackups(config.sites().enabledBackups(), localSiteName);\n+      if (trace) {\n+         String b = asyncBackups.stream().map(XSiteBackup::getSiteName).collect(Collectors.joining(\", \"));\n+         log.tracef(\"Async remote sites found: %s\", b);\n+      }\n+      Thread oldSender = sender;\n+      if (oldSender != null) {\n+         oldSender.interrupt();\n+      }\n+      senderNotifier.drainPermits();\n+      running = true;\n+      hasClear = false;\n+      //TODO should we use a runnable in blocking executor?\n+      // it requires some synchronization since we can stop the runnable if the map is empty (instead of having a thread blocked/waiting)\n+      // not for now...\n+      Thread newSender = new Thread(this, \"irac-sender-thread-\" + transport.getAddress());\n+      sender = newSender;\n+      newSender.start();\n+\n+   }\n+\n+   @Stop\n+   public void stop() {\n+      running = false;\n+      Thread oldSender = sender;\n+      if (oldSender != null) {\n+         oldSender.interrupt();\n+      }\n+   }\n+\n+   @Override\n+   public void trackUpdatedKey(Object key, Object lockOwner) {\n+      if (trace) {\n+         log.tracef(\"Tracking key for %s: %s\", lockOwner, key);\n+      }\n+      updatedKeys.put(key, lockOwner);\n+      senderNotifier.release();\n+   }\n+\n+   @Override\n+   public <K> void trackUpdatedKeys(Collection<K> keys, Object lockOwner) {\n+      if (trace) {\n+         log.tracef(\"Tracking keys for %s: %s\", lockOwner, keys);\n+      }\n+      if (keys.isEmpty()) {\n+         return;\n+      }\n+      keys.forEach(key -> updatedKeys.put(key, lockOwner));\n+      senderNotifier.release();\n+   }\n+\n+   @Override\n+   public void trackKeysFromTransaction(Stream<WriteCommand> modifications, GlobalTransaction lockOwner) {\n+      keysFromMods(modifications).forEach(key -> {\n+         if (trace) {\n+            log.tracef(\"Tracking key for %s: %s\", lockOwner, key);\n+         }\n+         updatedKeys.put(key, lockOwner);\n+      });\n+      senderNotifier.release();\n+   }\n+\n+   @Override\n+   public void trackClear() {\n+      if (trace) {\n+         log.trace(\"Tracking clear request\");\n+      }\n+      hasClear = true;\n+      updatedKeys.clear();\n+      senderNotifier.release();\n+   }\n+\n+   @Override\n+   public void cleanupKey(Object key, Object lockOwner, IracMetadata tombstone) {\n+      updatedKeys.remove(key, lockOwner);\n+      iracVersionGenerator.removeTombstone(key, tombstone);\n+   }\n+\n+   @Override\n+   public void onTopologyUpdate(CacheTopology oldCacheTopology, CacheTopology newCacheTopology) {\n+      if (trace) {\n+         log.trace(\"[IRAC] Topology Updated! Checking pending keys.\");\n+      }\n+      Address local = rpcManager.getAddress();\n+      if (!newCacheTopology.getMembers().contains(local)) {\n+         //not in teh cache topology\n+         return;\n+      }\n+      IntSet addedSegments = IntSets.from(newCacheTopology.getWriteConsistentHash().getSegmentsForOwner(local));\n+      if (oldCacheTopology.getMembers().contains(local)) {\n+         addedSegments.removeAll(IntSets.from(oldCacheTopology.getWriteConsistentHash().getSegmentsForOwner(local)));\n+      }\n+\n+      if (addedSegments.isEmpty()) {\n+         //this node doesn't have any new segments but it may become the primary owner of some.\n+         //trigger a new round (it also removes the keys if the node isn't a owner)\n+         senderNotifier.release();\n+         return;\n+      }\n+\n+      //group new segments by primary owner\n+      Map<Address, IntSet> primarySegments = new HashMap<>();\n+      for (int segment : addedSegments) {\n+         Address primary = newCacheTopology.getWriteConsistentHash().locatePrimaryOwnerForSegment(segment);\n+         primarySegments.computeIfAbsent(primary, DefaultIracManager::newIntSet).add(segment);\n+      }\n+\n+      primarySegments.forEach(this::sendStateRequest);\n+\n+      senderNotifier.release();\n+   }\n+\n+   @Override\n+   public void requestState(Address origin, IntSet segments) {\n+      updatedKeys.forEach((key, lockOwner) -> sendStateIfNeeded(origin, segments, key, lockOwner));\n+   }\n+\n+   @Override\n+   public void receiveState(Object key, Object lockOwner, IracMetadata tombstone) {\n+      iracVersionGenerator.storeTombstoneIfAbsent(key, tombstone);\n+      updatedKeys.putIfAbsent(key, lockOwner);\n+      senderNotifier.release();\n+   }\n+\n+   //public for testing purposes\n+   public void sendStateIfNeeded(Address origin, IntSet segments, Object key, Object lockOwner) {\n+      int segment = getSegment(key);\n+      if (!segments.contains(segment)) {\n+         return;\n+      }\n+      //send the tombstone too\n+      IracMetadata tombstone = iracVersionGenerator.getTombstone(key);\n+\n+      CacheRpcCommand cmd = commandsFactory.buildIracStateResponseCommand(key, lockOwner, tombstone);\n+      rpcManager.sendTo(origin, cmd, DeliverOrder.NONE);\n+   }\n+\n+   //public for testing purposes\n+   public Stream<?> keysFromMods(Stream<WriteCommand> modifications) {\n+      return modifications\n+            .filter(WriteCommand::isSuccessful)\n+            .filter(DefaultIracManager::backupToRemoteSite)\n+            .flatMap(DefaultIracManager::keyStream)\n+            .filter(this::isWriteOwner);\n+   }\n+\n+   @Override\n+   public void run() {\n+      try {\n+         while (running) {\n+            senderNotifier.acquire();\n+            senderNotifier.drainPermits();\n+            periodicSend();\n+         }\n+      } catch (InterruptedException e) {\n+         Thread.currentThread().interrupt();\n+      }\n+   }\n+\n+   private void sendStateRequest(Address primary, IntSet segments) {\n+      CacheRpcCommand cmd = commandsFactory.buildIracRequestStateCommand(segments);\n+      rpcManager.sendTo(primary, cmd, DeliverOrder.NONE);\n+   }\n+\n+\n+   private boolean awaitResponses(CompletionStage<Void> reply) throws InterruptedException {\n+      //wait for replies\n+      try {\n+         reply.toCompletableFuture().get();\n+         return true;\n+      } catch (ExecutionException e) {\n+         //can be ignored. it will be retried in the next round.\n+         log.trace(\"IRAC update failed!\", e);\n+         //if it fails, we release a permit so the thread can retry\n+         //otherwise, if the cluster is idle, the keys will never been sent to the remote site\n+         senderNotifier.release();\n+      }\n+      return false;\n+   }\n+\n+   private void periodicSend() throws InterruptedException {\n+      if (trace) {\n+         log.tracef(\"[IRAC] Sending keys to remote site(s). Has clear? %s, keys: %s\", hasClear, updatedKeys.keySet());\n+      }\n+      if (hasClear) {\n+         //make sure the clear is replicated everywhere before sending the updates!\n+         CompletionStage<Void> rsp = sendCommandToAllBackups(buildClearCommand());\n+         if (awaitResponses(rsp)) {\n+            hasClear = false;\n+         } else {\n+            //we got an exception. go for next round\n+            return;\n+         }\n+      }\n+      try {\n+         SendKeyTask task = new SendKeyTask();\n+         updatedKeys.forEach(task);\n+         task.await();\n+      } catch (InterruptedException e) {\n+         throw e;\n+      } catch (Throwable t) {\n+         //TODO log exception\n+         log.fatal(\"[IRAC] Unexpected error!\", t);\n+      }\n+   }\n+\n+   private XSiteResponse sendToRemoteSite(XSiteBackup backup, XSiteReplicateCommand cmd) {\n+      XSiteResponse rsp = rpcManager.invokeXSite(backup, cmd);\n+      takeOfflineManager.registerRequest(rsp);\n+      return rsp;\n+   }\n+\n+   private void removeKey(Object key, int segmentId, Object lockOwner, IracMetadata tombstone) {\n+      //removes the key from the \"updated keys map\" in all owners.\n+      DistributionInfo dInfo = getDistributionInfo(segmentId);\n+      IracCleanupKeyCommand cmd = commandsFactory.buildIracCleanupKeyCommand(key, lockOwner, tombstone);\n+      rpcManager.sendToMany(dInfo.writeOwners(), cmd, DeliverOrder.NONE);\n+      cleanupKey(key, lockOwner, tombstone);\n+   }\n+\n+   private DistributionInfo getDistributionInfoKey(Object key) {\n+      return clusteringDependentLogic.getCacheTopology().getDistribution(key);\n+   }\n+\n+   private DistributionInfo getDistributionInfo(int segmentId) {\n+      return clusteringDependentLogic.getCacheTopology().getDistribution(segmentId);\n+   }\n+\n+   private int getSegment(Object key) {\n+      return clusteringDependentLogic.getCacheTopology().getSegment(key);\n+   }\n+\n+   private boolean isWriteOwner(Object key) {\n+      return getDistributionInfoKey(key).isWriteOwner();\n+   }\n+\n+   private CompletionStage<Void> sendCommandToAllBackups(XSiteReplicateCommand command) {\n+      if (command == null) {\n+         return IGNORE_KEY_SEND;\n+      }\n+      AggregateCompletionStage<Void> collector = CompletionStages.aggregateCompletionStage();\n+      for (XSiteBackup backup : asyncBackups) {\n+         if (takeOfflineManager.getSiteState(backup.getSiteName()) == SiteState.OFFLINE) {\n+            continue; //backup is offline\n+         }\n+         collector.dependsOn(sendToRemoteSite(backup, command));\n+      }\n+      return collector.freeze();\n+   }\n+\n+   private XSiteReplicateCommand buildClearCommand() {\n+      return commandsFactory.buildIracUpdateKeyCommand(null, null, null, null);\n+   }\n+\n+   private XSiteReplicateCommand buildRemoveCommand(CleanupTask cleanupTask) {\n+      Object key = cleanupTask.key;\n+      IracMetadata metadata = iracVersionGenerator.getTombstone(key);\n+      if (metadata == null) {\n+         return null;\n+      }\n+      cleanupTask.tombstone = metadata;\n+      return commandsFactory.buildIracUpdateKeyCommand(key, null, null, metadata);\n+   }\n+\n+   private CompletionStage<InternalCacheEntry<Object, Object>> fetchEntry(Object key, int segmentId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b5445e53a13a794bcb6ac70abac6f12231255"}, "originalPosition": 394}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1OTA3Ng==", "bodyText": "It handles expiration, notifications and ordering if passivation is enabled. The data container lock is not used for this purpose anymore.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421059076", "createdAt": "2020-05-06T20:05:11Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/xsite/irac/DefaultIracManager.java", "diffHunk": "@@ -0,0 +1,501 @@\n+package org.infinispan.xsite.irac;\n+\n+import static org.infinispan.util.concurrent.CompletableFutures.completedExceptionFuture;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Semaphore;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.infinispan.commands.CommandsFactory;\n+import org.infinispan.commands.irac.IracCleanupKeyCommand;\n+import org.infinispan.commands.remote.CacheRpcCommand;\n+import org.infinispan.commands.write.WriteCommand;\n+import org.infinispan.commons.util.IntSet;\n+import org.infinispan.commons.util.IntSets;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.container.DataContainer;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.container.impl.InternalDataContainer;\n+import org.infinispan.container.impl.InternalEntryFactory;\n+import org.infinispan.container.versioning.irac.IracVersionGenerator;\n+import org.infinispan.context.impl.FlagBitSets;\n+import org.infinispan.distribution.DistributionInfo;\n+import org.infinispan.factories.annotations.Inject;\n+import org.infinispan.factories.annotations.Start;\n+import org.infinispan.factories.annotations.Stop;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.interceptors.locking.ClusteringDependentLogic;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.persistence.PersistenceUtil;\n+import org.infinispan.persistence.manager.PersistenceManager;\n+import org.infinispan.remoting.inboundhandler.DeliverOrder;\n+import org.infinispan.remoting.rpc.RpcManager;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.remoting.transport.Transport;\n+import org.infinispan.remoting.transport.XSiteResponse;\n+import org.infinispan.topology.CacheTopology;\n+import org.infinispan.transaction.xa.GlobalTransaction;\n+import org.infinispan.util.concurrent.AggregateCompletionStage;\n+import org.infinispan.util.concurrent.CompletionStages;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.infinispan.xsite.XSiteBackup;\n+import org.infinispan.xsite.XSiteReplicateCommand;\n+import org.infinispan.xsite.status.SiteState;\n+import org.infinispan.xsite.status.TakeOfflineManager;\n+\n+/**\n+ * Default implementation of {@link IracManager}.\n+ * <p>\n+ * It tracks the keys updated by this site and sends them, periodically, to the configured remote sites.\n+ * <p>\n+ * The primary owner coordinates everything. It sends the updates request to the remote site and coordinates the local\n+ * site backup owners. After sending the updates to the remote site, it sends a cleanup request to the local site backup\n+ * owners\n+ * <p>\n+ * The backup owners only keeps a backup list of the tracked keys.\n+ * <p>\n+ * On topology change, the updated keys list is replicate to the new owner(s). Also, if a segment is being transferred\n+ * (i.e. the primary owner isn't a write and read owner), no updates to the remote site is sent since, most likely, the\n+ * node doesn't have the most up-to-date value.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@Scope(Scopes.NAMED_CACHE)\n+public class DefaultIracManager implements IracManager, Runnable {\n+\n+   private static final Log log = LogFactory.getLog(DefaultIracManager.class);\n+   private static final boolean trace = log.isTraceEnabled();\n+   private static final CompletableFuture<Void> IGNORE_KEY_SEND = completedExceptionFuture(new Exception(\"Ignore update\"));\n+\n+   @Inject RpcManager rpcManager;\n+   @Inject Configuration config;\n+   @Inject TakeOfflineManager takeOfflineManager;\n+   @Inject ClusteringDependentLogic clusteringDependentLogic;\n+   @Inject InternalDataContainer<Object, Object> dataContainer;\n+   @Inject PersistenceManager persistenceManager;\n+   @Inject CommandsFactory commandsFactory;\n+   @Inject IracVersionGenerator iracVersionGenerator;\n+\n+   private final Map<Object, Object> updatedKeys;\n+   private final Semaphore senderNotifier;\n+   private volatile boolean hasClear;\n+   private volatile Collection<XSiteBackup> asyncBackups;\n+   private volatile Thread sender;\n+   private volatile boolean running;\n+\n+   public DefaultIracManager() {\n+      this.updatedKeys = new ConcurrentHashMap<>();\n+      this.senderNotifier = new Semaphore(0);\n+   }\n+\n+   private static Collection<XSiteBackup> asyncBackups(Collection<BackupConfiguration> config, String localSiteName) {\n+      return config.stream()\n+            .filter(BackupConfiguration::isAsyncBackup)\n+            .filter(bc -> !localSiteName.equals(bc.site()))\n+            .map(bc -> new XSiteBackup(bc.site(), true, bc.replicationTimeout())) //convert to sync\n+            .collect(Collectors.toList());\n+   }\n+\n+   private static Stream<?> keyStream(WriteCommand command) {\n+      return command.getAffectedKeys().stream();\n+   }\n+\n+   private static boolean backupToRemoteSite(WriteCommand command) {\n+      return !command.hasAnyFlag(FlagBitSets.SKIP_XSITE_BACKUP);\n+   }\n+\n+   private static IntSet newIntSet(Address ignored) {\n+      return IntSets.mutableEmptySet();\n+   }\n+\n+   @Start\n+   public void start() {\n+      Transport transport = rpcManager.getTransport();\n+      transport.checkCrossSiteAvailable();\n+      String localSiteName = transport.localSiteName();\n+      asyncBackups = asyncBackups(config.sites().enabledBackups(), localSiteName);\n+      if (trace) {\n+         String b = asyncBackups.stream().map(XSiteBackup::getSiteName).collect(Collectors.joining(\", \"));\n+         log.tracef(\"Async remote sites found: %s\", b);\n+      }\n+      Thread oldSender = sender;\n+      if (oldSender != null) {\n+         oldSender.interrupt();\n+      }\n+      senderNotifier.drainPermits();\n+      running = true;\n+      hasClear = false;\n+      //TODO should we use a runnable in blocking executor?\n+      // it requires some synchronization since we can stop the runnable if the map is empty (instead of having a thread blocked/waiting)\n+      // not for now...\n+      Thread newSender = new Thread(this, \"irac-sender-thread-\" + transport.getAddress());\n+      sender = newSender;\n+      newSender.start();\n+\n+   }\n+\n+   @Stop\n+   public void stop() {\n+      running = false;\n+      Thread oldSender = sender;\n+      if (oldSender != null) {\n+         oldSender.interrupt();\n+      }\n+   }\n+\n+   @Override\n+   public void trackUpdatedKey(Object key, Object lockOwner) {\n+      if (trace) {\n+         log.tracef(\"Tracking key for %s: %s\", lockOwner, key);\n+      }\n+      updatedKeys.put(key, lockOwner);\n+      senderNotifier.release();\n+   }\n+\n+   @Override\n+   public <K> void trackUpdatedKeys(Collection<K> keys, Object lockOwner) {\n+      if (trace) {\n+         log.tracef(\"Tracking keys for %s: %s\", lockOwner, keys);\n+      }\n+      if (keys.isEmpty()) {\n+         return;\n+      }\n+      keys.forEach(key -> updatedKeys.put(key, lockOwner));\n+      senderNotifier.release();\n+   }\n+\n+   @Override\n+   public void trackKeysFromTransaction(Stream<WriteCommand> modifications, GlobalTransaction lockOwner) {\n+      keysFromMods(modifications).forEach(key -> {\n+         if (trace) {\n+            log.tracef(\"Tracking key for %s: %s\", lockOwner, key);\n+         }\n+         updatedKeys.put(key, lockOwner);\n+      });\n+      senderNotifier.release();\n+   }\n+\n+   @Override\n+   public void trackClear() {\n+      if (trace) {\n+         log.trace(\"Tracking clear request\");\n+      }\n+      hasClear = true;\n+      updatedKeys.clear();\n+      senderNotifier.release();\n+   }\n+\n+   @Override\n+   public void cleanupKey(Object key, Object lockOwner, IracMetadata tombstone) {\n+      updatedKeys.remove(key, lockOwner);\n+      iracVersionGenerator.removeTombstone(key, tombstone);\n+   }\n+\n+   @Override\n+   public void onTopologyUpdate(CacheTopology oldCacheTopology, CacheTopology newCacheTopology) {\n+      if (trace) {\n+         log.trace(\"[IRAC] Topology Updated! Checking pending keys.\");\n+      }\n+      Address local = rpcManager.getAddress();\n+      if (!newCacheTopology.getMembers().contains(local)) {\n+         //not in teh cache topology\n+         return;\n+      }\n+      IntSet addedSegments = IntSets.from(newCacheTopology.getWriteConsistentHash().getSegmentsForOwner(local));\n+      if (oldCacheTopology.getMembers().contains(local)) {\n+         addedSegments.removeAll(IntSets.from(oldCacheTopology.getWriteConsistentHash().getSegmentsForOwner(local)));\n+      }\n+\n+      if (addedSegments.isEmpty()) {\n+         //this node doesn't have any new segments but it may become the primary owner of some.\n+         //trigger a new round (it also removes the keys if the node isn't a owner)\n+         senderNotifier.release();\n+         return;\n+      }\n+\n+      //group new segments by primary owner\n+      Map<Address, IntSet> primarySegments = new HashMap<>();\n+      for (int segment : addedSegments) {\n+         Address primary = newCacheTopology.getWriteConsistentHash().locatePrimaryOwnerForSegment(segment);\n+         primarySegments.computeIfAbsent(primary, DefaultIracManager::newIntSet).add(segment);\n+      }\n+\n+      primarySegments.forEach(this::sendStateRequest);\n+\n+      senderNotifier.release();\n+   }\n+\n+   @Override\n+   public void requestState(Address origin, IntSet segments) {\n+      updatedKeys.forEach((key, lockOwner) -> sendStateIfNeeded(origin, segments, key, lockOwner));\n+   }\n+\n+   @Override\n+   public void receiveState(Object key, Object lockOwner, IracMetadata tombstone) {\n+      iracVersionGenerator.storeTombstoneIfAbsent(key, tombstone);\n+      updatedKeys.putIfAbsent(key, lockOwner);\n+      senderNotifier.release();\n+   }\n+\n+   //public for testing purposes\n+   public void sendStateIfNeeded(Address origin, IntSet segments, Object key, Object lockOwner) {\n+      int segment = getSegment(key);\n+      if (!segments.contains(segment)) {\n+         return;\n+      }\n+      //send the tombstone too\n+      IracMetadata tombstone = iracVersionGenerator.getTombstone(key);\n+\n+      CacheRpcCommand cmd = commandsFactory.buildIracStateResponseCommand(key, lockOwner, tombstone);\n+      rpcManager.sendTo(origin, cmd, DeliverOrder.NONE);\n+   }\n+\n+   //public for testing purposes\n+   public Stream<?> keysFromMods(Stream<WriteCommand> modifications) {\n+      return modifications\n+            .filter(WriteCommand::isSuccessful)\n+            .filter(DefaultIracManager::backupToRemoteSite)\n+            .flatMap(DefaultIracManager::keyStream)\n+            .filter(this::isWriteOwner);\n+   }\n+\n+   @Override\n+   public void run() {\n+      try {\n+         while (running) {\n+            senderNotifier.acquire();\n+            senderNotifier.drainPermits();\n+            periodicSend();\n+         }\n+      } catch (InterruptedException e) {\n+         Thread.currentThread().interrupt();\n+      }\n+   }\n+\n+   private void sendStateRequest(Address primary, IntSet segments) {\n+      CacheRpcCommand cmd = commandsFactory.buildIracRequestStateCommand(segments);\n+      rpcManager.sendTo(primary, cmd, DeliverOrder.NONE);\n+   }\n+\n+\n+   private boolean awaitResponses(CompletionStage<Void> reply) throws InterruptedException {\n+      //wait for replies\n+      try {\n+         reply.toCompletableFuture().get();\n+         return true;\n+      } catch (ExecutionException e) {\n+         //can be ignored. it will be retried in the next round.\n+         log.trace(\"IRAC update failed!\", e);\n+         //if it fails, we release a permit so the thread can retry\n+         //otherwise, if the cluster is idle, the keys will never been sent to the remote site\n+         senderNotifier.release();\n+      }\n+      return false;\n+   }\n+\n+   private void periodicSend() throws InterruptedException {\n+      if (trace) {\n+         log.tracef(\"[IRAC] Sending keys to remote site(s). Has clear? %s, keys: %s\", hasClear, updatedKeys.keySet());\n+      }\n+      if (hasClear) {\n+         //make sure the clear is replicated everywhere before sending the updates!\n+         CompletionStage<Void> rsp = sendCommandToAllBackups(buildClearCommand());\n+         if (awaitResponses(rsp)) {\n+            hasClear = false;\n+         } else {\n+            //we got an exception. go for next round\n+            return;\n+         }\n+      }\n+      try {\n+         SendKeyTask task = new SendKeyTask();\n+         updatedKeys.forEach(task);\n+         task.await();\n+      } catch (InterruptedException e) {\n+         throw e;\n+      } catch (Throwable t) {\n+         //TODO log exception\n+         log.fatal(\"[IRAC] Unexpected error!\", t);\n+      }\n+   }\n+\n+   private XSiteResponse sendToRemoteSite(XSiteBackup backup, XSiteReplicateCommand cmd) {\n+      XSiteResponse rsp = rpcManager.invokeXSite(backup, cmd);\n+      takeOfflineManager.registerRequest(rsp);\n+      return rsp;\n+   }\n+\n+   private void removeKey(Object key, int segmentId, Object lockOwner, IracMetadata tombstone) {\n+      //removes the key from the \"updated keys map\" in all owners.\n+      DistributionInfo dInfo = getDistributionInfo(segmentId);\n+      IracCleanupKeyCommand cmd = commandsFactory.buildIracCleanupKeyCommand(key, lockOwner, tombstone);\n+      rpcManager.sendToMany(dInfo.writeOwners(), cmd, DeliverOrder.NONE);\n+      cleanupKey(key, lockOwner, tombstone);\n+   }\n+\n+   private DistributionInfo getDistributionInfoKey(Object key) {\n+      return clusteringDependentLogic.getCacheTopology().getDistribution(key);\n+   }\n+\n+   private DistributionInfo getDistributionInfo(int segmentId) {\n+      return clusteringDependentLogic.getCacheTopology().getDistribution(segmentId);\n+   }\n+\n+   private int getSegment(Object key) {\n+      return clusteringDependentLogic.getCacheTopology().getSegment(key);\n+   }\n+\n+   private boolean isWriteOwner(Object key) {\n+      return getDistributionInfoKey(key).isWriteOwner();\n+   }\n+\n+   private CompletionStage<Void> sendCommandToAllBackups(XSiteReplicateCommand command) {\n+      if (command == null) {\n+         return IGNORE_KEY_SEND;\n+      }\n+      AggregateCompletionStage<Void> collector = CompletionStages.aggregateCompletionStage();\n+      for (XSiteBackup backup : asyncBackups) {\n+         if (takeOfflineManager.getSiteState(backup.getSiteName()) == SiteState.OFFLINE) {\n+            continue; //backup is offline\n+         }\n+         collector.dependsOn(sendToRemoteSite(backup, command));\n+      }\n+      return collector.freeze();\n+   }\n+\n+   private XSiteReplicateCommand buildClearCommand() {\n+      return commandsFactory.buildIracUpdateKeyCommand(null, null, null, null);\n+   }\n+\n+   private XSiteReplicateCommand buildRemoveCommand(CleanupTask cleanupTask) {\n+      Object key = cleanupTask.key;\n+      IracMetadata metadata = iracVersionGenerator.getTombstone(key);\n+      if (metadata == null) {\n+         return null;\n+      }\n+      cleanupTask.tombstone = metadata;\n+      return commandsFactory.buildIracUpdateKeyCommand(key, null, null, metadata);\n+   }\n+\n+   private CompletionStage<InternalCacheEntry<Object, Object>> fetchEntry(Object key, int segmentId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1ODc0OQ=="}, "originalCommit": {"oid": "c51b5445e53a13a794bcb6ac70abac6f12231255"}, "originalPosition": 394}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA2NTQ5NQ==", "bodyText": "Sorry I can't quite follow, but what this is for? Isn't the irac manager handling the replication of values and the prior if stores the keys in backup owners as well, I guess miss what part this does.\nMaybe hasEnabledBackups should be hasSyncEnabledBackups ? at EmptyConstructorNamedCacheFactory\n         return configuration.sites().hasEnabledBackups() ?\n                new BackupSenderImpl() :\n                NoOpBackupSender.getInstance();", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421065495", "createdAt": "2020-05-06T20:16:54Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/interceptors/xsite/NonTransactionalBackupInterceptor.java", "diffHunk": "@@ -127,58 +124,66 @@ private Object handleSingleKeyWriteCommand(InvocationContext ctx, DataWriteComma\n       return invokeNextThenApply(ctx, command, handleSingleKeyWriteReturn);\n    }\n \n-   private Object handleSingleKeyWriteReturn(InvocationContext ctx, DataWriteCommand dataWriteCommand, Object rv) throws Throwable {\n-      int segment = dataWriteCommand.getSegment();\n-      if (dataWriteCommand.isSuccessful() &&\n-            clusteringDependentLogic.getCacheTopology().getSegmentDistribution(segment).isPrimary()) {\n-         CacheEntry entry = ctx.lookupEntry(dataWriteCommand.getKey());\n-         DataWriteCommand crossSiteCommand;\n-         if (entry.isRemoved()) {\n-            crossSiteCommand = commandsFactory.buildRemoveCommand(dataWriteCommand.getKey(), null, segment,\n-                  dataWriteCommand.getFlagsBitSet());\n-         } else {\n-            crossSiteCommand = commandsFactory.buildPutKeyValueCommand(dataWriteCommand.getKey(), entry.getValue(),\n-                  segment, entry.getMetadata(), dataWriteCommand.getFlagsBitSet());\n+   private Object handleSingleKeyWriteReturn(InvocationContext ctx, DataWriteCommand dataWriteCommand, Object rv) {\n+      if (!dataWriteCommand.isSuccessful()) {\n+         if (trace) {\n+            log.tracef(\"Command %s is not successful, not replicating\", dataWriteCommand);\n          }\n-         InvocationStage stage = backupSender.backupWrite(crossSiteCommand, dataWriteCommand);\n-         return stage.thenReturn(ctx, dataWriteCommand, rv);\n+         return rv;\n+      }\n+      int segment = dataWriteCommand.getSegment();\n+      DistributionInfo dInfo = clusteringDependentLogic.getCacheTopology().getSegmentDistribution(segment);\n+      if (dInfo.isWriteOwner()) {\n+         //all owners has to keep track of the updates even if the primary owner is the only one who sends it.\n+         iracManager.trackUpdatedKey(dataWriteCommand.getKey(), dataWriteCommand.getCommandInvocationId());\n+      }\n+      if (dInfo.isPrimary()) { //primary owner sends for sync backups\n+         CacheEntry<?,?> entry = ctx.lookupEntry(dataWriteCommand.getKey());\n+         WriteCommand crossSiteCommand = createCommandForXSite(entry, segment, dataWriteCommand.getFlagsBitSet());\n+         return backupSender.backupWrite(crossSiteCommand, dataWriteCommand).thenReturn(ctx, dataWriteCommand, rv);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c51b5445e53a13a794bcb6ac70abac6f12231255"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3Mjk5MTcy", "url": "https://github.com/infinispan/infinispan/pull/8244#pullrequestreview-407299172", "createdAt": "2020-05-07T09:25:11Z", "commit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOToyNToxMVrOGR2GrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMDoyNToxN1rOGR4RHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTQyMA==", "bodyText": "We avoid using required=true as it prevents schema evolution and has actually been removed in proto 3.\nThe type field is also redundant.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421365420", "createdAt": "2020-05-07T09:25:11Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/metadata/impl/IracMetadata.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package org.infinispan.metadata.impl;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.Objects;\n+\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.container.versioning.irac.IracEntryVersion;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.protostream.descriptors.Type;\n+\n+/**\n+ * The metadata stored for an entry needed for IRAC (async cross-site replication).\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@ProtoTypeId(ProtoStreamTypeIds.IRAC_METADATA)\n+public class IracMetadata {\n+\n+   private final String site;\n+   private final IracEntryVersion version;\n+\n+   @ProtoFactory\n+   public IracMetadata(String site, IracEntryVersion version) {\n+      this.site = Objects.requireNonNull(site);\n+      this.version = Objects.requireNonNull(version);\n+   }\n+\n+   public static void writeTo(ObjectOutput output, IracMetadata metadata) throws IOException {\n+      metadata.writeTo(output);\n+   }\n+\n+   public static IracMetadata readFrom(ObjectInput in) throws IOException, ClassNotFoundException {\n+      return new IracMetadata(in.readUTF(), (IracEntryVersion) in.readObject());\n+   }\n+\n+   @ProtoField(number = 1, type = Type.STRING, required = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NTUzNg==", "bodyText": "Remove required", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421365536", "createdAt": "2020-05-07T09:25:21Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/metadata/impl/IracMetadata.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package org.infinispan.metadata.impl;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.Objects;\n+\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.container.versioning.irac.IracEntryVersion;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.protostream.descriptors.Type;\n+\n+/**\n+ * The metadata stored for an entry needed for IRAC (async cross-site replication).\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@ProtoTypeId(ProtoStreamTypeIds.IRAC_METADATA)\n+public class IracMetadata {\n+\n+   private final String site;\n+   private final IracEntryVersion version;\n+\n+   @ProtoFactory\n+   public IracMetadata(String site, IracEntryVersion version) {\n+      this.site = Objects.requireNonNull(site);\n+      this.version = Objects.requireNonNull(version);\n+   }\n+\n+   public static void writeTo(ObjectOutput output, IracMetadata metadata) throws IOException {\n+      metadata.writeTo(output);\n+   }\n+\n+   public static IracMetadata readFrom(ObjectInput in) throws IOException, ClassNotFoundException {\n+      return new IracMetadata(in.readUTF(), (IracEntryVersion) in.readObject());\n+   }\n+\n+   @ProtoField(number = 1, type = Type.STRING, required = true)\n+   public String getSite() {\n+      return site;\n+   }\n+\n+   @ProtoField(number = 2, required = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3ODM2NA==", "bodyText": "Empty line", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421378364", "createdAt": "2020-05-07T09:46:10Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/commands/irac/IracStateResponseCommand.java", "diffHunk": "@@ -0,0 +1,120 @@\n+package org.infinispan.commands.irac;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.commands.CommandInvocationId;\n+import org.infinispan.commands.remote.CacheRpcCommand;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.util.ByteString;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+\n+/**\n+ * The IRAC state for a given key.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+public class IracStateResponseCommand implements CacheRpcCommand {\n+\n+   public static final byte COMMAND_ID = 120;\n+\n+   private ByteString cacheName;\n+   private Object key;\n+   private Object lockOwner;\n+   private IracMetadata tombstone;\n+\n+   @SuppressWarnings(\"unused\")\n+   public IracStateResponseCommand() {\n+   }\n+\n+   public IracStateResponseCommand(ByteString cacheName) {\n+      this.cacheName = cacheName;\n+   }\n+\n+   public IracStateResponseCommand(ByteString cacheName, Object key, Object lockOwner, IracMetadata tombstone) {\n+      this(cacheName);\n+      this.key = key;\n+      this.lockOwner = lockOwner;\n+      this.tombstone = tombstone;\n+   }\n+\n+   @Override\n+   public CompletionStage<?> invokeAsync(ComponentRegistry registry) throws Throwable {\n+      registry.getIracManager().wired().receiveState(key, lockOwner, tombstone);\n+      return CompletableFutures.completedNull();\n+   }\n+\n+   @Override\n+   public byte getCommandId() {\n+      return COMMAND_ID;\n+   }\n+\n+   @Override\n+   public boolean isReturnValueExpected() {\n+      return false;\n+   }\n+\n+   @Override\n+   public void writeTo(ObjectOutput output) throws IOException {\n+      output.writeObject(key);\n+      boolean cId = lockOwner instanceof CommandInvocationId;\n+      output.writeBoolean(cId);\n+      if (cId) {\n+         CommandInvocationId.writeTo(output, (CommandInvocationId) lockOwner);\n+      } else {\n+         output.writeObject(lockOwner);\n+      }\n+      boolean nullTombstone = tombstone == null;\n+      output.writeBoolean(nullTombstone);\n+      if (!nullTombstone) {\n+         tombstone.writeTo(output);\n+      }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4MzUxOQ==", "bodyText": "Can we split this into 3 commands:\n\nIracPutKeyCommand\nIracRemoveKeyCommand\nIracClearCommand\n\nIt separates the logic into the distinct commands, removes the need for the Operation implementations and longer term is more suitable for ProtoStream conversion.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421383519", "createdAt": "2020-05-07T09:54:48Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/commands/irac/IracUpdateKeyCommand.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package org.infinispan.commands.irac;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.util.ByteString;\n+import org.infinispan.xsite.BackupReceiver;\n+import org.infinispan.xsite.BackupReceiverRepository;\n+import org.infinispan.xsite.XSiteReplicateCommand;\n+import org.infinispan.xsite.irac.IracManager;\n+\n+/**\n+ * An update request that is sent to the remote site by {@link IracManager}.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+public class IracUpdateKeyCommand extends XSiteReplicateCommand {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4Mzc5Mw==", "bodyText": "Is this going into this PR?", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421383793", "createdAt": "2020-05-07T09:55:16Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/commands/irac/IracUpdateKeyCommand.java", "diffHunk": "@@ -0,0 +1,249 @@\n+package org.infinispan.commands.irac;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.factories.ComponentRegistry;\n+import org.infinispan.metadata.Metadata;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.util.ByteString;\n+import org.infinispan.xsite.BackupReceiver;\n+import org.infinispan.xsite.BackupReceiverRepository;\n+import org.infinispan.xsite.XSiteReplicateCommand;\n+import org.infinispan.xsite.irac.IracManager;\n+\n+/**\n+ * An update request that is sent to the remote site by {@link IracManager}.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+public class IracUpdateKeyCommand extends XSiteReplicateCommand {\n+\n+   public static final byte COMMAND_ID = 123;\n+\n+   private static final byte CLEAR_OP = 0;\n+   private static final byte REMOVE_OP = 1;\n+   private static final byte PUT_OP = 2;\n+\n+   private static final Operation CLEAR_OPERATION = new Operation() {\n+      @Override\n+      public byte getType() {\n+         return CLEAR_OP;\n+      }\n+\n+      @Override\n+      public CompletionStage<Void> execute(BackupReceiver receiver) {\n+         return receiver.clearKeys();\n+      }\n+\n+      @Override\n+      public String toString() {\n+         return \"CLEAR()\";\n+      }\n+   };\n+\n+   private Operation operation;\n+\n+   @SuppressWarnings(\"unused\")\n+   public IracUpdateKeyCommand() {\n+      super(COMMAND_ID, null);\n+   }\n+\n+   public IracUpdateKeyCommand(ByteString cacheName) {\n+      super(COMMAND_ID, cacheName);\n+   }\n+\n+   public IracUpdateKeyCommand(ByteString cacheName, Object key, Object value, Metadata metadata,\n+         IracMetadata iracMetadata) {\n+      super(COMMAND_ID, cacheName);\n+      if (key == null) {\n+         this.operation = CLEAR_OPERATION;\n+      } else if (value == null) {\n+         RemoveOperation op = new RemoveOperation();\n+         op.key = key;\n+         op.iracMetadata = iracMetadata;\n+         this.operation = op;\n+      } else {\n+         PutOperation op = new PutOperation();\n+         op.key = key;\n+         op.value = value;\n+         op.metadata = metadata;\n+         op.iracMetadata = iracMetadata;\n+         this.operation = op;\n+      }\n+   }\n+\n+   private static Operation createOperation(byte type) {\n+      switch (type) {\n+         case CLEAR_OP:\n+            return CLEAR_OPERATION;\n+         case PUT_OP:\n+            return new PutOperation();\n+         case REMOVE_OP:\n+            return new RemoveOperation();\n+         default:\n+            throw new IllegalStateException(\"Unknown type: \" + type);\n+      }\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> performInLocalSite(BackupReceiver receiver, boolean preserveOrder) {\n+      assert !preserveOrder : \"IRAC Update Command sent asynchronously!\";\n+      return receiver.forwardToPrimary(this);\n+   }\n+\n+   public CompletionStage<Void> executeOperation(BackupReceiver receiver) {\n+      return operation.execute(receiver);\n+   }\n+\n+   @Override\n+   public CompletionStage<?> invokeAsync(ComponentRegistry registry) {\n+      //noinspection unchecked\n+      Cache<Object, Object> cache = registry.getCache().running();\n+      //TODO! create a component for BackupReceiver", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4NjUzNg==", "bodyText": "Just protoFactory?", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421386536", "createdAt": "2020-05-07T09:59:45Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/container/versioning/irac/IracEntryVersion.java", "diffHunk": "@@ -0,0 +1,307 @@\n+package org.infinispan.container.versioning.irac;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.container.versioning.InequalVersionComparisonResult;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.protostream.descriptors.Type;\n+\n+/**\n+ * An entry version for the IRAC algorithm (async cross site replication).\n+ * <p>\n+ * It is represented as a vector clock where each site keeps it version.\n+ * <p>\n+ * The site version is composed as a pair (topology id, version).\n+ *\n+ * @author Pedro Ruivo\n+ * @see TopologyIracVersion\n+ * @since 11.0\n+ */\n+@ProtoTypeId(ProtoStreamTypeIds.IRAC_VERSION)\n+public class IracEntryVersion {\n+\n+   private final Map<String, TopologyIracVersion> vectorClock;\n+\n+   public IracEntryVersion(Map<String, TopologyIracVersion> vectorClock) {\n+      this.vectorClock = Objects.requireNonNull(vectorClock);\n+   }\n+\n+   @ProtoFactory\n+   static IracEntryVersion protostreamFactory(List<MapEntry> entries) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4NzU5NQ==", "bodyText": "If we place this below the @ProtoFactory method it makes the marshalling logic easier to read as it's all in one place.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421387595", "createdAt": "2020-05-07T10:01:29Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/container/versioning/irac/IracEntryVersion.java", "diffHunk": "@@ -0,0 +1,307 @@\n+package org.infinispan.container.versioning.irac;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.container.versioning.InequalVersionComparisonResult;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.protostream.descriptors.Type;\n+\n+/**\n+ * An entry version for the IRAC algorithm (async cross site replication).\n+ * <p>\n+ * It is represented as a vector clock where each site keeps it version.\n+ * <p>\n+ * The site version is composed as a pair (topology id, version).\n+ *\n+ * @author Pedro Ruivo\n+ * @see TopologyIracVersion\n+ * @since 11.0\n+ */\n+@ProtoTypeId(ProtoStreamTypeIds.IRAC_VERSION)\n+public class IracEntryVersion {\n+\n+   private final Map<String, TopologyIracVersion> vectorClock;\n+\n+   public IracEntryVersion(Map<String, TopologyIracVersion> vectorClock) {\n+      this.vectorClock = Objects.requireNonNull(vectorClock);\n+   }\n+\n+   @ProtoFactory\n+   static IracEntryVersion protostreamFactory(List<MapEntry> entries) {\n+      Map<String, TopologyIracVersion> vectorClock = entries.stream()\n+            .collect(Collectors.toMap(mapEntry -> mapEntry.site, mapEntry -> mapEntry.version));\n+      return new IracEntryVersion(vectorClock);\n+   }\n+\n+   /**\n+    * Converts this instance to a {@link Map}.\n+    * <p>\n+    * The map cannot be modified!.\n+    *\n+    * @return The {@link Map} representation of this version.\n+    */\n+   public Map<String, TopologyIracVersion> toMap() {\n+      return Collections.unmodifiableMap(vectorClock);\n+   }\n+\n+   /**\n+    * Iterates over all entries of this version as pairs (site name, site version).\n+    *\n+    * @param consumer The {@link BiConsumer}.\n+    */\n+   public void forEach(BiConsumer<String, TopologyIracVersion> consumer) {\n+      vectorClock.forEach(consumer);\n+   }\n+\n+   /**\n+    * Compares this instance with another {@link IracEntryVersion} instance.\n+    * @param other The other {@link IracEntryVersion} instance.\n+    * @return A {@link InequalVersionComparisonResult} instance with the compare result.\n+    */\n+   public InequalVersionComparisonResult compareTo(IracEntryVersion other) {\n+      VectorClock vectorClock = new VectorClock();\n+      this.forEach(vectorClock::setOurs);\n+      other.forEach(vectorClock::setTheirs);\n+\n+      Merger merger = Merger.NONE;\n+      for (VersionCompare v : vectorClock.values()) {\n+         merger = merger.accept(v);\n+      }\n+      return merger.result();\n+   }\n+\n+   @Override\n+   public String toString() {\n+      List<String> entries = new LinkedList<>();\n+      vectorClock.forEach((site, version) -> entries.add(site + \"=\" + version));\n+      return \"(\" + String.join(\", \", entries) + \")\";\n+   }\n+\n+   @Override\n+   public boolean equals(Object o) {\n+      if (this == o) {\n+         return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+         return false;\n+      }\n+\n+      IracEntryVersion version = (IracEntryVersion) o;\n+\n+      return vectorClock.equals(version.vectorClock);\n+   }\n+\n+   @Override\n+   public int hashCode() {\n+      return vectorClock.hashCode();\n+   }\n+\n+   @ProtoField(number = 1, collectionImplementation = ArrayList.class)\n+   List<MapEntry> entries() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4ODIxNw==", "bodyText": "required should be removed.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421388217", "createdAt": "2020-05-07T10:02:38Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/container/versioning/irac/IracEntryVersion.java", "diffHunk": "@@ -0,0 +1,307 @@\n+package org.infinispan.container.versioning.irac;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.container.versioning.InequalVersionComparisonResult;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.protostream.descriptors.Type;\n+\n+/**\n+ * An entry version for the IRAC algorithm (async cross site replication).\n+ * <p>\n+ * It is represented as a vector clock where each site keeps it version.\n+ * <p>\n+ * The site version is composed as a pair (topology id, version).\n+ *\n+ * @author Pedro Ruivo\n+ * @see TopologyIracVersion\n+ * @since 11.0\n+ */\n+@ProtoTypeId(ProtoStreamTypeIds.IRAC_VERSION)\n+public class IracEntryVersion {\n+\n+   private final Map<String, TopologyIracVersion> vectorClock;\n+\n+   public IracEntryVersion(Map<String, TopologyIracVersion> vectorClock) {\n+      this.vectorClock = Objects.requireNonNull(vectorClock);\n+   }\n+\n+   @ProtoFactory\n+   static IracEntryVersion protostreamFactory(List<MapEntry> entries) {\n+      Map<String, TopologyIracVersion> vectorClock = entries.stream()\n+            .collect(Collectors.toMap(mapEntry -> mapEntry.site, mapEntry -> mapEntry.version));\n+      return new IracEntryVersion(vectorClock);\n+   }\n+\n+   /**\n+    * Converts this instance to a {@link Map}.\n+    * <p>\n+    * The map cannot be modified!.\n+    *\n+    * @return The {@link Map} representation of this version.\n+    */\n+   public Map<String, TopologyIracVersion> toMap() {\n+      return Collections.unmodifiableMap(vectorClock);\n+   }\n+\n+   /**\n+    * Iterates over all entries of this version as pairs (site name, site version).\n+    *\n+    * @param consumer The {@link BiConsumer}.\n+    */\n+   public void forEach(BiConsumer<String, TopologyIracVersion> consumer) {\n+      vectorClock.forEach(consumer);\n+   }\n+\n+   /**\n+    * Compares this instance with another {@link IracEntryVersion} instance.\n+    * @param other The other {@link IracEntryVersion} instance.\n+    * @return A {@link InequalVersionComparisonResult} instance with the compare result.\n+    */\n+   public InequalVersionComparisonResult compareTo(IracEntryVersion other) {\n+      VectorClock vectorClock = new VectorClock();\n+      this.forEach(vectorClock::setOurs);\n+      other.forEach(vectorClock::setTheirs);\n+\n+      Merger merger = Merger.NONE;\n+      for (VersionCompare v : vectorClock.values()) {\n+         merger = merger.accept(v);\n+      }\n+      return merger.result();\n+   }\n+\n+   @Override\n+   public String toString() {\n+      List<String> entries = new LinkedList<>();\n+      vectorClock.forEach((site, version) -> entries.add(site + \"=\" + version));\n+      return \"(\" + String.join(\", \", entries) + \")\";\n+   }\n+\n+   @Override\n+   public boolean equals(Object o) {\n+      if (this == o) {\n+         return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+         return false;\n+      }\n+\n+      IracEntryVersion version = (IracEntryVersion) o;\n+\n+      return vectorClock.equals(version.vectorClock);\n+   }\n+\n+   @Override\n+   public int hashCode() {\n+      return vectorClock.hashCode();\n+   }\n+\n+   @ProtoField(number = 1, collectionImplementation = ArrayList.class)\n+   List<MapEntry> entries() {\n+      List<MapEntry> entries = new ArrayList<>(3);\n+      vectorClock.forEach((site, version) -> entries.add(new MapEntry(site, version)));\n+      return entries;\n+   }\n+\n+   private enum Merger {\n+      NONE {\n+         @Override\n+         Merger accept(VersionCompare versions) {\n+            int compare = versions.ours.compareTo(versions.theirs);\n+            if (compare < 0) {\n+               return OLD;\n+            } else if (compare > 0) {\n+               return NEW;\n+            }\n+            return EQUALS;\n+         }\n+\n+         @Override\n+         InequalVersionComparisonResult result() {\n+            throw new IllegalStateException();\n+         }\n+      },\n+      OLD {\n+         @Override\n+         Merger accept(VersionCompare versions) {\n+            int compare = versions.ours.compareTo(versions.theirs);\n+            if (compare < 0) {\n+               return OLD;\n+            } else if (compare > 0) {\n+               return CONFLICT;\n+            }\n+            return OLD_OR_EQUALS;\n+         }\n+\n+         @Override\n+         InequalVersionComparisonResult result() {\n+            return InequalVersionComparisonResult.BEFORE;\n+         }\n+      },\n+      OLD_OR_EQUALS {\n+         @Override\n+         Merger accept(VersionCompare versions) {\n+            int compare = versions.ours.compareTo(versions.theirs);\n+            return compare <= 0 ? OLD_OR_EQUALS : CONFLICT;\n+         }\n+\n+         @Override\n+         InequalVersionComparisonResult result() {\n+            return InequalVersionComparisonResult.BEFORE;\n+         }\n+      },\n+      NEW {\n+         @Override\n+         Merger accept(VersionCompare versions) {\n+            int compare = versions.ours.compareTo(versions.theirs);\n+            if (compare > 0) {\n+               return NEW;\n+            } else if (compare < 0) {\n+               return CONFLICT;\n+            }\n+            return NEW_OR_EQUALS;\n+         }\n+\n+         @Override\n+         InequalVersionComparisonResult result() {\n+            return InequalVersionComparisonResult.AFTER;\n+         }\n+      },\n+      NEW_OR_EQUALS {\n+         @Override\n+         Merger accept(VersionCompare versions) {\n+            int compare = versions.ours.compareTo(versions.theirs);\n+            return compare < 0 ? CONFLICT : NEW_OR_EQUALS;\n+         }\n+\n+         @Override\n+         InequalVersionComparisonResult result() {\n+            return InequalVersionComparisonResult.AFTER;\n+         }\n+      },\n+      EQUALS {\n+         @Override\n+         Merger accept(VersionCompare versions) {\n+            int compare = versions.ours.compareTo(versions.theirs);\n+            if (compare < 0) {\n+               return OLD_OR_EQUALS;\n+            } else if (compare > 0) {\n+               return NEW_OR_EQUALS;\n+            }\n+            return EQUALS;\n+         }\n+\n+         @Override\n+         InequalVersionComparisonResult result() {\n+            return InequalVersionComparisonResult.EQUAL;\n+         }\n+      },\n+      CONFLICT {\n+         @Override\n+         Merger accept(VersionCompare versions) {\n+            //no-op\n+            return CONFLICT;\n+         }\n+\n+         @Override\n+         InequalVersionComparisonResult result() {\n+            return InequalVersionComparisonResult.CONFLICTING;\n+         }\n+      };\n+\n+      abstract Merger accept(VersionCompare versions);\n+\n+      abstract InequalVersionComparisonResult result();\n+   }\n+\n+   @ProtoTypeId(ProtoStreamTypeIds.IRAC_VERSION_ENTRY)\n+   public static class MapEntry {\n+\n+      @ProtoField(number = 1, type = Type.STRING, required = true)\n+      final String site;\n+      @ProtoField(number = 2, required = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4ODMyNg==", "bodyText": "type is redundant and required should be removed.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421388326", "createdAt": "2020-05-07T10:02:48Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/container/versioning/irac/IracEntryVersion.java", "diffHunk": "@@ -0,0 +1,307 @@\n+package org.infinispan.container.versioning.irac;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+import org.infinispan.commons.marshall.ProtoStreamTypeIds;\n+import org.infinispan.container.versioning.InequalVersionComparisonResult;\n+import org.infinispan.protostream.annotations.ProtoFactory;\n+import org.infinispan.protostream.annotations.ProtoField;\n+import org.infinispan.protostream.annotations.ProtoTypeId;\n+import org.infinispan.protostream.descriptors.Type;\n+\n+/**\n+ * An entry version for the IRAC algorithm (async cross site replication).\n+ * <p>\n+ * It is represented as a vector clock where each site keeps it version.\n+ * <p>\n+ * The site version is composed as a pair (topology id, version).\n+ *\n+ * @author Pedro Ruivo\n+ * @see TopologyIracVersion\n+ * @since 11.0\n+ */\n+@ProtoTypeId(ProtoStreamTypeIds.IRAC_VERSION)\n+public class IracEntryVersion {\n+\n+   private final Map<String, TopologyIracVersion> vectorClock;\n+\n+   public IracEntryVersion(Map<String, TopologyIracVersion> vectorClock) {\n+      this.vectorClock = Objects.requireNonNull(vectorClock);\n+   }\n+\n+   @ProtoFactory\n+   static IracEntryVersion protostreamFactory(List<MapEntry> entries) {\n+      Map<String, TopologyIracVersion> vectorClock = entries.stream()\n+            .collect(Collectors.toMap(mapEntry -> mapEntry.site, mapEntry -> mapEntry.version));\n+      return new IracEntryVersion(vectorClock);\n+   }\n+\n+   /**\n+    * Converts this instance to a {@link Map}.\n+    * <p>\n+    * The map cannot be modified!.\n+    *\n+    * @return The {@link Map} representation of this version.\n+    */\n+   public Map<String, TopologyIracVersion> toMap() {\n+      return Collections.unmodifiableMap(vectorClock);\n+   }\n+\n+   /**\n+    * Iterates over all entries of this version as pairs (site name, site version).\n+    *\n+    * @param consumer The {@link BiConsumer}.\n+    */\n+   public void forEach(BiConsumer<String, TopologyIracVersion> consumer) {\n+      vectorClock.forEach(consumer);\n+   }\n+\n+   /**\n+    * Compares this instance with another {@link IracEntryVersion} instance.\n+    * @param other The other {@link IracEntryVersion} instance.\n+    * @return A {@link InequalVersionComparisonResult} instance with the compare result.\n+    */\n+   public InequalVersionComparisonResult compareTo(IracEntryVersion other) {\n+      VectorClock vectorClock = new VectorClock();\n+      this.forEach(vectorClock::setOurs);\n+      other.forEach(vectorClock::setTheirs);\n+\n+      Merger merger = Merger.NONE;\n+      for (VersionCompare v : vectorClock.values()) {\n+         merger = merger.accept(v);\n+      }\n+      return merger.result();\n+   }\n+\n+   @Override\n+   public String toString() {\n+      List<String> entries = new LinkedList<>();\n+      vectorClock.forEach((site, version) -> entries.add(site + \"=\" + version));\n+      return \"(\" + String.join(\", \", entries) + \")\";\n+   }\n+\n+   @Override\n+   public boolean equals(Object o) {\n+      if (this == o) {\n+         return true;\n+      }\n+      if (o == null || getClass() != o.getClass()) {\n+         return false;\n+      }\n+\n+      IracEntryVersion version = (IracEntryVersion) o;\n+\n+      return vectorClock.equals(version.vectorClock);\n+   }\n+\n+   @Override\n+   public int hashCode() {\n+      return vectorClock.hashCode();\n+   }\n+\n+   @ProtoField(number = 1, collectionImplementation = ArrayList.class)\n+   List<MapEntry> entries() {\n+      List<MapEntry> entries = new ArrayList<>(3);\n+      vectorClock.forEach((site, version) -> entries.add(new MapEntry(site, version)));\n+      return entries;\n+   }\n+\n+   private enum Merger {\n+      NONE {\n+         @Override\n+         Merger accept(VersionCompare versions) {\n+            int compare = versions.ours.compareTo(versions.theirs);\n+            if (compare < 0) {\n+               return OLD;\n+            } else if (compare > 0) {\n+               return NEW;\n+            }\n+            return EQUALS;\n+         }\n+\n+         @Override\n+         InequalVersionComparisonResult result() {\n+            throw new IllegalStateException();\n+         }\n+      },\n+      OLD {\n+         @Override\n+         Merger accept(VersionCompare versions) {\n+            int compare = versions.ours.compareTo(versions.theirs);\n+            if (compare < 0) {\n+               return OLD;\n+            } else if (compare > 0) {\n+               return CONFLICT;\n+            }\n+            return OLD_OR_EQUALS;\n+         }\n+\n+         @Override\n+         InequalVersionComparisonResult result() {\n+            return InequalVersionComparisonResult.BEFORE;\n+         }\n+      },\n+      OLD_OR_EQUALS {\n+         @Override\n+         Merger accept(VersionCompare versions) {\n+            int compare = versions.ours.compareTo(versions.theirs);\n+            return compare <= 0 ? OLD_OR_EQUALS : CONFLICT;\n+         }\n+\n+         @Override\n+         InequalVersionComparisonResult result() {\n+            return InequalVersionComparisonResult.BEFORE;\n+         }\n+      },\n+      NEW {\n+         @Override\n+         Merger accept(VersionCompare versions) {\n+            int compare = versions.ours.compareTo(versions.theirs);\n+            if (compare > 0) {\n+               return NEW;\n+            } else if (compare < 0) {\n+               return CONFLICT;\n+            }\n+            return NEW_OR_EQUALS;\n+         }\n+\n+         @Override\n+         InequalVersionComparisonResult result() {\n+            return InequalVersionComparisonResult.AFTER;\n+         }\n+      },\n+      NEW_OR_EQUALS {\n+         @Override\n+         Merger accept(VersionCompare versions) {\n+            int compare = versions.ours.compareTo(versions.theirs);\n+            return compare < 0 ? CONFLICT : NEW_OR_EQUALS;\n+         }\n+\n+         @Override\n+         InequalVersionComparisonResult result() {\n+            return InequalVersionComparisonResult.AFTER;\n+         }\n+      },\n+      EQUALS {\n+         @Override\n+         Merger accept(VersionCompare versions) {\n+            int compare = versions.ours.compareTo(versions.theirs);\n+            if (compare < 0) {\n+               return OLD_OR_EQUALS;\n+            } else if (compare > 0) {\n+               return NEW_OR_EQUALS;\n+            }\n+            return EQUALS;\n+         }\n+\n+         @Override\n+         InequalVersionComparisonResult result() {\n+            return InequalVersionComparisonResult.EQUAL;\n+         }\n+      },\n+      CONFLICT {\n+         @Override\n+         Merger accept(VersionCompare versions) {\n+            //no-op\n+            return CONFLICT;\n+         }\n+\n+         @Override\n+         InequalVersionComparisonResult result() {\n+            return InequalVersionComparisonResult.CONFLICTING;\n+         }\n+      };\n+\n+      abstract Merger accept(VersionCompare versions);\n+\n+      abstract InequalVersionComparisonResult result();\n+   }\n+\n+   @ProtoTypeId(ProtoStreamTypeIds.IRAC_VERSION_ENTRY)\n+   public static class MapEntry {\n+\n+      @ProtoField(number = 1, type = Type.STRING, required = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4ODYyNg==", "bodyText": "Additional empty line", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421388626", "createdAt": "2020-05-07T10:03:21Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/context/impl/LocalTxInvocationContext.java", "diffHunk": "@@ -64,4 +66,30 @@ public final void remoteLocksAcquired(Collection<Address> nodes) {\n    public final Transaction getTransaction() {\n       return getCacheTransaction().getTransaction();\n    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM5MDA0NQ==", "bodyText": "Can you create a Jira for this and add the ID to the comment.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421390045", "createdAt": "2020-05-07T10:05:57Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/interceptors/impl/AbstractIracRemoteSiteInterceptor.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package org.infinispan.interceptors.impl;\n+\n+import org.infinispan.commands.write.DataWriteCommand;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.container.versioning.irac.IracEntryVersion;\n+import org.infinispan.context.InvocationContext;\n+import org.infinispan.interceptors.AsyncInterceptorChain;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.xsite.irac.IracUtils;\n+\n+/**\n+ * An IRAC related interceptor that that handles the requests from the remote site.\n+ * <p>\n+ * This class contains only the common code and it is always present in the {@link AsyncInterceptorChain} because the\n+ * cache has no knowledge if it is a backup from others site or not.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+public abstract class AbstractIracRemoteSiteInterceptor extends AbstractIracLocalSiteInterceptor {\n+\n+   /**\n+    * Invoked on the primary owner, it validates if the remote site update is valid or not.\n+    * <p>\n+    * It also performs a conflict resolution if a conflict is found.\n+    */\n+   protected void validateOnPrimary(InvocationContext ctx, DataWriteCommand command,\n+         @SuppressWarnings(\"unused\") Object rv) {\n+      final Object key = command.getKey();\n+      CacheEntry<?, ?> entry = ctx.lookupEntry(key);\n+      IracMetadata remoteMetadata = IracUtils.getIracMetadataFromCommand(command, key);\n+      IracMetadata localMetadata = IracUtils.getIracMetadata(entry, iracVersionGenerator);\n+\n+      if (localMetadata == null) {\n+         localMetadata = iracVersionGenerator.getTombstone(key);\n+      }\n+\n+      assert remoteMetadata != null;\n+\n+      iracVersionGenerator.updateVersion(getSegment(key), remoteMetadata.getVersion());\n+\n+      if (localMetadata != null) {\n+         validateAndSetMetadata(entry, command, localMetadata, remoteMetadata);\n+      } else {\n+         setIracMetadata(entry, remoteMetadata);\n+      }\n+   }\n+\n+   /**\n+    * Invoked by backup owners, it make sure the entry has the same version as set by the primary owner.\n+    */\n+   protected void setIracMetadataForOwner(InvocationContext ctx, DataWriteCommand command,\n+         @SuppressWarnings(\"unused\") Object rv) {\n+      final Object key = command.getKey();\n+      IracMetadata metadata = IracUtils.getIracMetadataFromCommand(command, key);\n+      assert metadata != null;\n+      iracVersionGenerator.updateVersion(getSegment(key), metadata.getVersion());\n+      setIracMetadata(ctx.lookupEntry(key), metadata);\n+   }\n+\n+   private void validateAndSetMetadata(CacheEntry<?, ?> entry, DataWriteCommand command,\n+         IracMetadata localMetadata, IracMetadata remoteMetadata) {\n+      if (isTraceEnabled()) {\n+         getLog().tracef(\"[IRAC] Comparing local and remote metadata: %s and %s\", localMetadata, remoteMetadata);\n+      }\n+      IracEntryVersion localVersion = localMetadata.getVersion();\n+      IracEntryVersion remoteVersion = remoteMetadata.getVersion();\n+      switch (remoteVersion.compareTo(localVersion)) {\n+         case CONFLICTING:\n+            resolveConflict(entry, command, localMetadata, remoteMetadata);\n+            return;\n+         case EQUAL:\n+         case BEFORE:\n+            IracUtils.discardUpdate(getLog(), entry, command, remoteMetadata);\n+            return;\n+      }\n+      setIracMetadata(entry, remoteMetadata);\n+   }\n+\n+\n+   private void resolveConflict(CacheEntry<?, ?> entry, DataWriteCommand command, IracMetadata localMetadata,\n+         IracMetadata remoteMetadata) {\n+      if (isTraceEnabled()) {\n+         getLog().tracef(\"[IRAC] Conflict found between local and remote metadata: %s and %s\", localMetadata,\n+               remoteMetadata);\n+      }\n+      //same site? conflict?\n+      assert !localMetadata.getSite().equals(remoteMetadata.getSite());\n+      if (localMetadata.getSite().compareTo(remoteMetadata.getSite()) < 0) {\n+         IracUtils.discardUpdate(getLog(), entry, command, remoteMetadata);\n+         return;\n+      }\n+      //other site update has priority!\n+      setIracMetadata(entry, remoteMetadata);\n+      //TODO! this isn't required now but when we allow custom conflict resolution, we need to merge the versions!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM5MTMyNA==", "bodyText": "I assume InDoubtTxInfo will be removed when this is rebased on #8290", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421391324", "createdAt": "2020-05-07T10:08:17Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/marshall/persistence/impl/PersistenceContextInitializer.java", "diffHunk": "@@ -40,7 +43,12 @@\n             SimpleClusteredVersion.class,\n             MarshallableUserObject.class,\n             PrivateMetadata.class,\n-            InDoubtTxInfo.class\n+            InDoubtTxInfo.class,\n+            MarshallableUserObject.class,\n+            IracEntryVersion.class,\n+            IracEntryVersion.MapEntry.class,\n+            TopologyIracVersion.class,\n+            IracMetadata.class", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM5MTY3OA==", "bodyText": "protoFactory?", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421391678", "createdAt": "2020-05-07T10:08:51Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/metadata/impl/PrivateMetadata.java", "diffHunk": "@@ -52,34 +55,59 @@ public static Builder getBuilder(PrivateMetadata metadata) {\n     * It allows to do some logic before instantiate a new instance.\n     */\n    @ProtoFactory\n-   static PrivateMetadata protostreamFactory(/*add fields later*/) {\n-      return EMPTY;\n+   static PrivateMetadata protostreamFactory(IracMetadata iracMetadata) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM5MjQwMw==", "bodyText": "We can make this:\n@ProtoField(number = 1)\nfinal IracMetadata iracMetadata\nThat way the marshalling info is always at the top of the class and easier to read.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421392403", "createdAt": "2020-05-07T10:10:05Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/metadata/impl/PrivateMetadata.java", "diffHunk": "@@ -21,11 +22,13 @@\n    /**\n     * A cached empty {@link PrivateMetadata}.\n     */\n-   private static final PrivateMetadata EMPTY = new PrivateMetadata();\n+   private static final PrivateMetadata EMPTY = new PrivateMetadata(null);\n \n-   //The following fields will be added in later PRs:\n-   //IracVersion => used by IRAC (async xsite new algorithm)\n-   //SimpleClusteredVersion => used by Optimistic Transactions\n+   private final IracMetadata iracMetadata;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM5NTAwMg==", "bodyText": "Nitpick but how about instead of saying \"If a conflict happens\", we say \"If a conflict occurs\". The former doesn't sound correct to me.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421395002", "createdAt": "2020-05-07T10:14:38Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/xsite/BackupReceiver.java", "diffHunk": "@@ -17,10 +20,51 @@\n  */\n public interface BackupReceiver {\n \n-   Cache getCache();\n+   Cache<?, ?> getCache();\n \n    CompletionStage<Void> handleRemoteCommand(VisitableCommand command, boolean preserveOrder);\n \n+   /**\n+    * Updates the key with the value from a remote site.\n+    * <p>\n+    * If a conflict happens, the update can be discarded.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM5NzMwMQ==", "bodyText": "Currently these methods are only ever used by interceptors that extend AbstractIracLocalSiteInterceptor. Does it make more sense for these to be simply be defined in AbstractIracLocalSiteInterceptor and AbstractIracRemoteSiteInterceptor? Or do you envisage these methods being required elsewhere longer term.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421397301", "createdAt": "2020-05-07T10:18:48Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/xsite/irac/IracUtils.java", "diffHunk": "@@ -0,0 +1,102 @@\n+package org.infinispan.xsite.irac;\n+\n+import static org.infinispan.metadata.impl.PrivateMetadata.getBuilder;\n+\n+import org.infinispan.commands.write.DataWriteCommand;\n+import org.infinispan.commands.write.WriteCommand;\n+import org.infinispan.container.entries.CacheEntry;\n+import org.infinispan.container.versioning.irac.IracVersionGenerator;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.util.logging.Log;\n+\n+/**\n+ * Utility methods related to IRAC (async Cross-Site Replication)\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+public final class IracUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM5OTAyNg==", "bodyText": "Unnecessary whitespace.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421399026", "createdAt": "2020-05-07T10:21:55Z", "author": {"login": "ryanemerson"}, "path": "core/src/test/java/org/infinispan/xsite/irac/persistence/BaseIracPersistenceTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package org.infinispan.xsite.irac.persistence;\n+\n+import java.io.File;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.infinispan.commons.test.CommonsTestingUtil;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.container.versioning.irac.IracEntryVersion;\n+import org.infinispan.container.versioning.irac.TopologyIracVersion;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.persistence.spi.AdvancedLoadWriteStore;\n+import org.infinispan.persistence.spi.MarshallableEntry;\n+import org.infinispan.persistence.spi.MarshallableEntryFactory;\n+import org.infinispan.protostream.SerializationContextInitializer;\n+import org.infinispan.test.SingleCacheManagerTest;\n+import org.infinispan.test.TestDataSCI;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.test.fwk.TestCacheManagerFactory;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import net.jcip.annotations.GuardedBy;\n+\n+/**\n+ * An abstract IRAC test to make sure the {@link IracMetadata} is properly stored and retrieved from persistence.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\")\n+public abstract class BaseIracPersistenceTest<V> extends SingleCacheManagerTest {\n+\n+   private static final AtomicLong V_GENERATOR = new AtomicLong();\n+   private static final String SITE = \"LON\";\n+   protected String tmpDirectory;\n+   protected AdvancedLoadWriteStore<String, V> cacheStore;\n+   protected MarshallableEntryFactory<String, V> entryFactory;\n+\n+   public void testWriteAndLoad(Method method) {\n+      String key = TestingUtil.k(method);\n+      String value = TestingUtil.v(method);\n+      IracMetadata metadata = createMetadata();\n+\n+      cacheStore.write(createEntry(key, value, metadata));\n+\n+      MarshallableEntry<String, V> loadedMEntry = cacheStore.loadEntry(key);\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM5OTUxMA==", "bodyText": "Can we have the configuration methods above the tests. It makes it easier to read the test configuration etc.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421399510", "createdAt": "2020-05-07T10:22:53Z", "author": {"login": "ryanemerson"}, "path": "core/src/test/java/org/infinispan/xsite/irac/persistence/BaseIracPersistenceTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package org.infinispan.xsite.irac.persistence;\n+\n+import java.io.File;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.infinispan.commons.test.CommonsTestingUtil;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.container.versioning.irac.IracEntryVersion;\n+import org.infinispan.container.versioning.irac.TopologyIracVersion;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.persistence.spi.AdvancedLoadWriteStore;\n+import org.infinispan.persistence.spi.MarshallableEntry;\n+import org.infinispan.persistence.spi.MarshallableEntryFactory;\n+import org.infinispan.protostream.SerializationContextInitializer;\n+import org.infinispan.test.SingleCacheManagerTest;\n+import org.infinispan.test.TestDataSCI;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.test.fwk.TestCacheManagerFactory;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import net.jcip.annotations.GuardedBy;\n+\n+/**\n+ * An abstract IRAC test to make sure the {@link IracMetadata} is properly stored and retrieved from persistence.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\")\n+public abstract class BaseIracPersistenceTest<V> extends SingleCacheManagerTest {\n+\n+   private static final AtomicLong V_GENERATOR = new AtomicLong();\n+   private static final String SITE = \"LON\";\n+   protected String tmpDirectory;\n+   protected AdvancedLoadWriteStore<String, V> cacheStore;\n+   protected MarshallableEntryFactory<String, V> entryFactory;\n+\n+   public void testWriteAndLoad(Method method) {\n+      String key = TestingUtil.k(method);\n+      String value = TestingUtil.v(method);\n+      IracMetadata metadata = createMetadata();\n+\n+      cacheStore.write(createEntry(key, value, metadata));\n+\n+      MarshallableEntry<String, V> loadedMEntry = cacheStore.loadEntry(key);\n+\n+\n+      assertCorrectEntry(loadedMEntry, key, value, metadata);\n+   }\n+\n+   public void testWriteAndPublisher(Method method) {\n+      String key = TestingUtil.k(method);\n+      String value = TestingUtil.v(method);\n+      IracMetadata metadata = createMetadata();\n+\n+      cacheStore.write(createEntry(key, value, metadata));\n+\n+      MarshallableEntrySubscriber<V> subscriber = new MarshallableEntrySubscriber<>();\n+      cacheStore.entryPublisher(key::equals, true, true).subscribe(subscriber);\n+\n+\n+      List<MarshallableEntry<String, V>> entries = subscriber.cf.join();\n+\n+      AssertJUnit.assertEquals(1, entries.size());\n+      assertCorrectEntry(entries.get(0), key, value, metadata);\n+   }\n+\n+   @BeforeClass(alwaysRun = true)\n+   @Override\n+   protected void createBeforeClass() throws Exception {\n+      tmpDirectory = CommonsTestingUtil.tmpDirectory(this.getClass());\n+      Util.recursiveFileRemove(tmpDirectory);\n+      boolean created = new File(tmpDirectory).mkdirs();\n+      log.debugf(\"Created temporary directory %s (exists? %s)\", tmpDirectory, !created);\n+      super.createBeforeClass();\n+   }\n+\n+   @AfterClass(alwaysRun = true)\n+   @Override\n+   protected void destroyAfterClass() {\n+      super.destroyAfterClass();\n+      Util.recursiveFileRemove(tmpDirectory);\n+   }\n+\n+   @Override\n+   protected EmbeddedCacheManager createCacheManager() throws Exception {\n+      GlobalConfigurationBuilder gBuilder = createGlobalConfigurationBuilder();\n+      ConfigurationBuilder cBuilder = new ConfigurationBuilder();\n+      addPersistence(cBuilder);\n+      EmbeddedCacheManager cm = TestCacheManagerFactory.createCacheManager(gBuilder, cBuilder);\n+      cacheStore = TestingUtil.getFirstLoader(cm.getCache());\n+      //noinspection unchecked\n+      entryFactory = TestingUtil.extractComponent(cm.getCache(), MarshallableEntryFactory.class);\n+      return cm;\n+   }\n+\n+   protected SerializationContextInitializer getSerializationContextInitializer() {\n+      return TestDataSCI.INSTANCE;\n+   }\n+\n+   protected abstract void addPersistence(ConfigurationBuilder builder);\n+\n+   protected abstract V wrap(String key, String value);\n+\n+   protected abstract String unwrap(V value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwMDI4NQ==", "bodyText": "The wrap and unwrap implementations always return the value except in the case of the IracJpaStoreTest. We should create a default impl of:\n   @Override\n   protected String wrap(String key, String value) {\n      return value;\n   }\n\n   @Override\n   protected String unwrap(String value) {\n      return value;\n   }\nand override it in IracJpaStoreTest.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421400285", "createdAt": "2020-05-07T10:24:16Z", "author": {"login": "ryanemerson"}, "path": "core/src/test/java/org/infinispan/xsite/irac/persistence/BaseIracPersistenceTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package org.infinispan.xsite.irac.persistence;\n+\n+import java.io.File;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.infinispan.commons.test.CommonsTestingUtil;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.container.versioning.irac.IracEntryVersion;\n+import org.infinispan.container.versioning.irac.TopologyIracVersion;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.persistence.spi.AdvancedLoadWriteStore;\n+import org.infinispan.persistence.spi.MarshallableEntry;\n+import org.infinispan.persistence.spi.MarshallableEntryFactory;\n+import org.infinispan.protostream.SerializationContextInitializer;\n+import org.infinispan.test.SingleCacheManagerTest;\n+import org.infinispan.test.TestDataSCI;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.test.fwk.TestCacheManagerFactory;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import net.jcip.annotations.GuardedBy;\n+\n+/**\n+ * An abstract IRAC test to make sure the {@link IracMetadata} is properly stored and retrieved from persistence.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\")\n+public abstract class BaseIracPersistenceTest<V> extends SingleCacheManagerTest {\n+\n+   private static final AtomicLong V_GENERATOR = new AtomicLong();\n+   private static final String SITE = \"LON\";\n+   protected String tmpDirectory;\n+   protected AdvancedLoadWriteStore<String, V> cacheStore;\n+   protected MarshallableEntryFactory<String, V> entryFactory;\n+\n+   public void testWriteAndLoad(Method method) {\n+      String key = TestingUtil.k(method);\n+      String value = TestingUtil.v(method);\n+      IracMetadata metadata = createMetadata();\n+\n+      cacheStore.write(createEntry(key, value, metadata));\n+\n+      MarshallableEntry<String, V> loadedMEntry = cacheStore.loadEntry(key);\n+\n+\n+      assertCorrectEntry(loadedMEntry, key, value, metadata);\n+   }\n+\n+   public void testWriteAndPublisher(Method method) {\n+      String key = TestingUtil.k(method);\n+      String value = TestingUtil.v(method);\n+      IracMetadata metadata = createMetadata();\n+\n+      cacheStore.write(createEntry(key, value, metadata));\n+\n+      MarshallableEntrySubscriber<V> subscriber = new MarshallableEntrySubscriber<>();\n+      cacheStore.entryPublisher(key::equals, true, true).subscribe(subscriber);\n+\n+\n+      List<MarshallableEntry<String, V>> entries = subscriber.cf.join();\n+\n+      AssertJUnit.assertEquals(1, entries.size());\n+      assertCorrectEntry(entries.get(0), key, value, metadata);\n+   }\n+\n+   @BeforeClass(alwaysRun = true)\n+   @Override\n+   protected void createBeforeClass() throws Exception {\n+      tmpDirectory = CommonsTestingUtil.tmpDirectory(this.getClass());\n+      Util.recursiveFileRemove(tmpDirectory);\n+      boolean created = new File(tmpDirectory).mkdirs();\n+      log.debugf(\"Created temporary directory %s (exists? %s)\", tmpDirectory, !created);\n+      super.createBeforeClass();\n+   }\n+\n+   @AfterClass(alwaysRun = true)\n+   @Override\n+   protected void destroyAfterClass() {\n+      super.destroyAfterClass();\n+      Util.recursiveFileRemove(tmpDirectory);\n+   }\n+\n+   @Override\n+   protected EmbeddedCacheManager createCacheManager() throws Exception {\n+      GlobalConfigurationBuilder gBuilder = createGlobalConfigurationBuilder();\n+      ConfigurationBuilder cBuilder = new ConfigurationBuilder();\n+      addPersistence(cBuilder);\n+      EmbeddedCacheManager cm = TestCacheManagerFactory.createCacheManager(gBuilder, cBuilder);\n+      cacheStore = TestingUtil.getFirstLoader(cm.getCache());\n+      //noinspection unchecked\n+      entryFactory = TestingUtil.extractComponent(cm.getCache(), MarshallableEntryFactory.class);\n+      return cm;\n+   }\n+\n+   protected SerializationContextInitializer getSerializationContextInitializer() {\n+      return TestDataSCI.INSTANCE;\n+   }\n+\n+   protected abstract void addPersistence(ConfigurationBuilder builder);\n+\n+   protected abstract V wrap(String key, String value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQwMDg2Mw==", "bodyText": "How about just configure as we're passing the ConfigurationBuilder so it's possible for implementations to configure any component as required.", "url": "https://github.com/infinispan/infinispan/pull/8244#discussion_r421400863", "createdAt": "2020-05-07T10:25:17Z", "author": {"login": "ryanemerson"}, "path": "core/src/test/java/org/infinispan/xsite/irac/persistence/BaseIracPersistenceTest.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package org.infinispan.xsite.irac.persistence;\n+\n+import java.io.File;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.infinispan.commons.test.CommonsTestingUtil;\n+import org.infinispan.commons.util.Util;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.container.versioning.irac.IracEntryVersion;\n+import org.infinispan.container.versioning.irac.TopologyIracVersion;\n+import org.infinispan.manager.EmbeddedCacheManager;\n+import org.infinispan.metadata.impl.IracMetadata;\n+import org.infinispan.metadata.impl.PrivateMetadata;\n+import org.infinispan.persistence.spi.AdvancedLoadWriteStore;\n+import org.infinispan.persistence.spi.MarshallableEntry;\n+import org.infinispan.persistence.spi.MarshallableEntryFactory;\n+import org.infinispan.protostream.SerializationContextInitializer;\n+import org.infinispan.test.SingleCacheManagerTest;\n+import org.infinispan.test.TestDataSCI;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.test.fwk.TestCacheManagerFactory;\n+import org.reactivestreams.Subscriber;\n+import org.reactivestreams.Subscription;\n+import org.testng.AssertJUnit;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+import net.jcip.annotations.GuardedBy;\n+\n+/**\n+ * An abstract IRAC test to make sure the {@link IracMetadata} is properly stored and retrieved from persistence.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 11.0\n+ */\n+@Test(groups = \"functional\")\n+public abstract class BaseIracPersistenceTest<V> extends SingleCacheManagerTest {\n+\n+   private static final AtomicLong V_GENERATOR = new AtomicLong();\n+   private static final String SITE = \"LON\";\n+   protected String tmpDirectory;\n+   protected AdvancedLoadWriteStore<String, V> cacheStore;\n+   protected MarshallableEntryFactory<String, V> entryFactory;\n+\n+   public void testWriteAndLoad(Method method) {\n+      String key = TestingUtil.k(method);\n+      String value = TestingUtil.v(method);\n+      IracMetadata metadata = createMetadata();\n+\n+      cacheStore.write(createEntry(key, value, metadata));\n+\n+      MarshallableEntry<String, V> loadedMEntry = cacheStore.loadEntry(key);\n+\n+\n+      assertCorrectEntry(loadedMEntry, key, value, metadata);\n+   }\n+\n+   public void testWriteAndPublisher(Method method) {\n+      String key = TestingUtil.k(method);\n+      String value = TestingUtil.v(method);\n+      IracMetadata metadata = createMetadata();\n+\n+      cacheStore.write(createEntry(key, value, metadata));\n+\n+      MarshallableEntrySubscriber<V> subscriber = new MarshallableEntrySubscriber<>();\n+      cacheStore.entryPublisher(key::equals, true, true).subscribe(subscriber);\n+\n+\n+      List<MarshallableEntry<String, V>> entries = subscriber.cf.join();\n+\n+      AssertJUnit.assertEquals(1, entries.size());\n+      assertCorrectEntry(entries.get(0), key, value, metadata);\n+   }\n+\n+   @BeforeClass(alwaysRun = true)\n+   @Override\n+   protected void createBeforeClass() throws Exception {\n+      tmpDirectory = CommonsTestingUtil.tmpDirectory(this.getClass());\n+      Util.recursiveFileRemove(tmpDirectory);\n+      boolean created = new File(tmpDirectory).mkdirs();\n+      log.debugf(\"Created temporary directory %s (exists? %s)\", tmpDirectory, !created);\n+      super.createBeforeClass();\n+   }\n+\n+   @AfterClass(alwaysRun = true)\n+   @Override\n+   protected void destroyAfterClass() {\n+      super.destroyAfterClass();\n+      Util.recursiveFileRemove(tmpDirectory);\n+   }\n+\n+   @Override\n+   protected EmbeddedCacheManager createCacheManager() throws Exception {\n+      GlobalConfigurationBuilder gBuilder = createGlobalConfigurationBuilder();\n+      ConfigurationBuilder cBuilder = new ConfigurationBuilder();\n+      addPersistence(cBuilder);\n+      EmbeddedCacheManager cm = TestCacheManagerFactory.createCacheManager(gBuilder, cBuilder);\n+      cacheStore = TestingUtil.getFirstLoader(cm.getCache());\n+      //noinspection unchecked\n+      entryFactory = TestingUtil.extractComponent(cm.getCache(), MarshallableEntryFactory.class);\n+      return cm;\n+   }\n+\n+   protected SerializationContextInitializer getSerializationContextInitializer() {\n+      return TestDataSCI.INSTANCE;\n+   }\n+\n+   protected abstract void addPersistence(ConfigurationBuilder builder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b"}, "originalPosition": 115}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ce72693c71cd532417650c3872ab043f18d9054b", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/ce72693c71cd532417650c3872ab043f18d9054b", "committedDate": "2020-05-07T09:09:17Z", "message": "Update core/src/main/java/org/infinispan/xsite/irac/IracManager.java\n\nCo-authored-by: William Burns <william.a.burns@gmail.com>"}, "afterCommit": {"oid": "426bf108012a10509267e61c93ea9efab2e043b4", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/426bf108012a10509267e61c93ea9efab2e043b4", "committedDate": "2020-05-07T11:31:29Z", "message": "Will's comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "517b2e710a8eadfee2d33f82aa1e429b00018bd5", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/517b2e710a8eadfee2d33f82aa1e429b00018bd5", "committedDate": "2020-05-08T13:04:36Z", "message": "More comments"}, "afterCommit": {"oid": "359e384c64d4155dd93491eae0d0f7b181eade13", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/359e384c64d4155dd93491eae0d0f7b181eade13", "committedDate": "2020-05-11T08:57:44Z", "message": "More comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "359e384c64d4155dd93491eae0d0f7b181eade13", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/359e384c64d4155dd93491eae0d0f7b181eade13", "committedDate": "2020-05-11T08:57:44Z", "message": "More comments"}, "afterCommit": {"oid": "c78dc40d37ec28f467700f792736c15a9f33e2cd", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/c78dc40d37ec28f467700f792736c15a9f33e2cd", "committedDate": "2020-05-11T14:10:08Z", "message": "More comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c78dc40d37ec28f467700f792736c15a9f33e2cd", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/c78dc40d37ec28f467700f792736c15a9f33e2cd", "committedDate": "2020-05-11T14:10:08Z", "message": "More comments"}, "afterCommit": {"oid": "268dd9b5468467d3a812f301503a3ac364d3044e", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/268dd9b5468467d3a812f301503a3ac364d3044e", "committedDate": "2020-05-11T15:19:38Z", "message": "ISPN-2634 Implement cross-site replication based on IRAC"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f95d303c38f27dfcedc92c1958667c91f13718a0", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/f95d303c38f27dfcedc92c1958667c91f13718a0", "committedDate": "2020-05-11T18:08:35Z", "message": "ISPN-2634 Implement cross-site replication based on IRAC"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "268dd9b5468467d3a812f301503a3ac364d3044e", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/268dd9b5468467d3a812f301503a3ac364d3044e", "committedDate": "2020-05-11T15:19:38Z", "message": "ISPN-2634 Implement cross-site replication based on IRAC"}, "afterCommit": {"oid": "f95d303c38f27dfcedc92c1958667c91f13718a0", "author": {"user": {"login": "pruivo", "name": "Pedro Ruivo"}}, "url": "https://github.com/infinispan/infinispan/commit/f95d303c38f27dfcedc92c1958667c91f13718a0", "committedDate": "2020-05-11T18:08:35Z", "message": "ISPN-2634 Implement cross-site replication based on IRAC"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 921, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}