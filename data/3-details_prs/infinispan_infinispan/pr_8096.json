{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzNjEyMzA5", "number": 8096, "title": "ISPN-10457 Convert bulk blocking stream operations to publisher", "bodyText": "https://issues.redhat.com/browse/ISPN-10457", "createdAt": "2020-03-25T14:13:29Z", "url": "https://github.com/infinispan/infinispan/pull/8096", "merged": true, "mergeCommit": {"oid": "caa5dd1f42339026bddf08f0b5e16bf379c5236a"}, "closed": true, "closedAt": "2020-04-08T09:28:50Z", "author": {"login": "wburns"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRMCJYABqjMxNjUyOTcwNjY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcV7ztJAFqTM4OTgwMjUyOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "df3b87bc5d946c252c39423298422a000532d870", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/df3b87bc5d946c252c39423298422a000532d870", "committedDate": "2020-03-25T14:13:10Z", "message": "ISPN-10457 Convert bulk blocking stream operations to publisher"}, "afterCommit": {"oid": "c9a896855ff67626c655a8e69d15272718d57cf6", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/c9a896855ff67626c655a8e69d15272718d57cf6", "committedDate": "2020-03-25T18:43:54Z", "message": "ISPN-10457 Convert bulk blocking stream operations to publisher"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c9a896855ff67626c655a8e69d15272718d57cf6", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/c9a896855ff67626c655a8e69d15272718d57cf6", "committedDate": "2020-03-25T18:43:54Z", "message": "ISPN-10457 Convert bulk blocking stream operations to publisher"}, "afterCommit": {"oid": "12ee76412a2e024a6312fb4a405d50fe87e1939e", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/12ee76412a2e024a6312fb4a405d50fe87e1939e", "committedDate": "2020-03-25T21:17:28Z", "message": "ISPN-11533 Convert ClientListenerRegistry to use non blocking calls"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "12ee76412a2e024a6312fb4a405d50fe87e1939e", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/12ee76412a2e024a6312fb4a405d50fe87e1939e", "committedDate": "2020-03-25T21:17:28Z", "message": "ISPN-11533 Convert ClientListenerRegistry to use non blocking calls"}, "afterCommit": {"oid": "880533e8ede9667ad4435de82ac59d39305c2c10", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/880533e8ede9667ad4435de82ac59d39305c2c10", "committedDate": "2020-03-25T21:22:17Z", "message": "ISPN-11533 Convert ClientListenerRegistry to use non blocking calls"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "880533e8ede9667ad4435de82ac59d39305c2c10", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/880533e8ede9667ad4435de82ac59d39305c2c10", "committedDate": "2020-03-25T21:22:17Z", "message": "ISPN-11533 Convert ClientListenerRegistry to use non blocking calls"}, "afterCommit": {"oid": "84ff3c9abc0bf8c5955061ca66c84c99e813f322", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/84ff3c9abc0bf8c5955061ca66c84c99e813f322", "committedDate": "2020-03-25T22:17:59Z", "message": "ISPN-11533 Convert ClientListenerRegistry to use non blocking calls"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "74147765c8185db6416c181aeac72deab698baa3", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/74147765c8185db6416c181aeac72deab698baa3", "committedDate": "2020-03-26T13:54:57Z", "message": "fixing media type conversions"}, "afterCommit": {"oid": "512f3dc8392095a3b890b07354e734a2ba228f34", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/512f3dc8392095a3b890b07354e734a2ba228f34", "committedDate": "2020-03-26T14:31:02Z", "message": "ISPN-11533 Convert ClientListenerRegistry to use non blocking calls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3826a12f399e0f190c801fd8210efc763237963b", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/3826a12f399e0f190c801fd8210efc763237963b", "committedDate": "2020-04-06T13:16:07Z", "message": "ISPN-10457 Convert bulk blocking stream operations to publisher"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "84ba727899b552c8e6c45c036ae8b73c533d1a19", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/84ba727899b552c8e6c45c036ae8b73c533d1a19", "committedDate": "2020-04-06T13:16:07Z", "message": "ISPN-11533 Convert ClientListenerRegistry to use non blocking calls"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "512f3dc8392095a3b890b07354e734a2ba228f34", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/512f3dc8392095a3b890b07354e734a2ba228f34", "committedDate": "2020-03-26T14:31:02Z", "message": "ISPN-11533 Convert ClientListenerRegistry to use non blocking calls"}, "afterCommit": {"oid": "84ba727899b552c8e6c45c036ae8b73c533d1a19", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/84ba727899b552c8e6c45c036ae8b73c533d1a19", "committedDate": "2020-04-06T13:16:07Z", "message": "ISPN-11533 Convert ClientListenerRegistry to use non blocking calls"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5ODAyNTI4", "url": "https://github.com/infinispan/infinispan/pull/8096#pullrequestreview-389802528", "createdAt": "2020-04-08T09:26:19Z", "commit": {"oid": "84ba727899b552c8e6c45c036ae8b73c533d1a19"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwOToyNjoxOVrOGCmvJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMjozOTowNFrOGDW5vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM4NDk5OA==", "bodyText": "I suggest nullableToStream, I find the repetition of flatMap in the call sites a bit confusing.", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r405384998", "createdAt": "2020-04-08T09:26:19Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/filter/CacheFilters.java", "diffHunk": "@@ -80,13 +80,17 @@ private CacheFilters() { }\n    public static <K, V, C> Stream<CacheEntry<K, C>> filterAndConvert(Stream<CacheEntry<K, V>> stream,\n            KeyValueFilterConverter<? super K, ? super V, C> filterConverter) {\n       // Have to use flatMap instead of map/filter as reactive streams spec doesn't allow null values\n-      return stream.flatMap(new FilterConverterAsCacheEntryFunction(filterConverter));\n+      return stream.flatMap(flatMap(filterConverter));\n    }\n \n    public static <K, V, C> CacheStream<CacheEntry<K, C>> filterAndConvert(CacheStream<CacheEntry<K, V>> stream,\n             KeyValueFilterConverter<? super K, ? super V, C> filterConverter) {\n       // Have to use flatMap instead of map/filter as reactive streams spec doesn't allow null values\n-      return stream.flatMap(new FilterConverterAsCacheEntryFunction(filterConverter));\n+      return stream.flatMap(flatMap(filterConverter));\n+   }\n+\n+   public static <K, V, C> Function<CacheEntry<K, V>, Stream<CacheEntry<K, C>>> flatMap(KeyValueFilterConverter<? super K, ? super V, C> filterConverter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84ba727899b552c8e6c45c036ae8b73c533d1a19"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzMTY2Nw==", "bodyText": "IMO there's no need to avoid the allocation here, because it happens at most once per segment.", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406031667", "createdAt": "2020-04-09T08:12:43Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/notifications/cachelistener/DistributedQueueingSegmentListener.java", "diffHunk": "@@ -137,8 +115,34 @@ public boolean handleEvent(EventWrapper<K, V, CacheEntryEvent<K, V>> wrapped, Li\n    }\n \n    @Override\n-   public void accept(Supplier<PrimitiveIterator.OfInt> segments) {\n-      justCompletedSegments = segments.get();\n+   public void accept(int segment) {\n+      if (justCompletedSegments == null) {\n+         justCompletedSegments = IntSets.mutableEmptySet();\n+      }\n+      justCompletedSegments.set(segment);\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> delayProcessing() {\n+      AggregateCompletionStage<Void> aggregateCompletionStage = null;\n+      if (justCompletedSegments != null) {\n+         if (trace) {\n+            log.tracef(\"Segments %s completed for listener\", justCompletedSegments);\n+         }\n+         // This relies on the fact that notifiedKey is immediately called after the entry has finished being iterated on\n+         PrimitiveIterator.OfInt iter = justCompletedSegments.iterator();\n+         while (iter.hasNext()) {\n+            CompletionStage<Void> segmentStage = completeSegment(iter.nextInt());\n+            if (segmentStage != null) {\n+               if (aggregateCompletionStage == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84ba727899b552c8e6c45c036ae8b73c533d1a19"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzMzYwNA==", "bodyText": "This should never be necessary, only the main test thread should block on BEFORE_INVOCATION.", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406033604", "createdAt": "2020-04-09T08:15:59Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/notifications/cachelistener/CacheNotifierImplInitialTransferDistTest.java", "diffHunk": "@@ -295,15 +278,10 @@ private void testModificationAfterIterationBeganAndCompletedSegmentValueOwner(fi\n \n       CheckPoint checkPoint = new CheckPoint();\n \n-      AsyncInterceptorChain chain = mockEntrySet(cache, (mock, real, additional) -> {\n-         doAnswer(i -> {\n-            // Wait for main thread to sync up\n-            checkPoint.trigger(\"pre_close_iter_invoked\");\n-            // Now wait until main thread lets us through\n-            checkPoint.awaitStrict(\"pre_close_iter_released\", 10, TimeUnit.SECONDS);\n-            return invokeAndReturnMock(i, real);\n-         }).when(mock).close();\n-      });\n+      registerBlockingPublisher(checkPoint, cache);\n+\n+      checkPoint.triggerForever(Mocks.BEFORE_INVOCATION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84ba727899b552c8e6c45c036ae8b73c533d1a19"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzNDI1Ng==", "bodyText": "Same here, because that's how the Mocks methods all create mocks that trigger BEFORE/AFTER_INVOCATION and block on BEFORE/AFTER_RELEASE.", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406034256", "createdAt": "2020-04-09T08:17:07Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/notifications/cachelistener/CacheNotifierImplInitialTransferDistTest.java", "diffHunk": "@@ -485,23 +462,24 @@ protected void testIterationBeganAndSegmentNotComplete(final StateListener<Strin\n       }\n \n       CheckPoint checkPoint = new CheckPoint();\n+      checkPoint.triggerForever(Mocks.AFTER_RELEASE);\n+      checkPoint.triggerForever(Mocks.AFTER_INVOCATION);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84ba727899b552c8e6c45c036ae8b73c533d1a19"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzNjQzOQ==", "bodyText": "Surefire won't run this test because it doesn't end in Test\nAlso, what exactly is non-blocking about this test compared to other cluster listener tests?", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406036439", "createdAt": "2020-04-09T08:20:59Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/notifications/cachelistener/cluster/NonBlockingClusterListener.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package org.infinispan.notifications.cachelistener.cluster;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.factories.KnownComponentNames;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.testng.annotations.Test;\n+\n+@Test(groups = \"functional\", testName = \"notifications.cachelistener.NonBlockingClusterListener\")\n+public class NonBlockingClusterListener extends AbstractClusterListenerUtilTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84ba727899b552c8e6c45c036ae8b73c533d1a19"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3MjQ2OQ==", "bodyText": "This also works and avoids all the unchecked warnings:\n         Queue<IntermediateOperation<?, ?, ?, ?>> intermediateOperations = new ArrayDeque<>();\n\n         if (keyDataConversion != DataConversion.IDENTITY_KEY && valueDataConversion != DataConversion.IDENTITY_VALUE) {\n            intermediateOperations.add(new MapOperation<>(EncoderEntryMapper.newCacheEntryMapper(\n                  keyDataConversion, valueDataConversion, entryFactory)));\n         }\n\n         if (filter instanceof CacheEventFilterConverter && (filter == converter || converter == null)) {\n            intermediateOperations.add(new FlatMapOperation<>(CacheFilters.flatMap(\n                  new CacheEventFilterConverterAsKeyValueFilterConverter<>((CacheEventFilterConverter<?, ?, ?>) filter))));\n         } else {\n            if (filter != null) {\n               intermediateOperations.add(new FilterOperation<>(CacheFilters.predicate(\n                     new CacheEventFilterAsKeyValueFilter<>(filter))));\n            }\n            if (converter != null) {\n               intermediateOperations.add(new MapOperation<>(CacheFilters.function(\n                     new CacheEventConverterAsConverter<>(converter))));\n            }\n         }", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406172469", "createdAt": "2020-04-09T12:35:57Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/notifications/cachelistener/CacheNotifierImpl.java", "diffHunk": "@@ -1070,51 +1085,89 @@ public void addListener(Object listener, KeyFilter<? super K> filter, ClassLoade\n       }\n \n       // If we have a segment listener handler, it means we have to do initial state\n-      QueueingSegmentListener handler = segmentHandler.remove(generatedId);\n+      QueueingSegmentListener<K, V, ? extends Event<K, V>> handler = segmentHandler.remove(generatedId);\n       if (handler != null) {\n          if (trace) {\n             log.tracef(\"Listener %s requests initial state for cache\", generatedId);\n          }\n-         CacheStream entryStream = cache.wired().withEncoding(keyConversion.getEncoderClass(), valueConversion.getEncoderClass()).cacheEntrySet().stream();\n-         Stream<CacheEntry<K, V>> usedStream = entryStream.segmentCompletionListener(handler);\n+         Queue<IntermediateOperation> intermediateOperations = new ArrayDeque<>();\n+\n+         if (keyDataConversion != DataConversion.IDENTITY_KEY && valueDataConversion != DataConversion.IDENTITY_VALUE) {\n+            intermediateOperations.add(new MapOperation(EncoderEntryMapper.newCacheEntryMapper(\n+                  keyDataConversion, valueDataConversion, entryFactory)));\n+         }\n \n          if (filter instanceof CacheEventFilterConverter && (filter == converter || converter == null)) {\n             // Hacky cast to prevent other casts\n-            usedStream = CacheFilters.filterAndConvert(usedStream,\n-                  new CacheEventFilterConverterAsKeyValueFilterConverter<>((CacheEventFilterConverter<K, V, V>) filter));\n+            intermediateOperations.add(new FlatMapOperation(CacheFilters.flatMap(\n+                  new CacheEventFilterConverterAsKeyValueFilterConverter<>((CacheEventFilterConverter) filter))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84ba727899b552c8e6c45c036ae8b73c533d1a19"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NDE0MQ==", "bodyText": "Queue suggests that items are being removed from the front, but AFAICT it's only iterated, so I'd replace it with a List.", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406174141", "createdAt": "2020-04-09T12:39:04Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/notifications/cachelistener/CacheNotifierImpl.java", "diffHunk": "@@ -1070,51 +1085,89 @@ public void addListener(Object listener, KeyFilter<? super K> filter, ClassLoade\n       }\n \n       // If we have a segment listener handler, it means we have to do initial state\n-      QueueingSegmentListener handler = segmentHandler.remove(generatedId);\n+      QueueingSegmentListener<K, V, ? extends Event<K, V>> handler = segmentHandler.remove(generatedId);\n       if (handler != null) {\n          if (trace) {\n             log.tracef(\"Listener %s requests initial state for cache\", generatedId);\n          }\n-         CacheStream entryStream = cache.wired().withEncoding(keyConversion.getEncoderClass(), valueConversion.getEncoderClass()).cacheEntrySet().stream();\n-         Stream<CacheEntry<K, V>> usedStream = entryStream.segmentCompletionListener(handler);\n+         Queue<IntermediateOperation> intermediateOperations = new ArrayDeque<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84ba727899b552c8e6c45c036ae8b73c533d1a19"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 978, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}