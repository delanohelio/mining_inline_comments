{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3MjQwMjc1", "number": 7922, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNToxNTo0OVrODhkHKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDozOTo0NFrODippEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTIxMjU3OnYy", "diffSide": "LEFT", "path": "core/src/main/java/org/infinispan/distribution/group/impl/PartitionerConsistentHash.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNToxNTo0OVrOFsXW4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNToxNTo0OVrOFsXW4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA2NDM1NA==", "bodyText": "We should be able to remove PartitionerConsistentHash altogether.", "url": "https://github.com/infinispan/infinispan/pull/7922#discussion_r382064354", "createdAt": "2020-02-20T15:15:49Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/distribution/group/impl/PartitionerConsistentHash.java", "diffHunk": "@@ -41,11 +41,6 @@ public int getNumOwners() {\n       return ch.getMembers();\n    }\n \n-   @Override\n-   public int getSegment(Object key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34d35759aec27249e61b7b8cd526eee2d5b7d926"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTIyMjk4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/interceptors/distribution/NonTxDistributionInterceptor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNToxODowOVrOFsXdSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNToxODowOVrOFsXdSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA2NTk5Mw==", "bodyText": "Could use LocalizedCacheTopology#getLocalReadSegments", "url": "https://github.com/infinispan/infinispan/pull/7922#discussion_r382065993", "createdAt": "2020-02-20T15:18:09Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/interceptors/distribution/NonTxDistributionInterceptor.java", "diffHunk": "@@ -483,29 +483,30 @@ public Object visitWriteOnlyKeyCommand(InvocationContext ctx, WriteOnlyKeyComman\n    }\n \n    private <C extends WriteCommand> Object writeManyRemoteCallback(WriteManyCommandHelper<C , ?, ?> helper,InvocationContext ctx, C command, Object rv) {\n-         ConsistentHash ch = checkTopologyId(command).getWriteConsistentHash();\n-         // We have already checked that the command topology is actual, so we can assume that we really are primary owner\n-         Map<Address, IntSet> backups = backupOwnersOfSegments(ch, IntSets.from(ch.getPrimarySegmentsForOwner(rpcManager.getAddress())));\n-         if (backups.isEmpty()) {\n-            return rv;\n-         }\n-         boolean isSync = isSynchronous(command);\n-         CompletableFuture[] futures = isSync ? new CompletableFuture[backups.size()] : null;\n-         int future = 0;\n-         for (Entry<Address, IntSet> backup : backups.entrySet()) {\n-            C copy = helper.copyForBackup(command, ch, backup.getValue());\n-            copy.setTopologyId(command.getTopologyId());\n-            Address backupOwner = backup.getKey();\n-            if (isSync) {\n-               futures[future++] = rpcManager\n-                     .invokeCommand(backupOwner, copy, SingleResponseCollector.validOnly(),\n-                                    rpcManager.getSyncRpcOptions())\n-                     .toCompletableFuture();\n-            } else {\n-               rpcManager.sendTo(backupOwner, copy, DeliverOrder.PER_SENDER);\n-            }\n+      LocalizedCacheTopology topology = checkTopologyId(command);\n+      ConsistentHash ch = topology.getWriteConsistentHash();\n+      // We have already checked that the command topology is actual, so we can assume that we really are primary owner\n+      Map<Address, IntSet> backups = backupOwnersOfSegments(ch, IntSets.from(ch.getPrimarySegmentsForOwner(rpcManager.getAddress())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34d35759aec27249e61b7b8cd526eee2d5b7d926"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTMyOTg2OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/infinispan/distribution/topologyaware/TopologyAwareConsistentHashFactoryTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNTo0Mjo1NVrOFsYgCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNTo0Mjo1NVrOFsYgCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA4MzA4MA==", "bodyText": "This is kind of outdated, the test should iterate over the segments and check the owners of each segment instead.", "url": "https://github.com/infinispan/infinispan/pull/7922#discussion_r382083080", "createdAt": "2020-02-20T15:42:55Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/distribution/topologyaware/TopologyAwareConsistentHashFactoryTest.java", "diffHunk": "@@ -62,45 +65,50 @@ public void testNumberOfOwners() {\n       addNode(testAddresses[0], \"m0\", null, null);\n \n       updateConsistentHash(1);\n-      assertEquals(ch.locateOwners(testAddresses[0]).size(), 1);\n+      assertNumberOwners(testAddresses[0], 1);\n       updateConsistentHash(2);\n-      assertEquals(ch.locateOwners(testAddresses[0]).size(), 1);\n+      assertNumberOwners(testAddresses[0], 1);\n \n       addNode(testAddresses[1], \"m1\", null, null);\n \n       updateConsistentHash(1);\n-      for (Address testAddress : testAddresses) {\n-         assertEquals(ch.locateOwners(testAddress).size(), 1);\n+      for (Address testAddress : ch.getMembers()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34d35759aec27249e61b7b8cd526eee2d5b7d926"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTMzNDY3OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/infinispan/partitionhandling/NumOwnersNodeCrashInSequenceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNTo0NDowMlrOFsYi-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNTo0NDowMlrOFsYi-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA4MzgzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  ConsistentHash ch = cache(a0).getAdvancedCache().getDistributionManager().getReadConsistentHash();\n          \n          \n            \n                  LocalizedCacheTopology cacheTopology = cache(a0).getAdvancedCache().getDistributionManager().getCacheTopology();", "url": "https://github.com/infinispan/infinispan/pull/7922#discussion_r382083835", "createdAt": "2020-02-20T15:44:02Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/partitionhandling/NumOwnersNodeCrashInSequenceTest.java", "diffHunk": "@@ -148,7 +148,7 @@ public boolean isSatisfied() throws Exception {\n       ConsistentHash ch = cache(a0).getAdvancedCache().getDistributionManager().getReadConsistentHash();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34d35759aec27249e61b7b8cd526eee2d5b7d926"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2NTM0ODYyOnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/infinispan/statetransfer/TestKey.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNTo0NzozMFrOFsYrvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNTo0NzozMFrOFsYrvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjA4NjA3OA==", "bodyText": "I think the parameter should be the KP, not the CH.", "url": "https://github.com/infinispan/infinispan/pull/7922#discussion_r382086078", "createdAt": "2020-02-20T15:47:30Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/statetransfer/TestKey.java", "diffHunk": "@@ -32,10 +34,11 @@ public TestKey(String name, int segmentId, ConsistentHash ch) {\n       this.name = name;\n \n       Random rnd = new Random();\n+      KeyPartitioner keyPartitioner = new HashFunctionPartitioner(ch.getNumSegments());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "34d35759aec27249e61b7b8cd526eee2d5b7d926"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjYwMzY4OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/infinispan/util/ControlledConsistentHashFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDozOTozMlrOFuBFhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDozOTozMlrOFuBFhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5NjYxNQ==", "bodyText": "Can stay on the same line", "url": "https://github.com/infinispan/infinispan/pull/7922#discussion_r383796615", "createdAt": "2020-02-25T10:39:32Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/util/ControlledConsistentHashFactory.java", "diffHunk": "@@ -124,7 +124,8 @@ public void setMembersToUse(List<Address> membersToUse) {\n    @SerializeWith(Externalizer.class)\n    public static class Default extends ControlledConsistentHashFactory<DefaultConsistentHash> {\n       public Default(int primaryOwnerIndex, int... backupOwnerIndexes) {\n-         super(new DefaultTrait(), primaryOwnerIndex, backupOwnerIndexes);\n+         super(new DefaultTrait(),\n+               primaryOwnerIndex, backupOwnerIndexes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea192f2f8a3ada45e40411e6ebe3ff38e7a38a02"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NjYwNDM0OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/infinispan/util/BaseControlledConsistentHashFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDozOTo0NFrOFuBF8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMDozOTo0NFrOFuBF8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzc5NjcyMg==", "bodyText": "No longer needed", "url": "https://github.com/infinispan/infinispan/pull/7922#discussion_r383796722", "createdAt": "2020-02-25T10:39:44Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/util/BaseControlledConsistentHashFactory.java", "diffHunk": "@@ -99,23 +98,32 @@ public CH union(CH ch1, CH ch2) {\n       return trait.union(ch1, ch2);\n    }\n \n-   protected abstract int[][] assignOwners(int numSegments, int numOwners, List<Address> members);\n+   protected abstract int[][] assignOwners(int numSegments, List<Address> members);\n \n    private void assertNumberOfSegments(int numSegments) {\n       assertEquals(\"Wrong number of segments.\", this.numSegments, numSegments);\n    }\n \n    protected interface Trait<CH extends ConsistentHash> {\n-      CH create(Hash hashFunction, int numOwners, int numSegments, List<Address> members, Map<Address, Float> capacityFactors, List<Address>[] segmentOwners, boolean rebalanced);\n+      CH create(int numOwners, int numSegments, List<Address> members, Map<Address, Float> capacityFactors,\n+                List<Address>[] segmentOwners, boolean rebalanced);\n       CH union(CH ch1, CH ch2);\n \n       boolean requiresPrimaryOwner();\n+\n+      int getNumOwners(CH ch);\n    }\n \n    public static class DefaultTrait implements Trait<DefaultConsistentHash> {\n+\n+      public DefaultTrait() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea192f2f8a3ada45e40411e6ebe3ff38e7a38a02"}, "originalPosition": 93}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4483, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}