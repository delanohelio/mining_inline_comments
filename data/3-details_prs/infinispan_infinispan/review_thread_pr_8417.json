{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2MzcwODEx", "number": 8417, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzo0ODo0MlrOEBwMSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDoxNzoxM1rOECLJkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjczNjA4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzo0ODo0MlrOGdye8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzo0ODo0MlrOGdye8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg4OTAwOA==", "bodyText": "No longer exists.", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r433889008", "createdAt": "2020-06-02T13:48:42Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -997,84 +1008,35 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n     * <p>\n     * The {@link HandleFlowables} is provided for the sole reason of allowing reuse of this method by different callers.\n     * @param ctx the transactional context with modifications", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76b48006e6a9ce53f8912bcf11fda4a5c3192144"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjczNzI3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzo0ODo1OFrOGdyfqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxMzo0ODo1OFrOGdyfqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg4OTE5NA==", "bodyText": "Javadoc for mvccEntryFlowable missing.", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r433889194", "createdAt": "2020-06-02T13:48:58Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -997,84 +1008,35 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n     * <p>\n     * The {@link HandleFlowables} is provided for the sole reason of allowing reuse of this method by different callers.\n     * @param ctx the transactional context with modifications\n-    * @param commandKeyPredicate predicate to test if a key/command combination should be written\n     * @param flowableHandler callback handler that actually should subscribe to the underlying store\n     * @param <K> key type\n     * @param <V> value type\n     * @return a stage that when complete will contain how many write operations were done\n     */\n-   private <K, V> CompletionStage<Long> batchOperation(TxInvocationContext<AbstractCacheTransaction> ctx,\n-         BiPredicate<WriteCommand, Object> commandKeyPredicate, HandleFlowables<K, V> flowableHandler) {\n+   private <K, V> CompletionStage<Long> batchOperation(Flowable<MVCCEntry<K, V>> mvccEntryFlowable, InvocationContext ctx,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76b48006e6a9ce53f8912bcf11fda4a5c3192144"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjgyMjgwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDowNToyMFrOGdzVrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTowMDowMVrOGd11bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwMzAyMA==", "bodyText": "Wiith the various if (segmented) and if (shared) branches, this is now very difficult to read. Can we divide this further so that we have a createWriteFlowable(Flowable<MarshallableEntry<K, V>> entryWriteFlowable, boolean shared, boolean segmented) and equivalent createRemoveFlowable methods, containing their respective trace logs.", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r433903020", "createdAt": "2020-06-02T14:05:20Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -997,84 +1008,35 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n     * <p>\n     * The {@link HandleFlowables} is provided for the sole reason of allowing reuse of this method by different callers.\n     * @param ctx the transactional context with modifications\n-    * @param commandKeyPredicate predicate to test if a key/command combination should be written\n     * @param flowableHandler callback handler that actually should subscribe to the underlying store\n     * @param <K> key type\n     * @param <V> value type\n     * @return a stage that when complete will contain how many write operations were done\n     */\n-   private <K, V> CompletionStage<Long> batchOperation(TxInvocationContext<AbstractCacheTransaction> ctx,\n-         BiPredicate<WriteCommand, Object> commandKeyPredicate, HandleFlowables<K, V> flowableHandler) {\n+   private <K, V> CompletionStage<Long> batchOperation(Flowable<MVCCEntry<K, V>> mvccEntryFlowable, InvocationContext ctx,\n+         HandleFlowables<K, V> flowableHandler) {\n       return Single.using(\n             this::acquireReadLock,\n             ignore -> {\n                checkStoreAvailability();\n                if (trace) {\n                   log.trace(\"Writing batch to stores\");\n                }\n-               int size = stores.size();\n-               if (size == 0) {\n-                  return Single.just(0L);\n-               }\n-\n-               Flowable<MVCCEntry<K, V>> mvccEntryFlowable = Flowable.fromIterable(ctx.getCacheTransaction().getAllModifications())\n-                     .filter(writeCommand -> !writeCommand.hasAnyFlag(FlagBitSets.SKIP_CACHE_STORE))\n-                     .concatMap(writeCommand -> {\n-                        if (writeCommand instanceof DataWriteCommand) {\n-                           Object key = ((DataWriteCommand) writeCommand).getKey();\n-                           MVCCEntry<K, V> entry = acquireKeyFromContext(ctx, writeCommand, key, commandKeyPredicate);\n-                           return entry != null ? Flowable.just(entry) : Flowable.empty();\n-                        } else {\n-                           // Assume multiple key command\n-                           return Flowable.fromIterable(writeCommand.getAffectedKeys())\n-                                 .concatMapMaybe(key -> {\n-                                    MVCCEntry<K, V> entry = acquireKeyFromContext(ctx, writeCommand, key, commandKeyPredicate);\n-                                    // We use an empty Flowable to symbolize a miss - which is filtered by ofType just below\n-                                    return entry != null ? Maybe.just(entry) : Maybe.empty();\n-                                 });\n-                        }\n-                     });\n-               // We split the original source into possibly multiple, depending upon how many stores there are\n-               ConnectableFlowable<MVCCEntry<K, V>> connectableFlowable = mvccEntryFlowable.publish();\n-\n-               // We may have multiple stores - don't publish anything until this value goes back to 0\n-               AtomicInteger pendingConnects = new AtomicInteger(size);\n-               if (trace) {\n-                  log.tracef(\"Will wait for %s subscriptions of stores\", size);\n-               }\n \n                return Flowable.fromIterable(stores)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76b48006e6a9ce53f8912bcf11fda4a5c3192144"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk0MzkxOA==", "bodyText": "Sure", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r433943918", "createdAt": "2020-06-02T15:00:01Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -997,84 +1008,35 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n     * <p>\n     * The {@link HandleFlowables} is provided for the sole reason of allowing reuse of this method by different callers.\n     * @param ctx the transactional context with modifications\n-    * @param commandKeyPredicate predicate to test if a key/command combination should be written\n     * @param flowableHandler callback handler that actually should subscribe to the underlying store\n     * @param <K> key type\n     * @param <V> value type\n     * @return a stage that when complete will contain how many write operations were done\n     */\n-   private <K, V> CompletionStage<Long> batchOperation(TxInvocationContext<AbstractCacheTransaction> ctx,\n-         BiPredicate<WriteCommand, Object> commandKeyPredicate, HandleFlowables<K, V> flowableHandler) {\n+   private <K, V> CompletionStage<Long> batchOperation(Flowable<MVCCEntry<K, V>> mvccEntryFlowable, InvocationContext ctx,\n+         HandleFlowables<K, V> flowableHandler) {\n       return Single.using(\n             this::acquireReadLock,\n             ignore -> {\n                checkStoreAvailability();\n                if (trace) {\n                   log.trace(\"Writing batch to stores\");\n                }\n-               int size = stores.size();\n-               if (size == 0) {\n-                  return Single.just(0L);\n-               }\n-\n-               Flowable<MVCCEntry<K, V>> mvccEntryFlowable = Flowable.fromIterable(ctx.getCacheTransaction().getAllModifications())\n-                     .filter(writeCommand -> !writeCommand.hasAnyFlag(FlagBitSets.SKIP_CACHE_STORE))\n-                     .concatMap(writeCommand -> {\n-                        if (writeCommand instanceof DataWriteCommand) {\n-                           Object key = ((DataWriteCommand) writeCommand).getKey();\n-                           MVCCEntry<K, V> entry = acquireKeyFromContext(ctx, writeCommand, key, commandKeyPredicate);\n-                           return entry != null ? Flowable.just(entry) : Flowable.empty();\n-                        } else {\n-                           // Assume multiple key command\n-                           return Flowable.fromIterable(writeCommand.getAffectedKeys())\n-                                 .concatMapMaybe(key -> {\n-                                    MVCCEntry<K, V> entry = acquireKeyFromContext(ctx, writeCommand, key, commandKeyPredicate);\n-                                    // We use an empty Flowable to symbolize a miss - which is filtered by ofType just below\n-                                    return entry != null ? Maybe.just(entry) : Maybe.empty();\n-                                 });\n-                        }\n-                     });\n-               // We split the original source into possibly multiple, depending upon how many stores there are\n-               ConnectableFlowable<MVCCEntry<K, V>> connectableFlowable = mvccEntryFlowable.publish();\n-\n-               // We may have multiple stores - don't publish anything until this value goes back to 0\n-               AtomicInteger pendingConnects = new AtomicInteger(size);\n-               if (trace) {\n-                  log.tracef(\"Will wait for %s subscriptions of stores\", size);\n-               }\n \n                return Flowable.fromIterable(stores)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwMzAyMA=="}, "originalCommit": {"oid": "76b48006e6a9ce53f8912bcf11fda4a5c3192144"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjg1Nzg2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDoxMjowOVrOGdzsHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTowMDozMVrOGd13DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwODc2NA==", "bodyText": "It's not from this PR, but can we break this into a CompletionStage<Void> var that is passed to fromCompletionStage. It is very difficult to read atm.", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r433908764", "createdAt": "2020-06-02T14:12:09Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1109,21 +1084,38 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n                               });\n \n                         AtomicLong writeCount = new AtomicLong();\n-                        entryWriteFlowable = entryWriteFlowable.doOnNext(me -> writeCount.incrementAndGet());\n \n                         Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable;\n \n                         if (segmented) {\n+                           // Note the writeCount includes entries that aren't written due to being shared\n+                           // at this point\n+                           entryWriteFlowable = entryWriteFlowable.doOnNext(obj -> writeCount.incrementAndGet());\n                            writeFlowable = entryWriteFlowable\n                                  .groupBy(me -> keyPartitioner.getSegment(me.getKey()))\n                                  .map(SegmentPublisherWrapper::wrap);\n+                           if (shared) {\n+                              // The writeCount will be decremented for each grouping of values ignored\n+                              writeFlowable = filterSharedSegments(writeFlowable, writeCount);\n+                           }\n                         } else {\n+                           if (shared) {\n+                              entryWriteFlowable = entryWriteFlowable.filter(me ->\n+                                    distributionManager.getCacheTopology().getDistribution(me.getKey()).isPrimary());\n+                           }\n+                           entryWriteFlowable = entryWriteFlowable.doOnNext(obj -> writeCount.incrementAndGet());\n                            writeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(entryWriteFlowable));\n                         }\n \n                         if (trace) {\n-                           removeFlowable = removeFlowable.doOnSubscribe(sub ->\n+                           writeFlowable = writeFlowable.doOnSubscribe(sub ->\n                               log.tracef(\"Store %s has subscribed to write batch\", storeStatus.store));\n+                           writeFlowable = writeFlowable.map(sp -> {\n+                              int segment = sp.getSegment();\n+                              return SingleSegmentPublisher.singleSegment(segment, Flowable.fromPublisher(sp)\n+                                    .doOnNext(me -> log.tracef(\"Emitting entry %s for write to segment %s\",\n+                                          me, segment)));\n+                           });\n                         }\n \n                         return Single.fromCompletionStage(flowableHandler.handleFlowables(storeStatus.store(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76b48006e6a9ce53f8912bcf11fda4a5c3192144"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk0NDMzMw==", "bodyText": "Okay.", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r433944333", "createdAt": "2020-06-02T15:00:31Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1109,21 +1084,38 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n                               });\n \n                         AtomicLong writeCount = new AtomicLong();\n-                        entryWriteFlowable = entryWriteFlowable.doOnNext(me -> writeCount.incrementAndGet());\n \n                         Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable;\n \n                         if (segmented) {\n+                           // Note the writeCount includes entries that aren't written due to being shared\n+                           // at this point\n+                           entryWriteFlowable = entryWriteFlowable.doOnNext(obj -> writeCount.incrementAndGet());\n                            writeFlowable = entryWriteFlowable\n                                  .groupBy(me -> keyPartitioner.getSegment(me.getKey()))\n                                  .map(SegmentPublisherWrapper::wrap);\n+                           if (shared) {\n+                              // The writeCount will be decremented for each grouping of values ignored\n+                              writeFlowable = filterSharedSegments(writeFlowable, writeCount);\n+                           }\n                         } else {\n+                           if (shared) {\n+                              entryWriteFlowable = entryWriteFlowable.filter(me ->\n+                                    distributionManager.getCacheTopology().getDistribution(me.getKey()).isPrimary());\n+                           }\n+                           entryWriteFlowable = entryWriteFlowable.doOnNext(obj -> writeCount.incrementAndGet());\n                            writeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(entryWriteFlowable));\n                         }\n \n                         if (trace) {\n-                           removeFlowable = removeFlowable.doOnSubscribe(sub ->\n+                           writeFlowable = writeFlowable.doOnSubscribe(sub ->\n                               log.tracef(\"Store %s has subscribed to write batch\", storeStatus.store));\n+                           writeFlowable = writeFlowable.map(sp -> {\n+                              int segment = sp.getSegment();\n+                              return SingleSegmentPublisher.singleSegment(segment, Flowable.fromPublisher(sp)\n+                                    .doOnNext(me -> log.tracef(\"Emitting entry %s for write to segment %s\",\n+                                          me, segment)));\n+                           });\n                         }\n \n                         return Single.fromCompletionStage(flowableHandler.handleFlowables(storeStatus.store(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwODc2NA=="}, "originalCommit": {"oid": "76b48006e6a9ce53f8912bcf11fda4a5c3192144"}, "originalPosition": 266}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMjg2Mjg3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDoxMzoxNVrOGdzvXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDoxMzoxNVrOGdzvXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwOTU5Ng==", "bodyText": "Is there a better way of doing this? I don't have an alternative suggestion but this smells funny.", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r433909596", "createdAt": "2020-06-02T14:13:15Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1136,9 +1128,59 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n       ).toCompletionStage();\n    }\n \n-   private <K, V> MVCCEntry<K, V> acquireKeyFromContext(InvocationContext ctx, WriteCommand command, Object key,\n-         BiPredicate<WriteCommand, Object> commandKeyPredicate) {\n-      if (commandKeyPredicate.test(command, key)) {\n+   private <I> Flowable<NonBlockingStore.SegmentedPublisher<I>> filterSharedSegments(\n+         Flowable<NonBlockingStore.SegmentedPublisher<I>> flowable, AtomicLong writeCount) {\n+      return flowable.filter(sp -> {\n+         if (distributionManager.getCacheTopology().getSegmentDistribution(sp.getSegment()).isPrimary()) {\n+            return true;\n+         }\n+         // Way to ensure the filtered groups are still subscribed and the values are not counted\n+         Flowable.fromPublisher(sp)\n+               .count()\n+               .subscribe(ignoredCount -> {\n+                  if (writeCount != null) {\n+                     writeCount.addAndGet(-ignoredCount);\n+                  }\n+               });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76b48006e6a9ce53f8912bcf11fda4a5c3192144"}, "originalPosition": 287}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzA5NDI0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDowNDoyOVrOGedbLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDowNDoyOVrOGedbLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5MjU1OQ==", "bodyText": "variable can just be flowable to reduce verbosity now that it's within the createRemoveFlowable method.", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r434592559", "createdAt": "2020-06-03T14:04:29Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1109,36 +1054,139 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n                               });\n \n                         AtomicLong writeCount = new AtomicLong();\n-                        entryWriteFlowable = entryWriteFlowable.doOnNext(me -> writeCount.incrementAndGet());\n-\n-                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable;\n \n-                        if (segmented) {\n-                           writeFlowable = entryWriteFlowable\n-                                 .groupBy(me -> keyPartitioner.getSegment(me.getKey()))\n-                                 .map(SegmentPublisherWrapper::wrap);\n-                        } else {\n-                           writeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(entryWriteFlowable));\n-                        }\n+                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable =\n+                              createWriteFlowable(entryWriteFlowable, shared, segmented, writeCount, storeStatus);\n \n-                        if (trace) {\n-                           removeFlowable = removeFlowable.doOnSubscribe(sub ->\n-                              log.tracef(\"Store %s has subscribed to write batch\", storeStatus.store));\n-                        }\n+                        CompletionStage<Void> storeBatchStage = flowableHandler.handleFlowables(storeStatus.store(),\n+                              segmentCount(segmented), removeFlowable, writeFlowable);\n \n-                        return Single.fromCompletionStage(flowableHandler.handleFlowables(storeStatus.store(),\n-                              segmentCount(segmented), removeFlowable, writeFlowable)\n-                              .thenApply(ignore2 -> writeCount.get()));\n-                     }).first(0L);\n+                        return Single.fromCompletionStage(storeBatchStage)\n+                              .map(ignore2 -> writeCount.get());\n+                        // Only take the last element for the count - ensures all stores are completed\n+                     }).last(0L);\n \n             },\n             this::releaseReadLock\n       ).toCompletionStage();\n    }\n \n-   private <K, V> MVCCEntry<K, V> acquireKeyFromContext(InvocationContext ctx, WriteCommand command, Object key,\n-         BiPredicate<WriteCommand, Object> commandKeyPredicate) {\n-      if (commandKeyPredicate.test(command, key)) {\n+   <K> Flowable<NonBlockingStore.SegmentedPublisher<K>> createRemoveFlowable(Flowable<K> keyRemoveFlowable,\n+         boolean shared, boolean segmented, StoreStatus storeStatus) {\n+      Flowable<NonBlockingStore.SegmentedPublisher<K>> removeFlowable;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f780e777290fdeb283e01591a59e6f294b0226e"}, "originalPosition": 288}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzA5OTg2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDowNTo0NFrOGede1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDowNTo0NFrOGede1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5MzQ5NQ==", "bodyText": "I didn't say this before, but let's pass the keyRemoveFlowable in this method and just pass flowableToUse from batchOperation. That way the logic is in a single method.", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r434593495", "createdAt": "2020-06-03T14:05:44Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1109,36 +1054,139 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n                               });\n \n                         AtomicLong writeCount = new AtomicLong();\n-                        entryWriteFlowable = entryWriteFlowable.doOnNext(me -> writeCount.incrementAndGet());\n-\n-                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable;\n \n-                        if (segmented) {\n-                           writeFlowable = entryWriteFlowable\n-                                 .groupBy(me -> keyPartitioner.getSegment(me.getKey()))\n-                                 .map(SegmentPublisherWrapper::wrap);\n-                        } else {\n-                           writeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(entryWriteFlowable));\n-                        }\n+                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable =\n+                              createWriteFlowable(entryWriteFlowable, shared, segmented, writeCount, storeStatus);\n \n-                        if (trace) {\n-                           removeFlowable = removeFlowable.doOnSubscribe(sub ->\n-                              log.tracef(\"Store %s has subscribed to write batch\", storeStatus.store));\n-                        }\n+                        CompletionStage<Void> storeBatchStage = flowableHandler.handleFlowables(storeStatus.store(),\n+                              segmentCount(segmented), removeFlowable, writeFlowable);\n \n-                        return Single.fromCompletionStage(flowableHandler.handleFlowables(storeStatus.store(),\n-                              segmentCount(segmented), removeFlowable, writeFlowable)\n-                              .thenApply(ignore2 -> writeCount.get()));\n-                     }).first(0L);\n+                        return Single.fromCompletionStage(storeBatchStage)\n+                              .map(ignore2 -> writeCount.get());\n+                        // Only take the last element for the count - ensures all stores are completed\n+                     }).last(0L);\n \n             },\n             this::releaseReadLock\n       ).toCompletionStage();\n    }\n \n-   private <K, V> MVCCEntry<K, V> acquireKeyFromContext(InvocationContext ctx, WriteCommand command, Object key,\n-         BiPredicate<WriteCommand, Object> commandKeyPredicate) {\n-      if (commandKeyPredicate.test(command, key)) {\n+   <K> Flowable<NonBlockingStore.SegmentedPublisher<K>> createRemoveFlowable(Flowable<K> keyRemoveFlowable,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f780e777290fdeb283e01591a59e6f294b0226e"}, "originalPosition": 286}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzEzMjU1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDoxMjo1MVrOGedz5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDoxMjo1MVrOGedz5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5ODg4NA==", "bodyText": "If we pass shared to the method, this will make the code easier to read IMO. e.g.:\n   private <I> Flowable<NonBlockingStore.SegmentedPublisher<I>> filterSharedSegments(\n         Flowable<NonBlockingStore.SegmentedPublisher<I>> flowable, boolean shared) {\n      if (!shared)\n         return flowable;\n\n      return flowable.map(sp -> {\n         DistributionInfo distribution = distributionManager.getCacheTopology().getSegmentDistribution(sp.getSegment());\n         if (distribution.isPrimary()) {\n            return sp;\n         }\n         // Unfortunately we need to still need to subscribe to the publisher even though we don't want\n         // the store to use its values. Thus we just return them an empty SegmentPublisher.\n         return SingleSegmentPublisher.singleSegment(sp.getSegment(), Flowable.fromPublisher(sp).take(0));\n      });\n   }", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r434598884", "createdAt": "2020-06-03T14:12:51Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1109,36 +1054,139 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n                               });\n \n                         AtomicLong writeCount = new AtomicLong();\n-                        entryWriteFlowable = entryWriteFlowable.doOnNext(me -> writeCount.incrementAndGet());\n-\n-                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable;\n \n-                        if (segmented) {\n-                           writeFlowable = entryWriteFlowable\n-                                 .groupBy(me -> keyPartitioner.getSegment(me.getKey()))\n-                                 .map(SegmentPublisherWrapper::wrap);\n-                        } else {\n-                           writeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(entryWriteFlowable));\n-                        }\n+                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable =\n+                              createWriteFlowable(entryWriteFlowable, shared, segmented, writeCount, storeStatus);\n \n-                        if (trace) {\n-                           removeFlowable = removeFlowable.doOnSubscribe(sub ->\n-                              log.tracef(\"Store %s has subscribed to write batch\", storeStatus.store));\n-                        }\n+                        CompletionStage<Void> storeBatchStage = flowableHandler.handleFlowables(storeStatus.store(),\n+                              segmentCount(segmented), removeFlowable, writeFlowable);\n \n-                        return Single.fromCompletionStage(flowableHandler.handleFlowables(storeStatus.store(),\n-                              segmentCount(segmented), removeFlowable, writeFlowable)\n-                              .thenApply(ignore2 -> writeCount.get()));\n-                     }).first(0L);\n+                        return Single.fromCompletionStage(storeBatchStage)\n+                              .map(ignore2 -> writeCount.get());\n+                        // Only take the last element for the count - ensures all stores are completed\n+                     }).last(0L);\n \n             },\n             this::releaseReadLock\n       ).toCompletionStage();\n    }\n \n-   private <K, V> MVCCEntry<K, V> acquireKeyFromContext(InvocationContext ctx, WriteCommand command, Object key,\n-         BiPredicate<WriteCommand, Object> commandKeyPredicate) {\n-      if (commandKeyPredicate.test(command, key)) {\n+   <K> Flowable<NonBlockingStore.SegmentedPublisher<K>> createRemoveFlowable(Flowable<K> keyRemoveFlowable,\n+         boolean shared, boolean segmented, StoreStatus storeStatus) {\n+      Flowable<NonBlockingStore.SegmentedPublisher<K>> removeFlowable;\n+      if (segmented) {\n+         removeFlowable = keyRemoveFlowable\n+               .groupBy(keyPartitioner::getSegment)\n+               .map(SegmentPublisherWrapper::wrap);\n+         if (shared) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f780e777290fdeb283e01591a59e6f294b0226e"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzE1MjgyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDoxNzoxM1rOGeeAlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMjoyMToxNVrOGezjsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYwMjEzNQ==", "bodyText": "Is there a real cost to changing this to:\nelse {\n         entryWriteFlowable = entryWriteFlowable\n               .filter(me -> !shared || distributionManager.getCacheTopology().getDistribution(me.getKey()).isPrimary())\n               .doOnNext(obj -> writeCount.incrementAndGet());\n         writeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(entryWriteFlowable));\n      }\nThe same approach can be taken with createRemoveFlowable.", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r434602135", "createdAt": "2020-06-03T14:17:13Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1109,36 +1054,139 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n                               });\n \n                         AtomicLong writeCount = new AtomicLong();\n-                        entryWriteFlowable = entryWriteFlowable.doOnNext(me -> writeCount.incrementAndGet());\n-\n-                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable;\n \n-                        if (segmented) {\n-                           writeFlowable = entryWriteFlowable\n-                                 .groupBy(me -> keyPartitioner.getSegment(me.getKey()))\n-                                 .map(SegmentPublisherWrapper::wrap);\n-                        } else {\n-                           writeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(entryWriteFlowable));\n-                        }\n+                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable =\n+                              createWriteFlowable(entryWriteFlowable, shared, segmented, writeCount, storeStatus);\n \n-                        if (trace) {\n-                           removeFlowable = removeFlowable.doOnSubscribe(sub ->\n-                              log.tracef(\"Store %s has subscribed to write batch\", storeStatus.store));\n-                        }\n+                        CompletionStage<Void> storeBatchStage = flowableHandler.handleFlowables(storeStatus.store(),\n+                              segmentCount(segmented), removeFlowable, writeFlowable);\n \n-                        return Single.fromCompletionStage(flowableHandler.handleFlowables(storeStatus.store(),\n-                              segmentCount(segmented), removeFlowable, writeFlowable)\n-                              .thenApply(ignore2 -> writeCount.get()));\n-                     }).first(0L);\n+                        return Single.fromCompletionStage(storeBatchStage)\n+                              .map(ignore2 -> writeCount.get());\n+                        // Only take the last element for the count - ensures all stores are completed\n+                     }).last(0L);\n \n             },\n             this::releaseReadLock\n       ).toCompletionStage();\n    }\n \n-   private <K, V> MVCCEntry<K, V> acquireKeyFromContext(InvocationContext ctx, WriteCommand command, Object key,\n-         BiPredicate<WriteCommand, Object> commandKeyPredicate) {\n-      if (commandKeyPredicate.test(command, key)) {\n+   <K> Flowable<NonBlockingStore.SegmentedPublisher<K>> createRemoveFlowable(Flowable<K> keyRemoveFlowable,\n+         boolean shared, boolean segmented, StoreStatus storeStatus) {\n+      Flowable<NonBlockingStore.SegmentedPublisher<K>> removeFlowable;\n+      if (segmented) {\n+         removeFlowable = keyRemoveFlowable\n+               .groupBy(keyPartitioner::getSegment)\n+               .map(SegmentPublisherWrapper::wrap);\n+         if (shared) {\n+            removeFlowable = filterSharedSegments(removeFlowable);\n+         }\n+      } else {\n+         if (shared) {\n+            keyRemoveFlowable = keyRemoveFlowable.filter(k ->\n+                  distributionManager.getCacheTopology().getDistribution(k).isPrimary());\n+         }\n+         removeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(keyRemoveFlowable));\n+      }\n+\n+      if (trace) {\n+         removeFlowable = removeFlowable.doOnSubscribe(sub ->\n+               log.tracef(\"Store %s has subscribed to remove batch\", storeStatus.store));\n+         removeFlowable = removeFlowable.map(sp -> {\n+            int segment = sp.getSegment();\n+            return SingleSegmentPublisher.singleSegment(segment, Flowable.fromPublisher(sp)\n+                  .doOnNext(keyToRemove -> log.tracef(\"Emitting key %s for removal from segment %s\",\n+                        keyToRemove, segment)));\n+         });\n+      }\n+\n+      return removeFlowable;\n+   }\n+\n+   <K, V> Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> createWriteFlowable(\n+         Flowable<MarshallableEntry<K, V>> entryWriteFlowable, boolean shared, boolean segmented,\n+         AtomicLong writeCount, StoreStatus storeStatus) {\n+      Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable;\n+      if (segmented) {\n+         // Note the writeCount includes entries that aren't written due to being shared\n+         // at this point\n+         entryWriteFlowable = entryWriteFlowable.doOnNext(obj -> writeCount.incrementAndGet());\n+         writeFlowable = entryWriteFlowable\n+               .groupBy(me -> keyPartitioner.getSegment(me.getKey()))\n+               .map(SegmentPublisherWrapper::wrap);\n+         if (shared) {\n+            // The writeCount will be decremented for each grouping of values ignored\n+            writeFlowable = filterSharedSegments(writeFlowable);\n+         }\n+      } else {\n+         if (shared) {\n+            entryWriteFlowable = entryWriteFlowable.filter(me ->\n+                  distributionManager.getCacheTopology().getDistribution(me.getKey()).isPrimary());\n+         }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f780e777290fdeb283e01591a59e6f294b0226e"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1NTE4Ng==", "bodyText": "Hard to say, you have the extra lambda allocation and will have to invoke it for every entry in the write or remove. I would say we just leave it how it is personally.", "url": "https://github.com/infinispan/infinispan/pull/8417#discussion_r434955186", "createdAt": "2020-06-04T02:21:15Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -1109,36 +1054,139 @@ private boolean shouldPerformTransactionOperation(StoreStatus storeStatus, Predi\n                               });\n \n                         AtomicLong writeCount = new AtomicLong();\n-                        entryWriteFlowable = entryWriteFlowable.doOnNext(me -> writeCount.incrementAndGet());\n-\n-                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable;\n \n-                        if (segmented) {\n-                           writeFlowable = entryWriteFlowable\n-                                 .groupBy(me -> keyPartitioner.getSegment(me.getKey()))\n-                                 .map(SegmentPublisherWrapper::wrap);\n-                        } else {\n-                           writeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(entryWriteFlowable));\n-                        }\n+                        Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable =\n+                              createWriteFlowable(entryWriteFlowable, shared, segmented, writeCount, storeStatus);\n \n-                        if (trace) {\n-                           removeFlowable = removeFlowable.doOnSubscribe(sub ->\n-                              log.tracef(\"Store %s has subscribed to write batch\", storeStatus.store));\n-                        }\n+                        CompletionStage<Void> storeBatchStage = flowableHandler.handleFlowables(storeStatus.store(),\n+                              segmentCount(segmented), removeFlowable, writeFlowable);\n \n-                        return Single.fromCompletionStage(flowableHandler.handleFlowables(storeStatus.store(),\n-                              segmentCount(segmented), removeFlowable, writeFlowable)\n-                              .thenApply(ignore2 -> writeCount.get()));\n-                     }).first(0L);\n+                        return Single.fromCompletionStage(storeBatchStage)\n+                              .map(ignore2 -> writeCount.get());\n+                        // Only take the last element for the count - ensures all stores are completed\n+                     }).last(0L);\n \n             },\n             this::releaseReadLock\n       ).toCompletionStage();\n    }\n \n-   private <K, V> MVCCEntry<K, V> acquireKeyFromContext(InvocationContext ctx, WriteCommand command, Object key,\n-         BiPredicate<WriteCommand, Object> commandKeyPredicate) {\n-      if (commandKeyPredicate.test(command, key)) {\n+   <K> Flowable<NonBlockingStore.SegmentedPublisher<K>> createRemoveFlowable(Flowable<K> keyRemoveFlowable,\n+         boolean shared, boolean segmented, StoreStatus storeStatus) {\n+      Flowable<NonBlockingStore.SegmentedPublisher<K>> removeFlowable;\n+      if (segmented) {\n+         removeFlowable = keyRemoveFlowable\n+               .groupBy(keyPartitioner::getSegment)\n+               .map(SegmentPublisherWrapper::wrap);\n+         if (shared) {\n+            removeFlowable = filterSharedSegments(removeFlowable);\n+         }\n+      } else {\n+         if (shared) {\n+            keyRemoveFlowable = keyRemoveFlowable.filter(k ->\n+                  distributionManager.getCacheTopology().getDistribution(k).isPrimary());\n+         }\n+         removeFlowable = Flowable.just(SingleSegmentPublisher.singleSegment(keyRemoveFlowable));\n+      }\n+\n+      if (trace) {\n+         removeFlowable = removeFlowable.doOnSubscribe(sub ->\n+               log.tracef(\"Store %s has subscribed to remove batch\", storeStatus.store));\n+         removeFlowable = removeFlowable.map(sp -> {\n+            int segment = sp.getSegment();\n+            return SingleSegmentPublisher.singleSegment(segment, Flowable.fromPublisher(sp)\n+                  .doOnNext(keyToRemove -> log.tracef(\"Emitting key %s for removal from segment %s\",\n+                        keyToRemove, segment)));\n+         });\n+      }\n+\n+      return removeFlowable;\n+   }\n+\n+   <K, V> Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> createWriteFlowable(\n+         Flowable<MarshallableEntry<K, V>> entryWriteFlowable, boolean shared, boolean segmented,\n+         AtomicLong writeCount, StoreStatus storeStatus) {\n+      Flowable<NonBlockingStore.SegmentedPublisher<MarshallableEntry<K, V>>> writeFlowable;\n+      if (segmented) {\n+         // Note the writeCount includes entries that aren't written due to being shared\n+         // at this point\n+         entryWriteFlowable = entryWriteFlowable.doOnNext(obj -> writeCount.incrementAndGet());\n+         writeFlowable = entryWriteFlowable\n+               .groupBy(me -> keyPartitioner.getSegment(me.getKey()))\n+               .map(SegmentPublisherWrapper::wrap);\n+         if (shared) {\n+            // The writeCount will be decremented for each grouping of values ignored\n+            writeFlowable = filterSharedSegments(writeFlowable);\n+         }\n+      } else {\n+         if (shared) {\n+            entryWriteFlowable = entryWriteFlowable.filter(me ->\n+                  distributionManager.getCacheTopology().getDistribution(me.getKey()).isPrimary());\n+         }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYwMjEzNQ=="}, "originalCommit": {"oid": "3f780e777290fdeb283e01591a59e6f294b0226e"}, "originalPosition": 337}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4047, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}