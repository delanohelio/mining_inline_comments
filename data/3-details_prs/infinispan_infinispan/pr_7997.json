{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgzODczNDU0", "number": 7997, "title": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking t\u2026", "bodyText": "\u2026hread executor\n\nInvoke commands that block on blocking executor\nInvoke other commands by caller\nUse non blocking executor instead of remote in other places\n\nhttps://issues.redhat.com/browse/ISPN-11385\nhttps://issues.redhat.com/browse/ISPN-11473\nhttps://issues.redhat.com/browse/ISPN-11489", "createdAt": "2020-03-04T21:00:03Z", "url": "https://github.com/infinispan/infinispan/pull/7997", "merged": true, "mergeCommit": {"oid": "2c74173eeb6d534c38e40ffbef748702c113d39e"}, "closed": true, "closedAt": "2020-03-20T21:28:58Z", "author": {"login": "wburns"}, "timelineItems": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcKpfwRgFqTM2OTQ3OTIzMA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPm6Z-ABqjMxNTA4NzkyMTY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NDc5MjMw", "url": "https://github.com/infinispan/infinispan/pull/7997#pullrequestreview-369479230", "createdAt": "2020-03-05T11:06:07Z", "commit": {"oid": "75e1aa23af44388a3ba79e94f33f6c3ae072392b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMTowNjowN1rOFyPWeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMTowNjowN1rOFyPWeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODIyNDYzMg==", "bodyText": "@danberindei @wburns WDYT to adding a default implemntation to ReplicableCommand that returns false? It will remove a fair bit of boilerplate.", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r388224632", "createdAt": "2020-03-05T11:06:07Z", "author": {"login": "ryanemerson"}, "path": "core/src/main/java/org/infinispan/commands/functional/AbstractWriteManyCommand.java", "diffHunk": "@@ -88,7 +88,7 @@ public boolean isConditional() {\n \n    @Override\n    public boolean canBlock() {\n-      return true;\n+      return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75e1aa23af44388a3ba79e94f33f6c3ae072392b"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "75e1aa23af44388a3ba79e94f33f6c3ae072392b", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/75e1aa23af44388a3ba79e94f33f6c3ae072392b", "committedDate": "2020-03-04T19:50:19Z", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places"}, "afterCommit": {"oid": "0574783db675921d696b4434abe2784dba696582", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/0574783db675921d696b4434abe2784dba696582", "committedDate": "2020-03-05T16:56:58Z", "message": "test fixes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9c073f682c073a5048ceae319adf34900b57bb14", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/9c073f682c073a5048ceae319adf34900b57bb14", "committedDate": "2020-03-06T13:52:21Z", "message": "fix InfinispanExtensionIT again"}, "afterCommit": {"oid": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/57a1afb12cb3453e6a61fcd43788102311d3ab3f", "committedDate": "2020-03-10T17:00:36Z", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2NTgyMTQ3", "url": "https://github.com/infinispan/infinispan/pull/7997#pullrequestreview-376582147", "createdAt": "2020-03-18T05:58:46Z", "commit": {"oid": "57a1afb12cb3453e6a61fcd43788102311d3ab3f"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNTo1ODo0NlrOF33PmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwNjozNTo1N1rOF3318w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMTExMw==", "bodyText": "Is this really needed? The configuration is in a string, so we shouldn't block to read it, and there's no resolver to allow includes from external resources.\nOff-topic, ParserRegistry.parse(String) could avoid wrapping the ByteArrayInputStream in a BufferedInputStream. I would have suggested using factory.createXMLStreamReader(new StringReader(configString)), but then I read its implementation and it would do even more extra work.", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394121113", "createdAt": "2020-03-18T05:58:46Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java", "diffHunk": "@@ -196,13 +198,16 @@ void start() {\n \n    CompletableFuture<Void> createCacheLocally(String name, CacheState state) {\n       log.debugf(\"Create cache %s\", name);\n-      Configuration configuration = buildConfiguration(name, state);\n-      return localConfigurationManager.createCache(name, state.getTemplate(), configuration, state.getFlags());\n+      CompletionStage<Configuration> configurationStage = buildConfiguration(name, state);\n+      return configurationStage.thenCompose(configuration -> localConfigurationManager.createCache(name, state.getTemplate(), configuration, state.getFlags()))\n+            .toCompletableFuture();\n    }\n \n-   private Configuration buildConfiguration(String name, CacheState state) {\n-      ConfigurationBuilderHolder builderHolder = parserRegistry.parse(state.getConfiguration());\n-      return builderHolder.getNamedConfigurationBuilders().get(name).build(configurationManager.getGlobalConfiguration());\n+   private CompletionStage<Configuration> buildConfiguration(String name, CacheState state) {\n+      return CompletableFuture.supplyAsync(() -> {\n+         ConfigurationBuilderHolder builderHolder = parserRegistry.parse(state.getConfiguration());\n+         return builderHolder.getNamedConfigurationBuilders().get(name).build(configurationManager.getGlobalConfiguration());\n+      }, blockingExecutor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57a1afb12cb3453e6a61fcd43788102311d3ab3f"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMjIyNw==", "bodyText": "Is/should there be a way to use the non-blocking executor for users of ClusterExecutor that know their callback is non-blocking? Maybe internal code should be sending commands anyway?", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394122227", "createdAt": "2020-03-18T06:02:55Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/manager/DefaultCacheManager.java", "diffHunk": "@@ -1140,7 +1140,8 @@ public ClusterExecutor executor() {\n       if (transport != null) {\n          long time = configurationManager.getGlobalConfiguration().transport().distributedSyncTimeout();\n          return ClusterExecutors.allSubmissionExecutor(null, this, transport, time, TimeUnit.MILLISECONDS,\n-               globalComponentRegistry.getComponent(ExecutorService.class, KnownComponentNames.REMOTE_COMMAND_EXECUTOR),\n+               // This can run arbitrary code, including user - assume it is blocking\n+               globalComponentRegistry.getComponent(ExecutorService.class, KnownComponentNames.BLOCKING_EXECUTOR),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57a1afb12cb3453e6a61fcd43788102311d3ab3f"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyMjkzNg==", "bodyText": "I was hoping that the result of canBlock() would already be ignored, and it would be the command's job to submit a task to the blocking executor if needed. Maybe in the next version, then :)", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394122936", "createdAt": "2020-03-18T06:05:45Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/manager/impl/ReplicableManagerFunctionCommand.java", "diffHunk": "@@ -61,6 +61,7 @@ public boolean isReturnValueExpected() {\n \n    @Override\n    public boolean canBlock() {\n+      // These commands can be arbitrary user commands - so be careful about them blocking", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57a1afb12cb3453e6a61fcd43788102311d3ab3f"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyNzE0Mg==", "bodyText": "So we assume any ReplicableCommand is blocking?", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394127142", "createdAt": "2020-03-18T06:21:51Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/remoting/inboundhandler/GlobalInboundInvocationHandler.java", "diffHunk": "@@ -135,7 +135,7 @@ private void handleReplicableCommand(Address origin, ReplicableCommand command,\n          //we must/can run in this thread\n          runnable.run();\n       } else {\n-         remoteCommandsExecutor.execute(runnable);\n+         blockingExecutor.execute(runnable);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57a1afb12cb3453e6a61fcd43788102311d3ab3f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyNzgyMQ==", "bodyText": "I would assume the unlock method can't block, so it's just for symmetry", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394127821", "createdAt": "2020-03-18T06:24:35Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/topology/ClusterTopologyManagerImpl.java", "diffHunk": "@@ -179,17 +179,29 @@ public void start() {\n    @Stop(priority = 100)\n    public void stop() {\n       // Stop blocking cache topology commands.\n-      updateLock.lock();\n+      acquireUpdateLock();\n       try {\n          clusterManagerStatus = ClusterManagerStatus.STOPPING;\n          joinViewFuture.stop();\n       } finally {\n-         updateLock.unlock();\n+         releaseUpdateLock();\n       }\n \n       cacheManagerNotifier.removeListener(viewListener);\n    }\n \n+   // This method is here to augment with blockhound as we allow it to block, but don't want the calls\n+   // inside the lock to block - Do not move or rename without updating the reference\n+   private void acquireUpdateLock() {\n+      updateLock.lock();\n+   }\n+\n+   // This method is here to augment with blockhound as we allow it to block, but don't want the calls\n+   // inside the lock to block - Do not move or rename without updating the reference", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57a1afb12cb3453e6a61fcd43788102311d3ab3f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyODA4MA==", "bodyText": "Doesn't add anything IMO", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394128080", "createdAt": "2020-03-18T06:25:30Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/CoreBlockHoundIntegration.java", "diffHunk": "@@ -47,6 +48,10 @@ public void applyTo(BlockHound.Builder builder) {\n \n          // This shouldn't block long when held - but it is a write lock which can be delayed\n          builder.allowBlockingCallsInside(KeyAffinityServiceImpl.class.getName(), \"handleViewChange\");\n+\n+         // Let the lock acquisition be blocking", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57a1afb12cb3453e6a61fcd43788102311d3ab3f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzMDkzMQ==", "bodyText": "Assuming this is just for the Thread.sleep() call, I think it would be better to add an executor parameter to TestingUtil.delayed() and to inject the non-blocking executor in ReplListenerInterceptor.", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394130931", "createdAt": "2020-03-18T06:35:57Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/util/CoreTestBlockHoundIntegration.java", "diffHunk": "@@ -67,6 +73,10 @@ private static void allowTestsToBlock(BlockHound.Builder builder) {\n       CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, NotifierLatch.class);\n \n       CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, TestBlocking.class);\n+\n+      CommonsBlockHoundIntegration.allowMethodsToBlock(builder, Class.forName(ReplListener.class.getName() + \"$ReplListenerInterceptor\"), false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57a1afb12cb3453e6a61fcd43788102311d3ab3f"}, "originalPosition": 38}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "57a1afb12cb3453e6a61fcd43788102311d3ab3f", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/57a1afb12cb3453e6a61fcd43788102311d3ab3f", "committedDate": "2020-03-10T17:00:36Z", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places"}, "afterCommit": {"oid": "b3bd615b4121bde9fd9c99c662669841ac5a27d7", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/b3bd615b4121bde9fd9c99c662669841ac5a27d7", "committedDate": "2020-03-18T16:35:03Z", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b3bd615b4121bde9fd9c99c662669841ac5a27d7", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/b3bd615b4121bde9fd9c99c662669841ac5a27d7", "committedDate": "2020-03-18T16:35:03Z", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places"}, "afterCommit": {"oid": "ad99dea5d1406aa6bf894efe861566804ae9f1e6", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/ad99dea5d1406aa6bf894efe861566804ae9f1e6", "committedDate": "2020-03-18T16:53:42Z", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc3MjkzODY0", "url": "https://github.com/infinispan/infinispan/pull/7997#pullrequestreview-377293864", "createdAt": "2020-03-18T22:58:04Z", "commit": {"oid": "4730be1a23e42918e2f831d1bbff89fd1f778649"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQyMjo1ODowNFrOF4ZvTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQyMzowOToxMlrOF4Z9_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ==", "bodyText": "No longer necessary?", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394686285", "createdAt": "2020-03-18T22:58:04Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/manager/DefaultCacheManager.java", "diffHunk": "@@ -1139,11 +1138,14 @@ public ClusterExecutor executor() {\n       if (transport != null) {\n          long time = configurationManager.getGlobalConfiguration().transport().distributedSyncTimeout();\n          return ClusterExecutors.allSubmissionExecutor(null, this, transport, time, TimeUnit.MILLISECONDS,\n-               globalComponentRegistry.getComponent(ExecutorService.class, KnownComponentNames.REMOTE_COMMAND_EXECUTOR),\n+               // This can run arbitrary code, including user - such commands can block", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4730be1a23e42918e2f831d1bbff89fd1f778649"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NzIxOA==", "bodyText": "Since you created a separate ISPN-11483, we should return true here for now.", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394687218", "createdAt": "2020-03-18T23:00:45Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/manager/impl/ReplicableManagerFunctionCommand.java", "diffHunk": "@@ -61,6 +61,7 @@ public boolean isReturnValueExpected() {\n \n    @Override\n    public boolean canBlock() {\n-      return true;\n+      // Note that it is highly possible that a user command could block, and some internal Infinispan ones already do\n+      return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4730be1a23e42918e2f831d1bbff89fd1f778649"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4Nzk5MQ==", "bodyText": "Temporary?", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394687991", "createdAt": "2020-03-18T23:03:04Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/stream/DistributedSequentialNonRehashStreamTest.java", "diffHunk": "@@ -10,7 +10,7 @@\n  * Verifies stream tests work when rehash is disabled on a sequential stream\n  */\n @Test(groups = \"functional\", testName = \"streams.DistributedSequentialNonRehashStreamTest\")\n-@InCacheMode({ CacheMode.DIST_SYNC, CacheMode.SCATTERED_SYNC })\n+@InCacheMode({ /*CacheMode.DIST_SYNC,*/ CacheMode.SCATTERED_SYNC })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4730be1a23e42918e2f831d1bbff89fd1f778649"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4ODIxOA==", "bodyText": "+1 to add TestingUtil#sleepThread", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394688218", "createdAt": "2020-03-18T23:03:42Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/util/CoreTestBlockHoundIntegration.java", "diffHunk": "@@ -67,6 +73,10 @@ private static void allowTestsToBlock(BlockHound.Builder builder) {\n       CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, NotifierLatch.class);\n \n       CommonsBlockHoundIntegration.allowPublicMethodsToBlock(builder, TestBlocking.class);\n+\n+      CommonsBlockHoundIntegration.allowMethodsToBlock(builder, Class.forName(ReplListener.class.getName() + \"$ReplListenerInterceptor\"), false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEzMDkzMQ=="}, "originalCommit": {"oid": "57a1afb12cb3453e6a61fcd43788102311d3ab3f"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY5MDA0NQ==", "bodyText": "Sorry, I was only looking at the diff and I forgot that ReplicableCommand has canBlock(), I thought it was in CacheRpcCommand.", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r394690045", "createdAt": "2020-03-18T23:09:12Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/remoting/inboundhandler/GlobalInboundInvocationHandler.java", "diffHunk": "@@ -135,7 +135,7 @@ private void handleReplicableCommand(Address origin, ReplicableCommand command,\n          //we must/can run in this thread\n          runnable.run();\n       } else {\n-         remoteCommandsExecutor.execute(runnable);\n+         blockingExecutor.execute(runnable);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDEyNzE0Mg=="}, "originalCommit": {"oid": "57a1afb12cb3453e6a61fcd43788102311d3ab3f"}, "originalPosition": 24}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4730be1a23e42918e2f831d1bbff89fd1f778649", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/4730be1a23e42918e2f831d1bbff89fd1f778649", "committedDate": "2020-03-18T20:26:30Z", "message": "fixes for persistence and state transfer"}, "afterCommit": {"oid": "bf6f39a2d3909b5ea4a8484447c8da5678e7f926", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/bf6f39a2d3909b5ea4a8484447c8da5678e7f926", "committedDate": "2020-03-19T15:50:32Z", "message": "ISPN-11489 TransactionCoordinator updated for non blocking"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bf6f39a2d3909b5ea4a8484447c8da5678e7f926", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/bf6f39a2d3909b5ea4a8484447c8da5678e7f926", "committedDate": "2020-03-19T15:50:32Z", "message": "ISPN-11489 TransactionCoordinator updated for non blocking"}, "afterCommit": {"oid": "5c0b1da5ebdf26ebdae76312f643f4c659c29e3b", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/5c0b1da5ebdf26ebdae76312f643f4c659c29e3b", "committedDate": "2020-03-19T18:13:38Z", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5c0b1da5ebdf26ebdae76312f643f4c659c29e3b", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/5c0b1da5ebdf26ebdae76312f643f4c659c29e3b", "committedDate": "2020-03-19T18:13:38Z", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places"}, "afterCommit": {"oid": "ddd733c194568ba62d020813de25ad5507acdb8d", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/ddd733c194568ba62d020813de25ad5507acdb8d", "committedDate": "2020-03-19T19:02:46Z", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ddd733c194568ba62d020813de25ad5507acdb8d", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/ddd733c194568ba62d020813de25ad5507acdb8d", "committedDate": "2020-03-19T19:02:46Z", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places"}, "afterCommit": {"oid": "97976107c069b2923c52a869eb6a0e60c53a4691", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/97976107c069b2923c52a869eb6a0e60c53a4691", "committedDate": "2020-03-20T04:15:07Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "97976107c069b2923c52a869eb6a0e60c53a4691", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/97976107c069b2923c52a869eb6a0e60c53a4691", "committedDate": "2020-03-20T04:15:07Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}, "afterCommit": {"oid": "5ae68c59a1ff3b403e6cd10242709031b2122866", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/5ae68c59a1ff3b403e6cd10242709031b2122866", "committedDate": "2020-03-20T04:22:12Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5ae68c59a1ff3b403e6cd10242709031b2122866", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/5ae68c59a1ff3b403e6cd10242709031b2122866", "committedDate": "2020-03-20T04:22:12Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}, "afterCommit": {"oid": "21db4dfaa4eeca00d7ead811823205962d364414", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/21db4dfaa4eeca00d7ead811823205962d364414", "committedDate": "2020-03-20T04:40:16Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "21db4dfaa4eeca00d7ead811823205962d364414", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/21db4dfaa4eeca00d7ead811823205962d364414", "committedDate": "2020-03-20T04:40:16Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}, "afterCommit": {"oid": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/fdefde6f70556b8d6666f4038d0085bfadeffb0b", "committedDate": "2020-03-20T12:42:01Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MjY2Nzcz", "url": "https://github.com/infinispan/infinispan/pull/7997#pullrequestreview-378266773", "createdAt": "2020-03-20T07:14:54Z", "commit": {"oid": "21db4dfaa4eeca00d7ead811823205962d364414"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNzoxNDo1NVrOF5JYUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNTo1ODoxMFrOF5Zppw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ2NjgzMg==", "bodyText": "Still using ctx here", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395466832", "createdAt": "2020-03-20T07:14:55Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/cache/impl/InvocationHelper.java", "diffHunk": "@@ -238,7 +248,7 @@ private Transaction getOngoingTransaction() {\n             throw CompletableFutures.asCompletionException(e);\n          }\n          return result;\n-      });\n+      }, blockingExecutor), nonBlockingExecutor, ctx).toCompletableFuture();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21db4dfaa4eeca00d7ead811823205962d364414"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU0NTM4Nw==", "bodyText": "Unfortunately I think the few users of cluster executor may be doing exactly blocking cache operations, because there's no way to return a value asynchronously.\nI'm starting to think that the proper solution is\n\nchange PersistenceManagerImpl to detect if it is a blocking thread and run it inline and if non blocking thread to run the command in a blocking thread.\n\nIn fact, I would go even further, and change continueOnCPUExecutor to also continue on the caller thread if the caller thread was blocking. Otherwise, for cluster executor tasks doing cache.put(k1, v1), where the put requires 1 store operation to read the previous value and 1 store operation to store the value, the store read would happen on the task's initial blocking thread, but the store write would need another blocking thread. If the size of the blocking thread pool is N and you have N simultaneous tasks like this, there's no free thread to process the store writes.", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395545387", "createdAt": "2020-03-20T10:21:10Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/manager/DefaultCacheManager.java", "diffHunk": "@@ -1139,11 +1138,14 @@ public ClusterExecutor executor() {\n       if (transport != null) {\n          long time = configurationManager.getGlobalConfiguration().transport().distributedSyncTimeout();\n          return ClusterExecutors.allSubmissionExecutor(null, this, transport, time, TimeUnit.MILLISECONDS,\n-               globalComponentRegistry.getComponent(ExecutorService.class, KnownComponentNames.REMOTE_COMMAND_EXECUTOR),\n+               // This can run arbitrary code, including user - such commands can block", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NjI4NQ=="}, "originalCommit": {"oid": "4730be1a23e42918e2f831d1bbff89fd1f778649"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU2MTM0MA==", "bodyText": "Maybe I'm missing something, but that JIRA is a bit confusing to me. The subject is \"Provide way for ClusterExecutor to use non blocking thread\", but we are already using a non-blocking thread by returning false here.", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395561340", "createdAt": "2020-03-20T10:54:20Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/manager/impl/ReplicableManagerFunctionCommand.java", "diffHunk": "@@ -61,6 +61,7 @@ public boolean isReturnValueExpected() {\n \n    @Override\n    public boolean canBlock() {\n-      return true;\n+      // Note that it is highly possible that a user command could block, and some internal Infinispan ones already do\n+      return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDY4NzIxOA=="}, "originalCommit": {"oid": "4730be1a23e42918e2f831d1bbff89fd1f778649"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTU5NjI4NQ==", "bodyText": "I would prefer to make the prepare exception the cause and the rollback exception suppressed. I'd also rename innerT to rollbackThrowable and t to prepareThrowable.", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395596285", "createdAt": "2020-03-20T12:12:22Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java", "diffHunk": "@@ -99,92 +107,121 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n       }\n    }\n \n-   public final int prepare(LocalTransaction localTransaction) throws XAException {\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction) {\n       return prepare(localTransaction, false);\n    }\n \n-   public final int prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) throws XAException {\n-      validateNotMarkedForRollback(localTransaction);\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) {\n+      CompletionStage<Integer> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+      if (markRollbackStage != null) {\n+         return markRollbackStage;\n+      }\n \n       if (isOnePhaseCommit(localTransaction)) {\n          if (trace) log.tracef(\"Received prepare for tx: %s. Skipping call as 1PC will be used.\", localTransaction);\n-         return XA_OK;\n+         return XA_OKAY_STAGE;\n       }\n \n       PrepareCommand prepareCommand = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), localTransaction.getModifications(), false);\n       if (trace) log.tracef(\"Sending prepare command through the chain: %s\", prepareCommand);\n \n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       prepareCommand.setReplayEntryWrapping(replayEntryWrapping);\n-      try {\n-         invoker.running().invoke(ctx, prepareCommand);\n+      CompletionStage<Object> prepareStage = invoker.running().invokeAsync(ctx, prepareCommand);\n+      return CompletionStages.handleAndCompose(prepareStage, (ignore, t) -> {\n+         if (t != null) {\n+            if (shuttingDown)\n+               log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n+            else\n+               log.errorProcessingPrepare(t);\n+\n+            //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n+            //after prepare failed.\n+            return CompletionStages.handleAndCompose(rollback(localTransaction), (ignore2, innerT) -> {\n+               // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n+               XAException xe = new XAException(XAException.XA_RBROLLBACK);\n+               if (innerT != null) {\n+                  innerT.addSuppressed(t);\n+                  xe.initCause(innerT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21db4dfaa4eeca00d7ead811823205962d364414"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY3NjI5Mw==", "bodyText": "AFAICT handleRollbackFailure and handleCommitFailure don't need to return a CompletionStage", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395676293", "createdAt": "2020-03-20T14:33:00Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java", "diffHunk": "@@ -99,92 +107,121 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n       }\n    }\n \n-   public final int prepare(LocalTransaction localTransaction) throws XAException {\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction) {\n       return prepare(localTransaction, false);\n    }\n \n-   public final int prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) throws XAException {\n-      validateNotMarkedForRollback(localTransaction);\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) {\n+      CompletionStage<Integer> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+      if (markRollbackStage != null) {\n+         return markRollbackStage;\n+      }\n \n       if (isOnePhaseCommit(localTransaction)) {\n          if (trace) log.tracef(\"Received prepare for tx: %s. Skipping call as 1PC will be used.\", localTransaction);\n-         return XA_OK;\n+         return XA_OKAY_STAGE;\n       }\n \n       PrepareCommand prepareCommand = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), localTransaction.getModifications(), false);\n       if (trace) log.tracef(\"Sending prepare command through the chain: %s\", prepareCommand);\n \n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       prepareCommand.setReplayEntryWrapping(replayEntryWrapping);\n-      try {\n-         invoker.running().invoke(ctx, prepareCommand);\n+      CompletionStage<Object> prepareStage = invoker.running().invokeAsync(ctx, prepareCommand);\n+      return CompletionStages.handleAndCompose(prepareStage, (ignore, t) -> {\n+         if (t != null) {\n+            if (shuttingDown)\n+               log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n+            else\n+               log.errorProcessingPrepare(t);\n+\n+            //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n+            //after prepare failed.\n+            return CompletionStages.handleAndCompose(rollback(localTransaction), (ignore2, innerT) -> {\n+               // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n+               XAException xe = new XAException(XAException.XA_RBROLLBACK);\n+               if (innerT != null) {\n+                  innerT.addSuppressed(t);\n+                  xe.initCause(innerT);\n+               } else {\n+                  xe.initCause(t);\n+               }\n+               return CompletableFutures.completedExceptionFuture(xe);\n+            });\n+         }\n          if (localTransaction.isReadOnly()) {\n             if (trace) log.tracef(\"Readonly transaction: %s\", localTransaction.getGlobalTransaction());\n             // force a cleanup to release any objects held.  Some TMs don't call commit if it is a READ ONLY tx.  See ISPN-845\n-            commitInternal(ctx);\n-            return XA_RDONLY;\n+            return commitInternal(ctx)\n+                  .thenApply(XA_RDONLY_APPLY);\n          } else {\n             txTable.running().localTransactionPrepared(localTransaction);\n-            return XA_OK;\n+            return XA_OKAY_STAGE;\n          }\n-      } catch (Throwable e) {\n-         if (shuttingDown)\n-            log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n-         else\n-            log.errorProcessingPrepare(e);\n-\n-         //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n-         //after prepare failed.\n-         rollback(localTransaction);\n-         // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n-         XAException xe = new XAException(XAException.XA_RBROLLBACK);\n-         xe.initCause(e);\n-         throw xe;\n-      }\n+      });\n    }\n \n-   public boolean commit(LocalTransaction localTransaction, boolean isOnePhase) throws XAException {\n+   public CompletionStage<Boolean> commit(LocalTransaction localTransaction, boolean isOnePhase) {\n       if (trace) log.tracef(\"Committing transaction %s\", localTransaction.getGlobalTransaction());\n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       if (isOnePhaseCommit(localTransaction) || isOnePhase) {\n-         validateNotMarkedForRollback(localTransaction);\n+         CompletionStage<Boolean> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+         if (markRollbackStage != null) {\n+            return markRollbackStage;\n+         }\n \n          if (trace) log.trace(\"Doing an 1PC prepare call on the interceptor chain\");\n          List<WriteCommand> modifications = localTransaction.getModifications();\n          PrepareCommand command = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), modifications, true);\n          try {\n-            invoker.running().invoke(ctx, command);\n+            return CompletionStages.handleAndCompose(invoker.running().invokeAsync(ctx, command),\n+                  (ignore, t) -> {\n+                     if (t != null) {\n+                        return handleCommitFailure(t, true, ctx);\n+                     }\n+                     return CompletableFutures.completedTrue();\n+                  });\n          } catch (Throwable e) {\n-            handleCommitFailure(e, true, ctx);\n+            return handleCommitFailure(e, true, ctx);\n          }\n-         return true;\n       } else if (!localTransaction.isReadOnly()) {\n-         commitInternal(ctx);\n+         return commitInternal(ctx);\n       }\n-      return false;\n+      return CompletableFutures.completedFalse();\n    }\n \n-   public void rollback(LocalTransaction localTransaction) throws XAException {\n+   public CompletionStage<Void> rollback(LocalTransaction localTransaction) {\n       try {\n-         rollbackInternal(icf.running().createTxInvocationContext(localTransaction));\n+         return CompletionStages.handleAndCompose(rollbackInternal(icf.running().createTxInvocationContext(localTransaction)),\n+               (ignore, t) -> {\n+                  if (t != null) {\n+                     return handleRollbackFailure(t, localTransaction);\n+                  }\n+                  return CompletableFutures.completedNull();\n+               });\n+\n       } catch (Throwable e) {\n-         if (shuttingDown)\n-            log.trace(\"Exception while rolling back, probably because we're shutting down.\");\n-         else\n-            log.errorRollingBack(e);\n-\n-         final Transaction transaction = localTransaction.getTransaction();\n-         //this might be possible if the cache has stopped and TM still holds a reference to the XAResource\n-         if (transaction != null) {\n-            txTable.running().failureCompletingTransaction(transaction);\n-         }\n-         XAException xe = new XAException(XAException.XAER_RMERR);\n-         xe.initCause(e);\n-         throw xe;\n+         return handleRollbackFailure(e, localTransaction);\n+      }\n+   }\n+\n+   private <T> CompletionStage<T> handleRollbackFailure(Throwable t, LocalTransaction localTransaction) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdefde6f70556b8d6666f4038d0085bfadeffb0b"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4MjQ0Mw==", "bodyText": "AsyncInterceptorChain.invokeAsync() catches exceptions, so we don't nee the try..catch any more.", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395682443", "createdAt": "2020-03-20T14:42:22Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java", "diffHunk": "@@ -99,92 +107,121 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n       }\n    }\n \n-   public final int prepare(LocalTransaction localTransaction) throws XAException {\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction) {\n       return prepare(localTransaction, false);\n    }\n \n-   public final int prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) throws XAException {\n-      validateNotMarkedForRollback(localTransaction);\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) {\n+      CompletionStage<Integer> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+      if (markRollbackStage != null) {\n+         return markRollbackStage;\n+      }\n \n       if (isOnePhaseCommit(localTransaction)) {\n          if (trace) log.tracef(\"Received prepare for tx: %s. Skipping call as 1PC will be used.\", localTransaction);\n-         return XA_OK;\n+         return XA_OKAY_STAGE;\n       }\n \n       PrepareCommand prepareCommand = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), localTransaction.getModifications(), false);\n       if (trace) log.tracef(\"Sending prepare command through the chain: %s\", prepareCommand);\n \n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       prepareCommand.setReplayEntryWrapping(replayEntryWrapping);\n-      try {\n-         invoker.running().invoke(ctx, prepareCommand);\n+      CompletionStage<Object> prepareStage = invoker.running().invokeAsync(ctx, prepareCommand);\n+      return CompletionStages.handleAndCompose(prepareStage, (ignore, t) -> {\n+         if (t != null) {\n+            if (shuttingDown)\n+               log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n+            else\n+               log.errorProcessingPrepare(t);\n+\n+            //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n+            //after prepare failed.\n+            return CompletionStages.handleAndCompose(rollback(localTransaction), (ignore2, innerT) -> {\n+               // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n+               XAException xe = new XAException(XAException.XA_RBROLLBACK);\n+               if (innerT != null) {\n+                  innerT.addSuppressed(t);\n+                  xe.initCause(innerT);\n+               } else {\n+                  xe.initCause(t);\n+               }\n+               return CompletableFutures.completedExceptionFuture(xe);\n+            });\n+         }\n          if (localTransaction.isReadOnly()) {\n             if (trace) log.tracef(\"Readonly transaction: %s\", localTransaction.getGlobalTransaction());\n             // force a cleanup to release any objects held.  Some TMs don't call commit if it is a READ ONLY tx.  See ISPN-845\n-            commitInternal(ctx);\n-            return XA_RDONLY;\n+            return commitInternal(ctx)\n+                  .thenApply(XA_RDONLY_APPLY);\n          } else {\n             txTable.running().localTransactionPrepared(localTransaction);\n-            return XA_OK;\n+            return XA_OKAY_STAGE;\n          }\n-      } catch (Throwable e) {\n-         if (shuttingDown)\n-            log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n-         else\n-            log.errorProcessingPrepare(e);\n-\n-         //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n-         //after prepare failed.\n-         rollback(localTransaction);\n-         // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n-         XAException xe = new XAException(XAException.XA_RBROLLBACK);\n-         xe.initCause(e);\n-         throw xe;\n-      }\n+      });\n    }\n \n-   public boolean commit(LocalTransaction localTransaction, boolean isOnePhase) throws XAException {\n+   public CompletionStage<Boolean> commit(LocalTransaction localTransaction, boolean isOnePhase) {\n       if (trace) log.tracef(\"Committing transaction %s\", localTransaction.getGlobalTransaction());\n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       if (isOnePhaseCommit(localTransaction) || isOnePhase) {\n-         validateNotMarkedForRollback(localTransaction);\n+         CompletionStage<Boolean> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+         if (markRollbackStage != null) {\n+            return markRollbackStage;\n+         }\n \n          if (trace) log.trace(\"Doing an 1PC prepare call on the interceptor chain\");\n          List<WriteCommand> modifications = localTransaction.getModifications();\n          PrepareCommand command = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), modifications, true);\n          try {\n-            invoker.running().invoke(ctx, command);\n+            return CompletionStages.handleAndCompose(invoker.running().invokeAsync(ctx, command),\n+                  (ignore, t) -> {\n+                     if (t != null) {\n+                        return handleCommitFailure(t, true, ctx);\n+                     }\n+                     return CompletableFutures.completedTrue();\n+                  });\n          } catch (Throwable e) {\n-            handleCommitFailure(e, true, ctx);\n+            return handleCommitFailure(e, true, ctx);\n          }\n-         return true;\n       } else if (!localTransaction.isReadOnly()) {\n-         commitInternal(ctx);\n+         return commitInternal(ctx);\n       }\n-      return false;\n+      return CompletableFutures.completedFalse();\n    }\n \n-   public void rollback(LocalTransaction localTransaction) throws XAException {\n+   public CompletionStage<Void> rollback(LocalTransaction localTransaction) {\n       try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdefde6f70556b8d6666f4038d0085bfadeffb0b"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY4NTkxOA==", "bodyText": "The exception will be wrapped in a CompletionException anyway, so I don't think we need this exceptionally call. Same for afterCompletion.", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395685918", "createdAt": "2020-03-20T14:47:32Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionTable.java", "diffHunk": "@@ -888,35 +892,31 @@ private void updateLastPrunedTxId(final long txId, Address address) {\n       }\n    }\n \n-   public int beforeCompletion(LocalTransaction localTransaction) {\n+   public CompletionStage<Integer> beforeCompletion(LocalTransaction localTransaction) {\n       if (trace)\n          log.tracef(\"beforeCompletion called for %s\", localTransaction);\n-      try {\n-         txCoordinator.prepare(localTransaction);\n-      } catch (XAException e) {\n-         throw new CacheException(\"Could not prepare. \", e);//todo shall we just swallow this exception?\n-      }\n-      return 0;\n+      return txCoordinator.prepare(localTransaction)\n+            .exceptionally(t -> {\n+                  throw new CacheException(\"Could not prepare. \", t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdefde6f70556b8d6666f4038d0085bfadeffb0b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY5NTI0OQ==", "bodyText": "Could use CompletableFutures.COMPLETED_NULL.thenComposeAsync(...) to avoid the double wrapping the result.\nMaybe it's worth adding a static method in CompletableFutures.", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395695249", "createdAt": "2020-03-20T15:00:44Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/transaction/xa/TransactionXaAdapter.java", "diffHunk": "@@ -57,23 +66,23 @@ public TransactionXaAdapter(XaTransactionTable txTable) {\n     */\n    @Override\n    public int prepare(Xid externalXid) throws XAException {\n-      return txTable.prepare(externalXid);\n+      return joinAndRethrowXAException(CompletableFuture.supplyAsync(() -> txTable.prepare(externalXid), executor));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdefde6f70556b8d6666f4038d0085bfadeffb0b"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwMjg5MQ==", "bodyText": "Nitpicking, but I would prefer wrapping before prepareStage, or even\n  return prepareStage.thenCompose(ignore -> txCoordinator.commit(localTransaction, false))\n                     .thenApply(committedInOnePhase -> {", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395702891", "createdAt": "2020-03-20T15:12:15Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java", "diffHunk": "@@ -100,32 +104,47 @@ public int getLocalTxCount() {\n       return xid2LocalTx.size();\n    }\n \n-   public int prepare(Xid externalXid) throws XAException {\n+   public CompletionStage<Integer> prepare(Xid externalXid) {\n       Xid xid = convertXid(externalXid);\n       LocalXaTransaction localTransaction = getLocalTransactionAndValidate(xid);\n+      if (localTransaction == null) {\n+         return CompletableFutures.completedExceptionFuture(new XAException(XAException.XAER_NOTA));\n+      }\n       return txCoordinator.prepare(localTransaction);\n    }\n \n-   public void commit(Xid externalXid, boolean isOnePhase) throws XAException {\n+   public CompletionStage<Void> commit(Xid externalXid, boolean isOnePhase) {\n       Xid xid = convertXid(externalXid);\n       LocalXaTransaction localTransaction = getLocalTransactionAndValidate(xid);\n-      boolean committedInOnePhase;\n+      if (localTransaction == null) {\n+         return CompletableFutures.completedExceptionFuture(new XAException(XAException.XAER_NOTA));\n+      }\n+      CompletionStage<?> prepareStage;\n       if (isOnePhase) {\n          //isOnePhase being true means that we're the only participant in the distributed transaction and TM does the\n          //1PC optimization. We run a 2PC though, as running only 1PC has a high chance of leaving the cluster in\n          //inconsistent state.\n-         txCoordinator.prepare(localTransaction);\n+         prepareStage = txCoordinator.prepare(localTransaction);\n+      } else {\n+         prepareStage = CompletableFutures.completedNull();\n       }\n-      committedInOnePhase = txCoordinator.commit(localTransaction, false);\n-      forgetSuccessfullyCompletedTransaction(recoveryManager, localTransaction.getXid(), localTransaction,\n-            committedInOnePhase);\n+      CompletionStage<Boolean> commitStage = prepareStage\n+            .thenCompose(ignore -> txCoordinator.commit(localTransaction, false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdefde6f70556b8d6666f4038d0085bfadeffb0b"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwNjI1Mg==", "bodyText": "Since we know 100% xe is not a CompletionException, I would find throw new CompletionException(xe) clearer.", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395706252", "createdAt": "2020-03-20T15:17:04Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java", "diffHunk": "@@ -153,23 +172,23 @@ void end(LocalXaTransaction localTransaction) {\n          log.tracef(\"end called on tx %s(%s)\", localTransaction.getGlobalTransaction(), cacheName);\n    }\n \n-   void forget(Xid externalXid) throws XAException {\n+   CompletionStage<Void> forget(Xid externalXid) {\n       Xid xid = convertXid(externalXid);\n       if (trace)\n          log.tracef(\"forget called for xid %s\", xid);\n-      try {\n-         if (isRecoveryEnabled()) {\n-            recoveryManager.removeRecoveryInformation(null, xid, true, null, false);\n-         } else {\n-            if (trace)\n-               log.trace(\"Recovery not enabled\");\n-         }\n-      } catch (Exception e) {\n-         log.warnExceptionRemovingRecovery(e);\n-         XAException xe = new XAException(XAException.XAER_RMERR);\n-         xe.initCause(e);\n-         throw xe;\n+      if (isRecoveryEnabled()) {\n+         return recoveryManager.removeRecoveryInformation(null, xid, null, false)\n+               .exceptionally(t -> {\n+                  log.warnExceptionRemovingRecovery(t);\n+                  XAException xe = new XAException(XAException.XAER_RMERR);\n+                  xe.initCause(t);\n+                  throw CompletableFutures.asCompletionException(xe);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdefde6f70556b8d6666f4038d0085bfadeffb0b"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcwODEwOA==", "bodyText": "The name is outdated, there's no validation, so I would suggest inlining the method.", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395708108", "createdAt": "2020-03-20T15:19:38Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/transaction/xa/XaTransactionTable.java", "diffHunk": "@@ -180,20 +199,21 @@ private void forgetSuccessfullyCompletedTransaction(RecoveryManager recoveryMana\n          LocalXaTransaction localTransaction, boolean committedInOnePhase) {\n       final GlobalTransaction gtx = localTransaction.getGlobalTransaction();\n       if (isRecoveryEnabled()) {\n-         recoveryManager.removeRecoveryInformation(localTransaction.getRemoteLocksAcquired(), xid, false, gtx,\n+         // TODO: this should call a different method that doesn't receive an ack\n+         recoveryManager.removeRecoveryInformation(localTransaction.getRemoteLocksAcquired(), xid, gtx,\n                partitionHandlingManager.isTransactionPartiallyCommitted(gtx));\n          removeLocalTransaction(localTransaction);\n       } else {\n          releaseLocksForCompletedTransaction(localTransaction, committedInOnePhase);\n       }\n    }\n \n-   private LocalXaTransaction getLocalTransactionAndValidate(Xid xid) throws XAException {\n+   private LocalXaTransaction getLocalTransactionAndValidate(Xid xid) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdefde6f70556b8d6666f4038d0085bfadeffb0b"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcxNDYyNg==", "bodyText": "I think it's safe to remove the local recovery info in the caller thread and then return the stage.\nSlightly off-topic, I've been looking at RecoveryAwareTransactionTable.removeRemoteTransaction and it seems horribly inefficient. It should only iterate over the transactions when there the GlobalTransaction is not available.", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395714626", "createdAt": "2020-03-20T15:29:18Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java", "diffHunk": "@@ -128,38 +130,43 @@ public RecoveryIterator getPreparedTransactionsFromCluster() {\n    }\n \n    @Override\n-   public void removeRecoveryInformation(Collection<Address> lockOwners, Xid xid, boolean sync, GlobalTransaction gtx,\n+   public CompletionStage<Void> removeRecoveryInformation(Collection<Address> lockOwners, Xid xid, GlobalTransaction gtx,\n                                          boolean fromCluster) {\n       log.tracef(\"Forgetting tx information for %s\", gtx);\n       //todo make sure this gets broad casted or at least flushed\n       if (rpcManager != null && !fromCluster) {\n          TxCompletionNotificationCommand ftc = commandFactory.buildTxCompletionNotificationCommand(xid, gtx);\n-         sendTxCompletionNotification(lockOwners, ftc, sync);\n+         return sendTxCompletionNotification(lockOwners, ftc)\n+               .thenRun(() -> removeRecoveryInformation(xid));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdefde6f70556b8d6666f4038d0085bfadeffb0b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTcyNTAwNQ==", "bodyText": "IMO this is too abstract, it wouldn't be much longer if everything was inlined:\n      GlobalTransaction gtx = localTx.getGlobalTransaction();\n      if (commit) {\n         localTx.clearLookedUpEntries();\n         return txCoordinator.prepare(localTx, true)\n                             .thenCompose(ignore -> txCoordinator.commit(localTx, false))\n                             .thenCompose(ignore -> removeRecoveryInformation(null, xid, gtx, false))\n                             .thenApply(ignore -> \"Commit successful!\")\n                             .exceptionally(t -> {\n                                log.warnCouldNotCommitLocalTx(localTx, t);\n                                return \"Could not commit transaction \" + xid + \" : \" + t.getMessage();\n                             });\n      } else {\n         return txCoordinator.rollback(localTx)\n                             .thenCompose(ignore -> removeRecoveryInformation(null, xid, gtx, false))\n                             .thenApply(ignore -> \"Rollback successful\")\n                             .exceptionally(t -> {\n                                log.warnCouldNotRollbackLocalTx(localTx, t);\n                                return \"Could not rollback transaction \" + xid + \" : \" + t.getMessage();\n                             });\n      }", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395725005", "createdAt": "2020-03-20T15:45:29Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java", "diffHunk": "@@ -305,26 +312,29 @@ public String forceTransactionCompletion(Xid xid, boolean commit) {\n       }\n    }\n \n-   private String completeTransaction(LocalTransaction localTx, boolean commit, Xid xid) {\n+   private CompletionStage<String> completeTransaction(LocalTransaction localTx, boolean commit, Xid xid) {\n+      CompletionStage<?> stage;\n+      Function<Throwable, String> errorTranslation;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdefde6f70556b8d6666f4038d0085bfadeffb0b"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTczMzQxNQ==", "bodyText": "It's so weird that it wasn't a problem before, I have to debug the test to see how it's passing on master :)", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395733415", "createdAt": "2020-03-20T15:58:10Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/commands/GetAllCommandNodeCrashTest.java", "diffHunk": "@@ -41,6 +43,7 @@ public void test() throws Exception {\n       cache(2).put(key, \"value\");\n \n       ControlledRpcManager rpcManager = ControlledRpcManager.replaceRpcManager(cache(2));\n+      rpcManager.excludeCommands(StateResponseCommand.class, StateTransferStartCommand.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdefde6f70556b8d6666f4038d0085bfadeffb0b"}, "originalPosition": 13}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fdefde6f70556b8d6666f4038d0085bfadeffb0b", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/fdefde6f70556b8d6666f4038d0085bfadeffb0b", "committedDate": "2020-03-20T12:42:01Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}, "afterCommit": {"oid": "f1610673eb296c5cb60579b40ce1b024044ed2f4", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/f1610673eb296c5cb60579b40ce1b024044ed2f4", "committedDate": "2020-03-20T16:51:56Z", "message": "rework comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f1610673eb296c5cb60579b40ce1b024044ed2f4", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/f1610673eb296c5cb60579b40ce1b024044ed2f4", "committedDate": "2020-03-20T16:51:56Z", "message": "rework comments"}, "afterCommit": {"oid": "d02878704874e5aee0840e227a8a1d1d554321cd", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/d02878704874e5aee0840e227a8a1d1d554321cd", "committedDate": "2020-03-20T16:58:47Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d02878704874e5aee0840e227a8a1d1d554321cd", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/d02878704874e5aee0840e227a8a1d1d554321cd", "committedDate": "2020-03-20T16:58:47Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}, "afterCommit": {"oid": "7010d9595ad27759c856085b70a23cdb08037080", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/7010d9595ad27759c856085b70a23cdb08037080", "committedDate": "2020-03-20T17:01:51Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NzI4MDIw", "url": "https://github.com/infinispan/infinispan/pull/7997#pullrequestreview-378728020", "createdAt": "2020-03-20T18:40:04Z", "commit": {"oid": "7010d9595ad27759c856085b70a23cdb08037080"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODo0MDowNFrOF5fQSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODo0MDowNFrOF5fQSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTIyNg==", "bodyText": "No need for handleAndCompose", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395825226", "createdAt": "2020-03-20T18:40:04Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java", "diffHunk": "@@ -99,92 +107,116 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n       }\n    }\n \n-   public final int prepare(LocalTransaction localTransaction) throws XAException {\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction) {\n       return prepare(localTransaction, false);\n    }\n \n-   public final int prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) throws XAException {\n-      validateNotMarkedForRollback(localTransaction);\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) {\n+      CompletionStage<Integer> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+      if (markRollbackStage != null) {\n+         return markRollbackStage;\n+      }\n \n       if (isOnePhaseCommit(localTransaction)) {\n          if (trace) log.tracef(\"Received prepare for tx: %s. Skipping call as 1PC will be used.\", localTransaction);\n-         return XA_OK;\n+         return XA_OKAY_STAGE;\n       }\n \n       PrepareCommand prepareCommand = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), localTransaction.getModifications(), false);\n       if (trace) log.tracef(\"Sending prepare command through the chain: %s\", prepareCommand);\n \n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       prepareCommand.setReplayEntryWrapping(replayEntryWrapping);\n-      try {\n-         invoker.running().invoke(ctx, prepareCommand);\n+      CompletionStage<Object> prepareStage = invoker.running().invokeAsync(ctx, prepareCommand);\n+      return CompletionStages.handleAndCompose(prepareStage, (ignore, prepareThrowable) -> {\n+         if (prepareThrowable != null) {\n+            if (shuttingDown)\n+               log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n+            else\n+               log.errorProcessingPrepare(prepareThrowable);\n+\n+            //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n+            //after prepare failed.\n+            return CompletionStages.handleAndCompose(rollback(localTransaction), (ignore2, rollbackThrowable) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7010d9595ad27759c856085b70a23cdb08037080"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NzI4NTAw", "url": "https://github.com/infinispan/infinispan/pull/7997#pullrequestreview-378728500", "createdAt": "2020-03-20T18:40:46Z", "commit": {"oid": "7010d9595ad27759c856085b70a23cdb08037080"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODo0MDo0NlrOF5fRuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODo0MDo0NlrOF5fRuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgyNTU5NQ==", "bodyText": "No need for try..catch", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395825595", "createdAt": "2020-03-20T18:40:46Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/transaction/impl/TransactionCoordinator.java", "diffHunk": "@@ -99,92 +107,116 @@ public PrepareCommand createPrepareCommand(GlobalTransaction gtx, List<WriteComm\n       }\n    }\n \n-   public final int prepare(LocalTransaction localTransaction) throws XAException {\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction) {\n       return prepare(localTransaction, false);\n    }\n \n-   public final int prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) throws XAException {\n-      validateNotMarkedForRollback(localTransaction);\n+   public final CompletionStage<Integer> prepare(LocalTransaction localTransaction, boolean replayEntryWrapping) {\n+      CompletionStage<Integer> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+      if (markRollbackStage != null) {\n+         return markRollbackStage;\n+      }\n \n       if (isOnePhaseCommit(localTransaction)) {\n          if (trace) log.tracef(\"Received prepare for tx: %s. Skipping call as 1PC will be used.\", localTransaction);\n-         return XA_OK;\n+         return XA_OKAY_STAGE;\n       }\n \n       PrepareCommand prepareCommand = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), localTransaction.getModifications(), false);\n       if (trace) log.tracef(\"Sending prepare command through the chain: %s\", prepareCommand);\n \n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       prepareCommand.setReplayEntryWrapping(replayEntryWrapping);\n-      try {\n-         invoker.running().invoke(ctx, prepareCommand);\n+      CompletionStage<Object> prepareStage = invoker.running().invokeAsync(ctx, prepareCommand);\n+      return CompletionStages.handleAndCompose(prepareStage, (ignore, prepareThrowable) -> {\n+         if (prepareThrowable != null) {\n+            if (shuttingDown)\n+               log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n+            else\n+               log.errorProcessingPrepare(prepareThrowable);\n+\n+            //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n+            //after prepare failed.\n+            return CompletionStages.handleAndCompose(rollback(localTransaction), (ignore2, rollbackThrowable) -> {\n+               // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n+               XAException xe = new XAException(XAException.XA_RBROLLBACK);\n+               if (rollbackThrowable != null) {\n+                  rollbackThrowable.addSuppressed(prepareThrowable);\n+                  xe.initCause(rollbackThrowable);\n+               } else {\n+                  xe.initCause(prepareThrowable);\n+               }\n+               return CompletableFutures.completedExceptionFuture(xe);\n+            });\n+         }\n          if (localTransaction.isReadOnly()) {\n             if (trace) log.tracef(\"Readonly transaction: %s\", localTransaction.getGlobalTransaction());\n             // force a cleanup to release any objects held.  Some TMs don't call commit if it is a READ ONLY tx.  See ISPN-845\n-            commitInternal(ctx);\n-            return XA_RDONLY;\n+            return commitInternal(ctx)\n+                  .thenApply(XA_RDONLY_APPLY);\n          } else {\n             txTable.running().localTransactionPrepared(localTransaction);\n-            return XA_OK;\n+            return XA_OKAY_STAGE;\n          }\n-      } catch (Throwable e) {\n-         if (shuttingDown)\n-            log.trace(\"Exception while preparing back, probably because we're shutting down.\");\n-         else\n-            log.errorProcessingPrepare(e);\n-\n-         //rollback transaction before throwing the exception as there's no guarantee the TM calls XAResource.rollback\n-         //after prepare failed.\n-         rollback(localTransaction);\n-         // XA_RBROLLBACK tells the TM that we've rolled back already: the TM shouldn't call rollback after this.\n-         XAException xe = new XAException(XAException.XA_RBROLLBACK);\n-         xe.initCause(e);\n-         throw xe;\n-      }\n+      });\n    }\n \n-   public boolean commit(LocalTransaction localTransaction, boolean isOnePhase) throws XAException {\n+   public CompletionStage<Boolean> commit(LocalTransaction localTransaction, boolean isOnePhase) {\n       if (trace) log.tracef(\"Committing transaction %s\", localTransaction.getGlobalTransaction());\n       LocalTxInvocationContext ctx = icf.running().createTxInvocationContext(localTransaction);\n       if (isOnePhaseCommit(localTransaction) || isOnePhase) {\n-         validateNotMarkedForRollback(localTransaction);\n+         CompletionStage<Boolean> markRollbackStage = validateNotMarkedForRollback(localTransaction);\n+         if (markRollbackStage != null) {\n+            return markRollbackStage;\n+         }\n \n          if (trace) log.trace(\"Doing an 1PC prepare call on the interceptor chain\");\n          List<WriteCommand> modifications = localTransaction.getModifications();\n          PrepareCommand command = commandCreator.createPrepareCommand(localTransaction.getGlobalTransaction(), modifications, true);\n          try {\n-            invoker.running().invoke(ctx, command);\n+            return CompletionStages.handleAndCompose(invoker.running().invokeAsync(ctx, command),\n+                  (ignore, t) -> {\n+                     if (t != null) {\n+                        return handleCommitFailure(t, true, ctx);\n+                     }\n+                     return CompletableFutures.completedTrue();\n+                  });\n          } catch (Throwable e) {\n-            handleCommitFailure(e, true, ctx);\n+            return handleCommitFailure(e, true, ctx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7010d9595ad27759c856085b70a23cdb08037080"}, "originalPosition": 135}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NzM2NjUx", "url": "https://github.com/infinispan/infinispan/pull/7997#pullrequestreview-378736651", "createdAt": "2020-03-20T18:53:29Z", "commit": {"oid": "7010d9595ad27759c856085b70a23cdb08037080"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODo1MzoyOVrOF5fqfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODo1MzoyOVrOF5fqfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzMTkzMg==", "bodyText": "Could have moved more common code here, e.g.\n  return CompletionStages.join(CompletableFutures.completedNull()\n        .thenComposeAsync(consumer, executor));", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395831932", "createdAt": "2020-03-20T18:53:29Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/transaction/xa/TransactionXaAdapter.java", "diffHunk": "@@ -177,4 +191,16 @@ public boolean equals(Object o) {\n    private boolean isFlag(int value, int flag) {\n       return (value & flag) != 0;\n    }\n+\n+   private <T> T joinAndRethrowXAException(CompletionStage<T> stage) throws XAException {\n+      try {\n+         return CompletionStages.join(stage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7010d9595ad27759c856085b70a23cdb08037080"}, "originalPosition": 89}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7010d9595ad27759c856085b70a23cdb08037080", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/7010d9595ad27759c856085b70a23cdb08037080", "committedDate": "2020-03-20T17:01:51Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}, "afterCommit": {"oid": "3173ad9f37dea0b47869ebe53bfb4a52ad870b61", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/3173ad9f37dea0b47869ebe53bfb4a52ad870b61", "committedDate": "2020-03-20T19:09:21Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3173ad9f37dea0b47869ebe53bfb4a52ad870b61", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/3173ad9f37dea0b47869ebe53bfb4a52ad870b61", "committedDate": "2020-03-20T19:09:21Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}, "afterCommit": {"oid": "514d861666a6c3e1d7f874a41c3abb8b6c1b38e8", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/514d861666a6c3e1d7f874a41c3abb8b6c1b38e8", "committedDate": "2020-03-20T19:11:06Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "514d861666a6c3e1d7f874a41c3abb8b6c1b38e8", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/514d861666a6c3e1d7f874a41c3abb8b6c1b38e8", "committedDate": "2020-03-20T19:11:06Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}, "afterCommit": {"oid": "6030cc125086a6b25768497a0e33d56fa849c4fe", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/6030cc125086a6b25768497a0e33d56fa849c4fe", "committedDate": "2020-03-20T19:12:52Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NzU0NTA5", "url": "https://github.com/infinispan/infinispan/pull/7997#pullrequestreview-378754509", "createdAt": "2020-03-20T19:22:31Z", "commit": {"oid": "6030cc125086a6b25768497a0e33d56fa849c4fe"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxOToyMjozMVrOF5gf1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxOToyMjozMVrOF5gf1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg0NTU4OA==", "bodyText": "Don't need to wait for the tx completion responses before removing the local info here either, although since removing the local info is expensive you could still send the command first.", "url": "https://github.com/infinispan/infinispan/pull/7997#discussion_r395845588", "createdAt": "2020-03-20T19:22:31Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/transaction/xa/recovery/RecoveryManagerImpl.java", "diffHunk": "@@ -128,38 +129,43 @@ public RecoveryIterator getPreparedTransactionsFromCluster() {\n    }\n \n    @Override\n-   public void removeRecoveryInformation(Collection<Address> lockOwners, Xid xid, boolean sync, GlobalTransaction gtx,\n+   public CompletionStage<Void> removeRecoveryInformation(Collection<Address> lockOwners, Xid xid, GlobalTransaction gtx,\n                                          boolean fromCluster) {\n       log.tracef(\"Forgetting tx information for %s\", gtx);\n       //todo make sure this gets broad casted or at least flushed\n       if (rpcManager != null && !fromCluster) {\n          TxCompletionNotificationCommand ftc = commandFactory.buildTxCompletionNotificationCommand(xid, gtx);\n-         sendTxCompletionNotification(lockOwners, ftc, sync);\n+         removeRecoveryInformation(xid);\n+         return sendTxCompletionNotification(lockOwners, ftc);\n+      } else {\n+         removeRecoveryInformation(xid);\n+         return CompletableFutures.completedNull();\n       }\n-      removeRecoveryInformation(xid);\n    }\n \n    @Override\n-   public void removeRecoveryInformationFromCluster(Collection<Address> where, long internalId, boolean sync) {\n+   public CompletionStage<Void> removeRecoveryInformationFromCluster(Collection<Address> where, long internalId) {\n       if (rpcManager != null) {\n          TxCompletionNotificationCommand ftc = commandFactory.buildTxCompletionNotificationCommand(internalId);\n-         sendTxCompletionNotification(where, ftc, sync);\n+         CompletionStage<Void> stage = sendTxCompletionNotification(where, ftc);\n+         return stage.thenRun(() -> removeRecoveryInformation(internalId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6030cc125086a6b25768497a0e33d56fa849c4fe"}, "originalPosition": 48}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "553b36dca7563b374d719d761567263767d83f4b", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/553b36dca7563b374d719d761567263767d83f4b", "committedDate": "2020-03-20T20:54:58Z", "message": "ISPN-11489 TransactionCoordinator updated for non blocking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b352ff46b2be9073a02be60700a174287da92915", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/b352ff46b2be9073a02be60700a174287da92915", "committedDate": "2020-03-20T20:54:58Z", "message": "ISPN-11385 Convert Remote Command Executor to Non blocking/blocking thread executor\n\n* Invoke commands that block on blocking executor\n* Invoke other commands by caller\n* Use non blocking executor instead of remote in other places"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0caa5b70c4753a36e746f2d70097f26e762a0fb6", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/0caa5b70c4753a36e746f2d70097f26e762a0fb6", "committedDate": "2020-03-20T20:54:59Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6030cc125086a6b25768497a0e33d56fa849c4fe", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/6030cc125086a6b25768497a0e33d56fa849c4fe", "committedDate": "2020-03-20T19:12:52Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}, "afterCommit": {"oid": "0caa5b70c4753a36e746f2d70097f26e762a0fb6", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/0caa5b70c4753a36e746f2d70097f26e762a0fb6", "committedDate": "2020-03-20T20:54:59Z", "message": "ISPN-11473 InvocationHelper should commit or rollback the transaction on a blocking thread"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1066, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}