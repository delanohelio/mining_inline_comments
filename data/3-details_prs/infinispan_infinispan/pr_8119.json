{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0OTcxNDQ5", "number": 8119, "title": "ISPN-11543 Add BlockingHandler to simplify running blocking operations", "bodyText": "https://issues.redhat.com/browse/ISPN-11543\nhttps://issues.redhat.com/browse/ISPN-11524\nhttps://issues.redhat.com/browse/ISPN-11703", "createdAt": "2020-03-27T21:11:53Z", "url": "https://github.com/infinispan/infinispan/pull/8119", "merged": true, "mergeCommit": {"oid": "bc190c53176faa1824c1ed81afdde785feb1dc09"}, "closed": true, "closedAt": "2020-04-27T17:09:48Z", "author": {"login": "wburns"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcS1IftABqjMxODA1MTIxNTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcbxUbfABqjMyNzY0Mjg0MDA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "74efc69646d57b960c93e667522b4482870fe09c", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/74efc69646d57b960c93e667522b4482870fe09c", "committedDate": "2020-03-27T23:07:15Z", "message": "additional test fixes"}, "afterCommit": {"oid": "184c864f2c16a5f32b0e45f1cab0776c66d9b735", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/184c864f2c16a5f32b0e45f1cab0776c66d9b735", "committedDate": "2020-03-30T21:10:39Z", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NTA4MjMx", "url": "https://github.com/infinispan/infinispan/pull/8119#pullrequestreview-395508231", "createdAt": "2020-04-17T14:33:31Z", "commit": {"oid": "2a5f5a744eb8d19e6da70590206047c8f02d0fc9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNDozMzozMlrOGHQhSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNDozMzozMlrOGHQhSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI2Mzg4MA==", "bodyText": "Should only be if stage is also complete.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r410263880", "createdAt": "2020-04-17T14:33:32Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.commons.executors.BlockingResource;\n+import org.infinispan.commons.executors.NonBlockingResource;\n+import org.infinispan.executors.LimitedExecutor;\n+import org.infinispan.factories.KnownComponentNames;\n+import org.infinispan.factories.annotations.ComponentName;\n+import org.infinispan.factories.annotations.Inject;\n+import org.infinispan.factories.annotations.Start;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.Flowable;\n+import io.reactivex.Scheduler;\n+import io.reactivex.schedulers.Schedulers;\n+\n+@Scope(Scopes.GLOBAL)\n+public class BlockingHandler {\n+   private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass());\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   @Inject @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR)\n+   Executor nonBlockingExecutor;\n+   // This should eventually be the only reference to blocking executor\n+   @SuppressWarnings(\"checkstyle:RegexpSinglelineJava\")\n+   @Inject @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR)\n+   Executor blockingExecutor;\n+\n+   Scheduler blockingScheduler;\n+   Scheduler nonBlockingScheduler;\n+\n+   @Start\n+   protected void start() {\n+      blockingScheduler = Schedulers.from(blockingExecutor);\n+      nonBlockingScheduler = Schedulers.from(nonBlockingExecutor);\n+   }\n+\n+   public CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked run on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            runnable.run();\n+            return CompletableFutures.completedNull();\n+         } catch (Throwable t) {\n+            return CompletableFutures.completedExceptionFuture(t);\n+         }\n+      }\n+      CompletionStage<Void> stage;\n+      if (trace) {\n+         log.tracef(\"Submitting blocking run operation %s to blocking thread\", traceId);\n+         stage = CompletableFuture.runAsync(() -> {\n+            log.tracef(\"Running blocking run operation %s\", traceId);\n+            runnable.run();\n+         }, blockingExecutor);\n+      } else {\n+         stage = CompletableFuture.runAsync(runnable, blockingExecutor);\n+      }\n+      return continueOnNonBlockingThread(stage, traceId);\n+   }\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   public <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked supply on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            return CompletableFuture.completedFuture(supplier.get());\n+         } catch (Throwable t) {\n+            return CompletableFutures.completedExceptionFuture(t);\n+         }\n+      }\n+      CompletionStage<V> stage;\n+      if (trace) {\n+         log.tracef(\"Submitting blocking supply operation %s to blocking thread\", traceId);\n+         stage = CompletableFuture.supplyAsync(() -> {\n+            log.tracef(\"Running blocking supply operation %s\", traceId);\n+            return supplier.get();\n+         }, blockingExecutor);\n+      } else {\n+         stage = CompletableFuture.supplyAsync(supplier, blockingExecutor);\n+      }\n+      return continueOnNonBlockingThread(stage, traceId);\n+   }\n+\n+   /**\n+    * Similar to CompletionStage#handle\n+    * @param stage\n+    * @param function\n+    * @param traceId\n+    * @param <I>\n+    * @param <O>\n+    * @return\n+    */\n+   public <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId) {\n+      if (isCurrentThreadBlocking()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a5f5a744eb8d19e6da70590206047c8f02d0fc9"}, "originalPosition": 122}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NTA4MzY3", "url": "https://github.com/infinispan/infinispan/pull/8119#pullrequestreview-395508367", "createdAt": "2020-04-17T14:33:39Z", "commit": {"oid": "2a5f5a744eb8d19e6da70590206047c8f02d0fc9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNDozMzo0MFrOGHQhnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNDozMzo0MFrOGHQhnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI2Mzk2NA==", "bodyText": "Should only be if stage is also complete. Or maybe it should join the stage if not complete?", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r410263964", "createdAt": "2020-04-17T14:33:40Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.commons.executors.BlockingResource;\n+import org.infinispan.commons.executors.NonBlockingResource;\n+import org.infinispan.executors.LimitedExecutor;\n+import org.infinispan.factories.KnownComponentNames;\n+import org.infinispan.factories.annotations.ComponentName;\n+import org.infinispan.factories.annotations.Inject;\n+import org.infinispan.factories.annotations.Start;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.Flowable;\n+import io.reactivex.Scheduler;\n+import io.reactivex.schedulers.Schedulers;\n+\n+@Scope(Scopes.GLOBAL)\n+public class BlockingHandler {\n+   private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass());\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   @Inject @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR)\n+   Executor nonBlockingExecutor;\n+   // This should eventually be the only reference to blocking executor\n+   @SuppressWarnings(\"checkstyle:RegexpSinglelineJava\")\n+   @Inject @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR)\n+   Executor blockingExecutor;\n+\n+   Scheduler blockingScheduler;\n+   Scheduler nonBlockingScheduler;\n+\n+   @Start\n+   protected void start() {\n+      blockingScheduler = Schedulers.from(blockingExecutor);\n+      nonBlockingScheduler = Schedulers.from(nonBlockingExecutor);\n+   }\n+\n+   public CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked run on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            runnable.run();\n+            return CompletableFutures.completedNull();\n+         } catch (Throwable t) {\n+            return CompletableFutures.completedExceptionFuture(t);\n+         }\n+      }\n+      CompletionStage<Void> stage;\n+      if (trace) {\n+         log.tracef(\"Submitting blocking run operation %s to blocking thread\", traceId);\n+         stage = CompletableFuture.runAsync(() -> {\n+            log.tracef(\"Running blocking run operation %s\", traceId);\n+            runnable.run();\n+         }, blockingExecutor);\n+      } else {\n+         stage = CompletableFuture.runAsync(runnable, blockingExecutor);\n+      }\n+      return continueOnNonBlockingThread(stage, traceId);\n+   }\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   public <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked supply on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            return CompletableFuture.completedFuture(supplier.get());\n+         } catch (Throwable t) {\n+            return CompletableFutures.completedExceptionFuture(t);\n+         }\n+      }\n+      CompletionStage<V> stage;\n+      if (trace) {\n+         log.tracef(\"Submitting blocking supply operation %s to blocking thread\", traceId);\n+         stage = CompletableFuture.supplyAsync(() -> {\n+            log.tracef(\"Running blocking supply operation %s\", traceId);\n+            return supplier.get();\n+         }, blockingExecutor);\n+      } else {\n+         stage = CompletableFuture.supplyAsync(supplier, blockingExecutor);\n+      }\n+      return continueOnNonBlockingThread(stage, traceId);\n+   }\n+\n+   /**\n+    * Similar to CompletionStage#handle\n+    * @param stage\n+    * @param function\n+    * @param traceId\n+    * @param <I>\n+    * @param <O>\n+    * @return\n+    */\n+   public <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked handle on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         return stage.handle(function);\n+      }\n+      return continueOnNonBlockingThread(stage.handleAsync(function, blockingExecutor), traceId);\n+   }\n+\n+   /**\n+    * Similar to CompletionStage#thenApply\n+    * @param stage\n+    * @param function\n+    * @param traceId\n+    * @param <I>\n+    * @param <O>\n+    * @return\n+    */\n+   public <I, O> CompletionStage<O> thenApplyBlocking(CompletionStage<? extends I> stage,\n+         Function<? super I, ? extends O> function, Object traceId) {\n+      if (isCurrentThreadBlocking()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a5f5a744eb8d19e6da70590206047c8f02d0fc9"}, "originalPosition": 142}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NTA4NDIz", "url": "https://github.com/infinispan/infinispan/pull/8119#pullrequestreview-395508423", "createdAt": "2020-04-17T14:33:44Z", "commit": {"oid": "2a5f5a744eb8d19e6da70590206047c8f02d0fc9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNDozMzo0NFrOGHQh0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNDozMzo0NFrOGHQh0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI2NDAxNw==", "bodyText": "Should only be if stage is also complete.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r410264017", "createdAt": "2020-04-17T14:33:44Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.commons.executors.BlockingResource;\n+import org.infinispan.commons.executors.NonBlockingResource;\n+import org.infinispan.executors.LimitedExecutor;\n+import org.infinispan.factories.KnownComponentNames;\n+import org.infinispan.factories.annotations.ComponentName;\n+import org.infinispan.factories.annotations.Inject;\n+import org.infinispan.factories.annotations.Start;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.Flowable;\n+import io.reactivex.Scheduler;\n+import io.reactivex.schedulers.Schedulers;\n+\n+@Scope(Scopes.GLOBAL)\n+public class BlockingHandler {\n+   private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass());\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   @Inject @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR)\n+   Executor nonBlockingExecutor;\n+   // This should eventually be the only reference to blocking executor\n+   @SuppressWarnings(\"checkstyle:RegexpSinglelineJava\")\n+   @Inject @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR)\n+   Executor blockingExecutor;\n+\n+   Scheduler blockingScheduler;\n+   Scheduler nonBlockingScheduler;\n+\n+   @Start\n+   protected void start() {\n+      blockingScheduler = Schedulers.from(blockingExecutor);\n+      nonBlockingScheduler = Schedulers.from(nonBlockingExecutor);\n+   }\n+\n+   public CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked run on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            runnable.run();\n+            return CompletableFutures.completedNull();\n+         } catch (Throwable t) {\n+            return CompletableFutures.completedExceptionFuture(t);\n+         }\n+      }\n+      CompletionStage<Void> stage;\n+      if (trace) {\n+         log.tracef(\"Submitting blocking run operation %s to blocking thread\", traceId);\n+         stage = CompletableFuture.runAsync(() -> {\n+            log.tracef(\"Running blocking run operation %s\", traceId);\n+            runnable.run();\n+         }, blockingExecutor);\n+      } else {\n+         stage = CompletableFuture.runAsync(runnable, blockingExecutor);\n+      }\n+      return continueOnNonBlockingThread(stage, traceId);\n+   }\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   public <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked supply on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            return CompletableFuture.completedFuture(supplier.get());\n+         } catch (Throwable t) {\n+            return CompletableFutures.completedExceptionFuture(t);\n+         }\n+      }\n+      CompletionStage<V> stage;\n+      if (trace) {\n+         log.tracef(\"Submitting blocking supply operation %s to blocking thread\", traceId);\n+         stage = CompletableFuture.supplyAsync(() -> {\n+            log.tracef(\"Running blocking supply operation %s\", traceId);\n+            return supplier.get();\n+         }, blockingExecutor);\n+      } else {\n+         stage = CompletableFuture.supplyAsync(supplier, blockingExecutor);\n+      }\n+      return continueOnNonBlockingThread(stage, traceId);\n+   }\n+\n+   /**\n+    * Similar to CompletionStage#handle\n+    * @param stage\n+    * @param function\n+    * @param traceId\n+    * @param <I>\n+    * @param <O>\n+    * @return\n+    */\n+   public <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked handle on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         return stage.handle(function);\n+      }\n+      return continueOnNonBlockingThread(stage.handleAsync(function, blockingExecutor), traceId);\n+   }\n+\n+   /**\n+    * Similar to CompletionStage#thenApply\n+    * @param stage\n+    * @param function\n+    * @param traceId\n+    * @param <I>\n+    * @param <O>\n+    * @return\n+    */\n+   public <I, O> CompletionStage<O> thenApplyBlocking(CompletionStage<? extends I> stage,\n+         Function<? super I, ? extends O> function, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked handle on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         return stage.thenApply(function);\n+      }\n+      return continueOnNonBlockingThread(stage.thenApplyAsync(function, blockingExecutor), traceId);\n+   }\n+\n+   /**\n+    *\n+    * @param stage\n+    * @param biConsumer\n+    * @param traceId\n+    * @param <V>\n+    * @return\n+    */\n+   public <V> CompletionStage<V> whenCompleteBlocking(CompletionStage<V> stage,\n+         BiConsumer<? super V, ? super Throwable> biConsumer, Object traceId) {\n+      if (isCurrentThreadBlocking()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a5f5a744eb8d19e6da70590206047c8f02d0fc9"}, "originalPosition": 161}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NTE3OTc4", "url": "https://github.com/infinispan/infinispan/pull/8119#pullrequestreview-395517978", "createdAt": "2020-04-17T14:44:48Z", "commit": {"oid": "2a5f5a744eb8d19e6da70590206047c8f02d0fc9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNDo0NDo0OFrOGHQ90Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNDo0NDo0OFrOGHQ90Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDI3MTE4NQ==", "bodyText": "I am not sure about the inclusion of isCurrentThreadNonBlocking() here.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r410271185", "createdAt": "2020-04-17T14:44:48Z", "author": {"login": "wburns"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,268 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.commons.executors.BlockingResource;\n+import org.infinispan.commons.executors.NonBlockingResource;\n+import org.infinispan.executors.LimitedExecutor;\n+import org.infinispan.factories.KnownComponentNames;\n+import org.infinispan.factories.annotations.ComponentName;\n+import org.infinispan.factories.annotations.Inject;\n+import org.infinispan.factories.annotations.Start;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.Flowable;\n+import io.reactivex.Scheduler;\n+import io.reactivex.schedulers.Schedulers;\n+\n+@Scope(Scopes.GLOBAL)\n+public class BlockingHandler {\n+   private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass());\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   @Inject @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR)\n+   Executor nonBlockingExecutor;\n+   // This should eventually be the only reference to blocking executor\n+   @SuppressWarnings(\"checkstyle:RegexpSinglelineJava\")\n+   @Inject @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR)\n+   Executor blockingExecutor;\n+\n+   Scheduler blockingScheduler;\n+   Scheduler nonBlockingScheduler;\n+\n+   @Start\n+   protected void start() {\n+      blockingScheduler = Schedulers.from(blockingExecutor);\n+      nonBlockingScheduler = Schedulers.from(nonBlockingExecutor);\n+   }\n+\n+   public CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked run on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            runnable.run();\n+            return CompletableFutures.completedNull();\n+         } catch (Throwable t) {\n+            return CompletableFutures.completedExceptionFuture(t);\n+         }\n+      }\n+      CompletionStage<Void> stage;\n+      if (trace) {\n+         log.tracef(\"Submitting blocking run operation %s to blocking thread\", traceId);\n+         stage = CompletableFuture.runAsync(() -> {\n+            log.tracef(\"Running blocking run operation %s\", traceId);\n+            runnable.run();\n+         }, blockingExecutor);\n+      } else {\n+         stage = CompletableFuture.runAsync(runnable, blockingExecutor);\n+      }\n+      return continueOnNonBlockingThread(stage, traceId);\n+   }\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   public <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked supply on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         try {\n+            return CompletableFuture.completedFuture(supplier.get());\n+         } catch (Throwable t) {\n+            return CompletableFutures.completedExceptionFuture(t);\n+         }\n+      }\n+      CompletionStage<V> stage;\n+      if (trace) {\n+         log.tracef(\"Submitting blocking supply operation %s to blocking thread\", traceId);\n+         stage = CompletableFuture.supplyAsync(() -> {\n+            log.tracef(\"Running blocking supply operation %s\", traceId);\n+            return supplier.get();\n+         }, blockingExecutor);\n+      } else {\n+         stage = CompletableFuture.supplyAsync(supplier, blockingExecutor);\n+      }\n+      return continueOnNonBlockingThread(stage, traceId);\n+   }\n+\n+   /**\n+    * Similar to CompletionStage#handle\n+    * @param stage\n+    * @param function\n+    * @param traceId\n+    * @param <I>\n+    * @param <O>\n+    * @return\n+    */\n+   public <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked handle on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         return stage.handle(function);\n+      }\n+      return continueOnNonBlockingThread(stage.handleAsync(function, blockingExecutor), traceId);\n+   }\n+\n+   /**\n+    * Similar to CompletionStage#thenApply\n+    * @param stage\n+    * @param function\n+    * @param traceId\n+    * @param <I>\n+    * @param <O>\n+    * @return\n+    */\n+   public <I, O> CompletionStage<O> thenApplyBlocking(CompletionStage<? extends I> stage,\n+         Function<? super I, ? extends O> function, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked handle on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         return stage.thenApply(function);\n+      }\n+      return continueOnNonBlockingThread(stage.thenApplyAsync(function, blockingExecutor), traceId);\n+   }\n+\n+   /**\n+    *\n+    * @param stage\n+    * @param biConsumer\n+    * @param traceId\n+    * @param <V>\n+    * @return\n+    */\n+   public <V> CompletionStage<V> whenCompleteBlocking(CompletionStage<V> stage,\n+         BiConsumer<? super V, ? super Throwable> biConsumer, Object traceId) {\n+      if (isCurrentThreadBlocking()) {\n+         if (trace) {\n+            log.tracef(\"Invoked whenComplete on a blocking thread, running %s in same blocking thread\", traceId);\n+         }\n+         return stage.whenComplete(biConsumer);\n+      }\n+      return continueOnNonBlockingThread(stage.whenCompleteAsync(biConsumer, blockingExecutor), traceId);\n+   }\n+\n+   /**\n+    * When the provided stage is complete, continue the completion chain of the returned CompletionStage on the\n+    * supplied executor. If tracing is enabled a trace message is printed using the object as an identifier to more\n+    * easily track the transition between threads.\n+    * <p>\n+    * This method is useful when an asynchronous computation completes and you do not want to run further processing\n+    * on the thread that returned it. An example may be that some blocking operation is performed on a special blocking\n+    * thread pool. However when the blocking operation completes we will want to continue the processing of that result\n+    * in a thread pool that is for computational tasks.\n+    * <p>\n+    * If the supplied stage is already completed when invoking this command, this will return an already completed\n+    * stage, which means any additional dependent stages will run in the invoking thread.\n+    * @param <V> return value type of the supplied stage\n+    * @param delay the stage to delay the continuation until complete\n+    * @param traceId the id to print when tracing is enabled\n+    * @return a CompletionStage that when depended upon will run any callback in the supplied executor\n+    */\n+   public <V> CompletionStage<V> continueOnNonBlockingThread(CompletionStage<V> delay, Object traceId) {\n+      if (CompletionStages.isCompletedSuccessfully(delay) && isCurrentThreadNonBlocking()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a5f5a744eb8d19e6da70590206047c8f02d0fc9"}, "originalPosition": 188}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "184c864f2c16a5f32b0e45f1cab0776c66d9b735", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/184c864f2c16a5f32b0e45f1cab0776c66d9b735", "committedDate": "2020-03-30T21:10:39Z", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block"}, "afterCommit": {"oid": "d0534e4b41e5ca5422540005957dc7dce1526a82", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/d0534e4b41e5ca5422540005957dc7dce1526a82", "committedDate": "2020-04-17T18:26:14Z", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d0534e4b41e5ca5422540005957dc7dce1526a82", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/d0534e4b41e5ca5422540005957dc7dce1526a82", "committedDate": "2020-04-17T18:26:14Z", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block"}, "afterCommit": {"oid": "2d30d88a6415b95e9c344fc4d9a724d7dbf10477", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/2d30d88a6415b95e9c344fc4d9a724d7dbf10477", "committedDate": "2020-04-17T19:54:19Z", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2d30d88a6415b95e9c344fc4d9a724d7dbf10477", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/2d30d88a6415b95e9c344fc4d9a724d7dbf10477", "committedDate": "2020-04-17T19:54:19Z", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block"}, "afterCommit": {"oid": "255d3766f0b327e70d3f0790c0594fac2b9325a3", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/255d3766f0b327e70d3f0790c0594fac2b9325a3", "committedDate": "2020-04-20T17:16:00Z", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "255d3766f0b327e70d3f0790c0594fac2b9325a3", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/255d3766f0b327e70d3f0790c0594fac2b9325a3", "committedDate": "2020-04-20T17:16:00Z", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block"}, "afterCommit": {"oid": "297094aeb62968af80379ea9e7aed0f635900133", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/297094aeb62968af80379ea9e7aed0f635900133", "committedDate": "2020-04-20T17:23:55Z", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "297094aeb62968af80379ea9e7aed0f635900133", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/297094aeb62968af80379ea9e7aed0f635900133", "committedDate": "2020-04-20T17:23:55Z", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block"}, "afterCommit": {"oid": "eb4088f58c883681070c4a11082632e51068b03b", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/eb4088f58c883681070c4a11082632e51068b03b", "committedDate": "2020-04-20T17:32:00Z", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eb4088f58c883681070c4a11082632e51068b03b", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/eb4088f58c883681070c4a11082632e51068b03b", "committedDate": "2020-04-20T17:32:00Z", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block"}, "afterCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "committedDate": "2020-04-22T15:12:57Z", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MzI4NjIw", "url": "https://github.com/infinispan/infinispan/pull/8119#pullrequestreview-397328620", "createdAt": "2020-04-21T13:27:50Z", "commit": {"oid": "eb4088f58c883681070c4a11082632e51068b03b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzoyNzo1MFrOGJFsZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNjo0Njo0MlrOGKx9gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE4MzY1NA==", "bodyText": "Since this is in the loom source directory, I assume it will return false for a build of OpenJDK 15 without Loom, which would make the name misleading.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r412183654", "createdAt": "2020-04-21T13:27:50Z", "author": {"login": "danberindei"}, "path": "commons/loom/src/main/java/org/infinispan/commons/jdkspecific/JREVersion.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package org.infinispan.commons.jdkspecific;\n+\n+public class JREVersion {\n+   private JREVersion() { }\n+\n+   public static boolean isJava15OrNewer() {\n+      return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb4088f58c883681070c4a11082632e51068b03b"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY2OTIxNQ==", "bodyText": "Not worth it IMO, at least not at this time, because it requires way too many \"This is an approved use of blocking executor due to the fact that it only runs a task\" comments.\nThe error message too vague for my taste anyway, I would have liked a reference to some documentation about when it's safe to use BLOCKING_EXECUTOR.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413669215", "createdAt": "2020-04-23T09:41:16Z", "author": {"login": "danberindei"}, "path": "checkstyle/src/main/resources/checkstyle.xml", "diffHunk": "@@ -135,6 +135,11 @@\n \n         <!-- Allow annotated code to disable checkstyle check -->\n         <module name=\"SuppressWarningsHolder\" />\n+\n+        <module name=\"RegexpSinglelineJava\">\n+            <property name=\"format\" value=\"(class,\\s*|@ComponentName\\()(KnownComponentNames\\.)?BLOCKING_EXECUTOR\\)\"/>\n+            <property name=\"message\" value=\"[not required for tests] BlockingHandler should be used unless case can be confirmed to be okay\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzY4NDU0Mw==", "bodyText": "Is this related to BlockingHandler? To me reading the built-in stacks once in readElement seems more natural, although I'd like it even more if we didn't actually read the default stacks until they are referenced in the transport or in an inline stack.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413684543", "createdAt": "2020-04-23T10:03:53Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/configuration/parsing/Parser.java", "diffHunk": "@@ -105,15 +105,19 @@\n    public Parser() {\n    }\n \n+   private void addJGroupsDefaultStacksIfNeeded(final XMLExtendedStreamReader reader, final ConfigurationBuilderHolder holder) {\n+      if (holder.getJGroupsStack(BuiltinJGroupsChannelConfigurator.TCP_STACK_NAME) == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2NzYxOA==", "bodyText": "resolveConflicts() is not public API, so it can be changed to return CompletionStage.\nBut I don't see any advantage in using the BlockingExecutor interface here instead of the more familiar Executor.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413767618", "createdAt": "2020-04-23T12:20:32Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/conflict/impl/DefaultConflictManager.java", "diffHunk": "@@ -249,7 +245,9 @@ public void resolveConflicts(EntryMergePolicy<K, V> mergePolicy) {\n       } else {\n          localizedTopology = distributionManager.createLocalizedCacheTopology(topology);\n       }\n-      conflictFuture = CompletableFuture.runAsync(() -> doResolveConflicts(localizedTopology, entryMergePolicy, preferredNodes), resolutionExecutor);\n+      conflictFuture = resolutionExecutor.execute(() -> doResolveConflicts(localizedTopology, entryMergePolicy, preferredNodes),\n+            localizedTopology.getTopologyId())\n+            .toCompletableFuture();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzc2ODQxMQ==", "bodyText": "Comment doesn't sound right, now that there is no if statement.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413768411", "createdAt": "2020-04-23T12:21:41Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -158,13 +155,8 @@ public boolean isEnabled() {\n \n    @Override\n    public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry, long currentTime) {\n-      if (persistenceManager.hasWriter()) {\n-         // If entry was expired and we have store this can block - so fire in separate thread to remove the entry\n-         blockingExecutor.submit(() -> entryExpiredInMemorySync(entry, currentTime));\n-      } else {\n-         // This shouldn't block as there are no stores (other than the lock acquisition on the Map and notification)\n-         entryExpiredInMemory(entry, currentTime, false);\n-      }\n+      // This shouldn't block as there are no stores (other than the lock acquisition on the Map and notification)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxNTI2Mw==", "bodyText": "I'm not sure about the name, because it's definitely not the identifier of a single event. Maybe batchIdentifier is better?\nSame in the other methods, in ClusterEventManager and its implementations.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413815263", "createdAt": "2020-04-23T13:55:29Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/notifications/cachelistener/CacheNotifierImpl.java", "diffHunk": "@@ -414,7 +414,7 @@ int extractSegment(FlagAffectedCommand command, Object key) {\n             && (command == null || !command.hasAnyFlag(FlagBitSets.PUT_FOR_STATE_TRANSFER))) {\n          EventImpl<K, V> e = EventImpl.createEvent(cache.wired(), CACHE_ENTRY_CREATED);\n          boolean isLocalNodePrimaryOwner = isLocalNodePrimaryOwner(key);\n-         boolean sendEvents = !ctx.isInTxScope();\n+         Object eventIdentifier = ctx.isInTxScope() ? null : Thread.currentThread();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxNzIwOA==", "bodyText": "I think this could be better phrased by using a common terminology. I wouldn't know what \"signal through the current thread\" or \"in the same caller\" mean unless I already knew what addEvents does, but then I wouldn't need a comment here.\nThe comment did make me curious though, because it says with 10 registered listeners, all of them are notified about a put(K, V) in the same batch (I think!), but it doesn't say what happens when the operation is putAll() and it updates 10 entries with 10 registered listeners.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413817208", "createdAt": "2020-04-23T13:57:54Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/notifications/cachelistener/cluster/RemoteClusterListener.java", "diffHunk": "@@ -109,14 +109,17 @@ public Address getOwnerAddress() {\n          if (trace) {\n             log.tracef(\"Passing Event to manager %s to send to %s\", event, origin);\n          }\n-         eventManager.addEvents(origin, id, Collections.singleton(ClusterEvent.fromEvent(event)), sync);\n+         // For non tx events we signal through the current thread as we notify in the same caller for all events", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyMzExMw==", "bodyText": "Missing @param in javadoc", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413823113", "createdAt": "2020-04-23T14:04:38Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/notifications/cachelistener/cluster/ClusterEventManager.java", "diffHunk": "@@ -4,28 +4,27 @@\n import java.util.UUID;\n import java.util.concurrent.CompletionStage;\n \n-import org.infinispan.commons.CacheException;\n import org.infinispan.remoting.transport.Address;\n \n public interface ClusterEventManager<K, V> {\n    /**\n     * Adds additional cluster events that need to be sent remotely for an event originating locally.\n-    * These events are not sent at time of registering but rather after the {@link ClusterEventManager#sendEvents()} is invoked.\n+    * These events are not sent at time of registering but rather after the {@link ClusterEventManager#sendEvents(Object)} is invoked.\n     * These events are gathered on a per thread basis and batched to reduce number of RPCs required.\n     * @param target The target node this event was meant for\n     * @param identifier The cluster listener that is identified for these events\n     * @param events The events that were generated\n     * @param sync Whether these events need to be sent synchronously or not\n     */\n-   void addEvents(Address target, UUID identifier, Collection<ClusterEvent<K, V>> events, boolean sync);\n+   void addEvents(Object eventIdentifier, Address target, UUID identifier, Collection<ClusterEvent<K, V>> events, boolean sync);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgzMDU4Mg==", "bodyText": "Is it even possible to resume in another way?\nAlso would you mind moving all the fields to the top and the inner classes at the bottom? I get light-headed when I see them out of order like this ;)", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413830582", "createdAt": "2020-04-23T14:12:52Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/notifications/impl/AbstractListenerImpl.java", "diffHunk": "@@ -119,9 +120,8 @@ public AbstractInvocationBuilder setSubject(Subject subject) {\n    // Processor used to handle async listener notifications.\n    @Inject @ComponentName(KnownComponentNames.ASYNC_NOTIFICATION_EXECUTOR)\n    protected Executor asyncProcessor;\n-   // Make sure all listeners resume on this executor\n-   @Inject @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR)\n-   ExecutorService nonBlockingExecutor;\n+   // Make sure all listeners resume using this", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg5MTA4OA==", "bodyText": "This comment made more sense before, with the explicit call to subscribeOn, but now it looks out of place.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413891088", "createdAt": "2020-04-23T15:22:00Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -881,48 +831,28 @@ private void writeToAllNonTxStoresSync(MarshallableEntry marshalledEntry, int se\n \n       int id = getNextTraceNumber(\"Submitting persistence async operation of id %d to write a batch\");\n \n-      boolean hasSemaphore = false;\n-\n-      AggregateCompletionStage<Void> aggregateCompletionStage = CompletionStages.aggregateCompletionStage();\n-      storesMutex.readLock().lock();\n+      acquireReadLock();\n       try {\n          checkStoreAvailability();\n-         try {\n-            // We have to acquire semaphore as our operation will escape the storesMutex lock boundaries\n-            // as the flowables are subscribed on the persistence thread pool. Thus we have to retain the publisher\n-            // semaphore until after all the stores have completed their operations\n-            publisherSemaphore.acquire();\n-         } catch (InterruptedException e) {\n-            throw new PersistenceException(e);\n-         }\n-         hasSemaphore = true;\n-         //noinspection unchecked\n-         nonTxWriters.stream()\n-               .filter(writer -> !(writer instanceof FlagAffectedStore) || FlagAffectedStore.class.cast(writer).shouldWrite(flags))\n-               .filter(writer -> predicate.test(getStoreConfig(writer)))\n-               .map(writer -> {\n-                  Flowable<MarshallableEntry> flowable = Flowable.fromIterable(entries);\n-                  if (trace) {\n-                     // Note this trace message will be on the persistence thread as it is subscribed below\n-                     flowable = flowable.doOnSubscribe(s -> log.tracef(\"Continuing write batch for id %d\", id));\n-                  }\n-                  // Subscribing on the persistence scheduler here forces this invocation to be async\n-                  return writer.bulkUpdate(flowable.subscribeOn(blockingScheduler));\n-               })\n-               .forEach(aggregateCompletionStage::dependsOn);\n-      } catch (Throwable t) {\n-         if (hasSemaphore) {\n-            publisherSemaphore.release();\n-         }\n-         throw t;\n+         return Flowable.using(publisherSemaphoreCallable,\n+               semaphore -> Flowable.fromIterable(nonTxWriters)\n+                     .filter(writer -> !(writer instanceof FlagAffectedStore) || FlagAffectedStore.class.cast(writer).shouldWrite(flags))\n+                     .filter(writer -> predicate.test(getStoreConfig(writer)))\n+                     .map(writer -> {\n+                        Flowable<MarshallableEntry> flowable = Flowable.fromIterable(entries);\n+                        if (trace) {\n+                           // Note this trace message will be on the persistence thread as it is subscribed below\n+                           flowable = flowable.doOnSubscribe(s -> log.tracef(\"Continuing write batch for id %d\", id));\n+                        }\n+                        // Subscribing on the persistence scheduler here forces this invocation to be async", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 469}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg5NjU1OA==", "bodyText": "\"only runs a task\" doesn't sound very convincing to me, because that task could be a bulk operation using lots of CPU. \"This is an approved use\" is also kind of contradicted by the \"To be removed\" comment on the next line :)", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413896558", "createdAt": "2020-04-23T15:28:37Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/remoting/inboundhandler/BasePerCacheInboundInvocationHandler.java", "diffHunk": "@@ -52,6 +52,10 @@\n    public static final String MBEAN_COMPONENT_NAME = \"InboundInvocationHandler\";\n    private static final int NO_TOPOLOGY_COMMAND = Integer.MIN_VALUE;\n \n+   // This is an approved use of blocking executor due to the fact that it only runs a task", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkwMjMzNA==", "bodyText": "Why a \"handler\" and not a \"manager\"? Especially since it has a handleBlocking method, it gives the impression that handleBlocking is the \"main\" method and the others are just extras.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413902334", "createdAt": "2020-04-23T15:35:38Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkyNTY2NA==", "bodyText": "The first sentence mentions \"blocking operation\" and \"correct manner\" but they're just names without any meaning at this point. I'd say \"blocking task\", because \"task\" is more familiar when coupled with \"executor\", maybe\nRuns tasks on the blocking executor and returns a {@code CompletionStage} or {@code Publisher} that continues on the non-blocking executor, similar to {@code stage.handleAsync(callback, blockingExecutor).whenCompleteAsync(NOOP, nonBlockingExecutor)}.\n<p>\nIf the current thread is blocking, it blocks until the task may run, runs the task in the current thread, and returns a completed {@code CompletionStage}, so it <em>does not</em> continue the execution on the non-blocking executor.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413925664", "createdAt": "2020-04-23T16:04:43Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkyNzYwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Invokes the provided runnable in a blocking thread and returns the result eventually.\n          \n          \n            \n                * Replacement for {@code CompletableFuture.runAsync()} that invokes the {@code Runnable} in a blocking thread (if the current thread is non-blocking) or in the current thread (if the current thread is blocking).", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413927606", "createdAt": "2020-04-23T16:07:09Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkyODA1OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n          \n          \n            \n               CompletionStage<Void> runBlocking(Runnable runnable, Object traceId);", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413928059", "createdAt": "2020-04-23T16:07:43Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkyODE5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);\n          \n          \n            \n               <V> CompletionStage<V> supplyBlocking(Supplier<V> supplier, Object traceId);", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413928193", "createdAt": "2020-04-23T16:07:54Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkyODQwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Invokes the provided supplier in a blocking thread and returns the result eventually.\n          \n          \n            \n                * Replacement for {@code CompletableFuture.supplyAsync()} that invokes the {@code Supplier} in a blocking thread (if the current thread is non-blocking) or in the current thread (if the current thread is blocking).", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413928409", "createdAt": "2020-04-23T16:08:12Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzNjIxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Replacement for {@link CompletionStage#handle(BiFunction)} when the function is blocking to ensure the operation\n          \n          \n            \n                * Replacement for {@link CompletionStage#handle(BiFunction)} that invokes the {@code BiFunction} in a blocking thread (if the current thread is non-blocking or the given stage is not done yet) or in the current thread (if the current thread is blocking and the stage is done).", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413936216", "createdAt": "2020-04-23T16:18:18Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#handle(BiFunction)} when the function is blocking to ensure the operation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzNjU4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Replacement for {@link CompletionStage#thenApply(Function)} when the function is blocking to ensure the operation\n          \n          \n            \n                * Replacement for {@link CompletionStage#thenApply(Function)} that invokes the {@code Function} in a blocking thread (if the current thread is non-blocking or the given stage is not done yet) or in the current thread (if the current thread is blocking and the stage is done).", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413936586", "createdAt": "2020-04-23T16:18:48Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#handle(BiFunction)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to handle\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#thenApply(Function)} when the function is blocking to ensure the operation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzNzMxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * Replacement for {@link CompletionStage#whenComplete(BiConsumer)} when the consumer is blocking to ensure the operation\n          \n          \n            \n                * Replacement for {@link CompletionStage#whenComplete(BiConsumer)} that invokes the {@code BiConsumer} in a blocking thread (if the current thread is non-blocking or the given stage is not done yet) or in the current thread (if the current thread is blocking and the stage is done).", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413937319", "createdAt": "2020-04-23T16:19:45Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#handle(BiFunction)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to handle\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#thenApply(Function)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> thenApplyBlocking(CompletionStage<? extends I> stage,\n+         Function<? super I, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#whenComplete(BiConsumer)} when the consumer is blocking to ensure the operation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzODMwMA==", "bodyText": "Feels like there's something missing after \"any values published will be\"", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413938300", "createdAt": "2020-04-23T16:21:07Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#handle(BiFunction)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to handle\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#thenApply(Function)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> thenApplyBlocking(CompletionStage<? extends I> stage,\n+         Function<? super I, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#whenComplete(BiConsumer)} when the consumer is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param biConsumer the blocking biConsumer\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> stage value type\n+    * @return a stage that is complete when the biConsumer is but retains the results from the original stage\n+    */\n+   <V> CompletionStage<V> whenCompleteBlocking(CompletionStage<V> stage,\n+         BiConsumer<? super V, ? super Throwable> biConsumer, Object traceId);\n+\n+   /**\n+    * When the provided stage is complete, continue the completion chain of the returned CompletionStage on the\n+    * supplied executor. If tracing is enabled a trace message is printed using the object as an identifier to more\n+    * easily track the transition between threads.\n+    * <p>\n+    * This method is useful when an asynchronous computation completes and you do not want to run further processing\n+    * on the thread that returned it. An example may be that some blocking operation is performed on a special blocking\n+    * thread pool. However when the blocking operation completes we will want to continue the processing of that result\n+    * in a thread pool that is for computational tasks.\n+    * <p>\n+    * If the supplied stage is already completed when invoking this command, this will return an already completed\n+    * stage, which means any additional dependent stages will run in the invoking thread.\n+    * @param <V> return value type of the supplied stage\n+    * @param delay the stage to delay the continuation until complete\n+    * @param traceId the id to print when tracing is enabled\n+    * @return a CompletionStage that when depended upon will run any callback in the supplied executor\n+    */\n+   <V> CompletionStage<V> continueOnNonBlockingThread(CompletionStage<V> delay, Object traceId);\n+\n+   /**\n+    * Provided a publisher that is known to block, this will ensure that the publisher is subscribed on the\n+    * blocking thread and any values published will be on a non blocking thread. Note that if a blocking thread", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzkzOTQyMQ==", "bodyText": "Is \"these threads\" right, or should it be \"an additional thread\"?", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413939421", "createdAt": "2020-04-23T16:22:32Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#handle(BiFunction)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to handle\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#thenApply(Function)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> thenApplyBlocking(CompletionStage<? extends I> stage,\n+         Function<? super I, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#whenComplete(BiConsumer)} when the consumer is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param biConsumer the blocking biConsumer\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> stage value type\n+    * @return a stage that is complete when the biConsumer is but retains the results from the original stage\n+    */\n+   <V> CompletionStage<V> whenCompleteBlocking(CompletionStage<V> stage,\n+         BiConsumer<? super V, ? super Throwable> biConsumer, Object traceId);\n+\n+   /**\n+    * When the provided stage is complete, continue the completion chain of the returned CompletionStage on the\n+    * supplied executor. If tracing is enabled a trace message is printed using the object as an identifier to more\n+    * easily track the transition between threads.\n+    * <p>\n+    * This method is useful when an asynchronous computation completes and you do not want to run further processing\n+    * on the thread that returned it. An example may be that some blocking operation is performed on a special blocking\n+    * thread pool. However when the blocking operation completes we will want to continue the processing of that result\n+    * in a thread pool that is for computational tasks.\n+    * <p>\n+    * If the supplied stage is already completed when invoking this command, this will return an already completed\n+    * stage, which means any additional dependent stages will run in the invoking thread.\n+    * @param <V> return value type of the supplied stage\n+    * @param delay the stage to delay the continuation until complete\n+    * @param traceId the id to print when tracing is enabled\n+    * @return a CompletionStage that when depended upon will run any callback in the supplied executor\n+    */\n+   <V> CompletionStage<V> continueOnNonBlockingThread(CompletionStage<V> delay, Object traceId);\n+\n+   /**\n+    * Provided a publisher that is known to block, this will ensure that the publisher is subscribed on the\n+    * blocking thread and any values published will be on a non blocking thread. Note that if a blocking thread\n+    * subscribes to the publisher these threads will not be used and thus the entire Publisher is subscribed and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk0MTg3NQ==", "bodyText": "-1, it's not such a big deal to inject the non-blocking executor separately.\nOtherwise we shouldn't call it BlockingHandler IMO, it would need a name with Executor in it instead.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413941875", "createdAt": "2020-04-23T16:25:40Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#handle(BiFunction)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to handle\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#thenApply(Function)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> thenApplyBlocking(CompletionStage<? extends I> stage,\n+         Function<? super I, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#whenComplete(BiConsumer)} when the consumer is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param biConsumer the blocking biConsumer\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> stage value type\n+    * @return a stage that is complete when the biConsumer is but retains the results from the original stage\n+    */\n+   <V> CompletionStage<V> whenCompleteBlocking(CompletionStage<V> stage,\n+         BiConsumer<? super V, ? super Throwable> biConsumer, Object traceId);\n+\n+   /**\n+    * When the provided stage is complete, continue the completion chain of the returned CompletionStage on the\n+    * supplied executor. If tracing is enabled a trace message is printed using the object as an identifier to more\n+    * easily track the transition between threads.\n+    * <p>\n+    * This method is useful when an asynchronous computation completes and you do not want to run further processing\n+    * on the thread that returned it. An example may be that some blocking operation is performed on a special blocking\n+    * thread pool. However when the blocking operation completes we will want to continue the processing of that result\n+    * in a thread pool that is for computational tasks.\n+    * <p>\n+    * If the supplied stage is already completed when invoking this command, this will return an already completed\n+    * stage, which means any additional dependent stages will run in the invoking thread.\n+    * @param <V> return value type of the supplied stage\n+    * @param delay the stage to delay the continuation until complete\n+    * @param traceId the id to print when tracing is enabled\n+    * @return a CompletionStage that when depended upon will run any callback in the supplied executor\n+    */\n+   <V> CompletionStage<V> continueOnNonBlockingThread(CompletionStage<V> delay, Object traceId);\n+\n+   /**\n+    * Provided a publisher that is known to block, this will ensure that the publisher is subscribed on the\n+    * blocking thread and any values published will be on a non blocking thread. Note that if a blocking thread\n+    * subscribes to the publisher these threads will not be used and thus the entire Publisher is subscribed and\n+    * observed on the invoking thread, unless the caller changes this.\n+    * @param publisher the publisher that when subscribed to will block\n+    * @param <V> the published entry types\n+    * @return publisher that will not block the current thread\n+    */\n+   <V> Publisher<V> blockingPublisher(Publisher<V> publisher);\n+\n+   /**\n+    * Provides a {@link BlockingExecutor} which is limited to the provided concurrency amount.\n+    * @param name name of the limited blocking executor\n+    * @param concurrency maximum amount of concurrent operations to be performed via the returned executor\n+    * @return a blocking executor limited in the amount of concurrent invocations\n+    */\n+   BlockingExecutor limitedBlockingExecutor(String name, int concurrency);\n+\n+   /**\n+    * Retrieves the non blocking executor for use if needed.\n+    * @return executor that runs on non blocking threads\n+    */\n+   Executor getNonBlockingExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk0NTMzOA==", "bodyText": "Feels kind of artificial, to keep using BLOCKING_EXECUTOR without injecting it and triggering the checkstyle error.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413945338", "createdAt": "2020-04-23T16:30:07Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandler.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * A handler to ensure that blocking operations are performed in the correct manner. That is that a blocking operation\n+ * is ran on the blocking thread pool and if the operation is not complete immediately will call any chained stages\n+ * on the operation will be done in a non blocking thread.\n+ * <p>\n+ * The handler in an effort to reduce blocking thread usage, should run blocking operations in the invoking thread if\n+ * it was also blocking. This helps prevent blocking thread starvation since you may have blocking threads waiting on\n+ * blocking operations.\n+ */\n+public interface BlockingHandler {\n+   /**\n+    * Invokes the provided runnable in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread and if the returned\n+    * stage is not yet complete will perform any chained stages in a non blocking thread.\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed on the invoking thread and will return\n+    * only when the operation has completed, and does not require any additional threads.\n+    * @param runnable blocking operation that runs something\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @return a stage that is completed after the runnable is done or throws an exception\n+    */\n+   CompletionStage<Void> runBlockingOperation(Runnable runnable, Object traceId);\n+\n+   /**\n+    * Invokes the provided supplier in a blocking thread and returns the result eventually.\n+    * <p>\n+    * If the current thread is not a blocking thread it will invoke the supplier in a blocking thread\n+    * <p>\n+    * If this is invoked on a blocking thread instead the operation is performed inline and will return only when\n+    * the operation has completed, and does not use any additional threads.\n+    * @param supplier blocking operation that returns a value\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> the supplied type\n+    * @return a stage that when complete will contain the value returned from the supplier or a throwable\n+    */\n+   <V> CompletionStage<V> supplyBlockingOperation(Supplier<V> supplier, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#handle(BiFunction)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to handle\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> handleBlocking(CompletionStage<? extends I> stage,\n+         BiFunction<? super I, Throwable, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#thenApply(Function)} when the function is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param function the blocking function\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <I> input value type to the function\n+    * @param <O> output value type after being transformed via function\n+    * @return a stage that when complete will contain the value returned from the function or a throwable\n+    */\n+   <I, O> CompletionStage<O> thenApplyBlocking(CompletionStage<? extends I> stage,\n+         Function<? super I, ? extends O> function, Object traceId);\n+\n+   /**\n+    * Replacement for {@link CompletionStage#whenComplete(BiConsumer)} when the consumer is blocking to ensure the operation\n+    * is performed upon a blocking thread and handles chained stages being invoked on non blocking thread as needed.\n+    * @param stage stage that may or may not be complete to apply\n+    * @param biConsumer the blocking biConsumer\n+    * @param traceId an identifier that can be used to tell in a trace when an operation moves between threads\n+    * @param <V> stage value type\n+    * @return a stage that is complete when the biConsumer is but retains the results from the original stage\n+    */\n+   <V> CompletionStage<V> whenCompleteBlocking(CompletionStage<V> stage,\n+         BiConsumer<? super V, ? super Throwable> biConsumer, Object traceId);\n+\n+   /**\n+    * When the provided stage is complete, continue the completion chain of the returned CompletionStage on the\n+    * supplied executor. If tracing is enabled a trace message is printed using the object as an identifier to more\n+    * easily track the transition between threads.\n+    * <p>\n+    * This method is useful when an asynchronous computation completes and you do not want to run further processing\n+    * on the thread that returned it. An example may be that some blocking operation is performed on a special blocking\n+    * thread pool. However when the blocking operation completes we will want to continue the processing of that result\n+    * in a thread pool that is for computational tasks.\n+    * <p>\n+    * If the supplied stage is already completed when invoking this command, this will return an already completed\n+    * stage, which means any additional dependent stages will run in the invoking thread.\n+    * @param <V> return value type of the supplied stage\n+    * @param delay the stage to delay the continuation until complete\n+    * @param traceId the id to print when tracing is enabled\n+    * @return a CompletionStage that when depended upon will run any callback in the supplied executor\n+    */\n+   <V> CompletionStage<V> continueOnNonBlockingThread(CompletionStage<V> delay, Object traceId);\n+\n+   /**\n+    * Provided a publisher that is known to block, this will ensure that the publisher is subscribed on the\n+    * blocking thread and any values published will be on a non blocking thread. Note that if a blocking thread\n+    * subscribes to the publisher these threads will not be used and thus the entire Publisher is subscribed and\n+    * observed on the invoking thread, unless the caller changes this.\n+    * @param publisher the publisher that when subscribed to will block\n+    * @param <V> the published entry types\n+    * @return publisher that will not block the current thread\n+    */\n+   <V> Publisher<V> blockingPublisher(Publisher<V> publisher);\n+\n+   /**\n+    * Provides a {@link BlockingExecutor} which is limited to the provided concurrency amount.\n+    * @param name name of the limited blocking executor\n+    * @param concurrency maximum amount of concurrent operations to be performed via the returned executor\n+    * @return a blocking executor limited in the amount of concurrent invocations\n+    */\n+   BlockingExecutor limitedBlockingExecutor(String name, int concurrency);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk0NjYyMg==", "bodyText": "Could be private", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413946622", "createdAt": "2020-04-23T16:31:48Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingHandlerImpl.java", "diffHunk": "@@ -0,0 +1,235 @@\n+package org.infinispan.util.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.Executor;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+import org.infinispan.commons.executors.BlockingResource;\n+import org.infinispan.executors.LimitedExecutor;\n+import org.infinispan.factories.KnownComponentNames;\n+import org.infinispan.factories.annotations.ComponentName;\n+import org.infinispan.factories.annotations.Inject;\n+import org.infinispan.factories.annotations.Start;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.reactivestreams.Publisher;\n+\n+import io.reactivex.Flowable;\n+import io.reactivex.Scheduler;\n+import io.reactivex.schedulers.Schedulers;\n+\n+@Scope(Scopes.GLOBAL)\n+public class BlockingHandlerImpl implements BlockingHandler {\n+   private static final Log log = LogFactory.getLog(MethodHandles.lookup().lookupClass());\n+   private static final boolean trace = log.isTraceEnabled();\n+\n+   @Inject @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR)\n+   Executor nonBlockingExecutor;\n+   // This should eventually be the only reference to blocking executor\n+   @SuppressWarnings(\"checkstyle:RegexpSinglelineJava\")\n+   @Inject @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR)\n+   Executor blockingExecutor;\n+\n+   Scheduler blockingScheduler;\n+   Scheduler nonBlockingScheduler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1MTczNA==", "bodyText": "It was only deprecated in 11, we can't remove it so soon.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413951734", "createdAt": "2020-04-23T16:38:30Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/util/concurrent/CompletionStages.java", "diffHunk": "@@ -126,45 +125,6 @@ public static boolean isCompletedSuccessfully(CompletionStage<?> stage) {\n       return aggregateCompletionStage != null ? aggregateCompletionStage.freeze() : CompletableFutures.completedNull();\n    }\n \n-   /**\n-    * When the provided stage is complete, continue the completion chain of the returned CompletionStage on the\n-    * supplied executor. If tracing is enabled a trace message is printed using the object as an identifier to more\n-    * easily track the transition between threads.\n-    * <p>\n-    * This method is useful when an asynchronous computation completes and you do not want to run further processing\n-    * on the thread that returned it. An example may be that some blocking operation is performed on a special blocking\n-    * thread pool. However when the blocking operation completes we will want to continue the processing of that result\n-    * in a thread pool that is for computational tasks.\n-    * <p>\n-    * If the supplied stage is already completed when invoking this command, this will return an already completed\n-    * stage, which means any additional dependent stages will run in the invoking thread.\n-    * @param <V> return value type of the supplied stage\n-    * @param delay the stage to delay the continuation until complete\n-    * @param continuationExecutor the executor to run any further completion chain methods on\n-    * @param traceId the id to print when tracing is enabled\n-    * @return a CompletionStage that when depended upon will run any callback in the supplied executor\n-    * @deprecated This method is to be removed and replaced with a component to handle thread continuations in a better manner", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1Mjk2Nw==", "bodyText": "I'm guessing this needs to be reverted", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413952967", "createdAt": "2020-04-23T16:40:21Z", "author": {"login": "danberindei"}, "path": "core/src/test/java/org/infinispan/xsite/CacheOperationsTest.java", "diffHunk": "@@ -36,14 +36,14 @@\n    @Factory\n    public Object[] factory() {\n       return new Object[] {\n-            new CacheOperationsTest().cacheMode(CacheMode.DIST_SYNC).transactional(false),\n-            new CacheOperationsTest().cacheMode(CacheMode.REPL_SYNC).transactional(false),\n+//            new CacheOperationsTest().cacheMode(CacheMode.DIST_SYNC).transactional(false),\n+//            new CacheOperationsTest().cacheMode(CacheMode.REPL_SYNC).transactional(false),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NjIwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               public <T> CompletableFuture<T> runTask(String taskName, TaskContext context, BlockingHandler blockingHandler) {\n          \n          \n            \n               public <T> CompletionStage<T> runTask(String taskName, TaskContext context, BlockingHandler blockingHandler) {", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413956206", "createdAt": "2020-04-23T16:44:54Z", "author": {"login": "danberindei"}, "path": "server/core/src/main/java/org/infinispan/server/core/admin/AdminOperationsHandler.java", "diffHunk": "@@ -41,9 +41,9 @@ public String getName() {\n    }\n \n    @Override\n-   public <T> CompletableFuture<T> runTask(String taskName, TaskContext context, Executor executor) {\n+   public <T> CompletableFuture<T> runTask(String taskName, TaskContext context, BlockingHandler blockingHandler) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NzMwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               CompletableFuture<Void> asyncCompleteLocalTransaction(AdvancedCache<?, ?> cache, long timeout) {\n          \n          \n            \n               CompletionStage<Void> asyncCompleteLocalTransaction(AdvancedCache<?, ?> cache, long timeout) {", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413957305", "createdAt": "2020-04-23T16:46:25Z", "author": {"login": "danberindei"}, "path": "server/hotrod/src/main/java/org/infinispan/server/hotrod/tx/operation/CommitTransactionOperation.java", "diffHunk": "@@ -150,8 +150,7 @@ CacheRpcCommand buildForwardCommand(ByteString cacheName, long timeout) {\n \n    @Override\n    CompletableFuture<Void> asyncCompleteLocalTransaction(AdvancedCache<?, ?> cache, long timeout) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzk1NzUwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               CompletableFuture<Void> asyncCompleteLocalTransaction(AdvancedCache<?, ?> cache, long timeout) {\n          \n          \n            \n               CompletionStage<Void> asyncCompleteLocalTransaction(AdvancedCache<?, ?> cache, long timeout) {", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r413957504", "createdAt": "2020-04-23T16:46:42Z", "author": {"login": "danberindei"}, "path": "server/hotrod/src/main/java/org/infinispan/server/hotrod/tx/operation/RollbackTransactionOperation.java", "diffHunk": "@@ -143,8 +143,7 @@ CacheRpcCommand buildForwardCommand(ByteString cacheName, long timeout) {\n \n    @Override\n    CompletableFuture<Void> asyncCompleteLocalTransaction(AdvancedCache<?, ?> cache, long timeout) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5"}, "originalPosition": 3}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/4025e438df0a232cc4b797a5d6a1ae9d69aba0e5", "committedDate": "2020-04-22T15:12:57Z", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block"}, "afterCommit": {"oid": "89fc8237aa21b19c5f2f2c020499e91f56835d60", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/89fc8237aa21b19c5f2f2c020499e91f56835d60", "committedDate": "2020-04-23T19:21:18Z", "message": "rework comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "89fc8237aa21b19c5f2f2c020499e91f56835d60", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/89fc8237aa21b19c5f2f2c020499e91f56835d60", "committedDate": "2020-04-23T19:21:18Z", "message": "rework comments"}, "afterCommit": {"oid": "21d42d4e2e030a29eea0cf5fb426c4628a22904b", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/21d42d4e2e030a29eea0cf5fb426c4628a22904b", "committedDate": "2020-04-23T19:23:04Z", "message": "ISPN-11543 Jgroups Stacks should be initailized lazily"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "21d42d4e2e030a29eea0cf5fb426c4628a22904b", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/21d42d4e2e030a29eea0cf5fb426c4628a22904b", "committedDate": "2020-04-23T19:23:04Z", "message": "ISPN-11543 Jgroups Stacks should be initailized lazily"}, "afterCommit": {"oid": "eeefdb2aeae749f85050fe19aebf3e5b9c3b801a", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/eeefdb2aeae749f85050fe19aebf3e5b9c3b801a", "committedDate": "2020-04-23T19:25:41Z", "message": "ISPN-11543 JGroups Stacks should be initailized lazily"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eeefdb2aeae749f85050fe19aebf3e5b9c3b801a", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/eeefdb2aeae749f85050fe19aebf3e5b9c3b801a", "committedDate": "2020-04-23T19:25:41Z", "message": "ISPN-11543 JGroups Stacks should be initailized lazily"}, "afterCommit": {"oid": "d2f32657ed9bd068b88e73347f8946d7bee51630", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/d2f32657ed9bd068b88e73347f8946d7bee51630", "committedDate": "2020-04-23T19:32:27Z", "message": "ISPN-11703 JGroups Stacks should be initailized lazily"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d2f32657ed9bd068b88e73347f8946d7bee51630", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/d2f32657ed9bd068b88e73347f8946d7bee51630", "committedDate": "2020-04-23T19:32:27Z", "message": "ISPN-11703 JGroups Stacks should be initailized lazily"}, "afterCommit": {"oid": "7a1122b64b8d7e693e821c92db8e5bc91d9569cb", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/7a1122b64b8d7e693e821c92db8e5bc91d9569cb", "committedDate": "2020-04-24T12:33:25Z", "message": "ISPN-11703 JGroups Stacks should be initailized lazily"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7a1122b64b8d7e693e821c92db8e5bc91d9569cb", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/7a1122b64b8d7e693e821c92db8e5bc91d9569cb", "committedDate": "2020-04-24T12:33:25Z", "message": "ISPN-11703 JGroups Stacks should be initailized lazily"}, "afterCommit": {"oid": "ee3a49233b2c8d17f44939cd611d6fdf816a4908", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/ee3a49233b2c8d17f44939cd611d6fdf816a4908", "committedDate": "2020-04-24T12:37:41Z", "message": "ISPN-11703 JGroups Stacks should be initailized lazily"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ee3a49233b2c8d17f44939cd611d6fdf816a4908", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/ee3a49233b2c8d17f44939cd611d6fdf816a4908", "committedDate": "2020-04-24T12:37:41Z", "message": "ISPN-11703 JGroups Stacks should be initailized lazily"}, "afterCommit": {"oid": "848294324297c6c1a40d61db698b07ea1978fb06", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/848294324297c6c1a40d61db698b07ea1978fb06", "committedDate": "2020-04-24T13:12:26Z", "message": "ISPN-11703 JGroups Stacks should be initailized lazily"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "848294324297c6c1a40d61db698b07ea1978fb06", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/848294324297c6c1a40d61db698b07ea1978fb06", "committedDate": "2020-04-24T13:12:26Z", "message": "ISPN-11703 JGroups Stacks should be initailized lazily"}, "afterCommit": {"oid": "9e6611547638951b23317604865d30d1e114288c", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/9e6611547638951b23317604865d30d1e114288c", "committedDate": "2020-04-24T13:17:11Z", "message": "ISPN-11703 JGroups Stacks should be initailized lazily"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9e6611547638951b23317604865d30d1e114288c", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/9e6611547638951b23317604865d30d1e114288c", "committedDate": "2020-04-24T13:17:11Z", "message": "ISPN-11703 JGroups Stacks should be initailized lazily"}, "afterCommit": {"oid": "1e6cc8a71dffccf49972ee582914416ab79c1f11", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/1e6cc8a71dffccf49972ee582914416ab79c1f11", "committedDate": "2020-04-24T13:23:20Z", "message": "ISPN-11703 JGroups Stacks should be initailized lazily"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1e6cc8a71dffccf49972ee582914416ab79c1f11", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/1e6cc8a71dffccf49972ee582914416ab79c1f11", "committedDate": "2020-04-24T13:23:20Z", "message": "ISPN-11703 JGroups Stacks should be initailized lazily"}, "afterCommit": {"oid": "5769af44281c4d77c3c8dd52d3fa64109a3bcc0d", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/5769af44281c4d77c3c8dd52d3fa64109a3bcc0d", "committedDate": "2020-04-24T13:36:14Z", "message": "ISPN-11703 JGroups Stacks should be initialized lazily"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5769af44281c4d77c3c8dd52d3fa64109a3bcc0d", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/5769af44281c4d77c3c8dd52d3fa64109a3bcc0d", "committedDate": "2020-04-24T13:36:14Z", "message": "ISPN-11703 JGroups Stacks should be initialized lazily"}, "afterCommit": {"oid": "acaa9896edc84be5fdf2ddfa76ed6fee417b2a82", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/acaa9896edc84be5fdf2ddfa76ed6fee417b2a82", "committedDate": "2020-04-24T15:01:41Z", "message": "ISPN-11703 JGroups Stacks should be initialized lazily"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "acaa9896edc84be5fdf2ddfa76ed6fee417b2a82", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/acaa9896edc84be5fdf2ddfa76ed6fee417b2a82", "committedDate": "2020-04-24T15:01:41Z", "message": "ISPN-11703 JGroups Stacks should be initialized lazily"}, "afterCommit": {"oid": "be49a9674065e5131300c074d8a2f50090b00593", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/be49a9674065e5131300c074d8a2f50090b00593", "committedDate": "2020-04-24T16:55:39Z", "message": "ISPN-11703 JGroups Stacks should be initialized lazily"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwODkxMjc2", "url": "https://github.com/infinispan/infinispan/pull/8119#pullrequestreview-400891276", "createdAt": "2020-04-27T12:12:54Z", "commit": {"oid": "be49a9674065e5131300c074d8a2f50090b00593"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjoxMjo1NFrOGMf8jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjoxMjo1NFrOGMf8jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc1OTUwMA==", "bodyText": "Join lines please", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415759500", "createdAt": "2020-04-27T12:12:54Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/globalstate/impl/GlobalConfigurationManagerImpl.java", "diffHunk": "@@ -54,8 +52,8 @@\n    @Inject ConfigurationManager configurationManager;\n    @Inject InternalCacheRegistry internalCacheRegistry;\n    @Inject GlobalComponentRegistry globalComponentRegistry;\n-   @Inject @ComponentName(KnownComponentNames.BLOCKING_EXECUTOR)\n-   ExecutorService blockingExecutor;\n+   @Inject\n+   BlockingManager blockingManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be49a9674065e5131300c074d8a2f50090b00593"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwODkzNDI3", "url": "https://github.com/infinispan/infinispan/pull/8119#pullrequestreview-400893427", "createdAt": "2020-04-27T12:16:00Z", "commit": {"oid": "be49a9674065e5131300c074d8a2f50090b00593"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjoxNjowMFrOGMgDrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjoxNjowMFrOGMgDrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc2MTMyNQ==", "bodyText": "Join lines please", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415761325", "createdAt": "2020-04-27T12:16:00Z", "author": {"login": "danberindei"}, "path": "core/src/main/java/org/infinispan/persistence/manager/PersistenceManagerImpl.java", "diffHunk": "@@ -141,8 +136,8 @@\n    @Inject CacheNotifier cacheNotifier;\n    @Inject KeyPartitioner keyPartitioner;\n    @Inject Transport transport;\n-   @Inject @ComponentName(NON_BLOCKING_EXECUTOR)\n-   ExecutorService nonBlockingExecutor;\n+   @Inject\n+   BlockingManager handler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be49a9674065e5131300c074d8a2f50090b00593"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwOTA5NzU5", "url": "https://github.com/infinispan/infinispan/pull/8119#pullrequestreview-400909759", "createdAt": "2020-04-27T12:38:36Z", "commit": {"oid": "be49a9674065e5131300c074d8a2f50090b00593"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjozODozNlrOGMg9dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjozODozNlrOGMg9dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc3NjExNw==", "bodyText": "I didn't notice this before, are we assuming that the listeners are blocking?\nUpdate: Never mind, I see now that counters don't have a non-blocking listener interface, and our internal implementation potentially blocks when the event queue is full.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415776117", "createdAt": "2020-04-27T12:38:36Z", "author": {"login": "danberindei"}, "path": "counter/src/main/java/org/infinispan/counter/impl/listener/CounterManagerNotificationManager.java", "diffHunk": "@@ -69,15 +67,15 @@ public CounterManagerNotificationManager() {\n    }\n \n    /**\n-    * The executor to use where the user's {@link CounterListener} is invoked.\n+    * The blockingManager to use where the user's {@link CounterListener} is invoked.\n     *\n-    * @param asyncExecutor The {@link Executor} implementation.\n+    * @param blockingManager The {@link BlockingManager} to use.\n     */\n-   public void useExecutor(Executor asyncExecutor) {\n-      if (asyncExecutor == null) {\n+   public void useBlockingManager(BlockingManager blockingManager) {\n+      if (blockingManager == null) {\n          return;\n       }\n-      userListenerExecutor = new LimitedExecutor(\"counter-listener\", asyncExecutor, 1);\n+      userListenerExecutor = blockingManager.limitedBlockingExecutor(\"counter-listener\", 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be49a9674065e5131300c074d8a2f50090b00593"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwOTE3MjM3", "url": "https://github.com/infinispan/infinispan/pull/8119#pullrequestreview-400917237", "createdAt": "2020-04-27T12:48:45Z", "commit": {"oid": "be49a9674065e5131300c074d8a2f50090b00593"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjo0ODo0NVrOGMhYLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjo0ODo0NVrOGMhYLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4Mjk1OQ==", "bodyText": "IMO rollbackOldTransaction should return CompletionStage", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415782959", "createdAt": "2020-04-27T12:48:45Z", "author": {"login": "danberindei"}, "path": "server/hotrod/src/main/java/org/infinispan/server/hotrod/tx/table/GlobalTxTable.java", "diffHunk": "@@ -257,8 +254,9 @@ private void onOngoingTransaction(CacheXid cacheXid, TxState state) {\n             //local transaction doesn't exists.\n             onTransactionCompleted(cacheXid);\n          } else {\n-            blockingExecutor.execute(\n-                  () -> rollbackOldTransaction(cacheXid, state, () -> completeLocal(txTable, cacheXid, tx, false)));\n+            blockingManager.runBlocking(\n+                  () -> rollbackOldTransaction(cacheXid, state, () -> completeLocal(txTable, cacheXid, tx, false)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be49a9674065e5131300c074d8a2f50090b00593"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwOTE5MDQx", "url": "https://github.com/infinispan/infinispan/pull/8119#pullrequestreview-400919041", "createdAt": "2020-04-27T12:51:02Z", "commit": {"oid": "be49a9674065e5131300c074d8a2f50090b00593"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjo1MTowMlrOGMheTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxMjo1MTowMlrOGMheTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc4NDUyNg==", "bodyText": "I'd rather declare the variable as CompletionStage here and use CompletionStages.join() on the next line.", "url": "https://github.com/infinispan/infinispan/pull/8119#discussion_r415784526", "createdAt": "2020-04-27T12:51:02Z", "author": {"login": "danberindei"}, "path": "tasks/manager/src/test/java/org/infinispan/tasks/TaskManagerTest.java", "diffHunk": "@@ -58,7 +58,7 @@ public void testStoredEngines() {\n \n    public void testRunTask() throws InterruptedException, ExecutionException {\n       memoryLogger.reset();\n-      CompletableFuture<String> okTask = taskManager.runTask(DummyTaskTypes.SUCCESSFUL_TASK.name(), new TaskContext().logEvent(true));\n+      CompletableFuture<String> okTask = taskManager.<String>runTask(DummyTaskTypes.SUCCESSFUL_TASK.name(), new TaskContext().logEvent(true)).toCompletableFuture();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "be49a9674065e5131300c074d8a2f50090b00593"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "be49a9674065e5131300c074d8a2f50090b00593", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/be49a9674065e5131300c074d8a2f50090b00593", "committedDate": "2020-04-24T16:55:39Z", "message": "ISPN-11703 JGroups Stacks should be initialized lazily"}, "afterCommit": {"oid": "fce778164ae0f1778e38036d7f10afec5673e923", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/fce778164ae0f1778e38036d7f10afec5673e923", "committedDate": "2020-04-27T15:01:05Z", "message": "ISPN-11703 JGroups Stacks should be initialized lazily"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fce778164ae0f1778e38036d7f10afec5673e923", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/fce778164ae0f1778e38036d7f10afec5673e923", "committedDate": "2020-04-27T15:01:05Z", "message": "ISPN-11703 JGroups Stacks should be initialized lazily"}, "afterCommit": {"oid": "28e7ca18036ec676d6ffd73a66991e04ebf9c6fb", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/28e7ca18036ec676d6ffd73a66991e04ebf9c6fb", "committedDate": "2020-04-27T15:04:38Z", "message": "ISPN-11703 JGroups Stacks should be initialized lazily"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMDUyNTY0", "url": "https://github.com/infinispan/infinispan/pull/8119#pullrequestreview-401052564", "createdAt": "2020-04-27T15:13:41Z", "commit": {"oid": "28e7ca18036ec676d6ffd73a66991e04ebf9c6fb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d15b615796e4d9de732e166f1e720df30982939f", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/d15b615796e4d9de732e166f1e720df30982939f", "committedDate": "2020-04-27T15:49:33Z", "message": "ISPN-11543 Add BlockingHandler to simplify running blocking operations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b4cfc8a065fd5dd703bc4a73a2cbe9799bd6ec3", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/7b4cfc8a065fd5dd703bc4a73a2cbe9799bd6ec3", "committedDate": "2020-04-27T15:49:33Z", "message": "ISPN-11524 PersistenceManagerImpl locks should be able to block"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3519e557c5671cac5b9bf508d7a36fe87a9f3a18", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/3519e557c5671cac5b9bf508d7a36fe87a9f3a18", "committedDate": "2020-04-27T15:49:33Z", "message": "ISPN-11703 JGroups Stacks should be initialized lazily"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "28e7ca18036ec676d6ffd73a66991e04ebf9c6fb", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/28e7ca18036ec676d6ffd73a66991e04ebf9c6fb", "committedDate": "2020-04-27T15:04:38Z", "message": "ISPN-11703 JGroups Stacks should be initialized lazily"}, "afterCommit": {"oid": "3519e557c5671cac5b9bf508d7a36fe87a9f3a18", "author": {"user": {"login": "wburns", "name": "William Burns"}}, "url": "https://github.com/infinispan/infinispan/commit/3519e557c5671cac5b9bf508d7a36fe87a9f3a18", "committedDate": "2020-04-27T15:49:33Z", "message": "ISPN-11703 JGroups Stacks should be initialized lazily"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1002, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}