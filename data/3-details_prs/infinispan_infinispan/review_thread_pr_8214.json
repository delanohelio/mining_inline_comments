{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1MjI4NzU3", "number": 8214, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTo1MTozNFrODzzCGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNjowNjozNFrODzzhKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjQwMDg4OnYy", "diffSide": "RIGHT", "path": "jcache/remote/src/main/java/org/infinispan/jcache/remote/JCacheManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTo1MTozNFrOGIbYEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTo1MTozNFrOGIbYEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5MDMyMA==", "bodyText": "espace", "url": "https://github.com/infinispan/infinispan/pull/8214#discussion_r411490320", "createdAt": "2020-04-20T15:51:34Z", "author": {"login": "karesti"}, "path": "jcache/remote/src/main/java/org/infinispan/jcache/remote/JCacheManager.java", "diffHunk": "@@ -35,6 +36,14 @@\n    public JCacheManager(URI uri, ClassLoader classLoader, CachingProvider provider, Properties properties) {\n       super(uri, classLoader, provider, properties, false);\n \n+      try(InputStream is = uri.toURL().openStream()) {\n+\n+      } catch (MalformedURLException e) {\n+         // Ignore\n+      } catch (IOException e) {\n+         throw new RuntimeException(\"Could not load \"+uri, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34d52dbe1577c223fed6cb02922e1427803f01c"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjQxMzMyOnYy", "diffSide": "RIGHT", "path": "documentation/src/main/asciidoc/topics/proc_configuring_hotrod_createonaccess.adoc", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTo1Mzo1N1rOGIbfiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwOTo0ODo1NVrOGI87IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5MjIzNQ==", "bodyText": "I would add overloaded method with the template enum DefaultTemplate and String with parameter name templateName. Or at least use the DefaultTemplate enum for the example", "url": "https://github.com/infinispan/infinispan/pull/8214#discussion_r411492235", "createdAt": "2020-04-20T15:53:57Z", "author": {"login": "karesti"}, "path": "documentation/src/main/asciidoc/topics/proc_configuring_hotrod_createonaccess.adoc", "diffHunk": "@@ -0,0 +1,21 @@\n+[id='hotrod_create_caches_on_access']\n+= Creating server caches on first access\n+\n+The normal behaviour of a Hot Rod Java client when attempting to access a non-existent cache is to return `null` from the `getCache(\"name\")` invocation.\n+It is possible to have the Hot Rod Java clients automatically create requested caches on the server on first access using either a specific template or a full configuration.\n+\n+[source,java]\n+----\n+import org.infinispan.client.hotrod.configuration.ConfigurationBuilder;\n+import org.infinispan.client.hotrod.configuration.NearCacheMode;\n+...\n+\n+// Specify the server-side template or configuration to use\n+ConfigurationBuilder builder = new ConfigurationBuilder();\n+builder\n+  .remoteCache(\"my-cache\")\n+    .templateName(\"org.infinispan.DIST_SYNC\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34d52dbe1577c223fed6cb02922e1427803f01c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAzOTk2OQ==", "bodyText": "Done", "url": "https://github.com/infinispan/infinispan/pull/8214#discussion_r412039969", "createdAt": "2020-04-21T09:48:55Z", "author": {"login": "tristantarrant"}, "path": "documentation/src/main/asciidoc/topics/proc_configuring_hotrod_createonaccess.adoc", "diffHunk": "@@ -0,0 +1,21 @@\n+[id='hotrod_create_caches_on_access']\n+= Creating server caches on first access\n+\n+The normal behaviour of a Hot Rod Java client when attempting to access a non-existent cache is to return `null` from the `getCache(\"name\")` invocation.\n+It is possible to have the Hot Rod Java clients automatically create requested caches on the server on first access using either a specific template or a full configuration.\n+\n+[source,java]\n+----\n+import org.infinispan.client.hotrod.configuration.ConfigurationBuilder;\n+import org.infinispan.client.hotrod.configuration.NearCacheMode;\n+...\n+\n+// Specify the server-side template or configuration to use\n+ConfigurationBuilder builder = new ConfigurationBuilder();\n+builder\n+  .remoteCache(\"my-cache\")\n+    .templateName(\"org.infinispan.DIST_SYNC\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5MjIzNQ=="}, "originalCommit": {"oid": "c34d52dbe1577c223fed6cb02922e1427803f01c"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjQzMzQ3OnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/logging/Log.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTo1ODowMVrOGIbsLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxOToyMDo0OFrOGIj3mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NTQ3MA==", "bodyText": "what is Xor configuration ?", "url": "https://github.com/infinispan/infinispan/pull/8214#discussion_r411495470", "createdAt": "2020-04-20T15:58:01Z", "author": {"login": "karesti"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/logging/Log.java", "diffHunk": "@@ -332,4 +332,7 @@\n \n    @Message(value = \"OAUTHBEARER mechanism selected without providing a token\", id = 4093)\n    CacheConfigurationException oauthBearerWithoutToken();\n+\n+   @Message(value = \"Cannot specify both template name and configuration for '%s'\", id = 4094)\n+   CacheConfigurationException remoteCacheTemplateNameXorConfiguration(String name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34d52dbe1577c223fed6cb02922e1427803f01c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYyOTQ2NA==", "bodyText": "exclusive or: you can have either one or the other", "url": "https://github.com/infinispan/infinispan/pull/8214#discussion_r411629464", "createdAt": "2020-04-20T19:20:48Z", "author": {"login": "tristantarrant"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/logging/Log.java", "diffHunk": "@@ -332,4 +332,7 @@\n \n    @Message(value = \"OAUTHBEARER mechanism selected without providing a token\", id = 4093)\n    CacheConfigurationException oauthBearerWithoutToken();\n+\n+   @Message(value = \"Cannot specify both template name and configuration for '%s'\", id = 4094)\n+   CacheConfigurationException remoteCacheTemplateNameXorConfiguration(String name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NTQ3MA=="}, "originalCommit": {"oid": "c34d52dbe1577c223fed6cb02922e1427803f01c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjQzODUyOnYy", "diffSide": "LEFT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/Util.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNTo1ODo1OFrOGIbvOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwOTo1NDozMVrOGI9KMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NjI0OA==", "bodyText": "I have troubles with my editor and code formatter right now. I don't further know if this is the good or the bad format", "url": "https://github.com/infinispan/infinispan/pull/8214#discussion_r411496248", "createdAt": "2020-04-20T15:58:58Z", "author": {"login": "karesti"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/Util.java", "diffHunk": "@@ -28,20 +29,19 @@ public int getFormatId() {\n \n       @Override\n       public byte[] getGlobalTransactionId() {\n-         return new byte[] {1};\n+         return new byte[]{1};\n       }\n \n       @Override\n       public byte[] getBranchQualifier() {\n-         return new byte[] {1};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34d52dbe1577c223fed6cb02922e1427803f01c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA0MzgyNw==", "bodyText": "I've used our IDEA code style and that's what it does", "url": "https://github.com/infinispan/infinispan/pull/8214#discussion_r412043827", "createdAt": "2020-04-21T09:54:31Z", "author": {"login": "tristantarrant"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/impl/Util.java", "diffHunk": "@@ -28,20 +29,19 @@ public int getFormatId() {\n \n       @Override\n       public byte[] getGlobalTransactionId() {\n-         return new byte[] {1};\n+         return new byte[]{1};\n       }\n \n       @Override\n       public byte[] getBranchQualifier() {\n-         return new byte[] {1};", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5NjI0OA=="}, "originalCommit": {"oid": "c34d52dbe1577c223fed6cb02922e1427803f01c"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjQ1MTYzOnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/configuration/ConfigurationChildBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNjowMToxOVrOGIb2-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwOTo1NDo0MVrOGI9Kyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5ODIzMw==", "bodyText": "Java doc", "url": "https://github.com/infinispan/infinispan/pull/8214#discussion_r411498233", "createdAt": "2020-04-20T16:01:19Z", "author": {"login": "karesti"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/configuration/ConfigurationChildBuilder.java", "diffHunk": "@@ -222,6 +222,8 @@\n     */\n    TransactionConfigurationBuilder transaction();\n \n+   RemoteCacheConfigurationBuilder remoteCache(String name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34d52dbe1577c223fed6cb02922e1427803f01c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjA0Mzk3OQ==", "bodyText": "Done", "url": "https://github.com/infinispan/infinispan/pull/8214#discussion_r412043979", "createdAt": "2020-04-21T09:54:41Z", "author": {"login": "tristantarrant"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/configuration/ConfigurationChildBuilder.java", "diffHunk": "@@ -222,6 +222,8 @@\n     */\n    TransactionConfigurationBuilder transaction();\n \n+   RemoteCacheConfigurationBuilder remoteCache(String name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQ5ODIzMw=="}, "originalCommit": {"oid": "c34d52dbe1577c223fed6cb02922e1427803f01c"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjQ4MDQzOnYy", "diffSide": "RIGHT", "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCacheManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNjowNjozNFrOGIcH3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxOToyMTo0MVrOGIj5tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUwMjU1Nw==", "bodyText": "instead if returning null and exception or logging that would explain better the issue ?", "url": "https://github.com/infinispan/infinispan/pull/8214#discussion_r411502557", "createdAt": "2020-04-20T16:06:34Z", "author": {"login": "karesti"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCacheManager.java", "diffHunk": "@@ -427,52 +430,84 @@ private Properties loadFromStream(InputStream stream) {\n \n    private <K, V> RemoteCache<K, V> createRemoteCache(String cacheName, boolean forceReturnValueOverride,\n                                                       TransactionMode transactionModeOverride, TransactionManager transactionManagerOverride) {\n-      synchronized (cacheName2RemoteCache) {\n-         RemoteCacheKey key = new RemoteCacheKey(cacheName, forceReturnValueOverride);\n-         if (!cacheName2RemoteCache.containsKey(key)) {\n-            TransactionMode transactionMode = getTransactionMode(transactionModeOverride);\n-            RemoteCacheImpl<K, V> result;\n-            if (transactionMode == TransactionMode.NONE) {\n-               result = createRemoteCache(cacheName);\n-            } else {\n-               if (!this.isTransactional(cacheName)) {\n-                  throw HOTROD.cacheDoesNotSupportTransactions(cacheName);\n-               }\n-               TransactionManager transactionManager = getTransactionManager(transactionManagerOverride);\n-               result = createRemoteTransactionalCache(cacheName, forceReturnValueOverride,\n-                     transactionMode == TransactionMode.FULL_XA, transactionMode, transactionManager);\n-            }\n-            RemoteCacheHolder rcc = new RemoteCacheHolder(result, forceReturnValueOverride);\n-            startRemoteCache(rcc);\n+      RemoteCacheConfiguration cacheConfiguration = configuration.remoteCaches().get(cacheName);\n+      boolean forceReturnValue = forceReturnValueOverride ? true : (cacheConfiguration != null ? cacheConfiguration.forceReturnValues() : configuration.forceReturnValues());\n+      RemoteCacheKey key = new RemoteCacheKey(cacheName, forceReturnValue);\n+      if (cacheName2RemoteCache.containsKey(key)) {\n+         return cacheName2RemoteCache.get(key).remoteCache();\n+      }\n \n-            PingResponse pingResponse = result.resolveStorage();\n-            // If ping not successful assume that the cache does not exist\n-            if (pingResponse.isCacheNotFound()) {\n+      OperationsFactory operationsFactory = createOperationFactory(cacheName, forceReturnValue, codec, null);\n+      PingResponse pingResponse;\n+      if (started) {\n+         // Verify if the cache exists on the server first\n+         pingResponse = await(operationsFactory.newFaultTolerantPingOperation().execute());\n+\n+         // If ping not successful assume that the cache does not exist\n+         if (pingResponse.isCacheNotFound()) {\n+            // We may be able to create it. Don't use RemoteCacheAdmin for this, since it would end up calling this method again\n+            Map<String, byte[]> params = new HashMap<>(2);\n+            params.put(RemoteCacheManagerAdminImpl.CACHE_NAME, cacheName.getBytes(HotRodConstants.HOTROD_STRING_CHARSET));\n+            if (cacheConfiguration != null && cacheConfiguration.templateName() != null) {\n+               params.put(RemoteCacheManagerAdminImpl.CACHE_TEMPLATE, cacheConfiguration.templateName().getBytes(HotRodConstants.HOTROD_STRING_CHARSET));\n+            } else if (cacheConfiguration != null && cacheConfiguration.configuration() != null) {\n+               params.put(RemoteCacheManagerAdminImpl.CACHE_CONFIGURATION, new XMLStringConfiguration(cacheConfiguration.configuration()).toXMLString(cacheName).getBytes(HotRodConstants.HOTROD_STRING_CHARSET));\n+            } else {\n+               // We cannot create the cache\n                return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c34d52dbe1577c223fed6cb02922e1427803f01c"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTYzMDAwNQ==", "bodyText": "I really would like to throw an exception, but the previous version returned null and I didn't want to break backwards compat", "url": "https://github.com/infinispan/infinispan/pull/8214#discussion_r411630005", "createdAt": "2020-04-20T19:21:41Z", "author": {"login": "tristantarrant"}, "path": "client/hotrod-client/src/main/java/org/infinispan/client/hotrod/RemoteCacheManager.java", "diffHunk": "@@ -427,52 +430,84 @@ private Properties loadFromStream(InputStream stream) {\n \n    private <K, V> RemoteCache<K, V> createRemoteCache(String cacheName, boolean forceReturnValueOverride,\n                                                       TransactionMode transactionModeOverride, TransactionManager transactionManagerOverride) {\n-      synchronized (cacheName2RemoteCache) {\n-         RemoteCacheKey key = new RemoteCacheKey(cacheName, forceReturnValueOverride);\n-         if (!cacheName2RemoteCache.containsKey(key)) {\n-            TransactionMode transactionMode = getTransactionMode(transactionModeOverride);\n-            RemoteCacheImpl<K, V> result;\n-            if (transactionMode == TransactionMode.NONE) {\n-               result = createRemoteCache(cacheName);\n-            } else {\n-               if (!this.isTransactional(cacheName)) {\n-                  throw HOTROD.cacheDoesNotSupportTransactions(cacheName);\n-               }\n-               TransactionManager transactionManager = getTransactionManager(transactionManagerOverride);\n-               result = createRemoteTransactionalCache(cacheName, forceReturnValueOverride,\n-                     transactionMode == TransactionMode.FULL_XA, transactionMode, transactionManager);\n-            }\n-            RemoteCacheHolder rcc = new RemoteCacheHolder(result, forceReturnValueOverride);\n-            startRemoteCache(rcc);\n+      RemoteCacheConfiguration cacheConfiguration = configuration.remoteCaches().get(cacheName);\n+      boolean forceReturnValue = forceReturnValueOverride ? true : (cacheConfiguration != null ? cacheConfiguration.forceReturnValues() : configuration.forceReturnValues());\n+      RemoteCacheKey key = new RemoteCacheKey(cacheName, forceReturnValue);\n+      if (cacheName2RemoteCache.containsKey(key)) {\n+         return cacheName2RemoteCache.get(key).remoteCache();\n+      }\n \n-            PingResponse pingResponse = result.resolveStorage();\n-            // If ping not successful assume that the cache does not exist\n-            if (pingResponse.isCacheNotFound()) {\n+      OperationsFactory operationsFactory = createOperationFactory(cacheName, forceReturnValue, codec, null);\n+      PingResponse pingResponse;\n+      if (started) {\n+         // Verify if the cache exists on the server first\n+         pingResponse = await(operationsFactory.newFaultTolerantPingOperation().execute());\n+\n+         // If ping not successful assume that the cache does not exist\n+         if (pingResponse.isCacheNotFound()) {\n+            // We may be able to create it. Don't use RemoteCacheAdmin for this, since it would end up calling this method again\n+            Map<String, byte[]> params = new HashMap<>(2);\n+            params.put(RemoteCacheManagerAdminImpl.CACHE_NAME, cacheName.getBytes(HotRodConstants.HOTROD_STRING_CHARSET));\n+            if (cacheConfiguration != null && cacheConfiguration.templateName() != null) {\n+               params.put(RemoteCacheManagerAdminImpl.CACHE_TEMPLATE, cacheConfiguration.templateName().getBytes(HotRodConstants.HOTROD_STRING_CHARSET));\n+            } else if (cacheConfiguration != null && cacheConfiguration.configuration() != null) {\n+               params.put(RemoteCacheManagerAdminImpl.CACHE_CONFIGURATION, new XMLStringConfiguration(cacheConfiguration.configuration()).toXMLString(cacheName).getBytes(HotRodConstants.HOTROD_STRING_CHARSET));\n+            } else {\n+               // We cannot create the cache\n                return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUwMjU1Nw=="}, "originalCommit": {"oid": "c34d52dbe1577c223fed6cb02922e1427803f01c"}, "originalPosition": 92}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4279, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}