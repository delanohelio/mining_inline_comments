{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2MDc4OTIz", "number": 42, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxMzo1OVrODzv9qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMzo0NToxMVrOD3AKcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NTg5ODAyOnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxMzo1OVrOGIWn-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxMzo1OVrOGIWn-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMjQ3NQ==", "bodyText": "Can we avoid side effect assignment here? I'd much prefer two lines, one for the assignment and one for the session.attach call.", "url": "https://github.com/tensorflow/java/pull/42#discussion_r411412475", "createdAt": "2020-04-20T14:13:59Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperation.java", "diffHunk": "@@ -52,7 +50,8 @@\n     this.session = session;\n     this.type = type;\n     this.name = name;\n-    this.nativeRef = new NativeReference(session, this, opNativeHandle, outputNativeHandles);\n+    session.attach(this.opHandle = opNativeHandle);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODU4NTEwOnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/Ops.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMjowODoyNVrOGIvN2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0MDowN1rOGKNBCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxNTM4Nw==", "bodyText": "That's a new op that needs to be reclassified to the right package. In fact, it should replace the actual QuantizedConcat op that is found under org.tensorflow.op.quantization.\nHere's how to do it:\n\nDuplicate the file api_def_QuantizedConcat.pbtxt to api_def_QuantizedConcatV2.pbtxt in the same folder.\nReplace the endpoint in the old file by visibility: SKIP, like in this one\nReplace the graph_op_name in the new file by QuantizedConcatV2", "url": "https://github.com/tensorflow/java/pull/42#discussion_r411815387", "createdAt": "2020-04-21T02:08:25Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/Ops.java", "diffHunk": "@@ -3734,6 +3735,21 @@ public Print print(Operand<TString> input, Print.Options... options) {\n     return Prod.create(scope, input, axis, options);\n   }\n \n+  /**\n+   *\n+   * @param <T> data type for {@code output()} output\n+   * @param values\n+   * @param axis\n+   * @param inputMins\n+   * @param inputMaxes\n+   * @return a new instance of QuantizedConcatV2\n+   */\n+  public <T extends TType, U extends TNumber> QuantizedConcatV2<T> quantizedConcatV2(\n+      Iterable<Operand<T>> values, Operand<U> axis, Iterable<Operand<TFloat32>> inputMins,\n+      Iterable<Operand<TFloat32>> inputMaxes) {\n+    return QuantizedConcatV2.create(scope, values, axis, inputMins, inputMaxes);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg3Njg0NQ==", "bodyText": "Could you push that to my branch? Or I'll just leave those changes out and you can do it before or after we merge this PR?", "url": "https://github.com/tensorflow/java/pull/42#discussion_r411876845", "createdAt": "2020-04-21T05:20:41Z", "author": {"login": "saudet"}, "path": "tensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/Ops.java", "diffHunk": "@@ -3734,6 +3735,21 @@ public Print print(Operand<TString> input, Print.Options... options) {\n     return Prod.create(scope, input, axis, options);\n   }\n \n+  /**\n+   *\n+   * @param <T> data type for {@code output()} output\n+   * @param values\n+   * @param axis\n+   * @param inputMins\n+   * @param inputMaxes\n+   * @return a new instance of QuantizedConcatV2\n+   */\n+  public <T extends TType, U extends TNumber> QuantizedConcatV2<T> quantizedConcatV2(\n+      Iterable<Operand<T>> values, Operand<U> axis, Iterable<Operand<TFloat32>> inputMins,\n+      Iterable<Operand<TFloat32>> inputMaxes) {\n+    return QuantizedConcatV2.create(scope, values, axis, inputMins, inputMaxes);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxNTM4Nw=="}, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1MjIwMw==", "bodyText": "Yeah I can do that", "url": "https://github.com/tensorflow/java/pull/42#discussion_r413352203", "createdAt": "2020-04-22T21:40:07Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/Ops.java", "diffHunk": "@@ -3734,6 +3735,21 @@ public Print print(Operand<TString> input, Print.Options... options) {\n     return Prod.create(scope, input, axis, options);\n   }\n \n+  /**\n+   *\n+   * @param <T> data type for {@code output()} output\n+   * @param values\n+   * @param axis\n+   * @param inputMins\n+   * @param inputMaxes\n+   * @return a new instance of QuantizedConcatV2\n+   */\n+  public <T extends TType, U extends TNumber> QuantizedConcatV2<T> quantizedConcatV2(\n+      Iterable<Operand<T>> values, Operand<U> axis, Iterable<Operand<TFloat32>> inputMins,\n+      Iterable<Operand<TFloat32>> inputMaxes) {\n+    return QuantizedConcatV2.create(scope, values, axis, inputMins, inputMaxes);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxNTM4Nw=="}, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODYxMTE1OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMjoxODo1NlrOGIvcOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDowNDo1OVrOGKpx5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxOTA2Ng==", "bodyText": "If I recall correctly what @EronWright was envisioning for the reference counts is that it could be possible for the session to \"grab\" the ownership of the opHandle when it gets attached to it, instead of explicitly releasing it like in few places in this PR.\nI guess it is done like this because in JavaCPP, you need to explicitly retain a reference so its count is 1, instead of having an initial value of 1. Would you mind explaining again why it needs to be like this?", "url": "https://github.com/tensorflow/java/pull/42#discussion_r411819066", "createdAt": "2020-04-21T02:18:56Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -60,23 +58,28 @@\n     this.session = session;\n     this.type = type;\n     this.name = name;\n-    this.nativeRef = new NativeReference(session, this, allocate(session.nativeHandle(), type));\n+    this.opHandle = allocate(session.nativeHandle(), type);\n+    session.attach(opHandle);\n+    opHandle.releaseReference();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4MDEzNw==", "bodyText": "When we're inside a scope (as in PointerScope), the count does get initialized to 1 by default. But when we're outside of any scope, it stays to 0, as a flag to indicate that reference counting is disabled. We need to enable it manually. If a Pointer would own itself automatically, then the count would start at 2 when initialized inside a scope, and so users would need to release them manually, even inside of a scope. It would make the use of scope pointless.\nThe idea is to do everything with PointerScope, then we don't need to call anything else, and everything is done behind the scenes, since the scopes own all the Pointer objects. It works exactly like RAII in C++. If you would like to understand better the motivation behind this, please read up on C++ and RAII!", "url": "https://github.com/tensorflow/java/pull/42#discussion_r411880137", "createdAt": "2020-04-21T05:29:49Z", "author": {"login": "saudet"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -60,23 +58,28 @@\n     this.session = session;\n     this.type = type;\n     this.name = name;\n-    this.nativeRef = new NativeReference(session, this, allocate(session.nativeHandle(), type));\n+    this.opHandle = allocate(session.nativeHandle(), type);\n+    session.attach(opHandle);\n+    opHandle.releaseReference();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxOTA2Ng=="}, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5MjQ2Mg==", "bodyText": "Then why not working to integrate a bit better the PointerScope in this PR? How would that work, the EagerSession needs to extend from it?", "url": "https://github.com/tensorflow/java/pull/42#discussion_r413492462", "createdAt": "2020-04-23T04:03:45Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -60,23 +58,28 @@\n     this.session = session;\n     this.type = type;\n     this.name = name;\n-    this.nativeRef = new NativeReference(session, this, allocate(session.nativeHandle(), type));\n+    this.opHandle = allocate(session.nativeHandle(), type);\n+    session.attach(opHandle);\n+    opHandle.releaseReference();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxOTA2Ng=="}, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUwMzI0Nw==", "bodyText": "No, we just need to change a few things to be able to pass scopes around a bit more. Sure, let's do it now while we're at it.", "url": "https://github.com/tensorflow/java/pull/42#discussion_r413503247", "createdAt": "2020-04-23T04:39:35Z", "author": {"login": "saudet"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -60,23 +58,28 @@\n     this.session = session;\n     this.type = type;\n     this.name = name;\n-    this.nativeRef = new NativeReference(session, this, allocate(session.nativeHandle(), type));\n+    this.opHandle = allocate(session.nativeHandle(), type);\n+    session.attach(opHandle);\n+    opHandle.releaseReference();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxOTA2Ng=="}, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyMzQ2MA==", "bodyText": "Ok, it's done!", "url": "https://github.com/tensorflow/java/pull/42#discussion_r413823460", "createdAt": "2020-04-23T14:04:59Z", "author": {"login": "saudet"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -60,23 +58,28 @@\n     this.session = session;\n     this.type = type;\n     this.name = name;\n-    this.nativeRef = new NativeReference(session, this, allocate(session.nativeHandle(), type));\n+    this.opHandle = allocate(session.nativeHandle(), type);\n+    session.attach(opHandle);\n+    opHandle.releaseReference();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxOTA2Ng=="}, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODYyNDY1OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMjoyNDozMVrOGIvjvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QxNDowNDozNlrOGKpwbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgyMDk5MQ==", "bodyText": "In EagerOperation constructor, we attach the opHandle to the session, which was already attached to it in the constructor of this class, before we detach it here. So if I understand correctly, attaching more than once the same resource to an EagerSession (therefore to a PointerScope) requires to detach it the same amount of time?", "url": "https://github.com/tensorflow/java/pull/42#discussion_r411820991", "createdAt": "2020-04-21T02:24:31Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -60,23 +58,28 @@\n     this.session = session;\n     this.type = type;\n     this.name = name;\n-    this.nativeRef = new NativeReference(session, this, allocate(session.nativeHandle(), type));\n+    this.opHandle = allocate(session.nativeHandle(), type);\n+    session.attach(opHandle);\n+    opHandle.releaseReference();\n   }\n \n   @Override\n   public EagerOperation build() {\n-    TFE_TensorHandle[] tensorHandles = execute(nativeRef.opHandle);\n+    TFE_TensorHandle[] tensorHandles = execute(opHandle);\n     EagerOperation operation =\n-        new EagerOperation(session, nativeRef.opHandle, tensorHandles, type, name);\n+        new EagerOperation(session, opHandle, tensorHandles, type, name);\n     // Release our reference to the native op handle now that we transferred its\n     // ownership to the EagerOperation\n-    nativeRef.clear();\n+    session.detach(opHandle);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4MDQ0Nw==", "bodyText": "Yes, that's how reference counting works.", "url": "https://github.com/tensorflow/java/pull/42#discussion_r411880447", "createdAt": "2020-04-21T05:30:41Z", "author": {"login": "saudet"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -60,23 +58,28 @@\n     this.session = session;\n     this.type = type;\n     this.name = name;\n-    this.nativeRef = new NativeReference(session, this, allocate(session.nativeHandle(), type));\n+    this.opHandle = allocate(session.nativeHandle(), type);\n+    session.attach(opHandle);\n+    opHandle.releaseReference();\n   }\n \n   @Override\n   public EagerOperation build() {\n-    TFE_TensorHandle[] tensorHandles = execute(nativeRef.opHandle);\n+    TFE_TensorHandle[] tensorHandles = execute(opHandle);\n     EagerOperation operation =\n-        new EagerOperation(session, nativeRef.opHandle, tensorHandles, type, name);\n+        new EagerOperation(session, opHandle, tensorHandles, type, name);\n     // Release our reference to the native op handle now that we transferred its\n     // ownership to the EagerOperation\n-    nativeRef.clear();\n+    session.detach(opHandle);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgyMDk5MQ=="}, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgyMzA4Nw==", "bodyText": "Is this a problem?", "url": "https://github.com/tensorflow/java/pull/42#discussion_r413823087", "createdAt": "2020-04-23T14:04:36Z", "author": {"login": "saudet"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -60,23 +58,28 @@\n     this.session = session;\n     this.type = type;\n     this.name = name;\n-    this.nativeRef = new NativeReference(session, this, allocate(session.nativeHandle(), type));\n+    this.opHandle = allocate(session.nativeHandle(), type);\n+    session.attach(opHandle);\n+    opHandle.releaseReference();\n   }\n \n   @Override\n   public EagerOperation build() {\n-    TFE_TensorHandle[] tensorHandles = execute(nativeRef.opHandle);\n+    TFE_TensorHandle[] tensorHandles = execute(opHandle);\n     EagerOperation operation =\n-        new EagerOperation(session, nativeRef.opHandle, tensorHandles, type, name);\n+        new EagerOperation(session, opHandle, tensorHandles, type, name);\n     // Release our reference to the native op handle now that we transferred its\n     // ownership to the EagerOperation\n-    nativeRef.clear();\n+    session.detach(opHandle);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgyMDk5MQ=="}, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1ODY2ODE0OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerSession.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMjo0Mjo1OFrOGIv7Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNjowODowN1rOGKYIfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgyNzAxNA==", "bodyText": "What do we need both nativeRefs and nativeResources? If I understand correctly, nativeRefs are detached resources that are cleared only on safe points?\nThe purpose of safe points was mainly to allow releasing resources while a session is active but without having a separate thread for garbage-collection. Is the GC thread in JavaCPP is always running? If it cannot be disabled, then we don't need to support safe-points. If it can be disabled, can we link this option with the picked-up strategy then?", "url": "https://github.com/tensorflow/java/pull/42#discussion_r411827014", "createdAt": "2020-04-21T02:42:58Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerSession.java", "diffHunk": "@@ -364,174 +353,38 @@ ResourceCleanupStrategy resourceCleanupStrategy() {\n     return resourceCleanupStrategy;\n   }\n \n-  /**\n-   * A reference to one or more allocated native resources.\n-   *\n-   * <p>Any Java objects owning native resources must declare a reference to those resources in a\n-   * subclass that extends from {@code NativeReference}. When {@link NativeReference#delete()} is\n-   * invoked, the resources must be freed. For example:\n-   *\n-   * <pre>{@code\n-   * private static class NativeReference extends EagerSession.NativeReference {\n-   *\n-   *    NativeReference(EagerSession session, MyClass referent, long handle) {\n-   *        super(session, referent);\n-   *        this.handle = handle;\n-   *    }\n-   *\n-   *    @Override\n-   *    void delete() {\n-   *        MyClass.nativeDelete(handle);\n-   *    }\n-   *\n-   *    private final long handle;\n-   * }\n-   * }</pre>\n-   *\n-   * A Java object \"owns\" a native resource if this resource should not survive beyond the lifetime\n-   * of this object.\n-   *\n-   * <p><b>IMPORTANT</b>: All nested subclasses of {@code NativeReference} must be declared as\n-   * static, otherwise their instances will hold an implicit reference to their enclosing object,\n-   * preventing the garbage collector to release them when they are no longer needed.\n-   */\n-  abstract static class NativeReference extends PhantomReference<Object> {\n-\n-    /** Attach a new phantom reference of {@code referent} to {@code session}. */\n-    public NativeReference(EagerSession session, Object referent) {\n-      super(referent, session.nativeResources.garbageQueue);\n-      session.checkSession();\n-      nativeResources = session.nativeResources;\n-      nativeResources.attach(this);\n-    }\n-\n-    /**\n-     * Detach this reference from its current session.\n-     *\n-     * <p>Clearing a NativeReference does not invoke {@link #delete()}, thus won't release the\n-     * native resources it refers to. It can be used when passing the ownership of those resources\n-     * to another object.\n-     *\n-     * <p>If native resources needs to be deleted as well, call {@link #delete()} explicitly.\n-     */\n-    @Override\n-    public void clear() {\n-      nativeResources.detach(this);\n-      super.clear();\n+  void attach(Pointer... resources) {\n+    checkSession();\n+    for (Pointer r : resources) {\n+      nativeResources.attach(r);\n     }\n-\n-    /** Releases all native resources owned by the referred object, now deleted. */\n-    abstract void delete();\n-\n-    private final NativeResourceCollector nativeResources;\n   }\n \n-  /**\n-   * Collects native references attached to this session and releases their resources if they are no\n-   * longer needed.\n-   */\n-  private static class NativeResourceCollector {\n-\n-    NativeResourceCollector(ReferenceQueue<Object> garbageQueue) {\n-      this.garbageQueue = garbageQueue;\n-    }\n-\n-    void attach(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        nativeRefs.put(nativeRef, null);\n-      }\n-    }\n-\n-    void detach(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        nativeRefs.remove(nativeRef);\n-      }\n-    }\n-\n-    void delete(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        if (!nativeRefs.keySet().remove(nativeRef)) {\n-          return; // safety check\n-        }\n-      }\n-      nativeRef.delete();\n-    }\n-\n-    void deleteAll() {\n-      synchronized (nativeRefs) {\n-        for (NativeReference nativeRef : nativeRefs.keySet()) {\n-          nativeRef.delete();\n-        }\n-        nativeRefs.clear();\n-      }\n-    }\n-\n-    void tryCleanup() {\n-      Reference<?> nativeRef;\n-      synchronized (nativeRefs) {\n-        while ((nativeRef = garbageQueue.poll()) != null) {\n-          delete((NativeReference) nativeRef);\n-        }\n-      }\n-    }\n-\n-    synchronized void startCleanupThread() {\n-      if (cleanupInBackground) {\n-        return; // ignore if cleanup thread is already running\n-      }\n-      try {\n-        cleanupInBackground = true;\n-        cleanupService.execute(\n-            new Runnable() {\n-              @Override\n-              public void run() {\n-                try {\n-                  while (cleanupInBackground) {\n-                    NativeReference nativeRef = (NativeReference) garbageQueue.remove();\n-                    delete(nativeRef);\n-                  }\n-                } catch (InterruptedException e) {\n-                  // exit\n-                }\n-              }\n-            });\n-      } catch (Exception e) {\n-        cleanupInBackground = false;\n-        throw e;\n+  void detach(Pointer... resources) {\n+    checkSession();\n+    for (Pointer r : resources) {\n+      if (resourceCleanupStrategy == ResourceCleanupStrategy.ON_SAFE_POINTS) {\n+          nativeRefs.attach(r);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTg4MzY3OQ==", "bodyText": "We can remove those options. I would vote for this. I wasn't sure myself what was their purpose...\nJavaCPP starts a thread for GC by default, yes, but it should be considered more or less like a safety net. It can be disabled with a system property, but it's pretty much for debug purposes only:\nhttp://bytedeco.org/javacpp/apidocs/org/bytedeco/javacpp/Pointer.html#referenceQueue\nI haven't encountered a user who wanted to have it disabled as a \"feature\", yet anyway.", "url": "https://github.com/tensorflow/java/pull/42#discussion_r411883679", "createdAt": "2020-04-21T05:39:21Z", "author": {"login": "saudet"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerSession.java", "diffHunk": "@@ -364,174 +353,38 @@ ResourceCleanupStrategy resourceCleanupStrategy() {\n     return resourceCleanupStrategy;\n   }\n \n-  /**\n-   * A reference to one or more allocated native resources.\n-   *\n-   * <p>Any Java objects owning native resources must declare a reference to those resources in a\n-   * subclass that extends from {@code NativeReference}. When {@link NativeReference#delete()} is\n-   * invoked, the resources must be freed. For example:\n-   *\n-   * <pre>{@code\n-   * private static class NativeReference extends EagerSession.NativeReference {\n-   *\n-   *    NativeReference(EagerSession session, MyClass referent, long handle) {\n-   *        super(session, referent);\n-   *        this.handle = handle;\n-   *    }\n-   *\n-   *    @Override\n-   *    void delete() {\n-   *        MyClass.nativeDelete(handle);\n-   *    }\n-   *\n-   *    private final long handle;\n-   * }\n-   * }</pre>\n-   *\n-   * A Java object \"owns\" a native resource if this resource should not survive beyond the lifetime\n-   * of this object.\n-   *\n-   * <p><b>IMPORTANT</b>: All nested subclasses of {@code NativeReference} must be declared as\n-   * static, otherwise their instances will hold an implicit reference to their enclosing object,\n-   * preventing the garbage collector to release them when they are no longer needed.\n-   */\n-  abstract static class NativeReference extends PhantomReference<Object> {\n-\n-    /** Attach a new phantom reference of {@code referent} to {@code session}. */\n-    public NativeReference(EagerSession session, Object referent) {\n-      super(referent, session.nativeResources.garbageQueue);\n-      session.checkSession();\n-      nativeResources = session.nativeResources;\n-      nativeResources.attach(this);\n-    }\n-\n-    /**\n-     * Detach this reference from its current session.\n-     *\n-     * <p>Clearing a NativeReference does not invoke {@link #delete()}, thus won't release the\n-     * native resources it refers to. It can be used when passing the ownership of those resources\n-     * to another object.\n-     *\n-     * <p>If native resources needs to be deleted as well, call {@link #delete()} explicitly.\n-     */\n-    @Override\n-    public void clear() {\n-      nativeResources.detach(this);\n-      super.clear();\n+  void attach(Pointer... resources) {\n+    checkSession();\n+    for (Pointer r : resources) {\n+      nativeResources.attach(r);\n     }\n-\n-    /** Releases all native resources owned by the referred object, now deleted. */\n-    abstract void delete();\n-\n-    private final NativeResourceCollector nativeResources;\n   }\n \n-  /**\n-   * Collects native references attached to this session and releases their resources if they are no\n-   * longer needed.\n-   */\n-  private static class NativeResourceCollector {\n-\n-    NativeResourceCollector(ReferenceQueue<Object> garbageQueue) {\n-      this.garbageQueue = garbageQueue;\n-    }\n-\n-    void attach(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        nativeRefs.put(nativeRef, null);\n-      }\n-    }\n-\n-    void detach(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        nativeRefs.remove(nativeRef);\n-      }\n-    }\n-\n-    void delete(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        if (!nativeRefs.keySet().remove(nativeRef)) {\n-          return; // safety check\n-        }\n-      }\n-      nativeRef.delete();\n-    }\n-\n-    void deleteAll() {\n-      synchronized (nativeRefs) {\n-        for (NativeReference nativeRef : nativeRefs.keySet()) {\n-          nativeRef.delete();\n-        }\n-        nativeRefs.clear();\n-      }\n-    }\n-\n-    void tryCleanup() {\n-      Reference<?> nativeRef;\n-      synchronized (nativeRefs) {\n-        while ((nativeRef = garbageQueue.poll()) != null) {\n-          delete((NativeReference) nativeRef);\n-        }\n-      }\n-    }\n-\n-    synchronized void startCleanupThread() {\n-      if (cleanupInBackground) {\n-        return; // ignore if cleanup thread is already running\n-      }\n-      try {\n-        cleanupInBackground = true;\n-        cleanupService.execute(\n-            new Runnable() {\n-              @Override\n-              public void run() {\n-                try {\n-                  while (cleanupInBackground) {\n-                    NativeReference nativeRef = (NativeReference) garbageQueue.remove();\n-                    delete(nativeRef);\n-                  }\n-                } catch (InterruptedException e) {\n-                  // exit\n-                }\n-              }\n-            });\n-      } catch (Exception e) {\n-        cleanupInBackground = false;\n-        throw e;\n+  void detach(Pointer... resources) {\n+    checkSession();\n+    for (Pointer r : resources) {\n+      if (resourceCleanupStrategy == ResourceCleanupStrategy.ON_SAFE_POINTS) {\n+          nativeRefs.attach(r);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgyNzAxNA=="}, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyNTA4Mw==", "bodyText": "Why do the queues in JavaCPP call System.gc()? It's not guaranteed that that method does anything, and what it does is probably GC algorithm dependent. Does this work across all the GCs in Hotspot?", "url": "https://github.com/tensorflow/java/pull/42#discussion_r412425083", "createdAt": "2020-04-21T19:17:28Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerSession.java", "diffHunk": "@@ -364,174 +353,38 @@ ResourceCleanupStrategy resourceCleanupStrategy() {\n     return resourceCleanupStrategy;\n   }\n \n-  /**\n-   * A reference to one or more allocated native resources.\n-   *\n-   * <p>Any Java objects owning native resources must declare a reference to those resources in a\n-   * subclass that extends from {@code NativeReference}. When {@link NativeReference#delete()} is\n-   * invoked, the resources must be freed. For example:\n-   *\n-   * <pre>{@code\n-   * private static class NativeReference extends EagerSession.NativeReference {\n-   *\n-   *    NativeReference(EagerSession session, MyClass referent, long handle) {\n-   *        super(session, referent);\n-   *        this.handle = handle;\n-   *    }\n-   *\n-   *    @Override\n-   *    void delete() {\n-   *        MyClass.nativeDelete(handle);\n-   *    }\n-   *\n-   *    private final long handle;\n-   * }\n-   * }</pre>\n-   *\n-   * A Java object \"owns\" a native resource if this resource should not survive beyond the lifetime\n-   * of this object.\n-   *\n-   * <p><b>IMPORTANT</b>: All nested subclasses of {@code NativeReference} must be declared as\n-   * static, otherwise their instances will hold an implicit reference to their enclosing object,\n-   * preventing the garbage collector to release them when they are no longer needed.\n-   */\n-  abstract static class NativeReference extends PhantomReference<Object> {\n-\n-    /** Attach a new phantom reference of {@code referent} to {@code session}. */\n-    public NativeReference(EagerSession session, Object referent) {\n-      super(referent, session.nativeResources.garbageQueue);\n-      session.checkSession();\n-      nativeResources = session.nativeResources;\n-      nativeResources.attach(this);\n-    }\n-\n-    /**\n-     * Detach this reference from its current session.\n-     *\n-     * <p>Clearing a NativeReference does not invoke {@link #delete()}, thus won't release the\n-     * native resources it refers to. It can be used when passing the ownership of those resources\n-     * to another object.\n-     *\n-     * <p>If native resources needs to be deleted as well, call {@link #delete()} explicitly.\n-     */\n-    @Override\n-    public void clear() {\n-      nativeResources.detach(this);\n-      super.clear();\n+  void attach(Pointer... resources) {\n+    checkSession();\n+    for (Pointer r : resources) {\n+      nativeResources.attach(r);\n     }\n-\n-    /** Releases all native resources owned by the referred object, now deleted. */\n-    abstract void delete();\n-\n-    private final NativeResourceCollector nativeResources;\n   }\n \n-  /**\n-   * Collects native references attached to this session and releases their resources if they are no\n-   * longer needed.\n-   */\n-  private static class NativeResourceCollector {\n-\n-    NativeResourceCollector(ReferenceQueue<Object> garbageQueue) {\n-      this.garbageQueue = garbageQueue;\n-    }\n-\n-    void attach(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        nativeRefs.put(nativeRef, null);\n-      }\n-    }\n-\n-    void detach(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        nativeRefs.remove(nativeRef);\n-      }\n-    }\n-\n-    void delete(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        if (!nativeRefs.keySet().remove(nativeRef)) {\n-          return; // safety check\n-        }\n-      }\n-      nativeRef.delete();\n-    }\n-\n-    void deleteAll() {\n-      synchronized (nativeRefs) {\n-        for (NativeReference nativeRef : nativeRefs.keySet()) {\n-          nativeRef.delete();\n-        }\n-        nativeRefs.clear();\n-      }\n-    }\n-\n-    void tryCleanup() {\n-      Reference<?> nativeRef;\n-      synchronized (nativeRefs) {\n-        while ((nativeRef = garbageQueue.poll()) != null) {\n-          delete((NativeReference) nativeRef);\n-        }\n-      }\n-    }\n-\n-    synchronized void startCleanupThread() {\n-      if (cleanupInBackground) {\n-        return; // ignore if cleanup thread is already running\n-      }\n-      try {\n-        cleanupInBackground = true;\n-        cleanupService.execute(\n-            new Runnable() {\n-              @Override\n-              public void run() {\n-                try {\n-                  while (cleanupInBackground) {\n-                    NativeReference nativeRef = (NativeReference) garbageQueue.remove();\n-                    delete(nativeRef);\n-                  }\n-                } catch (InterruptedException e) {\n-                  // exit\n-                }\n-              }\n-            });\n-      } catch (Exception e) {\n-        cleanupInBackground = false;\n-        throw e;\n+  void detach(Pointer... resources) {\n+    checkSession();\n+    for (Pointer r : resources) {\n+      if (resourceCleanupStrategy == ResourceCleanupStrategy.ON_SAFE_POINTS) {\n+          nativeRefs.attach(r);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgyNzAxNA=="}, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjgwOTEyNw==", "bodyText": "Like I said, it's a safety net, precisely because Java does not provide any guarantees that anything gets done at all, it shouldn't be relied upon.", "url": "https://github.com/tensorflow/java/pull/42#discussion_r412809127", "createdAt": "2020-04-22T09:08:41Z", "author": {"login": "saudet"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerSession.java", "diffHunk": "@@ -364,174 +353,38 @@ ResourceCleanupStrategy resourceCleanupStrategy() {\n     return resourceCleanupStrategy;\n   }\n \n-  /**\n-   * A reference to one or more allocated native resources.\n-   *\n-   * <p>Any Java objects owning native resources must declare a reference to those resources in a\n-   * subclass that extends from {@code NativeReference}. When {@link NativeReference#delete()} is\n-   * invoked, the resources must be freed. For example:\n-   *\n-   * <pre>{@code\n-   * private static class NativeReference extends EagerSession.NativeReference {\n-   *\n-   *    NativeReference(EagerSession session, MyClass referent, long handle) {\n-   *        super(session, referent);\n-   *        this.handle = handle;\n-   *    }\n-   *\n-   *    @Override\n-   *    void delete() {\n-   *        MyClass.nativeDelete(handle);\n-   *    }\n-   *\n-   *    private final long handle;\n-   * }\n-   * }</pre>\n-   *\n-   * A Java object \"owns\" a native resource if this resource should not survive beyond the lifetime\n-   * of this object.\n-   *\n-   * <p><b>IMPORTANT</b>: All nested subclasses of {@code NativeReference} must be declared as\n-   * static, otherwise their instances will hold an implicit reference to their enclosing object,\n-   * preventing the garbage collector to release them when they are no longer needed.\n-   */\n-  abstract static class NativeReference extends PhantomReference<Object> {\n-\n-    /** Attach a new phantom reference of {@code referent} to {@code session}. */\n-    public NativeReference(EagerSession session, Object referent) {\n-      super(referent, session.nativeResources.garbageQueue);\n-      session.checkSession();\n-      nativeResources = session.nativeResources;\n-      nativeResources.attach(this);\n-    }\n-\n-    /**\n-     * Detach this reference from its current session.\n-     *\n-     * <p>Clearing a NativeReference does not invoke {@link #delete()}, thus won't release the\n-     * native resources it refers to. It can be used when passing the ownership of those resources\n-     * to another object.\n-     *\n-     * <p>If native resources needs to be deleted as well, call {@link #delete()} explicitly.\n-     */\n-    @Override\n-    public void clear() {\n-      nativeResources.detach(this);\n-      super.clear();\n+  void attach(Pointer... resources) {\n+    checkSession();\n+    for (Pointer r : resources) {\n+      nativeResources.attach(r);\n     }\n-\n-    /** Releases all native resources owned by the referred object, now deleted. */\n-    abstract void delete();\n-\n-    private final NativeResourceCollector nativeResources;\n   }\n \n-  /**\n-   * Collects native references attached to this session and releases their resources if they are no\n-   * longer needed.\n-   */\n-  private static class NativeResourceCollector {\n-\n-    NativeResourceCollector(ReferenceQueue<Object> garbageQueue) {\n-      this.garbageQueue = garbageQueue;\n-    }\n-\n-    void attach(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        nativeRefs.put(nativeRef, null);\n-      }\n-    }\n-\n-    void detach(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        nativeRefs.remove(nativeRef);\n-      }\n-    }\n-\n-    void delete(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        if (!nativeRefs.keySet().remove(nativeRef)) {\n-          return; // safety check\n-        }\n-      }\n-      nativeRef.delete();\n-    }\n-\n-    void deleteAll() {\n-      synchronized (nativeRefs) {\n-        for (NativeReference nativeRef : nativeRefs.keySet()) {\n-          nativeRef.delete();\n-        }\n-        nativeRefs.clear();\n-      }\n-    }\n-\n-    void tryCleanup() {\n-      Reference<?> nativeRef;\n-      synchronized (nativeRefs) {\n-        while ((nativeRef = garbageQueue.poll()) != null) {\n-          delete((NativeReference) nativeRef);\n-        }\n-      }\n-    }\n-\n-    synchronized void startCleanupThread() {\n-      if (cleanupInBackground) {\n-        return; // ignore if cleanup thread is already running\n-      }\n-      try {\n-        cleanupInBackground = true;\n-        cleanupService.execute(\n-            new Runnable() {\n-              @Override\n-              public void run() {\n-                try {\n-                  while (cleanupInBackground) {\n-                    NativeReference nativeRef = (NativeReference) garbageQueue.remove();\n-                    delete(nativeRef);\n-                  }\n-                } catch (InterruptedException e) {\n-                  // exit\n-                }\n-              }\n-            });\n-      } catch (Exception e) {\n-        cleanupInBackground = false;\n-        throw e;\n+  void detach(Pointer... resources) {\n+    checkSession();\n+    for (Pointer r : resources) {\n+      if (resourceCleanupStrategy == ResourceCleanupStrategy.ON_SAFE_POINTS) {\n+          nativeRefs.attach(r);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgyNzAxNA=="}, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5MTUyNQ==", "bodyText": "Then for the sake of simplicity, I opt to remove these options as well, the timing is still good for doing such changes. Anyway we can't disable the GC thread only at the eager session level anymore so they don't make much sense to have them there, if they have to be restored, it would be in a different place.", "url": "https://github.com/tensorflow/java/pull/42#discussion_r413491525", "createdAt": "2020-04-23T04:00:54Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerSession.java", "diffHunk": "@@ -364,174 +353,38 @@ ResourceCleanupStrategy resourceCleanupStrategy() {\n     return resourceCleanupStrategy;\n   }\n \n-  /**\n-   * A reference to one or more allocated native resources.\n-   *\n-   * <p>Any Java objects owning native resources must declare a reference to those resources in a\n-   * subclass that extends from {@code NativeReference}. When {@link NativeReference#delete()} is\n-   * invoked, the resources must be freed. For example:\n-   *\n-   * <pre>{@code\n-   * private static class NativeReference extends EagerSession.NativeReference {\n-   *\n-   *    NativeReference(EagerSession session, MyClass referent, long handle) {\n-   *        super(session, referent);\n-   *        this.handle = handle;\n-   *    }\n-   *\n-   *    @Override\n-   *    void delete() {\n-   *        MyClass.nativeDelete(handle);\n-   *    }\n-   *\n-   *    private final long handle;\n-   * }\n-   * }</pre>\n-   *\n-   * A Java object \"owns\" a native resource if this resource should not survive beyond the lifetime\n-   * of this object.\n-   *\n-   * <p><b>IMPORTANT</b>: All nested subclasses of {@code NativeReference} must be declared as\n-   * static, otherwise their instances will hold an implicit reference to their enclosing object,\n-   * preventing the garbage collector to release them when they are no longer needed.\n-   */\n-  abstract static class NativeReference extends PhantomReference<Object> {\n-\n-    /** Attach a new phantom reference of {@code referent} to {@code session}. */\n-    public NativeReference(EagerSession session, Object referent) {\n-      super(referent, session.nativeResources.garbageQueue);\n-      session.checkSession();\n-      nativeResources = session.nativeResources;\n-      nativeResources.attach(this);\n-    }\n-\n-    /**\n-     * Detach this reference from its current session.\n-     *\n-     * <p>Clearing a NativeReference does not invoke {@link #delete()}, thus won't release the\n-     * native resources it refers to. It can be used when passing the ownership of those resources\n-     * to another object.\n-     *\n-     * <p>If native resources needs to be deleted as well, call {@link #delete()} explicitly.\n-     */\n-    @Override\n-    public void clear() {\n-      nativeResources.detach(this);\n-      super.clear();\n+  void attach(Pointer... resources) {\n+    checkSession();\n+    for (Pointer r : resources) {\n+      nativeResources.attach(r);\n     }\n-\n-    /** Releases all native resources owned by the referred object, now deleted. */\n-    abstract void delete();\n-\n-    private final NativeResourceCollector nativeResources;\n   }\n \n-  /**\n-   * Collects native references attached to this session and releases their resources if they are no\n-   * longer needed.\n-   */\n-  private static class NativeResourceCollector {\n-\n-    NativeResourceCollector(ReferenceQueue<Object> garbageQueue) {\n-      this.garbageQueue = garbageQueue;\n-    }\n-\n-    void attach(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        nativeRefs.put(nativeRef, null);\n-      }\n-    }\n-\n-    void detach(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        nativeRefs.remove(nativeRef);\n-      }\n-    }\n-\n-    void delete(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        if (!nativeRefs.keySet().remove(nativeRef)) {\n-          return; // safety check\n-        }\n-      }\n-      nativeRef.delete();\n-    }\n-\n-    void deleteAll() {\n-      synchronized (nativeRefs) {\n-        for (NativeReference nativeRef : nativeRefs.keySet()) {\n-          nativeRef.delete();\n-        }\n-        nativeRefs.clear();\n-      }\n-    }\n-\n-    void tryCleanup() {\n-      Reference<?> nativeRef;\n-      synchronized (nativeRefs) {\n-        while ((nativeRef = garbageQueue.poll()) != null) {\n-          delete((NativeReference) nativeRef);\n-        }\n-      }\n-    }\n-\n-    synchronized void startCleanupThread() {\n-      if (cleanupInBackground) {\n-        return; // ignore if cleanup thread is already running\n-      }\n-      try {\n-        cleanupInBackground = true;\n-        cleanupService.execute(\n-            new Runnable() {\n-              @Override\n-              public void run() {\n-                try {\n-                  while (cleanupInBackground) {\n-                    NativeReference nativeRef = (NativeReference) garbageQueue.remove();\n-                    delete(nativeRef);\n-                  }\n-                } catch (InterruptedException e) {\n-                  // exit\n-                }\n-              }\n-            });\n-      } catch (Exception e) {\n-        cleanupInBackground = false;\n-        throw e;\n+  void detach(Pointer... resources) {\n+    checkSession();\n+    for (Pointer r : resources) {\n+      if (resourceCleanupStrategy == ResourceCleanupStrategy.ON_SAFE_POINTS) {\n+          nativeRefs.attach(r);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgyNzAxNA=="}, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzUzNDMzMw==", "bodyText": "\"Safety net\" isn't the right analogy. System.gc() is actually a last-ditch effort, but it usually helps avoid OutOfMemoryError, so that's why it's there.", "url": "https://github.com/tensorflow/java/pull/42#discussion_r413534333", "createdAt": "2020-04-23T06:08:07Z", "author": {"login": "saudet"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerSession.java", "diffHunk": "@@ -364,174 +353,38 @@ ResourceCleanupStrategy resourceCleanupStrategy() {\n     return resourceCleanupStrategy;\n   }\n \n-  /**\n-   * A reference to one or more allocated native resources.\n-   *\n-   * <p>Any Java objects owning native resources must declare a reference to those resources in a\n-   * subclass that extends from {@code NativeReference}. When {@link NativeReference#delete()} is\n-   * invoked, the resources must be freed. For example:\n-   *\n-   * <pre>{@code\n-   * private static class NativeReference extends EagerSession.NativeReference {\n-   *\n-   *    NativeReference(EagerSession session, MyClass referent, long handle) {\n-   *        super(session, referent);\n-   *        this.handle = handle;\n-   *    }\n-   *\n-   *    @Override\n-   *    void delete() {\n-   *        MyClass.nativeDelete(handle);\n-   *    }\n-   *\n-   *    private final long handle;\n-   * }\n-   * }</pre>\n-   *\n-   * A Java object \"owns\" a native resource if this resource should not survive beyond the lifetime\n-   * of this object.\n-   *\n-   * <p><b>IMPORTANT</b>: All nested subclasses of {@code NativeReference} must be declared as\n-   * static, otherwise their instances will hold an implicit reference to their enclosing object,\n-   * preventing the garbage collector to release them when they are no longer needed.\n-   */\n-  abstract static class NativeReference extends PhantomReference<Object> {\n-\n-    /** Attach a new phantom reference of {@code referent} to {@code session}. */\n-    public NativeReference(EagerSession session, Object referent) {\n-      super(referent, session.nativeResources.garbageQueue);\n-      session.checkSession();\n-      nativeResources = session.nativeResources;\n-      nativeResources.attach(this);\n-    }\n-\n-    /**\n-     * Detach this reference from its current session.\n-     *\n-     * <p>Clearing a NativeReference does not invoke {@link #delete()}, thus won't release the\n-     * native resources it refers to. It can be used when passing the ownership of those resources\n-     * to another object.\n-     *\n-     * <p>If native resources needs to be deleted as well, call {@link #delete()} explicitly.\n-     */\n-    @Override\n-    public void clear() {\n-      nativeResources.detach(this);\n-      super.clear();\n+  void attach(Pointer... resources) {\n+    checkSession();\n+    for (Pointer r : resources) {\n+      nativeResources.attach(r);\n     }\n-\n-    /** Releases all native resources owned by the referred object, now deleted. */\n-    abstract void delete();\n-\n-    private final NativeResourceCollector nativeResources;\n   }\n \n-  /**\n-   * Collects native references attached to this session and releases their resources if they are no\n-   * longer needed.\n-   */\n-  private static class NativeResourceCollector {\n-\n-    NativeResourceCollector(ReferenceQueue<Object> garbageQueue) {\n-      this.garbageQueue = garbageQueue;\n-    }\n-\n-    void attach(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        nativeRefs.put(nativeRef, null);\n-      }\n-    }\n-\n-    void detach(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        nativeRefs.remove(nativeRef);\n-      }\n-    }\n-\n-    void delete(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        if (!nativeRefs.keySet().remove(nativeRef)) {\n-          return; // safety check\n-        }\n-      }\n-      nativeRef.delete();\n-    }\n-\n-    void deleteAll() {\n-      synchronized (nativeRefs) {\n-        for (NativeReference nativeRef : nativeRefs.keySet()) {\n-          nativeRef.delete();\n-        }\n-        nativeRefs.clear();\n-      }\n-    }\n-\n-    void tryCleanup() {\n-      Reference<?> nativeRef;\n-      synchronized (nativeRefs) {\n-        while ((nativeRef = garbageQueue.poll()) != null) {\n-          delete((NativeReference) nativeRef);\n-        }\n-      }\n-    }\n-\n-    synchronized void startCleanupThread() {\n-      if (cleanupInBackground) {\n-        return; // ignore if cleanup thread is already running\n-      }\n-      try {\n-        cleanupInBackground = true;\n-        cleanupService.execute(\n-            new Runnable() {\n-              @Override\n-              public void run() {\n-                try {\n-                  while (cleanupInBackground) {\n-                    NativeReference nativeRef = (NativeReference) garbageQueue.remove();\n-                    delete(nativeRef);\n-                  }\n-                } catch (InterruptedException e) {\n-                  // exit\n-                }\n-              }\n-            });\n-      } catch (Exception e) {\n-        cleanupInBackground = false;\n-        throw e;\n+  void detach(Pointer... resources) {\n+    checkSession();\n+    for (Pointer r : resources) {\n+      if (resourceCleanupStrategy == ResourceCleanupStrategy.ON_SAFE_POINTS) {\n+          nativeRefs.attach(r);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgyNzAxNA=="}, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5MDAwOTQ0OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMzo0NToxMlrOGNBNyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxMzo0MDoyMVrOGNUjqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwNDU4Nw==", "bodyText": "Can you please elaborate more on how PointerScope is working?\nFor instance, the scope define in this method is not passed anywhere so I assume that the pointer created by TFE_Op.newOp is automatically attached to it on creation? Then, since we are already in the scope of another PointerScope (the one passed as outputScope), would it be automatically attached to it as well if we were not declaring a new one here (and shouldn't that be enough)?\nIf it is not required, I think it would make the code easier to follow not having so many scopes declared during the process.", "url": "https://github.com/tensorflow/java/pull/42#discussion_r416304587", "createdAt": "2020-04-28T03:45:12Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -277,22 +257,18 @@ private static void requireTensorHandle(TFE_TensorHandle handle) {\n     }\n   }\n \n-  private static TFE_Op allocate(TFE_Context ctxHandle, String type) {\n+  private static TFE_Op allocate(TFE_Context ctxHandle, String type, PointerScope outputScope) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f39f3a563d659493e6d9b5b3d2d140d144664f5"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwODczNg==", "bodyText": "In other words, instead of :\nvoid create() {\n  try (PointerScope scope = new PointerScope()) {\n    allocate(scope);\n  }\n}\n\nprivate void allocate(PointerScope outputScope) {\n  try (PointerScope scope = new PointerScope()) {\n    Pointer p = new Pointer();\n    outputScope.attach(p);\n  }\n}\n, can't we simply do this?\nvoid create() {\n  try (PointerScope scope = new PointerScope()) {\n    allocate(scope);\n  }\n}\n\nprivate void allocate(PointerScope outputScope) {\n  return new Pointer();\n}", "url": "https://github.com/tensorflow/java/pull/42#discussion_r416308736", "createdAt": "2020-04-28T03:58:22Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -277,22 +257,18 @@ private static void requireTensorHandle(TFE_TensorHandle handle) {\n     }\n   }\n \n-  private static TFE_Op allocate(TFE_Context ctxHandle, String type) {\n+  private static TFE_Op allocate(TFE_Context ctxHandle, String type, PointerScope outputScope) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwNDU4Nw=="}, "originalCommit": {"oid": "2f39f3a563d659493e6d9b5b3d2d140d144664f5"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxMTE0Nw==", "bodyText": "Can you please elaborate more on how PointerScope is working?\n\n\nhttp://bytedeco.org/news/2018/07/17/bytedeco-as-distribution/\nkarllessard/tensorflow-java-sandbox#3\n\n\nFor instance, the scope define in this method is not passed anywhere so I assume that the pointer created by TFE_Op.newOp is automatically attached to it on creation? Then, since we are already in the scope of another PointerScope (the one passed as outputScope), would it be automatically attached to it as well if we were not declaring a new one here (and shouldn't that be enough)?\n\nYes, that's the general idea. We need the new scopes to clean up any local resources that we don't want lying around.\n\nIf it is not required, I think it would make the code easier to follow not having so many scopes declared during the process.\n\nSurely, but I don't see an easier way of doing this, short of doing reference counting manually. Would you like to go that way? :) FWIW, to make it prettier, this pattern should really be integrated into the Java language. There's still most likely some more that can be done at the library level. I'll be updating JavaCPP with any ideas that help, for sure, but I'm not having any more for now...", "url": "https://github.com/tensorflow/java/pull/42#discussion_r416311147", "createdAt": "2020-04-28T04:06:33Z", "author": {"login": "saudet"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -277,22 +257,18 @@ private static void requireTensorHandle(TFE_TensorHandle handle) {\n     }\n   }\n \n-  private static TFE_Op allocate(TFE_Context ctxHandle, String type) {\n+  private static TFE_Op allocate(TFE_Context ctxHandle, String type, PointerScope outputScope) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwNDU4Nw=="}, "originalCommit": {"oid": "2f39f3a563d659493e6d9b5b3d2d140d144664f5"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMxMjkzOA==", "bodyText": "can't we simply do this?\n\nYes, but this is not what we have. We've got at least the status object to deallocate here.", "url": "https://github.com/tensorflow/java/pull/42#discussion_r416312938", "createdAt": "2020-04-28T04:12:38Z", "author": {"login": "saudet"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -277,22 +257,18 @@ private static void requireTensorHandle(TFE_TensorHandle handle) {\n     }\n   }\n \n-  private static TFE_Op allocate(TFE_Context ctxHandle, String type) {\n+  private static TFE_Op allocate(TFE_Context ctxHandle, String type, PointerScope outputScope) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwNDU4Nw=="}, "originalCommit": {"oid": "2f39f3a563d659493e6d9b5b3d2d140d144664f5"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU3OTIxMA==", "bodyText": "I'm refactoring this a bit to get rid of those temporary scopes by using the scopes already available in the session objects. I'll push the changes soon.", "url": "https://github.com/tensorflow/java/pull/42#discussion_r416579210", "createdAt": "2020-04-28T12:40:11Z", "author": {"login": "saudet"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -277,22 +257,18 @@ private static void requireTensorHandle(TFE_TensorHandle handle) {\n     }\n   }\n \n-  private static TFE_Op allocate(TFE_Context ctxHandle, String type) {\n+  private static TFE_Op allocate(TFE_Context ctxHandle, String type, PointerScope outputScope) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwNDU4Nw=="}, "originalCommit": {"oid": "2f39f3a563d659493e6d9b5b3d2d140d144664f5"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU3OTgzMg==", "bodyText": "But the status will be deallocated ultimately by the outer scope as well, right?\nI suggest then that we opt for simplicity and that we let the outer scopes release resources allocated by their private helper methods, which will probably end up being inlined anyway if we can them simple enough.\nI understand it might be less \u00ab\u00a0safe\u00a0\u00bb but I would be very surprised if something goes wrong and I take full responsibility if it does :)", "url": "https://github.com/tensorflow/java/pull/42#discussion_r416579832", "createdAt": "2020-04-28T12:41:08Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -277,22 +257,18 @@ private static void requireTensorHandle(TFE_TensorHandle handle) {\n     }\n   }\n \n-  private static TFE_Op allocate(TFE_Context ctxHandle, String type) {\n+  private static TFE_Op allocate(TFE_Context ctxHandle, String type, PointerScope outputScope) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwNDU4Nw=="}, "originalCommit": {"oid": "2f39f3a563d659493e6d9b5b3d2d140d144664f5"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjU4OTAyMg==", "bodyText": "Sure, we can refactor some more and start inlining those private methods. We don't need to keep them separate now that we're not writing JNI anymore. Anyway, let me know if it's good enough with the latest changes.", "url": "https://github.com/tensorflow/java/pull/42#discussion_r416589022", "createdAt": "2020-04-28T12:55:29Z", "author": {"login": "saudet"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -277,22 +257,18 @@ private static void requireTensorHandle(TFE_TensorHandle handle) {\n     }\n   }\n \n-  private static TFE_Op allocate(TFE_Context ctxHandle, String type) {\n+  private static TFE_Op allocate(TFE_Context ctxHandle, String type, PointerScope outputScope) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwNDU4Nw=="}, "originalCommit": {"oid": "2f39f3a563d659493e6d9b5b3d2d140d144664f5"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjYyMTQ4Mg==", "bodyText": "Yep, looks good!", "url": "https://github.com/tensorflow/java/pull/42#discussion_r416621482", "createdAt": "2020-04-28T13:40:21Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -277,22 +257,18 @@ private static void requireTensorHandle(TFE_TensorHandle handle) {\n     }\n   }\n \n-  private static TFE_Op allocate(TFE_Context ctxHandle, String type) {\n+  private static TFE_Op allocate(TFE_Context ctxHandle, String type, PointerScope outputScope) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwNDU4Nw=="}, "originalCommit": {"oid": "2f39f3a563d659493e6d9b5b3d2d140d144664f5"}, "originalPosition": 208}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1602, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}