{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5OTE5NzI0", "number": 116, "reviewThreads": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo0Mjo1N1rOElum3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDowMDo0NFrOEp7uhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTk2MzgwOnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Constant.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo0Mjo1N1rOHVXN_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMTowNDoxOFrOHViXHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MjU1OA==", "bodyText": "If we're casting to a double here why not just store it as a double? We're going to lose some precision from longs whatever, but then we save any boxing and casting overhead.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492162558", "createdAt": "2020-09-21T15:42:57Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Constant.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates tensors with a constant value.\n+ *\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *      Constant&lt;TFloat32&gt; initializer =\n+ *              new org.tensorflow.framework.initializers.Constant&lt;&gt;(tf, 3f);\n+ *      Operand&lt;TFloat32&gt; values =\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The Type for the call operation\n+ */\n+public class Constant<T extends TType> extends BaseInitializer<T> {\n+\n+  private final Number numberValue;\n+  private final Boolean booleanValue;\n+\n+  /**\n+   * Creates an Initializer that generates tensors with a constant value.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param value a number value\n+   */\n+  public Constant(Ops tf, Number value) {\n+    super(tf);\n+    this.numberValue = value;\n+    this.booleanValue = null;\n+  }\n+\n+  /**\n+   * Creates an Initializer that generates tensors with a constant value.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param value a boolean value\n+   */\n+  public Constant(Ops tf, Boolean value) {\n+    super(tf);\n+    this.numberValue = null;\n+    this.booleanValue = value;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!(dtype.isNumeric() || dtype.isBoolean())) {\n+      throw new IllegalArgumentException(\"DataType must be numeric or boolean: \" + dtype.name());\n+    }\n+    if (this.numberValue != null) {\n+      return tf.fill(dims, tf.dtypes.cast(tf.constant(numberValue.doubleValue()), dtype));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3NzIxNA==", "bodyText": "The basic requirement is to store either a number(integer + float) or a boolean.  What ever the most efficient way to do that is fine with me.\nOriginally I had it as Number, so it could be set to null, while the Boolean would be set. Vice-versa the other way. I could have a private flag to distinguish the two separate cases.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492277214", "createdAt": "2020-09-21T18:54:44Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Constant.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates tensors with a constant value.\n+ *\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *      Constant&lt;TFloat32&gt; initializer =\n+ *              new org.tensorflow.framework.initializers.Constant&lt;&gt;(tf, 3f);\n+ *      Operand&lt;TFloat32&gt; values =\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The Type for the call operation\n+ */\n+public class Constant<T extends TType> extends BaseInitializer<T> {\n+\n+  private final Number numberValue;\n+  private final Boolean booleanValue;\n+\n+  /**\n+   * Creates an Initializer that generates tensors with a constant value.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param value a number value\n+   */\n+  public Constant(Ops tf, Number value) {\n+    super(tf);\n+    this.numberValue = value;\n+    this.booleanValue = null;\n+  }\n+\n+  /**\n+   * Creates an Initializer that generates tensors with a constant value.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param value a boolean value\n+   */\n+  public Constant(Ops tf, Boolean value) {\n+    super(tf);\n+    this.numberValue = null;\n+    this.booleanValue = value;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!(dtype.isNumeric() || dtype.isBoolean())) {\n+      throw new IllegalArgumentException(\"DataType must be numeric or boolean: \" + dtype.name());\n+    }\n+    if (this.numberValue != null) {\n+      return tf.fill(dims, tf.dtypes.cast(tf.constant(numberValue.doubleValue()), dtype));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MjU1OA=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM0Mzk4OA==", "bodyText": "Fair enough.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492343988", "createdAt": "2020-09-21T21:01:53Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Constant.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates tensors with a constant value.\n+ *\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *      Constant&lt;TFloat32&gt; initializer =\n+ *              new org.tensorflow.framework.initializers.Constant&lt;&gt;(tf, 3f);\n+ *      Operand&lt;TFloat32&gt; values =\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The Type for the call operation\n+ */\n+public class Constant<T extends TType> extends BaseInitializer<T> {\n+\n+  private final Number numberValue;\n+  private final Boolean booleanValue;\n+\n+  /**\n+   * Creates an Initializer that generates tensors with a constant value.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param value a number value\n+   */\n+  public Constant(Ops tf, Number value) {\n+    super(tf);\n+    this.numberValue = value;\n+    this.booleanValue = null;\n+  }\n+\n+  /**\n+   * Creates an Initializer that generates tensors with a constant value.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param value a boolean value\n+   */\n+  public Constant(Ops tf, Boolean value) {\n+    super(tf);\n+    this.numberValue = null;\n+    this.booleanValue = value;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!(dtype.isNumeric() || dtype.isBoolean())) {\n+      throw new IllegalArgumentException(\"DataType must be numeric or boolean: \" + dtype.name());\n+    }\n+    if (this.numberValue != null) {\n+      return tf.fill(dims, tf.dtypes.cast(tf.constant(numberValue.doubleValue()), dtype));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MjU1OA=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM0NTExNg==", "bodyText": "I changed it to long longValue, double doubleValue, boolean booleanValue with an enum\nprivate enum ValueType {\n    LONG, DOUBLE, BOOLEAN\n }\n\nThat way, the integer and double precision is maintained.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492345116", "createdAt": "2020-09-21T21:04:18Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Constant.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates tensors with a constant value.\n+ *\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *      Constant&lt;TFloat32&gt; initializer =\n+ *              new org.tensorflow.framework.initializers.Constant&lt;&gt;(tf, 3f);\n+ *      Operand&lt;TFloat32&gt; values =\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The Type for the call operation\n+ */\n+public class Constant<T extends TType> extends BaseInitializer<T> {\n+\n+  private final Number numberValue;\n+  private final Boolean booleanValue;\n+\n+  /**\n+   * Creates an Initializer that generates tensors with a constant value.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param value a number value\n+   */\n+  public Constant(Ops tf, Number value) {\n+    super(tf);\n+    this.numberValue = value;\n+    this.booleanValue = null;\n+  }\n+\n+  /**\n+   * Creates an Initializer that generates tensors with a constant value.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param value a boolean value\n+   */\n+  public Constant(Ops tf, Boolean value) {\n+    super(tf);\n+    this.numberValue = null;\n+    this.booleanValue = value;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!(dtype.isNumeric() || dtype.isBoolean())) {\n+      throw new IllegalArgumentException(\"DataType must be numeric or boolean: \" + dtype.name());\n+    }\n+    if (this.numberValue != null) {\n+      return tf.fill(dims, tf.dtypes.cast(tf.constant(numberValue.doubleValue()), dtype));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MjU1OA=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTk3NDg2OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/HeUniform.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo0NToyMVrOHVXUnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMToxMzoyMVrOHWMmLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NDI1Mw==", "bodyText": "Why not have a single He class that accepts the distribution directly? Ditto for Glorot.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492164253", "createdAt": "2020-09-21T15:45:21Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/HeUniform.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * He uniform initializer.\n+ * <p>Draws samples from a uniform distribution within <code>[-limit, limit]</code>, where <code>limit = sqrt(6 / fanIn)</code> (fan_in is the number of input units in the weight tensor).</p>\n+ * <p>Examples:\n+ * <pre>\n+ *     HeUniform&lt;TFloat32, TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.HeUniform&lt;&gt;(tf);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ *\n+ * @see <a href=\"https://www.cv-foundation.org/openaccess/content_iccv_2015/html/He_Delving_Deep_into_ICCV_2015_paper.html\">He et al., 2015</a>\n+ */\n+public class HeUniform<T extends TType, U extends TNumber> extends VarianceScaling<T, U> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI4MTg5Mw==", "bodyText": "Since we are not totally bound to the Keras way, this makes sense to me.\nShould we reconsider, LeCunNormal/LeCunUniform too?", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492281893", "createdAt": "2020-09-21T19:03:13Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/HeUniform.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * He uniform initializer.\n+ * <p>Draws samples from a uniform distribution within <code>[-limit, limit]</code>, where <code>limit = sqrt(6 / fanIn)</code> (fan_in is the number of input units in the weight tensor).</p>\n+ * <p>Examples:\n+ * <pre>\n+ *     HeUniform&lt;TFloat32, TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.HeUniform&lt;&gt;(tf);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ *\n+ * @see <a href=\"https://www.cv-foundation.org/openaccess/content_iccv_2015/html/He_Delving_Deep_into_ICCV_2015_paper.html\">He et al., 2015</a>\n+ */\n+public class HeUniform<T extends TType, U extends TNumber> extends VarianceScaling<T, U> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NDI1Mw=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMzNzI0OQ==", "bodyText": "Also, should we restrict the distribution to TRUNCATED_NORMAL and UNIFORM, and show exception on UNTRUNCATED_NORMAL", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492337249", "createdAt": "2020-09-21T20:48:41Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/HeUniform.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * He uniform initializer.\n+ * <p>Draws samples from a uniform distribution within <code>[-limit, limit]</code>, where <code>limit = sqrt(6 / fanIn)</code> (fan_in is the number of input units in the weight tensor).</p>\n+ * <p>Examples:\n+ * <pre>\n+ *     HeUniform&lt;TFloat32, TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.HeUniform&lt;&gt;(tf);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ *\n+ * @see <a href=\"https://www.cv-foundation.org/openaccess/content_iccv_2015/html/He_Delving_Deep_into_ICCV_2015_paper.html\">He et al., 2015</a>\n+ */\n+public class HeUniform<T extends TType, U extends TNumber> extends VarianceScaling<T, U> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NDI1Mw=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM0NDU4OQ==", "bodyText": "Erm, I think that allowing all three enum values seems reasonable (someone might want to try all of them and they aren't incorrect), and yes I'd collapse LeCun as well.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492344589", "createdAt": "2020-09-21T21:03:15Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/HeUniform.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * He uniform initializer.\n+ * <p>Draws samples from a uniform distribution within <code>[-limit, limit]</code>, where <code>limit = sqrt(6 / fanIn)</code> (fan_in is the number of input units in the weight tensor).</p>\n+ * <p>Examples:\n+ * <pre>\n+ *     HeUniform&lt;TFloat32, TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.HeUniform&lt;&gt;(tf);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ *\n+ * @see <a href=\"https://www.cv-foundation.org/openaccess/content_iccv_2015/html/He_Delving_Deep_into_ICCV_2015_paper.html\">He et al., 2015</a>\n+ */\n+public class HeUniform<T extends TType, U extends TNumber> extends VarianceScaling<T, U> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NDI1Mw=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAzNzEwMA==", "bodyText": "Ok", "url": "https://github.com/tensorflow/java/pull/116#discussion_r493037100", "createdAt": "2020-09-22T21:13:21Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/HeUniform.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * He uniform initializer.\n+ * <p>Draws samples from a uniform distribution within <code>[-limit, limit]</code>, where <code>limit = sqrt(6 / fanIn)</code> (fan_in is the number of input units in the weight tensor).</p>\n+ * <p>Examples:\n+ * <pre>\n+ *     HeUniform&lt;TFloat32, TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.HeUniform&lt;&gt;(tf);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ *\n+ * @see <a href=\"https://www.cv-foundation.org/openaccess/content_iccv_2015/html/He_Delving_Deep_into_ICCV_2015_paper.html\">He et al., 2015</a>\n+ */\n+public class HeUniform<T extends TType, U extends TNumber> extends VarianceScaling<T, U> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NDI1Mw=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTk3OTQwOnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Identity.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo0NjoyOVrOHVXXgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOToxMDo0OFrOHVextg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NDk5Mg==", "bodyText": "This check doesn't seem to line up with the exception error message?", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492164992", "createdAt": "2020-09-21T15:46:29Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Identity.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.framework.utils.ShapeUtils;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates the identity matrix.\n+ * <p>Only usable for generating 2D matrices.</p>\n+ <p>Examples:\n+ * <pre>\n+ *     Identity&lt;TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Identity&lt;&gt;(tf);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ * @param <T> The TType for the call operation\n+ */\n+public class Identity<T extends TType> extends BaseInitializer<T> {\n+  public static final double GAIN_DEFAULT = 1.0;\n+\n+  private final double gain;\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public Identity(Ops tf) {\n+    super(tf);\n+    this.gain = GAIN_DEFAULT;\n+  }\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param gain the gain to be applied to the Identity Matrix\n+   */\n+  public Identity(Ops tf, double gain) {\n+    super(tf);\n+    this.gain = gain;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!dtype.isFloating()) {\n+      throw new IllegalArgumentException(\"DataType must be numeric or boolean: \" + dtype.name());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI4NjM5MA==", "bodyText": "You're right, it should only be a float.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492286390", "createdAt": "2020-09-21T19:10:48Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Identity.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.framework.utils.ShapeUtils;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates the identity matrix.\n+ * <p>Only usable for generating 2D matrices.</p>\n+ <p>Examples:\n+ * <pre>\n+ *     Identity&lt;TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Identity&lt;&gt;(tf);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ * @param <T> The TType for the call operation\n+ */\n+public class Identity<T extends TType> extends BaseInitializer<T> {\n+  public static final double GAIN_DEFAULT = 1.0;\n+\n+  private final double gain;\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public Identity(Ops tf) {\n+    super(tf);\n+    this.gain = GAIN_DEFAULT;\n+  }\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param gain the gain to be applied to the Identity Matrix\n+   */\n+  public Identity(Ops tf, double gain) {\n+    super(tf);\n+    this.gain = gain;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!dtype.isFloating()) {\n+      throw new IllegalArgumentException(\"DataType must be numeric or boolean: \" + dtype.name());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NDk5Mg=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTk4NjMwOnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Identity.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo0ODoxMVrOHVXb3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDoxMzoxMVrOHafn9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjEwOA==", "bodyText": "Should we just add an op to make an identity matrix next to the Zeros and Ones ops? I feel like it would be pretty useful outside of just this use case.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492166108", "createdAt": "2020-09-21T15:48:11Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Identity.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.framework.utils.ShapeUtils;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates the identity matrix.\n+ * <p>Only usable for generating 2D matrices.</p>\n+ <p>Examples:\n+ * <pre>\n+ *     Identity&lt;TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Identity&lt;&gt;(tf);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ * @param <T> The TType for the call operation\n+ */\n+public class Identity<T extends TType> extends BaseInitializer<T> {\n+  public static final double GAIN_DEFAULT = 1.0;\n+\n+  private final double gain;\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public Identity(Ops tf) {\n+    super(tf);\n+    this.gain = GAIN_DEFAULT;\n+  }\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param gain the gain to be applied to the Identity Matrix\n+   */\n+  public Identity(Ops tf, double gain) {\n+    super(tf);\n+    this.gain = gain;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!dtype.isFloating()) {\n+      throw new IllegalArgumentException(\"DataType must be numeric or boolean: \" + dtype.name());\n+    }\n+    Shape shape = ShapeUtils.toShape(tf.scope(), dims);\n+    if (shape.numDimensions() != 2) {\n+      throw new IllegalArgumentException(\"2D matrix required, got \" + shape.numDimensions());\n+    }\n+    boolean isSquare = shape.size(0) == shape.size(1);\n+    long diag_size = Math.min(shape.size(0), shape.size(1));\n+    Shape diagShape = Shape.of(diag_size);\n+\n+    Operand<T> op;\n+    Operand<T> zero = tf.dtypes.cast(tf.constant(0), dtype);\n+    Operand<T> diag_ones =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA1NTY4Mw==", "bodyText": "Could you explain this a little more? Are you saying, add an op similar to org.tensorflow.op.core.Zeros (tf.zeros)? In TF Java, there is no org.tensorflow.op.core.Ones (nor tf.ones). In Python, tf.ones is implemented in python and ends up calling the fill op.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r493055683", "createdAt": "2020-09-22T21:54:22Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Identity.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.framework.utils.ShapeUtils;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates the identity matrix.\n+ * <p>Only usable for generating 2D matrices.</p>\n+ <p>Examples:\n+ * <pre>\n+ *     Identity&lt;TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Identity&lt;&gt;(tf);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ * @param <T> The TType for the call operation\n+ */\n+public class Identity<T extends TType> extends BaseInitializer<T> {\n+  public static final double GAIN_DEFAULT = 1.0;\n+\n+  private final double gain;\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public Identity(Ops tf) {\n+    super(tf);\n+    this.gain = GAIN_DEFAULT;\n+  }\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param gain the gain to be applied to the Identity Matrix\n+   */\n+  public Identity(Ops tf, double gain) {\n+    super(tf);\n+    this.gain = gain;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!dtype.isFloating()) {\n+      throw new IllegalArgumentException(\"DataType must be numeric or boolean: \" + dtype.name());\n+    }\n+    Shape shape = ShapeUtils.toShape(tf.scope(), dims);\n+    if (shape.numDimensions() != 2) {\n+      throw new IllegalArgumentException(\"2D matrix required, got \" + shape.numDimensions());\n+    }\n+    boolean isSquare = shape.size(0) == shape.size(1);\n+    long diag_size = Math.min(shape.size(0), shape.size(1));\n+    Shape diagShape = Shape.of(diag_size);\n+\n+    Operand<T> op;\n+    Operand<T> zero = tf.dtypes.cast(tf.constant(0), dtype);\n+    Operand<T> diag_ones =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjEwOA=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQwODU1MQ==", "bodyText": "I'd forgot there wasn't a tf.ones, but I think it would probably be worthwhile to add one. Either way I think generating an identity matrix is a useful operation and we shouldn't have it solely exist in the initializers package.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r494408551", "createdAt": "2020-09-24T15:24:36Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Identity.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.framework.utils.ShapeUtils;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates the identity matrix.\n+ * <p>Only usable for generating 2D matrices.</p>\n+ <p>Examples:\n+ * <pre>\n+ *     Identity&lt;TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Identity&lt;&gt;(tf);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ * @param <T> The TType for the call operation\n+ */\n+public class Identity<T extends TType> extends BaseInitializer<T> {\n+  public static final double GAIN_DEFAULT = 1.0;\n+\n+  private final double gain;\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public Identity(Ops tf) {\n+    super(tf);\n+    this.gain = GAIN_DEFAULT;\n+  }\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param gain the gain to be applied to the Identity Matrix\n+   */\n+  public Identity(Ops tf, double gain) {\n+    super(tf);\n+    this.gain = gain;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!dtype.isFloating()) {\n+      throw new IllegalArgumentException(\"DataType must be numeric or boolean: \" + dtype.name());\n+    }\n+    Shape shape = ShapeUtils.toShape(tf.scope(), dims);\n+    if (shape.numDimensions() != 2) {\n+      throw new IllegalArgumentException(\"2D matrix required, got \" + shape.numDimensions());\n+    }\n+    boolean isSquare = shape.size(0) == shape.size(1);\n+    long diag_size = Math.min(shape.size(0), shape.size(1));\n+    Shape diagShape = Shape.of(diag_size);\n+\n+    Operand<T> op;\n+    Operand<T> zero = tf.dtypes.cast(tf.constant(0), dtype);\n+    Operand<T> diag_ones =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjEwOA=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIxMDYxNA==", "bodyText": "I will open another PR on tf.ones and tf.identity. BTW, TF Python already has both.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r495210614", "createdAt": "2020-09-25T20:16:28Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Identity.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.framework.utils.ShapeUtils;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates the identity matrix.\n+ * <p>Only usable for generating 2D matrices.</p>\n+ <p>Examples:\n+ * <pre>\n+ *     Identity&lt;TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Identity&lt;&gt;(tf);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ * @param <T> The TType for the call operation\n+ */\n+public class Identity<T extends TType> extends BaseInitializer<T> {\n+  public static final double GAIN_DEFAULT = 1.0;\n+\n+  private final double gain;\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public Identity(Ops tf) {\n+    super(tf);\n+    this.gain = GAIN_DEFAULT;\n+  }\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param gain the gain to be applied to the Identity Matrix\n+   */\n+  public Identity(Ops tf, double gain) {\n+    super(tf);\n+    this.gain = gain;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!dtype.isFloating()) {\n+      throw new IllegalArgumentException(\"DataType must be numeric or boolean: \" + dtype.name());\n+    }\n+    Shape shape = ShapeUtils.toShape(tf.scope(), dims);\n+    if (shape.numDimensions() != 2) {\n+      throw new IllegalArgumentException(\"2D matrix required, got \" + shape.numDimensions());\n+    }\n+    boolean isSquare = shape.size(0) == shape.size(1);\n+    long diag_size = Math.min(shape.size(0), shape.size(1));\n+    Shape diagShape = Shape.of(diag_size);\n+\n+    Operand<T> op;\n+    Operand<T> zero = tf.dtypes.cast(tf.constant(0), dtype);\n+    Operand<T> diag_ones =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjEwOA=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA4NTAyNw==", "bodyText": "Java TensorFlow has tf.identity, but that is different than an Identity Matrix. Python TensorFlow has tf.eye (written in Python) for creating an Identity Matrix.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r497085027", "createdAt": "2020-09-29T21:58:49Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Identity.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.framework.utils.ShapeUtils;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates the identity matrix.\n+ * <p>Only usable for generating 2D matrices.</p>\n+ <p>Examples:\n+ * <pre>\n+ *     Identity&lt;TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Identity&lt;&gt;(tf);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ * @param <T> The TType for the call operation\n+ */\n+public class Identity<T extends TType> extends BaseInitializer<T> {\n+  public static final double GAIN_DEFAULT = 1.0;\n+\n+  private final double gain;\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public Identity(Ops tf) {\n+    super(tf);\n+    this.gain = GAIN_DEFAULT;\n+  }\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param gain the gain to be applied to the Identity Matrix\n+   */\n+  public Identity(Ops tf, double gain) {\n+    super(tf);\n+    this.gain = gain;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!dtype.isFloating()) {\n+      throw new IllegalArgumentException(\"DataType must be numeric or boolean: \" + dtype.name());\n+    }\n+    Shape shape = ShapeUtils.toShape(tf.scope(), dims);\n+    if (shape.numDimensions() != 2) {\n+      throw new IllegalArgumentException(\"2D matrix required, got \" + shape.numDimensions());\n+    }\n+    boolean isSquare = shape.size(0) == shape.size(1);\n+    long diag_size = Math.min(shape.size(0), shape.size(1));\n+    Shape diagShape = Shape.of(diag_size);\n+\n+    Operand<T> op;\n+    Operand<T> zero = tf.dtypes.cast(tf.constant(0), dtype);\n+    Operand<T> diag_ones =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjEwOA=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU0MzE1Nw==", "bodyText": "Yeah I think the tf.eye mirrors numpy. Presumably tf.identity returns it's input?", "url": "https://github.com/tensorflow/java/pull/116#discussion_r497543157", "createdAt": "2020-09-30T14:13:11Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Identity.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.framework.utils.ShapeUtils;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates the identity matrix.\n+ * <p>Only usable for generating 2D matrices.</p>\n+ <p>Examples:\n+ * <pre>\n+ *     Identity&lt;TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Identity&lt;&gt;(tf);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ * @param <T> The TType for the call operation\n+ */\n+public class Identity<T extends TType> extends BaseInitializer<T> {\n+  public static final double GAIN_DEFAULT = 1.0;\n+\n+  private final double gain;\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public Identity(Ops tf) {\n+    super(tf);\n+    this.gain = GAIN_DEFAULT;\n+  }\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param gain the gain to be applied to the Identity Matrix\n+   */\n+  public Identity(Ops tf, double gain) {\n+    super(tf);\n+    this.gain = gain;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!dtype.isFloating()) {\n+      throw new IllegalArgumentException(\"DataType must be numeric or boolean: \" + dtype.name());\n+    }\n+    Shape shape = ShapeUtils.toShape(tf.scope(), dims);\n+    if (shape.numDimensions() != 2) {\n+      throw new IllegalArgumentException(\"2D matrix required, got \" + shape.numDimensions());\n+    }\n+    boolean isSquare = shape.size(0) == shape.size(1);\n+    long diag_size = Math.min(shape.size(0), shape.size(1));\n+    Shape diagShape = Shape.of(diag_size);\n+\n+    Operand<T> op;\n+    Operand<T> zero = tf.dtypes.cast(tf.constant(0), dtype);\n+    Operand<T> diag_ones =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjEwOA=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA3OTk5OTI3OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Initializers.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo1MTowNVrOHVXj_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMTo0NDo0MlrOHWNeRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2ODE5MQ==", "bodyText": "This worries me as it encourages people to not record the seed of their initializers. In my view any ML code which uses an unseeded PRNG is wrong as it's completely unreplicable and we've already got enough replicability problems in ML.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492168191", "createdAt": "2020-09-21T15:51:05Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Initializers.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.op.Ops;\n+\n+import java.util.function.Function;\n+\n+/** An Enum Type used to create a new Initializer with default parameters. */\n+public enum Initializers {\n+  IDENTITY(Identity::new),\n+  ONES(Ones::new),\n+  ZEROS(Zeros::new),\n+  GLOROT_NORMAL(GlorotNormal::new),\n+  GLOROT_UNIFORM(GlorotUniform::new),\n+  ORTHOGONAL(Orthogonal::new),\n+  RANDOM_NORMAL(RandomNormal::new),\n+  RANDOM_UNIFORM(RandomUniform::new),\n+  TRUNCATED_NORMAL(TruncatedNormal::new),\n+  VARIANCE_SCALING(VarianceScaling::new),\n+  HE_NORMAL(HeNormal::new),\n+  HE_UNIFORM(HeUniform::new),\n+  LECUN_NORMAL(LeCunNormal::new),\n+  LECUN_UNIFORM(LeCunUniform::new);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NzgxMg==", "bodyText": "Seeding should be true of any Initializer that uses a random generator. This is more of a convenience, so maybe we don't need this class in framework. Also the constructors for the the other Random initializers should then require a seed.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492297812", "createdAt": "2020-09-21T19:31:45Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Initializers.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.op.Ops;\n+\n+import java.util.function.Function;\n+\n+/** An Enum Type used to create a new Initializer with default parameters. */\n+public enum Initializers {\n+  IDENTITY(Identity::new),\n+  ONES(Ones::new),\n+  ZEROS(Zeros::new),\n+  GLOROT_NORMAL(GlorotNormal::new),\n+  GLOROT_UNIFORM(GlorotUniform::new),\n+  ORTHOGONAL(Orthogonal::new),\n+  RANDOM_NORMAL(RandomNormal::new),\n+  RANDOM_UNIFORM(RandomUniform::new),\n+  TRUNCATED_NORMAL(TruncatedNormal::new),\n+  VARIANCE_SCALING(VarianceScaling::new),\n+  HE_NORMAL(HeNormal::new),\n+  HE_UNIFORM(HeUniform::new),\n+  LECUN_NORMAL(LeCunNormal::new),\n+  LECUN_UNIFORM(LeCunUniform::new);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2ODE5MQ=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA1MTQ2Mg==", "bodyText": "I have changed a CTORs to require a seed parameter where a seed is used.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r493051462", "createdAt": "2020-09-22T21:44:42Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Initializers.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.op.Ops;\n+\n+import java.util.function.Function;\n+\n+/** An Enum Type used to create a new Initializer with default parameters. */\n+public enum Initializers {\n+  IDENTITY(Identity::new),\n+  ONES(Ones::new),\n+  ZEROS(Zeros::new),\n+  GLOROT_NORMAL(GlorotNormal::new),\n+  GLOROT_UNIFORM(GlorotUniform::new),\n+  ORTHOGONAL(Orthogonal::new),\n+  RANDOM_NORMAL(RandomNormal::new),\n+  RANDOM_UNIFORM(RandomUniform::new),\n+  TRUNCATED_NORMAL(TruncatedNormal::new),\n+  VARIANCE_SCALING(VarianceScaling::new),\n+  HE_NORMAL(HeNormal::new),\n+  HE_UNIFORM(HeUniform::new),\n+  LECUN_NORMAL(LeCunNormal::new),\n+  LECUN_UNIFORM(LeCunUniform::new);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2ODE5MQ=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDAwNjczOnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Orthogonal.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo1Mjo1MVrOHVXoxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo1Mjo1MVrOHVXoxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2OTQxNQ==", "bodyText": "The javadoc should reference this constructor sets the gain to GAIN_DEFAULT.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492169415", "createdAt": "2020-09-21T15:52:51Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Orthogonal.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Output;\n+import org.tensorflow.framework.utils.ShapeUtils;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.linalg.Qr;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates an orthogonal matrix.\n+ * <p>\n+ *     If the shape of the tensor to initialize is two-dimensional, it is initialized with an orthogonal matrix obtained from the QR\n+ *     decomposition of a matrix of random numbers drawn from a normal distribution. If the matrix has fewer rows than\n+ *     columns then the output will have orthogonal rows. Otherwise, the output will have orthogonal columns.\n+ * </p>\n+ * <p>\n+ *    If the shape of the tensor to initialize is more than two-dimensional,\n+ *    a matrix of shape <code>(shape.size(0) * ... * shape.size(n - 2), shape.size(n - 1))</code> is initialized,\n+ *    where <code>n</code> is the length of the shape vector. The matrix is subsequently reshaped\n+ *    to give a tensor of the desired shape.\n+ * </p>\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *      Orthogonal&lt;TFloat32, TFloat32&gt; initializer =\n+ *              new org.tensorflow.framework.initializers.Orthogonal&lt;&gt;(tf);\n+ *      Operand&lt;TFloat32&gt; values =\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ */\n+public class Orthogonal<T extends TType, U extends TNumber> extends BaseInitializer<T> {\n+\n+  public static final double GAIN_DEFAULT = 1.0;\n+\n+  private final double gain;\n+  private final Long seed;\n+\n+  /**\n+   * Creates an Orthogonal Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public Orthogonal(Ops tf) {\n+    this(tf, GAIN_DEFAULT, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDAwNzYwOnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Orthogonal.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo1MzowMlrOHVXpRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo1MzowMlrOHVXpRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2OTU0Mw==", "bodyText": "See previous comment.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492169543", "createdAt": "2020-09-21T15:53:02Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Orthogonal.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Output;\n+import org.tensorflow.framework.utils.ShapeUtils;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.linalg.Qr;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates an orthogonal matrix.\n+ * <p>\n+ *     If the shape of the tensor to initialize is two-dimensional, it is initialized with an orthogonal matrix obtained from the QR\n+ *     decomposition of a matrix of random numbers drawn from a normal distribution. If the matrix has fewer rows than\n+ *     columns then the output will have orthogonal rows. Otherwise, the output will have orthogonal columns.\n+ * </p>\n+ * <p>\n+ *    If the shape of the tensor to initialize is more than two-dimensional,\n+ *    a matrix of shape <code>(shape.size(0) * ... * shape.size(n - 2), shape.size(n - 1))</code> is initialized,\n+ *    where <code>n</code> is the length of the shape vector. The matrix is subsequently reshaped\n+ *    to give a tensor of the desired shape.\n+ * </p>\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *      Orthogonal&lt;TFloat32, TFloat32&gt; initializer =\n+ *              new org.tensorflow.framework.initializers.Orthogonal&lt;&gt;(tf);\n+ *      Operand&lt;TFloat32&gt; values =\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ */\n+public class Orthogonal<T extends TType, U extends TNumber> extends BaseInitializer<T> {\n+\n+  public static final double GAIN_DEFAULT = 1.0;\n+\n+  private final double gain;\n+  private final Long seed;\n+\n+  /**\n+   * Creates an Orthogonal Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public Orthogonal(Ops tf) {\n+    this(tf, GAIN_DEFAULT, null);\n+  }\n+\n+  /**\n+   * Creates an Orthogonal Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param gain the gain to be applied to the Matrix\n+   */\n+  public Orthogonal(Ops tf, double gain) {\n+    this(tf, gain, null);\n+  }\n+\n+  /**\n+   * Creates an Orthogonal Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param seed the seed for random number generation\n+   */\n+  public Orthogonal(Ops tf, Long seed) {\n+    this(tf, GAIN_DEFAULT, seed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDAxNTE0OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Orthogonal.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo1NDo0OVrOHVXuBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNDoxNjowM1rOHafwdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3MDc1OA==", "bodyText": "This seed shouldn't be hidden here. It's part of the public API as it's a breaking change if it's ever modified.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492170758", "createdAt": "2020-09-21T15:54:49Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Orthogonal.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Output;\n+import org.tensorflow.framework.utils.ShapeUtils;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.linalg.Qr;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates an orthogonal matrix.\n+ * <p>\n+ *     If the shape of the tensor to initialize is two-dimensional, it is initialized with an orthogonal matrix obtained from the QR\n+ *     decomposition of a matrix of random numbers drawn from a normal distribution. If the matrix has fewer rows than\n+ *     columns then the output will have orthogonal rows. Otherwise, the output will have orthogonal columns.\n+ * </p>\n+ * <p>\n+ *    If the shape of the tensor to initialize is more than two-dimensional,\n+ *    a matrix of shape <code>(shape.size(0) * ... * shape.size(n - 2), shape.size(n - 1))</code> is initialized,\n+ *    where <code>n</code> is the length of the shape vector. The matrix is subsequently reshaped\n+ *    to give a tensor of the desired shape.\n+ * </p>\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *      Orthogonal&lt;TFloat32, TFloat32&gt; initializer =\n+ *              new org.tensorflow.framework.initializers.Orthogonal&lt;&gt;(tf);\n+ *      Operand&lt;TFloat32&gt; values =\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ */\n+public class Orthogonal<T extends TType, U extends TNumber> extends BaseInitializer<T> {\n+\n+  public static final double GAIN_DEFAULT = 1.0;\n+\n+  private final double gain;\n+  private final Long seed;\n+\n+  /**\n+   * Creates an Orthogonal Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public Orthogonal(Ops tf) {\n+    this(tf, GAIN_DEFAULT, null);\n+  }\n+\n+  /**\n+   * Creates an Orthogonal Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param gain the gain to be applied to the Matrix\n+   */\n+  public Orthogonal(Ops tf, double gain) {\n+    this(tf, gain, null);\n+  }\n+\n+  /**\n+   * Creates an Orthogonal Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param seed the seed for random number generation\n+   */\n+  public Orthogonal(Ops tf, Long seed) {\n+    this(tf, GAIN_DEFAULT, seed);\n+  }\n+\n+  /**\n+   * Creates an Orthogonal Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param gain the gain to be applied to the Matrix\n+   * @param seed the seed for random number generation\n+   */\n+  public Orthogonal(Ops tf, double gain, Long seed) {\n+    super(tf);\n+    this.gain = gain;\n+    this.seed = seed;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!dtype.isFloating()) {\n+      throw new IllegalArgumentException(\"Expected floating point type, got \" + dtype.name());\n+    }\n+    Shape dimsShape = ShapeUtils.toShape(tf.scope(), dims);\n+    if (dimsShape.numDimensions() < 2) {\n+      throw new IllegalArgumentException(\n+          \"The tensor to initialize must be at least two-dimensional, got \"\n+              + dimsShape.numDimensions());\n+    }\n+    long num_rows = 1;\n+    int i = 0;\n+    for (; i < dimsShape.numDimensions() - 1; i++) num_rows *= dimsShape.size(i);\n+    long num_cols = dimsShape.size(i);\n+    Shape flat_shape = Shape.of(Math.max(num_rows, num_cols), Math.min(num_rows, num_cols));\n+    long lseed = this.seed == null ? 0L : this.seed;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU0NTMzMg==", "bodyText": "This isn't necessary if we make seed be a long not a Long. I think we should prevent people from passing nulls to the constructor.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r497545332", "createdAt": "2020-09-30T14:16:03Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Orthogonal.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Output;\n+import org.tensorflow.framework.utils.ShapeUtils;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.linalg.Qr;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates an orthogonal matrix.\n+ * <p>\n+ *     If the shape of the tensor to initialize is two-dimensional, it is initialized with an orthogonal matrix obtained from the QR\n+ *     decomposition of a matrix of random numbers drawn from a normal distribution. If the matrix has fewer rows than\n+ *     columns then the output will have orthogonal rows. Otherwise, the output will have orthogonal columns.\n+ * </p>\n+ * <p>\n+ *    If the shape of the tensor to initialize is more than two-dimensional,\n+ *    a matrix of shape <code>(shape.size(0) * ... * shape.size(n - 2), shape.size(n - 1))</code> is initialized,\n+ *    where <code>n</code> is the length of the shape vector. The matrix is subsequently reshaped\n+ *    to give a tensor of the desired shape.\n+ * </p>\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *      Orthogonal&lt;TFloat32, TFloat32&gt; initializer =\n+ *              new org.tensorflow.framework.initializers.Orthogonal&lt;&gt;(tf);\n+ *      Operand&lt;TFloat32&gt; values =\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ */\n+public class Orthogonal<T extends TType, U extends TNumber> extends BaseInitializer<T> {\n+\n+  public static final double GAIN_DEFAULT = 1.0;\n+\n+  private final double gain;\n+  private final Long seed;\n+\n+  /**\n+   * Creates an Orthogonal Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public Orthogonal(Ops tf) {\n+    this(tf, GAIN_DEFAULT, null);\n+  }\n+\n+  /**\n+   * Creates an Orthogonal Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param gain the gain to be applied to the Matrix\n+   */\n+  public Orthogonal(Ops tf, double gain) {\n+    this(tf, gain, null);\n+  }\n+\n+  /**\n+   * Creates an Orthogonal Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param seed the seed for random number generation\n+   */\n+  public Orthogonal(Ops tf, Long seed) {\n+    this(tf, GAIN_DEFAULT, seed);\n+  }\n+\n+  /**\n+   * Creates an Orthogonal Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param gain the gain to be applied to the Matrix\n+   * @param seed the seed for random number generation\n+   */\n+  public Orthogonal(Ops tf, double gain, Long seed) {\n+    super(tf);\n+    this.gain = gain;\n+    this.seed = seed;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!dtype.isFloating()) {\n+      throw new IllegalArgumentException(\"Expected floating point type, got \" + dtype.name());\n+    }\n+    Shape dimsShape = ShapeUtils.toShape(tf.scope(), dims);\n+    if (dimsShape.numDimensions() < 2) {\n+      throw new IllegalArgumentException(\n+          \"The tensor to initialize must be at least two-dimensional, got \"\n+              + dimsShape.numDimensions());\n+    }\n+    long num_rows = 1;\n+    int i = 0;\n+    for (; i < dimsShape.numDimensions() - 1; i++) num_rows *= dimsShape.size(i);\n+    long num_cols = dimsShape.size(i);\n+    Shape flat_shape = Shape.of(Math.max(num_rows, num_cols), Math.min(num_rows, num_cols));\n+    long lseed = this.seed == null ? 0L : this.seed;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3MDc1OA=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDAyNTUwOnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomNormal.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo1NzoxOVrOHVX0mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo1NzoxOVrOHVX0mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3MjQ0MA==", "bodyText": "Needs javadoc for the use of MEAN_DEFAULT and STDDEV_DEFAULT. Ditto for the rest of the constructors in here which use them.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492172440", "createdAt": "2020-09-21T15:57:19Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomNormal.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates tensors with a normal distribution.\n+ *\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *      RandomNormal&lt;TFloat32, TFloat32&gt; initializer =\n+ *              new org.tensorflow.framework.initializers.RandomNormal&lt;&gt;(tf);\n+ *      Operand&lt;TFloat32&gt; values =\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ */\n+public class RandomNormal<T extends TType, U extends TNumber> extends BaseInitializer<T> {\n+  public static final double MEAN_DEFAULT = 0.0;\n+  public static final double STDDEV_DEFAULT = 1.0;\n+\n+  private final double mean;\n+  private final double stddev;\n+  private final Long seed;\n+\n+  /**\n+   * creates the RandomUniform initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public RandomNormal(Ops tf) {\n+    this(tf, MEAN_DEFAULT, STDDEV_DEFAULT, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDAzMTg5OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomNormal.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo1ODo0NlrOHVX4dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo1ODo0NlrOHVX4dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3MzQzMQ==", "bodyText": "Same comment as the Orthogonal one wrt the seed being public API.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492173431", "createdAt": "2020-09-21T15:58:46Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomNormal.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates tensors with a normal distribution.\n+ *\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *      RandomNormal&lt;TFloat32, TFloat32&gt; initializer =\n+ *              new org.tensorflow.framework.initializers.RandomNormal&lt;&gt;(tf);\n+ *      Operand&lt;TFloat32&gt; values =\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ */\n+public class RandomNormal<T extends TType, U extends TNumber> extends BaseInitializer<T> {\n+  public static final double MEAN_DEFAULT = 0.0;\n+  public static final double STDDEV_DEFAULT = 1.0;\n+\n+  private final double mean;\n+  private final double stddev;\n+  private final Long seed;\n+\n+  /**\n+   * creates the RandomUniform initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public RandomNormal(Ops tf) {\n+    this(tf, MEAN_DEFAULT, STDDEV_DEFAULT, null);\n+  }\n+\n+  /**\n+   * creates the RandomUniform initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param mean Mean of the random values to generate.\n+   */\n+  public RandomNormal(Ops tf, double mean) {\n+    this(tf, mean, STDDEV_DEFAULT, null);\n+  }\n+\n+  /**\n+   * creates the RandomUniform initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param mean Mean of the random values to generate.\n+   * @param stddev Standard deviation of the random values to generate.\n+   */\n+  public RandomNormal(Ops tf, double mean, double stddev) {\n+    this(tf, mean, stddev, null);\n+  }\n+\n+  /**\n+   * creates the RandomUniform initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param mean Mean of the random values to generate.\n+   * @param stddev Standard deviation of the random values to generate.\n+   * @param seed Used to create random seeds.\n+   */\n+  public RandomNormal(Ops tf, double mean, double stddev, Long seed) {\n+    super(tf);\n+    this.mean = mean;\n+    this.stddev = stddev;\n+    this.seed = seed;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!dtype.isNumeric())\n+      throw new IllegalArgumentException(\"The data type must be numeric. Found : \" + dtype.name());\n+    long lseed = this.seed == null ? 0L : this.seed;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDA0MDE1OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomUniform.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjowMDozOFrOHVX9hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjowMDozOFrOHVX9hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3NDcyNg==", "bodyText": "Javadoc for the use of the static values.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492174726", "createdAt": "2020-09-21T16:00:38Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomUniform.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.random.RandomUniformInt;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates tensors with a uniform distribution.\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *      RandomUniform&lt;TFloat32, TFloat32&gt; initializer =\n+ *              new org.tensorflow.framework.initializers.RandomUniform&lt;&gt;(tf);\n+ *      Operand&lt;TFloat32&gt; values =\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ * */\n+public class RandomUniform<T extends TType, U extends TNumber> extends BaseInitializer<T> {\n+\n+  public static final double MINVAL_DEFAULT = 0.05;\n+  public static final double MAXVAL_DEFAULT = 0.05;\n+\n+  private final Double minval;\n+  private final Double maxval;\n+  private final Long seed;\n+\n+  /**\n+   * Creates a RandomUniform initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public RandomUniform(Ops tf) {\n+    this(tf, MINVAL_DEFAULT, MAXVAL_DEFAULT, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDA0MTUzOnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomUniform.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjowMDo1OFrOHVX-Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjowMDo1OFrOHVX-Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3NDk1MQ==", "bodyText": "Same comment as Orthogonal about the seed.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492174951", "createdAt": "2020-09-21T16:00:58Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomUniform.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.random.RandomUniformInt;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates tensors with a uniform distribution.\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *      RandomUniform&lt;TFloat32, TFloat32&gt; initializer =\n+ *              new org.tensorflow.framework.initializers.RandomUniform&lt;&gt;(tf);\n+ *      Operand&lt;TFloat32&gt; values =\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ * */\n+public class RandomUniform<T extends TType, U extends TNumber> extends BaseInitializer<T> {\n+\n+  public static final double MINVAL_DEFAULT = 0.05;\n+  public static final double MAXVAL_DEFAULT = 0.05;\n+\n+  private final Double minval;\n+  private final Double maxval;\n+  private final Long seed;\n+\n+  /**\n+   * Creates a RandomUniform initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public RandomUniform(Ops tf) {\n+    this(tf, MINVAL_DEFAULT, MAXVAL_DEFAULT, null);\n+  }\n+\n+  /**\n+   * Creates a RandomUniform initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param minval Lower bound of the range of random values to generate (inclusive).\n+   * @param maxval Upper bound of the range of random values to generate (exclusive).\n+   */\n+  public RandomUniform(Ops tf, double minval, double maxval) {\n+    this(tf, minval, maxval, null);\n+  }\n+\n+  /**\n+   * Creates a RandomUniform initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param minval Lower bound of the range of random values to generate (inclusive).\n+   * @param maxval Upper bound of the range of random values to generate (exclusive).\n+   * @param seed Used to create random seeds.\n+   */\n+  public RandomUniform(Ops tf, double minval, double maxval, Long seed) {\n+    super(tf);\n+    this.minval = minval;\n+    this.maxval = maxval;\n+    this.seed = seed;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!dtype.isNumeric())\n+      throw new IllegalArgumentException(\"The data type must be numeric. Found : \" + dtype.name());\n+    @SuppressWarnings(\"unchecked\")\n+    DataType<U> numdType = (DataType<U>) dtype;\n+    Operand<U> distOp;\n+\n+    if (dtype.isInteger()) {\n+      RandomUniformInt.Options options = RandomUniformInt.seed(this.seed);\n+      distOp =\n+          tf.random.randomUniformInt(\n+              dims,\n+              tf.dtypes.cast(tf.constant(this.minval), numdType),\n+              tf.dtypes.cast(tf.constant(this.maxval), numdType),\n+              options);\n+      @SuppressWarnings(\"unchecked\")\n+      Operand<T> distOpT = (Operand<T>) distOp;\n+      return distOpT;\n+    } else {\n+      long lseed = this.seed == null ? 0L : this.seed;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDA0MzY5OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomUniform.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjowMToyNlrOHVX_sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjowMToyNlrOHVX_sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3NTI4Mw==", "bodyText": "What happens when seed is null?", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492175283", "createdAt": "2020-09-21T16:01:26Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomUniform.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.random.RandomUniformInt;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates tensors with a uniform distribution.\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *      RandomUniform&lt;TFloat32, TFloat32&gt; initializer =\n+ *              new org.tensorflow.framework.initializers.RandomUniform&lt;&gt;(tf);\n+ *      Operand&lt;TFloat32&gt; values =\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ * */\n+public class RandomUniform<T extends TType, U extends TNumber> extends BaseInitializer<T> {\n+\n+  public static final double MINVAL_DEFAULT = 0.05;\n+  public static final double MAXVAL_DEFAULT = 0.05;\n+\n+  private final Double minval;\n+  private final Double maxval;\n+  private final Long seed;\n+\n+  /**\n+   * Creates a RandomUniform initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public RandomUniform(Ops tf) {\n+    this(tf, MINVAL_DEFAULT, MAXVAL_DEFAULT, null);\n+  }\n+\n+  /**\n+   * Creates a RandomUniform initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param minval Lower bound of the range of random values to generate (inclusive).\n+   * @param maxval Upper bound of the range of random values to generate (exclusive).\n+   */\n+  public RandomUniform(Ops tf, double minval, double maxval) {\n+    this(tf, minval, maxval, null);\n+  }\n+\n+  /**\n+   * Creates a RandomUniform initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param minval Lower bound of the range of random values to generate (inclusive).\n+   * @param maxval Upper bound of the range of random values to generate (exclusive).\n+   * @param seed Used to create random seeds.\n+   */\n+  public RandomUniform(Ops tf, double minval, double maxval, Long seed) {\n+    super(tf);\n+    this.minval = minval;\n+    this.maxval = maxval;\n+    this.seed = seed;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!dtype.isNumeric())\n+      throw new IllegalArgumentException(\"The data type must be numeric. Found : \" + dtype.name());\n+    @SuppressWarnings(\"unchecked\")\n+    DataType<U> numdType = (DataType<U>) dtype;\n+    Operand<U> distOp;\n+\n+    if (dtype.isInteger()) {\n+      RandomUniformInt.Options options = RandomUniformInt.seed(this.seed);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDA1MDc2OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/TruncatedNormal.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjowMzoxMlrOHVYEIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjowMzoxMlrOHVYEIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3NjQxNw==", "bodyText": "Javadoc for the static finals.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492176417", "createdAt": "2020-09-21T16:03:12Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/TruncatedNormal.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates a truncated normal distribution.\n+ *\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *      TruncatedNormal&lt;TFloat32, TFloat32&gt; initializer =\n+ *              new org.tensorflow.framework.initializers.TruncatedNormal&lt;&gt;(tf);\n+ *      Operand&lt;TFloat32&gt; values =\n+ *              initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ */\n+public class TruncatedNormal<T extends TType, U extends TNumber> extends BaseInitializer<T> {\n+\n+  public static final double MEAN_DEFAULT = 0.0;\n+  public static final double STDDEV_DEFAULT = 0.05;\n+\n+  private final double mean;\n+  private final double stddev;\n+  private final Long seed;\n+\n+  /**\n+   * Creates a TruncatedNormal Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public TruncatedNormal(Ops tf) {\n+    this(tf, MEAN_DEFAULT, STDDEV_DEFAULT, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDA1Mjk3OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/VarianceScaling.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjowMzo0NlrOHVYFhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjowMzo0NlrOHVYFhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3Njc3Mw==", "bodyText": "Javadoc for the static finals.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492176773", "createdAt": "2020-09-21T16:03:46Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/VarianceScaling.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.framework.utils.ShapeUtils;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer capable of adapting its scale to the shape of weights tensors.\n+ *\n+ * <p>\n+ *\n+ * <p>With <code>distribution=TRUNCATED_NORMAL or UNTRUNCATED_NORMAL</code>, samples are drawn from\n+ * a truncated/untruncated normal distribution with a mean of zero and a standard deviation (after\n+ * truncation, if used) <code>stddev = Math.sqrt(scale / n)</code>, where <code>n</code> is:\n+ *\n+ * <ul>\n+ *   <li>number of input units in the weight tensor, if <code>mode=FAN_IN</code>\n+ *   <li>number of output units, if <code>mode=FAN_OUT</code>\n+ *   <li>average of the numbers of input and output units, if <code>mode=FAN_AVG</code>\n+ * </ul>\n+ *\n+ * <p>With <code>distribution=UNIFORM</code>, samples are drawn from a uniform distribution within\n+ * <code>[-limit, limit]</code>, where <code>limit = Math.sqrt(3 * scale / n);</code>.\n+ *\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *      long seed = 1234l;\n+ *      float scale = 0.1f;\n+ *      VarianceScaling&lt;TFloat32, TFloat32&gt; initializer =\n+ *          new org.tensorflow.framework.initializers.VarianceScaling&lt;&gt;(\n+ *              tf, scale, Mode.FAN_IN, Distribution.UNIFORM, seed);\n+ *      Operand&lt;TFloat32&gt; values =\n+ *          initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ * @see VarianceScaling.Mode\n+ * @see VarianceScaling.Distribution\n+ */\n+public class VarianceScaling<T extends TType, U extends TNumber> extends BaseInitializer<T> {\n+\n+  public static final double SCALE_DEFAULT = 1.0;\n+  public static final Mode MODE_DEFAULT = Mode.FAN_IN;\n+  public static final Distribution DISTRIBUTION_DEFAULT = Distribution.TRUNCATED_NORMAL;\n+\n+  private final double scale;\n+  private final Mode mode;\n+  private final Distribution distribution;\n+  private final Long seed;\n+\n+  /**\n+   * Creates a VarianceScaling Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public VarianceScaling(Ops tf) {\n+    this(tf, SCALE_DEFAULT, MODE_DEFAULT, DISTRIBUTION_DEFAULT, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDA1NTA5OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/VarianceScaling.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjowNDoxNVrOHVYG0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjowNDoxNVrOHVYG0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3NzEwNg==", "bodyText": "Same comment as Orthogonal.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492177106", "createdAt": "2020-09-21T16:04:15Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/VarianceScaling.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.framework.utils.ShapeUtils;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer capable of adapting its scale to the shape of weights tensors.\n+ *\n+ * <p>\n+ *\n+ * <p>With <code>distribution=TRUNCATED_NORMAL or UNTRUNCATED_NORMAL</code>, samples are drawn from\n+ * a truncated/untruncated normal distribution with a mean of zero and a standard deviation (after\n+ * truncation, if used) <code>stddev = Math.sqrt(scale / n)</code>, where <code>n</code> is:\n+ *\n+ * <ul>\n+ *   <li>number of input units in the weight tensor, if <code>mode=FAN_IN</code>\n+ *   <li>number of output units, if <code>mode=FAN_OUT</code>\n+ *   <li>average of the numbers of input and output units, if <code>mode=FAN_AVG</code>\n+ * </ul>\n+ *\n+ * <p>With <code>distribution=UNIFORM</code>, samples are drawn from a uniform distribution within\n+ * <code>[-limit, limit]</code>, where <code>limit = Math.sqrt(3 * scale / n);</code>.\n+ *\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *      long seed = 1234l;\n+ *      float scale = 0.1f;\n+ *      VarianceScaling&lt;TFloat32, TFloat32&gt; initializer =\n+ *          new org.tensorflow.framework.initializers.VarianceScaling&lt;&gt;(\n+ *              tf, scale, Mode.FAN_IN, Distribution.UNIFORM, seed);\n+ *      Operand&lt;TFloat32&gt; values =\n+ *          initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ * @see VarianceScaling.Mode\n+ * @see VarianceScaling.Distribution\n+ */\n+public class VarianceScaling<T extends TType, U extends TNumber> extends BaseInitializer<T> {\n+\n+  public static final double SCALE_DEFAULT = 1.0;\n+  public static final Mode MODE_DEFAULT = Mode.FAN_IN;\n+  public static final Distribution DISTRIBUTION_DEFAULT = Distribution.TRUNCATED_NORMAL;\n+\n+  private final double scale;\n+  private final Mode mode;\n+  private final Distribution distribution;\n+  private final Long seed;\n+\n+  /**\n+   * Creates a VarianceScaling Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public VarianceScaling(Ops tf) {\n+    this(tf, SCALE_DEFAULT, MODE_DEFAULT, DISTRIBUTION_DEFAULT, null);\n+  }\n+\n+  /**\n+   * Creates a VarianceScaling Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param seed sed to create random seeds.\n+   */\n+  public VarianceScaling(Ops tf, long seed) {\n+    this(tf, SCALE_DEFAULT, MODE_DEFAULT, DISTRIBUTION_DEFAULT, seed);\n+  }\n+\n+  /**\n+   * Creates a VarianceScaling Initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param scale Scaling factor (positive float).\n+   * @param mode the mode for the variance\n+   * @param distribution Random distribution to use.\n+   * @param seed Used to create random seeds.\n+   */\n+  public VarianceScaling(Ops tf, double scale, Mode mode, Distribution distribution, Long seed) {\n+    super(tf);\n+    if (scale <= 0.0) {\n+      throw new IllegalArgumentException(\"scale must be greater than 0, got \" + scale);\n+    }\n+    this.scale = scale;\n+    this.mode = mode;\n+    this.distribution = distribution;\n+    this.seed = seed;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!dtype.isFloating()) {\n+      throw new IllegalArgumentException(\"Expected floating point type, got \" + dtype.name());\n+    }\n+    Shape shape = ShapeUtils.toShape(this.tf.scope(), dims);\n+    double lscale = this.scale;\n+    double[] fans /* fanIn, fanOut */ = computeFans(shape);\n+    switch (mode) {\n+      case FAN_IN:\n+        lscale /= Math.max(1., fans[0]);\n+        break;\n+      case FAN_OUT:\n+        lscale /= Math.max(1., fans[1]);\n+        break;\n+      case FAN_AVG:\n+        lscale /= Math.max(1., (fans[0] + fans[1]) / 2.);\n+        break;\n+    }\n+    Operand<U> distOp;\n+    Operand<U> mulOp = null;\n+    @SuppressWarnings(\"unchecked\")\n+    DataType<U> numdType = (DataType<U>) dtype;\n+    double stddev;\n+    long lseed = this.seed == null ? 0L : this.seed;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDA2NTE2OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjowNjo0MlrOHVYNJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjowNjo0MlrOHVYNJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE3ODcyNg==", "bodyText": "No star imports please.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492178726", "createdAt": "2020-09-21T16:06:42Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.utils;\n+\n+import org.tensorflow.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDA3ODM2OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjoxMDowOFrOHVYVsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1NjoyOFrOHVeRsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4MDkxNQ==", "bodyText": "The formatting on this else block looks odd? It's at the wrong indent level (or at least it looks that way in the review).", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492180915", "createdAt": "2020-09-21T16:10:08Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.utils;\n+\n+import org.tensorflow.*;\n+import org.tensorflow.ndarray.NdArray;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.TUint8;\n+import org.tensorflow.types.family.TNumber;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Various methods for processing with Shapes and Operands\n+ */\n+public class ShapeUtils {\n+\n+  /**\n+   * Converts a shape operand to a Shape object\n+   *\n+   * @param dims the Operand containing the shape values\n+   * @return a new Shape based on an Operand that contains dimensions\n+   */\n+  public static <T extends TNumber> Shape toShape(Scope scope, Operand<T> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Shape.of(longDims);\n+  }\n+\n+  /**\n+   * Converts a TInt32 type Operand to a Java int array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the TInt32 Operand\n+   * @return the int array\n+   */\n+  public static int[] getIntArray(Scope scope, Operand<TInt32> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Arrays.stream(longDims).mapToInt(i -> (int) i).toArray();\n+  }\n+\n+  /**\n+   * Converts a TInt32 or TInt64 Operand to a java long array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the Operand\n+   * @param <T> the type of the dimensions, must either be TInt32 or TInt64 type\n+   * @return the long array\n+   * @throws java.lang.IllegalArgumentException if the dims type is not an integer\n+   */\n+  public static <T extends TNumber> long[] getLongArray(Scope scope, Operand<T> dims) {\n+    DataType<T> dType = dims.asOutput().dataType();\n+    if (!dType.isInteger()) {\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+    List<Long> result = new ArrayList<>();\n+\n+    if (scope.env().isEager()) {\n+      if (dType.equals(TInt32.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt32> idims = (Operand<TInt32>) dims;\n+\n+        idims.asOutput().data().scalars().forEach(s -> result.add((long) s.getInt()));\n+      } else if (dType.equals(TInt64.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt64> ldims = (Operand<TInt64>) dims;\n+        ldims.asOutput().data().scalars().forEach(s -> result.add(s.getLong()));\n+      } else if (dType.equals(TUint8.DTYPE)) {\n+      @SuppressWarnings(\"unchecked\")\n+      Operand<TUint8> udims = (Operand<TUint8>) dims;\n+        udims.asOutput().data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+    }else { // shouldn't happen", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3ODE5NA==", "bodyText": "OK", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492278194", "createdAt": "2020-09-21T18:56:28Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.utils;\n+\n+import org.tensorflow.*;\n+import org.tensorflow.ndarray.NdArray;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.TUint8;\n+import org.tensorflow.types.family.TNumber;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Various methods for processing with Shapes and Operands\n+ */\n+public class ShapeUtils {\n+\n+  /**\n+   * Converts a shape operand to a Shape object\n+   *\n+   * @param dims the Operand containing the shape values\n+   * @return a new Shape based on an Operand that contains dimensions\n+   */\n+  public static <T extends TNumber> Shape toShape(Scope scope, Operand<T> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Shape.of(longDims);\n+  }\n+\n+  /**\n+   * Converts a TInt32 type Operand to a Java int array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the TInt32 Operand\n+   * @return the int array\n+   */\n+  public static int[] getIntArray(Scope scope, Operand<TInt32> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Arrays.stream(longDims).mapToInt(i -> (int) i).toArray();\n+  }\n+\n+  /**\n+   * Converts a TInt32 or TInt64 Operand to a java long array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the Operand\n+   * @param <T> the type of the dimensions, must either be TInt32 or TInt64 type\n+   * @return the long array\n+   * @throws java.lang.IllegalArgumentException if the dims type is not an integer\n+   */\n+  public static <T extends TNumber> long[] getLongArray(Scope scope, Operand<T> dims) {\n+    DataType<T> dType = dims.asOutput().dataType();\n+    if (!dType.isInteger()) {\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+    List<Long> result = new ArrayList<>();\n+\n+    if (scope.env().isEager()) {\n+      if (dType.equals(TInt32.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt32> idims = (Operand<TInt32>) dims;\n+\n+        idims.asOutput().data().scalars().forEach(s -> result.add((long) s.getInt()));\n+      } else if (dType.equals(TInt64.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt64> ldims = (Operand<TInt64>) dims;\n+        ldims.asOutput().data().scalars().forEach(s -> result.add(s.getLong()));\n+      } else if (dType.equals(TUint8.DTYPE)) {\n+      @SuppressWarnings(\"unchecked\")\n+      Operand<TUint8> udims = (Operand<TUint8>) dims;\n+        udims.asOutput().data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+    }else { // shouldn't happen", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4MDkxNQ=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDA5MjAxOnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjoxMzoyNFrOHVYeQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1NjozNVrOHVeR4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4MzEwNw==", "bodyText": "Formatting looks a little off here too.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492183107", "createdAt": "2020-09-21T16:13:24Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.utils;\n+\n+import org.tensorflow.*;\n+import org.tensorflow.ndarray.NdArray;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.TUint8;\n+import org.tensorflow.types.family.TNumber;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Various methods for processing with Shapes and Operands\n+ */\n+public class ShapeUtils {\n+\n+  /**\n+   * Converts a shape operand to a Shape object\n+   *\n+   * @param dims the Operand containing the shape values\n+   * @return a new Shape based on an Operand that contains dimensions\n+   */\n+  public static <T extends TNumber> Shape toShape(Scope scope, Operand<T> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Shape.of(longDims);\n+  }\n+\n+  /**\n+   * Converts a TInt32 type Operand to a Java int array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the TInt32 Operand\n+   * @return the int array\n+   */\n+  public static int[] getIntArray(Scope scope, Operand<TInt32> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Arrays.stream(longDims).mapToInt(i -> (int) i).toArray();\n+  }\n+\n+  /**\n+   * Converts a TInt32 or TInt64 Operand to a java long array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the Operand\n+   * @param <T> the type of the dimensions, must either be TInt32 or TInt64 type\n+   * @return the long array\n+   * @throws java.lang.IllegalArgumentException if the dims type is not an integer\n+   */\n+  public static <T extends TNumber> long[] getLongArray(Scope scope, Operand<T> dims) {\n+    DataType<T> dType = dims.asOutput().dataType();\n+    if (!dType.isInteger()) {\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+    List<Long> result = new ArrayList<>();\n+\n+    if (scope.env().isEager()) {\n+      if (dType.equals(TInt32.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt32> idims = (Operand<TInt32>) dims;\n+\n+        idims.asOutput().data().scalars().forEach(s -> result.add((long) s.getInt()));\n+      } else if (dType.equals(TInt64.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt64> ldims = (Operand<TInt64>) dims;\n+        ldims.asOutput().data().scalars().forEach(s -> result.add(s.getLong()));\n+      } else if (dType.equals(TUint8.DTYPE)) {\n+      @SuppressWarnings(\"unchecked\")\n+      Operand<TUint8> udims = (Operand<TUint8>) dims;\n+        udims.asOutput().data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+    }else { // shouldn't happen\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+\n+    } else {\n+      try (Session session = new Session((Graph) scope.env())) {\n+        if (dType.equals(TInt32.DTYPE)) {\n+          try (Tensor<TInt32> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt32.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add((long) s.getInt()));\n+          }\n+        } else if (dType.equals(TInt64.DTYPE)){\n+          try (Tensor<TInt64> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt64.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getLong()));\n+          }\n+        }else if (dType.equals(TUint8.DTYPE)){\n+          try (Tensor<TUint8> tensorResult =\n+                       session.runner().fetch(dims).run().get(0).expect(TUint8.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+          }\n+      }else { // shouldn't happen", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3ODI0Mw==", "bodyText": "OK", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492278243", "createdAt": "2020-09-21T18:56:35Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.utils;\n+\n+import org.tensorflow.*;\n+import org.tensorflow.ndarray.NdArray;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.TUint8;\n+import org.tensorflow.types.family.TNumber;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Various methods for processing with Shapes and Operands\n+ */\n+public class ShapeUtils {\n+\n+  /**\n+   * Converts a shape operand to a Shape object\n+   *\n+   * @param dims the Operand containing the shape values\n+   * @return a new Shape based on an Operand that contains dimensions\n+   */\n+  public static <T extends TNumber> Shape toShape(Scope scope, Operand<T> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Shape.of(longDims);\n+  }\n+\n+  /**\n+   * Converts a TInt32 type Operand to a Java int array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the TInt32 Operand\n+   * @return the int array\n+   */\n+  public static int[] getIntArray(Scope scope, Operand<TInt32> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Arrays.stream(longDims).mapToInt(i -> (int) i).toArray();\n+  }\n+\n+  /**\n+   * Converts a TInt32 or TInt64 Operand to a java long array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the Operand\n+   * @param <T> the type of the dimensions, must either be TInt32 or TInt64 type\n+   * @return the long array\n+   * @throws java.lang.IllegalArgumentException if the dims type is not an integer\n+   */\n+  public static <T extends TNumber> long[] getLongArray(Scope scope, Operand<T> dims) {\n+    DataType<T> dType = dims.asOutput().dataType();\n+    if (!dType.isInteger()) {\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+    List<Long> result = new ArrayList<>();\n+\n+    if (scope.env().isEager()) {\n+      if (dType.equals(TInt32.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt32> idims = (Operand<TInt32>) dims;\n+\n+        idims.asOutput().data().scalars().forEach(s -> result.add((long) s.getInt()));\n+      } else if (dType.equals(TInt64.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt64> ldims = (Operand<TInt64>) dims;\n+        ldims.asOutput().data().scalars().forEach(s -> result.add(s.getLong()));\n+      } else if (dType.equals(TUint8.DTYPE)) {\n+      @SuppressWarnings(\"unchecked\")\n+      Operand<TUint8> udims = (Operand<TUint8>) dims;\n+        udims.asOutput().data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+    }else { // shouldn't happen\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+\n+    } else {\n+      try (Session session = new Session((Graph) scope.env())) {\n+        if (dType.equals(TInt32.DTYPE)) {\n+          try (Tensor<TInt32> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt32.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add((long) s.getInt()));\n+          }\n+        } else if (dType.equals(TInt64.DTYPE)){\n+          try (Tensor<TInt64> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt64.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getLong()));\n+          }\n+        }else if (dType.equals(TUint8.DTYPE)){\n+          try (Tensor<TUint8> tensorResult =\n+                       session.runner().fetch(dims).run().get(0).expect(TUint8.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+          }\n+      }else { // shouldn't happen", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4MzEwNw=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDExMzQ3OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjoxODo0NFrOHVYrcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxOTo1NzozNlrOHb59Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4NjQ4MA==", "bodyText": "So this is not quite the same as numpy's broadcasting rules right? I wonder if it's worth mentioning that, as I expect that many people who see this function will be familiar with numpy.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492186480", "createdAt": "2020-09-21T16:18:44Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.utils;\n+\n+import org.tensorflow.*;\n+import org.tensorflow.ndarray.NdArray;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.TUint8;\n+import org.tensorflow.types.family.TNumber;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Various methods for processing with Shapes and Operands\n+ */\n+public class ShapeUtils {\n+\n+  /**\n+   * Converts a shape operand to a Shape object\n+   *\n+   * @param dims the Operand containing the shape values\n+   * @return a new Shape based on an Operand that contains dimensions\n+   */\n+  public static <T extends TNumber> Shape toShape(Scope scope, Operand<T> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Shape.of(longDims);\n+  }\n+\n+  /**\n+   * Converts a TInt32 type Operand to a Java int array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the TInt32 Operand\n+   * @return the int array\n+   */\n+  public static int[] getIntArray(Scope scope, Operand<TInt32> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Arrays.stream(longDims).mapToInt(i -> (int) i).toArray();\n+  }\n+\n+  /**\n+   * Converts a TInt32 or TInt64 Operand to a java long array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the Operand\n+   * @param <T> the type of the dimensions, must either be TInt32 or TInt64 type\n+   * @return the long array\n+   * @throws java.lang.IllegalArgumentException if the dims type is not an integer\n+   */\n+  public static <T extends TNumber> long[] getLongArray(Scope scope, Operand<T> dims) {\n+    DataType<T> dType = dims.asOutput().dataType();\n+    if (!dType.isInteger()) {\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+    List<Long> result = new ArrayList<>();\n+\n+    if (scope.env().isEager()) {\n+      if (dType.equals(TInt32.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt32> idims = (Operand<TInt32>) dims;\n+\n+        idims.asOutput().data().scalars().forEach(s -> result.add((long) s.getInt()));\n+      } else if (dType.equals(TInt64.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt64> ldims = (Operand<TInt64>) dims;\n+        ldims.asOutput().data().scalars().forEach(s -> result.add(s.getLong()));\n+      } else if (dType.equals(TUint8.DTYPE)) {\n+      @SuppressWarnings(\"unchecked\")\n+      Operand<TUint8> udims = (Operand<TUint8>) dims;\n+        udims.asOutput().data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+    }else { // shouldn't happen\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+\n+    } else {\n+      try (Session session = new Session((Graph) scope.env())) {\n+        if (dType.equals(TInt32.DTYPE)) {\n+          try (Tensor<TInt32> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt32.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add((long) s.getInt()));\n+          }\n+        } else if (dType.equals(TInt64.DTYPE)){\n+          try (Tensor<TInt64> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt64.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getLong()));\n+          }\n+        }else if (dType.equals(TUint8.DTYPE)){\n+          try (Tensor<TUint8> tensorResult =\n+                       session.runner().fetch(dims).run().get(0).expect(TUint8.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+          }\n+      }else { // shouldn't happen\n+          throw new IllegalArgumentException(\"the data type must be an integer type\");\n+        }\n+      }\n+    }\n+    return result.stream().mapToLong(i -> i).toArray();\n+  }\n+\n+  /**\n+   * Gets the shape for the data within a Tensor\n+   *\n+   * @param tensor the tensor\n+   * @return the Shape of the tensor's data;\n+   */\n+  public static <T extends TNumber> Shape getShape(Tensor<T> tensor) {\n+    NdArray<?> data = (NdArray<?>) tensor.data();\n+    return data.shape();\n+  }\n+\n+  /**\n+   * Determines whether two shapes are compatible.\n+   *\n+   * <p>\n+   *\n+   * <p>Two possibly-partially-defined shapes are compatible if there exists a fully-defined shape\n+   * that both shapes can represent. Thus, compatibility allows the shape inference code to reason\n+   * about partially-defined shapes. For example:\n+   *\n+   * <ul>\n+   *   <li><code>Shape.unknown()</code> is compatible with all shapes.\n+   *   <li><code>Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> is compatible with all two-dimensional\n+   *       shapes, such as <code>Shape(32, 784)</code>, and also <code>Shape.unknown()</code>. It is\n+   *       not compatible with, for example, <code>Shape(UNKNOWN_SIZE)</code> or <code>\n+   *       Shape(UNKNOWN_SIZE, UNKNOWN_SIZE, UNKNOWN_SIZE)</code>.\n+   *   <li><code>Shape(32, UNKNOWN_SIZE)</code> is compatible with all two-dimensional shapes with\n+   *       size 32 in the 0th dimension, and also <code>Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> and\n+   *       <code>Shape.unknown()</code>. It is not compatible with, for example, <code>Shape(32)\n+   *       </code>, <code>Shape(32, UNKNOWN_SIZE, 1)</code> or <code>Shape(64, UNKNOWN_SIZE)</code>.\n+   *   <li><code>Shape(32, 784)</code> is compatible with itself, and also <code>\n+   *       Shape(32, UNKNOWN_SIZE)</code>, <code>Shape(UNKNOWN_SIZE, 784)</code>, <code>\n+   *       Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> and <code>Shape.unknown()</code>. It is not\n+   *       compatible with, for example, <code>Shape(32, 1, 784)</code> or <code>Shape(UNKNOWN_SIZE)\n+   *       </code>.\n+   * </ul>\n+   *\n+   * <p>The compatibility relation is reflexive and symmetric, but not transitive. For example,\n+   * <code>Shape(32, 784)</code> is compatible with <code>Shape.unknown()</code>, and <code>\n+   * Shape.unknown()</code> is compatible with <code>Shape(4, 4)</code>, but <code>Shape(32, 784)\n+   * </code> is not compatible with <code>Shape(4, 4)</code>.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NTQ5Nw==", "bodyText": "No, it is not the same as broadcasting. Compatible shapes must  have the same number of dimensions and for each dimension pair, one dimension has to equal the other dimensions or at least one of the dimensions in the pair has to be UNKNOWN_SIZE.\nNumpy broadcasting allows different dimensions, but paired dimensions have to either be equal, or one dimension must be 1. If one shape has less dimensions than another shape, the smaller shape is \"stretched\" with dimensions of 1.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492295497", "createdAt": "2020-09-21T19:27:20Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.utils;\n+\n+import org.tensorflow.*;\n+import org.tensorflow.ndarray.NdArray;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.TUint8;\n+import org.tensorflow.types.family.TNumber;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Various methods for processing with Shapes and Operands\n+ */\n+public class ShapeUtils {\n+\n+  /**\n+   * Converts a shape operand to a Shape object\n+   *\n+   * @param dims the Operand containing the shape values\n+   * @return a new Shape based on an Operand that contains dimensions\n+   */\n+  public static <T extends TNumber> Shape toShape(Scope scope, Operand<T> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Shape.of(longDims);\n+  }\n+\n+  /**\n+   * Converts a TInt32 type Operand to a Java int array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the TInt32 Operand\n+   * @return the int array\n+   */\n+  public static int[] getIntArray(Scope scope, Operand<TInt32> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Arrays.stream(longDims).mapToInt(i -> (int) i).toArray();\n+  }\n+\n+  /**\n+   * Converts a TInt32 or TInt64 Operand to a java long array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the Operand\n+   * @param <T> the type of the dimensions, must either be TInt32 or TInt64 type\n+   * @return the long array\n+   * @throws java.lang.IllegalArgumentException if the dims type is not an integer\n+   */\n+  public static <T extends TNumber> long[] getLongArray(Scope scope, Operand<T> dims) {\n+    DataType<T> dType = dims.asOutput().dataType();\n+    if (!dType.isInteger()) {\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+    List<Long> result = new ArrayList<>();\n+\n+    if (scope.env().isEager()) {\n+      if (dType.equals(TInt32.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt32> idims = (Operand<TInt32>) dims;\n+\n+        idims.asOutput().data().scalars().forEach(s -> result.add((long) s.getInt()));\n+      } else if (dType.equals(TInt64.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt64> ldims = (Operand<TInt64>) dims;\n+        ldims.asOutput().data().scalars().forEach(s -> result.add(s.getLong()));\n+      } else if (dType.equals(TUint8.DTYPE)) {\n+      @SuppressWarnings(\"unchecked\")\n+      Operand<TUint8> udims = (Operand<TUint8>) dims;\n+        udims.asOutput().data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+    }else { // shouldn't happen\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+\n+    } else {\n+      try (Session session = new Session((Graph) scope.env())) {\n+        if (dType.equals(TInt32.DTYPE)) {\n+          try (Tensor<TInt32> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt32.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add((long) s.getInt()));\n+          }\n+        } else if (dType.equals(TInt64.DTYPE)){\n+          try (Tensor<TInt64> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt64.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getLong()));\n+          }\n+        }else if (dType.equals(TUint8.DTYPE)){\n+          try (Tensor<TUint8> tensorResult =\n+                       session.runner().fetch(dims).run().get(0).expect(TUint8.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+          }\n+      }else { // shouldn't happen\n+          throw new IllegalArgumentException(\"the data type must be an integer type\");\n+        }\n+      }\n+    }\n+    return result.stream().mapToLong(i -> i).toArray();\n+  }\n+\n+  /**\n+   * Gets the shape for the data within a Tensor\n+   *\n+   * @param tensor the tensor\n+   * @return the Shape of the tensor's data;\n+   */\n+  public static <T extends TNumber> Shape getShape(Tensor<T> tensor) {\n+    NdArray<?> data = (NdArray<?>) tensor.data();\n+    return data.shape();\n+  }\n+\n+  /**\n+   * Determines whether two shapes are compatible.\n+   *\n+   * <p>\n+   *\n+   * <p>Two possibly-partially-defined shapes are compatible if there exists a fully-defined shape\n+   * that both shapes can represent. Thus, compatibility allows the shape inference code to reason\n+   * about partially-defined shapes. For example:\n+   *\n+   * <ul>\n+   *   <li><code>Shape.unknown()</code> is compatible with all shapes.\n+   *   <li><code>Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> is compatible with all two-dimensional\n+   *       shapes, such as <code>Shape(32, 784)</code>, and also <code>Shape.unknown()</code>. It is\n+   *       not compatible with, for example, <code>Shape(UNKNOWN_SIZE)</code> or <code>\n+   *       Shape(UNKNOWN_SIZE, UNKNOWN_SIZE, UNKNOWN_SIZE)</code>.\n+   *   <li><code>Shape(32, UNKNOWN_SIZE)</code> is compatible with all two-dimensional shapes with\n+   *       size 32 in the 0th dimension, and also <code>Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> and\n+   *       <code>Shape.unknown()</code>. It is not compatible with, for example, <code>Shape(32)\n+   *       </code>, <code>Shape(32, UNKNOWN_SIZE, 1)</code> or <code>Shape(64, UNKNOWN_SIZE)</code>.\n+   *   <li><code>Shape(32, 784)</code> is compatible with itself, and also <code>\n+   *       Shape(32, UNKNOWN_SIZE)</code>, <code>Shape(UNKNOWN_SIZE, 784)</code>, <code>\n+   *       Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> and <code>Shape.unknown()</code>. It is not\n+   *       compatible with, for example, <code>Shape(32, 1, 784)</code> or <code>Shape(UNKNOWN_SIZE)\n+   *       </code>.\n+   * </ul>\n+   *\n+   * <p>The compatibility relation is reflexive and symmetric, but not transitive. For example,\n+   * <code>Shape(32, 784)</code> is compatible with <code>Shape.unknown()</code>, and <code>\n+   * Shape.unknown()</code> is compatible with <code>Shape(4, 4)</code>, but <code>Shape(32, 784)\n+   * </code> is not compatible with <code>Shape(4, 4)</code>.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4NjQ4MA=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzAzNjUwMA==", "bodyText": "I have upgraded the JavaDoc to explain the difference between compatible shapes and broadcastable shapes.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r493036500", "createdAt": "2020-09-22T21:12:06Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.utils;\n+\n+import org.tensorflow.*;\n+import org.tensorflow.ndarray.NdArray;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.TUint8;\n+import org.tensorflow.types.family.TNumber;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Various methods for processing with Shapes and Operands\n+ */\n+public class ShapeUtils {\n+\n+  /**\n+   * Converts a shape operand to a Shape object\n+   *\n+   * @param dims the Operand containing the shape values\n+   * @return a new Shape based on an Operand that contains dimensions\n+   */\n+  public static <T extends TNumber> Shape toShape(Scope scope, Operand<T> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Shape.of(longDims);\n+  }\n+\n+  /**\n+   * Converts a TInt32 type Operand to a Java int array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the TInt32 Operand\n+   * @return the int array\n+   */\n+  public static int[] getIntArray(Scope scope, Operand<TInt32> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Arrays.stream(longDims).mapToInt(i -> (int) i).toArray();\n+  }\n+\n+  /**\n+   * Converts a TInt32 or TInt64 Operand to a java long array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the Operand\n+   * @param <T> the type of the dimensions, must either be TInt32 or TInt64 type\n+   * @return the long array\n+   * @throws java.lang.IllegalArgumentException if the dims type is not an integer\n+   */\n+  public static <T extends TNumber> long[] getLongArray(Scope scope, Operand<T> dims) {\n+    DataType<T> dType = dims.asOutput().dataType();\n+    if (!dType.isInteger()) {\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+    List<Long> result = new ArrayList<>();\n+\n+    if (scope.env().isEager()) {\n+      if (dType.equals(TInt32.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt32> idims = (Operand<TInt32>) dims;\n+\n+        idims.asOutput().data().scalars().forEach(s -> result.add((long) s.getInt()));\n+      } else if (dType.equals(TInt64.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt64> ldims = (Operand<TInt64>) dims;\n+        ldims.asOutput().data().scalars().forEach(s -> result.add(s.getLong()));\n+      } else if (dType.equals(TUint8.DTYPE)) {\n+      @SuppressWarnings(\"unchecked\")\n+      Operand<TUint8> udims = (Operand<TUint8>) dims;\n+        udims.asOutput().data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+    }else { // shouldn't happen\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+\n+    } else {\n+      try (Session session = new Session((Graph) scope.env())) {\n+        if (dType.equals(TInt32.DTYPE)) {\n+          try (Tensor<TInt32> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt32.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add((long) s.getInt()));\n+          }\n+        } else if (dType.equals(TInt64.DTYPE)){\n+          try (Tensor<TInt64> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt64.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getLong()));\n+          }\n+        }else if (dType.equals(TUint8.DTYPE)){\n+          try (Tensor<TUint8> tensorResult =\n+                       session.runner().fetch(dims).run().get(0).expect(TUint8.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+          }\n+      }else { // shouldn't happen\n+          throw new IllegalArgumentException(\"the data type must be an integer type\");\n+        }\n+      }\n+    }\n+    return result.stream().mapToLong(i -> i).toArray();\n+  }\n+\n+  /**\n+   * Gets the shape for the data within a Tensor\n+   *\n+   * @param tensor the tensor\n+   * @return the Shape of the tensor's data;\n+   */\n+  public static <T extends TNumber> Shape getShape(Tensor<T> tensor) {\n+    NdArray<?> data = (NdArray<?>) tensor.data();\n+    return data.shape();\n+  }\n+\n+  /**\n+   * Determines whether two shapes are compatible.\n+   *\n+   * <p>\n+   *\n+   * <p>Two possibly-partially-defined shapes are compatible if there exists a fully-defined shape\n+   * that both shapes can represent. Thus, compatibility allows the shape inference code to reason\n+   * about partially-defined shapes. For example:\n+   *\n+   * <ul>\n+   *   <li><code>Shape.unknown()</code> is compatible with all shapes.\n+   *   <li><code>Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> is compatible with all two-dimensional\n+   *       shapes, such as <code>Shape(32, 784)</code>, and also <code>Shape.unknown()</code>. It is\n+   *       not compatible with, for example, <code>Shape(UNKNOWN_SIZE)</code> or <code>\n+   *       Shape(UNKNOWN_SIZE, UNKNOWN_SIZE, UNKNOWN_SIZE)</code>.\n+   *   <li><code>Shape(32, UNKNOWN_SIZE)</code> is compatible with all two-dimensional shapes with\n+   *       size 32 in the 0th dimension, and also <code>Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> and\n+   *       <code>Shape.unknown()</code>. It is not compatible with, for example, <code>Shape(32)\n+   *       </code>, <code>Shape(32, UNKNOWN_SIZE, 1)</code> or <code>Shape(64, UNKNOWN_SIZE)</code>.\n+   *   <li><code>Shape(32, 784)</code> is compatible with itself, and also <code>\n+   *       Shape(32, UNKNOWN_SIZE)</code>, <code>Shape(UNKNOWN_SIZE, 784)</code>, <code>\n+   *       Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> and <code>Shape.unknown()</code>. It is not\n+   *       compatible with, for example, <code>Shape(32, 1, 784)</code> or <code>Shape(UNKNOWN_SIZE)\n+   *       </code>.\n+   * </ul>\n+   *\n+   * <p>The compatibility relation is reflexive and symmetric, but not transitive. For example,\n+   * <code>Shape(32, 784)</code> is compatible with <code>Shape.unknown()</code>, and <code>\n+   * Shape.unknown()</code> is compatible with <code>Shape(4, 4)</code>, but <code>Shape(32, 784)\n+   * </code> is not compatible with <code>Shape(4, 4)</code>.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4NjQ4MA=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA1Mjc0Mw==", "bodyText": "Should isCompatibleWith be moved to org.tensorflow.ndarray.Shape?", "url": "https://github.com/tensorflow/java/pull/116#discussion_r493052743", "createdAt": "2020-09-22T21:47:48Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.utils;\n+\n+import org.tensorflow.*;\n+import org.tensorflow.ndarray.NdArray;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.TUint8;\n+import org.tensorflow.types.family.TNumber;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Various methods for processing with Shapes and Operands\n+ */\n+public class ShapeUtils {\n+\n+  /**\n+   * Converts a shape operand to a Shape object\n+   *\n+   * @param dims the Operand containing the shape values\n+   * @return a new Shape based on an Operand that contains dimensions\n+   */\n+  public static <T extends TNumber> Shape toShape(Scope scope, Operand<T> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Shape.of(longDims);\n+  }\n+\n+  /**\n+   * Converts a TInt32 type Operand to a Java int array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the TInt32 Operand\n+   * @return the int array\n+   */\n+  public static int[] getIntArray(Scope scope, Operand<TInt32> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Arrays.stream(longDims).mapToInt(i -> (int) i).toArray();\n+  }\n+\n+  /**\n+   * Converts a TInt32 or TInt64 Operand to a java long array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the Operand\n+   * @param <T> the type of the dimensions, must either be TInt32 or TInt64 type\n+   * @return the long array\n+   * @throws java.lang.IllegalArgumentException if the dims type is not an integer\n+   */\n+  public static <T extends TNumber> long[] getLongArray(Scope scope, Operand<T> dims) {\n+    DataType<T> dType = dims.asOutput().dataType();\n+    if (!dType.isInteger()) {\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+    List<Long> result = new ArrayList<>();\n+\n+    if (scope.env().isEager()) {\n+      if (dType.equals(TInt32.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt32> idims = (Operand<TInt32>) dims;\n+\n+        idims.asOutput().data().scalars().forEach(s -> result.add((long) s.getInt()));\n+      } else if (dType.equals(TInt64.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt64> ldims = (Operand<TInt64>) dims;\n+        ldims.asOutput().data().scalars().forEach(s -> result.add(s.getLong()));\n+      } else if (dType.equals(TUint8.DTYPE)) {\n+      @SuppressWarnings(\"unchecked\")\n+      Operand<TUint8> udims = (Operand<TUint8>) dims;\n+        udims.asOutput().data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+    }else { // shouldn't happen\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+\n+    } else {\n+      try (Session session = new Session((Graph) scope.env())) {\n+        if (dType.equals(TInt32.DTYPE)) {\n+          try (Tensor<TInt32> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt32.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add((long) s.getInt()));\n+          }\n+        } else if (dType.equals(TInt64.DTYPE)){\n+          try (Tensor<TInt64> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt64.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getLong()));\n+          }\n+        }else if (dType.equals(TUint8.DTYPE)){\n+          try (Tensor<TUint8> tensorResult =\n+                       session.runner().fetch(dims).run().get(0).expect(TUint8.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+          }\n+      }else { // shouldn't happen\n+          throw new IllegalArgumentException(\"the data type must be an integer type\");\n+        }\n+      }\n+    }\n+    return result.stream().mapToLong(i -> i).toArray();\n+  }\n+\n+  /**\n+   * Gets the shape for the data within a Tensor\n+   *\n+   * @param tensor the tensor\n+   * @return the Shape of the tensor's data;\n+   */\n+  public static <T extends TNumber> Shape getShape(Tensor<T> tensor) {\n+    NdArray<?> data = (NdArray<?>) tensor.data();\n+    return data.shape();\n+  }\n+\n+  /**\n+   * Determines whether two shapes are compatible.\n+   *\n+   * <p>\n+   *\n+   * <p>Two possibly-partially-defined shapes are compatible if there exists a fully-defined shape\n+   * that both shapes can represent. Thus, compatibility allows the shape inference code to reason\n+   * about partially-defined shapes. For example:\n+   *\n+   * <ul>\n+   *   <li><code>Shape.unknown()</code> is compatible with all shapes.\n+   *   <li><code>Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> is compatible with all two-dimensional\n+   *       shapes, such as <code>Shape(32, 784)</code>, and also <code>Shape.unknown()</code>. It is\n+   *       not compatible with, for example, <code>Shape(UNKNOWN_SIZE)</code> or <code>\n+   *       Shape(UNKNOWN_SIZE, UNKNOWN_SIZE, UNKNOWN_SIZE)</code>.\n+   *   <li><code>Shape(32, UNKNOWN_SIZE)</code> is compatible with all two-dimensional shapes with\n+   *       size 32 in the 0th dimension, and also <code>Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> and\n+   *       <code>Shape.unknown()</code>. It is not compatible with, for example, <code>Shape(32)\n+   *       </code>, <code>Shape(32, UNKNOWN_SIZE, 1)</code> or <code>Shape(64, UNKNOWN_SIZE)</code>.\n+   *   <li><code>Shape(32, 784)</code> is compatible with itself, and also <code>\n+   *       Shape(32, UNKNOWN_SIZE)</code>, <code>Shape(UNKNOWN_SIZE, 784)</code>, <code>\n+   *       Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> and <code>Shape.unknown()</code>. It is not\n+   *       compatible with, for example, <code>Shape(32, 1, 784)</code> or <code>Shape(UNKNOWN_SIZE)\n+   *       </code>.\n+   * </ul>\n+   *\n+   * <p>The compatibility relation is reflexive and symmetric, but not transitive. For example,\n+   * <code>Shape(32, 784)</code> is compatible with <code>Shape.unknown()</code>, and <code>\n+   * Shape.unknown()</code> is compatible with <code>Shape(4, 4)</code>, but <code>Shape(32, 784)\n+   * </code> is not compatible with <code>Shape(4, 4)</code>.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4NjQ4MA=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MjI0NA==", "bodyText": "The javadoc change looks good, @karllessard do you think this method should be moved?", "url": "https://github.com/tensorflow/java/pull/116#discussion_r493882244", "createdAt": "2020-09-23T20:41:46Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.utils;\n+\n+import org.tensorflow.*;\n+import org.tensorflow.ndarray.NdArray;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.TUint8;\n+import org.tensorflow.types.family.TNumber;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Various methods for processing with Shapes and Operands\n+ */\n+public class ShapeUtils {\n+\n+  /**\n+   * Converts a shape operand to a Shape object\n+   *\n+   * @param dims the Operand containing the shape values\n+   * @return a new Shape based on an Operand that contains dimensions\n+   */\n+  public static <T extends TNumber> Shape toShape(Scope scope, Operand<T> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Shape.of(longDims);\n+  }\n+\n+  /**\n+   * Converts a TInt32 type Operand to a Java int array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the TInt32 Operand\n+   * @return the int array\n+   */\n+  public static int[] getIntArray(Scope scope, Operand<TInt32> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Arrays.stream(longDims).mapToInt(i -> (int) i).toArray();\n+  }\n+\n+  /**\n+   * Converts a TInt32 or TInt64 Operand to a java long array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the Operand\n+   * @param <T> the type of the dimensions, must either be TInt32 or TInt64 type\n+   * @return the long array\n+   * @throws java.lang.IllegalArgumentException if the dims type is not an integer\n+   */\n+  public static <T extends TNumber> long[] getLongArray(Scope scope, Operand<T> dims) {\n+    DataType<T> dType = dims.asOutput().dataType();\n+    if (!dType.isInteger()) {\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+    List<Long> result = new ArrayList<>();\n+\n+    if (scope.env().isEager()) {\n+      if (dType.equals(TInt32.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt32> idims = (Operand<TInt32>) dims;\n+\n+        idims.asOutput().data().scalars().forEach(s -> result.add((long) s.getInt()));\n+      } else if (dType.equals(TInt64.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt64> ldims = (Operand<TInt64>) dims;\n+        ldims.asOutput().data().scalars().forEach(s -> result.add(s.getLong()));\n+      } else if (dType.equals(TUint8.DTYPE)) {\n+      @SuppressWarnings(\"unchecked\")\n+      Operand<TUint8> udims = (Operand<TUint8>) dims;\n+        udims.asOutput().data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+    }else { // shouldn't happen\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+\n+    } else {\n+      try (Session session = new Session((Graph) scope.env())) {\n+        if (dType.equals(TInt32.DTYPE)) {\n+          try (Tensor<TInt32> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt32.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add((long) s.getInt()));\n+          }\n+        } else if (dType.equals(TInt64.DTYPE)){\n+          try (Tensor<TInt64> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt64.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getLong()));\n+          }\n+        }else if (dType.equals(TUint8.DTYPE)){\n+          try (Tensor<TUint8> tensorResult =\n+                       session.runner().fetch(dims).run().get(0).expect(TUint8.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+          }\n+      }else { // shouldn't happen\n+          throw new IllegalArgumentException(\"the data type must be an integer type\");\n+        }\n+      }\n+    }\n+    return result.stream().mapToLong(i -> i).toArray();\n+  }\n+\n+  /**\n+   * Gets the shape for the data within a Tensor\n+   *\n+   * @param tensor the tensor\n+   * @return the Shape of the tensor's data;\n+   */\n+  public static <T extends TNumber> Shape getShape(Tensor<T> tensor) {\n+    NdArray<?> data = (NdArray<?>) tensor.data();\n+    return data.shape();\n+  }\n+\n+  /**\n+   * Determines whether two shapes are compatible.\n+   *\n+   * <p>\n+   *\n+   * <p>Two possibly-partially-defined shapes are compatible if there exists a fully-defined shape\n+   * that both shapes can represent. Thus, compatibility allows the shape inference code to reason\n+   * about partially-defined shapes. For example:\n+   *\n+   * <ul>\n+   *   <li><code>Shape.unknown()</code> is compatible with all shapes.\n+   *   <li><code>Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> is compatible with all two-dimensional\n+   *       shapes, such as <code>Shape(32, 784)</code>, and also <code>Shape.unknown()</code>. It is\n+   *       not compatible with, for example, <code>Shape(UNKNOWN_SIZE)</code> or <code>\n+   *       Shape(UNKNOWN_SIZE, UNKNOWN_SIZE, UNKNOWN_SIZE)</code>.\n+   *   <li><code>Shape(32, UNKNOWN_SIZE)</code> is compatible with all two-dimensional shapes with\n+   *       size 32 in the 0th dimension, and also <code>Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> and\n+   *       <code>Shape.unknown()</code>. It is not compatible with, for example, <code>Shape(32)\n+   *       </code>, <code>Shape(32, UNKNOWN_SIZE, 1)</code> or <code>Shape(64, UNKNOWN_SIZE)</code>.\n+   *   <li><code>Shape(32, 784)</code> is compatible with itself, and also <code>\n+   *       Shape(32, UNKNOWN_SIZE)</code>, <code>Shape(UNKNOWN_SIZE, 784)</code>, <code>\n+   *       Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> and <code>Shape.unknown()</code>. It is not\n+   *       compatible with, for example, <code>Shape(32, 1, 784)</code> or <code>Shape(UNKNOWN_SIZE)\n+   *       </code>.\n+   * </ul>\n+   *\n+   * <p>The compatibility relation is reflexive and symmetric, but not transitive. For example,\n+   * <code>Shape(32, 784)</code> is compatible with <code>Shape.unknown()</code>, and <code>\n+   * Shape.unknown()</code> is compatible with <code>Shape(4, 4)</code>, but <code>Shape(32, 784)\n+   * </code> is not compatible with <code>Shape(4, 4)</code>.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4NjQ4MA=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyMzE0Ng==", "bodyText": "Probably yes, it would perfectly fit as an instance method of Shape: shape.isCompatibleWith(...)", "url": "https://github.com/tensorflow/java/pull/116#discussion_r499023146", "createdAt": "2020-10-02T19:57:36Z", "author": {"login": "karllessard"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.utils;\n+\n+import org.tensorflow.*;\n+import org.tensorflow.ndarray.NdArray;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.TUint8;\n+import org.tensorflow.types.family.TNumber;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Various methods for processing with Shapes and Operands\n+ */\n+public class ShapeUtils {\n+\n+  /**\n+   * Converts a shape operand to a Shape object\n+   *\n+   * @param dims the Operand containing the shape values\n+   * @return a new Shape based on an Operand that contains dimensions\n+   */\n+  public static <T extends TNumber> Shape toShape(Scope scope, Operand<T> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Shape.of(longDims);\n+  }\n+\n+  /**\n+   * Converts a TInt32 type Operand to a Java int array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the TInt32 Operand\n+   * @return the int array\n+   */\n+  public static int[] getIntArray(Scope scope, Operand<TInt32> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Arrays.stream(longDims).mapToInt(i -> (int) i).toArray();\n+  }\n+\n+  /**\n+   * Converts a TInt32 or TInt64 Operand to a java long array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the Operand\n+   * @param <T> the type of the dimensions, must either be TInt32 or TInt64 type\n+   * @return the long array\n+   * @throws java.lang.IllegalArgumentException if the dims type is not an integer\n+   */\n+  public static <T extends TNumber> long[] getLongArray(Scope scope, Operand<T> dims) {\n+    DataType<T> dType = dims.asOutput().dataType();\n+    if (!dType.isInteger()) {\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+    List<Long> result = new ArrayList<>();\n+\n+    if (scope.env().isEager()) {\n+      if (dType.equals(TInt32.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt32> idims = (Operand<TInt32>) dims;\n+\n+        idims.asOutput().data().scalars().forEach(s -> result.add((long) s.getInt()));\n+      } else if (dType.equals(TInt64.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt64> ldims = (Operand<TInt64>) dims;\n+        ldims.asOutput().data().scalars().forEach(s -> result.add(s.getLong()));\n+      } else if (dType.equals(TUint8.DTYPE)) {\n+      @SuppressWarnings(\"unchecked\")\n+      Operand<TUint8> udims = (Operand<TUint8>) dims;\n+        udims.asOutput().data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+    }else { // shouldn't happen\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+\n+    } else {\n+      try (Session session = new Session((Graph) scope.env())) {\n+        if (dType.equals(TInt32.DTYPE)) {\n+          try (Tensor<TInt32> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt32.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add((long) s.getInt()));\n+          }\n+        } else if (dType.equals(TInt64.DTYPE)){\n+          try (Tensor<TInt64> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt64.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getLong()));\n+          }\n+        }else if (dType.equals(TUint8.DTYPE)){\n+          try (Tensor<TUint8> tensorResult =\n+                       session.runner().fetch(dims).run().get(0).expect(TUint8.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+          }\n+      }else { // shouldn't happen\n+          throw new IllegalArgumentException(\"the data type must be an integer type\");\n+        }\n+      }\n+    }\n+    return result.stream().mapToLong(i -> i).toArray();\n+  }\n+\n+  /**\n+   * Gets the shape for the data within a Tensor\n+   *\n+   * @param tensor the tensor\n+   * @return the Shape of the tensor's data;\n+   */\n+  public static <T extends TNumber> Shape getShape(Tensor<T> tensor) {\n+    NdArray<?> data = (NdArray<?>) tensor.data();\n+    return data.shape();\n+  }\n+\n+  /**\n+   * Determines whether two shapes are compatible.\n+   *\n+   * <p>\n+   *\n+   * <p>Two possibly-partially-defined shapes are compatible if there exists a fully-defined shape\n+   * that both shapes can represent. Thus, compatibility allows the shape inference code to reason\n+   * about partially-defined shapes. For example:\n+   *\n+   * <ul>\n+   *   <li><code>Shape.unknown()</code> is compatible with all shapes.\n+   *   <li><code>Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> is compatible with all two-dimensional\n+   *       shapes, such as <code>Shape(32, 784)</code>, and also <code>Shape.unknown()</code>. It is\n+   *       not compatible with, for example, <code>Shape(UNKNOWN_SIZE)</code> or <code>\n+   *       Shape(UNKNOWN_SIZE, UNKNOWN_SIZE, UNKNOWN_SIZE)</code>.\n+   *   <li><code>Shape(32, UNKNOWN_SIZE)</code> is compatible with all two-dimensional shapes with\n+   *       size 32 in the 0th dimension, and also <code>Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> and\n+   *       <code>Shape.unknown()</code>. It is not compatible with, for example, <code>Shape(32)\n+   *       </code>, <code>Shape(32, UNKNOWN_SIZE, 1)</code> or <code>Shape(64, UNKNOWN_SIZE)</code>.\n+   *   <li><code>Shape(32, 784)</code> is compatible with itself, and also <code>\n+   *       Shape(32, UNKNOWN_SIZE)</code>, <code>Shape(UNKNOWN_SIZE, 784)</code>, <code>\n+   *       Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> and <code>Shape.unknown()</code>. It is not\n+   *       compatible with, for example, <code>Shape(32, 1, 784)</code> or <code>Shape(UNKNOWN_SIZE)\n+   *       </code>.\n+   * </ul>\n+   *\n+   * <p>The compatibility relation is reflexive and symmetric, but not transitive. For example,\n+   * <code>Shape(32, 784)</code> is compatible with <code>Shape.unknown()</code>, and <code>\n+   * Shape.unknown()</code> is compatible with <code>Shape(4, 4)</code>, but <code>Shape(32, 784)\n+   * </code> is not compatible with <code>Shape(4, 4)</code>.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4NjQ4MA=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDE1NDg0OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjoyODo1NFrOHVZEwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1NzoyNlrOHVeTvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5Mjk2MQ==", "bodyText": "\"cade\"", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492192961", "createdAt": "2020-09-21T16:28:54Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.utils;\n+\n+import org.tensorflow.*;\n+import org.tensorflow.ndarray.NdArray;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.TUint8;\n+import org.tensorflow.types.family.TNumber;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Various methods for processing with Shapes and Operands\n+ */\n+public class ShapeUtils {\n+\n+  /**\n+   * Converts a shape operand to a Shape object\n+   *\n+   * @param dims the Operand containing the shape values\n+   * @return a new Shape based on an Operand that contains dimensions\n+   */\n+  public static <T extends TNumber> Shape toShape(Scope scope, Operand<T> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Shape.of(longDims);\n+  }\n+\n+  /**\n+   * Converts a TInt32 type Operand to a Java int array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the TInt32 Operand\n+   * @return the int array\n+   */\n+  public static int[] getIntArray(Scope scope, Operand<TInt32> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Arrays.stream(longDims).mapToInt(i -> (int) i).toArray();\n+  }\n+\n+  /**\n+   * Converts a TInt32 or TInt64 Operand to a java long array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the Operand\n+   * @param <T> the type of the dimensions, must either be TInt32 or TInt64 type\n+   * @return the long array\n+   * @throws java.lang.IllegalArgumentException if the dims type is not an integer\n+   */\n+  public static <T extends TNumber> long[] getLongArray(Scope scope, Operand<T> dims) {\n+    DataType<T> dType = dims.asOutput().dataType();\n+    if (!dType.isInteger()) {\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+    List<Long> result = new ArrayList<>();\n+\n+    if (scope.env().isEager()) {\n+      if (dType.equals(TInt32.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt32> idims = (Operand<TInt32>) dims;\n+\n+        idims.asOutput().data().scalars().forEach(s -> result.add((long) s.getInt()));\n+      } else if (dType.equals(TInt64.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt64> ldims = (Operand<TInt64>) dims;\n+        ldims.asOutput().data().scalars().forEach(s -> result.add(s.getLong()));\n+      } else if (dType.equals(TUint8.DTYPE)) {\n+      @SuppressWarnings(\"unchecked\")\n+      Operand<TUint8> udims = (Operand<TUint8>) dims;\n+        udims.asOutput().data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+    }else { // shouldn't happen\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+\n+    } else {\n+      try (Session session = new Session((Graph) scope.env())) {\n+        if (dType.equals(TInt32.DTYPE)) {\n+          try (Tensor<TInt32> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt32.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add((long) s.getInt()));\n+          }\n+        } else if (dType.equals(TInt64.DTYPE)){\n+          try (Tensor<TInt64> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt64.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getLong()));\n+          }\n+        }else if (dType.equals(TUint8.DTYPE)){\n+          try (Tensor<TUint8> tensorResult =\n+                       session.runner().fetch(dims).run().get(0).expect(TUint8.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+          }\n+      }else { // shouldn't happen\n+          throw new IllegalArgumentException(\"the data type must be an integer type\");\n+        }\n+      }\n+    }\n+    return result.stream().mapToLong(i -> i).toArray();\n+  }\n+\n+  /**\n+   * Gets the shape for the data within a Tensor\n+   *\n+   * @param tensor the tensor\n+   * @return the Shape of the tensor's data;\n+   */\n+  public static <T extends TNumber> Shape getShape(Tensor<T> tensor) {\n+    NdArray<?> data = (NdArray<?>) tensor.data();\n+    return data.shape();\n+  }\n+\n+  /**\n+   * Determines whether two shapes are compatible.\n+   *\n+   * <p>\n+   *\n+   * <p>Two possibly-partially-defined shapes are compatible if there exists a fully-defined shape\n+   * that both shapes can represent. Thus, compatibility allows the shape inference code to reason\n+   * about partially-defined shapes. For example:\n+   *\n+   * <ul>\n+   *   <li><code>Shape.unknown()</code> is compatible with all shapes.\n+   *   <li><code>Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> is compatible with all two-dimensional\n+   *       shapes, such as <code>Shape(32, 784)</code>, and also <code>Shape.unknown()</code>. It is\n+   *       not compatible with, for example, <code>Shape(UNKNOWN_SIZE)</code> or <code>\n+   *       Shape(UNKNOWN_SIZE, UNKNOWN_SIZE, UNKNOWN_SIZE)</code>.\n+   *   <li><code>Shape(32, UNKNOWN_SIZE)</code> is compatible with all two-dimensional shapes with\n+   *       size 32 in the 0th dimension, and also <code>Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> and\n+   *       <code>Shape.unknown()</code>. It is not compatible with, for example, <code>Shape(32)\n+   *       </code>, <code>Shape(32, UNKNOWN_SIZE, 1)</code> or <code>Shape(64, UNKNOWN_SIZE)</code>.\n+   *   <li><code>Shape(32, 784)</code> is compatible with itself, and also <code>\n+   *       Shape(32, UNKNOWN_SIZE)</code>, <code>Shape(UNKNOWN_SIZE, 784)</code>, <code>\n+   *       Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> and <code>Shape.unknown()</code>. It is not\n+   *       compatible with, for example, <code>Shape(32, 1, 784)</code> or <code>Shape(UNKNOWN_SIZE)\n+   *       </code>.\n+   * </ul>\n+   *\n+   * <p>The compatibility relation is reflexive and symmetric, but not transitive. For example,\n+   * <code>Shape(32, 784)</code> is compatible with <code>Shape.unknown()</code>, and <code>\n+   * Shape.unknown()</code> is compatible with <code>Shape(4, 4)</code>, but <code>Shape(32, 784)\n+   * </code> is not compatible with <code>Shape(4, 4)</code>.\n+   *\n+   * @param a The first shape\n+   * @param b The second shape\n+   * @return true, if the two shapes are compatible.\n+   */\n+  public static boolean isCompatibleWith(Shape a, Shape b) {\n+    if (isUnknownShape(a) && isUnknownShape(b)) {\n+      if (a.numDimensions() != b.numDimensions()) {\n+        return false;\n+      }\n+      for (int i = 0; i < a.numDimensions(); i++) {\n+        if (!isCompatible(a.size(i), b.size(i))) {\n+          return false;\n+        }\n+      }\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Determines if a shape is an unknown shape as provided in <cade>Shape.unknown()</code>.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3ODcxOA==", "bodyText": "OK", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492278718", "createdAt": "2020-09-21T18:57:26Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.utils;\n+\n+import org.tensorflow.*;\n+import org.tensorflow.ndarray.NdArray;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.TUint8;\n+import org.tensorflow.types.family.TNumber;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Various methods for processing with Shapes and Operands\n+ */\n+public class ShapeUtils {\n+\n+  /**\n+   * Converts a shape operand to a Shape object\n+   *\n+   * @param dims the Operand containing the shape values\n+   * @return a new Shape based on an Operand that contains dimensions\n+   */\n+  public static <T extends TNumber> Shape toShape(Scope scope, Operand<T> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Shape.of(longDims);\n+  }\n+\n+  /**\n+   * Converts a TInt32 type Operand to a Java int array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the TInt32 Operand\n+   * @return the int array\n+   */\n+  public static int[] getIntArray(Scope scope, Operand<TInt32> dims) {\n+    long[] longDims = getLongArray(scope, dims);\n+    return Arrays.stream(longDims).mapToInt(i -> (int) i).toArray();\n+  }\n+\n+  /**\n+   * Converts a TInt32 or TInt64 Operand to a java long array\n+   *\n+   * @param scope the TensorFlow scope\n+   * @param dims the Operand\n+   * @param <T> the type of the dimensions, must either be TInt32 or TInt64 type\n+   * @return the long array\n+   * @throws java.lang.IllegalArgumentException if the dims type is not an integer\n+   */\n+  public static <T extends TNumber> long[] getLongArray(Scope scope, Operand<T> dims) {\n+    DataType<T> dType = dims.asOutput().dataType();\n+    if (!dType.isInteger()) {\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+    List<Long> result = new ArrayList<>();\n+\n+    if (scope.env().isEager()) {\n+      if (dType.equals(TInt32.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt32> idims = (Operand<TInt32>) dims;\n+\n+        idims.asOutput().data().scalars().forEach(s -> result.add((long) s.getInt()));\n+      } else if (dType.equals(TInt64.DTYPE)) {\n+        @SuppressWarnings(\"unchecked\")\n+        Operand<TInt64> ldims = (Operand<TInt64>) dims;\n+        ldims.asOutput().data().scalars().forEach(s -> result.add(s.getLong()));\n+      } else if (dType.equals(TUint8.DTYPE)) {\n+      @SuppressWarnings(\"unchecked\")\n+      Operand<TUint8> udims = (Operand<TUint8>) dims;\n+        udims.asOutput().data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+    }else { // shouldn't happen\n+      throw new IllegalArgumentException(\"the data type must be an integer type\");\n+    }\n+\n+    } else {\n+      try (Session session = new Session((Graph) scope.env())) {\n+        if (dType.equals(TInt32.DTYPE)) {\n+          try (Tensor<TInt32> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt32.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add((long) s.getInt()));\n+          }\n+        } else if (dType.equals(TInt64.DTYPE)){\n+          try (Tensor<TInt64> tensorResult =\n+              session.runner().fetch(dims).run().get(0).expect(TInt64.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getLong()));\n+          }\n+        }else if (dType.equals(TUint8.DTYPE)){\n+          try (Tensor<TUint8> tensorResult =\n+                       session.runner().fetch(dims).run().get(0).expect(TUint8.DTYPE)) {\n+            tensorResult.data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n+          }\n+      }else { // shouldn't happen\n+          throw new IllegalArgumentException(\"the data type must be an integer type\");\n+        }\n+      }\n+    }\n+    return result.stream().mapToLong(i -> i).toArray();\n+  }\n+\n+  /**\n+   * Gets the shape for the data within a Tensor\n+   *\n+   * @param tensor the tensor\n+   * @return the Shape of the tensor's data;\n+   */\n+  public static <T extends TNumber> Shape getShape(Tensor<T> tensor) {\n+    NdArray<?> data = (NdArray<?>) tensor.data();\n+    return data.shape();\n+  }\n+\n+  /**\n+   * Determines whether two shapes are compatible.\n+   *\n+   * <p>\n+   *\n+   * <p>Two possibly-partially-defined shapes are compatible if there exists a fully-defined shape\n+   * that both shapes can represent. Thus, compatibility allows the shape inference code to reason\n+   * about partially-defined shapes. For example:\n+   *\n+   * <ul>\n+   *   <li><code>Shape.unknown()</code> is compatible with all shapes.\n+   *   <li><code>Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> is compatible with all two-dimensional\n+   *       shapes, such as <code>Shape(32, 784)</code>, and also <code>Shape.unknown()</code>. It is\n+   *       not compatible with, for example, <code>Shape(UNKNOWN_SIZE)</code> or <code>\n+   *       Shape(UNKNOWN_SIZE, UNKNOWN_SIZE, UNKNOWN_SIZE)</code>.\n+   *   <li><code>Shape(32, UNKNOWN_SIZE)</code> is compatible with all two-dimensional shapes with\n+   *       size 32 in the 0th dimension, and also <code>Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> and\n+   *       <code>Shape.unknown()</code>. It is not compatible with, for example, <code>Shape(32)\n+   *       </code>, <code>Shape(32, UNKNOWN_SIZE, 1)</code> or <code>Shape(64, UNKNOWN_SIZE)</code>.\n+   *   <li><code>Shape(32, 784)</code> is compatible with itself, and also <code>\n+   *       Shape(32, UNKNOWN_SIZE)</code>, <code>Shape(UNKNOWN_SIZE, 784)</code>, <code>\n+   *       Shape(UNKNOWN_SIZE, UNKNOWN_SIZE)</code> and <code>Shape.unknown()</code>. It is not\n+   *       compatible with, for example, <code>Shape(32, 1, 784)</code> or <code>Shape(UNKNOWN_SIZE)\n+   *       </code>.\n+   * </ul>\n+   *\n+   * <p>The compatibility relation is reflexive and symmetric, but not transitive. For example,\n+   * <code>Shape(32, 784)</code> is compatible with <code>Shape.unknown()</code>, and <code>\n+   * Shape.unknown()</code> is compatible with <code>Shape(4, 4)</code>, but <code>Shape(32, 784)\n+   * </code> is not compatible with <code>Shape(4, 4)</code>.\n+   *\n+   * @param a The first shape\n+   * @param b The second shape\n+   * @return true, if the two shapes are compatible.\n+   */\n+  public static boolean isCompatibleWith(Shape a, Shape b) {\n+    if (isUnknownShape(a) && isUnknownShape(b)) {\n+      if (a.numDimensions() != b.numDimensions()) {\n+        return false;\n+      }\n+      for (int i = 0; i < a.numDimensions(); i++) {\n+        if (!isCompatible(a.size(i), b.size(i))) {\n+          return false;\n+        }\n+      }\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Determines if a shape is an unknown shape as provided in <cade>Shape.unknown()</code>.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5Mjk2MQ=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDYwMTQ3OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/test/java/org/tensorflow/framework/initializers/ConstantTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODoyOTo1OVrOHVdZYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxODo1Nzo1NVrOHVeU0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2Mzc3OQ==", "bodyText": "Have these tests been run in graph mode too?", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492263779", "createdAt": "2020-09-21T18:29:59Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/test/java/org/tensorflow/framework/initializers/ConstantTest.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.junit.jupiter.api.*;\n+import org.tensorflow.Operand;\n+import org.tensorflow.framework.utils.TestSession;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.*;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/** Test the Constant initializer */\n+public class ConstantTest {\n+\n+  private final TestSession.Mode tfMode = TestSession.Mode.EAGER;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI3ODk5NQ==", "bodyText": "I will change to run in both modes.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r492278995", "createdAt": "2020-09-21T18:57:55Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/test/java/org/tensorflow/framework/initializers/ConstantTest.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.junit.jupiter.api.*;\n+import org.tensorflow.Operand;\n+import org.tensorflow.framework.utils.TestSession;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.*;\n+\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+/** Test the Constant initializer */\n+public class ConstantTest {\n+\n+  private final TestSession.Mode tfMode = TestSession.Mode.EAGER;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI2Mzc3OQ=="}, "originalCommit": {"oid": "33530bbd7d41f4b8f3b628b2252a378ae2f9bb49"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDg4MjcyOnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Constant.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMDoyNTo0M1rOHW_qeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMDoxODoxOFrOHYRTXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3Mzc4Ng==", "bodyText": "The javadoc says double, but the constructor expects a long.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r493873786", "createdAt": "2020-09-23T20:25:43Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Constant.java", "diffHunk": "@@ -36,19 +36,37 @@\n  */\n public class Constant<T extends TType> extends BaseInitializer<T> {\n \n-  private final Number numberValue;\n-  private final Boolean booleanValue;\n+  private final double doubleValue;\n+  private final long longValue;\n+  private final boolean booleanValue;\n+  private final ValueType valueType;\n \n   /**\n    * Creates an Initializer that generates tensors with a constant value.\n    *\n    * @param tf the TensorFlow Ops\n-   * @param value a number value\n+   * @param value a double value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIxMTM1OA==", "bodyText": "OK", "url": "https://github.com/tensorflow/java/pull/116#discussion_r495211358", "createdAt": "2020-09-25T20:18:18Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Constant.java", "diffHunk": "@@ -36,19 +36,37 @@\n  */\n public class Constant<T extends TType> extends BaseInitializer<T> {\n \n-  private final Number numberValue;\n-  private final Boolean booleanValue;\n+  private final double doubleValue;\n+  private final long longValue;\n+  private final boolean booleanValue;\n+  private final ValueType valueType;\n \n   /**\n    * Creates an Initializer that generates tensors with a constant value.\n    *\n    * @param tf the TensorFlow Ops\n-   * @param value a number value\n+   * @param value a double value", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3Mzc4Ng=="}, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDg5NDk4OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Glorot.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMDoyOTozMlrOHW_yEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMDozNToyNlrOHYRvEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NTcyOQ==", "bodyText": "So I understand that this is to replicate the behaviour in Keras, where GlorotNormal means use the Glorot variance and sample from a truncated normal, but why does it throw if people want to draw from a regular normal distribution? Also it looks like the super constructor doesn't throw IllegalArgumentException in this case, only if it got a zero SCALE param.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r493875729", "createdAt": "2020-09-23T20:29:32Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Glorot.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * The Glorot initializer, also called Xavier initializer.\n+ *\n+ * <p>Draws samples from a random distribution.\n+ *\n+ * <p>If the distribution is TRUNCATED_NORMAL, then the distribution is centered on 0 with <code>\n+ *  stddev = Math.sqrt(2. / (fanIn + fanOut))</code> where <code>fanIn</code> is the number of input\n+ * units in the weight tensor and <code>fanOut</code> is the number of output units in the weight\n+ * tensor.\n+ *\n+ * <p>If the distribution is UNIFORM, then samples are drawn from a uniform distribution within\n+ * <code>[-limit, limit]</code>, where <code>limit = sqrt(6 / (fanIn + fanOut))</code> ( <code>fanIn\n+ * </code> is the number of input units in the weight tensor and <code> fanOut</code> is the number\n+ * of output units).\n+ *\n+ * <p>Examples:\n+ *\n+ * <p>Glorot Normal:\n+ *\n+ * <pre>\n+ *     long seed = 1001l;\n+ *     Glorot&lt;TFloat32, TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Glorot&lt;&gt;(tf,\n+ *             Distribution.TRUNCATED_NORMAL, seed);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * <p>Glorot Uniform:\n+ *\n+ * <pre>\n+ *    long seed = 1001l;\n+ *    Glorot&lt;TFloat32, TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Glorot&lt;&gt;(tf,\n+ *             Distribution.UNIFORM, seed);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ * @see VarianceScaling.Distribution\n+ * @see <a href=\"http://proceedings.mlr.press/v9/glorot10a.html\">Glorot et al., 2010</a>\n+ */\n+public class Glorot<T extends TType, U extends TNumber> extends VarianceScaling<T, U> {\n+\n+  public static final double SCALE = 1.0;\n+\n+  /**\n+   * Creates a Glorot initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param distribution The distribution type for the Glorot initializer.\n+   * @param seed the seed for random number generation. An initializer created with a given seed\n+   *     will always produce the same random tensor for a given shape and dtype.\n+   * @throws java.lang.IllegalArgumentException if the distribution is not TRUNCATED_NORMAL or", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI2NzUxNw==", "bodyText": "In Keras, they only use Normal and Uniform. But it seems a little arbitrary.\nHere is the original discussion from the Keras thread on why they chose these two.\nKeras Issue on GlorotNormal vs GlorotUniform \nThe @throws was left in by mistake when I used to check for only TRUNCATED_NORMAL and UNIFORM. I will remove it.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r494267517", "createdAt": "2020-09-24T12:18:23Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Glorot.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * The Glorot initializer, also called Xavier initializer.\n+ *\n+ * <p>Draws samples from a random distribution.\n+ *\n+ * <p>If the distribution is TRUNCATED_NORMAL, then the distribution is centered on 0 with <code>\n+ *  stddev = Math.sqrt(2. / (fanIn + fanOut))</code> where <code>fanIn</code> is the number of input\n+ * units in the weight tensor and <code>fanOut</code> is the number of output units in the weight\n+ * tensor.\n+ *\n+ * <p>If the distribution is UNIFORM, then samples are drawn from a uniform distribution within\n+ * <code>[-limit, limit]</code>, where <code>limit = sqrt(6 / (fanIn + fanOut))</code> ( <code>fanIn\n+ * </code> is the number of input units in the weight tensor and <code> fanOut</code> is the number\n+ * of output units).\n+ *\n+ * <p>Examples:\n+ *\n+ * <p>Glorot Normal:\n+ *\n+ * <pre>\n+ *     long seed = 1001l;\n+ *     Glorot&lt;TFloat32, TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Glorot&lt;&gt;(tf,\n+ *             Distribution.TRUNCATED_NORMAL, seed);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * <p>Glorot Uniform:\n+ *\n+ * <pre>\n+ *    long seed = 1001l;\n+ *    Glorot&lt;TFloat32, TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Glorot&lt;&gt;(tf,\n+ *             Distribution.UNIFORM, seed);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ * @see VarianceScaling.Distribution\n+ * @see <a href=\"http://proceedings.mlr.press/v9/glorot10a.html\">Glorot et al., 2010</a>\n+ */\n+public class Glorot<T extends TType, U extends TNumber> extends VarianceScaling<T, U> {\n+\n+  public static final double SCALE = 1.0;\n+\n+  /**\n+   * Creates a Glorot initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param distribution The distribution type for the Glorot initializer.\n+   * @param seed the seed for random number generation. An initializer created with a given seed\n+   *     will always produce the same random tensor for a given shape and dtype.\n+   * @throws java.lang.IllegalArgumentException if the distribution is not TRUNCATED_NORMAL or", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NTcyOQ=="}, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDQyNzAyNA==", "bodyText": "I think exposing all three is fine, and maybe a note to say that Keras uses TRUNCATED_NORMAL in the ones that produce normal values.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r494427024", "createdAt": "2020-09-24T15:49:38Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Glorot.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * The Glorot initializer, also called Xavier initializer.\n+ *\n+ * <p>Draws samples from a random distribution.\n+ *\n+ * <p>If the distribution is TRUNCATED_NORMAL, then the distribution is centered on 0 with <code>\n+ *  stddev = Math.sqrt(2. / (fanIn + fanOut))</code> where <code>fanIn</code> is the number of input\n+ * units in the weight tensor and <code>fanOut</code> is the number of output units in the weight\n+ * tensor.\n+ *\n+ * <p>If the distribution is UNIFORM, then samples are drawn from a uniform distribution within\n+ * <code>[-limit, limit]</code>, where <code>limit = sqrt(6 / (fanIn + fanOut))</code> ( <code>fanIn\n+ * </code> is the number of input units in the weight tensor and <code> fanOut</code> is the number\n+ * of output units).\n+ *\n+ * <p>Examples:\n+ *\n+ * <p>Glorot Normal:\n+ *\n+ * <pre>\n+ *     long seed = 1001l;\n+ *     Glorot&lt;TFloat32, TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Glorot&lt;&gt;(tf,\n+ *             Distribution.TRUNCATED_NORMAL, seed);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * <p>Glorot Uniform:\n+ *\n+ * <pre>\n+ *    long seed = 1001l;\n+ *    Glorot&lt;TFloat32, TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Glorot&lt;&gt;(tf,\n+ *             Distribution.UNIFORM, seed);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ * @see VarianceScaling.Distribution\n+ * @see <a href=\"http://proceedings.mlr.press/v9/glorot10a.html\">Glorot et al., 2010</a>\n+ */\n+public class Glorot<T extends TType, U extends TNumber> extends VarianceScaling<T, U> {\n+\n+  public static final double SCALE = 1.0;\n+\n+  /**\n+   * Creates a Glorot initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param distribution The distribution type for the Glorot initializer.\n+   * @param seed the seed for random number generation. An initializer created with a given seed\n+   *     will always produce the same random tensor for a given shape and dtype.\n+   * @throws java.lang.IllegalArgumentException if the distribution is not TRUNCATED_NORMAL or", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NTcyOQ=="}, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIxODQ0OA==", "bodyText": "I added class JavaDoc in all three types, Glorot, He, and LeCun, highlighting how to reproduce xxxxxNormal, and xxxxxUniform by using TRUNCATED_NORMAL and UNIFORM, respectively.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r495218448", "createdAt": "2020-09-25T20:35:26Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Glorot.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * The Glorot initializer, also called Xavier initializer.\n+ *\n+ * <p>Draws samples from a random distribution.\n+ *\n+ * <p>If the distribution is TRUNCATED_NORMAL, then the distribution is centered on 0 with <code>\n+ *  stddev = Math.sqrt(2. / (fanIn + fanOut))</code> where <code>fanIn</code> is the number of input\n+ * units in the weight tensor and <code>fanOut</code> is the number of output units in the weight\n+ * tensor.\n+ *\n+ * <p>If the distribution is UNIFORM, then samples are drawn from a uniform distribution within\n+ * <code>[-limit, limit]</code>, where <code>limit = sqrt(6 / (fanIn + fanOut))</code> ( <code>fanIn\n+ * </code> is the number of input units in the weight tensor and <code> fanOut</code> is the number\n+ * of output units).\n+ *\n+ * <p>Examples:\n+ *\n+ * <p>Glorot Normal:\n+ *\n+ * <pre>\n+ *     long seed = 1001l;\n+ *     Glorot&lt;TFloat32, TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Glorot&lt;&gt;(tf,\n+ *             Distribution.TRUNCATED_NORMAL, seed);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * <p>Glorot Uniform:\n+ *\n+ * <pre>\n+ *    long seed = 1001l;\n+ *    Glorot&lt;TFloat32, TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Glorot&lt;&gt;(tf,\n+ *             Distribution.UNIFORM, seed);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The TType for the call operation\n+ * @param <U> The TNumber for the call operation\n+ * @see VarianceScaling.Distribution\n+ * @see <a href=\"http://proceedings.mlr.press/v9/glorot10a.html\">Glorot et al., 2010</a>\n+ */\n+public class Glorot<T extends TType, U extends TNumber> extends VarianceScaling<T, U> {\n+\n+  public static final double SCALE = 1.0;\n+\n+  /**\n+   * Creates a Glorot initializer\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param distribution The distribution type for the Glorot initializer.\n+   * @param seed the seed for random number generation. An initializer created with a given seed\n+   *     will always produce the same random tensor for a given shape and dtype.\n+   * @throws java.lang.IllegalArgumentException if the distribution is not TRUNCATED_NORMAL or", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg3NTcyOQ=="}, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDkyMzM0OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Orthogonal.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMDozNzo0MFrOHXADQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMDo0ODoxMFrOHYSCqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MDEyOQ==", "bodyText": "This default notice should be on the other constructor as this one can't use defaults.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r493880129", "createdAt": "2020-09-23T20:37:40Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Orthogonal.java", "diffHunk": "@@ -90,8 +72,9 @@ public Orthogonal(Ops tf, Long seed) {\n    * Creates an Orthogonal Initializer\n    *\n    * @param tf the TensorFlow Ops\n-   * @param gain the gain to be applied to the Matrix\n-   * @param seed the seed for random number generation\n+   * @param gain the gain to be applied to the Matrix. Default is 1.0.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIyMzQ2Ng==", "bodyText": "OK", "url": "https://github.com/tensorflow/java/pull/116#discussion_r495223466", "createdAt": "2020-09-25T20:48:10Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Orthogonal.java", "diffHunk": "@@ -90,8 +72,9 @@ public Orthogonal(Ops tf, Long seed) {\n    * Creates an Orthogonal Initializer\n    *\n    * @param tf the TensorFlow Ops\n-   * @param gain the gain to be applied to the Matrix\n-   * @param seed the seed for random number generation\n+   * @param gain the gain to be applied to the Matrix. Default is 1.0.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MDEyOQ=="}, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDkzMDE3OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomNormal.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMDozOTo0NlrOHXAHiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMjoyODozMFrOHaxg4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MTIyNA==", "bodyText": "Default doc needs to move to the place where it's defaulted. Also I'd make it refer to the default value that way the comment can't become stale (e.g. {@link MEAN_DEFAULT}).", "url": "https://github.com/tensorflow/java/pull/116#discussion_r493881224", "createdAt": "2020-09-23T20:39:46Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomNormal.java", "diffHunk": "@@ -47,39 +49,33 @@\n    * creates the RandomUniform initializer\n    *\n    * @param tf the TensorFlow Ops\n+   * @param seed the seed for random number generation. An initializer created with a given seed\n+   *     will always produce the same random tensor for a given shape and dtype.\n    */\n-  public RandomNormal(Ops tf) {\n-    this(tf, MEAN_DEFAULT, STDDEV_DEFAULT, null);\n-  }\n-\n-  /**\n-   * creates the RandomUniform initializer\n-   *\n-   * @param tf the TensorFlow Ops\n-   * @param mean Mean of the random values to generate.\n-   */\n-  public RandomNormal(Ops tf, double mean) {\n-    this(tf, mean, STDDEV_DEFAULT, null);\n+  public RandomNormal(Ops tf, Long seed) {\n+    this(tf, MEAN_DEFAULT, STDDEV_DEFAULT, seed);\n   }\n \n   /**\n    * creates the RandomUniform initializer\n    *\n    * @param tf the TensorFlow Ops\n-   * @param mean Mean of the random values to generate.\n-   * @param stddev Standard deviation of the random values to generate.\n+   * @param mean Mean of the random values to generate. Default is 0.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzNjI1OQ==", "bodyText": "OK", "url": "https://github.com/tensorflow/java/pull/116#discussion_r497836259", "createdAt": "2020-09-30T22:28:30Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomNormal.java", "diffHunk": "@@ -47,39 +49,33 @@\n    * creates the RandomUniform initializer\n    *\n    * @param tf the TensorFlow Ops\n+   * @param seed the seed for random number generation. An initializer created with a given seed\n+   *     will always produce the same random tensor for a given shape and dtype.\n    */\n-  public RandomNormal(Ops tf) {\n-    this(tf, MEAN_DEFAULT, STDDEV_DEFAULT, null);\n-  }\n-\n-  /**\n-   * creates the RandomUniform initializer\n-   *\n-   * @param tf the TensorFlow Ops\n-   * @param mean Mean of the random values to generate.\n-   */\n-  public RandomNormal(Ops tf, double mean) {\n-    this(tf, mean, STDDEV_DEFAULT, null);\n+  public RandomNormal(Ops tf, Long seed) {\n+    this(tf, MEAN_DEFAULT, STDDEV_DEFAULT, seed);\n   }\n \n   /**\n    * creates the RandomUniform initializer\n    *\n    * @param tf the TensorFlow Ops\n-   * @param mean Mean of the random values to generate.\n-   * @param stddev Standard deviation of the random values to generate.\n+   * @param mean Mean of the random values to generate. Default is 0.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MTIyNA=="}, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDkzMTk3OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomUniform.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMDo0MDoxOVrOHXAIrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQyMjoyODozN1rOHaxhEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MTUxOQ==", "bodyText": "Move the default doc.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r493881519", "createdAt": "2020-09-23T20:40:19Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomUniform.java", "diffHunk": "@@ -49,29 +51,23 @@\n    * Creates a RandomUniform initializer\n    *\n    * @param tf the TensorFlow Ops\n+   * @param seed the seed for random number generation. An initializer created with a given seed\n+   *     will always produce the same random tensor for a given shape and dtype.\n    */\n-  public RandomUniform(Ops tf) {\n-    this(tf, MINVAL_DEFAULT, MAXVAL_DEFAULT, null);\n-  }\n-\n-  /**\n-   * Creates a RandomUniform initializer\n-   *\n-   * @param tf the TensorFlow Ops\n-   * @param minval Lower bound of the range of random values to generate (inclusive).\n-   * @param maxval Upper bound of the range of random values to generate (exclusive).\n-   */\n-  public RandomUniform(Ops tf, double minval, double maxval) {\n-    this(tf, minval, maxval, null);\n+  public RandomUniform(Ops tf, Long seed) {\n+    this(tf, MINVAL_DEFAULT, MAXVAL_DEFAULT, seed);\n   }\n \n   /**\n    * Creates a RandomUniform initializer\n    *\n    * @param tf the TensorFlow Ops\n-   * @param minval Lower bound of the range of random values to generate (inclusive).\n-   * @param maxval Upper bound of the range of random values to generate (exclusive).\n-   * @param seed Used to create random seeds.\n+   * @param minval Lower bound of the range of random values to generate (inclusive). Default is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIyMzcxNg==", "bodyText": "OK", "url": "https://github.com/tensorflow/java/pull/116#discussion_r495223716", "createdAt": "2020-09-25T20:48:47Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomUniform.java", "diffHunk": "@@ -49,29 +51,23 @@\n    * Creates a RandomUniform initializer\n    *\n    * @param tf the TensorFlow Ops\n+   * @param seed the seed for random number generation. An initializer created with a given seed\n+   *     will always produce the same random tensor for a given shape and dtype.\n    */\n-  public RandomUniform(Ops tf) {\n-    this(tf, MINVAL_DEFAULT, MAXVAL_DEFAULT, null);\n-  }\n-\n-  /**\n-   * Creates a RandomUniform initializer\n-   *\n-   * @param tf the TensorFlow Ops\n-   * @param minval Lower bound of the range of random values to generate (inclusive).\n-   * @param maxval Upper bound of the range of random values to generate (exclusive).\n-   */\n-  public RandomUniform(Ops tf, double minval, double maxval) {\n-    this(tf, minval, maxval, null);\n+  public RandomUniform(Ops tf, Long seed) {\n+    this(tf, MINVAL_DEFAULT, MAXVAL_DEFAULT, seed);\n   }\n \n   /**\n    * Creates a RandomUniform initializer\n    *\n    * @param tf the TensorFlow Ops\n-   * @param minval Lower bound of the range of random values to generate (inclusive).\n-   * @param maxval Upper bound of the range of random values to generate (exclusive).\n-   * @param seed Used to create random seeds.\n+   * @param minval Lower bound of the range of random values to generate (inclusive). Default is", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MTUxOQ=="}, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzgzNjMwNA==", "bodyText": "OK", "url": "https://github.com/tensorflow/java/pull/116#discussion_r497836304", "createdAt": "2020-09-30T22:28:37Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/RandomUniform.java", "diffHunk": "@@ -49,29 +51,23 @@\n    * Creates a RandomUniform initializer\n    *\n    * @param tf the TensorFlow Ops\n+   * @param seed the seed for random number generation. An initializer created with a given seed\n+   *     will always produce the same random tensor for a given shape and dtype.\n    */\n-  public RandomUniform(Ops tf) {\n-    this(tf, MINVAL_DEFAULT, MAXVAL_DEFAULT, null);\n-  }\n-\n-  /**\n-   * Creates a RandomUniform initializer\n-   *\n-   * @param tf the TensorFlow Ops\n-   * @param minval Lower bound of the range of random values to generate (inclusive).\n-   * @param maxval Upper bound of the range of random values to generate (exclusive).\n-   */\n-  public RandomUniform(Ops tf, double minval, double maxval) {\n-    this(tf, minval, maxval, null);\n+  public RandomUniform(Ops tf, Long seed) {\n+    this(tf, MINVAL_DEFAULT, MAXVAL_DEFAULT, seed);\n   }\n \n   /**\n    * Creates a RandomUniform initializer\n    *\n    * @param tf the TensorFlow Ops\n-   * @param minval Lower bound of the range of random values to generate (inclusive).\n-   * @param maxval Upper bound of the range of random values to generate (exclusive).\n-   * @param seed Used to create random seeds.\n+   * @param minval Lower bound of the range of random values to generate (inclusive). Default is", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MTUxOQ=="}, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDkzMjcyOnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/TruncatedNormal.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMDo0MDozM1rOHXAJJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMDo0ODo1NVrOHYSD0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MTYzNw==", "bodyText": "Default doc.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r493881637", "createdAt": "2020-09-23T20:40:33Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/TruncatedNormal.java", "diffHunk": "@@ -49,29 +50,21 @@\n    * Creates a TruncatedNormal Initializer\n    *\n    * @param tf the TensorFlow Ops\n+   * @param seed the seed for random number generation. An initializer created with a given seed\n+   *     will always produce the same random tensor for a given shape and dtype.\n    */\n-  public TruncatedNormal(Ops tf) {\n-    this(tf, MEAN_DEFAULT, STDDEV_DEFAULT, null);\n+  public TruncatedNormal(Ops tf, Long seed) {\n+    this(tf, MEAN_DEFAULT, STDDEV_DEFAULT, seed);\n   }\n \n   /**\n    * Creates a TruncatedNormal Initializer\n    *\n    * @param tf the TensorFlow Ops\n-   * @param mean Mean of the random values to generate.\n-   * @param stddev Standard deviation of the random values to generate.\n-   */\n-  public TruncatedNormal(Ops tf, double mean, double stddev) {\n-    this(tf, mean, stddev, null);\n-  }\n-\n-  /**\n-   * Creates a TruncatedNormal Initializer\n-   *\n-   * @param tf the TensorFlow Ops\n-   * @param mean Mean of the random values to generate.\n-   * @param stddev Standard deviation of the random values to generate.\n-   * @param seed Used to create random seeds\n+   * @param mean Mean of the random values to generate. Default is 0.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTIyMzc2Mw==", "bodyText": "OK", "url": "https://github.com/tensorflow/java/pull/116#discussion_r495223763", "createdAt": "2020-09-25T20:48:55Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/TruncatedNormal.java", "diffHunk": "@@ -49,29 +50,21 @@\n    * Creates a TruncatedNormal Initializer\n    *\n    * @param tf the TensorFlow Ops\n+   * @param seed the seed for random number generation. An initializer created with a given seed\n+   *     will always produce the same random tensor for a given shape and dtype.\n    */\n-  public TruncatedNormal(Ops tf) {\n-    this(tf, MEAN_DEFAULT, STDDEV_DEFAULT, null);\n+  public TruncatedNormal(Ops tf, Long seed) {\n+    this(tf, MEAN_DEFAULT, STDDEV_DEFAULT, seed);\n   }\n \n   /**\n    * Creates a TruncatedNormal Initializer\n    *\n    * @param tf the TensorFlow Ops\n-   * @param mean Mean of the random values to generate.\n-   * @param stddev Standard deviation of the random values to generate.\n-   */\n-  public TruncatedNormal(Ops tf, double mean, double stddev) {\n-    this(tf, mean, stddev, null);\n-  }\n-\n-  /**\n-   * Creates a TruncatedNormal Initializer\n-   *\n-   * @param tf the TensorFlow Ops\n-   * @param mean Mean of the random values to generate.\n-   * @param stddev Standard deviation of the random values to generate.\n-   * @param seed Used to create random seeds\n+   * @param mean Mean of the random values to generate. Default is 0.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4MTYzNw=="}, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5MDk0NzkxOnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/VarianceScaling.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QyMDo0NTowNVrOHXASoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQxMjoxNDoyNlrOHXXi4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4NDA2NA==", "bodyText": "I'd missed this last time, could this just be NORMAL not UNTRUNCATED_NORMAL?", "url": "https://github.com/tensorflow/java/pull/116#discussion_r493884064", "createdAt": "2020-09-23T20:45:05Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/VarianceScaling.java", "diffHunk": "@@ -188,14 +188,14 @@ public VarianceScaling(Ops tf, double scale, Mode mode, Distribution distributio\n   }\n \n   /** The mode to use for calculating the fan values. */\n-  public static enum Mode {\n+  public enum Mode {\n     FAN_IN,\n     FAN_OUT,\n     FAN_AVG\n   }\n \n   /** The random distribution to use when initializing the values. */\n-  public static enum Distribution {\n+  public enum Distribution {\n     TRUNCATED_NORMAL,\n     UNTRUNCATED_NORMAL,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDI2NTA1OA==", "bodyText": "OK", "url": "https://github.com/tensorflow/java/pull/116#discussion_r494265058", "createdAt": "2020-09-24T12:14:26Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/VarianceScaling.java", "diffHunk": "@@ -188,14 +188,14 @@ public VarianceScaling(Ops tf, double scale, Mode mode, Distribution distributio\n   }\n \n   /** The mode to use for calculating the fan values. */\n-  public static enum Mode {\n+  public enum Mode {\n     FAN_IN,\n     FAN_OUT,\n     FAN_AVG\n   }\n \n   /** The random distribution to use when initializing the values. */\n-  public static enum Distribution {\n+  public enum Distribution {\n     TRUNCATED_NORMAL,\n     UNTRUNCATED_NORMAL,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg4NDA2NA=="}, "originalCommit": {"oid": "43f3fb76bd0eb2d9b8aaf2ac6731d10a9f17c0b4"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNDA1NjM4OnYy", "diffSide": "RIGHT", "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Identity.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDowMDo0NFrOHb6CKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMDowMDo0NFrOHb6CKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAyNDQyNw==", "bodyText": "There is still a few variables like this in the PR using snake_case instead of camelCase.", "url": "https://github.com/tensorflow/java/pull/116#discussion_r499024427", "createdAt": "2020-10-02T20:00:44Z", "author": {"login": "karllessard"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/initializers/Identity.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/* Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+=======================================================================*/\n+package org.tensorflow.framework.initializers;\n+\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.framework.utils.ShapeUtils;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * Initializer that generates the identity matrix.\n+ *\n+ * <p>Only usable for generating 2D matrices.\n+ *\n+ * <p>Examples:\n+ *\n+ * <pre>\n+ *     Identity&lt;TFloat32&gt; initializer =\n+ *             new org.tensorflow.framework.initializers.Identity&lt;&gt;(tf);\n+ *     Operand&lt;TFloat32&gt; values =\n+ *             initializer.call(tf.constant(Shape.of(2,2)), TFloat32.DTYPE);\n+ * </pre>\n+ *\n+ * @param <T> The TType for the call operation\n+ */\n+public class Identity<T extends TType> extends BaseInitializer<T> {\n+  public static final double GAIN_DEFAULT = 1.0;\n+\n+  private final double gain;\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   */\n+  public Identity(Ops tf) {\n+    super(tf);\n+    this.gain = GAIN_DEFAULT;\n+  }\n+\n+  /**\n+   * Creates an Initializer that generates the identity matrix.\n+   *\n+   * @param tf the TensorFlow Ops\n+   * @param gain the gain to be applied to the Identity Matrix\n+   */\n+  public Identity(Ops tf, double gain) {\n+    super(tf);\n+    this.gain = gain;\n+  }\n+\n+  /** {@inheritDoc} */\n+  @Override\n+  public Operand<T> call(Operand<TInt64> dims, DataType<T> dtype) {\n+    if (!dtype.isFloating()) {\n+      throw new IllegalArgumentException(\"DataType must be a float type: \" + dtype.name());\n+    }\n+    Shape shape = ShapeUtils.toShape(tf.scope(), dims);\n+    if (shape.numDimensions() != 2) {\n+      throw new IllegalArgumentException(\"2D matrix required, got \" + shape.numDimensions());\n+    }\n+    boolean isSquare = shape.size(0) == shape.size(1);\n+    long diag_size = Math.min(shape.size(0), shape.size(1));\n+    Shape diagShape = Shape.of(diag_size);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f2fb0dc6679f9ef23f2de8f6674286f179d4d9"}, "originalPosition": 79}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1634, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}