{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2MTMwNjE1", "number": 31, "title": "NdArrays and DataBuffers equality and hash codes", "bodyText": "This PR adds the ability to compare NdArray instances (or their underlying DataBuffer) for equality check, so it is now possible to do something like:\nIntNdArray array = NdArrays.ofInts(2).setInt(10, 0).setInt(20, 1);\nassertEquals(array, StdArrays.ndCopyOf(new int[]{10, 20}));\nThe comparison algorithms are not optimal for performances but it should be ok for a first revision and we can improve it later (e.g. by the use of native memcmp whenever possible).\nStill, I added a DataStorageVisitor that allows us to optimize a few paths for data copy and comparison (e.g. by invoking direction java.nio methods whenever possible).\nFinally, there's been a few method renaming in tensorflow-tools as well, for consistency, and I have dropped the StaticApi helper class, which was duplicating code without providing real benefits.\nCC: @Craigacp", "createdAt": "2020-03-10T13:24:00Z", "url": "https://github.com/tensorflow/java/pull/31", "merged": true, "mergeCommit": {"oid": "63ac9c65247ef54d807dddfd78c71a0ae7d24f63"}, "closed": true, "closedAt": "2020-03-18T00:47:09Z", "author": {"login": "karllessard"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcMSSLNgH2gAyMzg2MTMwNjE1Ojg4ZTFiMDE5YWNjODRjMjM2ZTlhODMzNTkwY2YzNTc1MzIzMzU0MGI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcOsaJKABqjMxMzk1NDgzNzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "88e1b019acc84c236e9a833590cf35753233540b", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/88e1b019acc84c236e9a833590cf35753233540b", "committedDate": "2020-03-10T13:11:19Z", "message": "NdArrays and DataBuffers equality"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NDYwMTYw", "url": "https://github.com/tensorflow/java/pull/31#pullrequestreview-374460160", "createdAt": "2020-03-13T16:53:01Z", "commit": {"oid": "88e1b019acc84c236e9a833590cf35753233540b"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNjo1MzowMVrOF2LOTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzoxMzo0NVrOF2L5gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MTMxMA==", "bodyText": "I'd refer to this as providing a view on the same memory, which is the terminology that java.nio.ByteBuffer uses for the equivalent operation.", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392351310", "createdAt": "2020-03-13T16:53:01Z", "author": {"login": "Craigacp"}, "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/ByteDataBuffer.java", "diffHunk": "@@ -132,6 +132,72 @@ default ByteDataBuffer write(byte[] src) {\n    */\n   ByteDataBuffer write(byte[] src, int offset, int length);\n \n+  /**\n+   * Return this byte buffer as a buffer of ints.\n+   *\n+   * <p>The returned buffer shares the same memory as the original one, meaning that changing a value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e1b019acc84c236e9a833590cf35753233540b"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MjAyOA==", "bodyText": "type -> types", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392352028", "createdAt": "2020-03-13T16:54:19Z", "author": {"login": "Craigacp"}, "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBuffer.java", "diffHunk": "@@ -223,4 +223,37 @@\n    * @throws IllegalArgumentException if size value do not pass validation checks\n    */\n   DataBuffer<T> narrow(long size);\n+\n+  /**\n+   * Visits the backing storage of this buffer.\n+   *\n+   * <p>The buffer implementation is responsible of passing back a reference to the actual data\n+   * storage to the provided visitor. The visitor does not have to handle all possible type of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e1b019acc84c236e9a833590cf35753233540b"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1MzMzMw==", "bodyText": "Does this equals also depend on the type of the buffer? i.e. if I do byteDataBuffer.equals(byteDataBuffer.asInts()) what happens? Either way is fine, but it should be documented.", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392353333", "createdAt": "2020-03-13T16:56:29Z", "author": {"login": "Craigacp"}, "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataBuffer.java", "diffHunk": "@@ -223,4 +223,37 @@\n    * @throws IllegalArgumentException if size value do not pass validation checks\n    */\n   DataBuffer<T> narrow(long size);\n+\n+  /**\n+   * Visits the backing storage of this buffer.\n+   *\n+   * <p>The buffer implementation is responsible of passing back a reference to the actual data\n+   * storage to the provided visitor. The visitor does not have to handle all possible type of\n+   * data storage and can override only methods for storage it is actually interested in. For any\n+   * other type of storage, the call will fallback to {@link DataStorageVisitor#otherwise()} so the\n+   * visitor can handle it as a general case.\n+   *\n+   * @param visitor visits the data storage of this buffer\n+   * @param <R> type of value returned by the visitor\n+   * @return the same value returned by the visitor\n+   */\n+  default <R> R accept(DataStorageVisitor<R> visitor) {\n+    return visitor.otherwise();\n+  }\n+\n+  /**\n+   * Checks equality between data buffers.\n+   *\n+   * <p>A data buffer is equal to another object if this object is another {@link DataBuffer} of the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e1b019acc84c236e9a833590cf35753233540b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1NTA0MQ==", "bodyText": "Maybe this could be called defaultVisit or something more indicative? What kinds of behaviour would it perform?", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392355041", "createdAt": "2020-03-13T16:59:35Z", "author": {"login": "Craigacp"}, "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/DataStorageVisitor.java", "diffHunk": "@@ -0,0 +1,147 @@\n+package org.tensorflow.tools.buffer;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n+import java.util.BitSet;\n+\n+/**\n+ * Visit the backing storage of {@link DataBuffer} instances.\n+ *\n+ * @param <R> value type returned by the visitor\n+ */\n+public interface DataStorageVisitor<R> {\n+\n+  /**\n+   * Visit the {@link ByteBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(ByteBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the {@link ShortBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(ShortBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the {@link IntBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(IntBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the {@link LongBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(LongBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the {@link FloatBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(FloatBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the {@link DoubleBuffer} backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param buffer underlying buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(DoubleBuffer buffer) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the boolean array backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param array underlying array\n+   * @param offset offset of the buffer within the array\n+   * @param length length of the buffer within the array\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(boolean[] array, int offset, int length) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the bit set backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param bitSet underlying bit set\n+   * @param offset offset of the buffer within the bit set\n+   * @param numBits number of bits used to represent the buffer within the bit set\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(BitSet bitSet, int offset, long numBits) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the object array backing a given instance of a {@link DataBuffer}\n+   *\n+   * @param array underlying array\n+   * @param offset offset of the buffer within the array\n+   * @param length length of the buffer within the array\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(Object[] array, int offset, int length) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Visit the raw memory segment of a given instance of a {@link DataBuffer}\n+   *\n+   * @param address native address of the buffer\n+   * @param length length of the buffer\n+   * @param scale number of bytes required to store a single value of this buffer\n+   * @return any value\n+   * @see DataBuffer#accept(DataStorageVisitor)\n+   */\n+  default R visit(long address, long length, long scale) {\n+    return otherwise();\n+  }\n+\n+  /**\n+   * Fallback method called if the visitor implementation does not support the type of backing storage\n+   * for a given {@link DataBuffer}\n+   *\n+   * <p>The implementor of this interface must override the {@code visit} methods for type of storage\n+   * it supports. If {@link DataBuffer#accept(DataStorageVisitor)} is called on a buffer\n+   * using a different type of storage, the invocation will fallback to this method.\n+   *\n+   * @return any value\n+   */\n+  R otherwise();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e1b019acc84c236e9a833590cf35753233540b"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1NzA4OQ==", "bodyText": "Can we stash these lambdas in static variables?", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392357089", "createdAt": "2020-03-13T17:03:24Z", "author": {"login": "Craigacp"}, "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/AbstractDataBuffer.java", "diffHunk": "@@ -38,9 +41,145 @@\n     return this;\n   }\n \n-  protected void slowCopyTo(DataBuffer<T> dst, long size) {\n-    for (long idx = 0; idx < size; ++idx) {\n+  @Override\n+  public DataBuffer<T> copyTo(DataBuffer<T> dst, long size) {\n+    Validator.copyToArgs(this, dst, size);\n+    for (long idx = 0L; idx < size; ++idx) {\n+      dst.setObject(getObject(idx), idx);\n+    }\n+    return this;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    // This hash code computation is generic to all types of data buffers and accurate but not optimized\n+    // for performances, it needs to be improved if there is a present use case for such hash codes.\n+    return slowHashCode();\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (this == obj) {\n+      return true;\n+    }\n+    if (!(obj instanceof DataBuffer)) {\n+      return false;\n+    }\n+    return slowEquals((DataBuffer<?>)obj);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected <U extends DataBuffer<T>> U slowCopyTo(DataBuffer<T> dst, long size) {\n+    Validator.copyToArgs(this, dst, size);\n+    for (long idx = 0L; idx < size; ++idx) {\n       dst.setObject(getObject(idx), idx);\n     }\n+    return (U)this;\n+  }\n+\n+  protected int slowHashCode() {\n+    final int prime = 31;\n+    int result = 1;\n+\n+    // First check from the first non-null element if we are dealing with a buffer of arrays\n+    long idx = 0L;\n+    for (; idx < size(); ++idx) {\n+      T o = getObject(idx);\n+      if (o != null) {\n+        if (o.getClass().isArray()) {\n+          result = prime * result + arrayHashCode(idx, o.getClass()); // compute hash codes based on array elements\n+          return result;\n+        }\n+        result = prime * result + o.hashCode();\n+        break;  // continue hash code computation without array type check\n+      }\n+      result = prime * result;\n+    }\n+    while (++idx < size()) {\n+      result = prime * result + Objects.hashCode(getObject(idx));\n+    }\n+    return result;\n+  }\n+\n+  protected boolean slowEquals(DataBuffer<?> other) {\n+    if (other.size() != size()) {\n+      return false;\n+    }\n+    long idx = 0L;\n+    for (; idx < size(); ++idx) {\n+      Object thisObject = getObject(idx);\n+      if (thisObject != null) {\n+        if (thisObject.getClass().isArray()) {\n+          return arrayEquals(idx, thisObject.getClass(), other);\n+        }\n+        if (!Objects.equals(other.getObject(idx), thisObject)) {\n+          return false;\n+        }\n+        break;  // continue equality comparison without array type check\n+      }\n+      if (other.getObject(idx) != null) {\n+        return false;\n+      }\n+    }\n+    while (++idx < size()) {\n+      if (!Objects.equals(other.getObject(idx), getObject(idx))) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  private int arrayHashCode(long startIdx, Class<?> arrayClass) {\n+    Function<Long, Integer> hashCoder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e1b019acc84c236e9a833590cf35753233540b"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM1ODU0Ng==", "bodyText": "Might be best to hoist the cast out of the for loop in case the JIT doesn't figure it out. Pity we can't use the pattern matching from JDK 14 yet.", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392358546", "createdAt": "2020-03-13T17:06:05Z", "author": {"login": "Craigacp"}, "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/adapter/DoubleDataBufferAdapter.java", "diffHunk": "@@ -56,16 +56,48 @@ public DoubleDataBuffer write(double[] src, int offset, int length) {\n     return this;\n   }\n \n+  @Override\n+  public DoubleDataBuffer copyTo(DataBuffer<Double> dst, long size) {\n+    Validator.copyToArgs(this, dst, size);\n+    if (dst instanceof DoubleDataBuffer) {\n+      for (long idx = 0L; idx < size; ++idx) {\n+        ((DoubleDataBuffer)dst).setDouble(getDouble(idx), idx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e1b019acc84c236e9a833590cf35753233540b"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM2MjM2OA==", "bodyText": "This should probably note \"the same shape, type and the elements are equal and in the same order\".", "url": "https://github.com/tensorflow/java/pull/31#discussion_r392362368", "createdAt": "2020-03-13T17:13:45Z", "author": {"login": "Craigacp"}, "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/NdArray.java", "diffHunk": "@@ -293,4 +291,20 @@ default long size() {\n    * @see DataBuffer#size()\n    */\n   NdArray<T> write(DataBuffer<T> src);\n+\n+  /**\n+   * Checks equality between n-dimensional arrays.\n+   *\n+   * <p>An array is equal to another object if this object is another {@link NdArray} of the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e1b019acc84c236e9a833590cf35753233540b"}, "originalPosition": 70}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "929acaf56f551bd9500b2b592a893139eb923aed", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/929acaf56f551bd9500b2b592a893139eb923aed", "committedDate": "2020-03-15T14:52:08Z", "message": "Improve Javadoc and fix few bugs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc1MzA2Njcz", "url": "https://github.com/tensorflow/java/pull/31#pullrequestreview-375306673", "createdAt": "2020-03-16T15:07:06Z", "commit": {"oid": "929acaf56f551bd9500b2b592a893139eb923aed"}, "state": "DISMISSED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNTowNzowNlrOF24l_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNTowNzowNlrOF24l_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzA5NDY1Mg==", "bodyText": "This is disappointing, is there no way to make equals and hashCode just look at the view without having to actually perform an operation on them?", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393094652", "createdAt": "2020-03-16T15:07:06Z", "author": {"login": "Craigacp"}, "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/impl/dense/AbstractDenseNdArray.java", "diffHunk": "@@ -110,6 +113,18 @@ protected AbstractDenseNdArray(DimensionalSpace dimensions) {\n \n   abstract protected DataBuffer<T> buffer();\n \n+  protected DataBuffer<T> trimBuffer() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "929acaf56f551bd9500b2b592a893139eb923aed"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc2MjkyNDgy", "url": "https://github.com/tensorflow/java/pull/31#pullrequestreview-376292482", "createdAt": "2020-03-17T18:19:24Z", "commit": {"oid": "656d771863e75d929698e4be9a0c2a8edf256342"}, "state": "DISMISSED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxODoyMTozMVrOF3oooA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QxODoyMTozMVrOF3oooA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mzg4MTc2MA==", "bodyText": "Looks like some unnecessary imports got dragged in.", "url": "https://github.com/tensorflow/java/pull/31#discussion_r393881760", "createdAt": "2020-03-17T18:21:31Z", "author": {"login": "Craigacp"}, "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/buffer/impl/nio/FloatNioDataBuffer.java", "diffHunk": "@@ -17,9 +17,11 @@\n \n package org.tensorflow.tools.buffer.impl.nio;\n \n+import java.nio.DoubleBuffer;\n import java.nio.FloatBuffer;\n import org.tensorflow.tools.buffer.DataBuffer;\n import org.tensorflow.tools.buffer.DataStorageVisitor;\n+import org.tensorflow.tools.buffer.DoubleDataBuffer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "656d771863e75d929698e4be9a0c2a8edf256342"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf2067530031d08c9488e7d1b4d8ae25b405498e", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/bf2067530031d08c9488e7d1b4d8ae25b405498e", "committedDate": "2020-03-18T00:45:07Z", "message": "Trim array buffers when slicing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "656d771863e75d929698e4be9a0c2a8edf256342", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/656d771863e75d929698e4be9a0c2a8edf256342", "committedDate": "2020-03-17T14:10:02Z", "message": "Trim array buffers when slicing"}, "afterCommit": {"oid": "bf2067530031d08c9488e7d1b4d8ae25b405498e", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/bf2067530031d08c9488e7d1b4d8ae25b405498e", "committedDate": "2020-03-18T00:45:07Z", "message": "Trim array buffers when slicing"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3437, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}