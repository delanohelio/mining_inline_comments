{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwNzM5NzM0", "number": 160, "title": "[Type Refactor] Merge TType and Tensor instances as a single entity", "bodyText": "This PR introduces some breaking changes related to Tensor and their relationship with the NdArray data structure, in an effort of simplification and standardization.\nInstances of TType (e.g. TFloat32, TInt32, etc.) now implements directly Tensor, which has been converted to a non-parameterized interface. This allows direct access to the tensor n-dimensional data space from a tensor instance, without the need to dereference to a second object by calling Tensor.data().\n// Before\nTensor<TFloat32> t = TFloat32.vectorOf(0, 1, 2, 3);\nTFloat32 data = t.data();\ndata.getFloat(1); // 1.0f\n\n// Now\nTFloat32 t = TFloat32.vectorOf(0, 1, 2, 3);\nt.getFloat(1); // 1.0f\nAn instance of TType can now be passed directly to any method accepting a Tensor in input, e.g. Session.Runner.feed. In addition, it is now possible to cast directly a tensor of an unknown type using standard Java explicit or implicit type casting, instead of the custom method expect.\n// Before\nTensor<TFloat32> t = session.run().get(0).expect(TFloat32.DTYPE);\n\n// Now\nTFloat32 = (TFloat32)s.run().get(0);\nIn a nutshell, important and/or breaking changes are:\n\nConvert Tensor from a parameterized class to an non-parameterized interface\nImplement directly Tensor from TType implementations\nAdd a RawTensor implementation of Tensor that takes care, among other things, of wrapping the native handle of the tensor in a protected way\nDrop now obsolete Tensor.data(), Tensor.expect() and Operand.data() methods\ntf.constant(TType) has to be renamed to tf.capture(TType) to avoid conflict with other Constant endpoints (left untouched).\n\nIn a next PR, the use of tf.capture will also become obsolete by implementing directly Operand from tensors.\n\n\n\nCC\\ @deansher , @Craigacp , @wmeddie", "createdAt": "2020-12-02T04:37:13Z", "url": "https://github.com/tensorflow/java/pull/160", "merged": true, "mergeCommit": {"oid": "98979f08d7844119f26292c8f3260ea72edf7626"}, "closed": true, "closedAt": "2020-12-17T00:57:27Z", "author": {"login": "karllessard"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdi4iy6gFqTU0NDA3NTExNg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdm2CeWAFqTU1NDEwODgzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MDc1MTE2", "url": "https://github.com/tensorflow/java/pull/160#pullrequestreview-544075116", "createdAt": "2020-12-03T15:27:46Z", "commit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxNToyNzo0NlrOH-h-MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMzowNjoxNFrOH_QFvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDM1Mg==", "bodyText": "Unless it would sometimes be correct to use a native handle from a different tensor than tensor, just pass in tensor and let the apply method obtain nativeHandle from it.", "url": "https://github.com/tensorflow/java/pull/160#discussion_r535330352", "createdAt": "2020-12-03T15:27:46Z", "author": {"login": "deansher"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/DataType.java", "diffHunk": "@@ -35,13 +34,13 @@\n   public interface TensorMapper<T> {\n \n     /**\n-     * Maps tensor memory to a data structure for manipulating elements of this type.\n+     * Maps the tensor memory to a n-dimensional typed data space.\n      *\n-     * @param nativeTensor pointer to the native tensor\n-     * @param shape the shape of the tensor\n-     * @return data structure of elements of this type\n+     * @param tensor the tensor to map in its raw nature\n+     * @param nativeHandle native handle of the tensor\n+     * @return a typed tensor of type {@code T}\n      */\n-    T apply(TF_Tensor nativeTensor, Shape shape);\n+    T apply(RawTensor tensor, TF_Tensor nativeHandle);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM0MDIxMA==", "bodyText": "This call to asTypedTensor is semantically strange: it does significant extra work to \"upgrade\" the tensor in a way not required by resolveTensorHandle's Tensor return type.\nI don't understand the overall flow well enough yet to know whether there's a runtime requirement to call asTypedTensor here. If so, return TType. If not, omit the call.", "url": "https://github.com/tensorflow/java/pull/160#discussion_r535340210", "createdAt": "2020-12-03T15:36:45Z", "author": {"login": "deansher"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperation.java", "diffHunk": "@@ -156,13 +156,13 @@ private static void requireTensorHandle(TFE_TensorHandle handle) {\n     }\n   }\n \n-  private static Tensor<?> resolveTensorHandle(TFE_TensorHandle handle, EagerSession session) {\n+  private static Tensor resolveTensorHandle(TFE_TensorHandle handle, EagerSession session) {\n     requireTensorHandle(handle);\n     try (PointerScope scope = new PointerScope()) {\n       TF_Status status = TF_Status.newStatus();\n       TF_Tensor tensor = TFE_TensorHandleResolve(handle, status).withDeallocator();\n       status.throwExceptionIfNotOK();\n-      return Tensor.fromHandle(tensor, session);\n+      return RawTensor.fromHandle(tensor, session).asTypedTensor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA3MDY1MQ==", "bodyText": "{@link org.tensorflow.RawTensor}", "url": "https://github.com/tensorflow/java/pull/160#discussion_r536070651", "createdAt": "2020-12-04T12:39:15Z", "author": {"login": "deansher"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/types/family/TType.java", "diffHunk": "@@ -17,21 +17,40 @@\n \n package org.tensorflow.types.family;\n \n+import org.tensorflow.Tensor;\n+\n /**\n- * Marker interface for all tensor types.\n+ * Common interface for all typed tensors.\n  *\n- * <p>Tensor types are carried as a generic parameter of the {@link org.tensorflow.Tensor Tensor}\n- * class bound by the {@code TType} interface. This generic parameter ensure type-compatibility\n- * between operands of a computation at compile-time. For example:\n+ * <p>Typed tensors wraps a {@link RawTensor} by mapping their native memory to a n-dimensional", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA3MzQ5Ng==", "bodyText": "TType is documented as wrapping a RawTensor and as adding new capability (\"mapping their native memory to a n-dimensional...\"), but neither shows up in this interface.\nIf every Tensor wraps a RawTensor, then perhaps that's not something TType does?\nPerhaps it would be cleaner to have TType indicate its additional capability by itself extending NdArray, rather than leaving that to its subinterfaces? This would require that TType carry a type parameter representing its element type. Perhaps that would prove cumbersome, but it feels usefully more expressive to me. (IDEA is happy to help me browse the 2,468 uses of TType to figure this out.) So:\npublic interface TType<T> extends Tensor, NdArray<T> {\n  . . .\n}\n\npublic interface TNumber<T extends Number> extends TType<T> {}\n\npublic interface TInt32 extends IntNdArray, TNumber<Integer> {\n  . . .\n}", "url": "https://github.com/tensorflow/java/pull/160#discussion_r536073496", "createdAt": "2020-12-04T12:44:21Z", "author": {"login": "deansher"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/types/family/TType.java", "diffHunk": "@@ -17,21 +17,40 @@\n \n package org.tensorflow.types.family;\n \n+import org.tensorflow.Tensor;\n+\n /**\n- * Marker interface for all tensor types.\n+ * Common interface for all typed tensors.\n  *\n- * <p>Tensor types are carried as a generic parameter of the {@link org.tensorflow.Tensor Tensor}\n- * class bound by the {@code TType} interface. This generic parameter ensure type-compatibility\n- * between operands of a computation at compile-time. For example:\n+ * <p>Typed tensors wraps a {@link RawTensor} by mapping their native memory to a n-dimensional\n+ * data space allowing direct I/O access from the JVM.</p>\n  *\n- * <pre>{@code\n- * Tensor<TFloat32> tensor1 = TFloat32.ofShape(2, 3, 2);\n- * Tensor<TFloat32> tensor2 = TFloat32.ofShape(2, 3, 2);\n- * Tensor<TInt32> tensor3 = TInt32.ofShape(2, 3, 2);\n+ * <p>Subinterfaces of {@code TType} are propagated as a generic parameter to various entities of\n+ * TensorFlow to identify the type of the tensor they carry. For example, a\n+ * {@link org.tensorflow.Operand Operand<TFloat32>} is an operand which outputs is a 32-bit floating\n+ * point tensor. This parameter ensure type-compatibility between operands of a computation at\n+ * compile-time. For example:\n  *\n+ * <pre>{@code\n  * Ops tf = Ops.create();\n- * tf.math.add(tf.constant(tensor1), tf.constant(tensor2));  // OK\n- * tf.math.add(tf.constant(tensor1), tf.constant(tensor3));  // Compilation failure\n+ *\n+ * Constant<TFloat32> c1 = tf.array(2.0f, 3.0f, 2.0f);\n+ * Constant<TFloat32> c2 = tf.array(1.0f, 2.0f, 3.0f);\n+ * Constant<TInt32> c3 = tf.array(2, 3, 2);\n+ *\n+ * tf.math.add(c1, c2);  // OK\n+ * tf.math.add(c1, c3);  // Compilation failure\n  * }</pre>\n  */\n-public interface TType {}\n+public interface TType extends Tensor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA4NTk0OA==", "bodyText": "Seems uncomfortable that both this method and asRawTensor, below, provide pathways for obtaining the DataType, but via completely different mechanisms. It would be very bad if a tbool.dataType() was different than tbool.asRawTensor().dataType().\nPerhaps have the TBoolImpl constructor throw IllegalStateException if rawTensor.dataType() != TBool.DTYPE, but then for efficiency leave the discomfort as it is?", "url": "https://github.com/tensorflow/java/pull/160#discussion_r536085948", "createdAt": "2020-12-04T13:06:14Z", "author": {"login": "deansher"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/types/TBool.java", "diffHunk": "@@ -111,19 +111,33 @@\n    * @return the new tensor\n    * @throws TensorFlowException if the tensor cannot be allocated or initialized\n    */\n-  static Tensor<TBool> tensorOf(Shape shape, Consumer<TBool> dataInit) {\n+  static TBool tensorOf(Shape shape, Consumer<TBool> dataInit) {\n     return Tensor.of(DTYPE, shape, dataInit);\n   }\n }\n \n /** Hidden implementation of a {@code TBool} */\n class TBoolImpl extends BooleanDenseNdArray implements TBool {\n \n-  static TBool mapTensor(TF_Tensor nativeTensor, Shape shape) {\n-    return new TBoolImpl(TensorBuffers.toBooleans(nativeTensor), shape);\n+  @Override\n+  public DataType<?> dataType() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NzcyODE2", "url": "https://github.com/tensorflow/java/pull/160#pullrequestreview-547772816", "createdAt": "2020-12-09T01:42:37Z", "commit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMTo0MjozN1rOIB-Tpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMzowMToyNVrOICAC5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MDMyNg==", "bodyText": "Why'd this go away in this PR?", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538940326", "createdAt": "2020-12-09T01:42:37Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/DebuggingOps.java", "diffHunk": "@@ -1,50 +0,0 @@\n-// Copyright 2020 The TensorFlow Authors. All Rights Reserved.\n-//\n-// Licensed under the Apache License, Version 2.0 (the \"License\");\n-// you may not use this file except in compliance with the License.\n-// You may obtain a copy of the License at\n-//\n-//     http://www.apache.org/licenses/LICENSE-2.0\n-//\n-// Unless required by applicable law or agreed to in writing, software\n-// distributed under the License is distributed on an \"AS IS\" BASIS,\n-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-// See the License for the specific language governing permissions and\n-// limitations under the License.\n-// ==============================================================================\n-//\n-// This class has been generated, DO NOT EDIT!\n-//\n-package org.tensorflow.op;\n-\n-import org.tensorflow.Operand;\n-import org.tensorflow.op.debugging.CheckNumerics;\n-import org.tensorflow.types.family.TNumber;\n-\n-/**\n- * An API for building {@code debugging} operations as {@link Op Op}s\n- *\n- * @see {@link Ops}\n- */\n-public final class DebuggingOps {\n-  private final Scope scope;\n-\n-  DebuggingOps(Scope scope) {\n-    this.scope = scope;\n-  }\n-\n-  /**\n-   * Checks a tensor for NaN and Inf values.\n-   *  <p>\n-   *  When run, reports an `InvalidArgument` error if `tensor` has any values\n-   *  that are not a number (NaN) or infinity (Inf). Otherwise, passes `tensor` as-is.\n-   *\n-   * @param <T> data type for {@code output()} output\n-   * @param tensor\n-   * @param message Prefix of the error message.\n-   * @return a new instance of CheckNumerics\n-   */\n-  public <T extends TNumber> CheckNumerics<T> checkNumerics(Operand<T> tensor, String message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MDYwMA==", "bodyText": "I guess I should do another round on making this deterministic as it's really annoying having it move things in PRs.", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538940600", "createdAt": "2020-12-09T01:43:27Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/Ops.java", "diffHunk": "@@ -347,10 +346,10 @@\n \n   public final SignalOps signal;\n \n-  public final TrainOps train;\n-\n   public final QuantizationOps quantization;\n \n+  public final TrainOps train;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk0MTEyNA==", "bodyText": "s/capture/copy/ or immutableCopy ? I don't particularly like the name capture here as it doesn't actually change the state of the tensor argument.", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538941124", "createdAt": "2020-12-09T01:44:54Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/Ops.java", "diffHunk": "@@ -1071,6 +1070,17 @@ public Batch batch(Iterable<Operand<?>> inTensors, Long numBatchThreads, Long ma\n     return Bucketize.create(scope, input, boundaries);\n   }\n \n+  /**\n+   * Capture a {@code tensor} by making a constant copy of it.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param tensor a Tensor holding the constant value\n+   * @return a constant of the same data type as `tensor`\n+   */\n+  public <T extends TType> Constant<T> capture(T tensor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1NTQ1Mg==", "bodyText": "We could add a default method that accepts a RawTensor and unpacks it into the RawTensor and the TF_Tensor and calls apply? I'm a little uncomfortable with the idea that we can't validate that they came from the same tensor (because we could end up with some weird bugs). At the very least the doc needs to note that the arguments are from the same object.", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538955452", "createdAt": "2020-12-09T02:24:13Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/DataType.java", "diffHunk": "@@ -35,13 +34,13 @@\n   public interface TensorMapper<T> {\n \n     /**\n-     * Maps tensor memory to a data structure for manipulating elements of this type.\n+     * Maps the tensor memory to a n-dimensional typed data space.\n      *\n-     * @param nativeTensor pointer to the native tensor\n-     * @param shape the shape of the tensor\n-     * @return data structure of elements of this type\n+     * @param tensor the tensor to map in its raw nature\n+     * @param nativeHandle native handle of the tensor\n+     * @return a typed tensor of type {@code T}\n      */\n-    T apply(TF_Tensor nativeTensor, Shape shape);\n+    T apply(RawTensor tensor, TF_Tensor nativeHandle);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTMzMDM1Mg=="}, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1Njg0NQ==", "bodyText": "\"implicitly via try-with-resources\"", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538956845", "createdAt": "2020-12-09T02:28:05Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/RawTensor.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+package org.tensorflow;\n+\n+import static org.tensorflow.internal.c_api.global.tensorflow.TF_Dim;\n+import static org.tensorflow.internal.c_api.global.tensorflow.TF_NumDims;\n+import static org.tensorflow.internal.c_api.global.tensorflow.TF_TensorByteSize;\n+import static org.tensorflow.internal.c_api.global.tensorflow.TF_TensorType;\n+\n+import org.bytedeco.javacpp.PointerScope;\n+import org.tensorflow.internal.buffer.TensorBuffers;\n+import org.tensorflow.internal.c_api.TF_Tensor;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.ndarray.Shaped;\n+import org.tensorflow.ndarray.buffer.ByteDataBuffer;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * A tensor which memory has not been mapped.\n+ *\n+ * <p>A raw tensor is a minimalist representation of a tensor allocated in native memory by the\n+ * TensorFlow runtime library and it controls its lifetime within the current process. The data\n+ * is represented by a flat {@link ByteDataBuffer buffer of bytes}, until it is mapped in a\n+ * n-dimensional typed space by a {@link TType typed tensor}.</p>\n+ *\n+ * <p>Instances of a RawTensor are <b>not</b> thread-safe and their resource must be released\n+ * by calling {@link #close()} explicitly or implicitly (try-with-resources).</p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1NzAxNw==", "bodyText": "This is a little confusing. Does it mean \"A tensor which is resident on the native heap rather than the Java heap\"?", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538957017", "createdAt": "2020-12-09T02:28:38Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/RawTensor.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+package org.tensorflow;\n+\n+import static org.tensorflow.internal.c_api.global.tensorflow.TF_Dim;\n+import static org.tensorflow.internal.c_api.global.tensorflow.TF_NumDims;\n+import static org.tensorflow.internal.c_api.global.tensorflow.TF_TensorByteSize;\n+import static org.tensorflow.internal.c_api.global.tensorflow.TF_TensorType;\n+\n+import org.bytedeco.javacpp.PointerScope;\n+import org.tensorflow.internal.buffer.TensorBuffers;\n+import org.tensorflow.internal.c_api.TF_Tensor;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.ndarray.Shaped;\n+import org.tensorflow.ndarray.buffer.ByteDataBuffer;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * A tensor which memory has not been mapped.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MDY2OA==", "bodyText": "Shouldn't this line be outside the <pre>?", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538960668", "createdAt": "2020-12-09T02:38:33Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Tensor.java", "diffHunk": "@@ -43,44 +46,34 @@\n  * try (Tensor t = Tensor.of(...)) {\n  *   doSomethingWith(t);\n  * }\n+ *\n+ * <p>Instances of a Tensor are <b>not</b> thread-safe.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MTM5Mw==", "bodyText": "Why not use tensor.asTypedTensor() here?", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538961393", "createdAt": "2020-12-09T02:40:39Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Tensor.java", "diffHunk": "@@ -92,19 +85,13 @@\n    *                                  store the tensor data\n    * @throws IllegalStateException if tensor failed to be allocated\n    */\n-  public static <T extends TType> Tensor<T> of(DataType<T> dtype, Shape shape, long size) {\n-    // Minimum requirements for datatypes of variable length cannot be verified in a relevant way so\n-    // we only validate them for fixed length datatypes\n-    if (!dtype.isVariableLength() && shape.size() * dtype.byteSize() > size) {\n-      throw new IllegalArgumentException(\"Tensor size is not large enough to contain all scalar values\");\n-    }\n-    Tensor<T> t = new Tensor<>(dtype, shape);\n-    TF_Tensor nativeHandle = allocate(t.dtype.nativeCode(), shape.asArray(), size);\n-    try (PointerScope scope = new PointerScope()) {\n-        scope.attach(nativeHandle);\n-        t.tensorHandle = nativeHandle;\n-        t.tensorScope = scope.extend();\n-        return t;\n+  static <T extends TType> T of(DataType<T> dtype, Shape shape, long size) {\n+    RawTensor tensor = RawTensor.allocate(dtype, shape, size);\n+    try {\n+      return dtype.map(tensor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MTcyNg==", "bodyText": "\"such as a\" or \"such as the\" (not sure if there could be more than one lookup table in a String tensor).", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538961726", "createdAt": "2020-12-09T02:41:36Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Tensor.java", "diffHunk": "@@ -144,7 +130,7 @@\n    * size for the tensor is explicitly set instead of being computed from the datatype and shape.\n    *\n    * <p>This could be useful for tensor types that stores data but also metadata in the tensor memory,\n-   * such as {@link org.tensorflow.types.TString TString}.\n+   * such as lookup table in a tensor of strings.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MjUwOA==", "bodyText": "Why does this catch Throwable? If an Error has been thrown then the JVM is going down anyway, and we might not be able to execute tensor.close(). Especially as the other of method catches Exception.", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538962508", "createdAt": "2020-12-09T02:43:48Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Tensor.java", "diffHunk": "@@ -157,11 +143,10 @@\n    *                                  store the tensor data\n    * @throws IllegalStateException if tensor failed to be allocated\n    */\n-  public static <T extends TType> Tensor<T> of(DataType<T> dtype, Shape shape, long size,\n-      Consumer<T> dataInitializer) {\n-    Tensor<T> tensor = of(dtype, shape, size);\n+  static <T extends TType> T of(DataType<T> dtype, Shape shape, long size, Consumer<T> dataInitializer) {\n+    T tensor = of(dtype, shape, size);\n     try {\n-      dataInitializer.accept(tensor.data());\n+      dataInitializer.accept(tensor);\n       return tensor;\n     } catch (Throwable t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MzM2MA==", "bodyText": "If we make this DataType<? extends TType> can we concretely type the subclass methods?", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538963360", "createdAt": "2020-12-09T02:46:22Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Tensor.java", "diffHunk": "@@ -182,203 +167,39 @@\n    * @throws IllegalArgumentException if {@code rawData} is not large enough to contain the tensor data\n    * @throws IllegalStateException if tensor failed to be allocated with the given parameters\n    */\n-  public static <T extends TType> Tensor<T> of(DataType<T> dtype, Shape shape, ByteDataBuffer rawData) {\n-    Tensor<T> t = of(dtype, shape, rawData.size());\n-    rawData.copyTo(TensorBuffers.toBytes(t.nativeHandle()), rawData.size());\n-    return t;\n-  }\n-\n-  /**\n-   * Returns this Tensor object with the type {@code Tensor<U>}. This method is useful when given a\n-   * value of type {@code Tensor<?>}.\n-   *\n-   * @param dt any supported tensor data type\n-   * @param <U> a tensor type\n-   * @return a tensor of the requested data type\n-   * @throws IllegalArgumentException if the actual data type of this object does not match the type\n-   *     {@code U}.\n-   */\n-  @SuppressWarnings(\"unchecked\")\n-  public <U extends TType> Tensor<U> expect(DataType<U> dt) {\n-    if (!dt.equals(this.dtype)) {\n-      throw new IllegalArgumentException(\n-          \"Cannot cast from tensor of \" + dtype + \" to tensor of \" + dt);\n-    }\n-    return ((Tensor<U>) this);\n+  static <T extends TType> T of(DataType<T> dtype, Shape shape, ByteDataBuffer rawData) {\n+    return of(dtype, shape, rawData.size(), t -> rawData.copyTo(t.asRawTensor().data(), rawData.size()));\n   }\n \n   /**\n-   * Release resources associated with the Tensor.\n-   *\n-   * <p><b>WARNING:</b>This must be invoked for all tensors that were not been produced by an eager\n-   * operation or memory will be leaked.\n-   *\n-   * <p>The Tensor object is no longer usable after {@code close} returns.\n+   * Returns the {@link DataType} of elements stored in the tensor.\n    */\n-  @Override\n-  public void close() {\n-    tensorScope.close();\n-  }\n-\n-  /** Returns the {@link DataType} of elements stored in the Tensor. */\n-  public DataType<T> dataType() {\n-    return dtype;\n-  }\n-\n-  /** Returns the size, in bytes, of the tensor data. */\n-  public long numBytes() {\n-    if (numBytes == null) {\n-      numBytes = TF_TensorByteSize(tensorHandle);\n-    }\n-    return numBytes;\n-  }\n-\n-  /** Returns the shape of this tensor. */\n-  @Override\n-  public Shape shape() {\n-    return shape;\n-  }\n+  DataType<?> dataType();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NDk4Mw==", "bodyText": "Can this be DataType<TBfloat16> if we type the super method appropriately?", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538964983", "createdAt": "2020-12-09T02:50:58Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/types/TBfloat16.java", "diffHunk": "@@ -119,20 +120,33 @@\n    * @return the new tensor\n    * @throws TensorFlowException if the tensor cannot be allocated or initialized\n    */\n-  static Tensor<TBfloat16> tensorOf(Shape shape, Consumer<TBfloat16> dataInit) {\n+  static TBfloat16 tensorOf(Shape shape, Consumer<TBfloat16> dataInit) {\n     return Tensor.of(DTYPE, shape, dataInit);\n   }\n }\n \n /** Hidden implementation of a {@code TBfloat16} */\n class TBfloat16Impl extends FloatDenseNdArray implements TBfloat16 {\n \n-  static TBfloat16 mapTensor(TF_Tensor nativeTensor, Shape shape) {\n-    return new TBfloat16Impl(\n-        DataLayouts.BFLOAT16.applyTo(TensorBuffers.toShorts(nativeTensor)), shape);\n+  @Override\n+  public DataType<?> dataType() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NjY4Nw==", "bodyText": "s/wraps/wrap/", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538966687", "createdAt": "2020-12-09T02:55:37Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/types/family/TType.java", "diffHunk": "@@ -17,21 +17,40 @@\n \n package org.tensorflow.types.family;\n \n+import org.tensorflow.Tensor;\n+\n /**\n- * Marker interface for all tensor types.\n+ * Common interface for all typed tensors.\n  *\n- * <p>Tensor types are carried as a generic parameter of the {@link org.tensorflow.Tensor Tensor}\n- * class bound by the {@code TType} interface. This generic parameter ensure type-compatibility\n- * between operands of a computation at compile-time. For example:\n+ * <p>Typed tensors wraps a {@link RawTensor} by mapping their native memory to a n-dimensional", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA3MDY1MQ=="}, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2NzAzOA==", "bodyText": "s/outputs is/outputs/", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538967038", "createdAt": "2020-12-09T02:56:33Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/types/family/TType.java", "diffHunk": "@@ -17,21 +17,40 @@\n \n package org.tensorflow.types.family;\n \n+import org.tensorflow.Tensor;\n+\n /**\n- * Marker interface for all tensor types.\n+ * Common interface for all typed tensors.\n  *\n- * <p>Tensor types are carried as a generic parameter of the {@link org.tensorflow.Tensor Tensor}\n- * class bound by the {@code TType} interface. This generic parameter ensure type-compatibility\n- * between operands of a computation at compile-time. For example:\n+ * <p>Typed tensors wraps a {@link RawTensor} by mapping their native memory to a n-dimensional\n+ * data space allowing direct I/O access from the JVM.</p>\n  *\n- * <pre>{@code\n- * Tensor<TFloat32> tensor1 = TFloat32.ofShape(2, 3, 2);\n- * Tensor<TFloat32> tensor2 = TFloat32.ofShape(2, 3, 2);\n- * Tensor<TInt32> tensor3 = TInt32.ofShape(2, 3, 2);\n+ * <p>Subinterfaces of {@code TType} are propagated as a generic parameter to various entities of\n+ * TensorFlow to identify the type of the tensor they carry. For example, a\n+ * {@link org.tensorflow.Operand Operand<TFloat32>} is an operand which outputs is a 32-bit floating", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2Nzk3Nw==", "bodyText": "Shouldn't the type of this list be Tensor not ??", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538967977", "createdAt": "2020-12-09T02:59:10Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/op/core/GradientsTest.java", "diffHunk": "@@ -47,13 +47,13 @@ public void createGradients() {\n       assertNotNull(grads.dy());\n       assertEquals(2, grads.dy().size());\n \n-      try (Tensor<TFloat32> c = TFloat32.scalarOf(3.0f);\n-          AutoCloseableList<Tensor<?>> outputs =\n+      try (TFloat32 c = TFloat32.scalarOf(3.0f);\n+          AutoCloseableList<?> outputs =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2ODgwNQ==", "bodyText": "Formatting seems off in this else block. Also maybe we should have a TIntegral type to go with TFloating and then the else block really can't happen. And when we get sealed types in a future Java version we can have the compiler check it for us.", "url": "https://github.com/tensorflow/java/pull/160#discussion_r538968805", "createdAt": "2020-12-09T03:01:25Z", "author": {"login": "Craigacp"}, "path": "tensorflow-framework/src/main/java/org/tensorflow/framework/utils/ShapeUtils.java", "diffHunk": "@@ -63,64 +63,36 @@\n    * @throws java.lang.IllegalArgumentException if the dims type is not an integer\n    */\n   public static <T extends TNumber> long[] getLongArray(Scope scope, Operand<T> dims) {\n-    DataType<T> dType = dims.asOutput().dataType();\n-    if (!dType.isInteger()) {\n-      throw new IllegalArgumentException(\"the data type must be an integer type\");\n-    }\n-    List<Long> result = new ArrayList<>();\n-\n     if (scope.env().isEager()) {\n-      if (dType.equals(TInt32.DTYPE)) {\n-        @SuppressWarnings(\"unchecked\")\n-        Operand<TInt32> idims = (Operand<TInt32>) dims;\n-\n-        idims.asOutput().data().scalars().forEach(s -> result.add((long) s.getInt()));\n-      } else if (dType.equals(TInt64.DTYPE)) {\n-        @SuppressWarnings(\"unchecked\")\n-        Operand<TInt64> ldims = (Operand<TInt64>) dims;\n-        ldims.asOutput().data().scalars().forEach(s -> result.add(s.getLong()));\n-      } else if (dType.equals(TUint8.DTYPE)) {\n-        @SuppressWarnings(\"unchecked\")\n-        Operand<TUint8> udims = (Operand<TUint8>) dims;\n-        udims.asOutput().data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n-      } else { // shouldn't happen\n-        throw new IllegalArgumentException(\"the data type must be an integer type\");\n-      }\n-\n-    } else {\n-      try (Session session = new Session((Graph) scope.env())) {\n-        if (dType.equals(TInt32.DTYPE)) {\n-          try (Tensor<TInt32> tensorResult =\n-              session.runner().fetch(dims).run().get(0).expect(TInt32.DTYPE)) {\n-            tensorResult.data().scalars().forEach(s -> result.add((long) s.getInt()));\n-          }\n-        } else if (dType.equals(TInt64.DTYPE)) {\n-          try (Tensor<TInt64> tensorResult =\n-              session.runner().fetch(dims).run().get(0).expect(TInt64.DTYPE)) {\n-            tensorResult.data().scalars().forEach(s -> result.add(s.getLong()));\n-          }\n-        } else if (dType.equals(TUint8.DTYPE)) {\n-          try (Tensor<TUint8> tensorResult =\n-              session.runner().fetch(dims).run().get(0).expect(TUint8.DTYPE)) {\n-            tensorResult.data().scalars().forEach(s -> result.add(s.getObject().longValue()));\n-          }\n-        } else { // shouldn't happen\n-          throw new IllegalArgumentException(\"the data type must be an integer type\");\n-        }\n-      }\n+      return getLongArray(dims.asTensor());\n+    }\n+    try (Session session = new Session((Graph)scope.env());\n+        Tensor tensor = session.runner().fetch(dims).run().get(0)) {\n+      return getLongArray(tensor);\n     }\n-    return result.stream().mapToLong(i -> i).toArray();\n   }\n \n   /**\n-   * Gets the shape for the data within a Tensor\n+   * Converts a TInt32 or TInt64 to a java long array\n    *\n-   * @param tensor the tensor\n-   * @return the Shape of the tensor's data;\n+   * @param scope the TensorFlow scope\n+   * @param dims the dimension tensor\n+   * @param <T> the type of the dimensions, must either be TInt32 or TInt64 type\n+   * @return the long array\n+   * @throws java.lang.IllegalArgumentException if the dims type is not an integer\n    */\n-  public static <T extends TNumber> Shape getShape(Tensor<T> tensor) {\n-    NdArray<?> data = (NdArray<?>) tensor.data();\n-    return data.shape();\n+  public static long[] getLongArray(Tensor dims) {\n+    List<Long> result = new ArrayList<>();\n+    if (dims instanceof TInt32) {\n+      ((TInt32)dims).scalars().forEach(s -> result.add((long) s.getInt()));\n+    } else if (dims instanceof TInt64) {\n+      ((TInt64)dims).scalars().forEach(s -> result.add(s.getLong()));\n+    } else if (dims instanceof TUint8) {\n+      ((TUint8)dims).scalars().forEach(s -> result.add(s.getObject().longValue()));\n+      } else { // shouldn't happen", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0225ab65e737ee3cccc4dcd61683779f0f8312ee"}, "originalPosition": 81}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "72d06532f94e7a23d6951954f4e96d77d0b5447d", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/72d06532f94e7a23d6951954f4e96d77d0b5447d", "committedDate": "2020-12-13T03:51:30Z", "message": "Rectify documentation based on PR review"}, "afterCommit": {"oid": "598fdc3e556ff4f3b57bb24ad89500e7fcc6bf63", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/598fdc3e556ff4f3b57bb24ad89500e7fcc6bf63", "committedDate": "2020-12-13T04:02:53Z", "message": "Rectify documentation based on PR review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2576e35752ae11dbb060ef05042b08df1460df26", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/2576e35752ae11dbb060ef05042b08df1460df26", "committedDate": "2020-12-13T16:28:56Z", "message": "Merge TType and Tensor instances as a single entity"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88e9a2166399a39bcbd5917af52dd9f32a495c17", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/88e9a2166399a39bcbd5917af52dd9f32a495c17", "committedDate": "2020-12-13T16:28:57Z", "message": "Rectify documentation based on PR review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8773ccc1981e4bc934af4031258df6a41a460a09", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/8773ccc1981e4bc934af4031258df6a41a460a09", "committedDate": "2020-12-13T21:00:13Z", "message": "Rebase on master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "598fdc3e556ff4f3b57bb24ad89500e7fcc6bf63", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/598fdc3e556ff4f3b57bb24ad89500e7fcc6bf63", "committedDate": "2020-12-13T04:02:53Z", "message": "Rectify documentation based on PR review"}, "afterCommit": {"oid": "8773ccc1981e4bc934af4031258df6a41a460a09", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/8773ccc1981e4bc934af4031258df6a41a460a09", "committedDate": "2020-12-13T21:00:13Z", "message": "Rebase on master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MTA4ODM1", "url": "https://github.com/tensorflow/java/pull/160#pullrequestreview-554108835", "createdAt": "2020-12-16T21:43:56Z", "commit": {"oid": "8773ccc1981e4bc934af4031258df6a41a460a09"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3467, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}