{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg1NDIxNzQ3", "number": 112, "title": "Create, save, load and run models using a new functional API", "bodyText": "Introducing a new ConcreteFunction class, which allows you to create graphs, load/save models and run inference using the same functional API. See documentation in this PR for some examples.\nExporting SavedModels only supports session-centric models, i.e. models that has a single main graph. This means that if multiple functions are saved with the model, they should all share the same graph for now. That limitation will be addressed later.\nCC\\ @Shajan", "createdAt": "2020-09-11T20:14:16Z", "url": "https://github.com/tensorflow/java/pull/112", "merged": true, "mergeCommit": {"oid": "1d35c17dcc85286a91f59a6ff0b94c48f1b8d4b1"}, "closed": true, "closedAt": "2020-09-17T20:04:03Z", "author": {"login": "karllessard"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdH882-gFqTQ4NzEyMjIyNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdJ2pMGgFqTQ4ODMzMTIzNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MTIyMjI0", "url": "https://github.com/tensorflow/java/pull/112#pullrequestreview-487122224", "createdAt": "2020-09-11T21:02:05Z", "commit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTowMjowNVrOHQtwug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMjoxNTowM1rOHQvSgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI4OTAxOA==", "bodyText": "Are we guaranteed that the iteration order of the signature's outputs map is consistent?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487289018", "createdAt": "2020-09-11T21:02:05Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/ConcreteFunction.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * ConcreteFunction myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class ConcreteFunction implements AutoCloseable {\n+\n+  /**\n+   * Creates a function by building a new graph.\n+   *\n+   * <p/>The {@code functionBuilder} must initialize the function graph from the provided\n+   * {@link Ops} instance and return a valid signature that will be used to feed the input tensors\n+   * and fetch the output tensors on execution.\n+   *\n+   * <p/>The function will be the owner of the new graph and its resulting session. Therefore,\n+   * the function must be enclosed properly with a try-with-resources block to guarantee that\n+   * all native resources will be freed once the function is discarded. For example:\n+   *\n+   * <pre>{@code\n+   * public class MyModel {\n+   *\n+   *   public static Signature addTwo(Ops tf) {\n+   *     Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *     Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *     return Signature.builder(\"addTwo\").input(\"x\", input).output(\"y\", output).build();\n+   *   }\n+   *\n+   *   public static void main(String args[]) {\n+   *     try (ConcreteFunction function = ConcreteFunction.create(MyModel::addTwo);\n+   *         Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *   }\n+   * }\n+   * }</pre>\n+   *\n+   * @param functionBuilder function builder\n+   * @return the new function\n+   */\n+  public static ConcreteFunction create(Function<Ops, Signature> functionBuilder) {\n+    Graph graph = new Graph();\n+    try {\n+      Ops tf = Ops.create(graph);\n+      Signature signature = functionBuilder.apply(tf);\n+      return new ConcreteFunction(signature, graph, new Session(graph), Ownership.GRAPH_AND_SESSION);\n+    } catch (Exception e) {\n+      graph.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Create a function from a signature and an existing graph.\n+   *\n+   * <p/>The function will keep the ownership of the session used to run the graph but not\n+   * the graph itself, meaning that the lifetime of the latter can extend beyond the scope\n+   * of the function. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (ConcreteFunction f = ConcreteFunction.create(signature, g);\n+   *       Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *     assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid and initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Graph graph) {\n+    return new ConcreteFunction(signature, graph, new Session(graph), Ownership.SESSION_ONLY);\n+  }\n+\n+  /**\n+   * Create a function from a signature and a valid graph session.\n+   *\n+   * <p/>The function will not own the session nor its graph, meaning that their lifetime\n+   * can extend beyond the scope of the function. Therefore the function does not need to be\n+   * closed after its usage. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (Session s = new Session(g)) {\n+   *     // Auto-closing the function just as an example but this is not required since it has\n+   *     // no effect\n+   *     try (ConcreteFunction f = ConcreteFunction.create(signature, s);\n+   *         Tensor<TFloat32> t = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *     // Session s is still valid at this point\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid session to an initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Session session) {\n+    return new ConcreteFunction(signature, session.graph(), session, Ownership.NONE);\n+  }\n+\n+  /**\n+   * Returns the signature of this function\n+   */\n+  public Signature signature() {\n+    return signature;\n+  }\n+\n+  /**\n+   * Invokes a function.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   */\n+  public Map<String, Tensor<?>> call(Map<String, Tensor<?>> arguments)\n+      throws IllegalArgumentException {\n+\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+    final Session.Runner runner = session.runner();\n+\n+    signatureDef.getInputsMap().forEach((argName, t) -> {\n+      Tensor<?> tensor = arguments.get(argName);\n+      if (tensor == null) {\n+        throw new IllegalArgumentException(String.format(\"Missing argument [%s]\", argName));\n+      }\n+      runner.feed(t.getName(), tensor);\n+    });\n+\n+    Map<String, TensorInfo> outputToNode = signatureDef.getOutputsMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI4OTI0Mw==", "bodyText": "Document the IOException with @throws?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487289243", "createdAt": "2020-09-11T21:02:40Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/ConcreteFunction.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * ConcreteFunction myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class ConcreteFunction implements AutoCloseable {\n+\n+  /**\n+   * Creates a function by building a new graph.\n+   *\n+   * <p/>The {@code functionBuilder} must initialize the function graph from the provided\n+   * {@link Ops} instance and return a valid signature that will be used to feed the input tensors\n+   * and fetch the output tensors on execution.\n+   *\n+   * <p/>The function will be the owner of the new graph and its resulting session. Therefore,\n+   * the function must be enclosed properly with a try-with-resources block to guarantee that\n+   * all native resources will be freed once the function is discarded. For example:\n+   *\n+   * <pre>{@code\n+   * public class MyModel {\n+   *\n+   *   public static Signature addTwo(Ops tf) {\n+   *     Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *     Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *     return Signature.builder(\"addTwo\").input(\"x\", input).output(\"y\", output).build();\n+   *   }\n+   *\n+   *   public static void main(String args[]) {\n+   *     try (ConcreteFunction function = ConcreteFunction.create(MyModel::addTwo);\n+   *         Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *   }\n+   * }\n+   * }</pre>\n+   *\n+   * @param functionBuilder function builder\n+   * @return the new function\n+   */\n+  public static ConcreteFunction create(Function<Ops, Signature> functionBuilder) {\n+    Graph graph = new Graph();\n+    try {\n+      Ops tf = Ops.create(graph);\n+      Signature signature = functionBuilder.apply(tf);\n+      return new ConcreteFunction(signature, graph, new Session(graph), Ownership.GRAPH_AND_SESSION);\n+    } catch (Exception e) {\n+      graph.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Create a function from a signature and an existing graph.\n+   *\n+   * <p/>The function will keep the ownership of the session used to run the graph but not\n+   * the graph itself, meaning that the lifetime of the latter can extend beyond the scope\n+   * of the function. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (ConcreteFunction f = ConcreteFunction.create(signature, g);\n+   *       Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *     assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid and initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Graph graph) {\n+    return new ConcreteFunction(signature, graph, new Session(graph), Ownership.SESSION_ONLY);\n+  }\n+\n+  /**\n+   * Create a function from a signature and a valid graph session.\n+   *\n+   * <p/>The function will not own the session nor its graph, meaning that their lifetime\n+   * can extend beyond the scope of the function. Therefore the function does not need to be\n+   * closed after its usage. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (Session s = new Session(g)) {\n+   *     // Auto-closing the function just as an example but this is not required since it has\n+   *     // no effect\n+   *     try (ConcreteFunction f = ConcreteFunction.create(signature, s);\n+   *         Tensor<TFloat32> t = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *     // Session s is still valid at this point\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid session to an initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Session session) {\n+    return new ConcreteFunction(signature, session.graph(), session, Ownership.NONE);\n+  }\n+\n+  /**\n+   * Returns the signature of this function\n+   */\n+  public Signature signature() {\n+    return signature;\n+  }\n+\n+  /**\n+   * Invokes a function.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   */\n+  public Map<String, Tensor<?>> call(Map<String, Tensor<?>> arguments)\n+      throws IllegalArgumentException {\n+\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+    final Session.Runner runner = session.runner();\n+\n+    signatureDef.getInputsMap().forEach((argName, t) -> {\n+      Tensor<?> tensor = arguments.get(argName);\n+      if (tensor == null) {\n+        throw new IllegalArgumentException(String.format(\"Missing argument [%s]\", argName));\n+      }\n+      runner.feed(t.getName(), tensor);\n+    });\n+\n+    Map<String, TensorInfo> outputToNode = signatureDef.getOutputsMap();\n+    outputToNode.values().forEach(t -> runner.fetch(t.getName()));\n+\n+    List<Tensor<?>> resultTensors = runner.run();\n+    try {\n+      ListIterator<Tensor<?>> resultTensorIter = resultTensors.listIterator();\n+      Map<String, Tensor<?>> returnMap = new HashMap<String, Tensor<?>>();\n+\n+      // Use the output names as present in the signature definition\n+      for (String nodeName: outputToNode.keySet()) {\n+        returnMap.put(nodeName, resultTensorIter.next());\n+      }\n+      return returnMap;\n+\n+    } catch (Exception e) {\n+      // Release tensors before throwing exception\n+      for (Tensor<?> t : resultTensors) {\n+        t.close();\n+      }\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Invokes a function with a single input and output.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   * @throws IllegalArgumentException if there are multiple input or output parameters defined\n+   *                                  in the function\n+   */\n+  public Tensor<?> call(Tensor<?> tensor) throws IllegalArgumentException {\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+\n+    if (signatureDef.getInputsCount() != 1) {\n+      throw new IllegalArgumentException(\n+        String.format(\"Function [%s] requires multiple inputs\", signatureDef.getMethodName()));\n+    }\n+    String inputNodeName = signatureDef.getInputsMap().values().iterator().next().getName();\n+\n+    if (signatureDef.getOutputsCount() != 1) {\n+      throw new IllegalArgumentException(\n+        String.format(\"Function [%s] has multiple outputs\", signatureDef.getMethodName()));\n+    }\n+    String outputNodeName = signatureDef.getOutputsMap().values().iterator().next().getName();\n+\n+    return session.runner().feed(inputNodeName, tensor).fetch(outputNodeName).run().get(0);\n+  }\n+\n+  /**\n+   * Export this function as a saved model.\n+   *\n+   * <p>This method is convenient shortcut equivalent to\n+   * {@code SavedModel.exporter(exportDir).withFunction(this).export()}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwMjQzNQ==", "bodyText": "Should we validate that the tags are non-empty Strings?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487302435", "createdAt": "2020-09-11T21:38:32Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "diffHunk": "@@ -77,10 +94,14 @@ public Loader withConfigProto(ConfigProto configProto) {\n     /**\n      * Sets the set of tags that identify the specific graph in the saved model to load.\n      *\n+     * <p>Has no effect if {@code tags} is null or empty\n+     *\n      * @param tags the tags identifying the specific MetaGraphDef to load.\n      */\n     public Loader withTags(String... tags) {\n-      this.tags = tags;\n+      if (tags != null && tags.length > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwMjk3Mw==", "bodyText": "It's a bit odd that tags in the Loader is an array, and tags here is an ArrayList. Is there a reason for the difference?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487302973", "createdAt": "2020-09-11T21:40:07Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "diffHunk": "@@ -89,11 +110,107 @@ private Loader(String exportDir) {\n     }\n \n     private String exportDir = null;\n-    private String[] tags = null;\n+    private String[] tags = {DEFAULT_TAG};\n     private ConfigProto configProto = null;\n     private RunOptions runOptions = null;\n   }\n \n+  /** Options for exporting a SavedModel. */\n+  public static final class Exporter {\n+\n+    /**\n+     * Sets the set of tags that identify the specific graph in the saved model to save.\n+     *\n+     * <p/>Note that only one graph per model can be saved right now using this API.\n+     *\n+     * @param tags the tags identifying the specific MetaGraphDef to save.\n+     * @return this object\n+     */\n+    public Exporter withTags(String... tags) {\n+      this.tags.addAll(Arrays.asList(tags));\n+      return this;\n+    }\n+\n+    /**\n+     * Save a concrete function of this model.\n+     *\n+     * <p/>The concrete function carries a signature (i.e. a list of user-friendly input and outputs\n+     * names to a graph) and a valid session to a graph to be saved in the model.\n+     *\n+     * <p/><i>Note:Eventually, TensorFlow for Java will support the export of functions objects like\n+     * the Python API does but right now, only session-centric models are supported (i.e. models that\n+     * has a single main graph and one or more signatures). These models are compatible with those\n+     * exported by TensorFlow 1.x or by TensorFlow 2.x estimators.\n+     *\n+     * <p>Therefore, all functions exported in a model should share the same session at the moment\n+     * or an exception will be thrown.</i>\n+     *\n+     * @param function a function carrying a signature and a valid session to the graph to be saved\n+     * @return this object\n+     * @throws IllegalArgumentException if a function with the same name has already been added to the model\n+     */\n+    public Exporter withFunction(ConcreteFunction function) {\n+      Signature signature = function.signature();\n+      if (functions.containsKey(signature.key())) {\n+        throw new IllegalArgumentException(\"Function \\\"\" + signature.key() + \"\\\" was already added to the model\");\n+      }\n+      functions.put(signature.key(), function);\n+      if (session == null) {\n+        session = function.session();\n+      } else if (session != function.session()) {\n+        throw new UnsupportedOperationException(\"Saving multiple functions with different graphs/sessions is not supported yet.\");\n+      }\n+      metaGraphDefBuilder.putSignatureDef(signature.key(), signature.asSignatureDef());\n+      return this;\n+    }\n+\n+    /**\n+     * Save the model into the export directory.\n+     *\n+     * @throws IOException if saved model or variable state can be written on disk\n+     */\n+    public void export() throws IOException {\n+      if (functions.isEmpty() || session == null) {\n+        throw new IllegalStateException(\"Model should contain at least one valid function\");\n+      }\n+      if (tags.isEmpty()) {\n+        tags.add(DEFAULT_TAG);\n+      }\n+      // It is imperative to retrieve the graphDef after the saverDef, as the former might add\n+      // new ops to the graph for saving and restoring the variables.\n+      Graph graph = session.graph();\n+      MetaGraphDef.Builder metaGraphDef = metaGraphDefBuilder\n+          .setSaverDef(graph.saverDef())\n+          .setGraphDef(graph.toGraphDef())\n+          .setMetaInfoDef(MetaInfoDef.newBuilder().addAllTags(tags));\n+      functions.forEach((k, f) -> metaGraphDef.putSignatureDef(k, f.signature().asSignatureDef()));\n+\n+      // Make sure saved model directories exist\n+      Path variableDir = Paths.get(exportDir, \"variables\");\n+      variableDir.toFile().mkdirs();\n+\n+      // Save the variables state\n+      session.save(variableDir.resolve(\"variables\").toString());\n+\n+      // Save the graph\n+      SavedModel savedModelDef = SavedModel.newBuilder().addMetaGraphs(metaGraphDef).build();\n+      try (OutputStream file =\n+          new FileOutputStream(Paths.get(exportDir, \"saved_model.pb\").toString())) {\n+        savedModelDef.writeTo(file);\n+      }\n+    }\n+\n+    Exporter(String exportDir) {\n+      this.exportDir = exportDir;\n+    }\n+\n+    private final String exportDir;\n+    private final List<String> tags = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwMzU5MQ==", "bodyText": "Should we note this in the @throws bit of the Javadoc? It says an exception will be thrown, but not what kind.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487303591", "createdAt": "2020-09-11T21:42:01Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "diffHunk": "@@ -89,11 +110,107 @@ private Loader(String exportDir) {\n     }\n \n     private String exportDir = null;\n-    private String[] tags = null;\n+    private String[] tags = {DEFAULT_TAG};\n     private ConfigProto configProto = null;\n     private RunOptions runOptions = null;\n   }\n \n+  /** Options for exporting a SavedModel. */\n+  public static final class Exporter {\n+\n+    /**\n+     * Sets the set of tags that identify the specific graph in the saved model to save.\n+     *\n+     * <p/>Note that only one graph per model can be saved right now using this API.\n+     *\n+     * @param tags the tags identifying the specific MetaGraphDef to save.\n+     * @return this object\n+     */\n+    public Exporter withTags(String... tags) {\n+      this.tags.addAll(Arrays.asList(tags));\n+      return this;\n+    }\n+\n+    /**\n+     * Save a concrete function of this model.\n+     *\n+     * <p/>The concrete function carries a signature (i.e. a list of user-friendly input and outputs\n+     * names to a graph) and a valid session to a graph to be saved in the model.\n+     *\n+     * <p/><i>Note:Eventually, TensorFlow for Java will support the export of functions objects like\n+     * the Python API does but right now, only session-centric models are supported (i.e. models that\n+     * has a single main graph and one or more signatures). These models are compatible with those\n+     * exported by TensorFlow 1.x or by TensorFlow 2.x estimators.\n+     *\n+     * <p>Therefore, all functions exported in a model should share the same session at the moment\n+     * or an exception will be thrown.</i>\n+     *\n+     * @param function a function carrying a signature and a valid session to the graph to be saved\n+     * @return this object\n+     * @throws IllegalArgumentException if a function with the same name has already been added to the model\n+     */\n+    public Exporter withFunction(ConcreteFunction function) {\n+      Signature signature = function.signature();\n+      if (functions.containsKey(signature.key())) {\n+        throw new IllegalArgumentException(\"Function \\\"\" + signature.key() + \"\\\" was already added to the model\");\n+      }\n+      functions.put(signature.key(), function);\n+      if (session == null) {\n+        session = function.session();\n+      } else if (session != function.session()) {\n+        throw new UnsupportedOperationException(\"Saving multiple functions with different graphs/sessions is not supported yet.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwNDA5OA==", "bodyText": "Given this comment, should we pull out the SaverDef as a variable before the MetaGraphDefBuilder call? That way it's explicit that it will always happen first.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487304098", "createdAt": "2020-09-11T21:43:36Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "diffHunk": "@@ -89,11 +110,107 @@ private Loader(String exportDir) {\n     }\n \n     private String exportDir = null;\n-    private String[] tags = null;\n+    private String[] tags = {DEFAULT_TAG};\n     private ConfigProto configProto = null;\n     private RunOptions runOptions = null;\n   }\n \n+  /** Options for exporting a SavedModel. */\n+  public static final class Exporter {\n+\n+    /**\n+     * Sets the set of tags that identify the specific graph in the saved model to save.\n+     *\n+     * <p/>Note that only one graph per model can be saved right now using this API.\n+     *\n+     * @param tags the tags identifying the specific MetaGraphDef to save.\n+     * @return this object\n+     */\n+    public Exporter withTags(String... tags) {\n+      this.tags.addAll(Arrays.asList(tags));\n+      return this;\n+    }\n+\n+    /**\n+     * Save a concrete function of this model.\n+     *\n+     * <p/>The concrete function carries a signature (i.e. a list of user-friendly input and outputs\n+     * names to a graph) and a valid session to a graph to be saved in the model.\n+     *\n+     * <p/><i>Note:Eventually, TensorFlow for Java will support the export of functions objects like\n+     * the Python API does but right now, only session-centric models are supported (i.e. models that\n+     * has a single main graph and one or more signatures). These models are compatible with those\n+     * exported by TensorFlow 1.x or by TensorFlow 2.x estimators.\n+     *\n+     * <p>Therefore, all functions exported in a model should share the same session at the moment\n+     * or an exception will be thrown.</i>\n+     *\n+     * @param function a function carrying a signature and a valid session to the graph to be saved\n+     * @return this object\n+     * @throws IllegalArgumentException if a function with the same name has already been added to the model\n+     */\n+    public Exporter withFunction(ConcreteFunction function) {\n+      Signature signature = function.signature();\n+      if (functions.containsKey(signature.key())) {\n+        throw new IllegalArgumentException(\"Function \\\"\" + signature.key() + \"\\\" was already added to the model\");\n+      }\n+      functions.put(signature.key(), function);\n+      if (session == null) {\n+        session = function.session();\n+      } else if (session != function.session()) {\n+        throw new UnsupportedOperationException(\"Saving multiple functions with different graphs/sessions is not supported yet.\");\n+      }\n+      metaGraphDefBuilder.putSignatureDef(signature.key(), signature.asSignatureDef());\n+      return this;\n+    }\n+\n+    /**\n+     * Save the model into the export directory.\n+     *\n+     * @throws IOException if saved model or variable state can be written on disk\n+     */\n+    public void export() throws IOException {\n+      if (functions.isEmpty() || session == null) {\n+        throw new IllegalStateException(\"Model should contain at least one valid function\");\n+      }\n+      if (tags.isEmpty()) {\n+        tags.add(DEFAULT_TAG);\n+      }\n+      // It is imperative to retrieve the graphDef after the saverDef, as the former might add\n+      // new ops to the graph for saving and restoring the variables.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwNTA5Nw==", "bodyText": "Should we make this a LinkedHashMap so it has a consistent iteration order? That way the signatures will always come out in the way that the metaGraphDef says they are (assuming it preserves ordering).", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487305097", "createdAt": "2020-09-11T21:46:23Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "diffHunk": "@@ -175,10 +364,21 @@ private SavedModelBundle(Graph graph, Session session, MetaGraphDef metaGraphDef\n    * <p>Invoked from the native load method. Takes ownership of the handles.\n    */\n   private static SavedModelBundle fromHandle(\n-      TF_Graph graphHandle, TF_Session sessionHandle, MetaGraphDef metaGraphDef) {\n-    Graph graph = new Graph(graphHandle);\n-    Session session = new Session(graph, sessionHandle);\n-    return new SavedModelBundle(graph, session, metaGraphDef);\n+      final TF_Graph graphHandle, final TF_Session sessionHandle, MetaGraphDef metaGraphDef) {\n+\n+    final Graph graph = new Graph(graphHandle, metaGraphDef.getSaverDef());\n+    final Session session = new Session(graph, sessionHandle);\n+\n+    // Create a separate function for each signature of the main graph.\n+    // Note that the saved model will remain the owner of the graph and the session, meaning\n+    // that the functions do not need to be closed by the user and if it does, it should have\n+    // no effect.\n+    final Map<String, ConcreteFunction> functions = new HashMap<>(metaGraphDef.getSignatureDefCount());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwODI3Ng==", "bodyText": "Should we note that this will permanently alter the graph itself by adding saving hooks?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487308276", "createdAt": "2020-09-11T21:56:16Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Session.java", "diffHunk": "@@ -444,6 +446,24 @@ public void run(Op op) {\n     runner().addTarget(op.op()).run();\n   }\n \n+  /**\n+   * Saves the actual state of the variables of this session's graph.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwODc3NA==", "bodyText": "Should we check the input isn't the empty String? And then while we're doing that, that it's not null?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487308774", "createdAt": "2020-09-11T21:57:45Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Signature.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.proto.framework.DataType;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+import org.tensorflow.proto.framework.TensorShapeProto;\n+import org.tensorflow.proto.framework.TensorShapeProto.Dim;\n+\n+/**\n+ * Describe the inputs and outputs of an executable entity, such as a {@link ConcreteFunction}, among\n+ * other useful metadata.\n+ */\n+public class Signature  {\n+\n+  /** The default signature key, when not provided */\n+  public static final String DEFAULT_KEY = \"serving_default\";\n+\n+  /**\n+   * Builds a new function signature.\n+   */\n+  public static class Builder {\n+\n+    /**\n+     * Sets the unique key of this signature.\n+     *\n+     * <p/>When not set explicitly, the default value is {@link #DEFAULT_KEY}.\n+     *\n+     * @param key signature key\n+     * @return this builder\n+     */\n+    public Builder key(String key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwOTE3Mw==", "bodyText": "What are the semantics for name collisions? If they aren't defined should we define them? Ditto for the outputs.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487309173", "createdAt": "2020-09-11T21:59:12Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Signature.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.proto.framework.DataType;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+import org.tensorflow.proto.framework.TensorShapeProto;\n+import org.tensorflow.proto.framework.TensorShapeProto.Dim;\n+\n+/**\n+ * Describe the inputs and outputs of an executable entity, such as a {@link ConcreteFunction}, among\n+ * other useful metadata.\n+ */\n+public class Signature  {\n+\n+  /** The default signature key, when not provided */\n+  public static final String DEFAULT_KEY = \"serving_default\";\n+\n+  /**\n+   * Builds a new function signature.\n+   */\n+  public static class Builder {\n+\n+    /**\n+     * Sets the unique key of this signature.\n+     *\n+     * <p/>When not set explicitly, the default value is {@link #DEFAULT_KEY}.\n+     *\n+     * @param key signature key\n+     * @return this builder\n+     */\n+    public Builder key(String key) {\n+      this.key = key;\n+      return this;\n+    }\n+\n+    /**\n+     * Register a tensor as an input of the function.\n+     *\n+     * @param inputName user-friendly name for this input tensor\n+     * @param input input tensor\n+     * @return this builder\n+     */\n+    public Builder input(String inputName, Operand<?> input) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxMDIzMw==", "bodyText": "Similarly should we check it isn't empty or null?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487310233", "createdAt": "2020-09-11T22:02:25Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Signature.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.proto.framework.DataType;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+import org.tensorflow.proto.framework.TensorShapeProto;\n+import org.tensorflow.proto.framework.TensorShapeProto.Dim;\n+\n+/**\n+ * Describe the inputs and outputs of an executable entity, such as a {@link ConcreteFunction}, among\n+ * other useful metadata.\n+ */\n+public class Signature  {\n+\n+  /** The default signature key, when not provided */\n+  public static final String DEFAULT_KEY = \"serving_default\";\n+\n+  /**\n+   * Builds a new function signature.\n+   */\n+  public static class Builder {\n+\n+    /**\n+     * Sets the unique key of this signature.\n+     *\n+     * <p/>When not set explicitly, the default value is {@link #DEFAULT_KEY}.\n+     *\n+     * @param key signature key\n+     * @return this builder\n+     */\n+    public Builder key(String key) {\n+      this.key = key;\n+      return this;\n+    }\n+\n+    /**\n+     * Register a tensor as an input of the function.\n+     *\n+     * @param inputName user-friendly name for this input tensor\n+     * @param input input tensor\n+     * @return this builder\n+     */\n+    public Builder input(String inputName, Operand<?> input) {\n+      signatureBuilder.putInputs(inputName, toTensorInfo(input.asOutput()));\n+      return this;\n+    }\n+\n+    /**\n+     * Register a tensor as an output of the function.\n+     *\n+     * @param inputName user-friendly name for this input tensor\n+     * @param input input tensor\n+     * @return this builder\n+     */\n+    public Builder output(String outputName, Operand<?> output) {\n+      signatureBuilder.putOutputs(outputName, toTensorInfo(output.asOutput()));\n+      return this;\n+    }\n+\n+    /**\n+     * Provide extensible name information enabling third-party users to mark a signature as\n+     * supporting a particular method\n+     *\n+     * @param methodName method name\n+     * @return this builder\n+     */\n+    public Builder methodName(String methodName) {\n+      signatureBuilder.setMethodName(methodName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxMTU3Mg==", "bodyText": "What does this init trigger?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487311572", "createdAt": "2020-09-11T22:06:41Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/ConcreteFunctionTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.tensorflow;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import org.junit.jupiter.api.Test;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.core.Init;\n+import org.tensorflow.op.core.Placeholder;\n+import org.tensorflow.op.math.Add;\n+import org.tensorflow.op.math.Sub;\n+import org.tensorflow.types.TFloat32;\n+\n+public class ConcreteFunctionTest {\n+\n+  private static Signature plusFive(Ops tf) {\n+    Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+    Add<TFloat32> output = tf.math.add(input, tf.constant(5.0f));\n+    Init init = tf.init();  // for native resource management tests", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxMjAxOA==", "bodyText": "Should we use the junit assertThrows test here? It's shorter.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487312018", "createdAt": "2020-09-11T22:08:04Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/ConcreteFunctionTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.tensorflow;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import org.junit.jupiter.api.Test;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.core.Init;\n+import org.tensorflow.op.core.Placeholder;\n+import org.tensorflow.op.math.Add;\n+import org.tensorflow.op.math.Sub;\n+import org.tensorflow.types.TFloat32;\n+\n+public class ConcreteFunctionTest {\n+\n+  private static Signature plusFive(Ops tf) {\n+    Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+    Add<TFloat32> output = tf.math.add(input, tf.constant(5.0f));\n+    Init init = tf.init();  // for native resource management tests\n+    return Signature.builder().key(\"plusFive\").input(\"x\", input).output(\"y\", output).build();\n+  }\n+\n+  private static Signature minusTwo(Ops tf) {\n+    Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+    Sub<TFloat32> output = tf.math.sub(input, tf.constant(2.0f));\n+    return Signature.builder().key(\"minusTwo\").input(\"x\", input).output(\"y\", output).build();\n+  }\n+\n+  @Test\n+  public void createFunction() {\n+    try (ConcreteFunction f = ConcreteFunction.create(ConcreteFunctionTest::plusFive);\n+        Tensor<TFloat32> x = TFloat32.scalarOf(3.0f)) {\n+      assertEquals(8.0f, f.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+    }\n+  }\n+\n+  @Test\n+  public void createFunctionFromGraph() {\n+    try (Graph g = new Graph()) {\n+      Signature signature = plusFive(Ops.create(g));\n+      try (ConcreteFunction f = ConcreteFunction.create(signature, g);\n+          Tensor<TFloat32> x = TFloat32.scalarOf(3.0f)) {\n+        assertEquals(8.0f, f.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void createFunctionFromSession() {\n+    try (Graph g = new Graph()) {\n+      Signature signature = plusFive(Ops.create(g));\n+      try (Session s = new Session(g)) {\n+        try (ConcreteFunction f = ConcreteFunction.create(signature, s);\n+            Tensor<TFloat32> x = TFloat32.scalarOf(3.0f)) {\n+          assertEquals(8.0f, f.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+        }\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void chainFunctions() {\n+    try (ConcreteFunction f1 = ConcreteFunction.create(ConcreteFunctionTest::plusFive);\n+        ConcreteFunction f2 = ConcreteFunction.create(ConcreteFunctionTest::minusTwo);\n+        Tensor<TFloat32> x = TFloat32.scalarOf(3.0f)) {\n+      assertEquals(6.0f, f2.call(f1.call(x)).expect(TFloat32.DTYPE).data().getFloat());\n+    }\n+  }\n+\n+  @Test\n+  public void closingFunctionReleaseAllResourcesItOwns() {\n+    Graph g;\n+    Session s;\n+    try (ConcreteFunction f = ConcreteFunction.create(ConcreteFunctionTest::plusFive)) {\n+      g = f.graph();\n+      s = f.session();\n+    }\n+    try {\n+      s.run(\"Add\");\n+      fail();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNDA1MA==", "bodyText": "Should we just check this in as a python file?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487314050", "createdAt": "2020-09-11T22:15:03Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/test/resources/saved_model_using_python/readme.txt", "diffHunk": "@@ -0,0 +1,45 @@\n+Saved model created using Python @tf.function, tensorflow version 2.3.0.\n+\n+Python code used to create saved model below:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 3}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c356139339616c82f2a284cd4603adef69a8ffa1", "author": {"user": {"login": "Shajan", "name": "Shajan Dasan"}}, "url": "https://github.com/tensorflow/java/commit/c356139339616c82f2a284cd4603adef69a8ffa1", "committedDate": "2020-09-16T00:40:18Z", "message": "Create, save and load models using functional API\n\nPython models that contain tf.function is inconvenient to be consumed by Java clients.\nThis proposal provides an API to\n(a) Invoke a tf.function, given the signature name\n(b) Retrieve the node name in the graph corresponding to a tf.function\n\nCo-authored-by: Shajan Dasan <sdasan@twitter.com>\n\nSave models as functions (#103)\n\n* Draft: Java API to use tf.function available on SavedModel. (#89)\n\nPython models that contain tf.function is inconvenient to be consumed by Java clients.\nThis proposal provides an API to\n(a) Invoke a tf.function, given the signature name\n(b) Retrieve the node name in the graph corresponding to a tf.function\n\nCo-authored-by: Shajan Dasan <sdasan@twitter.com>\n\n* Change API for creating concrete functions and exporting them to a saved model\n\nCo-authored-by: Karl Lessard <klessard@gmail.com>\n\nRename signature name to key\n\nPrint function signature when converting to String\n\nAdd method that returns the signature of all functions in a saved model\n\nAdd unit tests for python created SavedModel with tf.function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8cd74fc8fd8751b28f20411ec67552d9a5562a96", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/8cd74fc8fd8751b28f20411ec67552d9a5562a96", "committedDate": "2020-09-16T02:34:14Z", "message": "Add validations on signatures and saved models"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6", "author": {"user": {"login": "Shajan", "name": "Shajan Dasan"}}, "url": "https://github.com/tensorflow/java/commit/09c136ea671153452217138629e30cf83dc169f6", "committedDate": "2020-09-11T20:00:43Z", "message": "Create, save and load models using functional API\n\nPython models that contain tf.function is inconvenient to be consumed by Java clients.\nThis proposal provides an API to\n(a) Invoke a tf.function, given the signature name\n(b) Retrieve the node name in the graph corresponding to a tf.function\n\nCo-authored-by: Shajan Dasan <sdasan@twitter.com>\n\nSave models as functions (#103)\n\n* Draft: Java API to use tf.function available on SavedModel. (#89)\n\nPython models that contain tf.function is inconvenient to be consumed by Java clients.\nThis proposal provides an API to\n(a) Invoke a tf.function, given the signature name\n(b) Retrieve the node name in the graph corresponding to a tf.function\n\nCo-authored-by: Shajan Dasan <sdasan@twitter.com>\n\n* Change API for creating concrete functions and exporting them to a saved model\n\nCo-authored-by: Karl Lessard <klessard@gmail.com>\n\nRename signature name to key\n\nPrint function signature when converting to String\n\nAdd method that returns the signature of all functions in a saved model\n\nAdd unit tests for python created SavedModel with tf.function"}, "afterCommit": {"oid": "8cd74fc8fd8751b28f20411ec67552d9a5562a96", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/8cd74fc8fd8751b28f20411ec67552d9a5562a96", "committedDate": "2020-09-16T02:34:14Z", "message": "Add validations on signatures and saved models"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bb4622378998a773d4e67cd850e198179443c9b", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/2bb4622378998a773d4e67cd850e198179443c9b", "committedDate": "2020-09-16T02:48:56Z", "message": "Convert text file to Python"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwODk5OTAw", "url": "https://github.com/tensorflow/java/pull/112#pullrequestreview-490899900", "createdAt": "2020-09-17T19:03:23Z", "commit": {"oid": "2bb4622378998a773d4e67cd850e198179443c9b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTowMzoyM1rOHTxCxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTowMzoyM1rOHTxCxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4ODUxNw==", "bodyText": "This should have a copyright statement at the top.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r490488517", "createdAt": "2020-09-17T19:03:23Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/test/resources/saved_model_using_python/source_model.py", "diffHunk": "@@ -0,0 +1,48 @@\n+# Saved model created using Python @tf.function, tensorflow version 2.3.0.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bb4622378998a773d4e67cd850e198179443c9b"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc68d3a14682074f99a2298976785d28ccb5af92", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/fc68d3a14682074f99a2298976785d28ccb5af92", "committedDate": "2020-09-17T19:40:29Z", "message": "Add copyright on Python sample"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwOTQ1ODMw", "url": "https://github.com/tensorflow/java/pull/112#pullrequestreview-490945830", "createdAt": "2020-09-17T20:01:38Z", "commit": {"oid": "fc68d3a14682074f99a2298976785d28ccb5af92"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MzMxMjM3", "url": "https://github.com/tensorflow/java/pull/112#pullrequestreview-488331237", "createdAt": "2020-09-15T05:17:11Z", "commit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNToxNzoxMVrOHRxB3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQwNToxNzoxMVrOHRxB3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5MTEzNQ==", "bodyText": "@karllessard any guidance on having python files in the java repo?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r488391135", "createdAt": "2020-09-15T05:17:11Z", "author": {"login": "Shajan"}, "path": "tensorflow-core/tensorflow-core-api/src/test/resources/saved_model_using_python/readme.txt", "diffHunk": "@@ -0,0 +1,45 @@\n+Saved model created using Python @tf.function, tensorflow version 2.3.0.\n+\n+Python code used to create saved model below:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNDA1MA=="}, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 3}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3456, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}