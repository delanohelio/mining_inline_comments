{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg1NDIxNzQ3", "number": 112, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTowMjowNVrOEisOgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTowMzoyM1rOEkrpCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODExNjQ4OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/ConcreteFunction.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTowMjowNVrOHQtwug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwMToxNDo0OVrOIerk9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI4OTAxOA==", "bodyText": "Are we guaranteed that the iteration order of the signature's outputs map is consistent?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487289018", "createdAt": "2020-09-11T21:02:05Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/ConcreteFunction.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * ConcreteFunction myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class ConcreteFunction implements AutoCloseable {\n+\n+  /**\n+   * Creates a function by building a new graph.\n+   *\n+   * <p/>The {@code functionBuilder} must initialize the function graph from the provided\n+   * {@link Ops} instance and return a valid signature that will be used to feed the input tensors\n+   * and fetch the output tensors on execution.\n+   *\n+   * <p/>The function will be the owner of the new graph and its resulting session. Therefore,\n+   * the function must be enclosed properly with a try-with-resources block to guarantee that\n+   * all native resources will be freed once the function is discarded. For example:\n+   *\n+   * <pre>{@code\n+   * public class MyModel {\n+   *\n+   *   public static Signature addTwo(Ops tf) {\n+   *     Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *     Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *     return Signature.builder(\"addTwo\").input(\"x\", input).output(\"y\", output).build();\n+   *   }\n+   *\n+   *   public static void main(String args[]) {\n+   *     try (ConcreteFunction function = ConcreteFunction.create(MyModel::addTwo);\n+   *         Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *   }\n+   * }\n+   * }</pre>\n+   *\n+   * @param functionBuilder function builder\n+   * @return the new function\n+   */\n+  public static ConcreteFunction create(Function<Ops, Signature> functionBuilder) {\n+    Graph graph = new Graph();\n+    try {\n+      Ops tf = Ops.create(graph);\n+      Signature signature = functionBuilder.apply(tf);\n+      return new ConcreteFunction(signature, graph, new Session(graph), Ownership.GRAPH_AND_SESSION);\n+    } catch (Exception e) {\n+      graph.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Create a function from a signature and an existing graph.\n+   *\n+   * <p/>The function will keep the ownership of the session used to run the graph but not\n+   * the graph itself, meaning that the lifetime of the latter can extend beyond the scope\n+   * of the function. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (ConcreteFunction f = ConcreteFunction.create(signature, g);\n+   *       Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *     assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid and initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Graph graph) {\n+    return new ConcreteFunction(signature, graph, new Session(graph), Ownership.SESSION_ONLY);\n+  }\n+\n+  /**\n+   * Create a function from a signature and a valid graph session.\n+   *\n+   * <p/>The function will not own the session nor its graph, meaning that their lifetime\n+   * can extend beyond the scope of the function. Therefore the function does not need to be\n+   * closed after its usage. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (Session s = new Session(g)) {\n+   *     // Auto-closing the function just as an example but this is not required since it has\n+   *     // no effect\n+   *     try (ConcreteFunction f = ConcreteFunction.create(signature, s);\n+   *         Tensor<TFloat32> t = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *     // Session s is still valid at this point\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid session to an initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Session session) {\n+    return new ConcreteFunction(signature, session.graph(), session, Ownership.NONE);\n+  }\n+\n+  /**\n+   * Returns the signature of this function\n+   */\n+  public Signature signature() {\n+    return signature;\n+  }\n+\n+  /**\n+   * Invokes a function.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   */\n+  public Map<String, Tensor<?>> call(Map<String, Tensor<?>> arguments)\n+      throws IllegalArgumentException {\n+\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+    final Session.Runner runner = session.runner();\n+\n+    signatureDef.getInputsMap().forEach((argName, t) -> {\n+      Tensor<?> tensor = arguments.get(argName);\n+      if (tensor == null) {\n+        throw new IllegalArgumentException(String.format(\"Missing argument [%s]\", argName));\n+      }\n+      runner.feed(t.getName(), tensor);\n+    });\n+\n+    Map<String, TensorInfo> outputToNode = signatureDef.getOutputsMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzU3MDI1NQ==", "bodyText": "Good observation, the ordering of signature's output map need not be consistent.\nHere is why:\nWe depend on the ordering of output returned in the call  List<Tensor<?>> resultTensors = runner.run(). Which depends on the order we pass in at runner.fetch(t.getName()), that happens to be the iteration order of signatureDef.getOutputsMap().\nIn runHelper, See creation of outputOpIndices based on order of outputs.add(output), which gets passed into Session.run(..)\nSession.run uses outputOpIndices as the order of output, which is implemented in resolveOutputs and TF_Output", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487570255", "createdAt": "2020-09-13T19:53:26Z", "author": {"login": "Shajan"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/ConcreteFunction.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * ConcreteFunction myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class ConcreteFunction implements AutoCloseable {\n+\n+  /**\n+   * Creates a function by building a new graph.\n+   *\n+   * <p/>The {@code functionBuilder} must initialize the function graph from the provided\n+   * {@link Ops} instance and return a valid signature that will be used to feed the input tensors\n+   * and fetch the output tensors on execution.\n+   *\n+   * <p/>The function will be the owner of the new graph and its resulting session. Therefore,\n+   * the function must be enclosed properly with a try-with-resources block to guarantee that\n+   * all native resources will be freed once the function is discarded. For example:\n+   *\n+   * <pre>{@code\n+   * public class MyModel {\n+   *\n+   *   public static Signature addTwo(Ops tf) {\n+   *     Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *     Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *     return Signature.builder(\"addTwo\").input(\"x\", input).output(\"y\", output).build();\n+   *   }\n+   *\n+   *   public static void main(String args[]) {\n+   *     try (ConcreteFunction function = ConcreteFunction.create(MyModel::addTwo);\n+   *         Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *   }\n+   * }\n+   * }</pre>\n+   *\n+   * @param functionBuilder function builder\n+   * @return the new function\n+   */\n+  public static ConcreteFunction create(Function<Ops, Signature> functionBuilder) {\n+    Graph graph = new Graph();\n+    try {\n+      Ops tf = Ops.create(graph);\n+      Signature signature = functionBuilder.apply(tf);\n+      return new ConcreteFunction(signature, graph, new Session(graph), Ownership.GRAPH_AND_SESSION);\n+    } catch (Exception e) {\n+      graph.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Create a function from a signature and an existing graph.\n+   *\n+   * <p/>The function will keep the ownership of the session used to run the graph but not\n+   * the graph itself, meaning that the lifetime of the latter can extend beyond the scope\n+   * of the function. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (ConcreteFunction f = ConcreteFunction.create(signature, g);\n+   *       Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *     assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid and initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Graph graph) {\n+    return new ConcreteFunction(signature, graph, new Session(graph), Ownership.SESSION_ONLY);\n+  }\n+\n+  /**\n+   * Create a function from a signature and a valid graph session.\n+   *\n+   * <p/>The function will not own the session nor its graph, meaning that their lifetime\n+   * can extend beyond the scope of the function. Therefore the function does not need to be\n+   * closed after its usage. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (Session s = new Session(g)) {\n+   *     // Auto-closing the function just as an example but this is not required since it has\n+   *     // no effect\n+   *     try (ConcreteFunction f = ConcreteFunction.create(signature, s);\n+   *         Tensor<TFloat32> t = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *     // Session s is still valid at this point\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid session to an initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Session session) {\n+    return new ConcreteFunction(signature, session.graph(), session, Ownership.NONE);\n+  }\n+\n+  /**\n+   * Returns the signature of this function\n+   */\n+  public Signature signature() {\n+    return signature;\n+  }\n+\n+  /**\n+   * Invokes a function.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   */\n+  public Map<String, Tensor<?>> call(Map<String, Tensor<?>> arguments)\n+      throws IllegalArgumentException {\n+\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+    final Session.Runner runner = session.runner();\n+\n+    signatureDef.getInputsMap().forEach((argName, t) -> {\n+      Tensor<?> tensor = arguments.get(argName);\n+      if (tensor == null) {\n+        throw new IllegalArgumentException(String.format(\"Missing argument [%s]\", argName));\n+      }\n+      runner.feed(t.getName(), tensor);\n+    });\n+\n+    Map<String, TensorInfo> outputToNode = signatureDef.getOutputsMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI4OTAxOA=="}, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk1OTU2MA==", "bodyText": "So it will be consistent within an execution of call but could change across different VM executions if the signatureDef.getOutputsMap() is backed by a regular HashMap rather than a LinkedHashMap?\nI ask because we have a tendency to iterate the value set of maps in demo code, and I don't want users to think those will be consistent if they aren't. Usually it's because there is only a single output, but if we're not maintaining ordering then people might be confused  if they try to apply what we do in the demos/tests to larger problems.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487959560", "createdAt": "2020-09-14T14:11:52Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/ConcreteFunction.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * ConcreteFunction myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class ConcreteFunction implements AutoCloseable {\n+\n+  /**\n+   * Creates a function by building a new graph.\n+   *\n+   * <p/>The {@code functionBuilder} must initialize the function graph from the provided\n+   * {@link Ops} instance and return a valid signature that will be used to feed the input tensors\n+   * and fetch the output tensors on execution.\n+   *\n+   * <p/>The function will be the owner of the new graph and its resulting session. Therefore,\n+   * the function must be enclosed properly with a try-with-resources block to guarantee that\n+   * all native resources will be freed once the function is discarded. For example:\n+   *\n+   * <pre>{@code\n+   * public class MyModel {\n+   *\n+   *   public static Signature addTwo(Ops tf) {\n+   *     Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *     Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *     return Signature.builder(\"addTwo\").input(\"x\", input).output(\"y\", output).build();\n+   *   }\n+   *\n+   *   public static void main(String args[]) {\n+   *     try (ConcreteFunction function = ConcreteFunction.create(MyModel::addTwo);\n+   *         Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *   }\n+   * }\n+   * }</pre>\n+   *\n+   * @param functionBuilder function builder\n+   * @return the new function\n+   */\n+  public static ConcreteFunction create(Function<Ops, Signature> functionBuilder) {\n+    Graph graph = new Graph();\n+    try {\n+      Ops tf = Ops.create(graph);\n+      Signature signature = functionBuilder.apply(tf);\n+      return new ConcreteFunction(signature, graph, new Session(graph), Ownership.GRAPH_AND_SESSION);\n+    } catch (Exception e) {\n+      graph.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Create a function from a signature and an existing graph.\n+   *\n+   * <p/>The function will keep the ownership of the session used to run the graph but not\n+   * the graph itself, meaning that the lifetime of the latter can extend beyond the scope\n+   * of the function. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (ConcreteFunction f = ConcreteFunction.create(signature, g);\n+   *       Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *     assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid and initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Graph graph) {\n+    return new ConcreteFunction(signature, graph, new Session(graph), Ownership.SESSION_ONLY);\n+  }\n+\n+  /**\n+   * Create a function from a signature and a valid graph session.\n+   *\n+   * <p/>The function will not own the session nor its graph, meaning that their lifetime\n+   * can extend beyond the scope of the function. Therefore the function does not need to be\n+   * closed after its usage. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (Session s = new Session(g)) {\n+   *     // Auto-closing the function just as an example but this is not required since it has\n+   *     // no effect\n+   *     try (ConcreteFunction f = ConcreteFunction.create(signature, s);\n+   *         Tensor<TFloat32> t = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *     // Session s is still valid at this point\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid session to an initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Session session) {\n+    return new ConcreteFunction(signature, session.graph(), session, Ownership.NONE);\n+  }\n+\n+  /**\n+   * Returns the signature of this function\n+   */\n+  public Signature signature() {\n+    return signature;\n+  }\n+\n+  /**\n+   * Invokes a function.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   */\n+  public Map<String, Tensor<?>> call(Map<String, Tensor<?>> arguments)\n+      throws IllegalArgumentException {\n+\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+    final Session.Runner runner = session.runner();\n+\n+    signatureDef.getInputsMap().forEach((argName, t) -> {\n+      Tensor<?> tensor = arguments.get(argName);\n+      if (tensor == null) {\n+        throw new IllegalArgumentException(String.format(\"Missing argument [%s]\", argName));\n+      }\n+      runner.feed(t.getName(), tensor);\n+    });\n+\n+    Map<String, TensorInfo> outputToNode = signatureDef.getOutputsMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI4OTAxOA=="}, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyNTAyNw==", "bodyText": "The order we fetch the tensors does not really matter, as we don't return the outputs as a list but as a map, forcing the user to retrieve them by name instead of by ordinal position, like Session.Run does. And since this is not demo code neither, I think it is safe enough to leave it as is.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r489125027", "createdAt": "2020-09-16T02:32:02Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/ConcreteFunction.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * ConcreteFunction myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class ConcreteFunction implements AutoCloseable {\n+\n+  /**\n+   * Creates a function by building a new graph.\n+   *\n+   * <p/>The {@code functionBuilder} must initialize the function graph from the provided\n+   * {@link Ops} instance and return a valid signature that will be used to feed the input tensors\n+   * and fetch the output tensors on execution.\n+   *\n+   * <p/>The function will be the owner of the new graph and its resulting session. Therefore,\n+   * the function must be enclosed properly with a try-with-resources block to guarantee that\n+   * all native resources will be freed once the function is discarded. For example:\n+   *\n+   * <pre>{@code\n+   * public class MyModel {\n+   *\n+   *   public static Signature addTwo(Ops tf) {\n+   *     Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *     Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *     return Signature.builder(\"addTwo\").input(\"x\", input).output(\"y\", output).build();\n+   *   }\n+   *\n+   *   public static void main(String args[]) {\n+   *     try (ConcreteFunction function = ConcreteFunction.create(MyModel::addTwo);\n+   *         Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *   }\n+   * }\n+   * }</pre>\n+   *\n+   * @param functionBuilder function builder\n+   * @return the new function\n+   */\n+  public static ConcreteFunction create(Function<Ops, Signature> functionBuilder) {\n+    Graph graph = new Graph();\n+    try {\n+      Ops tf = Ops.create(graph);\n+      Signature signature = functionBuilder.apply(tf);\n+      return new ConcreteFunction(signature, graph, new Session(graph), Ownership.GRAPH_AND_SESSION);\n+    } catch (Exception e) {\n+      graph.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Create a function from a signature and an existing graph.\n+   *\n+   * <p/>The function will keep the ownership of the session used to run the graph but not\n+   * the graph itself, meaning that the lifetime of the latter can extend beyond the scope\n+   * of the function. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (ConcreteFunction f = ConcreteFunction.create(signature, g);\n+   *       Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *     assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid and initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Graph graph) {\n+    return new ConcreteFunction(signature, graph, new Session(graph), Ownership.SESSION_ONLY);\n+  }\n+\n+  /**\n+   * Create a function from a signature and a valid graph session.\n+   *\n+   * <p/>The function will not own the session nor its graph, meaning that their lifetime\n+   * can extend beyond the scope of the function. Therefore the function does not need to be\n+   * closed after its usage. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (Session s = new Session(g)) {\n+   *     // Auto-closing the function just as an example but this is not required since it has\n+   *     // no effect\n+   *     try (ConcreteFunction f = ConcreteFunction.create(signature, s);\n+   *         Tensor<TFloat32> t = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *     // Session s is still valid at this point\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid session to an initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Session session) {\n+    return new ConcreteFunction(signature, session.graph(), session, Ownership.NONE);\n+  }\n+\n+  /**\n+   * Returns the signature of this function\n+   */\n+  public Signature signature() {\n+    return signature;\n+  }\n+\n+  /**\n+   * Invokes a function.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   */\n+  public Map<String, Tensor<?>> call(Map<String, Tensor<?>> arguments)\n+      throws IllegalArgumentException {\n+\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+    final Session.Runner runner = session.runner();\n+\n+    signatureDef.getInputsMap().forEach((argName, t) -> {\n+      Tensor<?> tensor = arguments.get(argName);\n+      if (tensor == null) {\n+        throw new IllegalArgumentException(String.format(\"Missing argument [%s]\", argName));\n+      }\n+      runner.feed(t.getName(), tensor);\n+    });\n+\n+    Map<String, TensorInfo> outputToNode = signatureDef.getOutputsMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI4OTAxOA=="}, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODk2NzUyNA==", "bodyText": "Is this really correct? One line does outputToNode.values().forEach(t -> runner.fetch(t.getName())); and the other for (String nodeName: outputToNode.keySet()) { - is there any guarantee of consistent ordering between values() and keySet()!?\nThe code very much depends on this and there's no test to confirm (ConcreteFunctionTest.java only uses the simpler call()-method).", "url": "https://github.com/tensorflow/java/pull/112#discussion_r568967524", "createdAt": "2021-02-02T22:13:10Z", "author": {"login": "jxtps"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/ConcreteFunction.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * ConcreteFunction myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class ConcreteFunction implements AutoCloseable {\n+\n+  /**\n+   * Creates a function by building a new graph.\n+   *\n+   * <p/>The {@code functionBuilder} must initialize the function graph from the provided\n+   * {@link Ops} instance and return a valid signature that will be used to feed the input tensors\n+   * and fetch the output tensors on execution.\n+   *\n+   * <p/>The function will be the owner of the new graph and its resulting session. Therefore,\n+   * the function must be enclosed properly with a try-with-resources block to guarantee that\n+   * all native resources will be freed once the function is discarded. For example:\n+   *\n+   * <pre>{@code\n+   * public class MyModel {\n+   *\n+   *   public static Signature addTwo(Ops tf) {\n+   *     Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *     Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *     return Signature.builder(\"addTwo\").input(\"x\", input).output(\"y\", output).build();\n+   *   }\n+   *\n+   *   public static void main(String args[]) {\n+   *     try (ConcreteFunction function = ConcreteFunction.create(MyModel::addTwo);\n+   *         Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *   }\n+   * }\n+   * }</pre>\n+   *\n+   * @param functionBuilder function builder\n+   * @return the new function\n+   */\n+  public static ConcreteFunction create(Function<Ops, Signature> functionBuilder) {\n+    Graph graph = new Graph();\n+    try {\n+      Ops tf = Ops.create(graph);\n+      Signature signature = functionBuilder.apply(tf);\n+      return new ConcreteFunction(signature, graph, new Session(graph), Ownership.GRAPH_AND_SESSION);\n+    } catch (Exception e) {\n+      graph.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Create a function from a signature and an existing graph.\n+   *\n+   * <p/>The function will keep the ownership of the session used to run the graph but not\n+   * the graph itself, meaning that the lifetime of the latter can extend beyond the scope\n+   * of the function. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (ConcreteFunction f = ConcreteFunction.create(signature, g);\n+   *       Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *     assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid and initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Graph graph) {\n+    return new ConcreteFunction(signature, graph, new Session(graph), Ownership.SESSION_ONLY);\n+  }\n+\n+  /**\n+   * Create a function from a signature and a valid graph session.\n+   *\n+   * <p/>The function will not own the session nor its graph, meaning that their lifetime\n+   * can extend beyond the scope of the function. Therefore the function does not need to be\n+   * closed after its usage. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (Session s = new Session(g)) {\n+   *     // Auto-closing the function just as an example but this is not required since it has\n+   *     // no effect\n+   *     try (ConcreteFunction f = ConcreteFunction.create(signature, s);\n+   *         Tensor<TFloat32> t = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *     // Session s is still valid at this point\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid session to an initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Session session) {\n+    return new ConcreteFunction(signature, session.graph(), session, Ownership.NONE);\n+  }\n+\n+  /**\n+   * Returns the signature of this function\n+   */\n+  public Signature signature() {\n+    return signature;\n+  }\n+\n+  /**\n+   * Invokes a function.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   */\n+  public Map<String, Tensor<?>> call(Map<String, Tensor<?>> arguments)\n+      throws IllegalArgumentException {\n+\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+    final Session.Runner runner = session.runner();\n+\n+    signatureDef.getInputsMap().forEach((argName, t) -> {\n+      Tensor<?> tensor = arguments.get(argName);\n+      if (tensor == null) {\n+        throw new IllegalArgumentException(String.format(\"Missing argument [%s]\", argName));\n+      }\n+      runner.feed(t.getName(), tensor);\n+    });\n+\n+    Map<String, TensorInfo> outputToNode = signatureDef.getOutputsMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI4OTAxOA=="}, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTAzMTMwMQ==", "bodyText": "Protobuf uses LinkedHashMap internally, so yeah it's fine.  Wouldn't be a bad idea to convert it to one manually though.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r569031301", "createdAt": "2021-02-03T00:44:49Z", "author": {"login": "rnett"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/ConcreteFunction.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * ConcreteFunction myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class ConcreteFunction implements AutoCloseable {\n+\n+  /**\n+   * Creates a function by building a new graph.\n+   *\n+   * <p/>The {@code functionBuilder} must initialize the function graph from the provided\n+   * {@link Ops} instance and return a valid signature that will be used to feed the input tensors\n+   * and fetch the output tensors on execution.\n+   *\n+   * <p/>The function will be the owner of the new graph and its resulting session. Therefore,\n+   * the function must be enclosed properly with a try-with-resources block to guarantee that\n+   * all native resources will be freed once the function is discarded. For example:\n+   *\n+   * <pre>{@code\n+   * public class MyModel {\n+   *\n+   *   public static Signature addTwo(Ops tf) {\n+   *     Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *     Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *     return Signature.builder(\"addTwo\").input(\"x\", input).output(\"y\", output).build();\n+   *   }\n+   *\n+   *   public static void main(String args[]) {\n+   *     try (ConcreteFunction function = ConcreteFunction.create(MyModel::addTwo);\n+   *         Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *   }\n+   * }\n+   * }</pre>\n+   *\n+   * @param functionBuilder function builder\n+   * @return the new function\n+   */\n+  public static ConcreteFunction create(Function<Ops, Signature> functionBuilder) {\n+    Graph graph = new Graph();\n+    try {\n+      Ops tf = Ops.create(graph);\n+      Signature signature = functionBuilder.apply(tf);\n+      return new ConcreteFunction(signature, graph, new Session(graph), Ownership.GRAPH_AND_SESSION);\n+    } catch (Exception e) {\n+      graph.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Create a function from a signature and an existing graph.\n+   *\n+   * <p/>The function will keep the ownership of the session used to run the graph but not\n+   * the graph itself, meaning that the lifetime of the latter can extend beyond the scope\n+   * of the function. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (ConcreteFunction f = ConcreteFunction.create(signature, g);\n+   *       Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *     assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid and initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Graph graph) {\n+    return new ConcreteFunction(signature, graph, new Session(graph), Ownership.SESSION_ONLY);\n+  }\n+\n+  /**\n+   * Create a function from a signature and a valid graph session.\n+   *\n+   * <p/>The function will not own the session nor its graph, meaning that their lifetime\n+   * can extend beyond the scope of the function. Therefore the function does not need to be\n+   * closed after its usage. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (Session s = new Session(g)) {\n+   *     // Auto-closing the function just as an example but this is not required since it has\n+   *     // no effect\n+   *     try (ConcreteFunction f = ConcreteFunction.create(signature, s);\n+   *         Tensor<TFloat32> t = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *     // Session s is still valid at this point\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid session to an initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Session session) {\n+    return new ConcreteFunction(signature, session.graph(), session, Ownership.NONE);\n+  }\n+\n+  /**\n+   * Returns the signature of this function\n+   */\n+  public Signature signature() {\n+    return signature;\n+  }\n+\n+  /**\n+   * Invokes a function.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   */\n+  public Map<String, Tensor<?>> call(Map<String, Tensor<?>> arguments)\n+      throws IllegalArgumentException {\n+\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+    final Session.Runner runner = session.runner();\n+\n+    signatureDef.getInputsMap().forEach((argName, t) -> {\n+      Tensor<?> tensor = arguments.get(argName);\n+      if (tensor == null) {\n+        throw new IllegalArgumentException(String.format(\"Missing argument [%s]\", argName));\n+      }\n+      runner.feed(t.getName(), tensor);\n+    });\n+\n+    Map<String, TensorInfo> outputToNode = signatureDef.getOutputsMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI4OTAxOA=="}, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA0MDAzOQ==", "bodyText": "Maybe use .values() in both to raise fewer red flags? Though relying on a Map producing the same values() order is perhaps also questionable?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r569040039", "createdAt": "2021-02-03T01:08:31Z", "author": {"login": "jxtps"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/ConcreteFunction.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * ConcreteFunction myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class ConcreteFunction implements AutoCloseable {\n+\n+  /**\n+   * Creates a function by building a new graph.\n+   *\n+   * <p/>The {@code functionBuilder} must initialize the function graph from the provided\n+   * {@link Ops} instance and return a valid signature that will be used to feed the input tensors\n+   * and fetch the output tensors on execution.\n+   *\n+   * <p/>The function will be the owner of the new graph and its resulting session. Therefore,\n+   * the function must be enclosed properly with a try-with-resources block to guarantee that\n+   * all native resources will be freed once the function is discarded. For example:\n+   *\n+   * <pre>{@code\n+   * public class MyModel {\n+   *\n+   *   public static Signature addTwo(Ops tf) {\n+   *     Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *     Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *     return Signature.builder(\"addTwo\").input(\"x\", input).output(\"y\", output).build();\n+   *   }\n+   *\n+   *   public static void main(String args[]) {\n+   *     try (ConcreteFunction function = ConcreteFunction.create(MyModel::addTwo);\n+   *         Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *   }\n+   * }\n+   * }</pre>\n+   *\n+   * @param functionBuilder function builder\n+   * @return the new function\n+   */\n+  public static ConcreteFunction create(Function<Ops, Signature> functionBuilder) {\n+    Graph graph = new Graph();\n+    try {\n+      Ops tf = Ops.create(graph);\n+      Signature signature = functionBuilder.apply(tf);\n+      return new ConcreteFunction(signature, graph, new Session(graph), Ownership.GRAPH_AND_SESSION);\n+    } catch (Exception e) {\n+      graph.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Create a function from a signature and an existing graph.\n+   *\n+   * <p/>The function will keep the ownership of the session used to run the graph but not\n+   * the graph itself, meaning that the lifetime of the latter can extend beyond the scope\n+   * of the function. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (ConcreteFunction f = ConcreteFunction.create(signature, g);\n+   *       Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *     assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid and initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Graph graph) {\n+    return new ConcreteFunction(signature, graph, new Session(graph), Ownership.SESSION_ONLY);\n+  }\n+\n+  /**\n+   * Create a function from a signature and a valid graph session.\n+   *\n+   * <p/>The function will not own the session nor its graph, meaning that their lifetime\n+   * can extend beyond the scope of the function. Therefore the function does not need to be\n+   * closed after its usage. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (Session s = new Session(g)) {\n+   *     // Auto-closing the function just as an example but this is not required since it has\n+   *     // no effect\n+   *     try (ConcreteFunction f = ConcreteFunction.create(signature, s);\n+   *         Tensor<TFloat32> t = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *     // Session s is still valid at this point\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid session to an initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Session session) {\n+    return new ConcreteFunction(signature, session.graph(), session, Ownership.NONE);\n+  }\n+\n+  /**\n+   * Returns the signature of this function\n+   */\n+  public Signature signature() {\n+    return signature;\n+  }\n+\n+  /**\n+   * Invokes a function.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   */\n+  public Map<String, Tensor<?>> call(Map<String, Tensor<?>> arguments)\n+      throws IllegalArgumentException {\n+\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+    final Session.Runner runner = session.runner();\n+\n+    signatureDef.getInputsMap().forEach((argName, t) -> {\n+      Tensor<?> tensor = arguments.get(argName);\n+      if (tensor == null) {\n+        throw new IllegalArgumentException(String.format(\"Missing argument [%s]\", argName));\n+      }\n+      runner.feed(t.getName(), tensor);\n+    });\n+\n+    Map<String, TensorInfo> outputToNode = signatureDef.getOutputsMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI4OTAxOA=="}, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTA0MjE2Nw==", "bodyText": "Not if it's a LinkedHashMap, that's the point of the class, it provides stable iteration over a Map with minimal overhead.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r569042167", "createdAt": "2021-02-03T01:14:49Z", "author": {"login": "rnett"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/ConcreteFunction.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * ConcreteFunction myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class ConcreteFunction implements AutoCloseable {\n+\n+  /**\n+   * Creates a function by building a new graph.\n+   *\n+   * <p/>The {@code functionBuilder} must initialize the function graph from the provided\n+   * {@link Ops} instance and return a valid signature that will be used to feed the input tensors\n+   * and fetch the output tensors on execution.\n+   *\n+   * <p/>The function will be the owner of the new graph and its resulting session. Therefore,\n+   * the function must be enclosed properly with a try-with-resources block to guarantee that\n+   * all native resources will be freed once the function is discarded. For example:\n+   *\n+   * <pre>{@code\n+   * public class MyModel {\n+   *\n+   *   public static Signature addTwo(Ops tf) {\n+   *     Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *     Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *     return Signature.builder(\"addTwo\").input(\"x\", input).output(\"y\", output).build();\n+   *   }\n+   *\n+   *   public static void main(String args[]) {\n+   *     try (ConcreteFunction function = ConcreteFunction.create(MyModel::addTwo);\n+   *         Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *   }\n+   * }\n+   * }</pre>\n+   *\n+   * @param functionBuilder function builder\n+   * @return the new function\n+   */\n+  public static ConcreteFunction create(Function<Ops, Signature> functionBuilder) {\n+    Graph graph = new Graph();\n+    try {\n+      Ops tf = Ops.create(graph);\n+      Signature signature = functionBuilder.apply(tf);\n+      return new ConcreteFunction(signature, graph, new Session(graph), Ownership.GRAPH_AND_SESSION);\n+    } catch (Exception e) {\n+      graph.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Create a function from a signature and an existing graph.\n+   *\n+   * <p/>The function will keep the ownership of the session used to run the graph but not\n+   * the graph itself, meaning that the lifetime of the latter can extend beyond the scope\n+   * of the function. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (ConcreteFunction f = ConcreteFunction.create(signature, g);\n+   *       Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *     assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid and initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Graph graph) {\n+    return new ConcreteFunction(signature, graph, new Session(graph), Ownership.SESSION_ONLY);\n+  }\n+\n+  /**\n+   * Create a function from a signature and a valid graph session.\n+   *\n+   * <p/>The function will not own the session nor its graph, meaning that their lifetime\n+   * can extend beyond the scope of the function. Therefore the function does not need to be\n+   * closed after its usage. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (Session s = new Session(g)) {\n+   *     // Auto-closing the function just as an example but this is not required since it has\n+   *     // no effect\n+   *     try (ConcreteFunction f = ConcreteFunction.create(signature, s);\n+   *         Tensor<TFloat32> t = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *     // Session s is still valid at this point\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid session to an initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Session session) {\n+    return new ConcreteFunction(signature, session.graph(), session, Ownership.NONE);\n+  }\n+\n+  /**\n+   * Returns the signature of this function\n+   */\n+  public Signature signature() {\n+    return signature;\n+  }\n+\n+  /**\n+   * Invokes a function.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   */\n+  public Map<String, Tensor<?>> call(Map<String, Tensor<?>> arguments)\n+      throws IllegalArgumentException {\n+\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+    final Session.Runner runner = session.runner();\n+\n+    signatureDef.getInputsMap().forEach((argName, t) -> {\n+      Tensor<?> tensor = arguments.get(argName);\n+      if (tensor == null) {\n+        throw new IllegalArgumentException(String.format(\"Missing argument [%s]\", argName));\n+      }\n+      runner.feed(t.getName(), tensor);\n+    });\n+\n+    Map<String, TensorInfo> outputToNode = signatureDef.getOutputsMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI4OTAxOA=="}, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODExNzk3OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/ConcreteFunction.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTowMjo0MFrOHQtxmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTowMjo0MFrOHQtxmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzI4OTI0Mw==", "bodyText": "Document the IOException with @throws?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487289243", "createdAt": "2020-09-11T21:02:40Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/ConcreteFunction.java", "diffHunk": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * ConcreteFunction myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class ConcreteFunction implements AutoCloseable {\n+\n+  /**\n+   * Creates a function by building a new graph.\n+   *\n+   * <p/>The {@code functionBuilder} must initialize the function graph from the provided\n+   * {@link Ops} instance and return a valid signature that will be used to feed the input tensors\n+   * and fetch the output tensors on execution.\n+   *\n+   * <p/>The function will be the owner of the new graph and its resulting session. Therefore,\n+   * the function must be enclosed properly with a try-with-resources block to guarantee that\n+   * all native resources will be freed once the function is discarded. For example:\n+   *\n+   * <pre>{@code\n+   * public class MyModel {\n+   *\n+   *   public static Signature addTwo(Ops tf) {\n+   *     Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *     Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *     return Signature.builder(\"addTwo\").input(\"x\", input).output(\"y\", output).build();\n+   *   }\n+   *\n+   *   public static void main(String args[]) {\n+   *     try (ConcreteFunction function = ConcreteFunction.create(MyModel::addTwo);\n+   *         Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *   }\n+   * }\n+   * }</pre>\n+   *\n+   * @param functionBuilder function builder\n+   * @return the new function\n+   */\n+  public static ConcreteFunction create(Function<Ops, Signature> functionBuilder) {\n+    Graph graph = new Graph();\n+    try {\n+      Ops tf = Ops.create(graph);\n+      Signature signature = functionBuilder.apply(tf);\n+      return new ConcreteFunction(signature, graph, new Session(graph), Ownership.GRAPH_AND_SESSION);\n+    } catch (Exception e) {\n+      graph.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Create a function from a signature and an existing graph.\n+   *\n+   * <p/>The function will keep the ownership of the session used to run the graph but not\n+   * the graph itself, meaning that the lifetime of the latter can extend beyond the scope\n+   * of the function. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (ConcreteFunction f = ConcreteFunction.create(signature, g);\n+   *       Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *     assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid and initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Graph graph) {\n+    return new ConcreteFunction(signature, graph, new Session(graph), Ownership.SESSION_ONLY);\n+  }\n+\n+  /**\n+   * Create a function from a signature and a valid graph session.\n+   *\n+   * <p/>The function will not own the session nor its graph, meaning that their lifetime\n+   * can extend beyond the scope of the function. Therefore the function does not need to be\n+   * closed after its usage. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (Session s = new Session(g)) {\n+   *     // Auto-closing the function just as an example but this is not required since it has\n+   *     // no effect\n+   *     try (ConcreteFunction f = ConcreteFunction.create(signature, s);\n+   *         Tensor<TFloat32> t = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *     // Session s is still valid at this point\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid session to an initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Session session) {\n+    return new ConcreteFunction(signature, session.graph(), session, Ownership.NONE);\n+  }\n+\n+  /**\n+   * Returns the signature of this function\n+   */\n+  public Signature signature() {\n+    return signature;\n+  }\n+\n+  /**\n+   * Invokes a function.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   */\n+  public Map<String, Tensor<?>> call(Map<String, Tensor<?>> arguments)\n+      throws IllegalArgumentException {\n+\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+    final Session.Runner runner = session.runner();\n+\n+    signatureDef.getInputsMap().forEach((argName, t) -> {\n+      Tensor<?> tensor = arguments.get(argName);\n+      if (tensor == null) {\n+        throw new IllegalArgumentException(String.format(\"Missing argument [%s]\", argName));\n+      }\n+      runner.feed(t.getName(), tensor);\n+    });\n+\n+    Map<String, TensorInfo> outputToNode = signatureDef.getOutputsMap();\n+    outputToNode.values().forEach(t -> runner.fetch(t.getName()));\n+\n+    List<Tensor<?>> resultTensors = runner.run();\n+    try {\n+      ListIterator<Tensor<?>> resultTensorIter = resultTensors.listIterator();\n+      Map<String, Tensor<?>> returnMap = new HashMap<String, Tensor<?>>();\n+\n+      // Use the output names as present in the signature definition\n+      for (String nodeName: outputToNode.keySet()) {\n+        returnMap.put(nodeName, resultTensorIter.next());\n+      }\n+      return returnMap;\n+\n+    } catch (Exception e) {\n+      // Release tensors before throwing exception\n+      for (Tensor<?> t : resultTensors) {\n+        t.close();\n+      }\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Invokes a function with a single input and output.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   * @throws IllegalArgumentException if there are multiple input or output parameters defined\n+   *                                  in the function\n+   */\n+  public Tensor<?> call(Tensor<?> tensor) throws IllegalArgumentException {\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+\n+    if (signatureDef.getInputsCount() != 1) {\n+      throw new IllegalArgumentException(\n+        String.format(\"Function [%s] requires multiple inputs\", signatureDef.getMethodName()));\n+    }\n+    String inputNodeName = signatureDef.getInputsMap().values().iterator().next().getName();\n+\n+    if (signatureDef.getOutputsCount() != 1) {\n+      throw new IllegalArgumentException(\n+        String.format(\"Function [%s] has multiple outputs\", signatureDef.getMethodName()));\n+    }\n+    String outputNodeName = signatureDef.getOutputsMap().values().iterator().next().getName();\n+\n+    return session.runner().feed(inputNodeName, tensor).fetch(outputNodeName).run().get(0);\n+  }\n+\n+  /**\n+   * Export this function as a saved model.\n+   *\n+   * <p>This method is convenient shortcut equivalent to\n+   * {@code SavedModel.exporter(exportDir).withFunction(this).export()}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODIwMzY3OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTozODozMlrOHQulIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTozODozMlrOHQulIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwMjQzNQ==", "bodyText": "Should we validate that the tags are non-empty Strings?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487302435", "createdAt": "2020-09-11T21:38:32Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "diffHunk": "@@ -77,10 +94,14 @@ public Loader withConfigProto(ConfigProto configProto) {\n     /**\n      * Sets the set of tags that identify the specific graph in the saved model to load.\n      *\n+     * <p>Has no effect if {@code tags} is null or empty\n+     *\n      * @param tags the tags identifying the specific MetaGraphDef to load.\n      */\n     public Loader withTags(String... tags) {\n-      this.tags = tags;\n+      if (tags != null && tags.length > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODIwNzE1OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTo0MDowN1rOHQunPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNDoxNjowMVrOHRW9VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwMjk3Mw==", "bodyText": "It's a bit odd that tags in the Loader is an array, and tags here is an ArrayList. Is there a reason for the difference?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487302973", "createdAt": "2020-09-11T21:40:07Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "diffHunk": "@@ -89,11 +110,107 @@ private Loader(String exportDir) {\n     }\n \n     private String exportDir = null;\n-    private String[] tags = null;\n+    private String[] tags = {DEFAULT_TAG};\n     private ConfigProto configProto = null;\n     private RunOptions runOptions = null;\n   }\n \n+  /** Options for exporting a SavedModel. */\n+  public static final class Exporter {\n+\n+    /**\n+     * Sets the set of tags that identify the specific graph in the saved model to save.\n+     *\n+     * <p/>Note that only one graph per model can be saved right now using this API.\n+     *\n+     * @param tags the tags identifying the specific MetaGraphDef to save.\n+     * @return this object\n+     */\n+    public Exporter withTags(String... tags) {\n+      this.tags.addAll(Arrays.asList(tags));\n+      return this;\n+    }\n+\n+    /**\n+     * Save a concrete function of this model.\n+     *\n+     * <p/>The concrete function carries a signature (i.e. a list of user-friendly input and outputs\n+     * names to a graph) and a valid session to a graph to be saved in the model.\n+     *\n+     * <p/><i>Note:Eventually, TensorFlow for Java will support the export of functions objects like\n+     * the Python API does but right now, only session-centric models are supported (i.e. models that\n+     * has a single main graph and one or more signatures). These models are compatible with those\n+     * exported by TensorFlow 1.x or by TensorFlow 2.x estimators.\n+     *\n+     * <p>Therefore, all functions exported in a model should share the same session at the moment\n+     * or an exception will be thrown.</i>\n+     *\n+     * @param function a function carrying a signature and a valid session to the graph to be saved\n+     * @return this object\n+     * @throws IllegalArgumentException if a function with the same name has already been added to the model\n+     */\n+    public Exporter withFunction(ConcreteFunction function) {\n+      Signature signature = function.signature();\n+      if (functions.containsKey(signature.key())) {\n+        throw new IllegalArgumentException(\"Function \\\"\" + signature.key() + \"\\\" was already added to the model\");\n+      }\n+      functions.put(signature.key(), function);\n+      if (session == null) {\n+        session = function.session();\n+      } else if (session != function.session()) {\n+        throw new UnsupportedOperationException(\"Saving multiple functions with different graphs/sessions is not supported yet.\");\n+      }\n+      metaGraphDefBuilder.putSignatureDef(signature.key(), signature.asSignatureDef());\n+      return this;\n+    }\n+\n+    /**\n+     * Save the model into the export directory.\n+     *\n+     * @throws IOException if saved model or variable state can be written on disk\n+     */\n+    public void export() throws IOException {\n+      if (functions.isEmpty() || session == null) {\n+        throw new IllegalStateException(\"Model should contain at least one valid function\");\n+      }\n+      if (tags.isEmpty()) {\n+        tags.add(DEFAULT_TAG);\n+      }\n+      // It is imperative to retrieve the graphDef after the saverDef, as the former might add\n+      // new ops to the graph for saving and restoring the variables.\n+      Graph graph = session.graph();\n+      MetaGraphDef.Builder metaGraphDef = metaGraphDefBuilder\n+          .setSaverDef(graph.saverDef())\n+          .setGraphDef(graph.toGraphDef())\n+          .setMetaInfoDef(MetaInfoDef.newBuilder().addAllTags(tags));\n+      functions.forEach((k, f) -> metaGraphDef.putSignatureDef(k, f.signature().asSignatureDef()));\n+\n+      // Make sure saved model directories exist\n+      Path variableDir = Paths.get(exportDir, \"variables\");\n+      variableDir.toFile().mkdirs();\n+\n+      // Save the variables state\n+      session.save(variableDir.resolve(\"variables\").toString());\n+\n+      // Save the graph\n+      SavedModel savedModelDef = SavedModel.newBuilder().addMetaGraphs(metaGraphDef).build();\n+      try (OutputStream file =\n+          new FileOutputStream(Paths.get(exportDir, \"saved_model.pb\").toString())) {\n+        savedModelDef.writeTo(file);\n+      }\n+    }\n+\n+    Exporter(String exportDir) {\n+      this.exportDir = exportDir;\n+    }\n+\n+    private final String exportDir;\n+    private final List<String> tags = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2Mzk4OQ==", "bodyText": "Calling tags() on the exporter is cumulative, while calling it on the loader always resets the previous value. I agree that we can make this consistent, anyway tags in general are not very useful since most models only have a single tag, as suggested by TensorFlow.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487963989", "createdAt": "2020-09-14T14:16:01Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "diffHunk": "@@ -89,11 +110,107 @@ private Loader(String exportDir) {\n     }\n \n     private String exportDir = null;\n-    private String[] tags = null;\n+    private String[] tags = {DEFAULT_TAG};\n     private ConfigProto configProto = null;\n     private RunOptions runOptions = null;\n   }\n \n+  /** Options for exporting a SavedModel. */\n+  public static final class Exporter {\n+\n+    /**\n+     * Sets the set of tags that identify the specific graph in the saved model to save.\n+     *\n+     * <p/>Note that only one graph per model can be saved right now using this API.\n+     *\n+     * @param tags the tags identifying the specific MetaGraphDef to save.\n+     * @return this object\n+     */\n+    public Exporter withTags(String... tags) {\n+      this.tags.addAll(Arrays.asList(tags));\n+      return this;\n+    }\n+\n+    /**\n+     * Save a concrete function of this model.\n+     *\n+     * <p/>The concrete function carries a signature (i.e. a list of user-friendly input and outputs\n+     * names to a graph) and a valid session to a graph to be saved in the model.\n+     *\n+     * <p/><i>Note:Eventually, TensorFlow for Java will support the export of functions objects like\n+     * the Python API does but right now, only session-centric models are supported (i.e. models that\n+     * has a single main graph and one or more signatures). These models are compatible with those\n+     * exported by TensorFlow 1.x or by TensorFlow 2.x estimators.\n+     *\n+     * <p>Therefore, all functions exported in a model should share the same session at the moment\n+     * or an exception will be thrown.</i>\n+     *\n+     * @param function a function carrying a signature and a valid session to the graph to be saved\n+     * @return this object\n+     * @throws IllegalArgumentException if a function with the same name has already been added to the model\n+     */\n+    public Exporter withFunction(ConcreteFunction function) {\n+      Signature signature = function.signature();\n+      if (functions.containsKey(signature.key())) {\n+        throw new IllegalArgumentException(\"Function \\\"\" + signature.key() + \"\\\" was already added to the model\");\n+      }\n+      functions.put(signature.key(), function);\n+      if (session == null) {\n+        session = function.session();\n+      } else if (session != function.session()) {\n+        throw new UnsupportedOperationException(\"Saving multiple functions with different graphs/sessions is not supported yet.\");\n+      }\n+      metaGraphDefBuilder.putSignatureDef(signature.key(), signature.asSignatureDef());\n+      return this;\n+    }\n+\n+    /**\n+     * Save the model into the export directory.\n+     *\n+     * @throws IOException if saved model or variable state can be written on disk\n+     */\n+    public void export() throws IOException {\n+      if (functions.isEmpty() || session == null) {\n+        throw new IllegalStateException(\"Model should contain at least one valid function\");\n+      }\n+      if (tags.isEmpty()) {\n+        tags.add(DEFAULT_TAG);\n+      }\n+      // It is imperative to retrieve the graphDef after the saverDef, as the former might add\n+      // new ops to the graph for saving and restoring the variables.\n+      Graph graph = session.graph();\n+      MetaGraphDef.Builder metaGraphDef = metaGraphDefBuilder\n+          .setSaverDef(graph.saverDef())\n+          .setGraphDef(graph.toGraphDef())\n+          .setMetaInfoDef(MetaInfoDef.newBuilder().addAllTags(tags));\n+      functions.forEach((k, f) -> metaGraphDef.putSignatureDef(k, f.signature().asSignatureDef()));\n+\n+      // Make sure saved model directories exist\n+      Path variableDir = Paths.get(exportDir, \"variables\");\n+      variableDir.toFile().mkdirs();\n+\n+      // Save the variables state\n+      session.save(variableDir.resolve(\"variables\").toString());\n+\n+      // Save the graph\n+      SavedModel savedModelDef = SavedModel.newBuilder().addMetaGraphs(metaGraphDef).build();\n+      try (OutputStream file =\n+          new FileOutputStream(Paths.get(exportDir, \"saved_model.pb\").toString())) {\n+        savedModelDef.writeTo(file);\n+      }\n+    }\n+\n+    Exporter(String exportDir) {\n+      this.exportDir = exportDir;\n+    }\n+\n+    private final String exportDir;\n+    private final List<String> tags = new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwMjk3Mw=="}, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODIxMTA5OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTo0MjowMVrOHQuppw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTo0MjowMVrOHQuppw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwMzU5MQ==", "bodyText": "Should we note this in the @throws bit of the Javadoc? It says an exception will be thrown, but not what kind.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487303591", "createdAt": "2020-09-11T21:42:01Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "diffHunk": "@@ -89,11 +110,107 @@ private Loader(String exportDir) {\n     }\n \n     private String exportDir = null;\n-    private String[] tags = null;\n+    private String[] tags = {DEFAULT_TAG};\n     private ConfigProto configProto = null;\n     private RunOptions runOptions = null;\n   }\n \n+  /** Options for exporting a SavedModel. */\n+  public static final class Exporter {\n+\n+    /**\n+     * Sets the set of tags that identify the specific graph in the saved model to save.\n+     *\n+     * <p/>Note that only one graph per model can be saved right now using this API.\n+     *\n+     * @param tags the tags identifying the specific MetaGraphDef to save.\n+     * @return this object\n+     */\n+    public Exporter withTags(String... tags) {\n+      this.tags.addAll(Arrays.asList(tags));\n+      return this;\n+    }\n+\n+    /**\n+     * Save a concrete function of this model.\n+     *\n+     * <p/>The concrete function carries a signature (i.e. a list of user-friendly input and outputs\n+     * names to a graph) and a valid session to a graph to be saved in the model.\n+     *\n+     * <p/><i>Note:Eventually, TensorFlow for Java will support the export of functions objects like\n+     * the Python API does but right now, only session-centric models are supported (i.e. models that\n+     * has a single main graph and one or more signatures). These models are compatible with those\n+     * exported by TensorFlow 1.x or by TensorFlow 2.x estimators.\n+     *\n+     * <p>Therefore, all functions exported in a model should share the same session at the moment\n+     * or an exception will be thrown.</i>\n+     *\n+     * @param function a function carrying a signature and a valid session to the graph to be saved\n+     * @return this object\n+     * @throws IllegalArgumentException if a function with the same name has already been added to the model\n+     */\n+    public Exporter withFunction(ConcreteFunction function) {\n+      Signature signature = function.signature();\n+      if (functions.containsKey(signature.key())) {\n+        throw new IllegalArgumentException(\"Function \\\"\" + signature.key() + \"\\\" was already added to the model\");\n+      }\n+      functions.put(signature.key(), function);\n+      if (session == null) {\n+        session = function.session();\n+      } else if (session != function.session()) {\n+        throw new UnsupportedOperationException(\"Saving multiple functions with different graphs/sessions is not supported yet.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODIxNDQ0OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTo0MzozNlrOHQurog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTo0MzozNlrOHQurog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwNDA5OA==", "bodyText": "Given this comment, should we pull out the SaverDef as a variable before the MetaGraphDefBuilder call? That way it's explicit that it will always happen first.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487304098", "createdAt": "2020-09-11T21:43:36Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "diffHunk": "@@ -89,11 +110,107 @@ private Loader(String exportDir) {\n     }\n \n     private String exportDir = null;\n-    private String[] tags = null;\n+    private String[] tags = {DEFAULT_TAG};\n     private ConfigProto configProto = null;\n     private RunOptions runOptions = null;\n   }\n \n+  /** Options for exporting a SavedModel. */\n+  public static final class Exporter {\n+\n+    /**\n+     * Sets the set of tags that identify the specific graph in the saved model to save.\n+     *\n+     * <p/>Note that only one graph per model can be saved right now using this API.\n+     *\n+     * @param tags the tags identifying the specific MetaGraphDef to save.\n+     * @return this object\n+     */\n+    public Exporter withTags(String... tags) {\n+      this.tags.addAll(Arrays.asList(tags));\n+      return this;\n+    }\n+\n+    /**\n+     * Save a concrete function of this model.\n+     *\n+     * <p/>The concrete function carries a signature (i.e. a list of user-friendly input and outputs\n+     * names to a graph) and a valid session to a graph to be saved in the model.\n+     *\n+     * <p/><i>Note:Eventually, TensorFlow for Java will support the export of functions objects like\n+     * the Python API does but right now, only session-centric models are supported (i.e. models that\n+     * has a single main graph and one or more signatures). These models are compatible with those\n+     * exported by TensorFlow 1.x or by TensorFlow 2.x estimators.\n+     *\n+     * <p>Therefore, all functions exported in a model should share the same session at the moment\n+     * or an exception will be thrown.</i>\n+     *\n+     * @param function a function carrying a signature and a valid session to the graph to be saved\n+     * @return this object\n+     * @throws IllegalArgumentException if a function with the same name has already been added to the model\n+     */\n+    public Exporter withFunction(ConcreteFunction function) {\n+      Signature signature = function.signature();\n+      if (functions.containsKey(signature.key())) {\n+        throw new IllegalArgumentException(\"Function \\\"\" + signature.key() + \"\\\" was already added to the model\");\n+      }\n+      functions.put(signature.key(), function);\n+      if (session == null) {\n+        session = function.session();\n+      } else if (session != function.session()) {\n+        throw new UnsupportedOperationException(\"Saving multiple functions with different graphs/sessions is not supported yet.\");\n+      }\n+      metaGraphDefBuilder.putSignatureDef(signature.key(), signature.asSignatureDef());\n+      return this;\n+    }\n+\n+    /**\n+     * Save the model into the export directory.\n+     *\n+     * @throws IOException if saved model or variable state can be written on disk\n+     */\n+    public void export() throws IOException {\n+      if (functions.isEmpty() || session == null) {\n+        throw new IllegalStateException(\"Model should contain at least one valid function\");\n+      }\n+      if (tags.isEmpty()) {\n+        tags.add(DEFAULT_TAG);\n+      }\n+      // It is imperative to retrieve the graphDef after the saverDef, as the former might add\n+      // new ops to the graph for saving and restoring the variables.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODIyMTA1OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTo0NjoyM1rOHQuviQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTo0NjoyM1rOHQuviQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwNTA5Nw==", "bodyText": "Should we make this a LinkedHashMap so it has a consistent iteration order? That way the signatures will always come out in the way that the metaGraphDef says they are (assuming it preserves ordering).", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487305097", "createdAt": "2020-09-11T21:46:23Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "diffHunk": "@@ -175,10 +364,21 @@ private SavedModelBundle(Graph graph, Session session, MetaGraphDef metaGraphDef\n    * <p>Invoked from the native load method. Takes ownership of the handles.\n    */\n   private static SavedModelBundle fromHandle(\n-      TF_Graph graphHandle, TF_Session sessionHandle, MetaGraphDef metaGraphDef) {\n-    Graph graph = new Graph(graphHandle);\n-    Session session = new Session(graph, sessionHandle);\n-    return new SavedModelBundle(graph, session, metaGraphDef);\n+      final TF_Graph graphHandle, final TF_Session sessionHandle, MetaGraphDef metaGraphDef) {\n+\n+    final Graph graph = new Graph(graphHandle, metaGraphDef.getSaverDef());\n+    final Session session = new Session(graph, sessionHandle);\n+\n+    // Create a separate function for each signature of the main graph.\n+    // Note that the saved model will remain the owner of the graph and the session, meaning\n+    // that the functions do not need to be closed by the user and if it does, it should have\n+    // no effect.\n+    final Map<String, ConcreteFunction> functions = new HashMap<>(metaGraphDef.getSignatureDefCount());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 282}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODI0MjUwOnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Session.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTo1NjoxNlrOHQu79A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTo1NjoxNlrOHQu79A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwODI3Ng==", "bodyText": "Should we note that this will permanently alter the graph itself by adding saving hooks?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487308276", "createdAt": "2020-09-11T21:56:16Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Session.java", "diffHunk": "@@ -444,6 +446,24 @@ public void run(Op op) {\n     runner().addTarget(op.op()).run();\n   }\n \n+  /**\n+   * Saves the actual state of the variables of this session's graph.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODI0NTkyOnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Signature.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTo1Nzo0NVrOHQu95g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTo1Nzo0NVrOHQu95g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwODc3NA==", "bodyText": "Should we check the input isn't the empty String? And then while we're doing that, that it's not null?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487308774", "createdAt": "2020-09-11T21:57:45Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Signature.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.proto.framework.DataType;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+import org.tensorflow.proto.framework.TensorShapeProto;\n+import org.tensorflow.proto.framework.TensorShapeProto.Dim;\n+\n+/**\n+ * Describe the inputs and outputs of an executable entity, such as a {@link ConcreteFunction}, among\n+ * other useful metadata.\n+ */\n+public class Signature  {\n+\n+  /** The default signature key, when not provided */\n+  public static final String DEFAULT_KEY = \"serving_default\";\n+\n+  /**\n+   * Builds a new function signature.\n+   */\n+  public static class Builder {\n+\n+    /**\n+     * Sets the unique key of this signature.\n+     *\n+     * <p/>When not set explicitly, the default value is {@link #DEFAULT_KEY}.\n+     *\n+     * @param key signature key\n+     * @return this builder\n+     */\n+    public Builder key(String key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODI0ODM3OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Signature.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMTo1OToxMlrOHQu_dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNDozNDoxOVrOHRX-6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwOTE3Mw==", "bodyText": "What are the semantics for name collisions? If they aren't defined should we define them? Ditto for the outputs.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487309173", "createdAt": "2020-09-11T21:59:12Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Signature.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.proto.framework.DataType;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+import org.tensorflow.proto.framework.TensorShapeProto;\n+import org.tensorflow.proto.framework.TensorShapeProto.Dim;\n+\n+/**\n+ * Describe the inputs and outputs of an executable entity, such as a {@link ConcreteFunction}, among\n+ * other useful metadata.\n+ */\n+public class Signature  {\n+\n+  /** The default signature key, when not provided */\n+  public static final String DEFAULT_KEY = \"serving_default\";\n+\n+  /**\n+   * Builds a new function signature.\n+   */\n+  public static class Builder {\n+\n+    /**\n+     * Sets the unique key of this signature.\n+     *\n+     * <p/>When not set explicitly, the default value is {@link #DEFAULT_KEY}.\n+     *\n+     * @param key signature key\n+     * @return this builder\n+     */\n+    public Builder key(String key) {\n+      this.key = key;\n+      return this;\n+    }\n+\n+    /**\n+     * Register a tensor as an input of the function.\n+     *\n+     * @param inputName user-friendly name for this input tensor\n+     * @param input input tensor\n+     * @return this builder\n+     */\n+    public Builder input(String inputName, Operand<?> input) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2ODQzMg==", "bodyText": "We can raise an error if a user tries to add more than one input/output with the same name.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487968432", "createdAt": "2020-09-14T14:20:00Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Signature.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.proto.framework.DataType;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+import org.tensorflow.proto.framework.TensorShapeProto;\n+import org.tensorflow.proto.framework.TensorShapeProto.Dim;\n+\n+/**\n+ * Describe the inputs and outputs of an executable entity, such as a {@link ConcreteFunction}, among\n+ * other useful metadata.\n+ */\n+public class Signature  {\n+\n+  /** The default signature key, when not provided */\n+  public static final String DEFAULT_KEY = \"serving_default\";\n+\n+  /**\n+   * Builds a new function signature.\n+   */\n+  public static class Builder {\n+\n+    /**\n+     * Sets the unique key of this signature.\n+     *\n+     * <p/>When not set explicitly, the default value is {@link #DEFAULT_KEY}.\n+     *\n+     * @param key signature key\n+     * @return this builder\n+     */\n+    public Builder key(String key) {\n+      this.key = key;\n+      return this;\n+    }\n+\n+    /**\n+     * Register a tensor as an input of the function.\n+     *\n+     * @param inputName user-friendly name for this input tensor\n+     * @param input input tensor\n+     * @return this builder\n+     */\n+    public Builder input(String inputName, Operand<?> input) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwOTE3Mw=="}, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk4MDc3Nw==", "bodyText": "Sounds good.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487980777", "createdAt": "2020-09-14T14:34:19Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Signature.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.proto.framework.DataType;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+import org.tensorflow.proto.framework.TensorShapeProto;\n+import org.tensorflow.proto.framework.TensorShapeProto.Dim;\n+\n+/**\n+ * Describe the inputs and outputs of an executable entity, such as a {@link ConcreteFunction}, among\n+ * other useful metadata.\n+ */\n+public class Signature  {\n+\n+  /** The default signature key, when not provided */\n+  public static final String DEFAULT_KEY = \"serving_default\";\n+\n+  /**\n+   * Builds a new function signature.\n+   */\n+  public static class Builder {\n+\n+    /**\n+     * Sets the unique key of this signature.\n+     *\n+     * <p/>When not set explicitly, the default value is {@link #DEFAULT_KEY}.\n+     *\n+     * @param key signature key\n+     * @return this builder\n+     */\n+    public Builder key(String key) {\n+      this.key = key;\n+      return this;\n+    }\n+\n+    /**\n+     * Register a tensor as an input of the function.\n+     *\n+     * @param inputName user-friendly name for this input tensor\n+     * @param input input tensor\n+     * @return this builder\n+     */\n+    public Builder input(String inputName, Operand<?> input) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMwOTE3Mw=="}, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODI1NDk0OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Signature.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMjowMjoyNVrOHQvDmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNDoyMToyMVrOHRXUyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxMDIzMw==", "bodyText": "Similarly should we check it isn't empty or null?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487310233", "createdAt": "2020-09-11T22:02:25Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Signature.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.proto.framework.DataType;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+import org.tensorflow.proto.framework.TensorShapeProto;\n+import org.tensorflow.proto.framework.TensorShapeProto.Dim;\n+\n+/**\n+ * Describe the inputs and outputs of an executable entity, such as a {@link ConcreteFunction}, among\n+ * other useful metadata.\n+ */\n+public class Signature  {\n+\n+  /** The default signature key, when not provided */\n+  public static final String DEFAULT_KEY = \"serving_default\";\n+\n+  /**\n+   * Builds a new function signature.\n+   */\n+  public static class Builder {\n+\n+    /**\n+     * Sets the unique key of this signature.\n+     *\n+     * <p/>When not set explicitly, the default value is {@link #DEFAULT_KEY}.\n+     *\n+     * @param key signature key\n+     * @return this builder\n+     */\n+    public Builder key(String key) {\n+      this.key = key;\n+      return this;\n+    }\n+\n+    /**\n+     * Register a tensor as an input of the function.\n+     *\n+     * @param inputName user-friendly name for this input tensor\n+     * @param input input tensor\n+     * @return this builder\n+     */\n+    public Builder input(String inputName, Operand<?> input) {\n+      signatureBuilder.putInputs(inputName, toTensorInfo(input.asOutput()));\n+      return this;\n+    }\n+\n+    /**\n+     * Register a tensor as an output of the function.\n+     *\n+     * @param inputName user-friendly name for this input tensor\n+     * @param input input tensor\n+     * @return this builder\n+     */\n+    public Builder output(String outputName, Operand<?> output) {\n+      signatureBuilder.putOutputs(outputName, toTensorInfo(output.asOutput()));\n+      return this;\n+    }\n+\n+    /**\n+     * Provide extensible name information enabling third-party users to mark a signature as\n+     * supporting a particular method\n+     *\n+     * @param methodName method name\n+     * @return this builder\n+     */\n+    public Builder methodName(String methodName) {\n+      signatureBuilder.setMethodName(methodName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2OTk5Mg==", "bodyText": "I'll check but in this case, it is allowed to have no method name assigned to a signature, hence null should be accepted as a value. I can document this.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487969992", "createdAt": "2020-09-14T14:21:21Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Signature.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.util.Map;\n+import java.util.Set;\n+import org.tensorflow.ndarray.Shape;\n+import org.tensorflow.proto.framework.DataType;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+import org.tensorflow.proto.framework.TensorShapeProto;\n+import org.tensorflow.proto.framework.TensorShapeProto.Dim;\n+\n+/**\n+ * Describe the inputs and outputs of an executable entity, such as a {@link ConcreteFunction}, among\n+ * other useful metadata.\n+ */\n+public class Signature  {\n+\n+  /** The default signature key, when not provided */\n+  public static final String DEFAULT_KEY = \"serving_default\";\n+\n+  /**\n+   * Builds a new function signature.\n+   */\n+  public static class Builder {\n+\n+    /**\n+     * Sets the unique key of this signature.\n+     *\n+     * <p/>When not set explicitly, the default value is {@link #DEFAULT_KEY}.\n+     *\n+     * @param key signature key\n+     * @return this builder\n+     */\n+    public Builder key(String key) {\n+      this.key = key;\n+      return this;\n+    }\n+\n+    /**\n+     * Register a tensor as an input of the function.\n+     *\n+     * @param inputName user-friendly name for this input tensor\n+     * @param input input tensor\n+     * @return this builder\n+     */\n+    public Builder input(String inputName, Operand<?> input) {\n+      signatureBuilder.putInputs(inputName, toTensorInfo(input.asOutput()));\n+      return this;\n+    }\n+\n+    /**\n+     * Register a tensor as an output of the function.\n+     *\n+     * @param inputName user-friendly name for this input tensor\n+     * @param input input tensor\n+     * @return this builder\n+     */\n+    public Builder output(String outputName, Operand<?> output) {\n+      signatureBuilder.putOutputs(outputName, toTensorInfo(output.asOutput()));\n+      return this;\n+    }\n+\n+    /**\n+     * Provide extensible name information enabling third-party users to mark a signature as\n+     * supporting a particular method\n+     *\n+     * @param methodName method name\n+     * @return this builder\n+     */\n+    public Builder methodName(String methodName) {\n+      signatureBuilder.setMethodName(methodName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxMDIzMw=="}, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODI2NDAzOnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/ConcreteFunctionTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMjowNjo0MVrOHQvI1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxNDoyMjo1MFrOHRXbUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxMTU3Mg==", "bodyText": "What does this init trigger?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487311572", "createdAt": "2020-09-11T22:06:41Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/ConcreteFunctionTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.tensorflow;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import org.junit.jupiter.api.Test;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.core.Init;\n+import org.tensorflow.op.core.Placeholder;\n+import org.tensorflow.op.math.Add;\n+import org.tensorflow.op.math.Sub;\n+import org.tensorflow.types.TFloat32;\n+\n+public class ConcreteFunctionTest {\n+\n+  private static Signature plusFive(Ops tf) {\n+    Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+    Add<TFloat32> output = tf.math.add(input, tf.constant(5.0f));\n+    Init init = tf.init();  // for native resource management tests", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk3MTY2NA==", "bodyText": "Nothing, like the comment says, it is only used to test out resource management as in closingFunctionCreatedFromGraphOnlyReleaseResourcesItOwns", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487971664", "createdAt": "2020-09-14T14:22:50Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/ConcreteFunctionTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.tensorflow;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import org.junit.jupiter.api.Test;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.core.Init;\n+import org.tensorflow.op.core.Placeholder;\n+import org.tensorflow.op.math.Add;\n+import org.tensorflow.op.math.Sub;\n+import org.tensorflow.types.TFloat32;\n+\n+public class ConcreteFunctionTest {\n+\n+  private static Signature plusFive(Ops tf) {\n+    Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+    Add<TFloat32> output = tf.math.add(input, tf.constant(5.0f));\n+    Init init = tf.init();  // for native resource management tests", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxMTU3Mg=="}, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODI2NzAzOnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/ConcreteFunctionTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMjowODowNFrOHQvKkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMjowODowNFrOHQvKkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxMjAxOA==", "bodyText": "Should we use the junit assertThrows test here? It's shorter.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487312018", "createdAt": "2020-09-11T22:08:04Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/ConcreteFunctionTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package org.tensorflow;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+import org.junit.jupiter.api.Test;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.core.Init;\n+import org.tensorflow.op.core.Placeholder;\n+import org.tensorflow.op.math.Add;\n+import org.tensorflow.op.math.Sub;\n+import org.tensorflow.types.TFloat32;\n+\n+public class ConcreteFunctionTest {\n+\n+  private static Signature plusFive(Ops tf) {\n+    Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+    Add<TFloat32> output = tf.math.add(input, tf.constant(5.0f));\n+    Init init = tf.init();  // for native resource management tests\n+    return Signature.builder().key(\"plusFive\").input(\"x\", input).output(\"y\", output).build();\n+  }\n+\n+  private static Signature minusTwo(Ops tf) {\n+    Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+    Sub<TFloat32> output = tf.math.sub(input, tf.constant(2.0f));\n+    return Signature.builder().key(\"minusTwo\").input(\"x\", input).output(\"y\", output).build();\n+  }\n+\n+  @Test\n+  public void createFunction() {\n+    try (ConcreteFunction f = ConcreteFunction.create(ConcreteFunctionTest::plusFive);\n+        Tensor<TFloat32> x = TFloat32.scalarOf(3.0f)) {\n+      assertEquals(8.0f, f.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+    }\n+  }\n+\n+  @Test\n+  public void createFunctionFromGraph() {\n+    try (Graph g = new Graph()) {\n+      Signature signature = plusFive(Ops.create(g));\n+      try (ConcreteFunction f = ConcreteFunction.create(signature, g);\n+          Tensor<TFloat32> x = TFloat32.scalarOf(3.0f)) {\n+        assertEquals(8.0f, f.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void createFunctionFromSession() {\n+    try (Graph g = new Graph()) {\n+      Signature signature = plusFive(Ops.create(g));\n+      try (Session s = new Session(g)) {\n+        try (ConcreteFunction f = ConcreteFunction.create(signature, s);\n+            Tensor<TFloat32> x = TFloat32.scalarOf(3.0f)) {\n+          assertEquals(8.0f, f.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+        }\n+      }\n+    }\n+  }\n+\n+  @Test\n+  public void chainFunctions() {\n+    try (ConcreteFunction f1 = ConcreteFunction.create(ConcreteFunctionTest::plusFive);\n+        ConcreteFunction f2 = ConcreteFunction.create(ConcreteFunctionTest::minusTwo);\n+        Tensor<TFloat32> x = TFloat32.scalarOf(3.0f)) {\n+      assertEquals(6.0f, f2.call(f1.call(x)).expect(TFloat32.DTYPE).data().getFloat());\n+    }\n+  }\n+\n+  @Test\n+  public void closingFunctionReleaseAllResourcesItOwns() {\n+    Graph g;\n+    Session s;\n+    try (ConcreteFunction f = ConcreteFunction.create(ConcreteFunctionTest::plusFive)) {\n+      g = f.graph();\n+      s = f.session();\n+    }\n+    try {\n+      s.run(\"Add\");\n+      fail();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODI4MDMxOnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/test/resources/saved_model_using_python/readme.txt", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMjoxNTowM1rOHQvSgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMjo1MTozNFrOHSeH8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNDA1MA==", "bodyText": "Should we just check this in as a python file?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r487314050", "createdAt": "2020-09-11T22:15:03Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/test/resources/saved_model_using_python/readme.txt", "diffHunk": "@@ -0,0 +1,45 @@\n+Saved model created using Python @tf.function, tensorflow version 2.3.0.\n+\n+Python code used to create saved model below:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5MTEzNQ==", "bodyText": "@karllessard any guidance on having python files in the java repo?", "url": "https://github.com/tensorflow/java/pull/112#discussion_r488391135", "createdAt": "2020-09-15T05:17:11Z", "author": {"login": "Shajan"}, "path": "tensorflow-core/tensorflow-core-api/src/test/resources/saved_model_using_python/readme.txt", "diffHunk": "@@ -0,0 +1,45 @@\n+Saved model created using Python @tf.function, tensorflow version 2.3.0.\n+\n+Python code used to create saved model below:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNDA1MA=="}, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyMDYwMA==", "bodyText": "@Shajan  , what do you think? I think it could be a Python file, as long as we add a notice on top of that the file is only there for reference and is not being used anywhere in the code base.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r489120600", "createdAt": "2020-09-16T02:15:42Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/test/resources/saved_model_using_python/readme.txt", "diffHunk": "@@ -0,0 +1,45 @@\n+Saved model created using Python @tf.function, tensorflow version 2.3.0.\n+\n+Python code used to create saved model below:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNDA1MA=="}, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyOTk2OQ==", "bodyText": "I've moved forward and changed the file type to Python, please let me know if you think of any reason I should revert it to a text file.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r489129969", "createdAt": "2020-09-16T02:51:34Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/test/resources/saved_model_using_python/readme.txt", "diffHunk": "@@ -0,0 +1,45 @@\n+Saved model created using Python @tf.function, tensorflow version 2.3.0.\n+\n+Python code used to create saved model below:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMxNDA1MA=="}, "originalCommit": {"oid": "09c136ea671153452217138629e30cf83dc169f6"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2ODk5MjA5OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/test/resources/saved_model_using_python/source_model.py", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTowMzoyM1rOHTxCxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxOTowMzoyM1rOHTxCxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ4ODUxNw==", "bodyText": "This should have a copyright statement at the top.", "url": "https://github.com/tensorflow/java/pull/112#discussion_r490488517", "createdAt": "2020-09-17T19:03:23Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/test/resources/saved_model_using_python/source_model.py", "diffHunk": "@@ -0,0 +1,48 @@\n+# Saved model created using Python @tf.function, tensorflow version 2.3.0.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bb4622378998a773d4e67cd850e198179443c9b"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1631, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}