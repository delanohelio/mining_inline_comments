{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcyNjA4Mzkz", "number": 103, "title": "Save models as functions", "bodyText": "Ok I've modified a little this solution compared to the previous one, now FunctionGraph are auto-closeable and own the session/graph only if the function has been created before them. See examples provided in the FunctionGraph documentation for more details.\nThere are still a few things I need to look at before making this PR more official but I would like to get some feedbacks before continuing in that direction.\nIn summary:\n\nFunctionGraph is the new (disposable) name for TfFunction as submitted previously by @Shajan\nUsers can create their graph in a \"function style\" (while we still don't support real function graphs but this API should be ready to accommodate it when we will come to it).\nUsers can still define a graph and then convert it to a function (i.e. adding a signature to it). In this case, the function does not own the graph and releasing it will have no effect.\nSaving a model requires that one or more functions to be provided. The graph to be saved and the session to use to save the variables will be extracted from these functions (right now, since we can only export session-centric models, all functions saved should share the same session)\n\nI'll provide more and better examples later, thanks!", "createdAt": "2020-08-24T15:47:08Z", "url": "https://github.com/tensorflow/java/pull/103", "merged": true, "mergeCommit": {"oid": "bba783a70f233e25936e47c23ebe22727743028b"}, "closed": true, "closedAt": "2020-08-28T02:01:59Z", "author": {"login": "karllessard"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7wY0dAH2gAyNDcyNjA4MzkzOmJjZDUzM2Y2ZmY1ZjQ4MDI3ZDU5NzVlNzViNDc5YTgwYzkyZmYwZWI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdDUG34gFqTQ3NzY4MzgzOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "bcd533f6ff5f48027d5975e75b479a80c92ff0eb", "author": {"user": {"login": "Shajan", "name": "Shajan Dasan"}}, "url": "https://github.com/tensorflow/java/commit/bcd533f6ff5f48027d5975e75b479a80c92ff0eb", "committedDate": "2020-08-05T00:50:10Z", "message": "Draft: Java API to use tf.function available on SavedModel. (#89)\n\nPython models that contain tf.function is inconvenient to be consumed by Java clients.\r\nThis proposal provides an API to\r\n(a) Invoke a tf.function, given the signature name\r\n(b) Retrieve the node name in the graph corresponding to a tf.function\r\n\r\nCo-authored-by: Shajan Dasan <sdasan@twitter.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dbdd3ea83216e58fdf7ecf8dcabe8d7f9e60370", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/0dbdd3ea83216e58fdf7ecf8dcabe8d7f9e60370", "committedDate": "2020-08-06T03:38:04Z", "message": "tmp"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f17f385908cb165e8743c8f4193144153c195d0", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/5f17f385908cb165e8743c8f4193144153c195d0", "committedDate": "2020-08-24T01:49:38Z", "message": "Merge branch 'saved_model_2' into shared-saved-model\n\n# Conflicts:\n#\ttensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/Ops.java\n#\ttensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b311e27b71ca70c11c0e4eb8b75b3d4a462b2258", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/b311e27b71ca70c11c0e4eb8b75b3d4a462b2258", "committedDate": "2020-08-24T05:10:20Z", "message": "Create function objects as callable graphs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNjQ2NjI1", "url": "https://github.com/tensorflow/java/pull/103#pullrequestreview-473646625", "createdAt": "2020-08-24T16:08:20Z", "commit": {"oid": "45cb250de1722c7f4837a9d171844060785498c8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjowODoyMVrOHFsEfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjowODoyMVrOHFsEfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcyNjk3NA==", "bodyText": "Suggestion: Rename GRAPH to GRAPH_AND_SESSION", "url": "https://github.com/tensorflow/java/pull/103#discussion_r475726974", "createdAt": "2020-08-24T16:08:21Z", "author": {"login": "Shajan"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/FunctionGraph.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.math.Sign;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * FunctionGraph myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class FunctionGraph implements AutoCloseable {\n+\n+  /**\n+   * Creates a function by building a new graph.\n+   *\n+   * <p/>The {@code functionBuilder} must initialize the function graph from the provided\n+   * {@link Ops} instance and return a valid signature that will be used to feed the input tensors\n+   * and fetch the output tensors on execution.\n+   *\n+   * <p/>The function will be the owner of the new graph and its resulting session. Therefore,\n+   * the function must be enclosed properly with a try-with-resources block to guarantee that\n+   * all native resources will be freed once the function is discarded. For example:\n+   *\n+   * <pre>{@code\n+   * public class MyModel {\n+   *\n+   *   public static Signature addTwo(Ops tf) {\n+   *     Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *     Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *     return Signature.builder(\"addTwo\").input(\"x\", input).output(\"y\", output).build();\n+   *   }\n+   *\n+   *   public static void main(String args[]) {\n+   *     try (FunctionGraph function = FunctionGraph.create(MyModel::addTwo);\n+   *         Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *   }\n+   * }\n+   * }</pre>\n+   *\n+   * @param functionBuilder function builder\n+   * @return the new function\n+   */\n+  public static FunctionGraph create(Function<Ops, Signature> functionBuilder) {\n+    Graph graph = new Graph();\n+    try {\n+      Ops tf = Ops.create(graph);\n+      Signature signature = functionBuilder.apply(tf);\n+      return new FunctionGraph(signature, graph, new Session(graph), Ownership.GRAPH);\n+    } catch (Exception e) {\n+      graph.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Create a function from a signature and an existing graph.\n+   *\n+   * <p/>The function will keep the ownership of the session used to run the graph but not\n+   * the graph itself, meaning that the lifetime of the latter can extend beyond the scope\n+   * of the function. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (FunctionGraph f = FunctionGraph.create(signature, g);\n+   *       Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *     assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid and initialized graph\n+   * @return a new function\n+   */\n+  public static FunctionGraph create(Signature signature, Graph graph) {\n+    return new FunctionGraph(signature, graph, new Session(graph), Ownership.SESSION);\n+  }\n+\n+  /**\n+   * Create a function from a signature and a valid graph session.\n+   *\n+   * <p/>The function will not own the session nor its graph, meaning that their lifetime\n+   * can extend beyond the scope of the function. Therefore the function does not need to be\n+   * closed after its usage. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (Session s = new Session(g)) {\n+   *     // Auto-closing the function just as an example but this is not required since it has\n+   *     // no effect\n+   *     try (FunctionGraph f = FunctionGraph.create(signature, s);\n+   *         Tensor<TFloat32> t = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *     // Session s is still valid at this point\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid session to an initialized graph\n+   * @return a new function\n+   */\n+  public static FunctionGraph create(Signature signature, Session session) {\n+    return new FunctionGraph(signature, session.graph(), session, Ownership.NONE);\n+  }\n+\n+  /**\n+   * Returns the signature of this function\n+   */\n+  public Signature signature() {\n+    return signature;\n+  }\n+\n+  /**\n+   * Invokes a function.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   */\n+  public Map<String, Tensor<?>> call(Map<String, Tensor<?>> arguments)\n+      throws IllegalArgumentException {\n+\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+    final Session.Runner runner = session.runner();\n+\n+    signatureDef.getInputsMap().forEach((argName, t) -> {\n+      Tensor<?> tensor = arguments.get(argName);\n+      if (tensor == null) {\n+        throw new IllegalArgumentException(String.format(\"Missing argument [%s]\", argName));\n+      }\n+      runner.feed(t.getName(), tensor);\n+    });\n+\n+    Map<String, TensorInfo> outputToNode = signatureDef.getOutputsMap();\n+    outputToNode.values().forEach(t -> runner.fetch(t.getName()));\n+\n+    List<Tensor<?>> resultTensors = runner.run();\n+    try {\n+      ListIterator<Tensor<?>> resultTensorIter = resultTensors.listIterator();\n+      Map<String, Tensor<?>> returnMap = new HashMap<String, Tensor<?>>();\n+\n+      // Use the output names as present in the signature definition\n+      for (String nodeName: outputToNode.keySet()) {\n+        returnMap.put(nodeName, resultTensorIter.next());\n+      }\n+      return returnMap;\n+\n+    } catch (Exception e) {\n+      // Release tensors before throwing exception\n+      for (Tensor<?> t : resultTensors) {\n+        t.close();\n+      }\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Invokes a function with a single input and output.\n+   *\n+   * <p>Caller is responsible for closing all Tensors.\n+   *\n+   * @param tensor input tensor\n+   * @return output tensor\n+   * @throws IllegalArgumentException if there are multiple input or output parameters defined\n+   *                                  in the function\n+   */\n+  public Tensor<?> call(Tensor<?> tensor) throws IllegalArgumentException {\n+    final SignatureDef signatureDef = signature.asSignatureDef();\n+\n+    if (signatureDef.getInputsCount() != 1) {\n+      throw new IllegalArgumentException(\n+        String.format(\"Function [%s] requires multiple inputs\", signatureDef.getMethodName()));\n+    }\n+    String inputNodeName = signatureDef.getInputsMap().values().iterator().next().getName();\n+\n+    if (signatureDef.getOutputsCount() != 1) {\n+      throw new IllegalArgumentException(\n+        String.format(\"Function [%s] has multiple outputs\", signatureDef.getMethodName()));\n+    }\n+    String outputNodeName = signatureDef.getOutputsMap().values().iterator().next().getName();\n+\n+    return session.runner().feed(inputNodeName, tensor).fetch(outputNodeName).run().get(0);\n+  }\n+\n+  /**\n+   * Returns the session used to execute the graph when calling this function\n+   *\n+   * <p>In general, a user does not need to handle directly the session of a function and rely\n+   * on {@link #call(Map)} to execute the graph instead. But in some cases, direct access to\n+   * the session might be necessary, as it presents more running options.\n+   *\n+   * @return the function session\n+   */\n+  public Session session() {\n+    return session;\n+  }\n+\n+  @Override\n+  public void close() {\n+    if (ownership != Ownership.NONE) {\n+      session.close();\n+      if (ownership == Ownership.GRAPH) {\n+        graph.close();\n+      }\n+    }\n+  }\n+\n+  private enum Ownership {\n+    GRAPH, SESSION, NONE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45cb250de1722c7f4837a9d171844060785498c8"}, "originalPosition": 253}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNjUyODA4", "url": "https://github.com/tensorflow/java/pull/103#pullrequestreview-473652808", "createdAt": "2020-08-24T16:16:09Z", "commit": {"oid": "45cb250de1722c7f4837a9d171844060785498c8"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNjQ2NTg3", "url": "https://github.com/tensorflow/java/pull/103#pullrequestreview-473646587", "createdAt": "2020-08-24T16:08:18Z", "commit": {"oid": "45cb250de1722c7f4837a9d171844060785498c8"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjowODoxOFrOHFsEYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjoyMDo1NlrOHFsixw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcyNjk0Nw==", "bodyText": "Maybe FunctionSession as it's a specialised session? That way it conceptually lives next to EagerSession and  Session, rather than next to Graph. I feel like this is much closer to a session than a graph.", "url": "https://github.com/tensorflow/java/pull/103#discussion_r475726947", "createdAt": "2020-08-24T16:08:18Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/FunctionGraph.java", "diffHunk": "@@ -0,0 +1,267 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.op.math.Sign;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * FunctionGraph myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class FunctionGraph implements AutoCloseable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45cb250de1722c7f4837a9d171844060785498c8"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczMDUxMg==", "bodyText": "saverDef needs to be declared volatile for this to work - http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html", "url": "https://github.com/tensorflow/java/pull/103#discussion_r475730512", "createdAt": "2020-08-24T16:14:01Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Graph.java", "diffHunk": "@@ -287,6 +301,17 @@ public synchronized void addInitializer(Op initializer) {\n     return addGradients(null, new Output<?>[] {y}, x, null);\n   }\n \n+  public SaverDef saverDef() {\n+    if (saverDef == null) {\n+      synchronized (this) {\n+        if (saverDef == null) {\n+          saverDef = addVariableSaver(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45cb250de1722c7f4837a9d171844060785498c8"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczMDc3OQ==", "bodyText": "Or we make the whole method synchronized, which also seems fine as it's unlikely to be heavily contended.", "url": "https://github.com/tensorflow/java/pull/103#discussion_r475730779", "createdAt": "2020-08-24T16:14:26Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/Graph.java", "diffHunk": "@@ -287,6 +301,17 @@ public synchronized void addInitializer(Op initializer) {\n     return addGradients(null, new Output<?>[] {y}, x, null);\n   }\n \n+  public SaverDef saverDef() {\n+    if (saverDef == null) {\n+      synchronized (this) {\n+        if (saverDef == null) {\n+          saverDef = addVariableSaver(this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczMDUxMg=="}, "originalCommit": {"oid": "45cb250de1722c7f4837a9d171844060785498c8"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczMzMwNQ==", "bodyText": "Should we add a helper that takes an exportDir, a FunctionGraph and then performs all the necessary operations? Seems like there are a bunch of hoops to jump through if you just want to save a single FunctionGraph.", "url": "https://github.com/tensorflow/java/pull/103#discussion_r475733305", "createdAt": "2020-08-24T16:18:32Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/SavedModelBundle.java", "diffHunk": "@@ -224,6 +240,18 @@ public static Loader loader(String exportDir) {\n     return new Loader(exportDir);\n   }\n \n+  /**\n+   * Export a saved model.\n+   *\n+   * <p/>Returns a <code>Exporter</code> object for setting configuration options before actually\n+   * saving the model.\n+   *\n+   * @param exportDir the directory path containing a saved model.\n+   */\n+  public static Exporter exporter(String exportDir) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45cb250de1722c7f4837a9d171844060785498c8"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczNDcyNw==", "bodyText": "Wrong import.", "url": "https://github.com/tensorflow/java/pull/103#discussion_r475734727", "createdAt": "2020-08-24T16:20:56Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/SavedModelBundleTest.java", "diffHunk": "@@ -15,20 +15,38 @@\n \n package org.tensorflow;\n \n+import static org.junit.jupiter.api.Assertions.assertEquals;\n import static org.junit.jupiter.api.Assertions.assertNotNull;\n import static org.junit.jupiter.api.Assertions.assertTrue;\n import static org.junit.jupiter.api.Assertions.fail;\n \n+import java.io.IOException;\n import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n import java.nio.file.Paths;\n+import jdk.nashorn.internal.codegen.FunctionSignature;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45cb250de1722c7f4837a9d171844060785498c8"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "175d9e6676d360efc4832d51d96a75b8d7c09b7f", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/175d9e6676d360efc4832d51d96a75b8d7c09b7f", "committedDate": "2020-08-24T22:38:46Z", "message": "Make FunctionGraph auto-closeable"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "45cb250de1722c7f4837a9d171844060785498c8", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/45cb250de1722c7f4837a9d171844060785498c8", "committedDate": "2020-08-24T15:40:15Z", "message": "Make FunctionGraph auto-closeable"}, "afterCommit": {"oid": "175d9e6676d360efc4832d51d96a75b8d7c09b7f", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/175d9e6676d360efc4832d51d96a75b8d7c09b7f", "committedDate": "2020-08-24T22:38:46Z", "message": "Make FunctionGraph auto-closeable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99a74503f7a97e4615f754b916b9d7fe95add1dc", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/99a74503f7a97e4615f754b916b9d7fe95add1dc", "committedDate": "2020-08-27T16:07:21Z", "message": "Rename `FunctionGraph` to `ConcreteFunction`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1383a38006bf2ebbc08146bc76881db6f66d9860", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/1383a38006bf2ebbc08146bc76881db6f66d9860", "committedDate": "2020-08-28T01:57:44Z", "message": "Add more unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3NjgzODM4", "url": "https://github.com/tensorflow/java/pull/103#pullrequestreview-477683838", "createdAt": "2020-08-28T12:24:36Z", "commit": {"oid": "1383a38006bf2ebbc08146bc76881db6f66d9860"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMjoyNDozNlrOHJBsuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxMjoyNDozNlrOHJBsuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTIyNzA2Nw==", "bodyText": "Minor feature request: adding a toString() function to this ConcreteFunction class that prints a readable text representation of the signature would be really useful.", "url": "https://github.com/tensorflow/java/pull/103#discussion_r479227067", "createdAt": "2020-08-28T12:24:36Z", "author": {"login": "yzhuang"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/ConcreteFunction.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 The TensorFlow Authors. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.tensorflow;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.function.Function;\n+import org.tensorflow.op.Ops;\n+import org.tensorflow.proto.framework.SignatureDef;\n+import org.tensorflow.proto.framework.TensorInfo;\n+\n+/**\n+ * A graph that can be invoked as a single function, with an input and output signature.\n+ *\n+ * <p>A function can also invoke a\n+ * <a href=\"https://www.tensorflow.org/api_docs/python/tf/function\">tf.function</a>\n+ * defined in a {@link SavedModelBundle}.\n+ *\n+ * <pre>{@code\n+ * ConcreteFunction myFunction = savedModelBundle.function(\"myFunctionSignatureName\");\n+ * Map<String, Tensor<?>> outputTensorMap = myFunction.call(inputTensorMap);\n+ * }</pre>\n+ */\n+public class ConcreteFunction implements AutoCloseable {\n+\n+  /**\n+   * Creates a function by building a new graph.\n+   *\n+   * <p/>The {@code functionBuilder} must initialize the function graph from the provided\n+   * {@link Ops} instance and return a valid signature that will be used to feed the input tensors\n+   * and fetch the output tensors on execution.\n+   *\n+   * <p/>The function will be the owner of the new graph and its resulting session. Therefore,\n+   * the function must be enclosed properly with a try-with-resources block to guarantee that\n+   * all native resources will be freed once the function is discarded. For example:\n+   *\n+   * <pre>{@code\n+   * public class MyModel {\n+   *\n+   *   public static Signature addTwo(Ops tf) {\n+   *     Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *     Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *     return Signature.builder(\"addTwo\").input(\"x\", input).output(\"y\", output).build();\n+   *   }\n+   *\n+   *   public static void main(String args[]) {\n+   *     try (ConcreteFunction function = ConcreteFunction.create(MyModel::addTwo);\n+   *         Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *   }\n+   * }\n+   * }</pre>\n+   *\n+   * @param functionBuilder function builder\n+   * @return the new function\n+   */\n+  public static ConcreteFunction create(Function<Ops, Signature> functionBuilder) {\n+    Graph graph = new Graph();\n+    try {\n+      Ops tf = Ops.create(graph);\n+      Signature signature = functionBuilder.apply(tf);\n+      return new ConcreteFunction(signature, graph, new Session(graph), Ownership.GRAPH_AND_SESSION);\n+    } catch (Exception e) {\n+      graph.close();\n+      throw e;\n+    }\n+  }\n+\n+  /**\n+   * Create a function from a signature and an existing graph.\n+   *\n+   * <p/>The function will keep the ownership of the session used to run the graph but not\n+   * the graph itself, meaning that the lifetime of the latter can extend beyond the scope\n+   * of the function. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (ConcreteFunction f = ConcreteFunction.create(signature, g);\n+   *       Tensor<TFloat32> x = TFloat32.scalarOf(2.0f)) {\n+   *     assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid and initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Graph graph) {\n+    return new ConcreteFunction(signature, graph, new Session(graph), Ownership.SESSION_ONLY);\n+  }\n+\n+  /**\n+   * Create a function from a signature and a valid graph session.\n+   *\n+   * <p/>The function will not own the session nor its graph, meaning that their lifetime\n+   * can extend beyond the scope of the function. Therefore the function does not need to be\n+   * closed after its usage. For example:\n+   *\n+   * <pre>{@code\n+   * try (Graph g = new Graph()) {\n+   *   Placeholder<TFloat32> input = tf.placeholder(TFloat32.DTYPE);\n+   *   Add<TFloat32> output = tf.math.add(input, tf.constant(2.0f));\n+   *   Signature signature = Signature.builder().input(\"x\", input).output(\"y\", output).build();\n+   *\n+   *   try (Session s = new Session(g)) {\n+   *     // Auto-closing the function just as an example but this is not required since it has\n+   *     // no effect\n+   *     try (ConcreteFunction f = ConcreteFunction.create(signature, s);\n+   *         Tensor<TFloat32> t = TFloat32.scalarOf(2.0f)) {\n+   *       assertEquals(4.0f, function.call(x).expect(TFloat32.DTYPE).data().getFloat());\n+   *     }\n+   *     // Session s is still valid at this point\n+   *   }\n+   *   // Graph g is still valid at this point\n+   * }\n+   * }</pre>\n+   *\n+   * @param signature signature of the function to create\n+   * @param graph a valid session to an initialized graph\n+   * @return a new function\n+   */\n+  public static ConcreteFunction create(Signature signature, Session session) {\n+    return new ConcreteFunction(signature, session.graph(), session, Ownership.NONE);\n+  }\n+\n+  /**\n+   * Returns the signature of this function\n+   */\n+  public Signature signature() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1383a38006bf2ebbc08146bc76881db6f66d9860"}, "originalPosition": 152}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3453, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}