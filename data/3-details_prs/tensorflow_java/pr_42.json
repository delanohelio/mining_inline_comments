{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2MDc4OTIz", "number": 42, "title": "Replace EagerSession.NativeReference with JavaCPP Pointer", "bodyText": "With this, we're effectively managing the scope of Tensor with reference counting and PointerScope. There's still some manual calls to retainReference() and releaseReference that could be replaced with local PointerScope, but it's not too bad the way it is, so I'm opting for less refactoring, for now.\nAlso upgrade JavaCPP to 1.5.3 and TensorFlow to 2.2.0-rc3", "createdAt": "2020-04-20T13:53:46Z", "url": "https://github.com/tensorflow/java/pull/42", "merged": true, "mergeCommit": {"oid": "78f84c08bff9126f90cf6e123283f80450513d75"}, "closed": true, "closedAt": "2020-04-28T13:39:48Z", "author": {"login": "saudet"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZfayHAH2gAyNDA2MDc4OTIzOjY3Y2RmOWU5N2Q3MGMxZmVkYzY4M2M0ZmQzMzEwOGNlNGNhMzQ0ZWY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABccEDkmgFqTQwMTg0NDQ5MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef", "author": {"user": {"login": "saudet", "name": "Samuel Audet"}}, "url": "https://github.com/tensorflow/java/commit/67cdf9e97d70c1fedc683c4fd33108ce4ca344ef", "committedDate": "2020-04-20T13:50:30Z", "message": "Replace EagerSession.NativeReference with JavaCPP Pointer\n\nAlso upgrade JavaCPP to 1.5.3 and TensorFlow to 2.2.0-rc3"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NDkzNDkw", "url": "https://github.com/tensorflow/java/pull/42#pullrequestreview-396493490", "createdAt": "2020-04-20T14:13:59Z", "commit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxMzo1OVrOGIWn-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNDoxMzo1OVrOGIWn-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTQxMjQ3NQ==", "bodyText": "Can we avoid side effect assignment here? I'd much prefer two lines, one for the assignment and one for the session.attach call.", "url": "https://github.com/tensorflow/java/pull/42#discussion_r411412475", "createdAt": "2020-04-20T14:13:59Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperation.java", "diffHunk": "@@ -52,7 +50,8 @@\n     this.session = session;\n     this.type = type;\n     this.name = name;\n-    this.nativeRef = new NativeReference(session, this, opNativeHandle, outputNativeHandles);\n+    session.attach(this.opHandle = opNativeHandle);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2OTM4NzY1", "url": "https://github.com/tensorflow/java/pull/42#pullrequestreview-396938765", "createdAt": "2020-04-21T02:08:25Z", "commit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMjowODoyNVrOGIvN2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMjo0Mjo1OFrOGIv7Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxNTM4Nw==", "bodyText": "That's a new op that needs to be reclassified to the right package. In fact, it should replace the actual QuantizedConcat op that is found under org.tensorflow.op.quantization.\nHere's how to do it:\n\nDuplicate the file api_def_QuantizedConcat.pbtxt to api_def_QuantizedConcatV2.pbtxt in the same folder.\nReplace the endpoint in the old file by visibility: SKIP, like in this one\nReplace the graph_op_name in the new file by QuantizedConcatV2", "url": "https://github.com/tensorflow/java/pull/42#discussion_r411815387", "createdAt": "2020-04-21T02:08:25Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/Ops.java", "diffHunk": "@@ -3734,6 +3735,21 @@ public Print print(Operand<TString> input, Print.Options... options) {\n     return Prod.create(scope, input, axis, options);\n   }\n \n+  /**\n+   *\n+   * @param <T> data type for {@code output()} output\n+   * @param values\n+   * @param axis\n+   * @param inputMins\n+   * @param inputMaxes\n+   * @return a new instance of QuantizedConcatV2\n+   */\n+  public <T extends TType, U extends TNumber> QuantizedConcatV2<T> quantizedConcatV2(\n+      Iterable<Operand<T>> values, Operand<U> axis, Iterable<Operand<TFloat32>> inputMins,\n+      Iterable<Operand<TFloat32>> inputMaxes) {\n+    return QuantizedConcatV2.create(scope, values, axis, inputMins, inputMaxes);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxOTA2Ng==", "bodyText": "If I recall correctly what @EronWright was envisioning for the reference counts is that it could be possible for the session to \"grab\" the ownership of the opHandle when it gets attached to it, instead of explicitly releasing it like in few places in this PR.\nI guess it is done like this because in JavaCPP, you need to explicitly retain a reference so its count is 1, instead of having an initial value of 1. Would you mind explaining again why it needs to be like this?", "url": "https://github.com/tensorflow/java/pull/42#discussion_r411819066", "createdAt": "2020-04-21T02:18:56Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -60,23 +58,28 @@\n     this.session = session;\n     this.type = type;\n     this.name = name;\n-    this.nativeRef = new NativeReference(session, this, allocate(session.nativeHandle(), type));\n+    this.opHandle = allocate(session.nativeHandle(), type);\n+    session.attach(opHandle);\n+    opHandle.releaseReference();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgyMDk5MQ==", "bodyText": "In EagerOperation constructor, we attach the opHandle to the session, which was already attached to it in the constructor of this class, before we detach it here. So if I understand correctly, attaching more than once the same resource to an EagerSession (therefore to a PointerScope) requires to detach it the same amount of time?", "url": "https://github.com/tensorflow/java/pull/42#discussion_r411820991", "createdAt": "2020-04-21T02:24:31Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -60,23 +58,28 @@\n     this.session = session;\n     this.type = type;\n     this.name = name;\n-    this.nativeRef = new NativeReference(session, this, allocate(session.nativeHandle(), type));\n+    this.opHandle = allocate(session.nativeHandle(), type);\n+    session.attach(opHandle);\n+    opHandle.releaseReference();\n   }\n \n   @Override\n   public EagerOperation build() {\n-    TFE_TensorHandle[] tensorHandles = execute(nativeRef.opHandle);\n+    TFE_TensorHandle[] tensorHandles = execute(opHandle);\n     EagerOperation operation =\n-        new EagerOperation(session, nativeRef.opHandle, tensorHandles, type, name);\n+        new EagerOperation(session, opHandle, tensorHandles, type, name);\n     // Release our reference to the native op handle now that we transferred its\n     // ownership to the EagerOperation\n-    nativeRef.clear();\n+    session.detach(opHandle);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgyNzAxNA==", "bodyText": "What do we need both nativeRefs and nativeResources? If I understand correctly, nativeRefs are detached resources that are cleared only on safe points?\nThe purpose of safe points was mainly to allow releasing resources while a session is active but without having a separate thread for garbage-collection. Is the GC thread in JavaCPP is always running? If it cannot be disabled, then we don't need to support safe-points. If it can be disabled, can we link this option with the picked-up strategy then?", "url": "https://github.com/tensorflow/java/pull/42#discussion_r411827014", "createdAt": "2020-04-21T02:42:58Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerSession.java", "diffHunk": "@@ -364,174 +353,38 @@ ResourceCleanupStrategy resourceCleanupStrategy() {\n     return resourceCleanupStrategy;\n   }\n \n-  /**\n-   * A reference to one or more allocated native resources.\n-   *\n-   * <p>Any Java objects owning native resources must declare a reference to those resources in a\n-   * subclass that extends from {@code NativeReference}. When {@link NativeReference#delete()} is\n-   * invoked, the resources must be freed. For example:\n-   *\n-   * <pre>{@code\n-   * private static class NativeReference extends EagerSession.NativeReference {\n-   *\n-   *    NativeReference(EagerSession session, MyClass referent, long handle) {\n-   *        super(session, referent);\n-   *        this.handle = handle;\n-   *    }\n-   *\n-   *    @Override\n-   *    void delete() {\n-   *        MyClass.nativeDelete(handle);\n-   *    }\n-   *\n-   *    private final long handle;\n-   * }\n-   * }</pre>\n-   *\n-   * A Java object \"owns\" a native resource if this resource should not survive beyond the lifetime\n-   * of this object.\n-   *\n-   * <p><b>IMPORTANT</b>: All nested subclasses of {@code NativeReference} must be declared as\n-   * static, otherwise their instances will hold an implicit reference to their enclosing object,\n-   * preventing the garbage collector to release them when they are no longer needed.\n-   */\n-  abstract static class NativeReference extends PhantomReference<Object> {\n-\n-    /** Attach a new phantom reference of {@code referent} to {@code session}. */\n-    public NativeReference(EagerSession session, Object referent) {\n-      super(referent, session.nativeResources.garbageQueue);\n-      session.checkSession();\n-      nativeResources = session.nativeResources;\n-      nativeResources.attach(this);\n-    }\n-\n-    /**\n-     * Detach this reference from its current session.\n-     *\n-     * <p>Clearing a NativeReference does not invoke {@link #delete()}, thus won't release the\n-     * native resources it refers to. It can be used when passing the ownership of those resources\n-     * to another object.\n-     *\n-     * <p>If native resources needs to be deleted as well, call {@link #delete()} explicitly.\n-     */\n-    @Override\n-    public void clear() {\n-      nativeResources.detach(this);\n-      super.clear();\n+  void attach(Pointer... resources) {\n+    checkSession();\n+    for (Pointer r : resources) {\n+      nativeResources.attach(r);\n     }\n-\n-    /** Releases all native resources owned by the referred object, now deleted. */\n-    abstract void delete();\n-\n-    private final NativeResourceCollector nativeResources;\n   }\n \n-  /**\n-   * Collects native references attached to this session and releases their resources if they are no\n-   * longer needed.\n-   */\n-  private static class NativeResourceCollector {\n-\n-    NativeResourceCollector(ReferenceQueue<Object> garbageQueue) {\n-      this.garbageQueue = garbageQueue;\n-    }\n-\n-    void attach(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        nativeRefs.put(nativeRef, null);\n-      }\n-    }\n-\n-    void detach(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        nativeRefs.remove(nativeRef);\n-      }\n-    }\n-\n-    void delete(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        if (!nativeRefs.keySet().remove(nativeRef)) {\n-          return; // safety check\n-        }\n-      }\n-      nativeRef.delete();\n-    }\n-\n-    void deleteAll() {\n-      synchronized (nativeRefs) {\n-        for (NativeReference nativeRef : nativeRefs.keySet()) {\n-          nativeRef.delete();\n-        }\n-        nativeRefs.clear();\n-      }\n-    }\n-\n-    void tryCleanup() {\n-      Reference<?> nativeRef;\n-      synchronized (nativeRefs) {\n-        while ((nativeRef = garbageQueue.poll()) != null) {\n-          delete((NativeReference) nativeRef);\n-        }\n-      }\n-    }\n-\n-    synchronized void startCleanupThread() {\n-      if (cleanupInBackground) {\n-        return; // ignore if cleanup thread is already running\n-      }\n-      try {\n-        cleanupInBackground = true;\n-        cleanupService.execute(\n-            new Runnable() {\n-              @Override\n-              public void run() {\n-                try {\n-                  while (cleanupInBackground) {\n-                    NativeReference nativeRef = (NativeReference) garbageQueue.remove();\n-                    delete(nativeRef);\n-                  }\n-                } catch (InterruptedException e) {\n-                  // exit\n-                }\n-              }\n-            });\n-      } catch (Exception e) {\n-        cleanupInBackground = false;\n-        throw e;\n+  void detach(Pointer... resources) {\n+    checkSession();\n+    for (Pointer r : resources) {\n+      if (resourceCleanupStrategy == ResourceCleanupStrategy.ON_SAFE_POINTS) {\n+          nativeRefs.attach(r);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 185}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccd6963468f8201d10412a8ff3aa3d482da8d832", "author": {"user": {"login": "saudet", "name": "Samuel Audet"}}, "url": "https://github.com/tensorflow/java/commit/ccd6963468f8201d10412a8ff3aa3d482da8d832", "committedDate": "2020-04-21T05:44:04Z", "message": "Fix nits"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NzQzMTc3", "url": "https://github.com/tensorflow/java/pull/42#pullrequestreview-398743177", "createdAt": "2020-04-23T04:00:54Z", "commit": {"oid": "ccd6963468f8201d10412a8ff3aa3d482da8d832"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNDowMDo1NFrOGKVhRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QwNDowMzo0NVrOGKVk7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5MTUyNQ==", "bodyText": "Then for the sake of simplicity, I opt to remove these options as well, the timing is still good for doing such changes. Anyway we can't disable the GC thread only at the eager session level anymore so they don't make much sense to have them there, if they have to be restored, it would be in a different place.", "url": "https://github.com/tensorflow/java/pull/42#discussion_r413491525", "createdAt": "2020-04-23T04:00:54Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerSession.java", "diffHunk": "@@ -364,174 +353,38 @@ ResourceCleanupStrategy resourceCleanupStrategy() {\n     return resourceCleanupStrategy;\n   }\n \n-  /**\n-   * A reference to one or more allocated native resources.\n-   *\n-   * <p>Any Java objects owning native resources must declare a reference to those resources in a\n-   * subclass that extends from {@code NativeReference}. When {@link NativeReference#delete()} is\n-   * invoked, the resources must be freed. For example:\n-   *\n-   * <pre>{@code\n-   * private static class NativeReference extends EagerSession.NativeReference {\n-   *\n-   *    NativeReference(EagerSession session, MyClass referent, long handle) {\n-   *        super(session, referent);\n-   *        this.handle = handle;\n-   *    }\n-   *\n-   *    @Override\n-   *    void delete() {\n-   *        MyClass.nativeDelete(handle);\n-   *    }\n-   *\n-   *    private final long handle;\n-   * }\n-   * }</pre>\n-   *\n-   * A Java object \"owns\" a native resource if this resource should not survive beyond the lifetime\n-   * of this object.\n-   *\n-   * <p><b>IMPORTANT</b>: All nested subclasses of {@code NativeReference} must be declared as\n-   * static, otherwise their instances will hold an implicit reference to their enclosing object,\n-   * preventing the garbage collector to release them when they are no longer needed.\n-   */\n-  abstract static class NativeReference extends PhantomReference<Object> {\n-\n-    /** Attach a new phantom reference of {@code referent} to {@code session}. */\n-    public NativeReference(EagerSession session, Object referent) {\n-      super(referent, session.nativeResources.garbageQueue);\n-      session.checkSession();\n-      nativeResources = session.nativeResources;\n-      nativeResources.attach(this);\n-    }\n-\n-    /**\n-     * Detach this reference from its current session.\n-     *\n-     * <p>Clearing a NativeReference does not invoke {@link #delete()}, thus won't release the\n-     * native resources it refers to. It can be used when passing the ownership of those resources\n-     * to another object.\n-     *\n-     * <p>If native resources needs to be deleted as well, call {@link #delete()} explicitly.\n-     */\n-    @Override\n-    public void clear() {\n-      nativeResources.detach(this);\n-      super.clear();\n+  void attach(Pointer... resources) {\n+    checkSession();\n+    for (Pointer r : resources) {\n+      nativeResources.attach(r);\n     }\n-\n-    /** Releases all native resources owned by the referred object, now deleted. */\n-    abstract void delete();\n-\n-    private final NativeResourceCollector nativeResources;\n   }\n \n-  /**\n-   * Collects native references attached to this session and releases their resources if they are no\n-   * longer needed.\n-   */\n-  private static class NativeResourceCollector {\n-\n-    NativeResourceCollector(ReferenceQueue<Object> garbageQueue) {\n-      this.garbageQueue = garbageQueue;\n-    }\n-\n-    void attach(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        nativeRefs.put(nativeRef, null);\n-      }\n-    }\n-\n-    void detach(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        nativeRefs.remove(nativeRef);\n-      }\n-    }\n-\n-    void delete(NativeReference nativeRef) {\n-      synchronized (nativeRefs) {\n-        if (!nativeRefs.keySet().remove(nativeRef)) {\n-          return; // safety check\n-        }\n-      }\n-      nativeRef.delete();\n-    }\n-\n-    void deleteAll() {\n-      synchronized (nativeRefs) {\n-        for (NativeReference nativeRef : nativeRefs.keySet()) {\n-          nativeRef.delete();\n-        }\n-        nativeRefs.clear();\n-      }\n-    }\n-\n-    void tryCleanup() {\n-      Reference<?> nativeRef;\n-      synchronized (nativeRefs) {\n-        while ((nativeRef = garbageQueue.poll()) != null) {\n-          delete((NativeReference) nativeRef);\n-        }\n-      }\n-    }\n-\n-    synchronized void startCleanupThread() {\n-      if (cleanupInBackground) {\n-        return; // ignore if cleanup thread is already running\n-      }\n-      try {\n-        cleanupInBackground = true;\n-        cleanupService.execute(\n-            new Runnable() {\n-              @Override\n-              public void run() {\n-                try {\n-                  while (cleanupInBackground) {\n-                    NativeReference nativeRef = (NativeReference) garbageQueue.remove();\n-                    delete(nativeRef);\n-                  }\n-                } catch (InterruptedException e) {\n-                  // exit\n-                }\n-              }\n-            });\n-      } catch (Exception e) {\n-        cleanupInBackground = false;\n-        throw e;\n+  void detach(Pointer... resources) {\n+    checkSession();\n+    for (Pointer r : resources) {\n+      if (resourceCleanupStrategy == ResourceCleanupStrategy.ON_SAFE_POINTS) {\n+          nativeRefs.attach(r);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgyNzAxNA=="}, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQ5MjQ2Mg==", "bodyText": "Then why not working to integrate a bit better the PointerScope in this PR? How would that work, the EagerSession needs to extend from it?", "url": "https://github.com/tensorflow/java/pull/42#discussion_r413492462", "createdAt": "2020-04-23T04:03:45Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -60,23 +58,28 @@\n     this.session = session;\n     this.type = type;\n     this.name = name;\n-    this.nativeRef = new NativeReference(session, this, allocate(session.nativeHandle(), type));\n+    this.opHandle = allocate(session.nativeHandle(), type);\n+    session.attach(opHandle);\n+    opHandle.releaseReference();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTgxOTA2Ng=="}, "originalCommit": {"oid": "67cdf9e97d70c1fedc683c4fd33108ce4ca344ef"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d65493aeb4e7fa3eea8a2eab9030a4f745658c4", "author": {"user": {"login": "saudet", "name": "Samuel Audet"}}, "url": "https://github.com/tensorflow/java/commit/8d65493aeb4e7fa3eea8a2eab9030a4f745658c4", "committedDate": "2020-04-23T04:27:50Z", "message": "Remove incorrectly generated op file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c0e1418e76ead150d9295783258d2aaf212e923", "author": {"user": {"login": "saudet", "name": "Samuel Audet"}}, "url": "https://github.com/tensorflow/java/commit/4c0e1418e76ead150d9295783258d2aaf212e923", "committedDate": "2020-04-23T12:20:58Z", "message": "Remove no longer useful ResourceCleanupStrategy"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f39f3a563d659493e6d9b5b3d2d140d144664f5", "author": {"user": {"login": "saudet", "name": "Samuel Audet"}}, "url": "https://github.com/tensorflow/java/commit/2f39f3a563d659493e6d9b5b3d2d140d144664f5", "committedDate": "2020-04-23T13:53:27Z", "message": "Use PointerScope everywhere"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4eef804a4fe101afb3a05ad6aa0e83f926e5b83e", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/4eef804a4fe101afb3a05ad6aa0e83f926e5b83e", "committedDate": "2020-04-28T03:44:28Z", "message": "Skip MKL-specific op and update protos (#1)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNDc2OTY1", "url": "https://github.com/tensorflow/java/pull/42#pullrequestreview-401476965", "createdAt": "2020-04-28T03:45:11Z", "commit": {"oid": "2f39f3a563d659493e6d9b5b3d2d140d144664f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMzo0NToxMlrOGNBNyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMzo0NToxMlrOGNBNyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwNDU4Nw==", "bodyText": "Can you please elaborate more on how PointerScope is working?\nFor instance, the scope define in this method is not passed anywhere so I assume that the pointer created by TFE_Op.newOp is automatically attached to it on creation? Then, since we are already in the scope of another PointerScope (the one passed as outputScope), would it be automatically attached to it as well if we were not declaring a new one here (and shouldn't that be enough)?\nIf it is not required, I think it would make the code easier to follow not having so many scopes declared during the process.", "url": "https://github.com/tensorflow/java/pull/42#discussion_r416304587", "createdAt": "2020-04-28T03:45:12Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/EagerOperationBuilder.java", "diffHunk": "@@ -277,22 +257,18 @@ private static void requireTensorHandle(TFE_TensorHandle handle) {\n     }\n   }\n \n-  private static TFE_Op allocate(TFE_Context ctxHandle, String type) {\n+  private static TFE_Op allocate(TFE_Context ctxHandle, String type, PointerScope outputScope) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f39f3a563d659493e6d9b5b3d2d140d144664f5"}, "originalPosition": 208}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2556f130d41b0962b0396181f70a2a0df81ccd4b", "author": {"user": {"login": "saudet", "name": "Samuel Audet"}}, "url": "https://github.com/tensorflow/java/commit/2556f130d41b0962b0396181f70a2a0df81ccd4b", "committedDate": "2020-04-28T12:52:42Z", "message": "Get rid of temporary output PointerScope objects"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxODQ0NDkx", "url": "https://github.com/tensorflow/java/pull/42#pullrequestreview-401844491", "createdAt": "2020-04-28T13:39:29Z", "commit": {"oid": "2556f130d41b0962b0396181f70a2a0df81ccd4b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3441, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}