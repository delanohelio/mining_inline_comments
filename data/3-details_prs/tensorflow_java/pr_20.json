{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1NjQ5OTM3", "number": 20, "title": "Scalars and vectors", "bodyText": "This PR is a suggestion to improve the creation of constants for invoking TensorFlow ops, either in graph or eager mode.\nRight now, everything goes through the constant operator, which supports a huge list of possible constructor, most of them being standard arrays that increases in rank.\nIn the current PR, I deprecate most of them as we should use the NdArray API to create multidimensional arrays for better performances in general. Further more, the constructor that takes a single primitive value in parameter is now handled by the new scalar op and the one taking a single array goes to the vector op. For example:\ntf.constant(int) // -> tf.scalar(int)\ntf.constant(int[]) // -> tf.vector(int...)\ntf.constant(int[][]) // -> deprecated\ntf.constant(int[][][]) // -> deprecated\ntf.constant(Shape, IntBuffer) // -> deprecated\ntf.constant(Tensor<TInt32>) // -> remains, Tensor<TInt32> can be created from an NdArray\n\nThe reason of create two new distinct ops scalar and vector is that it allows us to use variadic parameters for creating constant of rank-1 with the need of always allocating a new array, i.e.\n// commonly saw in current code\nConstant<TInt32> v1 = tf.constant(new int[] { 1, 2, 3, 4 });\n// vs. new code\nVector<TInt32> v2 = tf.vector(1, 2, 3, 4);\n\nSo the new code is less verbose. And having distinct variable types like Scalar and Vector can be useful as an indicator of the rank of a tensor carried in a given constant.\nAlso, a vector can be created from a Shape object, as often a shape needs to be passed as an operand to an op (note that could have been done in constant as well). For example:\nTensor<TInt32> t = TInt32.ofShape(2, 2, 2);\n...\n// current code, array must match shape of the tensor \ntf.fill(tf.constant(new long[] { 2, 2, 2 }), tf.constant(1.0f));\n// vs. new code\ntf.fill(tf.vector(t.shape()), tf.scalar(1.0f));\n\nI found that the usage of those three different variants for creating constants, i.e scalar, vector and constant, creates richer and cleaner code but I would like to hear your comments on it.\nCC: @Craigacp, @EronWright, @dhruvrajan", "createdAt": "2020-01-22T03:52:46Z", "url": "https://github.com/tensorflow/java/pull/20", "merged": true, "mergeCommit": {"oid": "390bfba9b35e443339fac711fbfbb86f1297ca27"}, "closed": true, "closedAt": "2020-02-14T23:09:11Z", "author": {"login": "karllessard"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBtEtsgBqjMwMTQ1MDU2MjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcDvCatABqjMwMzI4NzYyNDc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5a3b45f014d7265b3b7e8fcdb65abfa7eafda25a", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/5a3b45f014d7265b3b7e8fcdb65abfa7eafda25a", "committedDate": "2020-01-22T03:27:09Z", "message": "Add Scalar and Vector ops"}, "afterCommit": {"oid": "34b9d7072fecd54e4b4542de02cdf5c285b74408", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/34b9d7072fecd54e4b4542de02cdf5c285b74408", "committedDate": "2020-02-06T16:06:59Z", "message": "Add Matrix operator"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "34b9d7072fecd54e4b4542de02cdf5c285b74408", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/34b9d7072fecd54e4b4542de02cdf5c285b74408", "committedDate": "2020-02-06T16:06:59Z", "message": "Add Matrix operator"}, "afterCommit": {"oid": "c9cad150cbc245edb92057b9f7e941750080e432", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/c9cad150cbc245edb92057b9f7e941750080e432", "committedDate": "2020-02-06T17:12:33Z", "message": "Add Matrix operator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MDk1NTk5", "url": "https://github.com/tensorflow/java/pull/20#pullrequestreview-356095599", "createdAt": "2020-02-10T16:49:01Z", "commit": {"oid": "c9cad150cbc245edb92057b9f7e941750080e432"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjo0OTowMlrOFnthnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjo0OTowMlrOFnthnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4NDY3MQ==", "bodyText": "The copyright on new files should probably be 2020.", "url": "https://github.com/tensorflow/java/pull/20#discussion_r377184671", "createdAt": "2020-02-10T16:49:02Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/Matrix.java", "diffHunk": "@@ -0,0 +1,563 @@\n+/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9cad150cbc245edb92057b9f7e941750080e432"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MDk3MjI1", "url": "https://github.com/tensorflow/java/pull/20#pullrequestreview-356097225", "createdAt": "2020-02-10T16:50:52Z", "commit": {"oid": "c9cad150cbc245edb92057b9f7e941750080e432"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjo1MDo1MlrOFntmzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNjo1MDo1MlrOFntmzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE4NTk5Ng==", "bodyText": "Is a 4-rank object really a matrix? Should these be moved to tensorConstant or some other name? Also the javadoc should probably note that these are slower than other ways of creating a 4-rank object.", "url": "https://github.com/tensorflow/java/pull/20#discussion_r377185996", "createdAt": "2020-02-10T16:50:52Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/Matrix.java", "diffHunk": "@@ -0,0 +1,563 @@\n+/* Copyright 2017 The TensorFlow Authors. All Rights Reserved.\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+    http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License.\n+==============================================================================*/\n+\n+package org.tensorflow.op.core;\n+\n+import org.tensorflow.Operation;\n+import org.tensorflow.Tensor;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.op.annotation.Operator;\n+import org.tensorflow.tools.ndarray.NdArray;\n+import org.tensorflow.tools.ndarray.NdArrays;\n+import org.tensorflow.tools.ndarray.StdArrays;\n+import org.tensorflow.types.TBool;\n+import org.tensorflow.types.TFloat32;\n+import org.tensorflow.types.TFloat64;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+import org.tensorflow.types.TString;\n+import org.tensorflow.types.TUint8;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * An operator producing a matrix (rank-2 or higher) constant value.\n+ */\n+@Operator\n+public final class Matrix<T extends TType> extends Constant<T> {\n+\n+  /**\n+   * Creates a rank-2 constant of {@code int} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TInt32} constant matrix\n+   */\n+  public static Matrix<TInt32> create(Scope scope, int[][] data) {\n+    try (Tensor<TInt32> value = TInt32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-3 constant of {@code int} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TInt32} constant matrix\n+   */\n+  public static Matrix<TInt32> create(Scope scope, int[][][] data) {\n+    try (Tensor<TInt32> value = TInt32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-4 constant of {@code int} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TInt32} constant matrix\n+   */\n+  public static Matrix<TInt32> create(Scope scope, int[][][][] data) {\n+    try (Tensor<TInt32> value = TInt32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-5 constant of {@code int} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TInt32} constant matrix\n+   */\n+  public static Matrix<TInt32> create(Scope scope, int[][][][][] data) {\n+    try (Tensor<TInt32> value = TInt32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-6 constant of {@code int} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TInt32} constant matrix\n+   */\n+  public static Matrix<TInt32> create(Scope scope, int[][][][][][] data) {\n+    try (Tensor<TInt32> value = TInt32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-2 constant of {@code float} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TFloat32} constant matrix\n+   */\n+  public static Matrix<TFloat32> create(Scope scope, float[][] data) {\n+    try (Tensor<TFloat32> value = TFloat32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-3 constant of {@code float} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TFloat32} constant matrix\n+   */\n+  public static Matrix<TFloat32> create(Scope scope, float[][][] data) {\n+    try (Tensor<TFloat32> value = TFloat32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-4 constant of {@code float} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TFloat32} constant matrix\n+   */\n+  public static Matrix<TFloat32> create(Scope scope, float[][][][] data) {\n+    try (Tensor<TFloat32> value = TFloat32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-5 constant of {@code float} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TFloat32} constant matrix\n+   */\n+  public static Matrix<TFloat32> create(Scope scope, float[][][][][] data) {\n+    try (Tensor<TFloat32> value = TFloat32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-6 constant of {@code float} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TFloat32} constant matrix\n+   */\n+  public static Matrix<TFloat32> create(Scope scope, float[][][][][][] data) {\n+    try (Tensor<TFloat32> value = TFloat32.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-2 constant of {@code double} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TFloat64} constant matrix\n+   */\n+  public static Matrix<TFloat64> create(Scope scope, double[][] data) {\n+    try (Tensor<TFloat64> value = TFloat64.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-3 constant of {@code double} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TFloat64} constant matrix\n+   */\n+  public static Matrix<TFloat64> create(Scope scope, double[][][] data) {\n+    try (Tensor<TFloat64> value = TFloat64.tensorOf(StdArrays.shapeOf(data), t -> StdArrays.copyTo(t, data))) {\n+      return createFromTensor(scope, value);\n+    }\n+  }\n+\n+  /**\n+   * Creates a rank-4 constant of {@code double} elements.\n+   *\n+   * @param scope is a scope used to add the underlying operation.\n+   * @param data An array containing the values to put into the new constant. The dimensions of the\n+   *     new constant will match those of the array.\n+   * @return a {@link TFloat64} constant matrix\n+   */\n+  public static Matrix<TFloat64> create(Scope scope, double[][][][] data) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9cad150cbc245edb92057b9f7e941750080e432"}, "originalPosition": 216}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2MTA3NjI0", "url": "https://github.com/tensorflow/java/pull/20#pullrequestreview-356107624", "createdAt": "2020-02-10T17:04:14Z", "commit": {"oid": "c9cad150cbc245edb92057b9f7e941750080e432"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNzowNDoxNFrOFnuG1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQxNzowNDoxNFrOFnuG1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzE5NDE5Ng==", "bodyText": "Is this the behaviour we want for ragged tensors? The ndarray machinery is mostly predicated on the ndarray being a hyperrectangle, is everything robust to getting a Shape.UNKNOWN_SIZE?", "url": "https://github.com/tensorflow/java/pull/20#discussion_r377194196", "createdAt": "2020-02-10T17:04:14Z", "author": {"login": "Craigacp"}, "path": "tensorflow-tools/src/main/java/org/tensorflow/tools/ndarray/StdArrays.java", "diffHunk": "@@ -0,0 +1,1476 @@\n+package org.tensorflow.tools.ndarray;\n+\n+import static org.tensorflow.tools.ndarray.NdArrays.vectorOf;\n+import static org.tensorflow.tools.ndarray.NdArrays.vectorOfObjects;\n+\n+import org.tensorflow.tools.Shape;\n+\n+/**\n+ * Utility class for working with {@link NdArray} instances mixed with standard Java arrays.\n+ */\n+public final class StdArrays {\n+\n+  /**\n+   * Copy a single-dimension array of ints into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-1 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-1 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(IntNdArray dst, int[] array) {\n+    vectorOf(array).copyTo(dst);\n+  }\n+\n+  /**\n+   * Copy a 2-dimensions array of ints into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-2 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-2 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(IntNdArray dst, int[][] array) {\n+    dst.elements(0).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 3-dimensions array of ints into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-3 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-3 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(IntNdArray dst, int[][][] array) {\n+    dst.elements(1).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 4-dimensions array of ints into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-4 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-4 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(IntNdArray dst, int[][][][] array) {\n+    dst.elements(2).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 5-dimensions array of ints into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-5 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-5 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(IntNdArray dst, int[][][][][] array) {\n+    dst.elements(3).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 6-dimensions array of ints into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-6 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-6 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(IntNdArray dst, int[][][][][][] array) {\n+    dst.elements(4).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]][(int)idx[4]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a single-dimension array of longs into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-1 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-1 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(LongNdArray dst, long[] array) {\n+    vectorOf(array).copyTo(dst);\n+  }\n+\n+  /**\n+   * Copy a 2-dimensions array of longs into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-2 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-2 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(LongNdArray dst, long[][] array) {\n+    dst.elements(0).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 3-dimensions array of longs into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-3 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-3 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(LongNdArray dst, long[][][] array) {\n+    dst.elements(1).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 4-dimensions array of longs into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-4 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-4 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(LongNdArray dst, long[][][][] array) {\n+    dst.elements(2).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 5-dimensions array of longs into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-5 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-5 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(LongNdArray dst, long[][][][][] array) {\n+    dst.elements(3).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 6-dimensions array of longs into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-6 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-6 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(LongNdArray dst, long[][][][][][] array) {\n+    dst.elements(4).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]][(int)idx[4]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a single-dimension array of floats into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-1 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-1 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(FloatNdArray dst, float[] array) {\n+    vectorOf(array).copyTo(dst);\n+  }\n+\n+  /**\n+   * Copy a 2-dimensions array of floats into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-2 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-2 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(FloatNdArray dst, float[][] array) {\n+    dst.elements(0).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 3-dimensions array of floats into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-3 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-3 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(FloatNdArray dst, float[][][] array) {\n+    dst.elements(1).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 4-dimensions array of floats into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-4 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-4 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(FloatNdArray dst, float[][][][] array) {\n+    dst.elements(2).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 5-dimensions array of floats into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-5 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-5 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(FloatNdArray dst, float[][][][][] array) {\n+    dst.elements(3).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 6-dimensions array of floats into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-6 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-6 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(FloatNdArray dst, float[][][][][][] array) {\n+    dst.elements(4).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]][(int)idx[4]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a single-dimension array of doubles into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-1 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-1 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(DoubleNdArray dst, double[] array) {\n+    vectorOf(array).copyTo(dst);\n+  }\n+\n+  /**\n+   * Copy a 2-dimensions array of doubles into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-2 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-2 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(DoubleNdArray dst, double[][] array) {\n+    dst.elements(0).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 3-dimensions array of doubles into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-3 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-3 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(DoubleNdArray dst, double[][][] array) {\n+    dst.elements(1).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 4-dimensions array of doubles into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-4 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-4 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(DoubleNdArray dst, double[][][][] array) {\n+    dst.elements(2).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 5-dimensions array of doubles into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-5 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-5 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(DoubleNdArray dst, double[][][][][] array) {\n+    dst.elements(3).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 6-dimensions array of doubles into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-6 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-6 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(DoubleNdArray dst, double[][][][][][] array) {\n+    dst.elements(4).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]][(int)idx[4]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a single-dimension array of bytes into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-1 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-1 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ByteNdArray dst, byte[] array) {\n+    vectorOf(array).copyTo(dst);\n+  }\n+\n+  /**\n+   * Copy a 2-dimensions array of bytes into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-2 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-2 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ByteNdArray dst, byte[][] array) {\n+    dst.elements(0).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 3-dimensions array of bytes into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-3 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-3 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ByteNdArray dst, byte[][][] array) {\n+    dst.elements(1).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 4-dimensions array of bytes into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-4 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-4 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ByteNdArray dst, byte[][][][] array) {\n+    dst.elements(2).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 5-dimensions array of bytes into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-5 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-5 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ByteNdArray dst, byte[][][][][] array) {\n+    dst.elements(3).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 6-dimensions array of bytes into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-6 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-6 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ByteNdArray dst, byte[][][][][][] array) {\n+    dst.elements(4).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]][(int)idx[4]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a single-dimension array of shorts into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-1 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-1 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ShortNdArray dst, short[] array) {\n+    vectorOf(array).copyTo(dst);\n+  }\n+\n+  /**\n+   * Copy a 2-dimensions array of shorts into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-2 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-2 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ShortNdArray dst, short[][] array) {\n+    dst.elements(0).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 3-dimensions array of shorts into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-3 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-3 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ShortNdArray dst, short[][][] array) {\n+    dst.elements(1).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 4-dimensions array of shorts into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-4 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-4 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ShortNdArray dst, short[][][][] array) {\n+    dst.elements(2).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 5-dimensions array of shorts into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-5 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-5 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ShortNdArray dst, short[][][][][] array) {\n+    dst.elements(3).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 6-dimensions array of shorts into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-6 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-6 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(ShortNdArray dst, short[][][][][][] array) {\n+    dst.elements(4).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]][(int)idx[4]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a single-dimension array of booleans into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-1 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-1 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(BooleanNdArray dst, boolean[] array) {\n+    vectorOf(array).copyTo(dst);\n+  }\n+\n+  /**\n+   * Copy a 2-dimensions array of booleans into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-2 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-2 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(BooleanNdArray dst, boolean[][] array) {\n+    dst.elements(0).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 3-dimensions array of booleans into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-3 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-3 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(BooleanNdArray dst, boolean[][][] array) {\n+    dst.elements(1).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 4-dimensions array of booleans into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-4 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-4 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(BooleanNdArray dst, boolean[][][][] array) {\n+    dst.elements(2).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 5-dimensions array of booleans into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-5 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-5 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(BooleanNdArray dst, boolean[][][][][] array) {\n+    dst.elements(3).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 6-dimensions array of booleans into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-6 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-6 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static void copyTo(BooleanNdArray dst, boolean[][][][][][] array) {\n+    dst.elements(4).forEachIndexed((idx, e) ->\n+        vectorOf(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]][(int)idx[4]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a single-dimension array of objects into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-1 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-1 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static <T> void copyTo(NdArray<T> dst, T[] array) {\n+    vectorOfObjects(array).copyTo(dst);\n+  }\n+\n+  /**\n+   * Copy a 2-dimensions array of objects into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-2 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-2 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static <T> void copyTo(NdArray<T> dst, T[][] array) {\n+    dst.elements(0).forEachIndexed((idx, e) ->\n+        vectorOfObjects(array[(int)idx[0]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 3-dimensions array of objects into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-3 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-3 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static <T> void copyTo(NdArray<T> dst, T[][][] array) {\n+    dst.elements(1).forEachIndexed((idx, e) ->\n+        vectorOfObjects(array[(int)idx[0]][(int)idx[1]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 4-dimensions array of objects into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-4 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-4 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static <T> void copyTo(NdArray<T> dst, T[][][][] array) {\n+    dst.elements(2).forEachIndexed((idx, e) ->\n+        vectorOfObjects(array[(int)idx[0]][(int)idx[1]][(int)idx[2]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 5-dimensions array of objects into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-5 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-5 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static <T> void copyTo(NdArray<T> dst, T[][][][][] array) {\n+    dst.elements(3).forEachIndexed((idx, e) ->\n+        vectorOfObjects(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Copy a 6-dimensions array of objects into the {@code dst} {@link NdArray}\n+   *\n+   * @param dst destination rank-6 array\n+   * @param array source array\n+   * @throws IllegalArgumentException if {@code dst} is not of rank-6 or has an incompatible shape\n+   *                                  with the source array\n+   */\n+  public static <T> void copyTo(NdArray<T> dst, T[][][][][][] array) {\n+    dst.elements(4).forEachIndexed((idx, e) ->\n+        vectorOfObjects(array[(int)idx[0]][(int)idx[1]][(int)idx[2]][(int)idx[3]][(int)idx[4]]).copyTo(e)\n+    );\n+  }\n+\n+  /**\n+   * Compute the shape of a single-dimension int array.\n+   *\n+   * @param array 1D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(int[] array) {\n+    return Shape.of(array.length);\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions int array.\n+   *\n+   * @param array 2D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(int[][] array) {\n+    return Shape.of(computeShape(array, new long[2]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions int array.\n+   *\n+   * @param array 3D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(int[][][] array) {\n+    return Shape.of(computeShape(array, new long[3]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 4-dimensions int array.\n+   *\n+   * @param array 4D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(int[][][][] array) {\n+    return Shape.of(computeShape(array, new long[4]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 5-dimensions int array.\n+   *\n+   * @param array 5D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(int[][][][][] array) {\n+    return Shape.of(computeShape(array, new long[5]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 6-dimensions int array.\n+   *\n+   * @param array 6D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(int[][][][][][] array) {\n+    return Shape.of(computeShape(array, new long[6]));\n+  }\n+\n+  /**\n+   * Compute the shape of a single-dimension long array.\n+   *\n+   * @param array 1D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(long[] array) {\n+    return Shape.of(array.length);\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions long array.\n+   *\n+   * @param array 2D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(long[][] array) {\n+    return Shape.of(computeShape(array, new long[2]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions long array.\n+   *\n+   * @param array 3D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(long[][][] array) {\n+    return Shape.of(computeShape(array, new long[3]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 4-dimensions long array.\n+   *\n+   * @param array 4D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(long[][][][] array) {\n+    return Shape.of(computeShape(array, new long[4]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 5-dimensions long array.\n+   *\n+   * @param array 5D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(long[][][][][] array) {\n+    return Shape.of(computeShape(array, new long[5]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 6-dimensions long array.\n+   *\n+   * @param array 6D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(long[][][][][][] array) {\n+    return Shape.of(computeShape(array, new long[6]));\n+  }\n+\n+  /**\n+   * Compute the shape of a single-dimension float array.\n+   *\n+   * @param array 1D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(float[] array) {\n+    return Shape.of(array.length);\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions float array.\n+   *\n+   * @param array 2D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(float[][] array) {\n+    return Shape.of(computeShape(array, new long[2]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions float array.\n+   *\n+   * @param array 3D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(float[][][] array) {\n+    return Shape.of(computeShape(array, new long[3]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 4-dimensions float array.\n+   *\n+   * @param array 4D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(float[][][][] array) {\n+    return Shape.of(computeShape(array, new long[4]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 5-dimensions float array.\n+   *\n+   * @param array 5D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(float[][][][][] array) {\n+    return Shape.of(computeShape(array, new long[5]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 6-dimensions float array.\n+   *\n+   * @param array 6D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(float[][][][][][] array) {\n+    return Shape.of(computeShape(array, new long[6]));\n+  }\n+\n+  /**\n+   * Compute the shape of a single-dimension double array.\n+   *\n+   * @param array 1D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(double[] array) {\n+    return Shape.of(array.length);\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions double array.\n+   *\n+   * @param array 2D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(double[][] array) {\n+    return Shape.of(computeShape(array, new long[2]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions double array.\n+   *\n+   * @param array 3D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(double[][][] array) {\n+    return Shape.of(computeShape(array, new long[3]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 4-dimensions double array.\n+   *\n+   * @param array 4D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(double[][][][] array) {\n+    return Shape.of(computeShape(array, new long[4]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 5-dimensions double array.\n+   *\n+   * @param array 5D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(double[][][][][] array) {\n+    return Shape.of(computeShape(array, new long[5]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 6-dimensions double array.\n+   *\n+   * @param array 6D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(double[][][][][][] array) {\n+    return Shape.of(computeShape(array, new long[6]));\n+  }\n+\n+  /**\n+   * Compute the shape of a single-dimension byte array.\n+   *\n+   * @param array 1D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(byte[] array) {\n+    return Shape.of(array.length);\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions byte array.\n+   *\n+   * @param array 2D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(byte[][] array) {\n+    return Shape.of(computeShape(array, new long[2]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions byte array.\n+   *\n+   * @param array 3D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(byte[][][] array) {\n+    return Shape.of(computeShape(array, new long[3]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 4-dimensions byte array.\n+   *\n+   * @param array 4D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(byte[][][][] array) {\n+    return Shape.of(computeShape(array, new long[4]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 5-dimensions byte array.\n+   *\n+   * @param array 5D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(byte[][][][][] array) {\n+    return Shape.of(computeShape(array, new long[5]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 6-dimensions byte array.\n+   *\n+   * @param array 6D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(byte[][][][][][] array) {\n+    return Shape.of(computeShape(array, new long[6]));\n+  }\n+\n+  /**\n+   * Compute the shape of a single-dimension short array.\n+   *\n+   * @param array 1D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(short[] array) {\n+    return Shape.of(array.length);\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions short array.\n+   *\n+   * @param array 2D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(short[][] array) {\n+    return Shape.of(computeShape(array, new long[2]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions short array.\n+   *\n+   * @param array 3D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(short[][][] array) {\n+    return Shape.of(computeShape(array, new long[3]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 4-dimensions short array.\n+   *\n+   * @param array 4D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(short[][][][] array) {\n+    return Shape.of(computeShape(array, new long[4]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 5-dimensions short array.\n+   *\n+   * @param array 5D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(short[][][][][] array) {\n+    return Shape.of(computeShape(array, new long[5]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 6-dimensions short array.\n+   *\n+   * @param array 6D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(short[][][][][][] array) {\n+    return Shape.of(computeShape(array, new long[6]));\n+  }\n+\n+  /**\n+   * Compute the shape of a single-dimension boolean array.\n+   *\n+   * @param array 1D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(boolean[] array) {\n+    return Shape.of(array.length);\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions boolean array.\n+   *\n+   * @param array 2D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(boolean[][] array) {\n+    return Shape.of(computeShape(array, new long[2]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions boolean array.\n+   *\n+   * @param array 3D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(boolean[][][] array) {\n+    return Shape.of(computeShape(array, new long[3]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 4-dimensions boolean array.\n+   *\n+   * @param array 4D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(boolean[][][][] array) {\n+    return Shape.of(computeShape(array, new long[4]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 5-dimensions boolean array.\n+   *\n+   * @param array 5D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(boolean[][][][][] array) {\n+    return Shape.of(computeShape(array, new long[5]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 6-dimensions boolean array.\n+   *\n+   * @param array 6D array\n+   * @return shape of the array\n+   */\n+  public static Shape shapeOf(boolean[][][][][][] array) {\n+    return Shape.of(computeShape(array, new long[6]));\n+  }\n+\n+  /**\n+   * Compute the shape of a single-dimension object array.\n+   *\n+   * @param array 1D array\n+   * @return shape of the array\n+   */\n+  public static <T> Shape shapeOf(T[] array) {\n+    return Shape.of(array.length);\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions object array.\n+   *\n+   * @param array 2D array\n+   * @return shape of the array\n+   */\n+  public static <T> Shape shapeOf(T[][] array) {\n+    return Shape.of(computeShape(array, new long[2]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 3-dimensions object array.\n+   *\n+   * @param array 3D array\n+   * @return shape of the array\n+   */\n+  public static <T> Shape shapeOf(T[][][] array) {\n+    return Shape.of(computeShape(array, new long[3]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 4-dimensions object array.\n+   *\n+   * @param array 4D array\n+   * @return shape of the array\n+   */\n+  public static <T> Shape shapeOf(T[][][][] array) {\n+    return Shape.of(computeShape(array, new long[4]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 5-dimensions object array.\n+   *\n+   * @param array 5D array\n+   * @return shape of the array\n+   */\n+  public static <T> Shape shapeOf(T[][][][][] array) {\n+    return Shape.of(computeShape(array, new long[5]));\n+  }\n+\n+  /**\n+   * Compute the shape of a 6-dimensions object array.\n+   *\n+   * @param array 6D array\n+   * @return shape of the array\n+   */\n+  public static <T> Shape shapeOf(T[][][][][][] array) {\n+    return Shape.of(computeShape(array, new long[6]));\n+  }\n+\n+  private static void dimSize(int arrayLength, long[] shape, int dimIdx) {\n+    if (shape[dimIdx] == 0) {\n+      shape[dimIdx] = arrayLength;\n+    } else if (shape[dimIdx] != arrayLength) {\n+      shape[dimIdx] = Shape.UNKNOWN_SIZE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9cad150cbc245edb92057b9f7e941750080e432"}, "originalPosition": 1153}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "400536c04e1745ff09ef555e8acd760939f7c8f1", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/400536c04e1745ff09ef555e8acd760939f7c8f1", "committedDate": "2020-02-12T23:00:17Z", "message": "Close default eager session for testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb98f16556db7b9541ec2d9537e80b8ac17dddb7", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/cb98f16556db7b9541ec2d9537e80b8ac17dddb7", "committedDate": "2020-02-12T23:02:01Z", "message": "Add support for deprecated ops"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23f9123116b4451825fa8f33ea5447e4d4b32693", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/23f9123116b4451825fa8f33ea5447e4d4b32693", "committedDate": "2020-02-12T23:02:03Z", "message": "Add Scalar and Vector ops"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e825b8711d230a6e81741c65c4b7c2e003860536", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/e825b8711d230a6e81741c65c4b7c2e003860536", "committedDate": "2020-02-12T23:02:03Z", "message": "Rename a few methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c590483bb0ef5626e1e4498e089fa403e4130358", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/c590483bb0ef5626e1e4498e089fa403e4130358", "committedDate": "2020-02-12T23:02:03Z", "message": "Cleanup types factories"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba3eb49c322e3a3eb614b3582b7ed70f56780ca1", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/ba3eb49c322e3a3eb614b3582b7ed70f56780ca1", "committedDate": "2020-02-12T23:02:03Z", "message": "Add StdArrays utilities"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "785bf7b936d04734a9b53e79d32efc682c3785e6", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/785bf7b936d04734a9b53e79d32efc682c3785e6", "committedDate": "2020-02-12T23:02:03Z", "message": "Add Matrix operator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "172dd5f7e6a9104d8d5ae5f6e0a1cd4cb8417a3a", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/172dd5f7e6a9104d8d5ae5f6e0a1cd4cb8417a3a", "committedDate": "2020-02-12T23:02:03Z", "message": "Reduce constants to 'val' and 'array'"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c9cad150cbc245edb92057b9f7e941750080e432", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/c9cad150cbc245edb92057b9f7e941750080e432", "committedDate": "2020-02-06T17:12:33Z", "message": "Add Matrix operator"}, "afterCommit": {"oid": "c6edd32e8f75b6db749cce71c6b4a4f2e84a115a", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/c6edd32e8f75b6db749cce71c6b4a4f2e84a115a", "committedDate": "2020-02-12T23:23:45Z", "message": "Reduce constants to 'val' and 'array'"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c73b39586ee490f3ec0a8bb07ea67530e6c95ab", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/8c73b39586ee490f3ec0a8bb07ea67530e6c95ab", "committedDate": "2020-02-12T23:35:43Z", "message": "Reduce constants to 'val' and 'array'"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c6edd32e8f75b6db749cce71c6b4a4f2e84a115a", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/c6edd32e8f75b6db749cce71c6b4a4f2e84a115a", "committedDate": "2020-02-12T23:23:45Z", "message": "Reduce constants to 'val' and 'array'"}, "afterCommit": {"oid": "8c73b39586ee490f3ec0a8bb07ea67530e6c95ab", "author": {"user": {"login": "karllessard", "name": "Karl Lessard"}}, "url": "https://github.com/tensorflow/java/commit/8c73b39586ee490f3ec0a8bb07ea67530e6c95ab", "committedDate": "2020-02-12T23:35:43Z", "message": "Reduce constants to 'val' and 'array'"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3432, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}