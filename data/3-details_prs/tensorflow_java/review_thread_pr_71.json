{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0MTY1NzU5", "number": 71, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMDozNjowNVrOEFsAGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMToxODo0NFrOEGkQ5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Mzk5MjU5OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMDozNjowNVrOGkB0pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMDo1MjoxMlrOGkCUHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzMTc4Mw==", "bodyText": "Please add the right license header (i.e. the non-Oracle one that references Tensorflow authors).", "url": "https://github.com/tensorflow/java/pull/71#discussion_r440431783", "createdAt": "2020-06-15T20:36:05Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9da3b9e9d52d917d4b30381a3bed0afba1b99014"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzOTgzOA==", "bodyText": "OK", "url": "https://github.com/tensorflow/java/pull/71#discussion_r440439838", "createdAt": "2020-06-15T20:52:12Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzMTc4Mw=="}, "originalCommit": {"oid": "9da3b9e9d52d917d4b30381a3bed0afba1b99014"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Mzk5NjI5OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/op/core/ShapeOpsTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMDozNzoxNFrOGkB28w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMDo0MzoxN1rOGkCCvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzMjM3MQ==", "bodyText": "What's this test trying to do?", "url": "https://github.com/tensorflow/java/pull/71#discussion_r440432371", "createdAt": "2020-06-15T20:37:14Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/op/core/ShapeOpsTest.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * To change this license header, choose License Headers in Project Properties.\n+ * To change this template file, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package org.tensorflow.keras.utils;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/***\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+****/\n+\n+\n+import org.tensorflow.Graph;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Session;\n+import org.tensorflow.Tensor;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.op.core.Constant;\n+import org.tensorflow.op.core.Reshape;\n+import org.tensorflow.op.core.Shape;\n+import org.tensorflow.types.TFloat32;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+\n+/**\n+ *\n+ * @author jbclarke\n+ */\n+@RunWith(JUnit4.class)\n+public class ShapeOpsTest {\n+    \n+    public ShapeOpsTest() {\n+    }\n+    \n+\n+    /**\n+     * Test of create method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testCreate_Scope() {\n+        try (Graph g = new Graph();\n+                Session sess = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps stf = ShapeOps.create(scope);\n+            assertEquals(scope, stf.scope());\n+            assertEquals(TInt32.DTYPE, stf.datatype());\n+        }\n+    }\n+\n+    /**\n+     * Test of create method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testCreate_Scope_DataType() {\n+        System.out.println(\"create DataType\");\n+        try (Graph g = new Graph();\n+                Session sess = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps stf = ShapeOps.create(scope, TInt64.DTYPE);\n+            assertEquals(scope, stf.scope());\n+            assertEquals(TInt64.DTYPE, stf.datatype());\n+        }\n+    }\n+\n+    /**\n+     * Test of flatten method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testFlatten_Operand() {\n+        System.out.println(\"flatten operand\");\n+        try (Graph g = new Graph();\n+                Session session = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps instance = ShapeOps.create(scope, TInt64.DTYPE);\n+            Operand<TFloat32> operand = Constant.arrayOf(scope, new float[]{1, 2, 3, 4, 5, 6, 7, 8});\n+            Shape<TInt64> expResult = Shape.create(scope, operand, TInt64.DTYPE);\n+            Operand<TFloat32> reshaped = Reshape.create(scope, operand, Constant.vectorOf(scope, new long[]{4, 2, 1}));\n+            Operand actual = instance.flatten(reshaped);\n+            Shape<TInt64> tfshape = Shape.create(scope, actual, TInt64.DTYPE);\n+\n+            AtomicInteger index = new AtomicInteger();\n+            try (Tensor<TInt64> result1 = session.runner().fetch(tfshape.asOutput()).run().get(0).expect(TInt64.DTYPE);\n+                    Tensor<TInt64> result2 = session.runner().fetch(expResult.asOutput()).run().get(0).expect(TInt64.DTYPE)) {\n+                result1.data().scalars().forEach(s -> assertEquals(\n+                        result2.data().getLong(index.getAndIncrement()), s.getLong()));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test of flatten method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testFlatten_Shape() {\n+        System.out.println(\"flatten shape\");\n+        try (Graph g = new Graph();\n+                Session session = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps instance = ShapeOps.create(scope, TInt64.DTYPE);\n+            Operand operand = Constant.arrayOf(scope, new float[] {1, 2, 3, 4, 5, 6, 7, 8} );\n+            Shape<TInt64> expShape = Shape.create(scope, operand, TInt64.DTYPE);\n+            Operand actual = Reshape.create(scope, operand, Constant.vectorOf(scope, new long[] { 4,2,1} ));\n+            Shape<TInt64> tfshape = Shape.create(scope, actual, TInt64.DTYPE);\n+            Operand<TInt64> flattened = instance.flatten(tfshape);\n+            \n+            \n+            AtomicInteger index = new AtomicInteger();\n+            try (Tensor<TInt64> result1 = session.runner().fetch(flattened.asOutput()).run().get(0).expect(TInt64.DTYPE);\n+                    Tensor<TInt64> result2 = session.runner().fetch(expShape.asOutput()).run().get(0).expect(TInt64.DTYPE)) {\n+                result1.data().scalars().forEach(s -> assertEquals(\n+                        result2.data().getLong(index.getAndIncrement()), s.getLong()));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test of size method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testSize_Shape() {\n+        System.out.println(\"size\");\n+        try (Graph g = new Graph();\n+                Session session = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps instance = ShapeOps.create(scope, TInt64.DTYPE);\n+            Operand operand = Constant.arrayOf(scope, new float[] {1, 2, 3, 4, 5, 6, 7, 8} );\n+            Operand actual = Reshape.create(scope, operand, Constant.vectorOf(scope, new long[] { 4,2,1} ));\n+            Shape<TInt64> tfshape = Shape.create(scope, actual, TInt64.DTYPE);\n+            Operand<TInt64> size = instance.size(tfshape);\n+            \n+            \n+            AtomicInteger index = new AtomicInteger();\n+            try (Tensor<TInt64> result1 = session.runner().fetch(size.asOutput()).run().get(0).expect(TInt64.DTYPE)) {\n+                result1.data().scalars().forEach(s -> assertEquals(8, s.getLong()));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test of size method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testSize_Shape_Operand() {\n+        System.out.println(\"size\");\n+        try (Graph g = new Graph();\n+                Session session = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps instance = ShapeOps.create(scope);\n+            Operand operand = Constant.arrayOf(scope, new float[] {1, 2, 3, 4, 5, 6, 7, 8} );\n+            Operand actual = Reshape.create(scope, operand, Constant.vectorOf(scope, new long[] { 4,2,1} ));\n+            Shape<TInt32> tfshape = Shape.create(scope, actual);\n+            \n+            Operand<TInt32> size = instance.size(tfshape, Constant.scalarOf(scope, 0));\n+            try (Tensor<TInt32> result = session.runner().fetch(size.asOutput()).run().get(0).expect(TInt32.DTYPE)) {\n+                result.data().scalars().forEach(s -> assertEquals(4, s.getInt()));\n+            }\n+            \n+            size = instance.size(tfshape, Constant.scalarOf(scope, 1));\n+            try (Tensor<TInt32> result = session.runner().fetch(size.asOutput()).run().get(0).expect(TInt32.DTYPE)) {\n+                result.data().scalars().forEach(s -> assertEquals(2, s.getInt()));\n+            }\n+            \n+            size = instance.size(tfshape, Constant.scalarOf(scope, 2));\n+            try (Tensor<TInt32> result = session.runner().fetch(size.asOutput()).run().get(0).expect(TInt32.DTYPE)) {\n+                result.data().scalars().forEach(s -> assertEquals(1, s.getInt()));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test of size method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testSize_Operand_Operand() {\n+        System.out.println(\"size\");\n+         try (Graph g = new Graph();\n+                Session session = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps instance = ShapeOps.create(scope);\n+            Operand operand = Constant.arrayOf(scope, new float[] {1, 2, 3, 4, 5, 6, 7, 8} );\n+            Operand actual = Reshape.create(scope, operand, Constant.vectorOf(scope, new long[] { 4,2,1} ));\n+            \n+            Operand<TInt32> size = instance.size(actual, Constant.scalarOf(scope, 0));\n+            try (Tensor<TInt32> result = session.runner().fetch(size.asOutput()).run().get(0).expect(TInt32.DTYPE)) {\n+                result.data().scalars().forEach(s -> assertEquals(4, s.getInt()));\n+            }\n+            \n+            size = instance.size(actual, Constant.scalarOf(scope, 1));\n+            try (Tensor<TInt32> result = session.runner().fetch(size.asOutput()).run().get(0).expect(TInt32.DTYPE)) {\n+                result.data().scalars().forEach(s -> assertEquals(2, s.getInt()));\n+            }\n+            \n+            size = instance.size(actual, Constant.scalarOf(scope, 2));\n+            try (Tensor<TInt32> result = session.runner().fetch(size.asOutput()).run().get(0).expect(TInt32.DTYPE)) {\n+                result.data().scalars().forEach(s -> assertEquals(1, s.getInt()));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test of numDimensions method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testNumDimensions() {\n+        System.out.println(\"numDimensions\");\n+        try (Graph g = new Graph();\n+                Session session = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps instance = ShapeOps.create(scope);\n+            Operand operand = Constant.arrayOf(scope, new float[] {1, 2, 3, 4, 5, 6, 7, 8} );\n+            Operand actual = Reshape.create(scope, operand, Constant.vectorOf(scope, new long[] { 4,2,1} ));\n+            Shape<TInt32> tfshape = Shape.create(scope, actual);\n+            \n+            Operand<TInt32> nDims = instance.numDimensions(tfshape);\n+            try (Tensor<TInt32> result = session.runner().fetch(nDims.asOutput()).run().get(0).expect(TInt32.DTYPE)) {\n+                result.data().scalars().forEach(s -> assertEquals(3, s.getInt()));\n+            }\n+            \n+        }\n+    }\n+\n+    /**\n+     * Test of reduceDims method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testReduceDims_Operand_Operand() {\n+        System.out.println(\"reduceDims\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9da3b9e9d52d917d4b30381a3bed0afba1b99014"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzNTM5MA==", "bodyText": "My mistake, It was intended to be the same as testReduceDims_Shape_Operand, but based on passing the operand rather than the shape directly. It may be a redundant, unless you think we need to test it both ways.", "url": "https://github.com/tensorflow/java/pull/71#discussion_r440435390", "createdAt": "2020-06-15T20:43:17Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/op/core/ShapeOpsTest.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * To change this license header, choose License Headers in Project Properties.\n+ * To change this template file, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package org.tensorflow.keras.utils;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/***\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+****/\n+\n+\n+import org.tensorflow.Graph;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Session;\n+import org.tensorflow.Tensor;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.op.core.Constant;\n+import org.tensorflow.op.core.Reshape;\n+import org.tensorflow.op.core.Shape;\n+import org.tensorflow.types.TFloat32;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+\n+/**\n+ *\n+ * @author jbclarke\n+ */\n+@RunWith(JUnit4.class)\n+public class ShapeOpsTest {\n+    \n+    public ShapeOpsTest() {\n+    }\n+    \n+\n+    /**\n+     * Test of create method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testCreate_Scope() {\n+        try (Graph g = new Graph();\n+                Session sess = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps stf = ShapeOps.create(scope);\n+            assertEquals(scope, stf.scope());\n+            assertEquals(TInt32.DTYPE, stf.datatype());\n+        }\n+    }\n+\n+    /**\n+     * Test of create method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testCreate_Scope_DataType() {\n+        System.out.println(\"create DataType\");\n+        try (Graph g = new Graph();\n+                Session sess = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps stf = ShapeOps.create(scope, TInt64.DTYPE);\n+            assertEquals(scope, stf.scope());\n+            assertEquals(TInt64.DTYPE, stf.datatype());\n+        }\n+    }\n+\n+    /**\n+     * Test of flatten method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testFlatten_Operand() {\n+        System.out.println(\"flatten operand\");\n+        try (Graph g = new Graph();\n+                Session session = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps instance = ShapeOps.create(scope, TInt64.DTYPE);\n+            Operand<TFloat32> operand = Constant.arrayOf(scope, new float[]{1, 2, 3, 4, 5, 6, 7, 8});\n+            Shape<TInt64> expResult = Shape.create(scope, operand, TInt64.DTYPE);\n+            Operand<TFloat32> reshaped = Reshape.create(scope, operand, Constant.vectorOf(scope, new long[]{4, 2, 1}));\n+            Operand actual = instance.flatten(reshaped);\n+            Shape<TInt64> tfshape = Shape.create(scope, actual, TInt64.DTYPE);\n+\n+            AtomicInteger index = new AtomicInteger();\n+            try (Tensor<TInt64> result1 = session.runner().fetch(tfshape.asOutput()).run().get(0).expect(TInt64.DTYPE);\n+                    Tensor<TInt64> result2 = session.runner().fetch(expResult.asOutput()).run().get(0).expect(TInt64.DTYPE)) {\n+                result1.data().scalars().forEach(s -> assertEquals(\n+                        result2.data().getLong(index.getAndIncrement()), s.getLong()));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test of flatten method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testFlatten_Shape() {\n+        System.out.println(\"flatten shape\");\n+        try (Graph g = new Graph();\n+                Session session = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps instance = ShapeOps.create(scope, TInt64.DTYPE);\n+            Operand operand = Constant.arrayOf(scope, new float[] {1, 2, 3, 4, 5, 6, 7, 8} );\n+            Shape<TInt64> expShape = Shape.create(scope, operand, TInt64.DTYPE);\n+            Operand actual = Reshape.create(scope, operand, Constant.vectorOf(scope, new long[] { 4,2,1} ));\n+            Shape<TInt64> tfshape = Shape.create(scope, actual, TInt64.DTYPE);\n+            Operand<TInt64> flattened = instance.flatten(tfshape);\n+            \n+            \n+            AtomicInteger index = new AtomicInteger();\n+            try (Tensor<TInt64> result1 = session.runner().fetch(flattened.asOutput()).run().get(0).expect(TInt64.DTYPE);\n+                    Tensor<TInt64> result2 = session.runner().fetch(expShape.asOutput()).run().get(0).expect(TInt64.DTYPE)) {\n+                result1.data().scalars().forEach(s -> assertEquals(\n+                        result2.data().getLong(index.getAndIncrement()), s.getLong()));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test of size method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testSize_Shape() {\n+        System.out.println(\"size\");\n+        try (Graph g = new Graph();\n+                Session session = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps instance = ShapeOps.create(scope, TInt64.DTYPE);\n+            Operand operand = Constant.arrayOf(scope, new float[] {1, 2, 3, 4, 5, 6, 7, 8} );\n+            Operand actual = Reshape.create(scope, operand, Constant.vectorOf(scope, new long[] { 4,2,1} ));\n+            Shape<TInt64> tfshape = Shape.create(scope, actual, TInt64.DTYPE);\n+            Operand<TInt64> size = instance.size(tfshape);\n+            \n+            \n+            AtomicInteger index = new AtomicInteger();\n+            try (Tensor<TInt64> result1 = session.runner().fetch(size.asOutput()).run().get(0).expect(TInt64.DTYPE)) {\n+                result1.data().scalars().forEach(s -> assertEquals(8, s.getLong()));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test of size method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testSize_Shape_Operand() {\n+        System.out.println(\"size\");\n+        try (Graph g = new Graph();\n+                Session session = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps instance = ShapeOps.create(scope);\n+            Operand operand = Constant.arrayOf(scope, new float[] {1, 2, 3, 4, 5, 6, 7, 8} );\n+            Operand actual = Reshape.create(scope, operand, Constant.vectorOf(scope, new long[] { 4,2,1} ));\n+            Shape<TInt32> tfshape = Shape.create(scope, actual);\n+            \n+            Operand<TInt32> size = instance.size(tfshape, Constant.scalarOf(scope, 0));\n+            try (Tensor<TInt32> result = session.runner().fetch(size.asOutput()).run().get(0).expect(TInt32.DTYPE)) {\n+                result.data().scalars().forEach(s -> assertEquals(4, s.getInt()));\n+            }\n+            \n+            size = instance.size(tfshape, Constant.scalarOf(scope, 1));\n+            try (Tensor<TInt32> result = session.runner().fetch(size.asOutput()).run().get(0).expect(TInt32.DTYPE)) {\n+                result.data().scalars().forEach(s -> assertEquals(2, s.getInt()));\n+            }\n+            \n+            size = instance.size(tfshape, Constant.scalarOf(scope, 2));\n+            try (Tensor<TInt32> result = session.runner().fetch(size.asOutput()).run().get(0).expect(TInt32.DTYPE)) {\n+                result.data().scalars().forEach(s -> assertEquals(1, s.getInt()));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test of size method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testSize_Operand_Operand() {\n+        System.out.println(\"size\");\n+         try (Graph g = new Graph();\n+                Session session = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps instance = ShapeOps.create(scope);\n+            Operand operand = Constant.arrayOf(scope, new float[] {1, 2, 3, 4, 5, 6, 7, 8} );\n+            Operand actual = Reshape.create(scope, operand, Constant.vectorOf(scope, new long[] { 4,2,1} ));\n+            \n+            Operand<TInt32> size = instance.size(actual, Constant.scalarOf(scope, 0));\n+            try (Tensor<TInt32> result = session.runner().fetch(size.asOutput()).run().get(0).expect(TInt32.DTYPE)) {\n+                result.data().scalars().forEach(s -> assertEquals(4, s.getInt()));\n+            }\n+            \n+            size = instance.size(actual, Constant.scalarOf(scope, 1));\n+            try (Tensor<TInt32> result = session.runner().fetch(size.asOutput()).run().get(0).expect(TInt32.DTYPE)) {\n+                result.data().scalars().forEach(s -> assertEquals(2, s.getInt()));\n+            }\n+            \n+            size = instance.size(actual, Constant.scalarOf(scope, 2));\n+            try (Tensor<TInt32> result = session.runner().fetch(size.asOutput()).run().get(0).expect(TInt32.DTYPE)) {\n+                result.data().scalars().forEach(s -> assertEquals(1, s.getInt()));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Test of numDimensions method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testNumDimensions() {\n+        System.out.println(\"numDimensions\");\n+        try (Graph g = new Graph();\n+                Session session = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps instance = ShapeOps.create(scope);\n+            Operand operand = Constant.arrayOf(scope, new float[] {1, 2, 3, 4, 5, 6, 7, 8} );\n+            Operand actual = Reshape.create(scope, operand, Constant.vectorOf(scope, new long[] { 4,2,1} ));\n+            Shape<TInt32> tfshape = Shape.create(scope, actual);\n+            \n+            Operand<TInt32> nDims = instance.numDimensions(tfshape);\n+            try (Tensor<TInt32> result = session.runner().fetch(nDims.asOutput()).run().get(0).expect(TInt32.DTYPE)) {\n+                result.data().scalars().forEach(s -> assertEquals(3, s.getInt()));\n+            }\n+            \n+        }\n+    }\n+\n+    /**\n+     * Test of reduceDims method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testReduceDims_Operand_Operand() {\n+        System.out.println(\"reduceDims\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzMjM3MQ=="}, "originalCommit": {"oid": "9da3b9e9d52d917d4b30381a3bed0afba1b99014"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Mzk5OTI4OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/op/core/ShapeOpsTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMDozODowOVrOGkB4sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMDo0MDo1N1rOGkB-GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzMjgxOQ==", "bodyText": "Given the number of tests that are in TF at the moment, having it print out the name of each one is a little much.", "url": "https://github.com/tensorflow/java/pull/71#discussion_r440432819", "createdAt": "2020-06-15T20:38:09Z", "author": {"login": "Craigacp"}, "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/op/core/ShapeOpsTest.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * To change this license header, choose License Headers in Project Properties.\n+ * To change this template file, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package org.tensorflow.keras.utils;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/***\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+****/\n+\n+\n+import org.tensorflow.Graph;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Session;\n+import org.tensorflow.Tensor;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.op.core.Constant;\n+import org.tensorflow.op.core.Reshape;\n+import org.tensorflow.op.core.Shape;\n+import org.tensorflow.types.TFloat32;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+\n+/**\n+ *\n+ * @author jbclarke\n+ */\n+@RunWith(JUnit4.class)\n+public class ShapeOpsTest {\n+    \n+    public ShapeOpsTest() {\n+    }\n+    \n+\n+    /**\n+     * Test of create method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testCreate_Scope() {\n+        try (Graph g = new Graph();\n+                Session sess = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps stf = ShapeOps.create(scope);\n+            assertEquals(scope, stf.scope());\n+            assertEquals(TInt32.DTYPE, stf.datatype());\n+        }\n+    }\n+\n+    /**\n+     * Test of create method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testCreate_Scope_DataType() {\n+        System.out.println(\"create DataType\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9da3b9e9d52d917d4b30381a3bed0afba1b99014"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzNDIwMQ==", "bodyText": "Ok I will remove the println's", "url": "https://github.com/tensorflow/java/pull/71#discussion_r440434201", "createdAt": "2020-06-15T20:40:57Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-core/tensorflow-core-api/src/test/java/org/tensorflow/op/core/ShapeOpsTest.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * To change this license header, choose License Headers in Project Properties.\n+ * To change this template file, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package org.tensorflow.keras.utils;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/***\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+****/\n+\n+\n+import org.tensorflow.Graph;\n+import org.tensorflow.Operand;\n+import org.tensorflow.Session;\n+import org.tensorflow.Tensor;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.op.core.Constant;\n+import org.tensorflow.op.core.Reshape;\n+import org.tensorflow.op.core.Shape;\n+import org.tensorflow.types.TFloat32;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.TInt64;\n+\n+/**\n+ *\n+ * @author jbclarke\n+ */\n+@RunWith(JUnit4.class)\n+public class ShapeOpsTest {\n+    \n+    public ShapeOpsTest() {\n+    }\n+    \n+\n+    /**\n+     * Test of create method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testCreate_Scope() {\n+        try (Graph g = new Graph();\n+                Session sess = new Session(g)) {\n+            Scope scope = new Scope(g);\n+            ShapeOps stf = ShapeOps.create(scope);\n+            assertEquals(scope, stf.scope());\n+            assertEquals(TInt32.DTYPE, stf.datatype());\n+        }\n+    }\n+\n+    /**\n+     * Test of create method, of class ShapeOps.\n+     */\n+    @Test\n+    public void testCreate_Scope_DataType() {\n+        System.out.println(\"create DataType\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzMjgxOQ=="}, "originalCommit": {"oid": "9da3b9e9d52d917d4b30381a3bed0afba1b99014"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzIwMzE2OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMToxNDoxNlrOGlcVCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMzo1Njo1N1rOGlwjqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxNDYzNQ==", "bodyText": "For consistency with other classes, please start the doc summary with a capital letter.", "url": "https://github.com/tensorflow/java/pull/71#discussion_r441914635", "createdAt": "2020-06-18T01:14:16Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * To change this license header, choose License Headers in Project Properties.\n+ * To change this template file, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package org.tensorflow.op.core;\n+\n+import java.util.Arrays;\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.op.annotation.Endpoint;\n+import org.tensorflow.op.annotation.Operator;\n+import org.tensorflow.op.core.Concat;\n+import org.tensorflow.op.core.ExpandDims;\n+import org.tensorflow.op.core.Reshape;\n+import org.tensorflow.op.core.Shape;\n+import org.tensorflow.op.core.Size;\n+import org.tensorflow.op.core.Slice;\n+import org.tensorflow.op.math.FloorMod;\n+import org.tensorflow.op.core.Constant;\n+import org.tensorflow.op.core.Gather;\n+import org.tensorflow.op.core.OnesLike;\n+import org.tensorflow.op.core.ReduceProd;\n+import org.tensorflow.op.core.Where;\n+import org.tensorflow.op.dtypes.Cast;\n+import org.tensorflow.op.math.NotEqual;\n+import org.tensorflow.op.math.Sub;\n+import org.tensorflow.types.TBool;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * An operator working with org.tensorflow.op.core.Shape tensors\n+ */\n+@Operator\n+public abstract class ShapeOps {\n+\n+    /**\n+     * flatten the shape to 1 dimension", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a734f53f85bbf0415cd105d580d730798c08d35b"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI0NjA1OQ==", "bodyText": "Ok", "url": "https://github.com/tensorflow/java/pull/71#discussion_r442246059", "createdAt": "2020-06-18T13:56:57Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * To change this license header, choose License Headers in Project Properties.\n+ * To change this template file, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package org.tensorflow.op.core;\n+\n+import java.util.Arrays;\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.op.annotation.Endpoint;\n+import org.tensorflow.op.annotation.Operator;\n+import org.tensorflow.op.core.Concat;\n+import org.tensorflow.op.core.ExpandDims;\n+import org.tensorflow.op.core.Reshape;\n+import org.tensorflow.op.core.Shape;\n+import org.tensorflow.op.core.Size;\n+import org.tensorflow.op.core.Slice;\n+import org.tensorflow.op.math.FloorMod;\n+import org.tensorflow.op.core.Constant;\n+import org.tensorflow.op.core.Gather;\n+import org.tensorflow.op.core.OnesLike;\n+import org.tensorflow.op.core.ReduceProd;\n+import org.tensorflow.op.core.Where;\n+import org.tensorflow.op.dtypes.Cast;\n+import org.tensorflow.op.math.NotEqual;\n+import org.tensorflow.op.math.Sub;\n+import org.tensorflow.types.TBool;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * An operator working with org.tensorflow.op.core.Shape tensors\n+ */\n+@Operator\n+public abstract class ShapeOps {\n+\n+    /**\n+     * flatten the shape to 1 dimension", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxNDYzNQ=="}, "originalCommit": {"oid": "a734f53f85bbf0415cd105d580d730798c08d35b"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzIxMDYxOnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMToxODo0NFrOGlcZdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMzo1NzowOFrOGlwkNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxNTc2Nw==", "bodyText": "Parentheses not required around the array instantiation", "url": "https://github.com/tensorflow/java/pull/71#discussion_r441915767", "createdAt": "2020-06-18T01:18:44Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * To change this license header, choose License Headers in Project Properties.\n+ * To change this template file, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package org.tensorflow.op.core;\n+\n+import java.util.Arrays;\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.op.annotation.Endpoint;\n+import org.tensorflow.op.annotation.Operator;\n+import org.tensorflow.op.core.Concat;\n+import org.tensorflow.op.core.ExpandDims;\n+import org.tensorflow.op.core.Reshape;\n+import org.tensorflow.op.core.Shape;\n+import org.tensorflow.op.core.Size;\n+import org.tensorflow.op.core.Slice;\n+import org.tensorflow.op.math.FloorMod;\n+import org.tensorflow.op.core.Constant;\n+import org.tensorflow.op.core.Gather;\n+import org.tensorflow.op.core.OnesLike;\n+import org.tensorflow.op.core.ReduceProd;\n+import org.tensorflow.op.core.Where;\n+import org.tensorflow.op.dtypes.Cast;\n+import org.tensorflow.op.math.NotEqual;\n+import org.tensorflow.op.math.Sub;\n+import org.tensorflow.types.TBool;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * An operator working with org.tensorflow.op.core.Shape tensors\n+ */\n+@Operator\n+public abstract class ShapeOps {\n+\n+    /**\n+     * flatten the shape to 1 dimension\n+     *\n+     * @param <T> the type of operand\n+     * @param scope current scope\n+     * @param operand the operand to flatten\n+     * @return the reshaped operand\n+     */\n+    @Endpoint(name = \"flatten\")\n+    public static <T extends TType> Operand<T> flatten(Scope scope, Operand<T> operand) {\n+        return flatten(scope, operand, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * flatten the shape to 1 dimension\n+     *\n+     * @param <T> the type of operand\n+     * @param <U> the shape datatype.\n+     * @param scope current scope\n+     * @param operand the operand to flatten\n+     * @param dType the shape datatype.\n+     * @return the reshaped operand\n+     */\n+    @Endpoint(name = \"flatten\")\n+    public static <T extends TType, U extends TNumber> Operand<T> flatten(Scope scope, Operand<T> operand, DataType<U> dType) {\n+        Operand<U> flatShape = flatten(scope, Shape.create(scope, operand, dType), dType);\n+        return Reshape.create(scope, operand, flatShape);\n+    }\n+\n+    /**\n+     * flatten the shape to 1 dimension\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return the flattened shape\n+     * @see reduceDims\n+     */\n+    @Endpoint(name = \"flatten\")\n+    public static Operand<TInt32> flatten(Scope scope, Shape<TInt32> shape) {\n+        return flatten(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * flatten the shape to 1 dimension\n+     *\n+     * @param <U> the shape datatype.\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @return the flattened shape\n+     * @see reduceDims\n+     */\n+    @Endpoint(name = \"flatten\")\n+    public static <U extends TNumber> Operand<U> flatten(Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return ExpandDims.create(scope,\n+                size(scope, shape, dType),\n+                Cast.create(scope, Constant.scalarOf(scope, -1), TInt32.DTYPE));\n+    }\n+\n+    /**\n+     * get the size represented by the TensorFlow shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return the size\n+     */\n+    @Endpoint(name = \"size\")\n+    public static Operand<TInt32> size(Scope scope, Shape<TInt32> shape) {\n+        return size(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * get the size represented by the TensorFlow shape\n+     *\n+     * @param <U> the shape datatype. the type of the shape\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @return the size\n+     */\n+    @Endpoint(name = \"size\")\n+    public static <U extends TNumber> Operand<U> size(Scope scope, Shape<U> shape, DataType<U> dType) {\n+        Slice<U> dims = Slice.create(scope, shape,\n+                Cast.create(scope, Constant.arrayOf(scope, (new int[]{0})), dType),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a734f53f85bbf0415cd105d580d730798c08d35b"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI0NjE5Nw==", "bodyText": "OK", "url": "https://github.com/tensorflow/java/pull/71#discussion_r442246197", "createdAt": "2020-06-18T13:57:08Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/*\n+ * To change this license header, choose License Headers in Project Properties.\n+ * To change this template file, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package org.tensorflow.op.core;\n+\n+import java.util.Arrays;\n+import org.tensorflow.DataType;\n+import org.tensorflow.Operand;\n+import org.tensorflow.op.Scope;\n+import org.tensorflow.op.annotation.Endpoint;\n+import org.tensorflow.op.annotation.Operator;\n+import org.tensorflow.op.core.Concat;\n+import org.tensorflow.op.core.ExpandDims;\n+import org.tensorflow.op.core.Reshape;\n+import org.tensorflow.op.core.Shape;\n+import org.tensorflow.op.core.Size;\n+import org.tensorflow.op.core.Slice;\n+import org.tensorflow.op.math.FloorMod;\n+import org.tensorflow.op.core.Constant;\n+import org.tensorflow.op.core.Gather;\n+import org.tensorflow.op.core.OnesLike;\n+import org.tensorflow.op.core.ReduceProd;\n+import org.tensorflow.op.core.Where;\n+import org.tensorflow.op.dtypes.Cast;\n+import org.tensorflow.op.math.NotEqual;\n+import org.tensorflow.op.math.Sub;\n+import org.tensorflow.types.TBool;\n+import org.tensorflow.types.TInt32;\n+import org.tensorflow.types.family.TNumber;\n+import org.tensorflow.types.family.TType;\n+\n+/**\n+ * An operator working with org.tensorflow.op.core.Shape tensors\n+ */\n+@Operator\n+public abstract class ShapeOps {\n+\n+    /**\n+     * flatten the shape to 1 dimension\n+     *\n+     * @param <T> the type of operand\n+     * @param scope current scope\n+     * @param operand the operand to flatten\n+     * @return the reshaped operand\n+     */\n+    @Endpoint(name = \"flatten\")\n+    public static <T extends TType> Operand<T> flatten(Scope scope, Operand<T> operand) {\n+        return flatten(scope, operand, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * flatten the shape to 1 dimension\n+     *\n+     * @param <T> the type of operand\n+     * @param <U> the shape datatype.\n+     * @param scope current scope\n+     * @param operand the operand to flatten\n+     * @param dType the shape datatype.\n+     * @return the reshaped operand\n+     */\n+    @Endpoint(name = \"flatten\")\n+    public static <T extends TType, U extends TNumber> Operand<T> flatten(Scope scope, Operand<T> operand, DataType<U> dType) {\n+        Operand<U> flatShape = flatten(scope, Shape.create(scope, operand, dType), dType);\n+        return Reshape.create(scope, operand, flatShape);\n+    }\n+\n+    /**\n+     * flatten the shape to 1 dimension\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return the flattened shape\n+     * @see reduceDims\n+     */\n+    @Endpoint(name = \"flatten\")\n+    public static Operand<TInt32> flatten(Scope scope, Shape<TInt32> shape) {\n+        return flatten(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * flatten the shape to 1 dimension\n+     *\n+     * @param <U> the shape datatype.\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @return the flattened shape\n+     * @see reduceDims\n+     */\n+    @Endpoint(name = \"flatten\")\n+    public static <U extends TNumber> Operand<U> flatten(Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return ExpandDims.create(scope,\n+                size(scope, shape, dType),\n+                Cast.create(scope, Constant.scalarOf(scope, -1), TInt32.DTYPE));\n+    }\n+\n+    /**\n+     * get the size represented by the TensorFlow shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return the size\n+     */\n+    @Endpoint(name = \"size\")\n+    public static Operand<TInt32> size(Scope scope, Shape<TInt32> shape) {\n+        return size(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * get the size represented by the TensorFlow shape\n+     *\n+     * @param <U> the shape datatype. the type of the shape\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @return the size\n+     */\n+    @Endpoint(name = \"size\")\n+    public static <U extends TNumber> Operand<U> size(Scope scope, Shape<U> shape, DataType<U> dType) {\n+        Slice<U> dims = Slice.create(scope, shape,\n+                Cast.create(scope, Constant.arrayOf(scope, (new int[]{0})), dType),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxNTc2Nw=="}, "originalCommit": {"oid": "a734f53f85bbf0415cd105d580d730798c08d35b"}, "originalPosition": 123}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1611, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}