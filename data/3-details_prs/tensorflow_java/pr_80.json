{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMDE2MjM1", "number": 80, "title": "Added methods head, take, tail, takeLast, prepend and append \u2026", "bodyText": "to mirror org.tensorflow.tools.Shape", "createdAt": "2020-06-30T13:07:45Z", "url": "https://github.com/tensorflow/java/pull/80", "merged": true, "mergeCommit": {"oid": "c065b70c05acefe703fee21a156561e76e54c66d"}, "closed": true, "closedAt": "2020-07-04T15:47:52Z", "author": {"login": "JimClarke5"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwVUOugH2gAyNDQyMDE2MjM1OjE4NWVmMTRmN2JjYzg3MTM4NTU3OThmOWNiNjY0NTgxNzI1YjJiMTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcxqCdMAFqTQ0MjYxNjgwMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16", "author": {"user": {"login": "JimClarke5", "name": "Jim Clarke"}}, "url": "https://github.com/tensorflow/java/commit/185ef14f7bcc8713855798f9cb664581725b2b16", "committedDate": "2020-06-30T13:04:33Z", "message": "Added methods head, take, tail, takeLast, prepend and append to mirror org.tensorflow.tools.Shape"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxOTQ0NjY0", "url": "https://github.com/tensorflow/java/pull/80#pullrequestreview-441944664", "createdAt": "2020-07-02T18:50:57Z", "commit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo1MDo1N1rOGsZgLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo1NTozNFrOGsZoHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwODM2Nw==", "bodyText": "Idem, should the Operand here be Shape instead?", "url": "https://github.com/tensorflow/java/pull/80#discussion_r449208367", "createdAt": "2020-07-02T18:50:57Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -337,4 +336,252 @@\n \n         return gather;\n     }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static Operand<TInt32> head(Scope scope, Shape<TInt32> shape) {\n+        return head(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static <U extends TNumber> Operand<U> head(Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return take(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static Operand<TInt32> take(Scope scope,  Shape<TInt32> shape, Operand<TInt32> n) {\n+        return take(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static <U extends TNumber> Operand<U> take(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+        Operand<U> dims = Slice.create(scope, shape,\n+                Cast.create(scope, Constant.arrayOf(scope, new int[]{0}), dType),\n+                ExpandDims.create(scope, n, Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static Operand<TInt32> tail(Scope scope, Shape<TInt32> shape) {\n+        return tail(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static <U extends TNumber> Operand<U> tail(\n+            Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return takeLast(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<TInt32> takeLast(\n+            Scope scope, Shape<TInt32> shape, Operand<TInt32> n) {\n+        return takeLast(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<U> takeLast(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+\n+        Size<U> rank = Size.create(scope, shape, dType);\n+        Sub<U> start = Sub.create(scope, rank, n);\n+        Operand<U> dims = Slice.create(scope, shape,\n+                ExpandDims.create(scope, start, Constant.scalarOf(scope, -1)),\n+                ExpandDims.create(scope,\n+                        Cast.create(scope, Constant.scalarOf(scope, -1), dType),\n+                        Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by the Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt32> prepend(\n+            Scope scope, Shape<TInt32> shape, int firstDimension) {\n+        Operand<TInt32> dim = Constant.arrayOf(scope, new int[]{firstDimension});\n+        Concat<TInt32> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by this Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt64> prepend(\n+            Scope scope, Shape<TInt64> shape, long firstDimension) {\n+        Operand<TInt64> dim = Constant.arrayOf(scope, new long[]{firstDimension});\n+        Concat<TInt64> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Returns a new Shape, with another Shape's dimensions prepended.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param otherShape     the other shape to prepend\n+     * @return a new shape with another Shape's dimensions prepended.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static <T extends TNumber> Operand<T> prepend(\n+            Scope scope, Operand<T> shape, Operand<T> otherShape) {\n+\n+        Concat<T> result = Concat.create(scope,  Arrays.asList(otherShape, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Returns a new Shape, with the last dimension(s) added.\n+     *\n+     * @param scope         current scope\n+     * @param shape         the TensorFlow shape\n+     * @param lastDimension the dimension(s) to append\n+     * @return a new shape with the shape, followed with the given dimension(s).\n+     */\n+    @Endpoint(name = \"append\")\n+    public static Operand<TInt32> append(Scope scope, Shape<TInt32> shape, int lastDimension) {\n+        Operand<TInt32> dim = Constant.arrayOf(scope, new int[]{lastDimension});\n+        Concat<TInt32> result = Concat.create(scope,  Arrays.asList(shape, dim),\n+                Constant.scalarOf(scope, 0));\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with the last dimension(s) added.\n+     *\n+     * @param scope         current scope\n+     * @param shape         the TensorFlow shape\n+     * @param lastDimension the dimension(s) to append\n+     * @return a new shape with the shape, followed with the given dimension(s).\n+     */\n+    @Endpoint(name = \"append\")\n+    public static  Operand<TInt64> append(Scope scope, Shape<TInt64> shape, long lastDimension) {\n+\n+        Operand<TInt64> dim =  Constant.arrayOf(scope, new long[]{lastDimension});\n+        Concat<TInt64> result = Concat.create(scope,  Arrays.asList(shape, dim),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with another Shape's dimensions prepended.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param otherShape     the other shape to prepend\n+     * @return a new shape with another Shape's dimensions prepended.\n+     */\n+    @Endpoint(name = \"append\")\n+    public static <T extends TNumber> Operand<T> append(\n+            Scope scope, Operand<T> shape, Operand<T> otherShape) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "originalPosition": 532}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwOTI3Mw==", "bodyText": "should the Operand here be Shape instead? I think we need to use strong typing here otherwise a user might easily think that tf.append can be used for any kind of tensors.", "url": "https://github.com/tensorflow/java/pull/80#discussion_r449209273", "createdAt": "2020-07-02T18:52:57Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -337,4 +336,252 @@\n \n         return gather;\n     }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static Operand<TInt32> head(Scope scope, Shape<TInt32> shape) {\n+        return head(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static <U extends TNumber> Operand<U> head(Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return take(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static Operand<TInt32> take(Scope scope,  Shape<TInt32> shape, Operand<TInt32> n) {\n+        return take(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static <U extends TNumber> Operand<U> take(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+        Operand<U> dims = Slice.create(scope, shape,\n+                Cast.create(scope, Constant.arrayOf(scope, new int[]{0}), dType),\n+                ExpandDims.create(scope, n, Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static Operand<TInt32> tail(Scope scope, Shape<TInt32> shape) {\n+        return tail(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static <U extends TNumber> Operand<U> tail(\n+            Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return takeLast(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<TInt32> takeLast(\n+            Scope scope, Shape<TInt32> shape, Operand<TInt32> n) {\n+        return takeLast(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<U> takeLast(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+\n+        Size<U> rank = Size.create(scope, shape, dType);\n+        Sub<U> start = Sub.create(scope, rank, n);\n+        Operand<U> dims = Slice.create(scope, shape,\n+                ExpandDims.create(scope, start, Constant.scalarOf(scope, -1)),\n+                ExpandDims.create(scope,\n+                        Cast.create(scope, Constant.scalarOf(scope, -1), dType),\n+                        Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by the Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt32> prepend(\n+            Scope scope, Shape<TInt32> shape, int firstDimension) {\n+        Operand<TInt32> dim = Constant.arrayOf(scope, new int[]{firstDimension});\n+        Concat<TInt32> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by this Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt64> prepend(\n+            Scope scope, Shape<TInt64> shape, long firstDimension) {\n+        Operand<TInt64> dim = Constant.arrayOf(scope, new long[]{firstDimension});\n+        Concat<TInt64> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Returns a new Shape, with another Shape's dimensions prepended.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param otherShape     the other shape to prepend\n+     * @return a new shape with another Shape's dimensions prepended.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static <T extends TNumber> Operand<T> prepend(\n+            Scope scope, Operand<T> shape, Operand<T> otherShape) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "originalPosition": 478}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIxMDM5OA==", "bodyText": "Just double-checking with you @JimClarke5 that you are using Google Java Formatter in your IDE, as there are a lot of reformatting changes in the PR (quickly like that, it looks like the previous version of the code was closer to what we find in the other source files).", "url": "https://github.com/tensorflow/java/pull/80#discussion_r449210398", "createdAt": "2020-07-02T18:55:34Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -49,28 +42,30 @@\n     /**\n      * Flatten the operand to 1 dimension\n      *\n-     * @param <T> the type of operand\n-     * @param scope current scope\n+     * @param <T>     the type of operand\n+     * @param scope   current scope\n      * @param operand the operand to flatten\n      * @return the reshaped operand\n      */\n     @Endpoint(name = \"flatten\")\n-    public static <T extends TType> Operand<T> flatten(Scope scope, Operand<T> operand) {\n+    public static <T extends TType> Operand<T> flatten(\n+            Scope scope, Operand<T> operand) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc70ca0d01960582daac27fbe22487b7b226b3a4", "author": {"user": {"login": "JimClarke5", "name": "Jim Clarke"}}, "url": "https://github.com/tensorflow/java/commit/fc70ca0d01960582daac27fbe22487b7b226b3a4", "committedDate": "2020-07-03T23:46:35Z", "message": "Reformated with google-java-format"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19e5916d3d415cfaace742a801584a9bb8999023", "author": {"user": {"login": "JimClarke5", "name": "Jim Clarke"}}, "url": "https://github.com/tensorflow/java/commit/19e5916d3d415cfaace742a801584a9bb8999023", "committedDate": "2020-07-04T00:07:37Z", "message": "changed @Operator to indicate that group \"shape\"\nReformatted with google-java-format,\nchanged JavaDoc to indicate that 1d Operands represent dimensions of a shape rather are Shapes.\nIn the prepend/append(Scope, Operand, Operand) methods, changed second operand name to shapeToAppend rather than otherShape for clarity.\nAdded examples to JavaDoc for class.\n\nCleaned up code based on inteliJ Code analysis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ef7726d04add96273babdde2fa28c0ea5469980", "author": {"user": {"login": "JimClarke5", "name": "Jim Clarke"}}, "url": "https://github.com/tensorflow/java/commit/9ef7726d04add96273babdde2fa28c0ea5469980", "committedDate": "2020-07-04T00:07:53Z", "message": "changed @Operator to indicate that group \"shape\"\nReformatted with google-java-format,\nchanged JavaDoc to indicate that 1d Operands represent dimensions of a shape rather are Shapes.\nIn the prepend/append(Scope, Operand, Operand) methods, changed second operand name to shapeToAppend rather than otherShape for clarity.\nAdded examples to JavaDoc for class.\n\nCleaned up code based on inteliJ Code analysis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "661ea96685b4e7607abc79012c6e9a4762036e42", "author": {"user": {"login": "JimClarke5", "name": "Jim Clarke"}}, "url": "https://github.com/tensorflow/java/commit/661ea96685b4e7607abc79012c6e9a4762036e42", "committedDate": "2020-07-04T00:19:27Z", "message": "Fix typo that caused UnitTest failure."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fc7790243322221ade0a8fb195c89d1118e761b", "author": {"user": {"login": "JimClarke5", "name": "Jim Clarke"}}, "url": "https://github.com/tensorflow/java/commit/1fc7790243322221ade0a8fb195c89d1118e761b", "committedDate": "2020-07-04T00:36:13Z", "message": "Delete ShapeOps.java\n\nGenerated file should not have been pushed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5e2fde851a60c1285b5947bf1f2a95efa5b22cf", "author": {"user": {"login": "JimClarke5", "name": "Jim Clarke"}}, "url": "https://github.com/tensorflow/java/commit/c5e2fde851a60c1285b5947bf1f2a95efa5b22cf", "committedDate": "2020-07-04T12:32:45Z", "message": "renamed ShapeOps to Shapes and ShapeOpsTest to ShapesTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efc752c24170c2120a7aab780689a7bdf0cf2d32", "author": {"user": {"login": "JimClarke5", "name": "Jim Clarke"}}, "url": "https://github.com/tensorflow/java/commit/efc752c24170c2120a7aab780689a7bdf0cf2d32", "committedDate": "2020-07-04T12:33:54Z", "message": "recoverd gen Ops.java and ShapeOps.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce89a4bc80dde6354a42105891d8a95c6fc6c5e4", "author": {"user": {"login": "JimClarke5", "name": "Jim Clarke"}}, "url": "https://github.com/tensorflow/java/commit/ce89a4bc80dde6354a42105891d8a95c6fc6c5e4", "committedDate": "2020-07-04T12:43:32Z", "message": "Merge remote-tracking branch 'origin/master'\n\n# Conflicts:\n#\ttensorflow-core/tensorflow-core-api/src/gen/annotations/org/tensorflow/op/ShapeOps.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNjE2ODAw", "url": "https://github.com/tensorflow/java/pull/80#pullrequestreview-442616800", "createdAt": "2020-07-04T15:47:04Z", "commit": {"oid": "ce89a4bc80dde6354a42105891d8a95c6fc6c5e4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3447, "cost": 1, "resetAt": "2021-11-02T12:20:56Z"}}}