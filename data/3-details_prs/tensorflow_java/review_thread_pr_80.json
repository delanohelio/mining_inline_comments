{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyMDE2MjM1", "number": 80, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo1MDo1N1rOELBLGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo1NTozNFrOELBQAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTg5MDE5OnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo1MDo1N1rOGsZgLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QyMDowNDowN1rOGs3KPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwODM2Nw==", "bodyText": "Idem, should the Operand here be Shape instead?", "url": "https://github.com/tensorflow/java/pull/80#discussion_r449208367", "createdAt": "2020-07-02T18:50:57Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -337,4 +336,252 @@\n \n         return gather;\n     }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static Operand<TInt32> head(Scope scope, Shape<TInt32> shape) {\n+        return head(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static <U extends TNumber> Operand<U> head(Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return take(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static Operand<TInt32> take(Scope scope,  Shape<TInt32> shape, Operand<TInt32> n) {\n+        return take(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static <U extends TNumber> Operand<U> take(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+        Operand<U> dims = Slice.create(scope, shape,\n+                Cast.create(scope, Constant.arrayOf(scope, new int[]{0}), dType),\n+                ExpandDims.create(scope, n, Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static Operand<TInt32> tail(Scope scope, Shape<TInt32> shape) {\n+        return tail(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static <U extends TNumber> Operand<U> tail(\n+            Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return takeLast(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<TInt32> takeLast(\n+            Scope scope, Shape<TInt32> shape, Operand<TInt32> n) {\n+        return takeLast(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<U> takeLast(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+\n+        Size<U> rank = Size.create(scope, shape, dType);\n+        Sub<U> start = Sub.create(scope, rank, n);\n+        Operand<U> dims = Slice.create(scope, shape,\n+                ExpandDims.create(scope, start, Constant.scalarOf(scope, -1)),\n+                ExpandDims.create(scope,\n+                        Cast.create(scope, Constant.scalarOf(scope, -1), dType),\n+                        Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by the Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt32> prepend(\n+            Scope scope, Shape<TInt32> shape, int firstDimension) {\n+        Operand<TInt32> dim = Constant.arrayOf(scope, new int[]{firstDimension});\n+        Concat<TInt32> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by this Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt64> prepend(\n+            Scope scope, Shape<TInt64> shape, long firstDimension) {\n+        Operand<TInt64> dim = Constant.arrayOf(scope, new long[]{firstDimension});\n+        Concat<TInt64> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Returns a new Shape, with another Shape's dimensions prepended.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param otherShape     the other shape to prepend\n+     * @return a new shape with another Shape's dimensions prepended.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static <T extends TNumber> Operand<T> prepend(\n+            Scope scope, Operand<T> shape, Operand<T> otherShape) {\n+\n+        Concat<T> result = Concat.create(scope,  Arrays.asList(otherShape, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Returns a new Shape, with the last dimension(s) added.\n+     *\n+     * @param scope         current scope\n+     * @param shape         the TensorFlow shape\n+     * @param lastDimension the dimension(s) to append\n+     * @return a new shape with the shape, followed with the given dimension(s).\n+     */\n+    @Endpoint(name = \"append\")\n+    public static Operand<TInt32> append(Scope scope, Shape<TInt32> shape, int lastDimension) {\n+        Operand<TInt32> dim = Constant.arrayOf(scope, new int[]{lastDimension});\n+        Concat<TInt32> result = Concat.create(scope,  Arrays.asList(shape, dim),\n+                Constant.scalarOf(scope, 0));\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with the last dimension(s) added.\n+     *\n+     * @param scope         current scope\n+     * @param shape         the TensorFlow shape\n+     * @param lastDimension the dimension(s) to append\n+     * @return a new shape with the shape, followed with the given dimension(s).\n+     */\n+    @Endpoint(name = \"append\")\n+    public static  Operand<TInt64> append(Scope scope, Shape<TInt64> shape, long lastDimension) {\n+\n+        Operand<TInt64> dim =  Constant.arrayOf(scope, new long[]{lastDimension});\n+        Concat<TInt64> result = Concat.create(scope,  Arrays.asList(shape, dim),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with another Shape's dimensions prepended.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param otherShape     the other shape to prepend\n+     * @return a new shape with another Shape's dimensions prepended.\n+     */\n+    @Endpoint(name = \"append\")\n+    public static <T extends TNumber> Operand<T> append(\n+            Scope scope, Operand<T> shape, Operand<T> otherShape) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "originalPosition": 532}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2Mjg1NQ==", "bodyText": "I assume you are referring to org.tensorflow.op.core.Shape.\nThese new operations manipulate \"dynamic shapes\" as detailed in the python code, as opposed to \"static shapes\" represented by org.tensorflow.tools.Shape. The primary use of this change is in creating and manipulating shapes within the TF operations, outside of Java code. Dynamic shape manipulations usually results because the static Shape has unknown dimensions or the shape needs to be manipulated within the graph to be compatible with another Graph Operation.\norg.tensorflow.op.core.Shape is a specific kind of operand that contains dimensions,\nbut any Operand that translates into a set of numbers (dimensions) works.\nFor example, tf.constant(new int[] { 1,2,3}), tf.slice(....), tf.concat(), tf.stack(), tf.shape(operand) or tf.constant(org.tensorflow.tools.Shape) all work equally. Also, the output of these all work with tf.reshape(),\ndefined as reshape(Operand tensor, Operand shape).\nAs far as I can tell, there is no way to create a org.tensorflow.op.core.Shape object from Operands containing dimensions. tf.shape() only takes the shape associated with the Operand, itself. Perhaps we need an operand that creates a org.tensorflow.op.core.Shape object from dimensions, but using an Operand of dimensions seems to suffice, at least at the level that I need to use these functions.\nThis PR creates three signatures for append, all for manipulating the dimensions of a \"shape\".\nOperand append(Operand shape, Operand otherShape)\nOperand append(Shape shape, long lastDimension)\nOperand append(Shape shape, int lastDimension)\nThe Shape versions of these methods require a Shape object but they are really a convenience in passing\nthe lastDimension as a Java int/long. Calling append(shapeObj, tf.constant(new int/long[]i) )\nproduces the same result, but is not as straight forward.", "url": "https://github.com/tensorflow/java/pull/80#discussion_r449262855", "createdAt": "2020-07-02T20:58:44Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -337,4 +336,252 @@\n \n         return gather;\n     }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static Operand<TInt32> head(Scope scope, Shape<TInt32> shape) {\n+        return head(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static <U extends TNumber> Operand<U> head(Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return take(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static Operand<TInt32> take(Scope scope,  Shape<TInt32> shape, Operand<TInt32> n) {\n+        return take(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static <U extends TNumber> Operand<U> take(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+        Operand<U> dims = Slice.create(scope, shape,\n+                Cast.create(scope, Constant.arrayOf(scope, new int[]{0}), dType),\n+                ExpandDims.create(scope, n, Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static Operand<TInt32> tail(Scope scope, Shape<TInt32> shape) {\n+        return tail(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static <U extends TNumber> Operand<U> tail(\n+            Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return takeLast(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<TInt32> takeLast(\n+            Scope scope, Shape<TInt32> shape, Operand<TInt32> n) {\n+        return takeLast(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<U> takeLast(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+\n+        Size<U> rank = Size.create(scope, shape, dType);\n+        Sub<U> start = Sub.create(scope, rank, n);\n+        Operand<U> dims = Slice.create(scope, shape,\n+                ExpandDims.create(scope, start, Constant.scalarOf(scope, -1)),\n+                ExpandDims.create(scope,\n+                        Cast.create(scope, Constant.scalarOf(scope, -1), dType),\n+                        Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by the Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt32> prepend(\n+            Scope scope, Shape<TInt32> shape, int firstDimension) {\n+        Operand<TInt32> dim = Constant.arrayOf(scope, new int[]{firstDimension});\n+        Concat<TInt32> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by this Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt64> prepend(\n+            Scope scope, Shape<TInt64> shape, long firstDimension) {\n+        Operand<TInt64> dim = Constant.arrayOf(scope, new long[]{firstDimension});\n+        Concat<TInt64> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Returns a new Shape, with another Shape's dimensions prepended.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param otherShape     the other shape to prepend\n+     * @return a new shape with another Shape's dimensions prepended.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static <T extends TNumber> Operand<T> prepend(\n+            Scope scope, Operand<T> shape, Operand<T> otherShape) {\n+\n+        Concat<T> result = Concat.create(scope,  Arrays.asList(otherShape, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Returns a new Shape, with the last dimension(s) added.\n+     *\n+     * @param scope         current scope\n+     * @param shape         the TensorFlow shape\n+     * @param lastDimension the dimension(s) to append\n+     * @return a new shape with the shape, followed with the given dimension(s).\n+     */\n+    @Endpoint(name = \"append\")\n+    public static Operand<TInt32> append(Scope scope, Shape<TInt32> shape, int lastDimension) {\n+        Operand<TInt32> dim = Constant.arrayOf(scope, new int[]{lastDimension});\n+        Concat<TInt32> result = Concat.create(scope,  Arrays.asList(shape, dim),\n+                Constant.scalarOf(scope, 0));\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with the last dimension(s) added.\n+     *\n+     * @param scope         current scope\n+     * @param shape         the TensorFlow shape\n+     * @param lastDimension the dimension(s) to append\n+     * @return a new shape with the shape, followed with the given dimension(s).\n+     */\n+    @Endpoint(name = \"append\")\n+    public static  Operand<TInt64> append(Scope scope, Shape<TInt64> shape, long lastDimension) {\n+\n+        Operand<TInt64> dim =  Constant.arrayOf(scope, new long[]{lastDimension});\n+        Concat<TInt64> result = Concat.create(scope,  Arrays.asList(shape, dim),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with another Shape's dimensions prepended.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param otherShape     the other shape to prepend\n+     * @return a new shape with another Shape's dimensions prepended.\n+     */\n+    @Endpoint(name = \"append\")\n+    public static <T extends TNumber> Operand<T> append(\n+            Scope scope, Operand<T> shape, Operand<T> otherShape) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwODM2Nw=="}, "originalCommit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "originalPosition": 532}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY5NDI3MQ==", "bodyText": "closing this thread as it is identical to the one above", "url": "https://github.com/tensorflow/java/pull/80#discussion_r449694271", "createdAt": "2020-07-03T20:04:07Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -337,4 +336,252 @@\n \n         return gather;\n     }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static Operand<TInt32> head(Scope scope, Shape<TInt32> shape) {\n+        return head(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static <U extends TNumber> Operand<U> head(Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return take(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static Operand<TInt32> take(Scope scope,  Shape<TInt32> shape, Operand<TInt32> n) {\n+        return take(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static <U extends TNumber> Operand<U> take(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+        Operand<U> dims = Slice.create(scope, shape,\n+                Cast.create(scope, Constant.arrayOf(scope, new int[]{0}), dType),\n+                ExpandDims.create(scope, n, Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static Operand<TInt32> tail(Scope scope, Shape<TInt32> shape) {\n+        return tail(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static <U extends TNumber> Operand<U> tail(\n+            Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return takeLast(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<TInt32> takeLast(\n+            Scope scope, Shape<TInt32> shape, Operand<TInt32> n) {\n+        return takeLast(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<U> takeLast(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+\n+        Size<U> rank = Size.create(scope, shape, dType);\n+        Sub<U> start = Sub.create(scope, rank, n);\n+        Operand<U> dims = Slice.create(scope, shape,\n+                ExpandDims.create(scope, start, Constant.scalarOf(scope, -1)),\n+                ExpandDims.create(scope,\n+                        Cast.create(scope, Constant.scalarOf(scope, -1), dType),\n+                        Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by the Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt32> prepend(\n+            Scope scope, Shape<TInt32> shape, int firstDimension) {\n+        Operand<TInt32> dim = Constant.arrayOf(scope, new int[]{firstDimension});\n+        Concat<TInt32> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by this Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt64> prepend(\n+            Scope scope, Shape<TInt64> shape, long firstDimension) {\n+        Operand<TInt64> dim = Constant.arrayOf(scope, new long[]{firstDimension});\n+        Concat<TInt64> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Returns a new Shape, with another Shape's dimensions prepended.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param otherShape     the other shape to prepend\n+     * @return a new shape with another Shape's dimensions prepended.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static <T extends TNumber> Operand<T> prepend(\n+            Scope scope, Operand<T> shape, Operand<T> otherShape) {\n+\n+        Concat<T> result = Concat.create(scope,  Arrays.asList(otherShape, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Returns a new Shape, with the last dimension(s) added.\n+     *\n+     * @param scope         current scope\n+     * @param shape         the TensorFlow shape\n+     * @param lastDimension the dimension(s) to append\n+     * @return a new shape with the shape, followed with the given dimension(s).\n+     */\n+    @Endpoint(name = \"append\")\n+    public static Operand<TInt32> append(Scope scope, Shape<TInt32> shape, int lastDimension) {\n+        Operand<TInt32> dim = Constant.arrayOf(scope, new int[]{lastDimension});\n+        Concat<TInt32> result = Concat.create(scope,  Arrays.asList(shape, dim),\n+                Constant.scalarOf(scope, 0));\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with the last dimension(s) added.\n+     *\n+     * @param scope         current scope\n+     * @param shape         the TensorFlow shape\n+     * @param lastDimension the dimension(s) to append\n+     * @return a new shape with the shape, followed with the given dimension(s).\n+     */\n+    @Endpoint(name = \"append\")\n+    public static  Operand<TInt64> append(Scope scope, Shape<TInt64> shape, long lastDimension) {\n+\n+        Operand<TInt64> dim =  Constant.arrayOf(scope, new long[]{lastDimension});\n+        Concat<TInt64> result = Concat.create(scope,  Arrays.asList(shape, dim),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with another Shape's dimensions prepended.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param otherShape     the other shape to prepend\n+     * @return a new shape with another Shape's dimensions prepended.\n+     */\n+    @Endpoint(name = \"append\")\n+    public static <T extends TNumber> Operand<T> append(\n+            Scope scope, Operand<T> shape, Operand<T> otherShape) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwODM2Nw=="}, "originalCommit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "originalPosition": 532}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTg5NTkwOnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo1Mjo1N1rOGsZjuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQxNTo0Njo1NVrOGs8mIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwOTI3Mw==", "bodyText": "should the Operand here be Shape instead? I think we need to use strong typing here otherwise a user might easily think that tf.append can be used for any kind of tensors.", "url": "https://github.com/tensorflow/java/pull/80#discussion_r449209273", "createdAt": "2020-07-02T18:52:57Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -337,4 +336,252 @@\n \n         return gather;\n     }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static Operand<TInt32> head(Scope scope, Shape<TInt32> shape) {\n+        return head(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static <U extends TNumber> Operand<U> head(Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return take(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static Operand<TInt32> take(Scope scope,  Shape<TInt32> shape, Operand<TInt32> n) {\n+        return take(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static <U extends TNumber> Operand<U> take(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+        Operand<U> dims = Slice.create(scope, shape,\n+                Cast.create(scope, Constant.arrayOf(scope, new int[]{0}), dType),\n+                ExpandDims.create(scope, n, Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static Operand<TInt32> tail(Scope scope, Shape<TInt32> shape) {\n+        return tail(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static <U extends TNumber> Operand<U> tail(\n+            Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return takeLast(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<TInt32> takeLast(\n+            Scope scope, Shape<TInt32> shape, Operand<TInt32> n) {\n+        return takeLast(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<U> takeLast(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+\n+        Size<U> rank = Size.create(scope, shape, dType);\n+        Sub<U> start = Sub.create(scope, rank, n);\n+        Operand<U> dims = Slice.create(scope, shape,\n+                ExpandDims.create(scope, start, Constant.scalarOf(scope, -1)),\n+                ExpandDims.create(scope,\n+                        Cast.create(scope, Constant.scalarOf(scope, -1), dType),\n+                        Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by the Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt32> prepend(\n+            Scope scope, Shape<TInt32> shape, int firstDimension) {\n+        Operand<TInt32> dim = Constant.arrayOf(scope, new int[]{firstDimension});\n+        Concat<TInt32> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by this Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt64> prepend(\n+            Scope scope, Shape<TInt64> shape, long firstDimension) {\n+        Operand<TInt64> dim = Constant.arrayOf(scope, new long[]{firstDimension});\n+        Concat<TInt64> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Returns a new Shape, with another Shape's dimensions prepended.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param otherShape     the other shape to prepend\n+     * @return a new shape with another Shape's dimensions prepended.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static <T extends TNumber> Operand<T> prepend(\n+            Scope scope, Operand<T> shape, Operand<T> otherShape) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "originalPosition": 478}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3NTk5Mg==", "bodyText": "I assume you are referring to org.tensorflow.op.core.Shape.\nThese new operations manipulate  \"dynamic shapes\" as detailed in the python code, as opposed to \"static shapes\" represented by org.tensorflow.tools.Shape. The primary use of this change is in creating and manipulating shapes within the TF operations, outside of Java code. Dynamic shape manipulations usually results because the static Shape has unknown dimensions or the shape needs to be manipulated within the graph to be compatible with another Graph Operation.\norg.tensorflow.op.core.Shape is a specific kind of operand that contains dimensions,\nbut any Operand that translates into a set of numbers (dimensions) works.\nFor example, tf.constant(new int[] { 1,2,3}), tf.slice(....), tf.concat(), tf.stack(), tf.shape(operand) or tf.constant(org.tensorflow.tools.Shape) all work equally. Also, the output of these all work with tf.reshape(),\ndefined as reshape(Operand<T> tensor, Operand<U> shape).\nAs far as I can tell, there is no way to create a org.tensorflow.op.core.Shape object from Operands containing dimensions. tf.shape() only takes the shape associated with  the Operand, itself. Perhaps we need an operand that creates a org.tensorflow.op.core.Shape object from dimensions,  but using an Operand of dimensions seems to suffice, at least at the level that I need to  use these functions.\nThis PR creates three signatures for append, all for manipulating the dimensions of a \"shape\".\n\nOperand append(Operand shape, Operand otherShape)\nOperand append(Shape shape,  long lastDimension)\nOperand append(Shape shape,  int lastDimension)\n\nThe Shape versions of these methods require a Shape object but they are really a convenience in passing\nthe lastDimension as a Java int/long. Calling append(shapeObj, tf.constant(new int/long[]i) )\nproduces the same result, but is not as straight forward.", "url": "https://github.com/tensorflow/java/pull/80#discussion_r449275992", "createdAt": "2020-07-02T21:33:35Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -337,4 +336,252 @@\n \n         return gather;\n     }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static Operand<TInt32> head(Scope scope, Shape<TInt32> shape) {\n+        return head(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static <U extends TNumber> Operand<U> head(Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return take(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static Operand<TInt32> take(Scope scope,  Shape<TInt32> shape, Operand<TInt32> n) {\n+        return take(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static <U extends TNumber> Operand<U> take(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+        Operand<U> dims = Slice.create(scope, shape,\n+                Cast.create(scope, Constant.arrayOf(scope, new int[]{0}), dType),\n+                ExpandDims.create(scope, n, Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static Operand<TInt32> tail(Scope scope, Shape<TInt32> shape) {\n+        return tail(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static <U extends TNumber> Operand<U> tail(\n+            Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return takeLast(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<TInt32> takeLast(\n+            Scope scope, Shape<TInt32> shape, Operand<TInt32> n) {\n+        return takeLast(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<U> takeLast(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+\n+        Size<U> rank = Size.create(scope, shape, dType);\n+        Sub<U> start = Sub.create(scope, rank, n);\n+        Operand<U> dims = Slice.create(scope, shape,\n+                ExpandDims.create(scope, start, Constant.scalarOf(scope, -1)),\n+                ExpandDims.create(scope,\n+                        Cast.create(scope, Constant.scalarOf(scope, -1), dType),\n+                        Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by the Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt32> prepend(\n+            Scope scope, Shape<TInt32> shape, int firstDimension) {\n+        Operand<TInt32> dim = Constant.arrayOf(scope, new int[]{firstDimension});\n+        Concat<TInt32> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by this Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt64> prepend(\n+            Scope scope, Shape<TInt64> shape, long firstDimension) {\n+        Operand<TInt64> dim = Constant.arrayOf(scope, new long[]{firstDimension});\n+        Concat<TInt64> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Returns a new Shape, with another Shape's dimensions prepended.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param otherShape     the other shape to prepend\n+     * @return a new shape with another Shape's dimensions prepended.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static <T extends TNumber> Operand<T> prepend(\n+            Scope scope, Operand<T> shape, Operand<T> otherShape) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwOTI3Mw=="}, "originalCommit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "originalPosition": 478}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY5NDIxNQ==", "bodyText": "Ok I understand your point, it is in case the given shape is any kind of tensor and not necessarily the result of the Shape op, make sense.\nMaybe we should update the documentation then because it stated that all the endpoint returns \"a Shape\" while it simply returns any integer rank-1 tensor that could be used as a shape or not (it looks like nothing would prevent a user to use this endpoint for any other reason).\nIf we want to make it clear that it should be used mainly for shapes, maybe we should add a prefix to all this endpoints so that they are accessible via tf.shape.prepend instead of just tf.prepend? That would be possible by simply adding a group to the operator annotation, i.e. @Operator(group=\"shape\")\nOr we can leave it as is but make the documentation a bit more generic as well. Btw, these are just suggestions.", "url": "https://github.com/tensorflow/java/pull/80#discussion_r449694215", "createdAt": "2020-07-03T20:03:38Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -337,4 +336,252 @@\n \n         return gather;\n     }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static Operand<TInt32> head(Scope scope, Shape<TInt32> shape) {\n+        return head(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static <U extends TNumber> Operand<U> head(Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return take(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static Operand<TInt32> take(Scope scope,  Shape<TInt32> shape, Operand<TInt32> n) {\n+        return take(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static <U extends TNumber> Operand<U> take(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+        Operand<U> dims = Slice.create(scope, shape,\n+                Cast.create(scope, Constant.arrayOf(scope, new int[]{0}), dType),\n+                ExpandDims.create(scope, n, Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static Operand<TInt32> tail(Scope scope, Shape<TInt32> shape) {\n+        return tail(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static <U extends TNumber> Operand<U> tail(\n+            Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return takeLast(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<TInt32> takeLast(\n+            Scope scope, Shape<TInt32> shape, Operand<TInt32> n) {\n+        return takeLast(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<U> takeLast(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+\n+        Size<U> rank = Size.create(scope, shape, dType);\n+        Sub<U> start = Sub.create(scope, rank, n);\n+        Operand<U> dims = Slice.create(scope, shape,\n+                ExpandDims.create(scope, start, Constant.scalarOf(scope, -1)),\n+                ExpandDims.create(scope,\n+                        Cast.create(scope, Constant.scalarOf(scope, -1), dType),\n+                        Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by the Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt32> prepend(\n+            Scope scope, Shape<TInt32> shape, int firstDimension) {\n+        Operand<TInt32> dim = Constant.arrayOf(scope, new int[]{firstDimension});\n+        Concat<TInt32> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by this Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt64> prepend(\n+            Scope scope, Shape<TInt64> shape, long firstDimension) {\n+        Operand<TInt64> dim = Constant.arrayOf(scope, new long[]{firstDimension});\n+        Concat<TInt64> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Returns a new Shape, with another Shape's dimensions prepended.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param otherShape     the other shape to prepend\n+     * @return a new shape with another Shape's dimensions prepended.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static <T extends TNumber> Operand<T> prepend(\n+            Scope scope, Operand<T> shape, Operand<T> otherShape) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwOTI3Mw=="}, "originalCommit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "originalPosition": 478}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTcyNDQwNg==", "bodyText": "I added the @Operator(group=\"shape\"), I was thinking of doing this anyway as it was growing bigger that I had originally thought and now it makes it clear what it is used for.\nI changed the JavaDoc and some other parameters to  clarify that Operand<> of dimensions are used rather than Shape objects. I reformatted with google-java-format formatter on both ShapeOps and ShapeOpsTest. Also cleaned up ShapeOps based on InteliJ Code Analysis. Changes are pushed.", "url": "https://github.com/tensorflow/java/pull/80#discussion_r449724406", "createdAt": "2020-07-04T00:42:36Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -337,4 +336,252 @@\n \n         return gather;\n     }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static Operand<TInt32> head(Scope scope, Shape<TInt32> shape) {\n+        return head(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static <U extends TNumber> Operand<U> head(Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return take(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static Operand<TInt32> take(Scope scope,  Shape<TInt32> shape, Operand<TInt32> n) {\n+        return take(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static <U extends TNumber> Operand<U> take(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+        Operand<U> dims = Slice.create(scope, shape,\n+                Cast.create(scope, Constant.arrayOf(scope, new int[]{0}), dType),\n+                ExpandDims.create(scope, n, Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static Operand<TInt32> tail(Scope scope, Shape<TInt32> shape) {\n+        return tail(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static <U extends TNumber> Operand<U> tail(\n+            Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return takeLast(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<TInt32> takeLast(\n+            Scope scope, Shape<TInt32> shape, Operand<TInt32> n) {\n+        return takeLast(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<U> takeLast(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+\n+        Size<U> rank = Size.create(scope, shape, dType);\n+        Sub<U> start = Sub.create(scope, rank, n);\n+        Operand<U> dims = Slice.create(scope, shape,\n+                ExpandDims.create(scope, start, Constant.scalarOf(scope, -1)),\n+                ExpandDims.create(scope,\n+                        Cast.create(scope, Constant.scalarOf(scope, -1), dType),\n+                        Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by the Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt32> prepend(\n+            Scope scope, Shape<TInt32> shape, int firstDimension) {\n+        Operand<TInt32> dim = Constant.arrayOf(scope, new int[]{firstDimension});\n+        Concat<TInt32> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by this Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt64> prepend(\n+            Scope scope, Shape<TInt64> shape, long firstDimension) {\n+        Operand<TInt64> dim = Constant.arrayOf(scope, new long[]{firstDimension});\n+        Concat<TInt64> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Returns a new Shape, with another Shape's dimensions prepended.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param otherShape     the other shape to prepend\n+     * @return a new shape with another Shape's dimensions prepended.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static <T extends TNumber> Operand<T> prepend(\n+            Scope scope, Operand<T> shape, Operand<T> otherShape) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwOTI3Mw=="}, "originalCommit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "originalPosition": 478}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTczNDM0OA==", "bodyText": "Thanks @JimClarke5 , looks good. The only thing though is that I'm pretty sure that when you ran mvn install on your branch, a few generated classes ended up being modified or added under src/gen/. These need to be committed as part of this PR too.\nAlso, probably that one of the file created is called ShapeOps as well and found under src/gen/annotations/org/tensorflow/op. It won't conflict with yours but it might be confusing to have two classes with the same name in the same jar. So I suggest then that you rename your operator class just Shapes (and ShapesTest).\nNote: at some point we will probably also need to rename the core package found in src/main/java/org/tensorflow/op as it conflicts with the same package found under src/gen/java but we can deal with this another time.", "url": "https://github.com/tensorflow/java/pull/80#discussion_r449734348", "createdAt": "2020-07-04T03:30:42Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -337,4 +336,252 @@\n \n         return gather;\n     }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static Operand<TInt32> head(Scope scope, Shape<TInt32> shape) {\n+        return head(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static <U extends TNumber> Operand<U> head(Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return take(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static Operand<TInt32> take(Scope scope,  Shape<TInt32> shape, Operand<TInt32> n) {\n+        return take(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static <U extends TNumber> Operand<U> take(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+        Operand<U> dims = Slice.create(scope, shape,\n+                Cast.create(scope, Constant.arrayOf(scope, new int[]{0}), dType),\n+                ExpandDims.create(scope, n, Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static Operand<TInt32> tail(Scope scope, Shape<TInt32> shape) {\n+        return tail(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static <U extends TNumber> Operand<U> tail(\n+            Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return takeLast(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<TInt32> takeLast(\n+            Scope scope, Shape<TInt32> shape, Operand<TInt32> n) {\n+        return takeLast(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<U> takeLast(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+\n+        Size<U> rank = Size.create(scope, shape, dType);\n+        Sub<U> start = Sub.create(scope, rank, n);\n+        Operand<U> dims = Slice.create(scope, shape,\n+                ExpandDims.create(scope, start, Constant.scalarOf(scope, -1)),\n+                ExpandDims.create(scope,\n+                        Cast.create(scope, Constant.scalarOf(scope, -1), dType),\n+                        Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by the Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt32> prepend(\n+            Scope scope, Shape<TInt32> shape, int firstDimension) {\n+        Operand<TInt32> dim = Constant.arrayOf(scope, new int[]{firstDimension});\n+        Concat<TInt32> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by this Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt64> prepend(\n+            Scope scope, Shape<TInt64> shape, long firstDimension) {\n+        Operand<TInt64> dim = Constant.arrayOf(scope, new long[]{firstDimension});\n+        Concat<TInt64> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Returns a new Shape, with another Shape's dimensions prepended.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param otherShape     the other shape to prepend\n+     * @return a new shape with another Shape's dimensions prepended.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static <T extends TNumber> Operand<T> prepend(\n+            Scope scope, Operand<T> shape, Operand<T> otherShape) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwOTI3Mw=="}, "originalCommit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "originalPosition": 478}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc3MTU4Ng==", "bodyText": "Ok, I have renamed ShapeOps ==> Shapes and ShapeOpsTest ==> ShapesTest under main.\nShapeOps under gen is generated from \"Shapes.java\", so I assumed (wrongly) that it wasn't tracked in Git,\nso I have added it and Ops.java back into my local repository.\nFYI, from my experience with Java modules, post Java 8, is that it gets very finicky about duplicate package names, especially across separate jars.\nHaving duplicate class names under different packages is possible, but gets nasty when using the  identically named classes within  the same code of another class, as I am finding out with the two Shape classes. Many times in the Keras code, it tries to first resolve the shape statically using org.tensorflow.tools.Shape, but if it can't, it then resolves the shape dynamically using org.tensorflow.op.core.Shape. The resolution is to fully qualify the class with the package name when using both identically named classes.", "url": "https://github.com/tensorflow/java/pull/80#discussion_r449771586", "createdAt": "2020-07-04T13:02:56Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -337,4 +336,252 @@\n \n         return gather;\n     }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static Operand<TInt32> head(Scope scope, Shape<TInt32> shape) {\n+        return head(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static <U extends TNumber> Operand<U> head(Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return take(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static Operand<TInt32> take(Scope scope,  Shape<TInt32> shape, Operand<TInt32> n) {\n+        return take(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static <U extends TNumber> Operand<U> take(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+        Operand<U> dims = Slice.create(scope, shape,\n+                Cast.create(scope, Constant.arrayOf(scope, new int[]{0}), dType),\n+                ExpandDims.create(scope, n, Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static Operand<TInt32> tail(Scope scope, Shape<TInt32> shape) {\n+        return tail(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static <U extends TNumber> Operand<U> tail(\n+            Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return takeLast(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<TInt32> takeLast(\n+            Scope scope, Shape<TInt32> shape, Operand<TInt32> n) {\n+        return takeLast(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<U> takeLast(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+\n+        Size<U> rank = Size.create(scope, shape, dType);\n+        Sub<U> start = Sub.create(scope, rank, n);\n+        Operand<U> dims = Slice.create(scope, shape,\n+                ExpandDims.create(scope, start, Constant.scalarOf(scope, -1)),\n+                ExpandDims.create(scope,\n+                        Cast.create(scope, Constant.scalarOf(scope, -1), dType),\n+                        Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by the Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt32> prepend(\n+            Scope scope, Shape<TInt32> shape, int firstDimension) {\n+        Operand<TInt32> dim = Constant.arrayOf(scope, new int[]{firstDimension});\n+        Concat<TInt32> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by this Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt64> prepend(\n+            Scope scope, Shape<TInt64> shape, long firstDimension) {\n+        Operand<TInt64> dim = Constant.arrayOf(scope, new long[]{firstDimension});\n+        Concat<TInt64> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Returns a new Shape, with another Shape's dimensions prepended.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param otherShape     the other shape to prepend\n+     * @return a new shape with another Shape's dimensions prepended.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static <T extends TNumber> Operand<T> prepend(\n+            Scope scope, Operand<T> shape, Operand<T> otherShape) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwOTI3Mw=="}, "originalCommit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "originalPosition": 478}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc4MzMyOA==", "bodyText": "gets nasty when using the identically named classes within the same code of another class, as I am finding out with the two Shape classes.\n\nI totally agree with you, I have the same surprise every time I'm working in the org.tensorflow.op.core package and I realize that my Shape instances are not of the expected type. I think it makes more sense that the static version keeps the Shape name and that we should override the name for the generated one (maybe TensorShape?).\nLet's do this another time though, this PR looks good to be merged now, thanks!", "url": "https://github.com/tensorflow/java/pull/80#discussion_r449783328", "createdAt": "2020-07-04T15:46:55Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -337,4 +336,252 @@\n \n         return gather;\n     }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static Operand<TInt32> head(Scope scope, Shape<TInt32> shape) {\n+        return head(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"head\")\n+    public static <U extends TNumber> Operand<U> head(Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return take(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static Operand<TInt32> take(Scope scope,  Shape<TInt32> shape, Operand<TInt32> n) {\n+        return take(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"take\")\n+    public static <U extends TNumber> Operand<U> take(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+        Operand<U> dims = Slice.create(scope, shape,\n+                Cast.create(scope, Constant.arrayOf(scope, new int[]{0}), dType),\n+                ExpandDims.create(scope, n, Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static Operand<TInt32> tail(Scope scope, Shape<TInt32> shape) {\n+        return tail(scope, shape, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return a 1-dimensional Shape with first dimension matching the first dimension of this Shape\n+     */\n+    @Endpoint(name = \"tail\")\n+    public static <U extends TNumber> Operand<U> tail(\n+            Scope scope, Shape<U> shape, DataType<U> dType) {\n+        return takeLast(scope, shape,\n+                Cast.create(scope, Constant.scalarOf(scope, 1), dType),\n+                dType);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<TInt32> takeLast(\n+            Scope scope, Shape<TInt32> shape, Operand<TInt32> n) {\n+        return takeLast(scope, shape, n, TInt32.DTYPE);\n+    }\n+\n+    /**\n+     * Returns an n-dimensional Shape with the dimensions matching the first n dimensions\n+     * of this shape\n+     *\n+     * @param scope current scope\n+     * @param shape the TensorFlow shape\n+     * @param n     the number of leading dimensions to get, must be <= than the shape's numDimensions()\n+     * @param dType the shape datatype.\n+     * @param <U>   the shape datatype.\n+     * @return an n-dimensional Shape with the first n dimensions matching the first n dimensions\n+     * of this Shape\n+     */\n+    @Endpoint(name = \"takeLast\")\n+    public static <U extends TNumber> Operand<U> takeLast(\n+            Scope scope, Shape<U> shape, Operand<U> n, DataType<U> dType) {\n+\n+        Size<U> rank = Size.create(scope, shape, dType);\n+        Sub<U> start = Sub.create(scope, rank, n);\n+        Operand<U> dims = Slice.create(scope, shape,\n+                ExpandDims.create(scope, start, Constant.scalarOf(scope, -1)),\n+                ExpandDims.create(scope,\n+                        Cast.create(scope, Constant.scalarOf(scope, -1), dType),\n+                        Constant.scalarOf(scope, -1)));\n+        return dims;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by the Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt32> prepend(\n+            Scope scope, Shape<TInt32> shape, int firstDimension) {\n+        Operand<TInt32> dim = Constant.arrayOf(scope, new int[]{firstDimension});\n+        Concat<TInt32> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Returns a new Shape, with a new first dimension inserted.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param firstDimension the dimension to prepend\n+     * @return a new shape with the given dimension(s) first, followed by this Shape's dimensions.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static Operand<TInt64> prepend(\n+            Scope scope, Shape<TInt64> shape, long firstDimension) {\n+        Operand<TInt64> dim = Constant.arrayOf(scope, new long[]{firstDimension});\n+        Concat<TInt64> result = Concat.create(scope,  Arrays.asList(dim, shape),\n+                Constant.scalarOf(scope, 0));\n+\n+        return result;\n+    }\n+\n+\n+\n+    /**\n+     * Returns a new Shape, with another Shape's dimensions prepended.\n+     *\n+     * @param scope          current scope\n+     * @param shape          the TensorFlow shape\n+     * @param otherShape     the other shape to prepend\n+     * @return a new shape with another Shape's dimensions prepended.\n+     */\n+    @Endpoint(name = \"prepend\")\n+    public static <T extends TNumber> Operand<T> prepend(\n+            Scope scope, Operand<T> shape, Operand<T> otherShape) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwOTI3Mw=="}, "originalCommit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "originalPosition": 478}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTkwMjczOnYy", "diffSide": "RIGHT", "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODo1NTozNFrOGsZoHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMTo0OTozN1rOGsd9vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIxMDM5OA==", "bodyText": "Just double-checking with you @JimClarke5 that you are using Google Java Formatter in your IDE, as there are a lot of reformatting changes in the PR (quickly like that, it looks like the previous version of the code was closer to what we find in the other source files).", "url": "https://github.com/tensorflow/java/pull/80#discussion_r449210398", "createdAt": "2020-07-02T18:55:34Z", "author": {"login": "karllessard"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -49,28 +42,30 @@\n     /**\n      * Flatten the operand to 1 dimension\n      *\n-     * @param <T> the type of operand\n-     * @param scope current scope\n+     * @param <T>     the type of operand\n+     * @param scope   current scope\n      * @param operand the operand to flatten\n      * @return the reshaped operand\n      */\n     @Endpoint(name = \"flatten\")\n-    public static <T extends TType> Operand<T> flatten(Scope scope, Operand<T> operand) {\n+    public static <T extends TType> Operand<T> flatten(\n+            Scope scope, Operand<T> operand) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2Mjc5Mg==", "bodyText": "I am using IntelliJ which seemed to have its own mind about formatting. I will see if I can add the Google Java Formatter to it.", "url": "https://github.com/tensorflow/java/pull/80#discussion_r449262792", "createdAt": "2020-07-02T20:58:32Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -49,28 +42,30 @@\n     /**\n      * Flatten the operand to 1 dimension\n      *\n-     * @param <T> the type of operand\n-     * @param scope current scope\n+     * @param <T>     the type of operand\n+     * @param scope   current scope\n      * @param operand the operand to flatten\n      * @return the reshaped operand\n      */\n     @Endpoint(name = \"flatten\")\n-    public static <T extends TType> Operand<T> flatten(Scope scope, Operand<T> operand) {\n+    public static <T extends TType> Operand<T> flatten(\n+            Scope scope, Operand<T> operand) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIxMDM5OA=="}, "originalCommit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI4MTQ2OA==", "bodyText": "Ok, if found the google-java-format plugin for intellij, so I can push up the reformatted code, pending  resolution to the first 2 questions.", "url": "https://github.com/tensorflow/java/pull/80#discussion_r449281468", "createdAt": "2020-07-02T21:49:37Z", "author": {"login": "JimClarke5"}, "path": "tensorflow-core/tensorflow-core-api/src/main/java/org/tensorflow/op/core/ShapeOps.java", "diffHunk": "@@ -49,28 +42,30 @@\n     /**\n      * Flatten the operand to 1 dimension\n      *\n-     * @param <T> the type of operand\n-     * @param scope current scope\n+     * @param <T>     the type of operand\n+     * @param scope   current scope\n      * @param operand the operand to flatten\n      * @return the reshaped operand\n      */\n     @Endpoint(name = \"flatten\")\n-    public static <T extends TType> Operand<T> flatten(Scope scope, Operand<T> operand) {\n+    public static <T extends TType> Operand<T> flatten(\n+            Scope scope, Operand<T> operand) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIxMDM5OA=="}, "originalCommit": {"oid": "185ef14f7bcc8713855798f9cb664581725b2b16"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1615, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}