{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyNzU0OTIx", "number": 2669, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzowMTowN1rOE6RYbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwNjo1Mjo0NVrOE9f3AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTM3NjQ1OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/BlockingRpcConnection.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzowMTowN1rOH1PBsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzowMTowN1rOH1PBsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4Mjc2OQ==", "bodyText": "This change is a forward port of the branch-1 change here: https://github.com/apache/hbase/pull/2671/files#diff-1a7ec27a8107293b6c87132823c262fc250570687a40f45646c43ae46dc6b04eR255\nThis change fixes a bug we encountered in production while running in Amazon's Elastic Kubernetes Service.", "url": "https://github.com/apache/hbase/pull/2669#discussion_r525582769", "createdAt": "2020-11-17T23:01:07Z", "author": {"login": "apurtell"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/BlockingRpcConnection.java", "diffHunk": "@@ -257,7 +256,17 @@ protected void setupConnection() throws IOException {\n         if (this.rpcClient.localAddr != null) {\n           this.socket.bind(this.rpcClient.localAddr);\n         }\n-        NetUtils.connect(this.socket, remoteId.getAddress(), this.rpcClient.connectTO);\n+        if (this.rpcClient.metrics != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dfa1f3cf13bf89ab46b4be2dda436391953512e"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTM4MzYwOnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/NettyRpcConnection.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzowNDowOFrOH1PGNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QyMzowNDowOFrOH1PGNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTU4MzkyNg==", "bodyText": "This is the netty version of the bug fix here: https://github.com/apache/hbase/pull/2669/files#diff-1a7ec27a8107293b6c87132823c262fc250570687a40f45646c43ae46dc6b04eR259", "url": "https://github.com/apache/hbase/pull/2669#discussion_r525583926", "createdAt": "2020-11-17T23:04:08Z", "author": {"login": "apurtell"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/NettyRpcConnection.java", "diffHunk": "@@ -265,23 +279,32 @@ public void operationComplete(Future<Boolean> future) throws Exception {\n     });\n   }\n \n-  private void connect() {\n+  private void connect() throws UnknownHostException {\n     assert eventLoop.inEventLoop();\n-    LOG.trace(\"Connecting to {}\", remoteId.address);\n-\n+    LOG.trace(\"Connecting to {}\", remoteId.getAddress());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dfa1f3cf13bf89ab46b4be2dda436391953512e"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTc3NDQ3OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncConnectionImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMTo1MToxNlrOH1Sr7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwMDoyMjozOVrOH2Ho7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0MjczMw==", "bodyText": "I do not think the old behavior is to ignore the unresolveable address? It just wants to make the stub key shorter and do not need to actual do a DNS lookup if we can make sure that the hostname will not change. And this is important for an async implementation, as we do not expect this method to be blocked but a DNS lookup could take several seconds if the the hostname can not be resolved.\nAnd in general, I never understand why here we need to add the ip address in the stub key... We have timestamp in server name so we could know whether it is the same region server, and for the rpc framework, there is no problem that they have the same stub key? We just use a string here and once we want to connect, we will resolve it and it will point to the correct ip address. We could point the hostname of a regionserver to another regionserver while both the regionservers are alive and can accept requests? This is not a good practice and can cause big troubles... I guess once we have done this, the old regionserver need to reconnect to master to again to tell master that its hostname has been changed?", "url": "https://github.com/apache/hbase/pull/2669#discussion_r525642733", "createdAt": "2020-11-18T01:51:16Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncConnectionImpl.java", "diffHunk": "@@ -186,6 +183,33 @@ private void spawnRenewalChore(final UserGroupInformation user) {\n     authService.scheduleChore(AuthUtil.getAuthRenewalChore(user));\n   }\n \n+  /**\n+   * Get a unique key for the rpc stub to the given server.\n+   */\n+  private String getStubKey(String serviceName, ServerName serverName) throws UnknownHostException {\n+    // Sometimes, servers go down and they come back up with the same hostname but a different\n+    // IP address. Force a resolution of the hostname by trying to instantiate an\n+    // InetSocketAddress, and this way we will rightfully get a new stubKey.\n+    // Also, include the hostname in the key so as to take care of those cases where the\n+    // DNS name is different but IP address remains the same.\n+    String hostname = serverName.getHostname();\n+    int port = serverName.getPort();\n+    // We used to ignore when the address was unresolvable but that makes no sense. It", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dfa1f3cf13bf89ab46b4be2dda436391953512e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI4OTQ5Mw==", "bodyText": "So we should use the ServerName here directly to make the key instead?\nI can do that. Let me make the change.", "url": "https://github.com/apache/hbase/pull/2669#discussion_r526289493", "createdAt": "2020-11-18T17:38:58Z", "author": {"login": "apurtell"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncConnectionImpl.java", "diffHunk": "@@ -186,6 +183,33 @@ private void spawnRenewalChore(final UserGroupInformation user) {\n     authService.scheduleChore(AuthUtil.getAuthRenewalChore(user));\n   }\n \n+  /**\n+   * Get a unique key for the rpc stub to the given server.\n+   */\n+  private String getStubKey(String serviceName, ServerName serverName) throws UnknownHostException {\n+    // Sometimes, servers go down and they come back up with the same hostname but a different\n+    // IP address. Force a resolution of the hostname by trying to instantiate an\n+    // InetSocketAddress, and this way we will rightfully get a new stubKey.\n+    // Also, include the hostname in the key so as to take care of those cases where the\n+    // DNS name is different but IP address remains the same.\n+    String hostname = serverName.getHostname();\n+    int port = serverName.getPort();\n+    // We used to ignore when the address was unresolvable but that makes no sense. It", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0MjczMw=="}, "originalCommit": {"oid": "1dfa1f3cf13bf89ab46b4be2dda436391953512e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxMDMxOQ==", "bodyText": "I'm not sure whether we really need to identify different region servers here. What is the problem if we just use host and port as the stub key here? It will not be a problem if we will resolve it when we actually connecting the remote side? Thoughts?", "url": "https://github.com/apache/hbase/pull/2669#discussion_r526510319", "createdAt": "2020-11-19T00:22:39Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncConnectionImpl.java", "diffHunk": "@@ -186,6 +183,33 @@ private void spawnRenewalChore(final UserGroupInformation user) {\n     authService.scheduleChore(AuthUtil.getAuthRenewalChore(user));\n   }\n \n+  /**\n+   * Get a unique key for the rpc stub to the given server.\n+   */\n+  private String getStubKey(String serviceName, ServerName serverName) throws UnknownHostException {\n+    // Sometimes, servers go down and they come back up with the same hostname but a different\n+    // IP address. Force a resolution of the hostname by trying to instantiate an\n+    // InetSocketAddress, and this way we will rightfully get a new stubKey.\n+    // Also, include the hostname in the key so as to take care of those cases where the\n+    // DNS name is different but IP address remains the same.\n+    String hostname = serverName.getHostname();\n+    int port = serverName.getPort();\n+    // We used to ignore when the address was unresolvable but that makes no sense. It", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0MjczMw=="}, "originalCommit": {"oid": "1dfa1f3cf13bf89ab46b4be2dda436391953512e"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTc5NzI5OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/AbstractRpcClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMjowMjowOVrOH1S5cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMjowMjowOVrOH1S5cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NjE5Mg==", "bodyText": "Good. When implementing an in-house rpc framework in the past, I used to use InetSocketAddress.createUnresolved. But it has a problem that usually a network framework will not accept a unresolved InetSocketAddress so if you forget to  recreate a resolved one you will get exception. Since here we have a special structure, I think it is good to make use it to explicitly say that, here we do not want a resolve yet.", "url": "https://github.com/apache/hbase/pull/2669#discussion_r525646192", "createdAt": "2020-11-18T02:02:09Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/AbstractRpcClient.java", "diffHunk": "@@ -135,10 +136,10 @@\n \n   private int maxConcurrentCallsPerServer;\n \n-  private static final LoadingCache<InetSocketAddress, AtomicInteger> concurrentCounterCache =\n+  private static final LoadingCache<Address, AtomicInteger> concurrentCounterCache =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dfa1f3cf13bf89ab46b4be2dda436391953512e"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTgwNTA4OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/AbstractRpcClient.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMjowNTo1MFrOH1S-CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwNzowNzowNlrOH6OI1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NzM2OQ==", "bodyText": "Could we change this to use Address directly? And we could also remove the UnknownHostException from the createAddr method then which could makes the createRpcChannel and createBlockingRpcChannel not throw IOException, which will be very good.", "url": "https://github.com/apache/hbase/pull/2669#discussion_r525647369", "createdAt": "2020-11-18T02:05:50Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/AbstractRpcClient.java", "diffHunk": "@@ -390,8 +391,8 @@ private void onCallFinished(Call call, HBaseRpcController hrc, InetSocketAddress\n   }\n \n   Call callMethod(final Descriptors.MethodDescriptor md, final HBaseRpcController hrc,\n-      final Message param, Message returnType, final User ticket, final InetSocketAddress addr,\n-      final RpcCallback<Message> callback) {\n+      final Message param, Message returnType, final User ticket,\n+      final InetSocketAddress inetAddr, final RpcCallback<Message> callback) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dfa1f3cf13bf89ab46b4be2dda436391953512e"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjI5MTgxNA==", "bodyText": "Let me check.\nWhat we want to avoid is making an ISA for every Call.\nWill try this and get back to you.", "url": "https://github.com/apache/hbase/pull/2669#discussion_r526291814", "createdAt": "2020-11-18T17:40:29Z", "author": {"login": "apurtell"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/AbstractRpcClient.java", "diffHunk": "@@ -390,8 +391,8 @@ private void onCallFinished(Call call, HBaseRpcController hrc, InetSocketAddress\n   }\n \n   Call callMethod(final Descriptors.MethodDescriptor md, final HBaseRpcController hrc,\n-      final Message param, Message returnType, final User ticket, final InetSocketAddress addr,\n-      final RpcCallback<Message> callback) {\n+      final Message param, Message returnType, final User ticket,\n+      final InetSocketAddress inetAddr, final RpcCallback<Message> callback) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NzM2OQ=="}, "originalCommit": {"oid": "1dfa1f3cf13bf89ab46b4be2dda436391953512e"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ0OTYzOA==", "bodyText": "I can't do this or else there will be a new InetSocketAddress() for every callMethod(), which may cause a DNS lookup per call.", "url": "https://github.com/apache/hbase/pull/2669#discussion_r526449638", "createdAt": "2020-11-18T21:57:37Z", "author": {"login": "apurtell"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/AbstractRpcClient.java", "diffHunk": "@@ -390,8 +391,8 @@ private void onCallFinished(Call call, HBaseRpcController hrc, InetSocketAddress\n   }\n \n   Call callMethod(final Descriptors.MethodDescriptor md, final HBaseRpcController hrc,\n-      final Message param, Message returnType, final User ticket, final InetSocketAddress addr,\n-      final RpcCallback<Message> callback) {\n+      final Message param, Message returnType, final User ticket,\n+      final InetSocketAddress inetAddr, final RpcCallback<Message> callback) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NzM2OQ=="}, "originalCommit": {"oid": "1dfa1f3cf13bf89ab46b4be2dda436391953512e"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3Njk5Ng==", "bodyText": "Ok, done. Lookup done upon first call and then cached there; or else an exception or failure indication is returned at that time.", "url": "https://github.com/apache/hbase/pull/2669#discussion_r526476996", "createdAt": "2020-11-18T22:52:35Z", "author": {"login": "apurtell"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/AbstractRpcClient.java", "diffHunk": "@@ -390,8 +391,8 @@ private void onCallFinished(Call call, HBaseRpcController hrc, InetSocketAddress\n   }\n \n   Call callMethod(final Descriptors.MethodDescriptor md, final HBaseRpcController hrc,\n-      final Message param, Message returnType, final User ticket, final InetSocketAddress addr,\n-      final RpcCallback<Message> callback) {\n+      final Message param, Message returnType, final User ticket,\n+      final InetSocketAddress inetAddr, final RpcCallback<Message> callback) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NzM2OQ=="}, "originalCommit": {"oid": "1dfa1f3cf13bf89ab46b4be2dda436391953512e"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjUxMjc0NA==", "bodyText": "Can not view the code now but IIRC, on this execution path, we will use a ConnectionId to get a RpcConnection and then use it to send the rpc call? Then I think we could put the actual resolving in the connect method? Before connecting we could always use the Address class to represent the remote address.", "url": "https://github.com/apache/hbase/pull/2669#discussion_r526512744", "createdAt": "2020-11-19T00:29:51Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/AbstractRpcClient.java", "diffHunk": "@@ -390,8 +391,8 @@ private void onCallFinished(Call call, HBaseRpcController hrc, InetSocketAddress\n   }\n \n   Call callMethod(final Descriptors.MethodDescriptor md, final HBaseRpcController hrc,\n-      final Message param, Message returnType, final User ticket, final InetSocketAddress addr,\n-      final RpcCallback<Message> callback) {\n+      final Message param, Message returnType, final User ticket,\n+      final InetSocketAddress inetAddr, final RpcCallback<Message> callback) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NzM2OQ=="}, "originalCommit": {"oid": "1dfa1f3cf13bf89ab46b4be2dda436391953512e"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDgxMTA5NA==", "bodyText": "Checked the code, I think we could avoid creating an InetSocketAddress everytime here, we just need to change more classes to make use of Address instead of InetSocketAddress, such as ConnetionId, FailedServers, as well as the RpcClient interface. And the resolving of the actual address could be delayed to NettyRpcConnection.connect and BlockingRpcConnection.setupConnection, where we really want to connect to the remote side. And once the connection has been established, and it has not been closed because of error or idle for too long, we do not need to involve InetSocketAddress again. I think it is OK?", "url": "https://github.com/apache/hbase/pull/2669#discussion_r530811094", "createdAt": "2020-11-26T07:07:06Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/AbstractRpcClient.java", "diffHunk": "@@ -390,8 +391,8 @@ private void onCallFinished(Call call, HBaseRpcController hrc, InetSocketAddress\n   }\n \n   Call callMethod(final Descriptors.MethodDescriptor md, final HBaseRpcController hrc,\n-      final Message param, Message returnType, final User ticket, final InetSocketAddress addr,\n-      final RpcCallback<Message> callback) {\n+      final Message param, Message returnType, final User ticket,\n+      final InetSocketAddress inetAddr, final RpcCallback<Message> callback) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NzM2OQ=="}, "originalCommit": {"oid": "1dfa1f3cf13bf89ab46b4be2dda436391953512e"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5NTgwNjEyOnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/ConnectionId.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMjowNjoyMVrOH1S-qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQwMjowNjoyMVrOH1S-qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NzUyOA==", "bodyText": "Good.", "url": "https://github.com/apache/hbase/pull/2669#discussion_r525647528", "createdAt": "2020-11-18T02:06:21Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/ConnectionId.java", "diffHunk": "@@ -32,9 +32,9 @@\n   private static final int PRIME = 16777619;\n   final User ticket;\n   final String serviceName;\n-  final InetSocketAddress address;\n+  final Address address;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1dfa1f3cf13bf89ab46b4be2dda436391953512e"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMjU0NjA1OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwOTo0MTowNFrOH2UgbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNjoxMzozM1rOH2mSgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyMTEzMg==", "bodyText": "nit: both InetAddress and InetSocketAddress are no longer in use, imports can be removed.", "url": "https://github.com/apache/hbase/pull/2669#discussion_r526721132", "createdAt": "2020-11-19T09:41:04Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -25,6 +25,7 @@\n import java.io.IOException;\n import java.lang.reflect.UndeclaredThrowableException;\n import java.net.InetAddress;\n+import java.net.InetSocketAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02560a78677d16a81f775be5f1c8be820c9179e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAxMjQ4MQ==", "bodyText": "Ok. There are going to be other checkstyle nits too, will look at the report and fix them all.", "url": "https://github.com/apache/hbase/pull/2669#discussion_r527012481", "createdAt": "2020-11-19T16:13:33Z", "author": {"login": "apurtell"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -25,6 +25,7 @@\n import java.io.IOException;\n import java.lang.reflect.UndeclaredThrowableException;\n import java.net.InetAddress;\n+import java.net.InetSocketAddress;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyMTEzMg=="}, "originalCommit": {"oid": "e02560a78677d16a81f775be5f1c8be820c9179e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMjU1MjYxOnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncConnectionImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwOTo0MjozOFrOH2Ukpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQwOTo0MjozOFrOH2Ukpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjcyMjIxNQ==", "bodyText": "nit: same here, no longer in use.", "url": "https://github.com/apache/hbase/pull/2669#discussion_r526722215", "createdAt": "2020-11-19T09:42:38Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncConnectionImpl.java", "diffHunk": "@@ -28,6 +28,8 @@\n import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n \n import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02560a78677d16a81f775be5f1c8be820c9179e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMjY1Mjc3OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxMDowNTowOFrOH2Vgpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwNzowOToxM1rOH3pFnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjczNzU3NQ==", "bodyText": "This conversion to InetSocketAddress[] takes place for each new StoreFileWriter creation right? Is there any other usecase that I am missing here?", "url": "https://github.com/apache/hbase/pull/2669#discussion_r526737575", "createdAt": "2020-11-19T10:05:08Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java", "diffHunk": "@@ -3485,25 +3488,26 @@ boolean checkFileSystem() {\n   @Override\n   public void updateRegionFavoredNodesMapping(String encodedRegionName,\n       List<org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.ServerName> favoredNodes) {\n-    InetSocketAddress[] addr = new InetSocketAddress[favoredNodes.size()];\n+    Address[] addr = new Address[favoredNodes.size()];\n     // Refer to the comment on the declaration of regionFavoredNodesMap on why\n-    // it is a map of region name to InetSocketAddress[]\n+    // it is a map of region name to Address[]\n     for (int i = 0; i < favoredNodes.size(); i++) {\n-      addr[i] = InetSocketAddress.createUnresolved(favoredNodes.get(i).getHostName(),\n+      addr[i] = Address.fromParts(favoredNodes.get(i).getHostName(),\n           favoredNodes.get(i).getPort());\n     }\n     regionFavoredNodesMap.put(encodedRegionName, addr);\n   }\n \n   /**\n    * Return the favored nodes for a region given its encoded name. Look at the\n-   * comment around {@link #regionFavoredNodesMap} on why it is InetSocketAddress[]\n-   *\n+   * comment around {@link #regionFavoredNodesMap} on why we convert to InetSocketAddress[]\n+   * here.\n+   * @param encodedRegionName\n    * @return array of favored locations\n    */\n   @Override\n   public InetSocketAddress[] getFavoredNodesForRegion(String encodedRegionName) {\n-    return regionFavoredNodesMap.get(encodedRegionName);\n+    return Address.toSocketAddress(regionFavoredNodesMap.get(encodedRegionName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e02560a78677d16a81f775be5f1c8be820c9179e"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc0ODA3OA==", "bodyText": "Where do we check if these addresses are resolved? Or we don't need to for this specific use-case?", "url": "https://github.com/apache/hbase/pull/2669#discussion_r526748078", "createdAt": "2020-11-19T10:21:44Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java", "diffHunk": "@@ -3485,25 +3488,26 @@ boolean checkFileSystem() {\n   @Override\n   public void updateRegionFavoredNodesMapping(String encodedRegionName,\n       List<org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.ServerName> favoredNodes) {\n-    InetSocketAddress[] addr = new InetSocketAddress[favoredNodes.size()];\n+    Address[] addr = new Address[favoredNodes.size()];\n     // Refer to the comment on the declaration of regionFavoredNodesMap on why\n-    // it is a map of region name to InetSocketAddress[]\n+    // it is a map of region name to Address[]\n     for (int i = 0; i < favoredNodes.size(); i++) {\n-      addr[i] = InetSocketAddress.createUnresolved(favoredNodes.get(i).getHostName(),\n+      addr[i] = Address.fromParts(favoredNodes.get(i).getHostName(),\n           favoredNodes.get(i).getPort());\n     }\n     regionFavoredNodesMap.put(encodedRegionName, addr);\n   }\n \n   /**\n    * Return the favored nodes for a region given its encoded name. Look at the\n-   * comment around {@link #regionFavoredNodesMap} on why it is InetSocketAddress[]\n-   *\n+   * comment around {@link #regionFavoredNodesMap} on why we convert to InetSocketAddress[]\n+   * here.\n+   * @param encodedRegionName\n    * @return array of favored locations\n    */\n   @Override\n   public InetSocketAddress[] getFavoredNodesForRegion(String encodedRegionName) {\n-    return regionFavoredNodesMap.get(encodedRegionName);\n+    return Address.toSocketAddress(regionFavoredNodesMap.get(encodedRegionName));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjczNzU3NQ=="}, "originalCommit": {"oid": "e02560a78677d16a81f775be5f1c8be820c9179e"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAxMTk5MQ==", "bodyText": "This will happen whenever the regionserver needs to build a list of ISA of datanodes for handing to FileSystem#create, but only if Favored Nodes is enabled. (As far as I know, nobody actually uses favored nodes, well, perhaps Francis and ex-Yahoo team.) So yeah, just before store file creation time. We can hand the ISA directly to HDFS without checking ISA#isUnresolved because should an ISA be unresolved when HDFS tries to use it the Java network API will throw an exception, which will propagate up to us. However if you would prefer to check the resolution status of the ISAs and explicitly throw our own exception, the place to do this would be FSUtils.java where the call to FileSystem#create including ISA parameters is performed via reflection.", "url": "https://github.com/apache/hbase/pull/2669#discussion_r527011991", "createdAt": "2020-11-19T16:12:52Z", "author": {"login": "apurtell"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java", "diffHunk": "@@ -3485,25 +3488,26 @@ boolean checkFileSystem() {\n   @Override\n   public void updateRegionFavoredNodesMapping(String encodedRegionName,\n       List<org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.ServerName> favoredNodes) {\n-    InetSocketAddress[] addr = new InetSocketAddress[favoredNodes.size()];\n+    Address[] addr = new Address[favoredNodes.size()];\n     // Refer to the comment on the declaration of regionFavoredNodesMap on why\n-    // it is a map of region name to InetSocketAddress[]\n+    // it is a map of region name to Address[]\n     for (int i = 0; i < favoredNodes.size(); i++) {\n-      addr[i] = InetSocketAddress.createUnresolved(favoredNodes.get(i).getHostName(),\n+      addr[i] = Address.fromParts(favoredNodes.get(i).getHostName(),\n           favoredNodes.get(i).getPort());\n     }\n     regionFavoredNodesMap.put(encodedRegionName, addr);\n   }\n \n   /**\n    * Return the favored nodes for a region given its encoded name. Look at the\n-   * comment around {@link #regionFavoredNodesMap} on why it is InetSocketAddress[]\n-   *\n+   * comment around {@link #regionFavoredNodesMap} on why we convert to InetSocketAddress[]\n+   * here.\n+   * @param encodedRegionName\n    * @return array of favored locations\n    */\n   @Override\n   public InetSocketAddress[] getFavoredNodesForRegion(String encodedRegionName) {\n-    return regionFavoredNodesMap.get(encodedRegionName);\n+    return Address.toSocketAddress(regionFavoredNodesMap.get(encodedRegionName));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjczNzU3NQ=="}, "originalCommit": {"oid": "e02560a78677d16a81f775be5f1c8be820c9179e"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODEwNjkwOQ==", "bodyText": "the place to do this would be FSUtils.java where the call to FileSystem#create including ISA parameters is performed via reflection.\n\nOh, what a giant reflection happening here :)\n          return (FSDataOutputStream) (DistributedFileSystem.class\n            .getDeclaredMethod(\"create\", Path.class, FsPermission.class, boolean.class, int.class,\n              short.class, long.class, Progressable.class, InetSocketAddress[].class)\n            .invoke(backingFs, path, perm, true, CommonFSUtils.getDefaultBufferSize(backingFs),\n              replication > 0 ? replication : CommonFSUtils.getDefaultReplication(backingFs, path),\n              CommonFSUtils.getDefaultBlockSize(backingFs, path), null, favoredNodes));\n\n\nWe can hand the ISA directly to HDFS without checking ISA#isUnresolved because should an ISA be unresolved when HDFS tries to use it the Java network API will throw an exception, which will propagate up to us.\n\nMakes sense, I think we should be good with this as is, rather than performing resolution checks at both layers.", "url": "https://github.com/apache/hbase/pull/2669#discussion_r528106909", "createdAt": "2020-11-21T07:09:13Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java", "diffHunk": "@@ -3485,25 +3488,26 @@ boolean checkFileSystem() {\n   @Override\n   public void updateRegionFavoredNodesMapping(String encodedRegionName,\n       List<org.apache.hadoop.hbase.shaded.protobuf.generated.HBaseProtos.ServerName> favoredNodes) {\n-    InetSocketAddress[] addr = new InetSocketAddress[favoredNodes.size()];\n+    Address[] addr = new Address[favoredNodes.size()];\n     // Refer to the comment on the declaration of regionFavoredNodesMap on why\n-    // it is a map of region name to InetSocketAddress[]\n+    // it is a map of region name to Address[]\n     for (int i = 0; i < favoredNodes.size(); i++) {\n-      addr[i] = InetSocketAddress.createUnresolved(favoredNodes.get(i).getHostName(),\n+      addr[i] = Address.fromParts(favoredNodes.get(i).getHostName(),\n           favoredNodes.get(i).getPort());\n     }\n     regionFavoredNodesMap.put(encodedRegionName, addr);\n   }\n \n   /**\n    * Return the favored nodes for a region given its encoded name. Look at the\n-   * comment around {@link #regionFavoredNodesMap} on why it is InetSocketAddress[]\n-   *\n+   * comment around {@link #regionFavoredNodesMap} on why we convert to InetSocketAddress[]\n+   * here.\n+   * @param encodedRegionName\n    * @return array of favored locations\n    */\n   @Override\n   public InetSocketAddress[] getFavoredNodesForRegion(String encodedRegionName) {\n-    return regionFavoredNodesMap.get(encodedRegionName);\n+    return Address.toSocketAddress(regionFavoredNodesMap.get(encodedRegionName));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjczNzU3NQ=="}, "originalCommit": {"oid": "e02560a78677d16a81f775be5f1c8be820c9179e"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyOTIwNTc3OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwNjo1Mjo0NVrOH6Nzlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwNjo1Mjo0NVrOH6Nzlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDgwNTY1NQ==", "bodyText": "As said before, I wonder what is the problem if we just use host:port directly here? In the past I think the problem is that we will not resolve again when connecting, for now, I think the problem has been solved?", "url": "https://github.com/apache/hbase/pull/2669#discussion_r530805655", "createdAt": "2020-11-26T06:52:45Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -128,32 +129,17 @@ public static void setServerSideHConnectionRetriesConfig(final Configuration c,\n   }\n \n   /**\n-   * Return retires + 1. The returned value will be in range [1, Integer.MAX_VALUE].\n+   * Get a unique key for the rpc stub to the given server.\n    */\n-  static int retries2Attempts(int retries) {\n-    return Math.max(1, retries == Integer.MAX_VALUE ? Integer.MAX_VALUE : retries + 1);\n+  static String getStubKey(String serviceName, ServerName serverName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df43787aa25d98d5796e4d7ada20337d4f593d33"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2401, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}