{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExMTc0NjUy", "number": 1613, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNToxNToyMVrOD4FqUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNjoxNTozMlrOD4aSkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTM5NjAzOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HbckChore.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNToxNToyMVrOGOuBKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMDoxNDo1NFrOGPUiZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA4NzIwOQ==", "bodyText": "would it make sense to make it a bit more generic and have \"loadRegionsFromMeta()\" function (similar to loadRegionsFromInMemoryState/loadRegionsFromRSReport) as then you'd have another source to compare against - hbase:meta. Then loadRegionsFromFS() would check against that state to see if a region is merged or not.", "url": "https://github.com/apache/hbase/pull/1613#discussion_r418087209", "createdAt": "2020-04-30T15:15:21Z", "author": {"login": "timoha"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HbckChore.java", "diffHunk": "@@ -134,7 +135,7 @@ protected synchronized void chore() {\n       loadRegionsFromInMemoryState();\n       loadRegionsFromRSReport();\n       try {\n-        loadRegionsFromFS();\n+        loadRegionsFromFS(scanForMergedParentRegions());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e4d080cdf848a307c62010193865fb0cceb7431"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEzNDE2Mg==", "bodyText": "Yeah, that is the idea. scanForMergedParentRegions() loads regions from meta. For merge, it is a bit special, the parent regions are deleted from meta already, the only bit left is the merge qualifers in the child region.", "url": "https://github.com/apache/hbase/pull/1613#discussion_r418134162", "createdAt": "2020-04-30T16:24:22Z", "author": {"login": "huaxiangsun"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HbckChore.java", "diffHunk": "@@ -134,7 +135,7 @@ protected synchronized void chore() {\n       loadRegionsFromInMemoryState();\n       loadRegionsFromRSReport();\n       try {\n-        loadRegionsFromFS();\n+        loadRegionsFromFS(scanForMergedParentRegions());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA4NzIwOQ=="}, "originalCommit": {"oid": "3e4d080cdf848a307c62010193865fb0cceb7431"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYxMDYxMw==", "bodyText": "Does InMemoryState not have the needed merge info in it? If not, maybe it should.\nThe CatalogJanitor is what manages when merge references are let go so this scan of meta is probably necessary.\nTo the @timoha point, are there other places in hbckchore where we need currrent picture of hbase:meta?", "url": "https://github.com/apache/hbase/pull/1613#discussion_r418610613", "createdAt": "2020-05-01T16:08:40Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HbckChore.java", "diffHunk": "@@ -134,7 +135,7 @@ protected synchronized void chore() {\n       loadRegionsFromInMemoryState();\n       loadRegionsFromRSReport();\n       try {\n-        loadRegionsFromFS();\n+        loadRegionsFromFS(scanForMergedParentRegions());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA4NzIwOQ=="}, "originalCommit": {"oid": "3e4d080cdf848a307c62010193865fb0cceb7431"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcxODMxMQ==", "bodyText": "@saintstack Yeah the in-memory state/meta row for merged parents are let go at early state of MergeRegionsProcedures.\n@timoha Per Stack's comments about the source of truth is the in-memory database (meta/procedure store are ways to recover in-memory databse since they are persistent).\nAt this moment, there is no other usage of regions from meta in hbck chore, the merged parents info is a special case, they are columns from the child region,  the only source of truth for merged parents. We can maintain the in-memory hashset for merged parent if meta scan is too costly, which can be addressed later. In case of the future requirements, scanForMergedParentRegions() can be modified to get more info from meta.", "url": "https://github.com/apache/hbase/pull/1613#discussion_r418718311", "createdAt": "2020-05-01T20:14:54Z", "author": {"login": "huaxiangsun"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HbckChore.java", "diffHunk": "@@ -134,7 +135,7 @@ protected synchronized void chore() {\n       loadRegionsFromInMemoryState();\n       loadRegionsFromRSReport();\n       try {\n-        loadRegionsFromFS();\n+        loadRegionsFromFS(scanForMergedParentRegions());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA4NzIwOQ=="}, "originalCommit": {"oid": "3e4d080cdf848a307c62010193865fb0cceb7431"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTQxMzEzOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HbckChore.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNToxOTozNFrOGOuMHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNjoxMzo0MFrOGPOGlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDAxMw==", "bodyText": "if it's not in in-memory database but it is in merged regions, that seems like a problem as well and should be reported?", "url": "https://github.com/apache/hbase/pull/1613#discussion_r418090013", "createdAt": "2020-04-30T15:19:34Z", "author": {"login": "timoha"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HbckChore.java", "diffHunk": "@@ -271,12 +297,12 @@ private void loadRegionsFromFS() throws IOException {\n           continue;\n         }\n         HbckRegionInfo hri = regionInfoMap.get(encodedRegionName);\n-        if (hri == null) {\n+        // If it is not in in-memory database and not a merged region,\n+        // report it as an orphan region.\n+        if (hri == null && !mergedParentRegions.contains(encodedRegionName)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e4d080cdf848a307c62010193865fb0cceb7431"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE0MTg0OQ==", "bodyText": "Are you referring to the following case?\nif (hri == null && mergedParentRegions.contains(encodedRegionName)) {} \nThis is valid for merged parent regions as of today.", "url": "https://github.com/apache/hbase/pull/1613#discussion_r418141849", "createdAt": "2020-04-30T16:36:42Z", "author": {"login": "huaxiangsun"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HbckChore.java", "diffHunk": "@@ -271,12 +297,12 @@ private void loadRegionsFromFS() throws IOException {\n           continue;\n         }\n         HbckRegionInfo hri = regionInfoMap.get(encodedRegionName);\n-        if (hri == null) {\n+        // If it is not in in-memory database and not a merged region,\n+        // report it as an orphan region.\n+        if (hri == null && !mergedParentRegions.contains(encodedRegionName)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDAxMw=="}, "originalCommit": {"oid": "3e4d080cdf848a307c62010193865fb0cceb7431"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYxMjg4NQ==", "bodyText": "Oh, merge parents are NOT in in-memory state because they are not active. We just have this background cleaner task that is doing janitorial work on hbase:meta cleaning up meta and filesystem....", "url": "https://github.com/apache/hbase/pull/1613#discussion_r418612885", "createdAt": "2020-05-01T16:13:40Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HbckChore.java", "diffHunk": "@@ -271,12 +297,12 @@ private void loadRegionsFromFS() throws IOException {\n           continue;\n         }\n         HbckRegionInfo hri = regionInfoMap.get(encodedRegionName);\n-        if (hri == null) {\n+        // If it is not in in-memory database and not a merged region,\n+        // report it as an orphan region.\n+        if (hri == null && !mergedParentRegions.contains(encodedRegionName)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDAxMw=="}, "originalCommit": {"oid": "3e4d080cdf848a307c62010193865fb0cceb7431"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDc2MzgzOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HbckChore.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNjoxMDo1N1rOGPOB-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNjoxMDo1N1rOGPOB-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYxMTcwNA==", "bodyText": "Yeah, may be no way around it given the scan for merged parents is so specialized.\nThis looks good.", "url": "https://github.com/apache/hbase/pull/1613#discussion_r418611704", "createdAt": "2020-05-01T16:10:57Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HbckChore.java", "diffHunk": "@@ -187,6 +188,31 @@ private void saveCheckResultToSnapshot() {\n     }\n   }\n \n+  /**\n+   * Scan hbase:meta to get set of merged parent regions, this is a very heavy scan.\n+   *\n+   * @return Return generated {@link HashSet}\n+   */\n+  private HashSet<String> scanForMergedParentRegions() throws IOException {\n+    HashSet<String> mergedParentRegions = new HashSet<>();\n+    // Null tablename means scan all of meta.\n+    MetaTableAccessor.scanMetaForTableRegions(this.master.getConnection(),\n+      r -> {\n+        List<RegionInfo> mergeParents = MetaTableAccessor.getMergeRegions(r.rawCells());\n+        if (mergeParents != null) {\n+          for (RegionInfo mergeRegion : mergeParents) {\n+            if (mergeRegion != null) {\n+              // This region is already being merged\n+              mergedParentRegions.add(mergeRegion.getEncodedName());\n+            }\n+          }\n+        }\n+        return true;\n+        },\n+      null);\n+    return mergedParentRegions;\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b53c068b9beeace2cdf2f3e7b8ff9fe556d5477"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDc3NDgwOnYy", "diffSide": "LEFT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/assignment/AssignmentManager.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNjoxNTowMlrOGPOJDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMjo0MDowNlrOGPXgXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYxMzUxOA==", "bodyText": "ok. good. lets keep an eye on this one because sometimes fun, unexpected conditions when change order of operations.", "url": "https://github.com/apache/hbase/pull/1613#discussion_r418613518", "createdAt": "2020-05-01T16:15:02Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/assignment/AssignmentManager.java", "diffHunk": "@@ -1859,11 +1859,17 @@ public void markRegionAsMerged(final RegionInfo child, final ServerName serverNa\n       throws IOException {\n     final RegionStateNode node = regionStates.getOrCreateRegionStateNode(child);\n     node.setState(State.MERGED);\n+    regionStateStore.mergeRegions(child, mergeParents, serverName);\n+\n+    // The order of adding merge qualifers and deleting from regionStates is important.\n+    // hbck chore depends on these merge qualifers and regionStates to check if a region on FS\n+    // is an orphan. If deleting from regionStates first, then there is a small gap that\n+    // a region is not in regionStates and there is no merge qualifer for this region, it will be\n+    // reported as an orphan.\n     for (RegionInfo ri: mergeParents) {\n       regionStates.deleteRegion(ri);\n \n     }\n-    regionStateStore.mergeRegions(child, mergeParents, serverName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b53c068b9beeace2cdf2f3e7b8ff9fe556d5477"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODcwMTc0OQ==", "bodyText": "This happens during my test, which is doing a hbck report every 10 ms, yeah, will check the sequence to make sure it does not cause any unexpected conditions.", "url": "https://github.com/apache/hbase/pull/1613#discussion_r418701749", "createdAt": "2020-05-01T19:33:53Z", "author": {"login": "huaxiangsun"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/assignment/AssignmentManager.java", "diffHunk": "@@ -1859,11 +1859,17 @@ public void markRegionAsMerged(final RegionInfo child, final ServerName serverNa\n       throws IOException {\n     final RegionStateNode node = regionStates.getOrCreateRegionStateNode(child);\n     node.setState(State.MERGED);\n+    regionStateStore.mergeRegions(child, mergeParents, serverName);\n+\n+    // The order of adding merge qualifers and deleting from regionStates is important.\n+    // hbck chore depends on these merge qualifers and regionStates to check if a region on FS\n+    // is an orphan. If deleting from regionStates first, then there is a small gap that\n+    // a region is not in regionStates and there is no merge qualifer for this region, it will be\n+    // reported as an orphan.\n     for (RegionInfo ri: mergeParents) {\n       regionStates.deleteRegion(ri);\n \n     }\n-    regionStateStore.mergeRegions(child, mergeParents, serverName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYxMzUxOA=="}, "originalCommit": {"oid": "2b53c068b9beeace2cdf2f3e7b8ff9fe556d5477"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc2Njk0Mw==", "bodyText": "I dropped this change as the fix is only targeting to a corner case for a small time window (~10ms). regionMap is being referenced in more than 100 places, it is hard to figure out every possible case.", "url": "https://github.com/apache/hbase/pull/1613#discussion_r418766943", "createdAt": "2020-05-01T22:40:06Z", "author": {"login": "huaxiangsun"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/assignment/AssignmentManager.java", "diffHunk": "@@ -1859,11 +1859,17 @@ public void markRegionAsMerged(final RegionInfo child, final ServerName serverNa\n       throws IOException {\n     final RegionStateNode node = regionStates.getOrCreateRegionStateNode(child);\n     node.setState(State.MERGED);\n+    regionStateStore.mergeRegions(child, mergeParents, serverName);\n+\n+    // The order of adding merge qualifers and deleting from regionStates is important.\n+    // hbck chore depends on these merge qualifers and regionStates to check if a region on FS\n+    // is an orphan. If deleting from regionStates first, then there is a small gap that\n+    // a region is not in regionStates and there is no merge qualifer for this region, it will be\n+    // reported as an orphan.\n     for (RegionInfo ri: mergeParents) {\n       regionStates.deleteRegion(ri);\n \n     }\n-    regionStateStore.mergeRegions(child, mergeParents, serverName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYxMzUxOA=="}, "originalCommit": {"oid": "2b53c068b9beeace2cdf2f3e7b8ff9fe556d5477"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDc3NTg2OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/client/HConnectionTestingUtility.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNjoxNTozMlrOGPOJ1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxOToyNDowMVrOGPTSSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYxMzcxNw==", "bodyText": "Empty javadoc like this provokes complaint by checkstyle. Just remove it.", "url": "https://github.com/apache/hbase/pull/1613#discussion_r418613717", "createdAt": "2020-05-01T16:15:32Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/client/HConnectionTestingUtility.java", "diffHunk": "@@ -39,12 +39,17 @@\n    * probably not what you want.\n    * @param conf configuration\n    * @return ConnectionImplementation object for <code>conf</code>\n-   * @throws ZooKeeperConnectionException\n+   * @throws IOException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b53c068b9beeace2cdf2f3e7b8ff9fe556d5477"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODY5NzgwMA==", "bodyText": "Will do.", "url": "https://github.com/apache/hbase/pull/1613#discussion_r418697800", "createdAt": "2020-05-01T19:24:01Z", "author": {"login": "huaxiangsun"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/client/HConnectionTestingUtility.java", "diffHunk": "@@ -39,12 +39,17 @@\n    * probably not what you want.\n    * @param conf configuration\n    * @return ConnectionImplementation object for <code>conf</code>\n-   * @throws ZooKeeperConnectionException\n+   * @throws IOException", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYxMzcxNw=="}, "originalCommit": {"oid": "2b53c068b9beeace2cdf2f3e7b8ff9fe556d5477"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1847, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}