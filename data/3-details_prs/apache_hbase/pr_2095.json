{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUxOTY0NTg4", "number": 2095, "title": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocato\u2026", "bodyText": "\u2026r to ConnectionRegistry", "createdAt": "2020-07-18T14:37:41Z", "url": "https://github.com/apache/hbase/pull/2095", "merged": true, "mergeCommit": {"oid": "ee7264206cfa5fe0373d15b4f9e4d5259b5a6ab7"}, "closed": true, "closedAt": "2020-08-25T13:14:29Z", "author": {"login": "Apache9"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc2dJBxABqjM1NjI1ODkyNTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdA_3uJgBqjM2Nzg0Mzg5OTk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6bfa715329e4b56eb795cac9e1b9f5b60a242c3f", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/6bfa715329e4b56eb795cac9e1b9f5b60a242c3f", "committedDate": "2020-07-18T14:27:02Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}, "afterCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/7099bdd8a6344d2c0d9a6f9013b08108257096ca", "committedDate": "2020-07-19T13:34:20Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMTQ3ODYw", "url": "https://github.com/apache/hbase/pull/2095#pullrequestreview-451147860", "createdAt": "2020-07-19T17:05:50Z", "commit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxNzowNTo1MFrOGzw5hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxODo0ODo0NlrOGzxgfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzMTcxNw==", "bodyText": "By any chance, subsequent execution with error can produce NPE here? e.g first thread encounters error, sets futureRef to null and second one when calls completeExceptionally(), it calls it on null?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456931717", "createdAt": "2020-07-19T17:05:50Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -652,4 +626,160 @@ static void setCoprocessorError(RpcController controller, Throwable error) {\n       controller.setFailed(error.toString());\n     }\n   }\n+\n+  public static RegionLocations locateRow(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    Map.Entry<byte[], RegionLocations> entry = cache.floorEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    byte[] endKey = loc.getRegion().getEndKey();\n+    if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.CURRENT, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static RegionLocations locateRowBefore(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    boolean isEmptyStopRow = isEmptyStopRow(row);\n+    Map.Entry<byte[], RegionLocations> entry =\n+      isEmptyStopRow ? cache.lastEntry() : cache.lowerEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n+      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static void tryClearMasterStubCache(IOException error,\n+    ClientMetaService.Interface currentStub, AtomicReference<ClientMetaService.Interface> stub) {\n+    if (ClientExceptionsUtil.isConnectionException(error) ||\n+      error instanceof ServerNotRunningYetException) {\n+      stub.compareAndSet(currentStub, null);\n+    }\n+  }\n+\n+  public static <T> CompletableFuture<T> getMasterStub(ConnectionRegistry registry,\n+    AtomicReference<T> stub, AtomicReference<CompletableFuture<T>> stubMakeFuture,\n+    RpcClient rpcClient, User user, long rpcTimeout, TimeUnit unit,\n+    Function<RpcChannel, T> stubMaker, String type) {\n+    return getOrFetch(stub, stubMakeFuture, () -> {\n+      CompletableFuture<T> future = new CompletableFuture<>();\n+      addListener(registry.getActiveMaster(), (addr, error) -> {\n+        if (error != null) {\n+          future.completeExceptionally(error);\n+        } else if (addr == null) {\n+          future.completeExceptionally(new MasterNotRunningException(\n+            \"ZooKeeper available but no active master location found\"));\n+        } else {\n+          LOG.debug(\"The fetched master address is {}\", addr);\n+          try {\n+            future.complete(stubMaker.apply(\n+              rpcClient.createRpcChannel(addr, user, toIntNoOverflow(unit.toMillis(rpcTimeout)))));\n+          } catch (IOException e) {\n+            future.completeExceptionally(e);\n+          }\n+        }\n+\n+      });\n+      return future;\n+    }, type);\n+  }\n+\n+  private static <T> CompletableFuture<T> getOrFetch(AtomicReference<T> cacheRef,\n+    AtomicReference<CompletableFuture<T>> futureRef, \n+    Supplier<CompletableFuture<T>> fetch, String type) {\n+    for (;;) {\n+      T cachedValue = cacheRef.get();\n+      if (cachedValue != null) {\n+        return CompletableFuture.completedFuture(cachedValue);\n+      }\n+      LOG.trace(\"{} cache is null, try fetching from registry\", type);\n+      if (futureRef.compareAndSet(null, new CompletableFuture<>())) {\n+        LOG.debug(\"Start fetching {} from registry\", type);\n+        CompletableFuture<T> future = futureRef.get();\n+        addListener(fetch.get(), (value, error) -> {\n+          if (error != null) {\n+            LOG.debug(\"Failed to fetch {} from registry\", type, error);\n+            futureRef.getAndSet(null).completeExceptionally(error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzMjk0NQ==", "bodyText": "nit: Since we have multiple Interface in MasterProtos, would you prefer providing ClientMetaService.Interface for better readability? i.e AtomicReference<ClientMetaService.Interface> and AtomicReference<CompletableFuture<ClientMetaService.Interface>>\nNo strong opinion though.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456932945", "createdAt": "2020-07-19T17:19:03Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ZKConnectionRegistry.java", "diffHunk": "@@ -59,9 +74,29 @@\n \n   private final ZNodePaths znodePaths;\n \n-  ZKConnectionRegistry(Configuration conf) {\n+  private final AtomicReference<Interface> stub = new AtomicReference<>();\n+\n+  private final AtomicReference<CompletableFuture<Interface>> stubMakeFuture =\n+    new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNTg5MA==", "bodyText": "Similar to above methods, we can use generics here also:\n  public static <T extends ClientMetaService.Interface> CompletableFuture<List<HRegionLocation>> getAllMetaRegionLocations(\n    boolean excludeOfflinedSplitParents, CompletableFuture<T> getStubFuture,\n    AtomicReference<T> stubRef, RpcControllerFactory rpcControllerFactory, int callTimeoutMs) {\n\n&\n  public static<T extends ClientMetaService.Interface> void tryClearMasterStubCache(IOException error,\n    T currentStub, AtomicReference<T> stub) {\n\nBeing Utils class, this might suit well, thought?\nBut if you feel this is overkill, we are good without that change.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456935890", "createdAt": "2020-07-19T17:49:27Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -652,4 +626,160 @@ static void setCoprocessorError(RpcController controller, Throwable error) {\n       controller.setFailed(error.toString());\n     }\n   }\n+\n+  public static RegionLocations locateRow(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    Map.Entry<byte[], RegionLocations> entry = cache.floorEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    byte[] endKey = loc.getRegion().getEndKey();\n+    if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.CURRENT, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static RegionLocations locateRowBefore(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    boolean isEmptyStopRow = isEmptyStopRow(row);\n+    Map.Entry<byte[], RegionLocations> entry =\n+      isEmptyStopRow ? cache.lastEntry() : cache.lowerEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n+      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static void tryClearMasterStubCache(IOException error,\n+    ClientMetaService.Interface currentStub, AtomicReference<ClientMetaService.Interface> stub) {\n+    if (ClientExceptionsUtil.isConnectionException(error) ||\n+      error instanceof ServerNotRunningYetException) {\n+      stub.compareAndSet(currentStub, null);\n+    }\n+  }\n+\n+  public static <T> CompletableFuture<T> getMasterStub(ConnectionRegistry registry,\n+    AtomicReference<T> stub, AtomicReference<CompletableFuture<T>> stubMakeFuture,\n+    RpcClient rpcClient, User user, long rpcTimeout, TimeUnit unit,\n+    Function<RpcChannel, T> stubMaker, String type) {\n+    return getOrFetch(stub, stubMakeFuture, () -> {\n+      CompletableFuture<T> future = new CompletableFuture<>();\n+      addListener(registry.getActiveMaster(), (addr, error) -> {\n+        if (error != null) {\n+          future.completeExceptionally(error);\n+        } else if (addr == null) {\n+          future.completeExceptionally(new MasterNotRunningException(\n+            \"ZooKeeper available but no active master location found\"));\n+        } else {\n+          LOG.debug(\"The fetched master address is {}\", addr);\n+          try {\n+            future.complete(stubMaker.apply(\n+              rpcClient.createRpcChannel(addr, user, toIntNoOverflow(unit.toMillis(rpcTimeout)))));\n+          } catch (IOException e) {\n+            future.completeExceptionally(e);\n+          }\n+        }\n+\n+      });\n+      return future;\n+    }, type);\n+  }\n+\n+  private static <T> CompletableFuture<T> getOrFetch(AtomicReference<T> cacheRef,\n+    AtomicReference<CompletableFuture<T>> futureRef, \n+    Supplier<CompletableFuture<T>> fetch, String type) {\n+    for (;;) {\n+      T cachedValue = cacheRef.get();\n+      if (cachedValue != null) {\n+        return CompletableFuture.completedFuture(cachedValue);\n+      }\n+      LOG.trace(\"{} cache is null, try fetching from registry\", type);\n+      if (futureRef.compareAndSet(null, new CompletableFuture<>())) {\n+        LOG.debug(\"Start fetching {} from registry\", type);\n+        CompletableFuture<T> future = futureRef.get();\n+        addListener(fetch.get(), (value, error) -> {\n+          if (error != null) {\n+            LOG.debug(\"Failed to fetch {} from registry\", type, error);\n+            futureRef.getAndSet(null).completeExceptionally(error);\n+            return;\n+          }\n+          LOG.debug(\"The fetched {} is {}\", type, value);\n+          // Here we update cache before reset future, so it is possible that someone can get a\n+          // stale value. Consider this:\n+          // 1. update cacheRef\n+          // 2. someone clears the cache and relocates again\n+          // 3. the futureRef is not null so the old future is used.\n+          // 4. we clear futureRef and complete the future in it with the value being\n+          // cleared in step 2.\n+          // But we do not think it is a big deal as it rarely happens, and even if it happens, the\n+          // caller will retry again later, no correctness problems.\n+          cacheRef.set(value);\n+          futureRef.set(null);\n+          future.complete(value);\n+        });\n+        return future;\n+      } else {\n+        CompletableFuture<T> future = futureRef.get();\n+        if (future != null) {\n+          return future;\n+        }\n+      }\n+    }\n+  }\n+\n+  public static CompletableFuture<List<HRegionLocation>> getAllMetaRegionLocations(\n+    boolean excludeOfflinedSplitParents,\n+    CompletableFuture<ClientMetaService.Interface> getStubFuture,\n+    AtomicReference<ClientMetaService.Interface> stubRef,\n+    RpcControllerFactory rpcControllerFactory, int callTimeoutMs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 332}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNzQwNw==", "bodyText": "Since this is used for MasterService.Interface and ClientMetaService.Interface, we can call the method something generic? maybe just getStub()?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456937407", "createdAt": "2020-07-19T18:04:47Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -652,4 +626,160 @@ static void setCoprocessorError(RpcController controller, Throwable error) {\n       controller.setFailed(error.toString());\n     }\n   }\n+\n+  public static RegionLocations locateRow(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    Map.Entry<byte[], RegionLocations> entry = cache.floorEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    byte[] endKey = loc.getRegion().getEndKey();\n+    if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.CURRENT, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static RegionLocations locateRowBefore(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    boolean isEmptyStopRow = isEmptyStopRow(row);\n+    Map.Entry<byte[], RegionLocations> entry =\n+      isEmptyStopRow ? cache.lastEntry() : cache.lowerEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n+      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static void tryClearMasterStubCache(IOException error,\n+    ClientMetaService.Interface currentStub, AtomicReference<ClientMetaService.Interface> stub) {\n+    if (ClientExceptionsUtil.isConnectionException(error) ||\n+      error instanceof ServerNotRunningYetException) {\n+      stub.compareAndSet(currentStub, null);\n+    }\n+  }\n+\n+  public static <T> CompletableFuture<T> getMasterStub(ConnectionRegistry registry,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNzk2Mg==", "bodyText": "nit: IOException is redundant", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456937962", "createdAt": "2020-07-19T18:10:00Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -2318,19 +2333,17 @@ public long createSystemTable(final TableDescriptor tableDescriptor) throws IOEx\n     return procId;\n   }\n \n-  private void startActiveMasterManager(int infoPort) throws KeeperException {\n+  private void startActiveMasterManager(int infoPort) throws KeeperException, IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzOTIzMg==", "bodyText": "Yes, this seems better, hopefully with not too much of perf impact when MasterRpcServices access it.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456939232", "createdAt": "2020-07-19T18:22:31Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -376,12 +376,11 @@ public void run() {\n   // manager of assignment nodes in zookeeper\n   private AssignmentManager assignmentManager;\n \n-\n   /**\n    * Cache for the meta region replica's locations. Also tracks their changes to avoid stale\n    * cache entries.\n    */\n-  private final MetaRegionLocationCache metaRegionLocationCache;\n+  private volatile MetaLocationCache metaLocationCache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzOTU0Nw==", "bodyText": "nit: replace with lambda?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456939547", "createdAt": "2020-07-19T18:25:43Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -634,6 +631,27 @@ protected String getUseThisHostnameInstead(Configuration conf) {\n   @Override\n   public void run() {\n     try {\n+      // we have to do this in a background thread as for a fresh new cluster, we need to become\n+      // active master first to set the cluster id so we can initialize the cluster connection.\n+      // for backup master, we need to use async cluster connection to connect to active master for\n+      // fetching the content of root table, to serve the locate meta requests from client.\n+      Threads.setDaemonThreadRunning(new Thread() {\n+\n+        @Override\n+        public void run() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzOTY4NA==", "bodyText": "For else part, maybe we can have trace log?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456939684", "createdAt": "2020-07-19T18:27:14Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -634,6 +631,27 @@ protected String getUseThisHostnameInstead(Configuration conf) {\n   @Override\n   public void run() {\n     try {\n+      // we have to do this in a background thread as for a fresh new cluster, we need to become\n+      // active master first to set the cluster id so we can initialize the cluster connection.\n+      // for backup master, we need to use async cluster connection to connect to active master for\n+      // fetching the content of root table, to serve the locate meta requests from client.\n+      Threads.setDaemonThreadRunning(new Thread() {\n+\n+        @Override\n+        public void run() {\n+          for (;;) {\n+            try {\n+              if (!Strings.isNullOrEmpty(ZKClusterId.readClusterIdZNode(zooKeeper))) {\n+                setupClusterConnection();\n+                break;\n+              }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MDUyMw==", "bodyText": "This method getMetaRegionLocations() is no longer being called from MasterRegistry.\nMasterRegistry.getMetaRegionLocations() is not in use:\n  public CompletableFuture<RegionLocations> getMetaRegionLocations()\n\nOther rpc calls i.e locateMetaRegion()  &  getAllMetaRegionLocations() are in use.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456940523", "createdAt": "2020-07-19T18:36:11Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -3276,11 +3290,16 @@ public LocateMetaRegionResponse locateMetaRegion(RpcController controller,\n     byte[] row = request.getRow().toByteArray();\n     RegionLocateType locateType = ProtobufUtil.toRegionLocateType(request.getLocateType());\n     try {\n-      master.checkServiceStarted();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MTUxNg==", "bodyText": "We are never expecting null cache for backup masters right?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456941516", "createdAt": "2020-07-19T18:46:23Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -3305,24 +3324,31 @@ public GetAllMetaRegionLocationsResponse getAllMetaRegionLocations(RpcController\n     GetAllMetaRegionLocationsRequest request) throws ServiceException {\n     boolean excludeOfflinedSplitParents = request.getExcludeOfflinedSplitParents();\n     try {\n-      master.checkServiceStarted();\n       if (master.getMasterCoprocessorHost() != null) {\n         master.getMasterCoprocessorHost().preGetAllMetaRegionLocations(excludeOfflinedSplitParents);\n       }\n-      List<RegionLocations> locs = master.getAllMetaRegionLocations(excludeOfflinedSplitParents);\n-      List<HRegionLocation> list = new ArrayList<>();\n-      GetAllMetaRegionLocationsResponse.Builder builder =\n-        GetAllMetaRegionLocationsResponse.newBuilder();\n-      if (locs != null) {\n-        for (RegionLocations ls : locs) {\n-          for (HRegionLocation loc : ls) {\n-            if (loc != null) {\n-              builder.addMetaLocations(ProtobufUtil.toRegionLocation(loc));\n-              list.add(loc);\n+      MetaLocationCache cache = master.getMetaLocationCache();\n+      List<HRegionLocation> list;\n+      if (cache != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MTY5NA==", "bodyText": "nit: holder = new CacheHolder(locs)", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456941694", "createdAt": "2020-07-19T18:48:46Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));\n+    }\n+  }\n+\n+  private volatile CacheHolder holder;\n+\n+  private volatile boolean stopped = false;\n+\n+  MetaLocationCache(MasterServices master) {\n+    int syncIntervalSeconds =\n+      master.getConfiguration().getInt(SYNC_INTERVAL_SECONDS, DEFAULT_SYNC_INTERVAL_SECONDS);\n+    int fetchTimeoutMs =\n+      master.getConfiguration().getInt(FETCH_TIMEOUT_MS, DEFAULT_FETCH_TIMEOUT_MS);\n+    master.getChoreService().scheduleChore(new ScheduledChore(\n+      getClass().getSimpleName() + \"-Sync-Chore\", this, syncIntervalSeconds, 0, TimeUnit.SECONDS) {\n+\n+      @Override\n+      protected void chore() {\n+        AsyncClusterConnection conn = master.getAsyncClusterConnection();\n+        if (conn != null) {\n+          addListener(conn.getAllMetaRegionLocations(fetchTimeoutMs), (locs, error) -> {\n+            if (error != null) {\n+              LOG.warn(\"Failed to fetch all meta region locations from active master\", error);\n+              return;\n+            }\n+            CacheHolder ch = new CacheHolder(locs);\n+            holder = ch;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxMTc3MTU4", "url": "https://github.com/apache/hbase/pull/2095#pullrequestreview-451177158", "createdAt": "2020-07-20T00:13:06Z", "commit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMDoxMzowNlrOGzzecw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMToxMzo1OVrOGzz-jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3MzkzOQ==", "bodyText": "I think you can also remove MetaRegionLocationCache implementation..", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456973939", "createdAt": "2020-07-20T00:13:06Z", "author": {"login": "bharathv"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMetaRegionLocationCache.java", "diffHunk": "@@ -1,191 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hadoop.hbase.client;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import org.apache.hadoop.conf.Configuration;\n-import org.apache.hadoop.hbase.HBaseClassTestRule;\n-import org.apache.hadoop.hbase.HBaseTestingUtility;\n-import org.apache.hadoop.hbase.HConstants;\n-import org.apache.hadoop.hbase.HRegionLocation;\n-import org.apache.hadoop.hbase.MultithreadedTestUtil;\n-import org.apache.hadoop.hbase.ServerName;\n-import org.apache.hadoop.hbase.master.HMaster;\n-import org.apache.hadoop.hbase.master.MetaRegionLocationCache;\n-import org.apache.hadoop.hbase.master.RegionState;\n-import org.apache.hadoop.hbase.testclassification.MasterTests;\n-import org.apache.hadoop.hbase.testclassification.SmallTests;\n-import org.apache.hadoop.hbase.util.JVMClusterUtil;\n-import org.apache.hadoop.hbase.zookeeper.MetaTableLocator;\n-import org.apache.hadoop.hbase.zookeeper.ZKUtil;\n-import org.apache.hadoop.hbase.zookeeper.ZKWatcher;\n-import org.apache.hadoop.hbase.zookeeper.ZNodePaths;\n-import org.junit.AfterClass;\n-import org.junit.BeforeClass;\n-import org.junit.ClassRule;\n-import org.junit.Test;\n-import org.junit.experimental.categories.Category;\n-\n-import org.apache.hbase.thirdparty.com.google.common.io.Closeables;\n-\n-@Category({ SmallTests.class, MasterTests.class })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3NDkyMA==", "bodyText": "Should we consider merging the both the APIs to fetch meta locations into a single RPC call to keep this interface simple and clean? Right now it maps 1:1 to the requirements of RegionLocator API.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456974920", "createdAt": "2020-07-20T00:21:25Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionRegistry.java", "diffHunk": "@@ -18,21 +18,36 @@\n package org.apache.hadoop.hbase.client;\n \n import java.io.Closeable;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n import org.apache.hadoop.hbase.ServerName;\n import org.apache.yetus.audience.InterfaceAudience;\n \n /**\n  * Registry for meta information needed for connection setup to a HBase cluster. Implementations\n- * hold cluster information such as this cluster's id, location of hbase:meta, etc..\n- * Internal use only.\n+ * hold cluster information such as this cluster's id, location of hbase:meta, etc.. Internal use\n+ * only.\n  */\n @InterfaceAudience.Private\n interface ConnectionRegistry extends Closeable {\n \n+  /**\n+   * Get location of meta region for the given {@code row}.\n+   */\n+  CompletableFuture<RegionLocations> locateMeta(byte[] row, RegionLocateType locateType);\n+\n+  /**\n+   * Get all meta region locations, including the location of secondary regions.\n+   * @param excludeOfflinedSplitParents whether to include split parent.\n+   */\n+  CompletableFuture<List<HRegionLocation>>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3ODM5NA==", "bodyText": "rpcClient.close()?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456978394", "createdAt": "2020-07-20T00:48:23Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ZKConnectionRegistry.java", "diffHunk": "@@ -229,6 +264,45 @@ private void getMetaRegionLocation(CompletableFuture<RegionLocations> future,\n       });\n   }\n \n+  private CompletableFuture<Interface> getStub() {\n+    return ConnectionUtils.getMasterStub(this, stub, stubMakeFuture, rpcClient, user,\n+      readRpcTimeoutNs, TimeUnit.NANOSECONDS, ClientMetaService::newStub, \"ClientMetaService\");\n+  }\n+\n+  @Override\n+  public CompletableFuture<RegionLocations> locateMeta(byte[] row, RegionLocateType locateType) {\n+    CompletableFuture<RegionLocations> future = new CompletableFuture<>();\n+    addListener(getStub(), (stub, error) -> {\n+      if (error != null) {\n+        future.completeExceptionally(error);\n+        return;\n+      }\n+      HBaseRpcController controller = rpcControllerFactory.newController();\n+      stub.locateMetaRegion(controller,\n+        LocateMetaRegionRequest.newBuilder().setRow(ByteString.copyFrom(row))\n+          .setLocateType(ProtobufUtil.toProtoRegionLocateType(locateType)).build(),\n+        resp -> {\n+          if (controller.failed()) {\n+            IOException ex = controller.getFailed();\n+            ConnectionUtils.tryClearMasterStubCache(ex, stub, ZKConnectionRegistry.this.stub);\n+            future.completeExceptionally(ex);\n+            return;\n+          }\n+          RegionLocations locs = new RegionLocations(resp.getMetaLocationsList().stream()\n+            .map(ProtobufUtil::toRegionLocation).collect(Collectors.toList()));\n+          future.complete(locs);\n+        });\n+    });\n+    return future;\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<HRegionLocation>>\n+    getAllMetaRegionLocations(boolean excludeOfflinedSplitParents) {\n+    return ConnectionUtils.getAllMetaRegionLocations(excludeOfflinedSplitParents, getStub(), stub,\n+      rpcControllerFactory, -1);\n+  }\n+\n   @Override\n   public void close() {\n     zk.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3ODc1OA==", "bodyText": "nit: call it cachedStub or something?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456978758", "createdAt": "2020-07-20T00:50:48Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ZKConnectionRegistry.java", "diffHunk": "@@ -59,9 +74,29 @@\n \n   private final ZNodePaths znodePaths;\n \n-  ZKConnectionRegistry(Configuration conf) {\n+  private final AtomicReference<Interface> stub = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3OTEwOQ==", "bodyText": "I liked @saintstack's idea in the design doc where we can ask active master for the list of available masters and load balance the RPCs. I think that can be used both here (to randomize the master we are talking to) and in master registry to always maintain a fresh list of masters and only use the initial list of masters a seed input.\n(I can quickly add that feature if everyone is okay with it).", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456979109", "createdAt": "2020-07-20T00:53:22Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -652,4 +626,160 @@ static void setCoprocessorError(RpcController controller, Throwable error) {\n       controller.setFailed(error.toString());\n     }\n   }\n+\n+  public static RegionLocations locateRow(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    Map.Entry<byte[], RegionLocations> entry = cache.floorEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    byte[] endKey = loc.getRegion().getEndKey();\n+    if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.CURRENT, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static RegionLocations locateRowBefore(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    boolean isEmptyStopRow = isEmptyStopRow(row);\n+    Map.Entry<byte[], RegionLocations> entry =\n+      isEmptyStopRow ? cache.lastEntry() : cache.lowerEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n+      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static void tryClearMasterStubCache(IOException error,\n+    ClientMetaService.Interface currentStub, AtomicReference<ClientMetaService.Interface> stub) {\n+    if (ClientExceptionsUtil.isConnectionException(error) ||\n+      error instanceof ServerNotRunningYetException) {\n+      stub.compareAndSet(currentStub, null);\n+    }\n+  }\n+\n+  public static <T> CompletableFuture<T> getMasterStub(ConnectionRegistry registry,\n+    AtomicReference<T> stub, AtomicReference<CompletableFuture<T>> stubMakeFuture,\n+    RpcClient rpcClient, User user, long rpcTimeout, TimeUnit unit,\n+    Function<RpcChannel, T> stubMaker, String type) {\n+    return getOrFetch(stub, stubMakeFuture, () -> {\n+      CompletableFuture<T> future = new CompletableFuture<>();\n+      addListener(registry.getActiveMaster(), (addr, error) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTAzMw==", "bodyText": "Why do we need the else part? It looks like the cache runs on all masters ?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456981033", "createdAt": "2020-07-20T01:06:36Z", "author": {"login": "bharathv"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2928,13 +2928,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n \n   @Override\n   public GetMetaRegionLocationsResponse getMetaRegionLocations(RpcController rpcController,\n-      GetMetaRegionLocationsRequest request) throws ServiceException {\n-    GetMetaRegionLocationsResponse.Builder response = GetMetaRegionLocationsResponse.newBuilder();\n-    Optional<List<HRegionLocation>> metaLocations =\n-        master.getMetaRegionLocationCache().getMetaRegionLocations();\n-    metaLocations.ifPresent(hRegionLocations -> hRegionLocations.forEach(\n-      location -> response.addMetaLocations(ProtobufUtil.toRegionLocation(location))));\n-    return response.build();\n+    GetMetaRegionLocationsRequest request) throws ServiceException {\n+    MetaLocationCache cache = master.getMetaLocationCache();\n+    RegionLocations locs;\n+    try {\n+      if (cache != null) {\n+        locs = cache.locateMeta(HConstants.EMPTY_BYTE_ARRAY, RegionLocateType.CURRENT);\n+      } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTY4NQ==", "bodyText": "I believe thats for thread-safety of holder", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456981685", "createdAt": "2020-07-20T01:10:50Z", "author": {"login": "bharathv"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));\n+    }\n+  }\n+\n+  private volatile CacheHolder holder;\n+\n+  private volatile boolean stopped = false;\n+\n+  MetaLocationCache(MasterServices master) {\n+    int syncIntervalSeconds =\n+      master.getConfiguration().getInt(SYNC_INTERVAL_SECONDS, DEFAULT_SYNC_INTERVAL_SECONDS);\n+    int fetchTimeoutMs =\n+      master.getConfiguration().getInt(FETCH_TIMEOUT_MS, DEFAULT_FETCH_TIMEOUT_MS);\n+    master.getChoreService().scheduleChore(new ScheduledChore(\n+      getClass().getSimpleName() + \"-Sync-Chore\", this, syncIntervalSeconds, 0, TimeUnit.SECONDS) {\n+\n+      @Override\n+      protected void chore() {\n+        AsyncClusterConnection conn = master.getAsyncClusterConnection();\n+        if (conn != null) {\n+          addListener(conn.getAllMetaRegionLocations(fetchTimeoutMs), (locs, error) -> {\n+            if (error != null) {\n+              LOG.warn(\"Failed to fetch all meta region locations from active master\", error);\n+              return;\n+            }\n+            CacheHolder ch = new CacheHolder(locs);\n+            holder = ch;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MTY5NA=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTgyOQ==", "bodyText": "nit: conn reference can be cached once", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456981829", "createdAt": "2020-07-20T01:11:45Z", "author": {"login": "bharathv"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));\n+    }\n+  }\n+\n+  private volatile CacheHolder holder;\n+\n+  private volatile boolean stopped = false;\n+\n+  MetaLocationCache(MasterServices master) {\n+    int syncIntervalSeconds =\n+      master.getConfiguration().getInt(SYNC_INTERVAL_SECONDS, DEFAULT_SYNC_INTERVAL_SECONDS);\n+    int fetchTimeoutMs =\n+      master.getConfiguration().getInt(FETCH_TIMEOUT_MS, DEFAULT_FETCH_TIMEOUT_MS);\n+    master.getChoreService().scheduleChore(new ScheduledChore(\n+      getClass().getSimpleName() + \"-Sync-Chore\", this, syncIntervalSeconds, 0, TimeUnit.SECONDS) {\n+\n+      @Override\n+      protected void chore() {\n+        AsyncClusterConnection conn = master.getAsyncClusterConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MjE1OQ==", "bodyText": "We need any tests to test sync / timeout etc of this cache?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456982159", "createdAt": "2020-07-20T01:13:59Z", "author": {"login": "bharathv"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 53}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/7099bdd8a6344d2c0d9a6f9013b08108257096ca", "committedDate": "2020-07-19T13:34:20Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}, "afterCommit": {"oid": "a79b4ffc658b9475796ac229dd249840be7dc825", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/a79b4ffc658b9475796ac229dd249840be7dc825", "committedDate": "2020-07-20T05:46:36Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a79b4ffc658b9475796ac229dd249840be7dc825", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/a79b4ffc658b9475796ac229dd249840be7dc825", "committedDate": "2020-07-20T05:46:36Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}, "afterCommit": {"oid": "488a9b7e92a5db536f2287a19b17f2f38dbf1d77", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/488a9b7e92a5db536f2287a19b17f2f38dbf1d77", "committedDate": "2020-07-20T06:16:17Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9e3f6b8ca1231e9d702da607d9775a3e58bea033", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/9e3f6b8ca1231e9d702da607d9775a3e58bea033", "committedDate": "2020-07-20T10:47:32Z", "message": "add UT for MetaLocationCache"}, "afterCommit": {"oid": "6c7fd65482301a1bc6c4890b74633d18a365b9b2", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/6c7fd65482301a1bc6c4890b74633d18a365b9b2", "committedDate": "2020-07-20T14:09:48Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6c7fd65482301a1bc6c4890b74633d18a365b9b2", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/6c7fd65482301a1bc6c4890b74633d18a365b9b2", "committedDate": "2020-07-20T14:09:48Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}, "afterCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/4e0cd933d7c2b619b34a75bdc196d5be47fe2184", "committedDate": "2020-07-20T14:16:34Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUxNjIyODU3", "url": "https://github.com/apache/hbase/pull/2095#pullrequestreview-451622857", "createdAt": "2020-07-20T13:49:03Z", "commit": {"oid": "9e3f6b8ca1231e9d702da607d9775a3e58bea033"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMzo0OTowM1rOG0NjTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNDozOTo0NlrOG0Qdaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQwMTE2NA==", "bodyText": "nit: final ?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457401164", "createdAt": "2020-07-20T13:49:03Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfoBuilder;\n+import org.apache.hadoop.hbase.testclassification.MasterTests;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.apache.hadoop.hbase.util.FutureUtils;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category({ MasterTests.class, MediumTests.class })\n+public class TestMetaLocationCache {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule CLASS_RULE =\n+    HBaseClassTestRule.forClass(TestMetaFixerNoCluster.class);\n+\n+  private static Configuration CONF = HBaseConfiguration.create();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e3f6b8ca1231e9d702da607d9775a3e58bea033"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQyNjc1Nw==", "bodyText": "typo: TestMetaLocationCache", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457426757", "createdAt": "2020-07-20T14:16:40Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionInfoBuilder;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.testclassification.MasterTests;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.FutureUtils;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category({ MasterTests.class, MediumTests.class })\n+public class TestMetaLocationCache {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule CLASS_RULE =\n+    HBaseClassTestRule.forClass(TestMetaFixerNoCluster.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c7fd65482301a1bc6c4890b74633d18a365b9b2"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQzMDcwMA==", "bodyText": "Since we are dealing with Mocks only, this can be SmallTests?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457430700", "createdAt": "2020-07-20T14:21:06Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionInfoBuilder;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.testclassification.MasterTests;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.FutureUtils;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category({ MasterTests.class, MediumTests.class })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQzMjg5MQ==", "bodyText": "nit: we can assign value right here and keep this static final", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457432891", "createdAt": "2020-07-20T14:23:17Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionInfoBuilder;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.testclassification.MasterTests;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.FutureUtils;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category({ MasterTests.class, MediumTests.class })\n+public class TestMetaLocationCache {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule CLASS_RULE =\n+    HBaseClassTestRule.forClass(TestMetaLocationCache.class);\n+\n+  private static Configuration CONF = HBaseConfiguration.create();\n+\n+  private static ChoreService CHORE_SERVICE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQzMzEyNw==", "bodyText": "nit: final", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457433127", "createdAt": "2020-07-20T14:23:32Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionInfoBuilder;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.testclassification.MasterTests;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.FutureUtils;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category({ MasterTests.class, MediumTests.class })\n+public class TestMetaLocationCache {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule CLASS_RULE =\n+    HBaseClassTestRule.forClass(TestMetaLocationCache.class);\n+\n+  private static Configuration CONF = HBaseConfiguration.create();\n+\n+  private static ChoreService CHORE_SERVICE;\n+\n+  private static byte[] SPLIT = Bytes.toBytes(\"a\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ0ODgxMQ==", "bodyText": "LOG.error might fit well? Also, what if this chore keeps getting error multiple times? That could mean due to some issue with RPC call, backup masters will serve stale data? Should we rather make this a high priority issue and stop backup masters if we get error say 30-60 times in a consecutive manner?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457448811", "createdAt": "2020-07-20T14:39:46Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));\n+    }\n+  }\n+\n+  private volatile CacheHolder holder;\n+\n+  private volatile boolean stopped = false;\n+\n+  MetaLocationCache(MasterServices master) {\n+    int syncIntervalSeconds =\n+      master.getConfiguration().getInt(SYNC_INTERVAL_SECONDS, DEFAULT_SYNC_INTERVAL_SECONDS);\n+    int fetchTimeoutMs =\n+      master.getConfiguration().getInt(FETCH_TIMEOUT_MS, DEFAULT_FETCH_TIMEOUT_MS);\n+    master.getChoreService().scheduleChore(new ScheduledChore(\n+      getClass().getSimpleName() + \"-Sync-Chore\", this, syncIntervalSeconds, 0, TimeUnit.SECONDS) {\n+\n+      @Override\n+      protected void chore() {\n+        AsyncClusterConnection conn = master.getAsyncClusterConnection();\n+        if (conn != null) {\n+          addListener(conn.getAllMetaRegionLocations(fetchTimeoutMs), (locs, error) -> {\n+            if (error != null) {\n+              LOG.warn(\"Failed to fetch all meta region locations from active master\", error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyMDM2Njc4", "url": "https://github.com/apache/hbase/pull/2095#pullrequestreview-452036678", "createdAt": "2020-07-20T23:59:12Z", "commit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMzo1OToxM1rOG0jRvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQyMzo1OToxM1rOG0jRvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc1NzExNg==", "bodyText": "Ah got it, I missed that part in the first iteration, I think you could roll that logic into the cache to keep the lifecycle simple (since the cache already has access to the master and we can check if master.isActive()). That way all the callers only use the cache and we can avoid the logic in finishMasterInitialization logic.\nAlso as discussed in the design doc, would be nice to have an actual versioned cache that avoids round trips if nothing changes (for the future). The 1s pull seems a bit aggressive but is fine as a stop-gap I guess.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457757116", "createdAt": "2020-07-20T23:59:13Z", "author": {"login": "bharathv"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2928,13 +2928,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n \n   @Override\n   public GetMetaRegionLocationsResponse getMetaRegionLocations(RpcController rpcController,\n-      GetMetaRegionLocationsRequest request) throws ServiceException {\n-    GetMetaRegionLocationsResponse.Builder response = GetMetaRegionLocationsResponse.newBuilder();\n-    Optional<List<HRegionLocation>> metaLocations =\n-        master.getMetaRegionLocationCache().getMetaRegionLocations();\n-    metaLocations.ifPresent(hRegionLocations -> hRegionLocations.forEach(\n-      location -> response.addMetaLocations(ProtobufUtil.toRegionLocation(location))));\n-    return response.build();\n+    GetMetaRegionLocationsRequest request) throws ServiceException {\n+    MetaLocationCache cache = master.getMetaLocationCache();\n+    RegionLocations locs;\n+    try {\n+      if (cache != null) {\n+        locs = cache.locateMeta(HConstants.EMPTY_BYTE_ARRAY, RegionLocateType.CURRENT);\n+      } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTAzMw=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyMTE1NjM2", "url": "https://github.com/apache/hbase/pull/2095#pullrequestreview-452115636", "createdAt": "2020-07-21T04:20:49Z", "commit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNDoyMDo0OVrOG0njCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNDoyMzozOVrOG0nl4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNzA4Mg==", "bodyText": "Sure, MediumTests is fine since we have sleep.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457827082", "createdAt": "2020-07-21T04:20:49Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionInfoBuilder;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.testclassification.MasterTests;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.FutureUtils;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category({ MasterTests.class, MediumTests.class })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQzMDcwMA=="}, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNzgxMQ==", "bodyText": "Sure, we can take it up on follow-up Jira.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457827811", "createdAt": "2020-07-21T04:23:39Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));\n+    }\n+  }\n+\n+  private volatile CacheHolder holder;\n+\n+  private volatile boolean stopped = false;\n+\n+  MetaLocationCache(MasterServices master) {\n+    int syncIntervalSeconds =\n+      master.getConfiguration().getInt(SYNC_INTERVAL_SECONDS, DEFAULT_SYNC_INTERVAL_SECONDS);\n+    int fetchTimeoutMs =\n+      master.getConfiguration().getInt(FETCH_TIMEOUT_MS, DEFAULT_FETCH_TIMEOUT_MS);\n+    master.getChoreService().scheduleChore(new ScheduledChore(\n+      getClass().getSimpleName() + \"-Sync-Chore\", this, syncIntervalSeconds, 0, TimeUnit.SECONDS) {\n+\n+      @Override\n+      protected void chore() {\n+        AsyncClusterConnection conn = master.getAsyncClusterConnection();\n+        if (conn != null) {\n+          addListener(conn.getAllMetaRegionLocations(fetchTimeoutMs), (locs, error) -> {\n+            if (error != null) {\n+              LOG.warn(\"Failed to fetch all meta region locations from active master\", error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ0ODgxMQ=="}, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNjI5Mjc5", "url": "https://github.com/apache/hbase/pull/2095#pullrequestreview-452629279", "createdAt": "2020-07-21T16:27:44Z", "commit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjoyNzo0NFrOG1AGxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjozODo0N1rOG1AiWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyOTQ0Nw==", "bodyText": "Seems arbitrary that we do ROOT location in here but location for hbase:meta is elsewhere and if they want to do 'caching'/'replicas', they'd use a different system.\nOr is idea that this cache of location be generalized? Or for ROOT only?\nImplementations could get RS stubs I suppose so don't have to go to Master to get meta Locations?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r458229447", "createdAt": "2020-07-21T16:27:44Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionRegistry.java", "diffHunk": "@@ -18,21 +18,36 @@\n package org.apache.hadoop.hbase.client;\n \n import java.io.Closeable;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n import org.apache.hadoop.hbase.ServerName;\n import org.apache.yetus.audience.InterfaceAudience;\n \n /**\n  * Registry for meta information needed for connection setup to a HBase cluster. Implementations\n- * hold cluster information such as this cluster's id, location of hbase:meta, etc..\n- * Internal use only.\n+ * hold cluster information such as this cluster's id, location of hbase:meta, etc.. Internal use\n+ * only.\n  */\n @InterfaceAudience.Private\n interface ConnectionRegistry extends Closeable {\n \n+  /**\n+   * Get location of meta region for the given {@code row}.\n+   */\n+  CompletableFuture<RegionLocations> locateMeta(byte[] row, RegionLocateType locateType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzNjUwNA==", "bodyText": "Yeah, noted previously that there is overlap with RegionLocator API. One bother is that RL is public. CR is not (though I think changing it after release will be troublesome..)", "url": "https://github.com/apache/hbase/pull/2095#discussion_r458236504", "createdAt": "2020-07-21T16:38:47Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionRegistry.java", "diffHunk": "@@ -18,21 +18,36 @@\n package org.apache.hadoop.hbase.client;\n \n import java.io.Closeable;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n import org.apache.hadoop.hbase.ServerName;\n import org.apache.yetus.audience.InterfaceAudience;\n \n /**\n  * Registry for meta information needed for connection setup to a HBase cluster. Implementations\n- * hold cluster information such as this cluster's id, location of hbase:meta, etc..\n- * Internal use only.\n+ * hold cluster information such as this cluster's id, location of hbase:meta, etc.. Internal use\n+ * only.\n  */\n @InterfaceAudience.Private\n interface ConnectionRegistry extends Closeable {\n \n+  /**\n+   * Get location of meta region for the given {@code row}.\n+   */\n+  CompletableFuture<RegionLocations> locateMeta(byte[] row, RegionLocateType locateType);\n+\n+  /**\n+   * Get all meta region locations, including the location of secondary regions.\n+   * @param excludeOfflinedSplitParents whether to include split parent.\n+   */\n+  CompletableFuture<List<HRegionLocation>>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3NDkyMA=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNzAyNTU1", "url": "https://github.com/apache/hbase/pull/2095#pullrequestreview-452702555", "createdAt": "2020-07-21T18:01:07Z", "commit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxODowMTowN1rOG1DqdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxODowMzozOVrOG1DwSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4NzczMg==", "bodyText": "Serving from NavigableMap should be faster than fetch from local Region? For this reason would we want to do like @bharathv  suggests (can be follow-on)", "url": "https://github.com/apache/hbase/pull/2095#discussion_r458287732", "createdAt": "2020-07-21T18:01:07Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2928,13 +2928,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n \n   @Override\n   public GetMetaRegionLocationsResponse getMetaRegionLocations(RpcController rpcController,\n-      GetMetaRegionLocationsRequest request) throws ServiceException {\n-    GetMetaRegionLocationsResponse.Builder response = GetMetaRegionLocationsResponse.newBuilder();\n-    Optional<List<HRegionLocation>> metaLocations =\n-        master.getMetaRegionLocationCache().getMetaRegionLocations();\n-    metaLocations.ifPresent(hRegionLocations -> hRegionLocations.forEach(\n-      location -> response.addMetaLocations(ProtobufUtil.toRegionLocation(location))));\n-    return response.build();\n+    GetMetaRegionLocationsRequest request) throws ServiceException {\n+    MetaLocationCache cache = master.getMetaLocationCache();\n+    RegionLocations locs;\n+    try {\n+      if (cache != null) {\n+        locs = cache.locateMeta(HConstants.EMPTY_BYTE_ARRAY, RegionLocateType.CURRENT);\n+      } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTAzMw=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4OTIyNA==", "bodyText": "Needs to be meta comparator?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r458289224", "createdAt": "2020-07-21T18:03:39Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 91}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/4e0cd933d7c2b619b34a75bdc196d5be47fe2184", "committedDate": "2020-07-20T14:16:34Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}, "afterCommit": {"oid": "46df66505ba0c783db24715da45aa3c388b02cf8", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/46df66505ba0c783db24715da45aa3c388b02cf8", "committedDate": "2020-07-23T09:23:46Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "46df66505ba0c783db24715da45aa3c388b02cf8", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/46df66505ba0c783db24715da45aa3c388b02cf8", "committedDate": "2020-07-23T09:23:46Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}, "afterCommit": {"oid": "137fd978b5658919741f18a7e8d0cd13d9112554", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/137fd978b5658919741f18a7e8d0cd13d9112554", "committedDate": "2020-08-07T02:25:39Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "137fd978b5658919741f18a7e8d0cd13d9112554", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/137fd978b5658919741f18a7e8d0cd13d9112554", "committedDate": "2020-08-07T02:25:39Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}, "afterCommit": {"oid": "0a2a69201431e38d27a9dc687089926352c6e1f5", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/0a2a69201431e38d27a9dc687089926352c6e1f5", "committedDate": "2020-08-09T14:17:37Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a2a69201431e38d27a9dc687089926352c6e1f5", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/0a2a69201431e38d27a9dc687089926352c6e1f5", "committedDate": "2020-08-09T14:17:37Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}, "afterCommit": {"oid": "4fa5c92070e510c1739df72d0bdce272ad0a67c7", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/4fa5c92070e510c1739df72d0bdce272ad0a67c7", "committedDate": "2020-08-12T02:31:28Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4fa5c92070e510c1739df72d0bdce272ad0a67c7", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/4fa5c92070e510c1739df72d0bdce272ad0a67c7", "committedDate": "2020-08-12T02:31:28Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}, "afterCommit": {"oid": "160b3759a2c8c20e228c577e0ebfff79933db789", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/160b3759a2c8c20e228c577e0ebfff79933db789", "committedDate": "2020-08-17T15:03:32Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "160b3759a2c8c20e228c577e0ebfff79933db789", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/160b3759a2c8c20e228c577e0ebfff79933db789", "committedDate": "2020-08-17T15:03:32Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}, "afterCommit": {"oid": "22ec1edc11f62826f8270c7900dc359e1cac6bc5", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/22ec1edc11f62826f8270c7900dc359e1cac6bc5", "committedDate": "2020-08-19T06:37:41Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "22ec1edc11f62826f8270c7900dc359e1cac6bc5", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/22ec1edc11f62826f8270c7900dc359e1cac6bc5", "committedDate": "2020-08-19T06:37:41Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}, "afterCommit": {"oid": "0e404e6441061abaad60b0097464bd4dff56f908", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/0e404e6441061abaad60b0097464bd4dff56f908", "committedDate": "2020-08-20T08:03:57Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e67cdc8c7008a41be2fc90437b2e9fea6eeadf3", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/8e67cdc8c7008a41be2fc90437b2e9fea6eeadf3", "committedDate": "2020-08-21T07:41:51Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0e404e6441061abaad60b0097464bd4dff56f908", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/0e404e6441061abaad60b0097464bd4dff56f908", "committedDate": "2020-08-20T08:03:57Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}, "afterCommit": {"oid": "8e67cdc8c7008a41be2fc90437b2e9fea6eeadf3", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/8e67cdc8c7008a41be2fc90437b2e9fea6eeadf3", "committedDate": "2020-08-21T07:41:51Z", "message": "HBASE-24459 Move the locateMeta logic from AsyncMetaRegionTableLocator to ConnectionRegistry"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4313, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}