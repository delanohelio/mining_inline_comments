{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1NjAyNDQ0", "number": 1818, "title": "HBASE-24456 : Create ImmutableScan and use it for CustomizedScanInfoBuilder", "bodyText": "", "createdAt": "2020-05-31T12:09:33Z", "url": "https://github.com/apache/hbase/pull/1818", "merged": true, "mergeCommit": {"oid": "61a7468df7412874d2fb492a8bab5d0d72ac6fcd"}, "closed": true, "closedAt": "2020-06-04T10:55:48Z", "author": {"login": "virajjasani"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcmqezqAH2gAyNDI1NjAyNDQ0OmQ5NWVjOGEyNjBiM2M0YzJmNWRlNjhkMjM1ZWU0MTcwYjU4ZDBkYzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcn6tseAFqTQyNDI2ODI2OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d95ec8a260b3c4c2f5de68d235ee4170b58d0dc4", "author": {"user": {"login": "virajjasani", "name": "Viraj Jasani"}}, "url": "https://github.com/apache/hbase/commit/d95ec8a260b3c4c2f5de68d235ee4170b58d0dc4", "committedDate": "2020-05-31T12:04:52Z", "message": "HBASE-24456 : Create ImmutableScan and use it for CustomizedScanInfoBuilder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb27ee6b2874f9048c66ae943e05b54080ac9fbb", "author": {"user": {"login": "virajjasani", "name": "Viraj Jasani"}}, "url": "https://github.com/apache/hbase/commit/bb27ee6b2874f9048c66ae943e05b54080ac9fbb", "committedDate": "2020-05-31T16:37:50Z", "message": "minor change"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNjgyMTQ3", "url": "https://github.com/apache/hbase/pull/1818#pullrequestreview-421682147", "createdAt": "2020-06-01T08:40:16Z", "commit": {"oid": "bb27ee6b2874f9048c66ae943e05b54080ac9fbb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwODo0MDoxN1rOGdDBMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwODo0NDoyNFrOGdDIhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMTM0Ng==", "bodyText": "Do we really want this to be public?", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433111346", "createdAt": "2020-06-01T08:40:17Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,477 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Public", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb27ee6b2874f9048c66ae943e05b54080ac9fbb"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMTk1NA==", "bodyText": "Is it necessary to return a ImmutableScan for this method?", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433111954", "createdAt": "2020-06-01T08:41:39Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,477 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Public\n+public final class ImmutableScan extends Scan {\n+\n+  /**\n+   * Create Immutable instance of Scan from given Scan object\n+   *\n+   * @param scan Copy all values from Scan\n+   * @throws IOException From parent constructor\n+   */\n+  public ImmutableScan(Scan scan) throws IOException {\n+    super(scan);\n+    super.setIsolationLevel(scan.getIsolationLevel());\n+    Map<byte[], NavigableSet<byte[]>> familyMap = scan.getFamilyMap();\n+    for (Map.Entry<byte[], NavigableSet<byte[]>> entry : familyMap.entrySet()) {\n+      byte[] family = entry.getKey();\n+      NavigableSet<byte[]> cols = entry.getValue();\n+      if (cols != null && cols.size() > 0) {\n+        for (byte[] col : cols) {\n+          super.addColumn(family, col);\n+        }\n+      } else {\n+        super.addFamily(family);\n+      }\n+    }\n+    for (Map.Entry<String, byte[]> attr : scan.getAttributesMap().entrySet()) {\n+      super.setAttribute(attr.getKey(), attr.getValue());\n+    }\n+    for (Map.Entry<byte[], TimeRange> entry : scan.getColumnFamilyTimeRange().entrySet()) {\n+      TimeRange tr = entry.getValue();\n+      super.setColumnFamilyTimeRange(entry.getKey(), tr.getMin(), tr.getMax());\n+    }\n+    super.setPriority(scan.getPriority());\n+  }\n+\n+  /**\n+   * Create Immutable instance of Scan from given Get object\n+   *\n+   * @param get Get to model Scan after\n+   */\n+  public ImmutableScan(Get get) {\n+    super(get);\n+    super.setIsolationLevel(get.getIsolationLevel());\n+    for (Map.Entry<String, byte[]> attr : get.getAttributesMap().entrySet()) {\n+      super.setAttribute(attr.getKey(), attr.getValue());\n+    }\n+    for (Map.Entry<byte[], TimeRange> entry : get.getColumnFamilyTimeRange().entrySet()) {\n+      TimeRange tr = entry.getValue();\n+      super.setColumnFamilyTimeRange(entry.getKey(), tr.getMin(), tr.getMax());\n+    }\n+    super.setPriority(get.getPriority());\n+  }\n+\n+  /**\n+   * Create a new Scan with a cursor. It only set the position information like start row key.\n+   * The others (like cfs, stop row, limit) should still be filled in by the user.\n+   * {@link Result#isCursor()}\n+   * {@link Result#getCursor()}\n+   * {@link Cursor}\n+   */\n+  public static Scan createScanFromCursor(Cursor cursor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb27ee6b2874f9048c66ae943e05b54080ac9fbb"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMjA3Mg==", "bodyText": "UnsupportedOperationException or IllegalStateException?", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433112072", "createdAt": "2020-06-01T08:41:56Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,477 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Public\n+public final class ImmutableScan extends Scan {\n+\n+  /**\n+   * Create Immutable instance of Scan from given Scan object\n+   *\n+   * @param scan Copy all values from Scan\n+   * @throws IOException From parent constructor\n+   */\n+  public ImmutableScan(Scan scan) throws IOException {\n+    super(scan);\n+    super.setIsolationLevel(scan.getIsolationLevel());\n+    Map<byte[], NavigableSet<byte[]>> familyMap = scan.getFamilyMap();\n+    for (Map.Entry<byte[], NavigableSet<byte[]>> entry : familyMap.entrySet()) {\n+      byte[] family = entry.getKey();\n+      NavigableSet<byte[]> cols = entry.getValue();\n+      if (cols != null && cols.size() > 0) {\n+        for (byte[] col : cols) {\n+          super.addColumn(family, col);\n+        }\n+      } else {\n+        super.addFamily(family);\n+      }\n+    }\n+    for (Map.Entry<String, byte[]> attr : scan.getAttributesMap().entrySet()) {\n+      super.setAttribute(attr.getKey(), attr.getValue());\n+    }\n+    for (Map.Entry<byte[], TimeRange> entry : scan.getColumnFamilyTimeRange().entrySet()) {\n+      TimeRange tr = entry.getValue();\n+      super.setColumnFamilyTimeRange(entry.getKey(), tr.getMin(), tr.getMax());\n+    }\n+    super.setPriority(scan.getPriority());\n+  }\n+\n+  /**\n+   * Create Immutable instance of Scan from given Get object\n+   *\n+   * @param get Get to model Scan after\n+   */\n+  public ImmutableScan(Get get) {\n+    super(get);\n+    super.setIsolationLevel(get.getIsolationLevel());\n+    for (Map.Entry<String, byte[]> attr : get.getAttributesMap().entrySet()) {\n+      super.setAttribute(attr.getKey(), attr.getValue());\n+    }\n+    for (Map.Entry<byte[], TimeRange> entry : get.getColumnFamilyTimeRange().entrySet()) {\n+      TimeRange tr = entry.getValue();\n+      super.setColumnFamilyTimeRange(entry.getKey(), tr.getMin(), tr.getMax());\n+    }\n+    super.setPriority(get.getPriority());\n+  }\n+\n+  /**\n+   * Create a new Scan with a cursor. It only set the position information like start row key.\n+   * The others (like cfs, stop row, limit) should still be filled in by the user.\n+   * {@link Result#isCursor()}\n+   * {@link Result#getCursor()}\n+   * {@link Cursor}\n+   */\n+  public static Scan createScanFromCursor(Cursor cursor) {\n+    Scan scan = new Scan().withStartRow(cursor.getRow());\n+    try {\n+      return new ImmutableScan(scan);\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"Scan should not throw IOException\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Scan addFamily(byte[] family) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to addFamily\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb27ee6b2874f9048c66ae943e05b54080ac9fbb"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMjI4NQ==", "bodyText": "Do not need to implement these methods?", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433112285", "createdAt": "2020-06-01T08:42:25Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,477 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Public\n+public final class ImmutableScan extends Scan {\n+\n+  /**\n+   * Create Immutable instance of Scan from given Scan object\n+   *\n+   * @param scan Copy all values from Scan\n+   * @throws IOException From parent constructor\n+   */\n+  public ImmutableScan(Scan scan) throws IOException {\n+    super(scan);\n+    super.setIsolationLevel(scan.getIsolationLevel());\n+    Map<byte[], NavigableSet<byte[]>> familyMap = scan.getFamilyMap();\n+    for (Map.Entry<byte[], NavigableSet<byte[]>> entry : familyMap.entrySet()) {\n+      byte[] family = entry.getKey();\n+      NavigableSet<byte[]> cols = entry.getValue();\n+      if (cols != null && cols.size() > 0) {\n+        for (byte[] col : cols) {\n+          super.addColumn(family, col);\n+        }\n+      } else {\n+        super.addFamily(family);\n+      }\n+    }\n+    for (Map.Entry<String, byte[]> attr : scan.getAttributesMap().entrySet()) {\n+      super.setAttribute(attr.getKey(), attr.getValue());\n+    }\n+    for (Map.Entry<byte[], TimeRange> entry : scan.getColumnFamilyTimeRange().entrySet()) {\n+      TimeRange tr = entry.getValue();\n+      super.setColumnFamilyTimeRange(entry.getKey(), tr.getMin(), tr.getMax());\n+    }\n+    super.setPriority(scan.getPriority());\n+  }\n+\n+  /**\n+   * Create Immutable instance of Scan from given Get object\n+   *\n+   * @param get Get to model Scan after\n+   */\n+  public ImmutableScan(Get get) {\n+    super(get);\n+    super.setIsolationLevel(get.getIsolationLevel());\n+    for (Map.Entry<String, byte[]> attr : get.getAttributesMap().entrySet()) {\n+      super.setAttribute(attr.getKey(), attr.getValue());\n+    }\n+    for (Map.Entry<byte[], TimeRange> entry : get.getColumnFamilyTimeRange().entrySet()) {\n+      TimeRange tr = entry.getValue();\n+      super.setColumnFamilyTimeRange(entry.getKey(), tr.getMin(), tr.getMax());\n+    }\n+    super.setPriority(get.getPriority());\n+  }\n+\n+  /**\n+   * Create a new Scan with a cursor. It only set the position information like start row key.\n+   * The others (like cfs, stop row, limit) should still be filled in by the user.\n+   * {@link Result#isCursor()}\n+   * {@link Result#getCursor()}\n+   * {@link Cursor}\n+   */\n+  public static Scan createScanFromCursor(Cursor cursor) {\n+    Scan scan = new Scan().withStartRow(cursor.getRow());\n+    try {\n+      return new ImmutableScan(scan);\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"Scan should not throw IOException\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Scan addFamily(byte[] family) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to addFamily\");\n+  }\n+\n+  @Override\n+  public Scan addColumn(byte[] family, byte[] qualifier) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to addColumn\");\n+  }\n+\n+  @Override\n+  public Scan setTimeRange(long minStamp, long maxStamp) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setTimeRange\");\n+  }\n+\n+  @Deprecated\n+  @Override\n+  public Scan setTimeStamp(long timestamp) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setTimeStamp\");\n+  }\n+\n+  @Override\n+  public Scan setTimestamp(long timestamp) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setTimestamp\");\n+  }\n+\n+  @Override\n+  public Scan setColumnFamilyTimeRange(byte[] cf, long minStamp, long maxStamp) {\n+    throw new IllegalStateException(\n+      \"ImmutableScan does not allow access to setColumnFamilyTimeRange\");\n+  }\n+\n+  @Override\n+  public Scan withStartRow(byte[] startRow) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to withStartRow\");\n+  }\n+\n+  @Override\n+  public Scan withStartRow(byte[] startRow, boolean inclusive) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to withStartRow\");\n+  }\n+\n+  @Override\n+  public Scan withStopRow(byte[] stopRow) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to withStopRow\");\n+  }\n+\n+  @Override\n+  public Scan withStopRow(byte[] stopRow, boolean inclusive) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to withStopRow\");\n+  }\n+\n+  @Override\n+  public Scan setRowPrefixFilter(byte[] rowPrefix) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setRowPrefixFilter\");\n+  }\n+\n+  @Override\n+  public Scan readAllVersions() {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to readAllVersions\");\n+  }\n+\n+  @Override\n+  public Scan readVersions(int versions) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to readVersions\");\n+  }\n+\n+  @Override\n+  public Scan setBatch(int batch) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setBatch\");\n+  }\n+\n+  @Override\n+  public Scan setMaxResultsPerColumnFamily(int limit) {\n+    throw new IllegalStateException(\n+      \"ImmutableScan does not allow access to setMaxResultsPerColumnFamily\");\n+  }\n+\n+  @Override\n+  public Scan setRowOffsetPerColumnFamily(int offset) {\n+    throw new IllegalStateException(\n+      \"ImmutableScan does not allow access to setRowOffsetPerColumnFamily\");\n+  }\n+\n+  @Override\n+  public Scan setCaching(int caching) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setCaching\");\n+  }\n+\n+  @Override\n+  public Scan setMaxResultSize(long maxResultSize) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setMaxResultSize\");\n+  }\n+\n+  @Override\n+  public Scan setFilter(Filter filter) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setFilter\");\n+  }\n+\n+  @Override\n+  public Scan setFamilyMap(Map<byte[], NavigableSet<byte[]>> familyMap) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setFamilyMap\");\n+  }\n+\n+  @Override\n+  public Scan setCacheBlocks(boolean cacheBlocks) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setCacheBlocks\");\n+  }\n+\n+  @Override\n+  public Scan setReversed(boolean reversed) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setReversed\");\n+  }\n+\n+  @Override\n+  public Scan setAllowPartialResults(final boolean allowPartialResults) {\n+    throw new IllegalStateException(\n+      \"ImmutableScan does not allow access to setAllowPartialResults\");\n+  }\n+\n+  @Override\n+  public Scan setLoadColumnFamiliesOnDemand(boolean value) {\n+    throw new IllegalStateException(\n+      \"ImmutableScan does not allow access to setLoadColumnFamiliesOnDemand\");\n+  }\n+\n+  @Override\n+  public Scan setRaw(boolean raw) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setRaw\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public Scan setSmall(boolean small) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setSmall\");\n+  }\n+\n+  @Override\n+  public Scan setAttribute(String name, byte[] value) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setAttribute\");\n+  }\n+\n+  @Override\n+  public Scan setId(String id) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setId\");\n+  }\n+\n+  @Override\n+  public Scan setAuthorizations(Authorizations authorizations) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setAuthorizations\");\n+  }\n+\n+  @Override\n+  public Scan setACL(Map<String, Permission> perms) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setACL\");\n+  }\n+\n+  @Override\n+  public Scan setACL(String user, Permission perms) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setACL\");\n+  }\n+\n+  @Override\n+  public Scan setConsistency(Consistency consistency) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setConsistency\");\n+  }\n+\n+  @Override\n+  public Scan setReplicaId(int Id) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setReplicaId\");\n+  }\n+\n+  @Override\n+  public Scan setIsolationLevel(IsolationLevel level) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setIsolationLevel\");\n+  }\n+\n+  @Override\n+  public Scan setPriority(int priority) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setPriority\");\n+  }\n+\n+  @Override\n+  public Scan setScanMetricsEnabled(final boolean enabled) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setScanMetricsEnabled\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public Scan setAsyncPrefetch(boolean asyncPrefetch) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setAsyncPrefetch\");\n+  }\n+\n+  @Override\n+  public Scan setLimit(int limit) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setLimit\");\n+  }\n+\n+  @Override\n+  public Scan setOneRowLimit() {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setOneRowLimit\");\n+  }\n+\n+  @Override\n+  public Scan setReadType(ReadType readType) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setReadType\");\n+  }\n+\n+  @Override\n+  Scan setMvccReadPoint(long mvccReadPoint) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setMvccReadPoint\");\n+  }\n+\n+  @Override\n+  Scan resetMvccReadPoint() {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to resetMvccReadPoint\");\n+  }\n+\n+  @Override\n+  public Scan setNeedCursorResult(boolean needCursorResult) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setNeedCursorResult\");\n+  }\n+\n+  @Override\n+  public long getMaxResultSize() {\n+    return super.getMaxResultSize();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb27ee6b2874f9048c66ae943e05b54080ac9fbb"}, "originalPosition": 328}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMjQ1Mw==", "bodyText": "Why?", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433112453", "createdAt": "2020-06-01T08:42:49Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/Query.java", "diffHunk": "@@ -164,7 +164,11 @@ public int getReplicaId() {\n    * @param level IsolationLevel for this query\n    */\n   public Query setIsolationLevel(IsolationLevel level) {\n-    setAttribute(ISOLATION_LEVEL, level.toBytes());\n+    if (this instanceof ImmutableScan) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb27ee6b2874f9048c66ae943e05b54080ac9fbb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMzIyMg==", "bodyText": "This is not a good practise... Cna we avoid this instanceof for testing a sub class in the parent class?", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433113222", "createdAt": "2020-06-01T08:44:24Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/Scan.java", "diffHunk": "@@ -200,35 +200,37 @@ public Scan(Scan scan) throws IOException {\n     filter = scan.getFilter(); // clone?\n     loadColumnFamiliesOnDemand = scan.getLoadColumnFamiliesOnDemandValue();\n     consistency = scan.getConsistency();\n-    this.setIsolationLevel(scan.getIsolationLevel());\n     reversed = scan.isReversed();\n     asyncPrefetch = scan.isAsyncPrefetch();\n     small = scan.isSmall();\n     allowPartialResults = scan.getAllowPartialResults();\n     tr = scan.getTimeRange(); // TimeRange is immutable\n-    Map<byte[], NavigableSet<byte[]>> fams = scan.getFamilyMap();\n-    for (Map.Entry<byte[],NavigableSet<byte[]>> entry : fams.entrySet()) {\n-      byte [] fam = entry.getKey();\n-      NavigableSet<byte[]> cols = entry.getValue();\n-      if (cols != null && cols.size() > 0) {\n-        for (byte[] col : cols) {\n-          addColumn(fam, col);\n+    if (!(this instanceof ImmutableScan)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb27ee6b2874f9048c66ae943e05b54080ac9fbb"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a178112456d4b0df504a1491b187fb606994727c", "author": {"user": {"login": "virajjasani", "name": "Viraj Jasani"}}, "url": "https://github.com/apache/hbase/commit/a178112456d4b0df504a1491b187fb606994727c", "committedDate": "2020-06-01T09:51:27Z", "message": "addressing review"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a075e17f2dcf128e11d05de2630249fc3048de49", "author": {"user": {"login": "virajjasani", "name": "Viraj Jasani"}}, "url": "https://github.com/apache/hbase/commit/a075e17f2dcf128e11d05de2630249fc3048de49", "committedDate": "2020-06-01T12:32:16Z", "message": "setter unsupported if object is initialized"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxODIyNzYx", "url": "https://github.com/apache/hbase/pull/1818#pullrequestreview-421822761", "createdAt": "2020-06-01T13:00:39Z", "commit": {"oid": "a075e17f2dcf128e11d05de2630249fc3048de49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMzowMDozOVrOGdJnCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxMzowMDozOVrOGdJnCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIxOTMzNg==", "bodyText": "This is used by tests only ?\nDo u want to create ImmutableScan over a new Scan()?  Or direct new ImmutableScan is enough?", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433219336", "createdAt": "2020-06-01T13:00:39Z", "author": {"login": "anoopsjohn"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/CustomizedScanInfoBuilder.java", "diffHunk": "@@ -42,13 +43,18 @@\n \n   public CustomizedScanInfoBuilder(ScanInfo scanInfo) {\n     this.scanInfo = scanInfo;\n-    this.scan = new Scan();\n+    try {\n+      this.scan = new ImmutableScan(new Scan());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a075e17f2dcf128e11d05de2630249fc3048de49"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "410fcff425f20786400cfd833a56af11eea6855d", "author": {"user": {"login": "virajjasani", "name": "Viraj Jasani"}}, "url": "https://github.com/apache/hbase/commit/410fcff425f20786400cfd833a56af11eea6855d", "committedDate": "2020-06-01T13:57:38Z", "message": "removing createScanFromCursor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93613b91b896d17dd16245e75a26e0a655e5aa99", "author": {"user": {"login": "virajjasani", "name": "Viraj Jasani"}}, "url": "https://github.com/apache/hbase/commit/93613b91b896d17dd16245e75a26e0a655e5aa99", "committedDate": "2020-06-02T10:32:01Z", "message": "review comment - add delegate Scan"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a1503b0435cb3a2675f0f85f51a721e7b18d0b2", "author": {"user": {"login": "virajjasani", "name": "Viraj Jasani"}}, "url": "https://github.com/apache/hbase/commit/1a1503b0435cb3a2675f0f85f51a721e7b18d0b2", "committedDate": "2020-06-02T10:38:16Z", "message": "testUnmodifiableSetters"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyODkwNjIy", "url": "https://github.com/apache/hbase/pull/1818#pullrequestreview-422890622", "createdAt": "2020-06-02T17:15:12Z", "commit": {"oid": "1a1503b0435cb3a2675f0f85f51a721e7b18d0b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNzoxNToxM1rOGd7w6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNzoxNToxM1rOGd7w6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MTA2Nw==", "bodyText": "When it is delegate model, better get the delegate via constructor arg always. Let the creator pass a new Scan() to this explicitly. Pls avoid this constructor.", "url": "https://github.com/apache/hbase/pull/1818#discussion_r434041067", "createdAt": "2020-06-02T17:15:13Z", "author": {"login": "anoopsjohn"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.exceptions.DeserializationException;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Private\n+public final class ImmutableScan extends Scan {\n+\n+  private final Scan delegateScan;\n+\n+  /**\n+   * Create Immutable instance of Scan\n+   */\n+  public ImmutableScan() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a1503b0435cb3a2675f0f85f51a721e7b18d0b2"}, "originalPosition": 44}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f62b017dcb20d750eff56272d2d8d64a1253261b", "author": {"user": {"login": "virajjasani", "name": "Viraj Jasani"}}, "url": "https://github.com/apache/hbase/commit/f62b017dcb20d750eff56272d2d8d64a1253261b", "committedDate": "2020-06-02T17:36:04Z", "message": "addressing review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyODkxMzkz", "url": "https://github.com/apache/hbase/pull/1818#pullrequestreview-422891393", "createdAt": "2020-06-02T17:16:15Z", "commit": {"oid": "1a1503b0435cb3a2675f0f85f51a721e7b18d0b2"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNzoxNjoxNVrOGd7zXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNzozNjoyM1rOGd8jlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MTY5NQ==", "bodyText": "As we are not exposing the original Scan directly, why to create a new Scan again here? No need", "url": "https://github.com/apache/hbase/pull/1818#discussion_r434041695", "createdAt": "2020-06-02T17:16:15Z", "author": {"login": "anoopsjohn"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.exceptions.DeserializationException;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Private\n+public final class ImmutableScan extends Scan {\n+\n+  private final Scan delegateScan;\n+\n+  /**\n+   * Create Immutable instance of Scan\n+   */\n+  public ImmutableScan() {\n+    this.delegateScan = new Scan();\n+  }\n+\n+  /**\n+   * Create Immutable instance of Scan from given Scan object\n+   *\n+   * @param scan Copy all values from Scan\n+   * @throws IOException From parent constructor\n+   */\n+  public ImmutableScan(Scan scan) throws IOException {\n+    this.delegateScan = new Scan(scan);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a1503b0435cb3a2675f0f85f51a721e7b18d0b2"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MjM2MA==", "bodyText": "As of now we dont have this constructor req right? If not better not add now. When there is a need, we can add. At the place where we create this ImmutableScan, already the Get would have been converted to scan", "url": "https://github.com/apache/hbase/pull/1818#discussion_r434042360", "createdAt": "2020-06-02T17:17:22Z", "author": {"login": "anoopsjohn"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.exceptions.DeserializationException;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Private\n+public final class ImmutableScan extends Scan {\n+\n+  private final Scan delegateScan;\n+\n+  /**\n+   * Create Immutable instance of Scan\n+   */\n+  public ImmutableScan() {\n+    this.delegateScan = new Scan();\n+  }\n+\n+  /**\n+   * Create Immutable instance of Scan from given Scan object\n+   *\n+   * @param scan Copy all values from Scan\n+   * @throws IOException From parent constructor\n+   */\n+  public ImmutableScan(Scan scan) throws IOException {\n+    this.delegateScan = new Scan(scan);\n+  }\n+\n+  /**\n+   * Create Immutable instance of Scan from given Get object\n+   *\n+   * @param get Get to model Scan after\n+   */\n+  public ImmutableScan(Get get) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a1503b0435cb3a2675f0f85f51a721e7b18d0b2"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1NDAzOA==", "bodyText": "Just thinking whether we should be cloning this byte[]? Using this getter it is possible to really set a new start row for the scan (by direct changing byte(s) in this byte[]).", "url": "https://github.com/apache/hbase/pull/1818#discussion_r434054038", "createdAt": "2020-06-02T17:36:23Z", "author": {"login": "anoopsjohn"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.exceptions.DeserializationException;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Private\n+public final class ImmutableScan extends Scan {\n+\n+  private final Scan delegateScan;\n+\n+  /**\n+   * Create Immutable instance of Scan\n+   */\n+  public ImmutableScan() {\n+    this.delegateScan = new Scan();\n+  }\n+\n+  /**\n+   * Create Immutable instance of Scan from given Scan object\n+   *\n+   * @param scan Copy all values from Scan\n+   * @throws IOException From parent constructor\n+   */\n+  public ImmutableScan(Scan scan) throws IOException {\n+    this.delegateScan = new Scan(scan);\n+  }\n+\n+  /**\n+   * Create Immutable instance of Scan from given Get object\n+   *\n+   * @param get Get to model Scan after\n+   */\n+  public ImmutableScan(Get get) {\n+    this.delegateScan = new Scan(get);\n+  }\n+\n+  @Override\n+  public Scan addFamily(byte[] family) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to addFamily\");\n+  }\n+\n+  @Override\n+  public Scan addColumn(byte[] family, byte[] qualifier) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to addColumn\");\n+  }\n+\n+  @Override\n+  public Scan setTimeRange(long minStamp, long maxStamp) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setTimeRange\");\n+  }\n+\n+  @Deprecated\n+  @Override\n+  public Scan setTimeStamp(long timestamp) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setTimeStamp\");\n+  }\n+\n+  @Override\n+  public Scan setTimestamp(long timestamp) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setTimestamp\");\n+  }\n+\n+  @Override\n+  public Scan setColumnFamilyTimeRange(byte[] cf, long minStamp, long maxStamp) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setColumnFamilyTimeRange\");\n+  }\n+\n+  @Override\n+  public Scan withStartRow(byte[] startRow) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to withStartRow\");\n+  }\n+\n+  @Override\n+  public Scan withStartRow(byte[] startRow, boolean inclusive) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to withStartRow\");\n+  }\n+\n+  @Override\n+  public Scan withStopRow(byte[] stopRow) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to withStopRow\");\n+  }\n+\n+  @Override\n+  public Scan withStopRow(byte[] stopRow, boolean inclusive) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to withStopRow\");\n+  }\n+\n+  @Override\n+  public Scan setRowPrefixFilter(byte[] rowPrefix) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setRowPrefixFilter\");\n+  }\n+\n+  @Override\n+  public Scan readAllVersions() {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to readAllVersions\");\n+  }\n+\n+  @Override\n+  public Scan readVersions(int versions) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to readVersions\");\n+  }\n+\n+  @Override\n+  public Scan setBatch(int batch) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setBatch\");\n+  }\n+\n+  @Override\n+  public Scan setMaxResultsPerColumnFamily(int limit) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setMaxResultsPerColumnFamily\");\n+  }\n+\n+  @Override\n+  public Scan setRowOffsetPerColumnFamily(int offset) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setRowOffsetPerColumnFamily\");\n+  }\n+\n+  @Override\n+  public Scan setCaching(int caching) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setCaching\");\n+  }\n+\n+  @Override\n+  public Scan setMaxResultSize(long maxResultSize) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setMaxResultSize\");\n+  }\n+\n+  @Override\n+  public Scan setFilter(Filter filter) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setFilter\");\n+  }\n+\n+  @Override\n+  public Scan setFamilyMap(Map<byte[], NavigableSet<byte[]>> familyMap) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setFamilyMap\");\n+  }\n+\n+  @Override\n+  public Scan setCacheBlocks(boolean cacheBlocks) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setCacheBlocks\");\n+  }\n+\n+  @Override\n+  public Scan setReversed(boolean reversed) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setReversed\");\n+  }\n+\n+  @Override\n+  public Scan setAllowPartialResults(final boolean allowPartialResults) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setAllowPartialResults\");\n+  }\n+\n+  @Override\n+  public Scan setLoadColumnFamiliesOnDemand(boolean value) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setLoadColumnFamiliesOnDemand\");\n+  }\n+\n+  @Override\n+  public Scan setRaw(boolean raw) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setRaw\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public Scan setSmall(boolean small) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setSmall\");\n+  }\n+\n+  @Override\n+  public Scan setAttribute(String name, byte[] value) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setAttribute\");\n+  }\n+\n+  @Override\n+  public Scan setId(String id) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setId\");\n+  }\n+\n+  @Override\n+  public Scan setAuthorizations(Authorizations authorizations) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setAuthorizations\");\n+  }\n+\n+  @Override\n+  public Scan setACL(Map<String, Permission> perms) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setACL\");\n+  }\n+\n+  @Override\n+  public Scan setACL(String user, Permission perms) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setACL\");\n+  }\n+\n+  @Override\n+  public Scan setConsistency(Consistency consistency) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setConsistency\");\n+  }\n+\n+  @Override\n+  public Scan setReplicaId(int id) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setReplicaId\");\n+  }\n+\n+  @Override\n+  public Scan setIsolationLevel(IsolationLevel level) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setIsolationLevel\");\n+  }\n+\n+  @Override\n+  public Scan setPriority(int priority) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setPriority\");\n+  }\n+\n+  @Override\n+  public Scan setScanMetricsEnabled(final boolean enabled) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setScanMetricsEnabled\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public Scan setAsyncPrefetch(boolean asyncPrefetch) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setAsyncPrefetch\");\n+  }\n+\n+  @Override\n+  public Scan setLimit(int limit) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setLimit\");\n+  }\n+\n+  @Override\n+  public Scan setOneRowLimit() {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setOneRowLimit\");\n+  }\n+\n+  @Override\n+  public Scan setReadType(ReadType readType) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setReadType\");\n+  }\n+\n+  @Override\n+  Scan setMvccReadPoint(long mvccReadPoint) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setMvccReadPoint\");\n+  }\n+\n+  @Override\n+  Scan resetMvccReadPoint() {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to resetMvccReadPoint\");\n+  }\n+\n+  @Override\n+  public Scan setNeedCursorResult(boolean needCursorResult) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setNeedCursorResult\");\n+  }\n+\n+  @Override\n+  public long getMaxResultSize() {\n+    return this.delegateScan.getMaxResultSize();\n+  }\n+\n+  @Override\n+  public Map<byte[], NavigableSet<byte[]>> getFamilyMap() {\n+    return Collections.unmodifiableMap(this.delegateScan.getFamilyMap());\n+  }\n+\n+  @Override\n+  public int numFamilies() {\n+    return this.delegateScan.numFamilies();\n+  }\n+\n+  @Override\n+  public boolean hasFamilies() {\n+    return this.delegateScan.hasFamilies();\n+  }\n+\n+  @Override\n+  public byte[][] getFamilies() {\n+    return this.delegateScan.getFamilies();\n+  }\n+\n+  @Override\n+  public byte[] getStartRow() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a1503b0435cb3a2675f0f85f51a721e7b18d0b2"}, "originalPosition": 329}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a45dc146ad10be412b3274c8958326215b0fcd1a", "author": {"user": {"login": "virajjasani", "name": "Viraj Jasani"}}, "url": "https://github.com/apache/hbase/commit/a45dc146ad10be412b3274c8958326215b0fcd1a", "committedDate": "2020-06-02T19:16:32Z", "message": "review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNzk1MzUx", "url": "https://github.com/apache/hbase/pull/1818#pullrequestreview-423795351", "createdAt": "2020-06-03T17:53:28Z", "commit": {"oid": "a45dc146ad10be412b3274c8958326215b0fcd1a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzo1MzoyOVrOGenDTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzo1MzoyOVrOGenDTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc1MDI4NA==", "bodyText": "Now we dont have to keep this throws IOE at this constructor.  So below catch stuff in CustomizedScanInfoBuilder also can be avoided.", "url": "https://github.com/apache/hbase/pull/1818#discussion_r434750284", "createdAt": "2020-06-03T17:53:29Z", "author": {"login": "anoopsjohn"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.exceptions.DeserializationException;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Private\n+public final class ImmutableScan extends Scan {\n+\n+  private final Scan delegateScan;\n+\n+  /**\n+   * Create Immutable instance of Scan from given Scan object\n+   *\n+   * @param scan Copy all values from Scan\n+   * @throws IOException From parent constructor\n+   */\n+  public ImmutableScan(Scan scan) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a45dc146ad10be412b3274c8958326215b0fcd1a"}, "originalPosition": 48}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed78982d1c7be3388a13fbd9c0d8e0b22d55857e", "author": {"user": {"login": "virajjasani", "name": "Viraj Jasani"}}, "url": "https://github.com/apache/hbase/commit/ed78982d1c7be3388a13fbd9c0d8e0b22d55857e", "committedDate": "2020-06-03T18:14:18Z", "message": "review - Bytes.copy and remove IOE"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MjY4MjY5", "url": "https://github.com/apache/hbase/pull/1818#pullrequestreview-424268269", "createdAt": "2020-06-04T09:33:32Z", "commit": {"oid": "ed78982d1c7be3388a13fbd9c0d8e0b22d55857e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4479, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}