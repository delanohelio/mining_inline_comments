{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MzE1MjEz", "number": 1858, "title": "HBASE-24506 async client deadlock", "bodyText": "", "createdAt": "2020-06-05T08:50:30Z", "url": "https://github.com/apache/hbase/pull/1858", "merged": true, "mergeCommit": {"oid": "754ac1d06d0db16ec78d565a192c12f7456d0294"}, "closed": true, "closedAt": "2020-06-08T01:38:59Z", "author": {"login": "Apache9"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcoOyObgBqjM0MTAzNjE0NTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpFgtnAFqTQyNTg2MDM2MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aa83710d23fe3162fbf173281c16d82f862e5aab", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/aa83710d23fe3162fbf173281c16d82f862e5aab", "committedDate": "2020-06-05T08:49:07Z", "message": "HBASE-24506 async client deadlock"}, "afterCommit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/08b77a5eca368f391f528e009c95e749d5fa750f", "committedDate": "2020-06-05T08:56:19Z", "message": "HBASE-24506 async client deadlock"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTA1NTcx", "url": "https://github.com/apache/hbase/pull/1858#pullrequestreview-425505571", "createdAt": "2020-06-05T17:53:15Z", "commit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo1MzoxNVrOGf33IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNzo1MzoxNVrOGf33IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3NDI3Mw==", "bodyText": "just checking you want these to be java asserts? production jdks are almost never run with asserts enabled", "url": "https://github.com/apache/hbase/pull/1858#discussion_r436074273", "createdAt": "2020-06-05T17:53:15Z", "author": {"login": "busbey"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/NettyRpcConnection.java", "diffHunk": "@@ -146,45 +163,43 @@ private void established(Channel ch) throws IOException {\n   private boolean reloginInProgress;\n \n   private void scheduleRelogin(Throwable error) {\n+    assert eventLoop.inEventLoop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f"}, "originalPosition": 159}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTA2MzYy", "url": "https://github.com/apache/hbase/pull/1858#pullrequestreview-425506362", "createdAt": "2020-06-05T17:54:25Z", "commit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTQ1MTc0", "url": "https://github.com/apache/hbase/pull/1858#pullrequestreview-425545174", "createdAt": "2020-06-05T18:50:08Z", "commit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOTowOTo0NVrOGf6Qxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOTo0NzowMlrOGf7NUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExMzYwNw==", "bodyText": "Curious to know your thoughts on the performance implications of this change. Now that the event loop is responsible for more than what it was doing before, how would it affect the overall throughput.", "url": "https://github.com/apache/hbase/pull/1858#discussion_r436113607", "createdAt": "2020-06-05T19:09:45Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/NettyRpcConnection.java", "diffHunk": "@@ -253,52 +268,38 @@ public void operationComplete(Future<Boolean> future) throws Exception {\n   }\n \n   private void connect() {\n+    assert eventLoop.inEventLoop();\n     LOG.trace(\"Connecting to {}\", remoteId.address);\n \n-    this.channel = new Bootstrap().group(rpcClient.group).channel(rpcClient.channelClass)\n-        .option(ChannelOption.TCP_NODELAY, rpcClient.isTcpNoDelay())\n-        .option(ChannelOption.SO_KEEPALIVE, rpcClient.tcpKeepAlive)\n-        .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, rpcClient.connectTO)\n-        .handler(new BufferCallBeforeInitHandler()).localAddress(rpcClient.localAddr)\n-        .remoteAddress(remoteId.address).connect().addListener(new ChannelFutureListener() {\n-\n-          @Override\n-          public void operationComplete(ChannelFuture future) throws Exception {\n-            Channel ch = future.channel();\n-            if (!future.isSuccess()) {\n-              failInit(ch, toIOE(future.cause()));\n-              rpcClient.failedServers.addToFailedServers(remoteId.address, future.cause());\n-              return;\n-            }\n-            ch.writeAndFlush(connectionHeaderPreamble.retainedDuplicate());\n-            if (useSasl) {\n-              saslNegotiate(ch);\n-            } else {\n-              // send the connection header to server\n-              ch.write(connectionHeaderWithLength.retainedDuplicate());\n-              established(ch);\n-            }\n-          }\n-        }).channel();\n-  }\n+    this.channel = new Bootstrap().group(eventLoop).channel(rpcClient.channelClass)\n+      .option(ChannelOption.TCP_NODELAY, rpcClient.isTcpNoDelay())\n+      .option(ChannelOption.SO_KEEPALIVE, rpcClient.tcpKeepAlive)\n+      .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, rpcClient.connectTO)\n+      .handler(new BufferCallBeforeInitHandler()).localAddress(rpcClient.localAddr)\n+      .remoteAddress(remoteId.address).connect().addListener(new ChannelFutureListener() {\n \n-  private void write(Channel ch, final Call call) {\n-    ch.writeAndFlush(call).addListener(new ChannelFutureListener() {\n-\n-      @Override\n-      public void operationComplete(ChannelFuture future) throws Exception {\n-        // Fail the call if we failed to write it out. This usually because the channel is\n-        // closed. This is needed because we may shutdown the channel inside event loop and\n-        // there may still be some pending calls in the event loop queue after us.\n-        if (!future.isSuccess()) {\n-          call.setException(toIOE(future.cause()));\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+          Channel ch = future.channel();\n+          if (!future.isSuccess()) {\n+            failInit(ch, toIOE(future.cause()));\n+            rpcClient.failedServers.addToFailedServers(remoteId.address, future.cause());\n+            return;\n+          }\n+          ch.writeAndFlush(connectionHeaderPreamble.retainedDuplicate());\n+          if (useSasl) {\n+            saslNegotiate(ch);\n+          } else {\n+            // send the connection header to server\n+            ch.write(connectionHeaderWithLength.retainedDuplicate());\n+            established(ch);\n+          }\n         }\n-      }\n-    });\n+      }).channel();\n   }\n \n-  @Override\n-  public synchronized void sendRequest(final Call call, HBaseRpcController hrc) throws IOException {\n+  private void sendRequest0(Call call, HBaseRpcController hrc) throws IOException {\n+    assert eventLoop.inEventLoop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyMzAwOQ==", "bodyText": "nit: would the first if() be ever true for client threads?", "url": "https://github.com/apache/hbase/pull/1858#discussion_r436123009", "createdAt": "2020-06-05T19:32:02Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/NettyRpcConnection.java", "diffHunk": "@@ -73,40 +73,53 @@\n   private static final Logger LOG = LoggerFactory.getLogger(NettyRpcConnection.class);\n \n   private static final ScheduledExecutorService RELOGIN_EXECUTOR =\n-      Executors.newSingleThreadScheduledExecutor(Threads.newDaemonThreadFactory(\"Relogin\"));\n+    Executors.newSingleThreadScheduledExecutor(Threads.newDaemonThreadFactory(\"Relogin\"));\n \n   private final NettyRpcClient rpcClient;\n \n+  // the event loop used to set up the connection, we will also execute other operations for this\n+  // connection in this event loop, to avoid locking everywhere.\n+  private final EventLoop eventLoop;\n+\n   private ByteBuf connectionHeaderPreamble;\n \n   private ByteBuf connectionHeaderWithLength;\n \n-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = \"IS2_INCONSISTENT_SYNC\",\n-      justification = \"connect is also under lock as notifyOnCancel will call our action directly\")\n-  private Channel channel;\n+  private volatile Channel channel;\n \n   NettyRpcConnection(NettyRpcClient rpcClient, ConnectionId remoteId) throws IOException {\n     super(rpcClient.conf, AbstractRpcClient.WHEEL_TIMER, remoteId, rpcClient.clusterId,\n-        rpcClient.userProvider.isHBaseSecurityEnabled(), rpcClient.codec, rpcClient.compressor);\n+      rpcClient.userProvider.isHBaseSecurityEnabled(), rpcClient.codec, rpcClient.compressor);\n     this.rpcClient = rpcClient;\n+    this.eventLoop = rpcClient.group.next();\n     byte[] connectionHeaderPreamble = getConnectionHeaderPreamble();\n     this.connectionHeaderPreamble =\n-        Unpooled.directBuffer(connectionHeaderPreamble.length).writeBytes(connectionHeaderPreamble);\n+      Unpooled.directBuffer(connectionHeaderPreamble.length).writeBytes(connectionHeaderPreamble);\n     ConnectionHeader header = getConnectionHeader();\n     this.connectionHeaderWithLength = Unpooled.directBuffer(4 + header.getSerializedSize());\n     this.connectionHeaderWithLength.writeInt(header.getSerializedSize());\n     header.writeTo(new ByteBufOutputStream(this.connectionHeaderWithLength));\n   }\n \n-  @Override\n-  protected synchronized void callTimeout(Call call) {\n-    if (channel != null) {\n-      channel.pipeline().fireUserEventTriggered(new CallEvent(TIMEOUT, call));\n+  private void execute(Runnable action) {\n+    if (eventLoop.inEventLoop()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyOTEwNQ==", "bodyText": "Just a question, why does it have to be giant synchronized? What is the un-safe shared state? Wondering if we can narrow down the lock and simplify the threading model to fix the actual problem.", "url": "https://github.com/apache/hbase/pull/1858#discussion_r436129105", "createdAt": "2020-06-05T19:47:02Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/NettyRpcConnection.java", "diffHunk": "@@ -253,52 +268,38 @@ public void operationComplete(Future<Boolean> future) throws Exception {\n   }\n \n   private void connect() {\n+    assert eventLoop.inEventLoop();\n     LOG.trace(\"Connecting to {}\", remoteId.address);\n \n-    this.channel = new Bootstrap().group(rpcClient.group).channel(rpcClient.channelClass)\n-        .option(ChannelOption.TCP_NODELAY, rpcClient.isTcpNoDelay())\n-        .option(ChannelOption.SO_KEEPALIVE, rpcClient.tcpKeepAlive)\n-        .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, rpcClient.connectTO)\n-        .handler(new BufferCallBeforeInitHandler()).localAddress(rpcClient.localAddr)\n-        .remoteAddress(remoteId.address).connect().addListener(new ChannelFutureListener() {\n-\n-          @Override\n-          public void operationComplete(ChannelFuture future) throws Exception {\n-            Channel ch = future.channel();\n-            if (!future.isSuccess()) {\n-              failInit(ch, toIOE(future.cause()));\n-              rpcClient.failedServers.addToFailedServers(remoteId.address, future.cause());\n-              return;\n-            }\n-            ch.writeAndFlush(connectionHeaderPreamble.retainedDuplicate());\n-            if (useSasl) {\n-              saslNegotiate(ch);\n-            } else {\n-              // send the connection header to server\n-              ch.write(connectionHeaderWithLength.retainedDuplicate());\n-              established(ch);\n-            }\n-          }\n-        }).channel();\n-  }\n+    this.channel = new Bootstrap().group(eventLoop).channel(rpcClient.channelClass)\n+      .option(ChannelOption.TCP_NODELAY, rpcClient.isTcpNoDelay())\n+      .option(ChannelOption.SO_KEEPALIVE, rpcClient.tcpKeepAlive)\n+      .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, rpcClient.connectTO)\n+      .handler(new BufferCallBeforeInitHandler()).localAddress(rpcClient.localAddr)\n+      .remoteAddress(remoteId.address).connect().addListener(new ChannelFutureListener() {\n \n-  private void write(Channel ch, final Call call) {\n-    ch.writeAndFlush(call).addListener(new ChannelFutureListener() {\n-\n-      @Override\n-      public void operationComplete(ChannelFuture future) throws Exception {\n-        // Fail the call if we failed to write it out. This usually because the channel is\n-        // closed. This is needed because we may shutdown the channel inside event loop and\n-        // there may still be some pending calls in the event loop queue after us.\n-        if (!future.isSuccess()) {\n-          call.setException(toIOE(future.cause()));\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+          Channel ch = future.channel();\n+          if (!future.isSuccess()) {\n+            failInit(ch, toIOE(future.cause()));\n+            rpcClient.failedServers.addToFailedServers(remoteId.address, future.cause());\n+            return;\n+          }\n+          ch.writeAndFlush(connectionHeaderPreamble.retainedDuplicate());\n+          if (useSasl) {\n+            saslNegotiate(ch);\n+          } else {\n+            // send the connection header to server\n+            ch.write(connectionHeaderWithLength.retainedDuplicate());\n+            established(ch);\n+          }\n         }\n-      }\n-    });\n+      }).channel();\n   }\n \n-  @Override\n-  public synchronized void sendRequest(final Call call, HBaseRpcController hrc) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f"}, "originalPosition": 314}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NjEwOTU2", "url": "https://github.com/apache/hbase/pull/1858#pullrequestreview-425610956", "createdAt": "2020-06-05T20:38:05Z", "commit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDozODowNVrOGf8rJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDozODowNVrOGf8rJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1MzEyNg==", "bodyText": "Same as @busbey mentioned at L166, asserts are not usually enabled.", "url": "https://github.com/apache/hbase/pull/1858#discussion_r436153126", "createdAt": "2020-06-05T20:38:05Z", "author": {"login": "esteban"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/NettyRpcConnection.java", "diffHunk": "@@ -146,45 +163,43 @@ private void established(Channel ch) throws IOException {\n   private boolean reloginInProgress;\n \n   private void scheduleRelogin(Throwable error) {\n+    assert eventLoop.inEventLoop();\n     if (error instanceof FallbackDisallowedException) {\n       return;\n     }\n     if (!provider.canRetry()) {\n       LOG.trace(\"SASL Provider does not support retries\");\n       return;\n     }\n-    synchronized (this) {\n-      if (reloginInProgress) {\n-        return;\n-      }\n-      reloginInProgress = true;\n-      RELOGIN_EXECUTOR.schedule(new Runnable() {\n+    if (reloginInProgress) {\n+      return;\n+    }\n+    reloginInProgress = true;\n+    RELOGIN_EXECUTOR.schedule(new Runnable() {\n \n-        @Override\n-        public void run() {\n-          try {\n-            provider.relogin();\n-          } catch (IOException e) {\n-            LOG.warn(\"Relogin failed\", e);\n-          }\n-          synchronized (this) {\n-            reloginInProgress = false;\n-          }\n+      @Override\n+      public void run() {\n+        try {\n+          provider.relogin();\n+        } catch (IOException e) {\n+          LOG.warn(\"Relogin failed\", e);\n         }\n-      }, ThreadLocalRandom.current().nextInt(reloginMaxBackoff), TimeUnit.MILLISECONDS);\n-    }\n+        eventLoop.execute(() -> {\n+          reloginInProgress = false;\n+        });\n+      }\n+    }, ThreadLocalRandom.current().nextInt(reloginMaxBackoff), TimeUnit.MILLISECONDS);\n   }\n \n   private void failInit(Channel ch, IOException e) {\n-    synchronized (this) {\n-      // fail all pending calls\n-      ch.pipeline().fireUserEventTriggered(BufferCallEvent.fail(e));\n-      shutdown0();\n-      return;\n-    }\n+    assert eventLoop.inEventLoop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f"}, "originalPosition": 212}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NjExMTg0", "url": "https://github.com/apache/hbase/pull/1858#pullrequestreview-425611184", "createdAt": "2020-06-05T20:38:32Z", "commit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDozODozMlrOGf8r1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDozODozMlrOGf8r1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1MzMwMQ==", "bodyText": "same 08b77a5#r436153126", "url": "https://github.com/apache/hbase/pull/1858#discussion_r436153301", "createdAt": "2020-06-05T20:38:32Z", "author": {"login": "esteban"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/NettyRpcConnection.java", "diffHunk": "@@ -146,45 +163,43 @@ private void established(Channel ch) throws IOException {\n   private boolean reloginInProgress;\n \n   private void scheduleRelogin(Throwable error) {\n+    assert eventLoop.inEventLoop();\n     if (error instanceof FallbackDisallowedException) {\n       return;\n     }\n     if (!provider.canRetry()) {\n       LOG.trace(\"SASL Provider does not support retries\");\n       return;\n     }\n-    synchronized (this) {\n-      if (reloginInProgress) {\n-        return;\n-      }\n-      reloginInProgress = true;\n-      RELOGIN_EXECUTOR.schedule(new Runnable() {\n+    if (reloginInProgress) {\n+      return;\n+    }\n+    reloginInProgress = true;\n+    RELOGIN_EXECUTOR.schedule(new Runnable() {\n \n-        @Override\n-        public void run() {\n-          try {\n-            provider.relogin();\n-          } catch (IOException e) {\n-            LOG.warn(\"Relogin failed\", e);\n-          }\n-          synchronized (this) {\n-            reloginInProgress = false;\n-          }\n+      @Override\n+      public void run() {\n+        try {\n+          provider.relogin();\n+        } catch (IOException e) {\n+          LOG.warn(\"Relogin failed\", e);\n         }\n-      }, ThreadLocalRandom.current().nextInt(reloginMaxBackoff), TimeUnit.MILLISECONDS);\n-    }\n+        eventLoop.execute(() -> {\n+          reloginInProgress = false;\n+        });\n+      }\n+    }, ThreadLocalRandom.current().nextInt(reloginMaxBackoff), TimeUnit.MILLISECONDS);\n   }\n \n   private void failInit(Channel ch, IOException e) {\n-    synchronized (this) {\n-      // fail all pending calls\n-      ch.pipeline().fireUserEventTriggered(BufferCallEvent.fail(e));\n-      shutdown0();\n-      return;\n-    }\n+    assert eventLoop.inEventLoop();\n+    // fail all pending calls\n+    ch.pipeline().fireUserEventTriggered(BufferCallEvent.fail(e));\n+    shutdown0();\n   }\n \n   private void saslNegotiate(final Channel ch) {\n+    assert eventLoop.inEventLoop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f"}, "originalPosition": 219}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NjExNDcy", "url": "https://github.com/apache/hbase/pull/1858#pullrequestreview-425611472", "createdAt": "2020-06-05T20:39:02Z", "commit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDozOTowMlrOGf8soQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDozOTowMlrOGf8soQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1MzUwNQ==", "bodyText": "same 08b77a5#r436153126", "url": "https://github.com/apache/hbase/pull/1858#discussion_r436153505", "createdAt": "2020-06-05T20:39:02Z", "author": {"login": "esteban"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/NettyRpcConnection.java", "diffHunk": "@@ -253,52 +268,38 @@ public void operationComplete(Future<Boolean> future) throws Exception {\n   }\n \n   private void connect() {\n+    assert eventLoop.inEventLoop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f"}, "originalPosition": 245}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/08b77a5eca368f391f528e009c95e749d5fa750f", "committedDate": "2020-06-05T08:56:19Z", "message": "HBASE-24506 async client deadlock"}, "afterCommit": {"oid": "1b7c5ba8bc51a932ec47bddc0613b4d8ed217b63", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/1b7c5ba8bc51a932ec47bddc0613b4d8ed217b63", "committedDate": "2020-06-06T08:04:22Z", "message": "HBASE-24506 async client deadlock"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1b7c5ba8bc51a932ec47bddc0613b4d8ed217b63", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/1b7c5ba8bc51a932ec47bddc0613b4d8ed217b63", "committedDate": "2020-06-06T08:04:22Z", "message": "HBASE-24506 async client deadlock"}, "afterCommit": {"oid": "fc72e3d96c1327b20dafff1ecd190826bee1297a", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/fc72e3d96c1327b20dafff1ecd190826bee1297a", "committedDate": "2020-06-06T13:11:49Z", "message": "HBASE-24506 async client deadlock"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1Nzk2MDc5", "url": "https://github.com/apache/hbase/pull/1858#pullrequestreview-425796079", "createdAt": "2020-06-07T07:51:44Z", "commit": {"oid": "fc72e3d96c1327b20dafff1ecd190826bee1297a"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwNzo1MTo0NFrOGgH2WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwODoxMjoxMlrOGgH7-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNjIxNg==", "bodyText": "nit: if we want to go till depth of 4, want to use MutableShort?", "url": "https://github.com/apache/hbase/pull/1858#discussion_r436336216", "createdAt": "2020-06-07T07:51:44Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/NettyRpcConnection.java", "diffHunk": "@@ -73,40 +79,77 @@\n   private static final Logger LOG = LoggerFactory.getLogger(NettyRpcConnection.class);\n \n   private static final ScheduledExecutorService RELOGIN_EXECUTOR =\n-      Executors.newSingleThreadScheduledExecutor(Threads.newDaemonThreadFactory(\"Relogin\"));\n+    Executors.newSingleThreadScheduledExecutor(Threads.newDaemonThreadFactory(\"Relogin\"));\n \n   private final NettyRpcClient rpcClient;\n \n+  // the event loop used to set up the connection, we will also execute other operations for this\n+  // connection in this event loop, to avoid locking everywhere.\n+  private final EventLoop eventLoop;\n+\n   private ByteBuf connectionHeaderPreamble;\n \n   private ByteBuf connectionHeaderWithLength;\n \n-  @edu.umd.cs.findbugs.annotations.SuppressWarnings(value = \"IS2_INCONSISTENT_SYNC\",\n-      justification = \"connect is also under lock as notifyOnCancel will call our action directly\")\n-  private Channel channel;\n+  // make it volatile so in the isActive method below we do not need to switch to the event loop\n+  // thread to access this field.\n+  private volatile Channel channel;\n \n   NettyRpcConnection(NettyRpcClient rpcClient, ConnectionId remoteId) throws IOException {\n     super(rpcClient.conf, AbstractRpcClient.WHEEL_TIMER, remoteId, rpcClient.clusterId,\n-        rpcClient.userProvider.isHBaseSecurityEnabled(), rpcClient.codec, rpcClient.compressor);\n+      rpcClient.userProvider.isHBaseSecurityEnabled(), rpcClient.codec, rpcClient.compressor);\n     this.rpcClient = rpcClient;\n+    this.eventLoop = rpcClient.group.next();\n     byte[] connectionHeaderPreamble = getConnectionHeaderPreamble();\n     this.connectionHeaderPreamble =\n-        Unpooled.directBuffer(connectionHeaderPreamble.length).writeBytes(connectionHeaderPreamble);\n+      Unpooled.directBuffer(connectionHeaderPreamble.length).writeBytes(connectionHeaderPreamble);\n     ConnectionHeader header = getConnectionHeader();\n     this.connectionHeaderWithLength = Unpooled.directBuffer(4 + header.getSerializedSize());\n     this.connectionHeaderWithLength.writeInt(header.getSerializedSize());\n     header.writeTo(new ByteBufOutputStream(this.connectionHeaderWithLength));\n   }\n \n-  @Override\n-  protected synchronized void callTimeout(Call call) {\n-    if (channel != null) {\n-      channel.pipeline().fireUserEventTriggered(new CallEvent(TIMEOUT, call));\n+  private static final FastThreadLocal<MutableInt> DEPTH = new FastThreadLocal<MutableInt>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc72e3d96c1327b20dafff1ecd190826bee1297a"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNjY1NQ==", "bodyText": "nit: Would you prefer converting to lambda () -> ?", "url": "https://github.com/apache/hbase/pull/1858#discussion_r436336655", "createdAt": "2020-06-07T07:57:46Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/NettyRpcConnection.java", "diffHunk": "@@ -153,35 +200,30 @@ private void scheduleRelogin(Throwable error) {\n       LOG.trace(\"SASL Provider does not support retries\");\n       return;\n     }\n-    synchronized (this) {\n-      if (reloginInProgress) {\n-        return;\n-      }\n-      reloginInProgress = true;\n-      RELOGIN_EXECUTOR.schedule(new Runnable() {\n+    if (reloginInProgress) {\n+      return;\n+    }\n+    reloginInProgress = true;\n+    RELOGIN_EXECUTOR.schedule(new Runnable() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc72e3d96c1327b20dafff1ecd190826bee1297a"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNzY1Ng==", "bodyText": "This is covered already right? Maybe older comment, I might have read it in different order. Sorry for the confusion.\nBtw +1 for volatile channel and removal of synchronized from this method as netty is taking care of incoming requests already.", "url": "https://github.com/apache/hbase/pull/1858#discussion_r436337656", "createdAt": "2020-06-07T08:12:12Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/NettyRpcConnection.java", "diffHunk": "@@ -253,52 +268,38 @@ public void operationComplete(Future<Boolean> future) throws Exception {\n   }\n \n   private void connect() {\n+    assert eventLoop.inEventLoop();\n     LOG.trace(\"Connecting to {}\", remoteId.address);\n \n-    this.channel = new Bootstrap().group(rpcClient.group).channel(rpcClient.channelClass)\n-        .option(ChannelOption.TCP_NODELAY, rpcClient.isTcpNoDelay())\n-        .option(ChannelOption.SO_KEEPALIVE, rpcClient.tcpKeepAlive)\n-        .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, rpcClient.connectTO)\n-        .handler(new BufferCallBeforeInitHandler()).localAddress(rpcClient.localAddr)\n-        .remoteAddress(remoteId.address).connect().addListener(new ChannelFutureListener() {\n-\n-          @Override\n-          public void operationComplete(ChannelFuture future) throws Exception {\n-            Channel ch = future.channel();\n-            if (!future.isSuccess()) {\n-              failInit(ch, toIOE(future.cause()));\n-              rpcClient.failedServers.addToFailedServers(remoteId.address, future.cause());\n-              return;\n-            }\n-            ch.writeAndFlush(connectionHeaderPreamble.retainedDuplicate());\n-            if (useSasl) {\n-              saslNegotiate(ch);\n-            } else {\n-              // send the connection header to server\n-              ch.write(connectionHeaderWithLength.retainedDuplicate());\n-              established(ch);\n-            }\n-          }\n-        }).channel();\n-  }\n+    this.channel = new Bootstrap().group(eventLoop).channel(rpcClient.channelClass)\n+      .option(ChannelOption.TCP_NODELAY, rpcClient.isTcpNoDelay())\n+      .option(ChannelOption.SO_KEEPALIVE, rpcClient.tcpKeepAlive)\n+      .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, rpcClient.connectTO)\n+      .handler(new BufferCallBeforeInitHandler()).localAddress(rpcClient.localAddr)\n+      .remoteAddress(remoteId.address).connect().addListener(new ChannelFutureListener() {\n \n-  private void write(Channel ch, final Call call) {\n-    ch.writeAndFlush(call).addListener(new ChannelFutureListener() {\n-\n-      @Override\n-      public void operationComplete(ChannelFuture future) throws Exception {\n-        // Fail the call if we failed to write it out. This usually because the channel is\n-        // closed. This is needed because we may shutdown the channel inside event loop and\n-        // there may still be some pending calls in the event loop queue after us.\n-        if (!future.isSuccess()) {\n-          call.setException(toIOE(future.cause()));\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+          Channel ch = future.channel();\n+          if (!future.isSuccess()) {\n+            failInit(ch, toIOE(future.cause()));\n+            rpcClient.failedServers.addToFailedServers(remoteId.address, future.cause());\n+            return;\n+          }\n+          ch.writeAndFlush(connectionHeaderPreamble.retainedDuplicate());\n+          if (useSasl) {\n+            saslNegotiate(ch);\n+          } else {\n+            // send the connection header to server\n+            ch.write(connectionHeaderWithLength.retainedDuplicate());\n+            established(ch);\n+          }\n         }\n-      }\n-    });\n+      }).channel();\n   }\n \n-  @Override\n-  public synchronized void sendRequest(final Call call, HBaseRpcController hrc) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyOTEwNQ=="}, "originalCommit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f"}, "originalPosition": 314}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fc72e3d96c1327b20dafff1ecd190826bee1297a", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/fc72e3d96c1327b20dafff1ecd190826bee1297a", "committedDate": "2020-06-06T13:11:49Z", "message": "HBASE-24506 async client deadlock"}, "afterCommit": {"oid": "03931bd005f0479061aa97b92144bb6f8ea37aa9", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/03931bd005f0479061aa97b92144bb6f8ea37aa9", "committedDate": "2020-06-07T14:41:56Z", "message": "HBASE-24506 async client deadlock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d01fbc5a873321695b7db9191e91dbed4538576", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/8d01fbc5a873321695b7db9191e91dbed4538576", "committedDate": "2020-06-07T14:43:20Z", "message": "HBASE-24506 async client deadlock"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "03931bd005f0479061aa97b92144bb6f8ea37aa9", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/03931bd005f0479061aa97b92144bb6f8ea37aa9", "committedDate": "2020-06-07T14:41:56Z", "message": "HBASE-24506 async client deadlock"}, "afterCommit": {"oid": "8d01fbc5a873321695b7db9191e91dbed4538576", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/8d01fbc5a873321695b7db9191e91dbed4538576", "committedDate": "2020-06-07T14:43:20Z", "message": "HBASE-24506 async client deadlock"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODYwMzYx", "url": "https://github.com/apache/hbase/pull/1858#pullrequestreview-425860361", "createdAt": "2020-06-07T22:57:41Z", "commit": {"oid": "8d01fbc5a873321695b7db9191e91dbed4538576"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QyMjo1Nzo0MVrOGgMWJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMDozODozM1rOGgM0Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwOTg5NQ==", "bodyText": "Hmm okay. I still think the locking can be made fine grained with rw locks for channel and totally get rid of eventloop but its okay, your perf run shows no regression, so its fine.", "url": "https://github.com/apache/hbase/pull/1858#discussion_r436409895", "createdAt": "2020-06-07T22:57:41Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/NettyRpcConnection.java", "diffHunk": "@@ -253,52 +268,38 @@ public void operationComplete(Future<Boolean> future) throws Exception {\n   }\n \n   private void connect() {\n+    assert eventLoop.inEventLoop();\n     LOG.trace(\"Connecting to {}\", remoteId.address);\n \n-    this.channel = new Bootstrap().group(rpcClient.group).channel(rpcClient.channelClass)\n-        .option(ChannelOption.TCP_NODELAY, rpcClient.isTcpNoDelay())\n-        .option(ChannelOption.SO_KEEPALIVE, rpcClient.tcpKeepAlive)\n-        .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, rpcClient.connectTO)\n-        .handler(new BufferCallBeforeInitHandler()).localAddress(rpcClient.localAddr)\n-        .remoteAddress(remoteId.address).connect().addListener(new ChannelFutureListener() {\n-\n-          @Override\n-          public void operationComplete(ChannelFuture future) throws Exception {\n-            Channel ch = future.channel();\n-            if (!future.isSuccess()) {\n-              failInit(ch, toIOE(future.cause()));\n-              rpcClient.failedServers.addToFailedServers(remoteId.address, future.cause());\n-              return;\n-            }\n-            ch.writeAndFlush(connectionHeaderPreamble.retainedDuplicate());\n-            if (useSasl) {\n-              saslNegotiate(ch);\n-            } else {\n-              // send the connection header to server\n-              ch.write(connectionHeaderWithLength.retainedDuplicate());\n-              established(ch);\n-            }\n-          }\n-        }).channel();\n-  }\n+    this.channel = new Bootstrap().group(eventLoop).channel(rpcClient.channelClass)\n+      .option(ChannelOption.TCP_NODELAY, rpcClient.isTcpNoDelay())\n+      .option(ChannelOption.SO_KEEPALIVE, rpcClient.tcpKeepAlive)\n+      .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, rpcClient.connectTO)\n+      .handler(new BufferCallBeforeInitHandler()).localAddress(rpcClient.localAddr)\n+      .remoteAddress(remoteId.address).connect().addListener(new ChannelFutureListener() {\n \n-  private void write(Channel ch, final Call call) {\n-    ch.writeAndFlush(call).addListener(new ChannelFutureListener() {\n-\n-      @Override\n-      public void operationComplete(ChannelFuture future) throws Exception {\n-        // Fail the call if we failed to write it out. This usually because the channel is\n-        // closed. This is needed because we may shutdown the channel inside event loop and\n-        // there may still be some pending calls in the event loop queue after us.\n-        if (!future.isSuccess()) {\n-          call.setException(toIOE(future.cause()));\n+        @Override\n+        public void operationComplete(ChannelFuture future) throws Exception {\n+          Channel ch = future.channel();\n+          if (!future.isSuccess()) {\n+            failInit(ch, toIOE(future.cause()));\n+            rpcClient.failedServers.addToFailedServers(remoteId.address, future.cause());\n+            return;\n+          }\n+          ch.writeAndFlush(connectionHeaderPreamble.retainedDuplicate());\n+          if (useSasl) {\n+            saslNegotiate(ch);\n+          } else {\n+            // send the connection header to server\n+            ch.write(connectionHeaderWithLength.retainedDuplicate());\n+            established(ch);\n+          }\n         }\n-      }\n-    });\n+      }).channel();\n   }\n \n-  @Override\n-  public synchronized void sendRequest(final Call call, HBaseRpcController hrc) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyOTEwNQ=="}, "originalCommit": {"oid": "08b77a5eca368f391f528e009c95e749d5fa750f"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQxNzU0Mw==", "bodyText": "haha, nice test :-)", "url": "https://github.com/apache/hbase/pull/1858#discussion_r436417543", "createdAt": "2020-06-08T00:38:33Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/test/java/org/apache/hadoop/hbase/ipc/TestNettyRpcConnection.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.ipc;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.net.InetSocketAddress;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.security.User;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.io.Closeables;\n+\n+public class TestNettyRpcConnection {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule CLASS_RULE =\n+    HBaseClassTestRule.forClass(TestNettyRpcConnection.class);\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(TestNettyRpcConnection.class);\n+\n+  private static NettyRpcClient CLIENT;\n+\n+  private static NettyRpcConnection CONN;\n+\n+  @BeforeClass\n+  public static void setUp() throws IOException {\n+    CLIENT = new NettyRpcClient(HBaseConfiguration.create());\n+    CONN = new NettyRpcConnection(CLIENT,\n+      new ConnectionId(User.getCurrent(), \"test\", new InetSocketAddress(\"localhost\", 1234)));\n+  }\n+\n+  @AfterClass\n+  public static void tearDown() throws IOException {\n+    Closeables.close(CLIENT, true);\n+  }\n+\n+  @Test\n+  public void testPrivateMethodExecutedInEventLoop() throws IllegalAccessException {\n+    // make sure the test is executed with \"-ea\"\n+    assertThrows(AssertionError.class, () -> {\n+      assert false;\n+    });\n+    for (Method method : NettyRpcConnection.class.getDeclaredMethods()) {\n+      if (Modifier.isPrivate(method.getModifiers()) && !method.getName().contains(\"$\")) {\n+        LOG.info(\"checking {}\", method);\n+        method.setAccessible(true);\n+        // all private methods should be called inside the event loop thread, so calling it from", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d01fbc5a873321695b7db9191e91dbed4538576"}, "originalPosition": 76}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4542, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}