{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzMzQxMjU5", "number": 1784, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMToxNzozNlrOD_2bXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMToyNToyMFrOD_2kTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4Mjc4NjIwOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMToxNzozNlrOGawpLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzowNzozOVrOGa8FNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxMzEzNA==", "bodyText": "Or should we define a new constant for high priority splits that is not quite MIN_VALUE, so someone can still schedule something ahead of us? idk, like MIN_VALUE+1000.", "url": "https://github.com/apache/hbase/pull/1784#discussion_r430713134", "createdAt": "2020-05-26T21:17:36Z", "author": {"login": "apurtell"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java", "diffHunk": "@@ -1921,9 +1921,15 @@ public boolean shouldPerformMajorCompaction() throws IOException {\n         // If we're enqueuing a major, clear the force flag.\n         this.forceMajor = this.forceMajor && !request.isMajor();\n \n-        // Set common request properties.\n-        // Set priority, either override value supplied by caller or from store.\n-        request.setPriority((priority != Store.NO_PRIORITY) ? priority : getCompactPriority());\n+        if (request.isAfterSplit()) {\n+          // If the store belongs to recently splitted daughter regions, better we consider\n+          // them with the highest priority in the compaction queue.\n+          request.setPriority(Integer.MIN_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c98aa8026b2a919b171f1358d17fd3060a619877"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwMDUzNQ==", "bodyText": "Yeah, MIN_VALUE+1000 (or 5000) should be able to provide more than enough room for tasks that can emerge as even higher priority than split housekeeping in future.", "url": "https://github.com/apache/hbase/pull/1784#discussion_r430900535", "createdAt": "2020-05-27T07:07:39Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java", "diffHunk": "@@ -1921,9 +1921,15 @@ public boolean shouldPerformMajorCompaction() throws IOException {\n         // If we're enqueuing a major, clear the force flag.\n         this.forceMajor = this.forceMajor && !request.isMajor();\n \n-        // Set common request properties.\n-        // Set priority, either override value supplied by caller or from store.\n-        request.setPriority((priority != Store.NO_PRIORITY) ? priority : getCompactPriority());\n+        if (request.isAfterSplit()) {\n+          // If the store belongs to recently splitted daughter regions, better we consider\n+          // them with the highest priority in the compaction queue.\n+          request.setPriority(Integer.MIN_VALUE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxMzEzNA=="}, "originalCommit": {"oid": "c98aa8026b2a919b171f1358d17fd3060a619877"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4Mjc5OTY0OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMToyMjoxMVrOGawxvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxMTo0Mzo0N1rOGbFdLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNTMyNw==", "bodyText": "Hmm. I suppose this is fine. We already have request#isMajor to inform us if we need to schedule a major compaction.\nrequest#isSplit is just as informative as request#isAfterSplit, but no strong opinion there.", "url": "https://github.com/apache/hbase/pull/1784#discussion_r430715327", "createdAt": "2020-05-26T21:22:11Z", "author": {"login": "apurtell"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java", "diffHunk": "@@ -1921,9 +1921,15 @@ public boolean shouldPerformMajorCompaction() throws IOException {\n         // If we're enqueuing a major, clear the force flag.\n         this.forceMajor = this.forceMajor && !request.isMajor();\n \n-        // Set common request properties.\n-        // Set priority, either override value supplied by caller or from store.\n-        request.setPriority((priority != Store.NO_PRIORITY) ? priority : getCompactPriority());\n+        if (request.isAfterSplit()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c98aa8026b2a919b171f1358d17fd3060a619877"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNTkzOQ==", "bodyText": "We should log when we are overriding request priority with the reason why, at DEBUG level at least, but INFO makes sense too.", "url": "https://github.com/apache/hbase/pull/1784#discussion_r430715939", "createdAt": "2020-05-26T21:23:28Z", "author": {"login": "apurtell"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java", "diffHunk": "@@ -1921,9 +1921,15 @@ public boolean shouldPerformMajorCompaction() throws IOException {\n         // If we're enqueuing a major, clear the force flag.\n         this.forceMajor = this.forceMajor && !request.isMajor();\n \n-        // Set common request properties.\n-        // Set priority, either override value supplied by caller or from store.\n-        request.setPriority((priority != Store.NO_PRIORITY) ? priority : getCompactPriority());\n+        if (request.isAfterSplit()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNTMyNw=="}, "originalCommit": {"oid": "c98aa8026b2a919b171f1358d17fd3060a619877"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxODMwNQ==", "bodyText": "Oh, if you accept my above suggestion wrt a constant value for split housekeeping that is not quite MIN_VALUE then we should not override priority if it is already equal to or less than what we need.", "url": "https://github.com/apache/hbase/pull/1784#discussion_r430718305", "createdAt": "2020-05-26T21:28:36Z", "author": {"login": "apurtell"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java", "diffHunk": "@@ -1921,9 +1921,15 @@ public boolean shouldPerformMajorCompaction() throws IOException {\n         // If we're enqueuing a major, clear the force flag.\n         this.forceMajor = this.forceMajor && !request.isMajor();\n \n-        // Set common request properties.\n-        // Set priority, either override value supplied by caller or from store.\n-        request.setPriority((priority != Store.NO_PRIORITY) ? priority : getCompactPriority());\n+        if (request.isAfterSplit()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNTMyNw=="}, "originalCommit": {"oid": "c98aa8026b2a919b171f1358d17fd3060a619877"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5OTQ3OA==", "bodyText": "Agree, we should override priority only if it is higher than constant (MIN_VALUE + 1000).", "url": "https://github.com/apache/hbase/pull/1784#discussion_r430899478", "createdAt": "2020-05-27T07:05:13Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java", "diffHunk": "@@ -1921,9 +1921,15 @@ public boolean shouldPerformMajorCompaction() throws IOException {\n         // If we're enqueuing a major, clear the force flag.\n         this.forceMajor = this.forceMajor && !request.isMajor();\n \n-        // Set common request properties.\n-        // Set priority, either override value supplied by caller or from store.\n-        request.setPriority((priority != Store.NO_PRIORITY) ? priority : getCompactPriority());\n+        if (request.isAfterSplit()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNTMyNw=="}, "originalCommit": {"oid": "c98aa8026b2a919b171f1358d17fd3060a619877"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAyNzg5Ng==", "bodyText": "@virajjasani  One Q.\nRather than handling at this layer by checking whether the call is after a split or not,  can we set a higher priority on the compact request, created after the split op?  So then we dont need to set with these split status etc and handle specially at this layer.", "url": "https://github.com/apache/hbase/pull/1784#discussion_r431027896", "createdAt": "2020-05-27T10:49:46Z", "author": {"login": "anoopsjohn"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java", "diffHunk": "@@ -1921,9 +1921,15 @@ public boolean shouldPerformMajorCompaction() throws IOException {\n         // If we're enqueuing a major, clear the force flag.\n         this.forceMajor = this.forceMajor && !request.isMajor();\n \n-        // Set common request properties.\n-        // Set priority, either override value supplied by caller or from store.\n-        request.setPriority((priority != Store.NO_PRIORITY) ? priority : getCompactPriority());\n+        if (request.isAfterSplit()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNTMyNw=="}, "originalCommit": {"oid": "c98aa8026b2a919b171f1358d17fd3060a619877"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1NDEyNQ==", "bodyText": "There are 2 reasons:\n\nisAfterSplit is an additional field which could be useful for maybe some other purpose also (in future).\nWe already have logic to determine priority at this layer only: request.setPriority((priority != Store.NO_PRIORITY) ? priority : getCompactPriority());. Nowhere other than this place, are we using priority setter request.setPriority(int p). So this will provide better alignment and also avoid setting priority in multiple places: SortedCompactionPolicy, StripeCompactionPolicy, HStore.", "url": "https://github.com/apache/hbase/pull/1784#discussion_r431054125", "createdAt": "2020-05-27T11:43:47Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java", "diffHunk": "@@ -1921,9 +1921,15 @@ public boolean shouldPerformMajorCompaction() throws IOException {\n         // If we're enqueuing a major, clear the force flag.\n         this.forceMajor = this.forceMajor && !request.isMajor();\n \n-        // Set common request properties.\n-        // Set priority, either override value supplied by caller or from store.\n-        request.setPriority((priority != Store.NO_PRIORITY) ? priority : getCompactPriority());\n+        if (request.isAfterSplit()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNTMyNw=="}, "originalCommit": {"oid": "c98aa8026b2a919b171f1358d17fd3060a619877"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4MjgwOTA4OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/CompactionRequestImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMToyNToyMFrOGaw3hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QwNzoxMToyNFrOGa8L1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNjgwNQ==", "bodyText": "This pattern is not one I've seen before but we do it above for isOffPeak so (shrug).", "url": "https://github.com/apache/hbase/pull/1784#discussion_r430716805", "createdAt": "2020-05-26T21:25:20Z", "author": {"login": "apurtell"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/CompactionRequestImpl.java", "diffHunk": "@@ -149,6 +158,7 @@ public int hashCode() {\n     result = prime * result + ((storeName == null) ? 0 : storeName.hashCode());\n     result = prime * result + (int) (totalSize ^ (totalSize >>> 32));\n     result = prime * result + ((tracker == null) ? 0 : tracker.hashCode());\n+    result = prime * result + (isAfterSplit ? 1231 : 1237);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c98aa8026b2a919b171f1358d17fd3060a619877"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwMjIzMQ==", "bodyText": "Yeah right, I exactly looked for an existing boolean and applied same formula rather than regenerating hashcode() by IDE :)", "url": "https://github.com/apache/hbase/pull/1784#discussion_r430902231", "createdAt": "2020-05-27T07:11:24Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/CompactionRequestImpl.java", "diffHunk": "@@ -149,6 +158,7 @@ public int hashCode() {\n     result = prime * result + ((storeName == null) ? 0 : storeName.hashCode());\n     result = prime * result + (int) (totalSize ^ (totalSize >>> 32));\n     result = prime * result + ((tracker == null) ? 0 : tracker.hashCode());\n+    result = prime * result + (isAfterSplit ? 1231 : 1237);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNjgwNQ=="}, "originalCommit": {"oid": "c98aa8026b2a919b171f1358d17fd3060a619877"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3054, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}