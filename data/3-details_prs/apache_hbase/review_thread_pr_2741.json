{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzMTMyMjE0", "number": 2741, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQxNDowNDo0NlrOFBc2zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0Mzo0NlrOFB7aAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MDY1Njc4OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQxNDowNDo0N1rOIAKqZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQwMjoxODozM1rOIF1tyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA0NTYwNA==", "bodyText": "The logic here is different from original?", "url": "https://github.com/apache/hbase/pull/2741#discussion_r537045604", "createdAt": "2020-12-06T14:04:47Z", "author": {"login": "nyl3532016"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java", "diffHunk": "@@ -380,143 +378,146 @@ public static Cell getMidpoint(final CellComparator comparator, final Cell left,\n     if (comparator instanceof MetaCellComparator) {\n       return right;\n     }\n-    int diff = comparator.compareRows(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left row sorts after right row; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n     byte[] midRow;\n     boolean bufferBacked = left instanceof ByteBufferExtendedCell\n         && right instanceof ByteBufferExtendedCell;\n-    if (diff < 0) {\n-      // Left row is < right row.\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n-            ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(),\n-            left.getRowLength(), right.getRowArray(), right.getRowOffset(), right.getRowLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n+        ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(), left.getRowLength(),\n+        right.getRowArray(), right.getRowOffset(), right.getRowLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRow(midRow);\n     }\n-    // Rows are same. Compare on families.\n-    diff = comparator.compareFamilies(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left family sorts after right family; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n-            ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n-            left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n-            right.getFamilyLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and then a mid sort family.\n+    //Rows are same. Compare on families.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n+        ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n+        left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n+        right.getFamilyLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowFamily(right, midRow, 0, midRow.length);\n     }\n     // Families are same. Compare on qualifiers.\n-    diff = comparator.compareQualifiers(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left qualifier sorts after right qualifier; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n-            ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n-            left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n-            right.getQualifierLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and family and then a mid sort qualifier.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n+        ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n+        left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n+        right.getQualifierLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowCol(right, midRow, 0, midRow.length);\n     }\n     // No opportunity for optimization. Just return right key.\n     return right;\n   }\n \n   /**\n+   * Try to get a byte array that falls between left and right as short as possible with\n+   * lexicographical order;\n+   *\n    * @return Return a new array that is between left and right and minimally\n-   *         sized else just return null as indicator that we could not create a\n-   *         mid point.\n+   *         sized else just return null if left == right.\n    */\n   private static byte[] getMinimumMidpointArray(final byte[] leftArray, final int leftOffset,\n       final int leftLength, final byte[] rightArray, final int rightOffset, final int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength\n-        && leftArray[leftOffset + diffIdx] == rightArray[rightOffset + diffIdx]) {\n-      diffIdx++;\n-    }\n-    byte[] minimumMidpointArray = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minimumMidpointArray = new byte[diffIdx + 1];\n-      System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = leftArray[leftOffset + diffIdx];\n-      if ((0xff & diffByte) < 0xff && (diffByte + 1) < (rightArray[rightOffset + diffIdx] & 0xff)) {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx);\n-        minimumMidpointArray[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      byte leftByte = leftArray[leftOffset + diffIdx];\n+      byte rightByte = rightArray[rightOffset + diffIdx];\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;\n+        return minimumMidpointArray;\n       } else {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n+        //left == right\n+        return null;\n       }\n     }\n+    //Note that left[diffIdx] can never be equal to 0xff since left < right\n+    byte[] minimumMidpointArray = new byte[diffIdx + 1];\n+    System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx + 1);\n+    minimumMidpointArray[diffIdx] = (byte) (minimumMidpointArray[diffIdx] + 1);\n     return minimumMidpointArray;\n   }\n \n+  /**\n+   * Try to create a new byte array that falls between left and right as short as possible with\n+   * lexicographical order.\n+   *\n+   * @return Return a new array that is between left and right and minimally\n+   *         sized else just return null if left == right.\n+   */\n   private static byte[] getMinimumMidpointArray(ByteBuffer left, int leftOffset, int leftLength,\n       ByteBuffer right, int rightOffset, int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength && ByteBufferUtils.toByte(left,\n-        leftOffset + diffIdx) == ByteBufferUtils.toByte(right, rightOffset + diffIdx)) {\n-      diffIdx++;\n-    }\n-    byte[] minMidpoint = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minMidpoint = new byte[diffIdx + 1];\n-      ByteBufferUtils.copyFromBufferToArray(minMidpoint, right, rightOffset, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n-      if ((0xff & diffByte) < 0xff\n-          && (diffByte + 1) < (ByteBufferUtils.toByte(right, rightOffset + diffIdx) & 0xff)) {\n-        minMidpoint = new byte[diffIdx + 1];\n-        ByteBufferUtils.copyFromBufferToArray(minMidpoint, left, leftOffset, 0, diffIdx);\n-        minMidpoint[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      int leftByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n+      int rightByte = ByteBufferUtils.toByte(right, rightOffset + diffIdx);\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        ByteBufferUtils\n+          .copyFromBufferToArray(minimumMidpointArray, right, rightOffset, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;\n+        return minimumMidpointArray;\n       } else {\n-        minMidpoint = new byte[diffIdx + 1];\n-        ByteBufferUtils.copyFromBufferToArray(minMidpoint, right, rightOffset, 0, diffIdx + 1);\n+        //left == right\n+        return null;\n       }\n     }\n-    return minMidpoint;\n+    //Note that left[diffIdx] can never be equal to 0xff since left < right", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "436329a60a477db76d21a458a857d20defe2317e"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA1MTIwNQ==", "bodyText": "The logic of composing midPoint is basically the same, with some small differences", "url": "https://github.com/apache/hbase/pull/2741#discussion_r537051205", "createdAt": "2020-12-06T14:35:34Z", "author": {"login": "GeorryHuang"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java", "diffHunk": "@@ -380,143 +378,146 @@ public static Cell getMidpoint(final CellComparator comparator, final Cell left,\n     if (comparator instanceof MetaCellComparator) {\n       return right;\n     }\n-    int diff = comparator.compareRows(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left row sorts after right row; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n     byte[] midRow;\n     boolean bufferBacked = left instanceof ByteBufferExtendedCell\n         && right instanceof ByteBufferExtendedCell;\n-    if (diff < 0) {\n-      // Left row is < right row.\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n-            ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(),\n-            left.getRowLength(), right.getRowArray(), right.getRowOffset(), right.getRowLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n+        ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(), left.getRowLength(),\n+        right.getRowArray(), right.getRowOffset(), right.getRowLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRow(midRow);\n     }\n-    // Rows are same. Compare on families.\n-    diff = comparator.compareFamilies(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left family sorts after right family; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n-            ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n-            left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n-            right.getFamilyLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and then a mid sort family.\n+    //Rows are same. Compare on families.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n+        ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n+        left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n+        right.getFamilyLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowFamily(right, midRow, 0, midRow.length);\n     }\n     // Families are same. Compare on qualifiers.\n-    diff = comparator.compareQualifiers(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left qualifier sorts after right qualifier; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n-            ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n-            left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n-            right.getQualifierLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and family and then a mid sort qualifier.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n+        ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n+        left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n+        right.getQualifierLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowCol(right, midRow, 0, midRow.length);\n     }\n     // No opportunity for optimization. Just return right key.\n     return right;\n   }\n \n   /**\n+   * Try to get a byte array that falls between left and right as short as possible with\n+   * lexicographical order;\n+   *\n    * @return Return a new array that is between left and right and minimally\n-   *         sized else just return null as indicator that we could not create a\n-   *         mid point.\n+   *         sized else just return null if left == right.\n    */\n   private static byte[] getMinimumMidpointArray(final byte[] leftArray, final int leftOffset,\n       final int leftLength, final byte[] rightArray, final int rightOffset, final int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength\n-        && leftArray[leftOffset + diffIdx] == rightArray[rightOffset + diffIdx]) {\n-      diffIdx++;\n-    }\n-    byte[] minimumMidpointArray = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minimumMidpointArray = new byte[diffIdx + 1];\n-      System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = leftArray[leftOffset + diffIdx];\n-      if ((0xff & diffByte) < 0xff && (diffByte + 1) < (rightArray[rightOffset + diffIdx] & 0xff)) {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx);\n-        minimumMidpointArray[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      byte leftByte = leftArray[leftOffset + diffIdx];\n+      byte rightByte = rightArray[rightOffset + diffIdx];\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;\n+        return minimumMidpointArray;\n       } else {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n+        //left == right\n+        return null;\n       }\n     }\n+    //Note that left[diffIdx] can never be equal to 0xff since left < right\n+    byte[] minimumMidpointArray = new byte[diffIdx + 1];\n+    System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx + 1);\n+    minimumMidpointArray[diffIdx] = (byte) (minimumMidpointArray[diffIdx] + 1);\n     return minimumMidpointArray;\n   }\n \n+  /**\n+   * Try to create a new byte array that falls between left and right as short as possible with\n+   * lexicographical order.\n+   *\n+   * @return Return a new array that is between left and right and minimally\n+   *         sized else just return null if left == right.\n+   */\n   private static byte[] getMinimumMidpointArray(ByteBuffer left, int leftOffset, int leftLength,\n       ByteBuffer right, int rightOffset, int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength && ByteBufferUtils.toByte(left,\n-        leftOffset + diffIdx) == ByteBufferUtils.toByte(right, rightOffset + diffIdx)) {\n-      diffIdx++;\n-    }\n-    byte[] minMidpoint = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minMidpoint = new byte[diffIdx + 1];\n-      ByteBufferUtils.copyFromBufferToArray(minMidpoint, right, rightOffset, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n-      if ((0xff & diffByte) < 0xff\n-          && (diffByte + 1) < (ByteBufferUtils.toByte(right, rightOffset + diffIdx) & 0xff)) {\n-        minMidpoint = new byte[diffIdx + 1];\n-        ByteBufferUtils.copyFromBufferToArray(minMidpoint, left, leftOffset, 0, diffIdx);\n-        minMidpoint[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      int leftByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n+      int rightByte = ByteBufferUtils.toByte(right, rightOffset + diffIdx);\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        ByteBufferUtils\n+          .copyFromBufferToArray(minimumMidpointArray, right, rightOffset, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;\n+        return minimumMidpointArray;\n       } else {\n-        minMidpoint = new byte[diffIdx + 1];\n-        ByteBufferUtils.copyFromBufferToArray(minMidpoint, right, rightOffset, 0, diffIdx + 1);\n+        //left == right\n+        return null;\n       }\n     }\n-    return minMidpoint;\n+    //Note that left[diffIdx] can never be equal to 0xff since left < right", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA0NTYwNA=="}, "originalCommit": {"oid": "436329a60a477db76d21a458a857d20defe2317e"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk5Mzg2Ng==", "bodyText": "(diffByte + 1) < (ByteBufferUtils.toByte(right, rightOffset + diffIdx) & 0xff)\nI think this logical branch is lost", "url": "https://github.com/apache/hbase/pull/2741#discussion_r542993866", "createdAt": "2020-12-15T02:18:33Z", "author": {"login": "nyl3532016"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java", "diffHunk": "@@ -380,143 +378,146 @@ public static Cell getMidpoint(final CellComparator comparator, final Cell left,\n     if (comparator instanceof MetaCellComparator) {\n       return right;\n     }\n-    int diff = comparator.compareRows(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left row sorts after right row; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n     byte[] midRow;\n     boolean bufferBacked = left instanceof ByteBufferExtendedCell\n         && right instanceof ByteBufferExtendedCell;\n-    if (diff < 0) {\n-      // Left row is < right row.\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n-            ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(),\n-            left.getRowLength(), right.getRowArray(), right.getRowOffset(), right.getRowLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n+        ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(), left.getRowLength(),\n+        right.getRowArray(), right.getRowOffset(), right.getRowLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRow(midRow);\n     }\n-    // Rows are same. Compare on families.\n-    diff = comparator.compareFamilies(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left family sorts after right family; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n-            ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n-            left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n-            right.getFamilyLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and then a mid sort family.\n+    //Rows are same. Compare on families.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n+        ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n+        left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n+        right.getFamilyLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowFamily(right, midRow, 0, midRow.length);\n     }\n     // Families are same. Compare on qualifiers.\n-    diff = comparator.compareQualifiers(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left qualifier sorts after right qualifier; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n-            ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n-            left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n-            right.getQualifierLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and family and then a mid sort qualifier.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n+        ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n+        left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n+        right.getQualifierLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowCol(right, midRow, 0, midRow.length);\n     }\n     // No opportunity for optimization. Just return right key.\n     return right;\n   }\n \n   /**\n+   * Try to get a byte array that falls between left and right as short as possible with\n+   * lexicographical order;\n+   *\n    * @return Return a new array that is between left and right and minimally\n-   *         sized else just return null as indicator that we could not create a\n-   *         mid point.\n+   *         sized else just return null if left == right.\n    */\n   private static byte[] getMinimumMidpointArray(final byte[] leftArray, final int leftOffset,\n       final int leftLength, final byte[] rightArray, final int rightOffset, final int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength\n-        && leftArray[leftOffset + diffIdx] == rightArray[rightOffset + diffIdx]) {\n-      diffIdx++;\n-    }\n-    byte[] minimumMidpointArray = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minimumMidpointArray = new byte[diffIdx + 1];\n-      System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = leftArray[leftOffset + diffIdx];\n-      if ((0xff & diffByte) < 0xff && (diffByte + 1) < (rightArray[rightOffset + diffIdx] & 0xff)) {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx);\n-        minimumMidpointArray[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      byte leftByte = leftArray[leftOffset + diffIdx];\n+      byte rightByte = rightArray[rightOffset + diffIdx];\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;\n+        return minimumMidpointArray;\n       } else {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n+        //left == right\n+        return null;\n       }\n     }\n+    //Note that left[diffIdx] can never be equal to 0xff since left < right\n+    byte[] minimumMidpointArray = new byte[diffIdx + 1];\n+    System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx + 1);\n+    minimumMidpointArray[diffIdx] = (byte) (minimumMidpointArray[diffIdx] + 1);\n     return minimumMidpointArray;\n   }\n \n+  /**\n+   * Try to create a new byte array that falls between left and right as short as possible with\n+   * lexicographical order.\n+   *\n+   * @return Return a new array that is between left and right and minimally\n+   *         sized else just return null if left == right.\n+   */\n   private static byte[] getMinimumMidpointArray(ByteBuffer left, int leftOffset, int leftLength,\n       ByteBuffer right, int rightOffset, int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength && ByteBufferUtils.toByte(left,\n-        leftOffset + diffIdx) == ByteBufferUtils.toByte(right, rightOffset + diffIdx)) {\n-      diffIdx++;\n-    }\n-    byte[] minMidpoint = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minMidpoint = new byte[diffIdx + 1];\n-      ByteBufferUtils.copyFromBufferToArray(minMidpoint, right, rightOffset, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n-      if ((0xff & diffByte) < 0xff\n-          && (diffByte + 1) < (ByteBufferUtils.toByte(right, rightOffset + diffIdx) & 0xff)) {\n-        minMidpoint = new byte[diffIdx + 1];\n-        ByteBufferUtils.copyFromBufferToArray(minMidpoint, left, leftOffset, 0, diffIdx);\n-        minMidpoint[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      int leftByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n+      int rightByte = ByteBufferUtils.toByte(right, rightOffset + diffIdx);\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        ByteBufferUtils\n+          .copyFromBufferToArray(minimumMidpointArray, right, rightOffset, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;\n+        return minimumMidpointArray;\n       } else {\n-        minMidpoint = new byte[diffIdx + 1];\n-        ByteBufferUtils.copyFromBufferToArray(minMidpoint, right, rightOffset, 0, diffIdx + 1);\n+        //left == right\n+        return null;\n       }\n     }\n-    return minMidpoint;\n+    //Note that left[diffIdx] can never be equal to 0xff since left < right", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA0NTYwNA=="}, "originalCommit": {"oid": "436329a60a477db76d21a458a857d20defe2317e"}, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MDY2MDA1OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQxNDowNzowMFrOIAKr8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQxNDozNDowNFrOIAK_DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA0NjAwMg==", "bodyText": "Here is different from original?", "url": "https://github.com/apache/hbase/pull/2741#discussion_r537046002", "createdAt": "2020-12-06T14:07:00Z", "author": {"login": "nyl3532016"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java", "diffHunk": "@@ -380,143 +378,146 @@ public static Cell getMidpoint(final CellComparator comparator, final Cell left,\n     if (comparator instanceof MetaCellComparator) {\n       return right;\n     }\n-    int diff = comparator.compareRows(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left row sorts after right row; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n     byte[] midRow;\n     boolean bufferBacked = left instanceof ByteBufferExtendedCell\n         && right instanceof ByteBufferExtendedCell;\n-    if (diff < 0) {\n-      // Left row is < right row.\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n-            ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(),\n-            left.getRowLength(), right.getRowArray(), right.getRowOffset(), right.getRowLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n+        ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(), left.getRowLength(),\n+        right.getRowArray(), right.getRowOffset(), right.getRowLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRow(midRow);\n     }\n-    // Rows are same. Compare on families.\n-    diff = comparator.compareFamilies(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left family sorts after right family; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n-            ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n-            left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n-            right.getFamilyLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and then a mid sort family.\n+    //Rows are same. Compare on families.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n+        ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n+        left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n+        right.getFamilyLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowFamily(right, midRow, 0, midRow.length);\n     }\n     // Families are same. Compare on qualifiers.\n-    diff = comparator.compareQualifiers(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left qualifier sorts after right qualifier; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n-            ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n-            left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n-            right.getQualifierLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and family and then a mid sort qualifier.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n+        ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n+        left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n+        right.getQualifierLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowCol(right, midRow, 0, midRow.length);\n     }\n     // No opportunity for optimization. Just return right key.\n     return right;\n   }\n \n   /**\n+   * Try to get a byte array that falls between left and right as short as possible with\n+   * lexicographical order;\n+   *\n    * @return Return a new array that is between left and right and minimally\n-   *         sized else just return null as indicator that we could not create a\n-   *         mid point.\n+   *         sized else just return null if left == right.\n    */\n   private static byte[] getMinimumMidpointArray(final byte[] leftArray, final int leftOffset,\n       final int leftLength, final byte[] rightArray, final int rightOffset, final int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength\n-        && leftArray[leftOffset + diffIdx] == rightArray[rightOffset + diffIdx]) {\n-      diffIdx++;\n-    }\n-    byte[] minimumMidpointArray = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minimumMidpointArray = new byte[diffIdx + 1];\n-      System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = leftArray[leftOffset + diffIdx];\n-      if ((0xff & diffByte) < 0xff && (diffByte + 1) < (rightArray[rightOffset + diffIdx] & 0xff)) {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx);\n-        minimumMidpointArray[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      byte leftByte = leftArray[leftOffset + diffIdx];\n+      byte rightByte = rightArray[rightOffset + diffIdx];\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;\n+        return minimumMidpointArray;\n       } else {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n+        //left == right\n+        return null;\n       }\n     }\n+    //Note that left[diffIdx] can never be equal to 0xff since left < right\n+    byte[] minimumMidpointArray = new byte[diffIdx + 1];\n+    System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx + 1);\n+    minimumMidpointArray[diffIdx] = (byte) (minimumMidpointArray[diffIdx] + 1);\n     return minimumMidpointArray;\n   }\n \n+  /**\n+   * Try to create a new byte array that falls between left and right as short as possible with\n+   * lexicographical order.\n+   *\n+   * @return Return a new array that is between left and right and minimally\n+   *         sized else just return null if left == right.\n+   */\n   private static byte[] getMinimumMidpointArray(ByteBuffer left, int leftOffset, int leftLength,\n       ByteBuffer right, int rightOffset, int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength && ByteBufferUtils.toByte(left,\n-        leftOffset + diffIdx) == ByteBufferUtils.toByte(right, rightOffset + diffIdx)) {\n-      diffIdx++;\n-    }\n-    byte[] minMidpoint = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minMidpoint = new byte[diffIdx + 1];\n-      ByteBufferUtils.copyFromBufferToArray(minMidpoint, right, rightOffset, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n-      if ((0xff & diffByte) < 0xff\n-          && (diffByte + 1) < (ByteBufferUtils.toByte(right, rightOffset + diffIdx) & 0xff)) {\n-        minMidpoint = new byte[diffIdx + 1];\n-        ByteBufferUtils.copyFromBufferToArray(minMidpoint, left, leftOffset, 0, diffIdx);\n-        minMidpoint[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      int leftByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n+      int rightByte = ByteBufferUtils.toByte(right, rightOffset + diffIdx);\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        ByteBufferUtils\n+          .copyFromBufferToArray(minimumMidpointArray, right, rightOffset, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "436329a60a477db76d21a458a857d20defe2317e"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA1MDg5Mg==", "bodyText": "Yes, I made some adjustments.", "url": "https://github.com/apache/hbase/pull/2741#discussion_r537050892", "createdAt": "2020-12-06T14:34:04Z", "author": {"login": "GeorryHuang"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java", "diffHunk": "@@ -380,143 +378,146 @@ public static Cell getMidpoint(final CellComparator comparator, final Cell left,\n     if (comparator instanceof MetaCellComparator) {\n       return right;\n     }\n-    int diff = comparator.compareRows(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left row sorts after right row; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n     byte[] midRow;\n     boolean bufferBacked = left instanceof ByteBufferExtendedCell\n         && right instanceof ByteBufferExtendedCell;\n-    if (diff < 0) {\n-      // Left row is < right row.\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n-            ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(),\n-            left.getRowLength(), right.getRowArray(), right.getRowOffset(), right.getRowLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n+        ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(), left.getRowLength(),\n+        right.getRowArray(), right.getRowOffset(), right.getRowLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRow(midRow);\n     }\n-    // Rows are same. Compare on families.\n-    diff = comparator.compareFamilies(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left family sorts after right family; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n-            ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n-            left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n-            right.getFamilyLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and then a mid sort family.\n+    //Rows are same. Compare on families.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n+        ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n+        left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n+        right.getFamilyLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowFamily(right, midRow, 0, midRow.length);\n     }\n     // Families are same. Compare on qualifiers.\n-    diff = comparator.compareQualifiers(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left qualifier sorts after right qualifier; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n-            ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n-            left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n-            right.getQualifierLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and family and then a mid sort qualifier.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n+        ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n+        left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n+        right.getQualifierLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowCol(right, midRow, 0, midRow.length);\n     }\n     // No opportunity for optimization. Just return right key.\n     return right;\n   }\n \n   /**\n+   * Try to get a byte array that falls between left and right as short as possible with\n+   * lexicographical order;\n+   *\n    * @return Return a new array that is between left and right and minimally\n-   *         sized else just return null as indicator that we could not create a\n-   *         mid point.\n+   *         sized else just return null if left == right.\n    */\n   private static byte[] getMinimumMidpointArray(final byte[] leftArray, final int leftOffset,\n       final int leftLength, final byte[] rightArray, final int rightOffset, final int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength\n-        && leftArray[leftOffset + diffIdx] == rightArray[rightOffset + diffIdx]) {\n-      diffIdx++;\n-    }\n-    byte[] minimumMidpointArray = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minimumMidpointArray = new byte[diffIdx + 1];\n-      System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = leftArray[leftOffset + diffIdx];\n-      if ((0xff & diffByte) < 0xff && (diffByte + 1) < (rightArray[rightOffset + diffIdx] & 0xff)) {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx);\n-        minimumMidpointArray[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      byte leftByte = leftArray[leftOffset + diffIdx];\n+      byte rightByte = rightArray[rightOffset + diffIdx];\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;\n+        return minimumMidpointArray;\n       } else {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n+        //left == right\n+        return null;\n       }\n     }\n+    //Note that left[diffIdx] can never be equal to 0xff since left < right\n+    byte[] minimumMidpointArray = new byte[diffIdx + 1];\n+    System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx + 1);\n+    minimumMidpointArray[diffIdx] = (byte) (minimumMidpointArray[diffIdx] + 1);\n     return minimumMidpointArray;\n   }\n \n+  /**\n+   * Try to create a new byte array that falls between left and right as short as possible with\n+   * lexicographical order.\n+   *\n+   * @return Return a new array that is between left and right and minimally\n+   *         sized else just return null if left == right.\n+   */\n   private static byte[] getMinimumMidpointArray(ByteBuffer left, int leftOffset, int leftLength,\n       ByteBuffer right, int rightOffset, int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength && ByteBufferUtils.toByte(left,\n-        leftOffset + diffIdx) == ByteBufferUtils.toByte(right, rightOffset + diffIdx)) {\n-      diffIdx++;\n-    }\n-    byte[] minMidpoint = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minMidpoint = new byte[diffIdx + 1];\n-      ByteBufferUtils.copyFromBufferToArray(minMidpoint, right, rightOffset, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n-      if ((0xff & diffByte) < 0xff\n-          && (diffByte + 1) < (ByteBufferUtils.toByte(right, rightOffset + diffIdx) & 0xff)) {\n-        minMidpoint = new byte[diffIdx + 1];\n-        ByteBufferUtils.copyFromBufferToArray(minMidpoint, left, leftOffset, 0, diffIdx);\n-        minMidpoint[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      int leftByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n+      int rightByte = ByteBufferUtils.toByte(right, rightOffset + diffIdx);\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        ByteBufferUtils\n+          .copyFromBufferToArray(minimumMidpointArray, right, rightOffset, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA0NjAwMg=="}, "originalCommit": {"oid": "436329a60a477db76d21a458a857d20defe2317e"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTY2MjA4OnYy", "diffSide": "LEFT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0Mzo0N1rOIA1Fsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0Mzo0N1rOIA1Fsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0MDcyMg==", "bodyText": "From HBASE-10800 ... By our Ramkrishna", "url": "https://github.com/apache/hbase/pull/2741#discussion_r537740722", "createdAt": "2020-12-07T18:43:47Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java", "diffHunk": "@@ -366,8 +366,6 @@ private void finishBlock() throws IOException {\n    */\n   public static Cell getMidpoint(final CellComparator comparator, final Cell left,\n       final Cell right) {\n-    // TODO: Redo so only a single pass over the arrays rather than one to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "436329a60a477db76d21a458a857d20defe2317e"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2324, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}