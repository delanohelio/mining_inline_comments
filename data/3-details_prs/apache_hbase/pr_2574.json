{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3OTQ5NjQx", "number": 2574, "title": "HBASE-25212 Optionally abort requests in progress after deciding a region should close", "bodyText": "If hbase.regionserver.close.wait.abort is set to true, interrupt RPC\nhandler threads holding the region close lock.\nUntil requests in progress can be aborted, wait on the region close lock\nfor a configurable interval (specified by hbase.regionserver.close.wait.time,\nin ms). If we have failed to acquire the close lock after this interval\nelapses, if allowed (also specified by hbase.regionserver.close.wait.abort),\nabort the regionserver.\nDefine a subset of region operations as interruptable. Track threads holding\nthe close lock transiting those operations. Set the thread interrupt status\nof tracked threads when trying to close the region. Use the thread interrupt\nstatus where safe to break out of request processing.", "createdAt": "2020-10-22T01:13:23Z", "url": "https://github.com/apache/hbase/pull/2574", "merged": true, "mergeCommit": {"oid": "c98e993b238f527fb8cdc7f8a03a3555bb1dc74a"}, "closed": true, "closedAt": "2020-11-03T23:20:28Z", "author": {"login": "apurtell"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdU4qVtgFqTUxNDMxNDM5Nw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdY-_-0gBqjM5NTQ2MzIwOTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MzE0Mzk3", "url": "https://github.com/apache/hbase/pull/2574#pullrequestreview-514314397", "createdAt": "2020-10-22T02:22:22Z", "commit": {"oid": "57ef804122a4ad7242489337a4c1e643ea27ed0c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMjoyMjoyM1rOHmOM_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMjozNjoyNlrOHmOblg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MDYzNw==", "bodyText": "Better make it return an exception and make here 'throw throwOnInterrupt(e)' so the compiler will know that this is an exit point.", "url": "https://github.com/apache/hbase/pull/2574#discussion_r509840637", "createdAt": "2020-10-22T02:22:23Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -1174,7 +1178,7 @@ public HStore call() throws IOException {\n           LOG.info(\"Setting FlushNonSloppyStoresFirstPolicy for the region=\" + this);\n         }\n       } catch (InterruptedException e) {\n-        throw (InterruptedIOException)new InterruptedIOException().initCause(e);\n+        throwOnInterrupt(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57ef804122a4ad7242489337a4c1e643ea27ed0c"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MTY2Mg==", "bodyText": "Pity we need to repeat this call many times in the same method...", "url": "https://github.com/apache/hbase/pull/2574#discussion_r509841662", "createdAt": "2020-10-22T02:26:23Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -4550,6 +4619,10 @@ private void doMiniBatchMutate(BatchOperation<?> batchOp) throws IOException {\n     /** Keep track of the locks we hold so we can release them in finally clause */\n     List<RowLock> acquiredRowLocks = Lists.newArrayListWithCapacity(batchOp.size());\n     try {\n+      // Check for thread interrupt status in case we have been signaled from\n+      // #interruptRegionOperation.\n+      checkInterrupt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57ef804122a4ad7242489337a4c1e643ea27ed0c"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MTkyMQ==", "bodyText": "Here the interrupt may come from the checkInterrupt call, not acquire lock?", "url": "https://github.com/apache/hbase/pull/2574#discussion_r509841921", "createdAt": "2020-10-22T02:27:11Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -6588,8 +6677,10 @@ protected RowLock getRowLockInternal(byte[] row, boolean readLock, final RowLock\n       success = true;\n       return result;\n     } catch (InterruptedException ie) {\n-      LOG.warn(\"Thread interrupted waiting for lock on row: {}, in region {}\", rowKey,\n-        getRegionInfo().getRegionNameAsString());\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Thread interrupted waiting for lock on row: {}, in region {}\", rowKey,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57ef804122a4ad7242489337a4c1e643ea27ed0c"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MzA0NQ==", "bodyText": "Maybe we could just use Collections.newSetFromMap(new ConcurrentHashMap<>()) here?", "url": "https://github.com/apache/hbase/pull/2574#discussion_r509843045", "createdAt": "2020-10-22T02:31:22Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -8748,6 +8863,11 @@ public void startRegionOperation(Operation op) throws IOException {\n       throw new NotServingRegionException(getRegionInfo().getRegionNameAsString() + \" is closing\");\n     }\n     lock(lock.readLock());\n+    // Update regionLockHolders ONLY for any startRegionOperation call that is invoked from an RPC handler\n+    Thread thisThread = Thread.currentThread();\n+    if (isInterruptableOp) {\n+      regionLockHolders.put(thisThread.hashCode(), thisThread);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57ef804122a4ad7242489337a4c1e643ea27ed0c"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0Mzg0Mg==", "bodyText": "Usually we do not add this to a single test as we have a test timeout for the whole test file.", "url": "https://github.com/apache/hbase/pull/2574#discussion_r509843842", "createdAt": "2020-10-22T02:34:27Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java", "diffHunk": "@@ -7364,4 +7367,154 @@ protected HStoreForTesting(final HRegion region,\n       return super.doCompaction(cr, filesToCompact, user, compactionStartTime, newFiles);\n     }\n   }\n+\n+  @Test(timeout=20000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57ef804122a4ad7242489337a4c1e643ea27ed0c"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0NDE5MQ==", "bodyText": "Use the config from the HBTU? Maybe new Configuration(TEST_UTIL.getConfiguration())", "url": "https://github.com/apache/hbase/pull/2574#discussion_r509844191", "createdAt": "2020-10-22T02:35:46Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java", "diffHunk": "@@ -7364,4 +7367,154 @@ protected HStoreForTesting(final HRegion region,\n       return super.doCompaction(cr, filesToCompact, user, compactionStartTime, newFiles);\n     }\n   }\n+\n+  @Test(timeout=20000)\n+  public void testCloseNoInterrupt() throws Exception {\n+    byte[] cf1 = Bytes.toBytes(\"CF1\");\n+    byte[][] families = { cf1 };\n+\n+    Configuration conf = HBaseConfiguration.create();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57ef804122a4ad7242489337a4c1e643ea27ed0c"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0NDM3NA==", "bodyText": "Just use TableNameTestRule.", "url": "https://github.com/apache/hbase/pull/2574#discussion_r509844374", "createdAt": "2020-10-22T02:36:26Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRegionInterrupt.java", "diffHunk": "@@ -0,0 +1,357 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.regionserver;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseTestingUtility;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.NotServingRegionException;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.Waiter;\n+import org.apache.hadoop.hbase.client.Admin;\n+import org.apache.hadoop.hbase.client.Append;\n+import org.apache.hadoop.hbase.client.BufferedMutator;\n+import org.apache.hadoop.hbase.client.ColumnFamilyDescriptorBuilder;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Durability;\n+import org.apache.hadoop.hbase.client.Increment;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.RetriesExhaustedWithDetailsException;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.client.TableDescriptor;\n+import org.apache.hadoop.hbase.client.TableDescriptorBuilder;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.RegionCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.coprocessor.RegionObserver;\n+import org.apache.hadoop.hbase.exceptions.DeserializationException;\n+import org.apache.hadoop.hbase.filter.FilterBase;\n+import org.apache.hadoop.hbase.testclassification.LargeTests;\n+import org.apache.hadoop.hbase.testclassification.RegionServerTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALEdit;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.TestName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Category({RegionServerTests.class, LargeTests.class})\n+public class TestRegionInterrupt {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule CLASS_RULE =\n+    HBaseClassTestRule.forClass(TestRegionInterrupt.class);\n+\n+  private static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();\n+  private static final Logger LOG = LoggerFactory.getLogger(TestRegionInterrupt.class);\n+\n+  static final int SLEEP_TIME = 10 * 1000;\n+  static final byte[] FAMILY = Bytes.toBytes(\"info\");\n+\n+  @Rule\n+  public TestName name = new TestName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57ef804122a4ad7242489337a4c1e643ea27ed0c"}, "originalPosition": 90}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MzQxMjgz", "url": "https://github.com/apache/hbase/pull/2574#pullrequestreview-514341283", "createdAt": "2020-10-22T03:52:43Z", "commit": {"oid": "57ef804122a4ad7242489337a4c1e643ea27ed0c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMzo1Mjo0M1rOHmPohQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMzo1Mjo0M1rOHmPohQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg2NDA2OQ==", "bodyText": "+1", "url": "https://github.com/apache/hbase/pull/2574#discussion_r509864069", "createdAt": "2020-10-22T03:52:43Z", "author": {"login": "bharathv"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -8748,6 +8863,11 @@ public void startRegionOperation(Operation op) throws IOException {\n       throw new NotServingRegionException(getRegionInfo().getRegionNameAsString() + \" is closing\");\n     }\n     lock(lock.readLock());\n+    // Update regionLockHolders ONLY for any startRegionOperation call that is invoked from an RPC handler\n+    Thread thisThread = Thread.currentThread();\n+    if (isInterruptableOp) {\n+      regionLockHolders.put(thisThread.hashCode(), thisThread);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MzA0NQ=="}, "originalCommit": {"oid": "57ef804122a4ad7242489337a4c1e643ea27ed0c"}, "originalPosition": 293}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "57ef804122a4ad7242489337a4c1e643ea27ed0c", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/57ef804122a4ad7242489337a4c1e643ea27ed0c", "committedDate": "2020-10-22T01:11:47Z", "message": "HBASE-25212 Optionally abort requests in progress after deciding a region should close\n\nIf hbase.regionserver.close.wait.abort is set to true, interrupt RPC\nhandler threads holding the region close lock.\n\nUntil requests in progress can be aborted, wait on the region close lock\nfor a configurable interval (specified by hbase.regionserver.close.wait.time,\nin ms). If we have failed to acquire the close lock after this interval\nelapses, if allowed (also specified by hbase.regionserver.close.wait.abort),\nabort the regionserver.\n\nDefine a subset of region operations as interruptable. Track threads holding\nthe close lock transiting those operations. Set the thread interrupt status\nof tracked threads when trying to close the region. Use the thread interrupt\nstatus where safe to break out of request processing."}, "afterCommit": {"oid": "b5b6a9032e145daaf3aa3fc7ae2d0cd0a47e1c9f", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/b5b6a9032e145daaf3aa3fc7ae2d0cd0a47e1c9f", "committedDate": "2020-10-22T19:23:31Z", "message": "Address review feedback\n\n- Address review feedback\n- Fix spotbugs warnings\n- Fix checkstyle nit\n- Fix new unit tests, missed a needed HTU change for master branch\n- Fix more unit tests after HTU change\n- Reduce chance of race conditions in new TestHRegion units by joining on lock holder"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bccfabf497fc2300de83189c859e0bc2912c4a2e", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/bccfabf497fc2300de83189c859e0bc2912c4a2e", "committedDate": "2020-10-22T21:42:01Z", "message": "Fix more checkstyle nits"}, "afterCommit": {"oid": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a", "committedDate": "2020-10-23T17:35:38Z", "message": "Set HRegion#DEFAULT_CLOSE_WAIT_ABORT to true"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2ODI5NTky", "url": "https://github.com/apache/hbase/pull/2574#pullrequestreview-516829592", "createdAt": "2020-10-26T14:24:52Z", "commit": {"oid": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNDoyNDo1MlrOHoR-AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTozMzo1MlrOHoVWMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5OTQ4OQ==", "bodyText": "nit: Instead of using holderInterrupted, maybe we can throw AssertionError with message that holder should not have been interrupted?", "url": "https://github.com/apache/hbase/pull/2574#discussion_r511999489", "createdAt": "2020-10-26T14:24:52Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java", "diffHunk": "@@ -7364,4 +7366,157 @@ protected HStoreForTesting(final HRegion region,\n       return super.doCompaction(cr, filesToCompact, user, compactionStartTime, newFiles);\n     }\n   }\n+\n+  @Test\n+  public void testCloseNoInterrupt() throws Exception {\n+    byte[] cf1 = Bytes.toBytes(\"CF1\");\n+    byte[][] families = { cf1 };\n+\n+    Configuration conf = new Configuration(CONF);\n+    // Disable close thread interrupt and server abort behavior\n+    conf.setBoolean(HRegion.CLOSE_WAIT_ABORT, false);\n+    region = initHRegion(tableName, method, conf, families);\n+\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    final AtomicBoolean holderInterrupted = new AtomicBoolean();\n+    Thread holder = new Thread(new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          LOG.info(\"Starting region operation holder\");\n+          region.startRegionOperation(Operation.SCAN);\n+          latch.countDown();\n+          try {\n+            Thread.sleep(10*1000);\n+          } catch (InterruptedException e) {\n+            LOG.info(\"Interrupted\");\n+            holderInterrupted.set(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwNjYwOA==", "bodyText": "nit: if the only usage is to find diff b/ end and start, directly using System.currentTimeMillis() might be preferred option?", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512006608", "createdAt": "2020-10-26T14:33:42Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java", "diffHunk": "@@ -7364,4 +7366,157 @@ protected HStoreForTesting(final HRegion region,\n       return super.doCompaction(cr, filesToCompact, user, compactionStartTime, newFiles);\n     }\n   }\n+\n+  @Test\n+  public void testCloseNoInterrupt() throws Exception {\n+    byte[] cf1 = Bytes.toBytes(\"CF1\");\n+    byte[][] families = { cf1 };\n+\n+    Configuration conf = new Configuration(CONF);\n+    // Disable close thread interrupt and server abort behavior\n+    conf.setBoolean(HRegion.CLOSE_WAIT_ABORT, false);\n+    region = initHRegion(tableName, method, conf, families);\n+\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    final AtomicBoolean holderInterrupted = new AtomicBoolean();\n+    Thread holder = new Thread(new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          LOG.info(\"Starting region operation holder\");\n+          region.startRegionOperation(Operation.SCAN);\n+          latch.countDown();\n+          try {\n+            Thread.sleep(10*1000);\n+          } catch (InterruptedException e) {\n+            LOG.info(\"Interrupted\");\n+            holderInterrupted.set(true);\n+          }\n+        } catch (Exception e) {\n+          throw new RuntimeException(e);\n+        } finally {\n+          try {\n+            region.closeRegionOperation();\n+          } catch (IOException e) {\n+          }\n+          LOG.info(\"Stopped region operation holder\");\n+        }\n+      }\n+    });\n+\n+    holder.start();\n+    latch.await();\n+    region.close();\n+    holder.join();\n+    region = null;\n+\n+    assertFalse(\"Region lock holder should not have been interrupted\", holderInterrupted.get());\n+  }\n+\n+  @Test\n+  public void testCloseInterrupt() throws Exception {\n+    byte[] cf1 = Bytes.toBytes(\"CF1\");\n+    byte[][] families = { cf1 };\n+\n+    Configuration conf = new Configuration(CONF);\n+    // Enable close thread interrupt and server abort behavior\n+    conf.setBoolean(HRegion.CLOSE_WAIT_ABORT, true);\n+    region = initHRegion(tableName, method, conf, families);\n+\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    final AtomicBoolean holderInterrupted = new AtomicBoolean();\n+    Thread holder = new Thread(new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          LOG.info(\"Starting region operation holder\");\n+          region.startRegionOperation(Operation.SCAN);\n+          latch.countDown();\n+          try {\n+            Thread.sleep(10*1000);\n+          } catch (InterruptedException e) {\n+            LOG.info(\"Interrupted\");\n+            holderInterrupted.set(true);\n+          }\n+        } catch (Exception e) {\n+          throw new RuntimeException(e);\n+        } finally {\n+          try {\n+            region.closeRegionOperation();\n+          } catch (IOException e) {\n+          }\n+          LOG.info(\"Stopped region operation holder\");\n+        }\n+      }\n+    });\n+\n+    holder.start();\n+    latch.await();\n+    region.close();\n+    holder.join();\n+    region = null;\n+\n+    assertTrue(\"Region lock holder was not interrupted\", holderInterrupted.get());\n+  }\n+\n+  @Test\n+  public void testCloseAbort() throws Exception {\n+    byte[] cf1 = Bytes.toBytes(\"CF1\");\n+    byte[][] families = { cf1 };\n+\n+    Configuration conf = new Configuration(CONF);\n+    // Enable close thread interrupt and server abort behavior\n+    // Set the close lock acquisition wait time to 5 seconds\n+    conf.setBoolean(HRegion.CLOSE_WAIT_ABORT, true);\n+    conf.setInt(HRegion.CLOSE_WAIT_TIME, 5*1000);\n+    region = initHRegion(tableName, method, conf, families);\n+    RegionServerServices rsServices = mock(RegionServerServices.class);\n+    region.rsServices = rsServices;\n+\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    Thread holder = new Thread(new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          LOG.info(\"Starting region operation holder\");\n+          region.startRegionOperation(Operation.SCAN);\n+          latch.countDown();\n+          // Hold the lock for 10 seconds no matter how many times we are interrupted\n+          int timeRemaining = 10 * 1000;\n+          while (timeRemaining > 0) {\n+            long start = EnvironmentEdgeManager.currentTime();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a"}, "originalPosition": 315}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxODU0MA==", "bodyText": "Although this is not an atomic operation on volatile, but we are just converting it's own value in sec to ms, hence we should be good here.", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512018540", "createdAt": "2020-10-26T14:48:32Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -1679,22 +1688,82 @@ public void setTimeoutForWriteLock(long timeoutForWriteLock) {\n       }\n     }\n \n-    if (timeoutForWriteLock == null\n-        || timeoutForWriteLock == Long.MAX_VALUE) {\n-      // block waiting for the lock for closing\n-      lock.writeLock().lock(); // FindBugs: Complains UL_UNRELEASED_LOCK_EXCEPTION_PATH but seems fine\n+    // Set the closing flag\n+    // From this point new arrivals at the region lock will get NSRE.\n+\n+    this.closing.set(true);\n+    LOG.info(\"Closing region {}\", this);\n+\n+    // Acquire the close lock\n+\n+    // The configuration parameter CLOSE_WAIT_ABORT is overloaded to enable both\n+    // the new regionserver abort condition and interrupts for running requests.\n+    // If CLOSE_WAIT_ABORT is not enabled there is no change from earlier behavior,\n+    // we will not attempt to interrupt threads servicing requests nor crash out\n+    // the regionserver if something remains stubborn.\n+\n+    boolean canAbort = conf.getBoolean(CLOSE_WAIT_ABORT, DEFAULT_CLOSE_WAIT_ABORT);\n+    boolean useTimedWait = false;\n+    if (timeoutForWriteLock == null || timeoutForWriteLock == Long.MAX_VALUE) {\n+      if (canAbort) {\n+        timeoutForWriteLock = conf.getLong(CLOSE_WAIT_TIME, DEFAULT_CLOSE_WAIT_TIME);\n+        useTimedWait = true;\n+      }\n     } else {\n+      // convert legacy use of timeoutForWriteLock in seconds to new use in millis\n+      timeoutForWriteLock = TimeUnit.SECONDS.toMillis(timeoutForWriteLock);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzMzYxNQ==", "bodyText": "nit: we can remove NSRE here", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512033615", "createdAt": "2020-10-26T15:07:11Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -8793,7 +8921,7 @@ public void closeRegionOperation(Operation operation) throws IOException {\n    * @throws InterruptedIOException if interrupted while waiting for a lock\n    */\n   private void startBulkRegionOperation(boolean writeLockNeeded)\n-      throws NotServingRegionException, RegionTooBusyException, InterruptedIOException {\n+      throws NotServingRegionException, IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzNTUxOA==", "bodyText": "maybe Waiting can be replaced with Waiting without time limit ?", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512035518", "createdAt": "2020-10-26T15:09:38Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -1679,22 +1688,82 @@ public void setTimeoutForWriteLock(long timeoutForWriteLock) {\n       }\n     }\n \n-    if (timeoutForWriteLock == null\n-        || timeoutForWriteLock == Long.MAX_VALUE) {\n-      // block waiting for the lock for closing\n-      lock.writeLock().lock(); // FindBugs: Complains UL_UNRELEASED_LOCK_EXCEPTION_PATH but seems fine\n+    // Set the closing flag\n+    // From this point new arrivals at the region lock will get NSRE.\n+\n+    this.closing.set(true);\n+    LOG.info(\"Closing region {}\", this);\n+\n+    // Acquire the close lock\n+\n+    // The configuration parameter CLOSE_WAIT_ABORT is overloaded to enable both\n+    // the new regionserver abort condition and interrupts for running requests.\n+    // If CLOSE_WAIT_ABORT is not enabled there is no change from earlier behavior,\n+    // we will not attempt to interrupt threads servicing requests nor crash out\n+    // the regionserver if something remains stubborn.\n+\n+    boolean canAbort = conf.getBoolean(CLOSE_WAIT_ABORT, DEFAULT_CLOSE_WAIT_ABORT);\n+    boolean useTimedWait = false;\n+    if (timeoutForWriteLock == null || timeoutForWriteLock == Long.MAX_VALUE) {\n+      if (canAbort) {\n+        timeoutForWriteLock = conf.getLong(CLOSE_WAIT_TIME, DEFAULT_CLOSE_WAIT_TIME);\n+        useTimedWait = true;\n+      }\n     } else {\n+      // convert legacy use of timeoutForWriteLock in seconds to new use in millis\n+      timeoutForWriteLock = TimeUnit.SECONDS.toMillis(timeoutForWriteLock);\n+      useTimedWait = true;\n+    }\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug((useTimedWait ? \"Time limited wait\" : \"Waiting\") + \" for close lock on \" + this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MTc5NQ==", "bodyText": "nit: put these lines by mistake? :)", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512041795", "createdAt": "2020-10-26T15:17:37Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -9000,6 +9129,49 @@ public long getReadPoint() {\n     return getReadPoint(IsolationLevel.READ_COMMITTED);\n   }\n \n+  /**\n+   * Interrupt any region options that have acquired the region lock via\n+   * {@link #startRegionOperation(org.apache.hadoop.hbase.regionserver.Region.Operation)},\n+   * or {@link #startBulkRegionOperation(boolean)}.\n+   */\n+  private void interruptRegionOperations() {\n+    for (Thread t: regionLockHolders) {\n+      t.interrupt();\n+    }\n+  }\n+\n+  /**\n+   * Check thread interrupt status and throw an exception if interrupted.\n+   * @throws NotServingRegionException if region is closing\n+   * @throws InterruptedIOException if interrupted but region is not closing\n+   */\n+  // Package scope for tests\n+  void checkInterrupt() throws NotServingRegionException, InterruptedIOException {\n+    if (Thread.interrupted()) {\n+      if (this.closing.get()) {\n+        throw new NotServingRegionException(\n+          getRegionInfo().getRegionNameAsString() + \" is closing\");\n+      }\n+      throw new InterruptedIOException();\n+    }\n+  }\n+\n+  /**\n+   * Throw the correct exception upon interrupt\n+   * @param t cause\n+   * @throws NotServingRegionException if region is closing\n+   * @throws InterruptedIOException in all cases except if region is closing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a"}, "originalPosition": 425}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0NjI2Nw==", "bodyText": "Similar to how we passed conf all the way from HBaseTestingUtility methods to actual HRegion instance, we can also pass rsServices instance in same methods and we won't have to worry about changing this to non-final, but not a strong opinion if this means too many args in testing utility methods so it's upto you.", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512046267", "createdAt": "2020-10-26T15:23:15Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -688,14 +688,17 @@ void sawNoSuchFamily() {\n   // Last flush time for each Store. Useful when we are flushing for each column\n   private final ConcurrentMap<HStore, Long> lastStoreFlushTimeMap = new ConcurrentHashMap<>();\n \n-  final RegionServerServices rsServices;\n+  protected RegionServerServices rsServices;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MDcwOQ==", "bodyText": "Test category LargeTests will take care of timeouts so we can remove all timeout from individual tests.", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512050709", "createdAt": "2020-10-26T15:28:39Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRegionInterrupt.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.regionserver;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseTestingUtility;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.NotServingRegionException;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.TableNameTestRule;\n+import org.apache.hadoop.hbase.Waiter;\n+import org.apache.hadoop.hbase.client.Admin;\n+import org.apache.hadoop.hbase.client.Append;\n+import org.apache.hadoop.hbase.client.BufferedMutator;\n+import org.apache.hadoop.hbase.client.ColumnFamilyDescriptorBuilder;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Durability;\n+import org.apache.hadoop.hbase.client.Increment;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.client.TableDescriptor;\n+import org.apache.hadoop.hbase.client.TableDescriptorBuilder;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.RegionCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.coprocessor.RegionObserver;\n+import org.apache.hadoop.hbase.exceptions.DeserializationException;\n+import org.apache.hadoop.hbase.filter.FilterBase;\n+import org.apache.hadoop.hbase.testclassification.LargeTests;\n+import org.apache.hadoop.hbase.testclassification.RegionServerTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALEdit;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Category({RegionServerTests.class, LargeTests.class})\n+public class TestRegionInterrupt {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule CLASS_RULE =\n+    HBaseClassTestRule.forClass(TestRegionInterrupt.class);\n+\n+  private static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();\n+  private static final Logger LOG = LoggerFactory.getLogger(TestRegionInterrupt.class);\n+\n+  static final int SLEEP_TIME = 10 * 1000;\n+  static final byte[] FAMILY = Bytes.toBytes(\"info\");\n+\n+  @Rule\n+  public TableNameTestRule name = new TableNameTestRule();\n+\n+  @BeforeClass\n+  public static void setUpBeforeClass() throws Exception {\n+    Configuration conf = TEST_UTIL.getConfiguration();\n+    conf.setClass(HConstants.REGION_IMPL, InterruptInterceptingHRegion.class, Region.class);\n+    conf.setBoolean(HRegion.CLOSE_WAIT_ABORT, true);\n+    conf.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER, 1);\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    TEST_UTIL.startMiniCluster();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    TEST_UTIL.shutdownMiniCluster();\n+  }\n+\n+  @Test(timeout=120000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1NDgzNQ==", "bodyText": "We don't want to restrict 5 min of wait time by updating CLOSE_WAIT_TIME ?", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512054835", "createdAt": "2020-10-26T15:33:52Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRegionInterrupt.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.regionserver;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseTestingUtility;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.NotServingRegionException;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.TableNameTestRule;\n+import org.apache.hadoop.hbase.Waiter;\n+import org.apache.hadoop.hbase.client.Admin;\n+import org.apache.hadoop.hbase.client.Append;\n+import org.apache.hadoop.hbase.client.BufferedMutator;\n+import org.apache.hadoop.hbase.client.ColumnFamilyDescriptorBuilder;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Durability;\n+import org.apache.hadoop.hbase.client.Increment;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.client.TableDescriptor;\n+import org.apache.hadoop.hbase.client.TableDescriptorBuilder;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.RegionCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.coprocessor.RegionObserver;\n+import org.apache.hadoop.hbase.exceptions.DeserializationException;\n+import org.apache.hadoop.hbase.filter.FilterBase;\n+import org.apache.hadoop.hbase.testclassification.LargeTests;\n+import org.apache.hadoop.hbase.testclassification.RegionServerTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALEdit;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Category({RegionServerTests.class, LargeTests.class})\n+public class TestRegionInterrupt {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule CLASS_RULE =\n+    HBaseClassTestRule.forClass(TestRegionInterrupt.class);\n+\n+  private static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();\n+  private static final Logger LOG = LoggerFactory.getLogger(TestRegionInterrupt.class);\n+\n+  static final int SLEEP_TIME = 10 * 1000;\n+  static final byte[] FAMILY = Bytes.toBytes(\"info\");\n+\n+  @Rule\n+  public TableNameTestRule name = new TableNameTestRule();\n+\n+  @BeforeClass\n+  public static void setUpBeforeClass() throws Exception {\n+    Configuration conf = TEST_UTIL.getConfiguration();\n+    conf.setClass(HConstants.REGION_IMPL, InterruptInterceptingHRegion.class, Region.class);\n+    conf.setBoolean(HRegion.CLOSE_WAIT_ABORT, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a"}, "originalPosition": 95}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a", "committedDate": "2020-10-23T17:35:38Z", "message": "Set HRegion#DEFAULT_CLOSE_WAIT_ABORT to true"}, "afterCommit": {"oid": "c08de396bcb508eb2272af20a4bd103d9e9734a8", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/c08de396bcb508eb2272af20a4bd103d9e9734a8", "committedDate": "2020-10-26T20:24:10Z", "message": "- Use a smaller interval than the close wait limit when attempting to acquire\n  the region close lock. Wait for one lock acquisition attempt before interrupting\n  region opeations. Repeat interrupts at this interval until the lock is acquired\n  or the maximum close wait time has been reached. If we interrupt too soon we are\n  too aggressive. Allowing some time for operations in flight to complete is\n  reasonable. This has added benefit of retrying the interrupt attempt in the\n  event that one or more handlers were not interrupted because third party code\n  swallowed the interrupt.\n\n- Use a less conservative default close wait limit of 1 minute (60000 ms).\n\n- Address more review feedback.\n\n- Fix a race problem with TestHRegion#testCloseAbort where we may need to\n  return a valid ServerName from the mock RegionServerServices."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE3MzM0NDAx", "url": "https://github.com/apache/hbase/pull/2574#pullrequestreview-517334401", "createdAt": "2020-10-27T04:07:55Z", "commit": {"oid": "c08de396bcb508eb2272af20a4bd103d9e9734a8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwNDowNzo1NlrOHoqtxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwNDowNzo1NlrOHoqtxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQwNDkzMg==", "bodyText": "Could we only call checkInterrupt() once before or after WAL synced, instead of a check after every step.\nPersonally I incline to check after WAL synced.\nIt also makes sense to call before WAL synced if considering the sync issue which occasionally happen.", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512404932", "createdAt": "2020-10-27T04:07:56Z", "author": {"login": "Reidddddd"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -4569,13 +4665,29 @@ private void doMiniBatchMutate(BatchOperation<?> batchOp) throws IOException {\n       // We should record the timestamp only after we have acquired the rowLock,\n       // otherwise, newer puts/deletes/increment/append are not guaranteed to have a newer\n       // timestamp\n+\n+      // Check for thread interrupt status in case we have been signaled from\n+      // #interruptRegionOperation.\n+      checkInterrupt();\n+\n       long now = EnvironmentEdgeManager.currentTime();\n       batchOp.prepareMiniBatchOperations(miniBatchOp, now, acquiredRowLocks);\n \n       // STEP 3. Build WAL edit\n+\n+      // Check for thread interrupt status in case we have been signaled from\n+      // #interruptRegionOperation.\n+      checkInterrupt();\n+\n       List<Pair<NonceKey, WALEdit>> walEdits = batchOp.buildWALEdits(miniBatchOp);\n \n       // STEP 4. Append the WALEdits to WAL and sync.\n+\n+      // Check for thread interrupt status in case we have been signaled from\n+      // #interruptRegionOperation. This is the last place we can do it \"safely\" before\n+      // WAL appends.\n+      checkInterrupt();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c08de396bcb508eb2272af20a4bd103d9e9734a8"}, "originalPosition": 213}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c08de396bcb508eb2272af20a4bd103d9e9734a8", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/c08de396bcb508eb2272af20a4bd103d9e9734a8", "committedDate": "2020-10-26T20:24:10Z", "message": "- Use a smaller interval than the close wait limit when attempting to acquire\n  the region close lock. Wait for one lock acquisition attempt before interrupting\n  region opeations. Repeat interrupts at this interval until the lock is acquired\n  or the maximum close wait time has been reached. If we interrupt too soon we are\n  too aggressive. Allowing some time for operations in flight to complete is\n  reasonable. This has added benefit of retrying the interrupt attempt in the\n  event that one or more handlers were not interrupted because third party code\n  swallowed the interrupt.\n\n- Use a less conservative default close wait limit of 1 minute (60000 ms).\n\n- Address more review feedback.\n\n- Fix a race problem with TestHRegion#testCloseAbort where we may need to\n  return a valid ServerName from the mock RegionServerServices."}, "afterCommit": {"oid": "3f0bc125cdb864af04895c86990cfcebe6eed6da", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/3f0bc125cdb864af04895c86990cfcebe6eed6da", "committedDate": "2020-10-28T01:33:12Z", "message": "- Protect WAL append and memstore update from interrupts when processing mutations\n\n- New unit test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4OTA1OTkx", "url": "https://github.com/apache/hbase/pull/2574#pullrequestreview-518905991", "createdAt": "2020-10-28T17:17:59Z", "commit": {"oid": "3f0bc125cdb864af04895c86990cfcebe6eed6da"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzoxNzo1OVrOHp1Hjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzoxNzo1OVrOHp1Hjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMzk1MA==", "bodyText": "nit: Amend the comment to add what this boolean means?", "url": "https://github.com/apache/hbase/pull/2574#discussion_r513623950", "createdAt": "2020-10-28T17:17:59Z", "author": {"login": "bharathv"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -688,14 +689,17 @@ void sawNoSuchFamily() {\n   // Last flush time for each Store. Useful when we are flushing for each column\n   private final ConcurrentMap<HStore, Long> lastStoreFlushTimeMap = new ConcurrentHashMap<>();\n \n-  final RegionServerServices rsServices;\n+  protected RegionServerServices rsServices;\n   private RegionServerAccounting rsAccounting;\n   private long flushCheckInterval;\n   // flushPerChanges is to prevent too many changes in memstore\n   private long flushPerChanges;\n   private long blockingMemStoreSize;\n   // Used to guard closes\n   final ReentrantReadWriteLock lock;\n+  // Used to track interruptible holders of the region lock\n+  // Currently that is only RPC handler threads\n+  final ConcurrentHashMap<Thread, Boolean> regionLockHolders;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f0bc125cdb864af04895c86990cfcebe6eed6da"}, "originalPosition": 23}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3f0bc125cdb864af04895c86990cfcebe6eed6da", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/3f0bc125cdb864af04895c86990cfcebe6eed6da", "committedDate": "2020-10-28T01:33:12Z", "message": "- Protect WAL append and memstore update from interrupts when processing mutations\n\n- New unit test"}, "afterCommit": {"oid": "7254af38791750d4b6c584959c5aa66c66cf75a0", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/7254af38791750d4b6c584959c5aa66c66cf75a0", "committedDate": "2020-10-28T22:11:44Z", "message": "Update comment in HRegion to address review feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MjkzNTg3", "url": "https://github.com/apache/hbase/pull/2574#pullrequestreview-519293587", "createdAt": "2020-10-29T02:49:04Z", "commit": {"oid": "7254af38791750d4b6c584959c5aa66c66cf75a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwMjo0OTowNFrOHqF10Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwMjo0OTowNFrOHqF10Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg5NzkzNw==", "bodyText": "Only one q left, read operations are interruptible, but i couldn't find new interruption handling in read path. Do we just leave it as it is? (just for confirmation)", "url": "https://github.com/apache/hbase/pull/2574#discussion_r513897937", "createdAt": "2020-10-29T02:49:04Z", "author": {"login": "Reidddddd"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -8730,12 +8868,22 @@ public void startRegionOperation() throws IOException {\n \n   @Override\n   public void startRegionOperation(Operation op) throws IOException {\n+    boolean isInterruptableOp = false;\n     switch (op) {\n-      case GET:  // read operations\n+      case GET:  // interruptible read operations\n       case SCAN:\n+        isInterruptableOp = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7254af38791750d4b6c584959c5aa66c66cf75a0"}, "originalPosition": 435}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MjkzODcw", "url": "https://github.com/apache/hbase/pull/2574#pullrequestreview-519293870", "createdAt": "2020-10-29T02:49:59Z", "commit": {"oid": "7254af38791750d4b6c584959c5aa66c66cf75a0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5NTMzOTg0", "url": "https://github.com/apache/hbase/pull/2574#pullrequestreview-519533984", "createdAt": "2020-10-29T10:39:18Z", "commit": {"oid": "7254af38791750d4b6c584959c5aa66c66cf75a0"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMDozOToxOFrOHqV3yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMDozOToxOFrOHqV3yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE2MDU4NA==", "bodyText": "nit: entry.getValue() is enough", "url": "https://github.com/apache/hbase/pull/2574#discussion_r514160584", "createdAt": "2020-10-29T10:39:18Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -9000,6 +9173,51 @@ public long getReadPoint() {\n     return getReadPoint(IsolationLevel.READ_COMMITTED);\n   }\n \n+  /**\n+   * Interrupt any region options that have acquired the region lock via\n+   * {@link #startRegionOperation(org.apache.hadoop.hbase.regionserver.Region.Operation)},\n+   * or {@link #startBulkRegionOperation(boolean)}.\n+   */\n+  private void interruptRegionOperations() {\n+    for (Map.Entry<Thread, Boolean> entry: regionLockHolders.entrySet()) {\n+      // An entry in this map will have a boolean value indicating if it is currently\n+      // eligible for interrupt; if so, we should interrupt it.\n+      if (entry.getValue().booleanValue()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7254af38791750d4b6c584959c5aa66c66cf75a0"}, "originalPosition": 581}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5NjA1NDEw", "url": "https://github.com/apache/hbase/pull/2574#pullrequestreview-519605410", "createdAt": "2020-10-29T12:20:12Z", "commit": {"oid": "7254af38791750d4b6c584959c5aa66c66cf75a0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMjoyMDoxMlrOHqZMPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMjozMzoyMFrOHqZpfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIxNDk3NQ==", "bodyText": "I mean the log message. Waiting on row lock is not the only case now?", "url": "https://github.com/apache/hbase/pull/2574#discussion_r514214975", "createdAt": "2020-10-29T12:20:12Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -6588,8 +6677,10 @@ protected RowLock getRowLockInternal(byte[] row, boolean readLock, final RowLock\n       success = true;\n       return result;\n     } catch (InterruptedException ie) {\n-      LOG.warn(\"Thread interrupted waiting for lock on row: {}, in region {}\", rowKey,\n-        getRegionInfo().getRegionNameAsString());\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Thread interrupted waiting for lock on row: {}, in region {}\", rowKey,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MTkyMQ=="}, "originalCommit": {"oid": "57ef804122a4ad7242489337a4c1e643ea27ed0c"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIxNzUzMA==", "bodyText": "Why remove these comments? They are not the cases for now?", "url": "https://github.com/apache/hbase/pull/2574#discussion_r514217530", "createdAt": "2020-10-29T12:24:52Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -8777,23 +8936,36 @@ public void closeRegionOperation(Operation operation) throws IOException {\n     if (operation == Operation.SNAPSHOT) {\n       stores.values().forEach(HStore::postSnapshotOperation);\n     }\n+    regionLockHolders.remove(Thread.currentThread());\n     lock.readLock().unlock();\n     if (coprocessorHost != null) {\n       coprocessorHost.postCloseRegionOperation(operation);\n     }\n   }\n \n+  /**\n+   * If a handler thread is eligible for interrupt, make it ineligible. Should be paired\n+   * with {{@link #enableInterrupts()}.\n+   */\n+  protected void disableInterrupts() {\n+    regionLockHolders.computeIfPresent(Thread.currentThread(), (t,b) -> false);\n+  }\n+\n+  /**\n+   * If a handler thread was made ineligible for interrupt via {{@link #disableInterrupts()},\n+   * make it eligible again. No-op if interrupts are already enabled.\n+   */\n+  protected void enableInterrupts() {\n+    regionLockHolders.computeIfPresent(Thread.currentThread(), (t,b) -> true);\n+  }\n+\n   /**\n    * This method needs to be called before any public call that reads or\n    * modifies stores in bulk. It has to be called just before a try.\n    * #closeBulkRegionOperation needs to be called in the try's finally block\n    * Acquires a writelock and checks if the region is closing or closed.\n-   * @throws NotServingRegionException when the region is closing or closed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7254af38791750d4b6c584959c5aa66c66cf75a0"}, "originalPosition": 508}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIyMjQ2Mg==", "bodyText": "After reading this discussion several times, I think the reason we do not want to niterrupte a WAL sync is that it may lead to a region server abort?\nI would say this is not the case here. I checked the code again, the actual sync is done in the disruptor thread, in the rpc thread we just block on a SyncFuture(as Andrew mentioned above), the interruption on the rpc thread will just lead to an IOException tp client, the actual sync operation will not be interrupted so we are safe.\nSo I do not think we need to disable interrupts here?", "url": "https://github.com/apache/hbase/pull/2574#discussion_r514222462", "createdAt": "2020-10-29T12:33:20Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -4569,13 +4665,29 @@ private void doMiniBatchMutate(BatchOperation<?> batchOp) throws IOException {\n       // We should record the timestamp only after we have acquired the rowLock,\n       // otherwise, newer puts/deletes/increment/append are not guaranteed to have a newer\n       // timestamp\n+\n+      // Check for thread interrupt status in case we have been signaled from\n+      // #interruptRegionOperation.\n+      checkInterrupt();\n+\n       long now = EnvironmentEdgeManager.currentTime();\n       batchOp.prepareMiniBatchOperations(miniBatchOp, now, acquiredRowLocks);\n \n       // STEP 3. Build WAL edit\n+\n+      // Check for thread interrupt status in case we have been signaled from\n+      // #interruptRegionOperation.\n+      checkInterrupt();\n+\n       List<Pair<NonceKey, WALEdit>> walEdits = batchOp.buildWALEdits(miniBatchOp);\n \n       // STEP 4. Append the WALEdits to WAL and sync.\n+\n+      // Check for thread interrupt status in case we have been signaled from\n+      // #interruptRegionOperation. This is the last place we can do it \"safely\" before\n+      // WAL appends.\n+      checkInterrupt();\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQwNDkzMg=="}, "originalCommit": {"oid": "c08de396bcb508eb2272af20a4bd103d9e9734a8"}, "originalPosition": 213}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7254af38791750d4b6c584959c5aa66c66cf75a0", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/7254af38791750d4b6c584959c5aa66c66cf75a0", "committedDate": "2020-10-28T22:11:44Z", "message": "Update comment in HRegion to address review feedback"}, "afterCommit": {"oid": "2baafa4b5cdff6c49bbb3f45aef4f12e7ae1e8a7", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/2baafa4b5cdff6c49bbb3f45aef4f12e7ae1e8a7", "committedDate": "2020-10-30T17:10:32Z", "message": "Remove some checkInterrupt calls to address review feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2baafa4b5cdff6c49bbb3f45aef4f12e7ae1e8a7", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/2baafa4b5cdff6c49bbb3f45aef4f12e7ae1e8a7", "committedDate": "2020-10-30T17:10:32Z", "message": "Remove some checkInterrupt calls to address review feedback"}, "afterCommit": {"oid": "cc294feae5ddffaf0779bde22866ca0f29a49c60", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/cc294feae5ddffaf0779bde22866ca0f29a49c60", "committedDate": "2020-10-30T21:33:08Z", "message": "Protect WAL append and memstore update from interrupts when processing mutations"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxNjUyODgw", "url": "https://github.com/apache/hbase/pull/2574#pullrequestreview-521652880", "createdAt": "2020-11-02T14:01:53Z", "commit": {"oid": "e5a714d32e88ef6543d2d7f575c7ae6ad18b5484"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNDowMTo1M1rOHsFkJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQxNDowNDoyOFrOHsFqwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5MDU2NQ==", "bodyText": "I think here we could have a checkInterrupt? And for me, I think before STEP 4, we could always interrupt the handler but I wonder whether it worth. The prepare mini batch and build WAL are all in memory operations so they should be fast. So I suggest that, we call checkInterrupt here, if we pass, then remove the handler from the Map.", "url": "https://github.com/apache/hbase/pull/2574#discussion_r515990565", "createdAt": "2020-11-02T14:01:53Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -4565,17 +4663,23 @@ private void doMiniBatchMutate(BatchOperation<?> batchOp) throws IOException {\n       lock(this.updatesLock.readLock(), miniBatchOp.getReadyToWriteCount());\n       locked = true;\n \n+      // From this point until memstore update this operation should not be interrupted.\n+      disableInterrupts();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5a714d32e88ef6543d2d7f575c7ae6ad18b5484"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5MTg5Mg==", "bodyText": "I wonder whether it is possible to return what we have to client instead of throwing an exception to client. Anyway, Can be a follow on issue, not a blocker here.", "url": "https://github.com/apache/hbase/pull/2574#discussion_r515991892", "createdAt": "2020-11-02T14:03:53Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -7623,6 +7740,9 @@ protected boolean nextRow(ScannerContext scannerContext, Cell curRowCell) throws\n       Cell next;\n       while ((next = this.storeHeap.peek()) != null &&\n              CellUtil.matchingRows(next, curRowCell)) {\n+        // Check for thread interrupt status in case we have been signaled from\n+        // #interruptRegionOperation.\n+        checkInterrupt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5a714d32e88ef6543d2d7f575c7ae6ad18b5484"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5MjI1OA==", "bodyText": "Same with the doMiniBatchMutation above.", "url": "https://github.com/apache/hbase/pull/2574#discussion_r515992258", "createdAt": "2020-11-02T14:04:28Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -8303,9 +8428,14 @@ public void processRowsWithLocks(RowProcessor<?,?> processor, long timeout,\n             prevRowLock = rowLock;\n           }\n         }\n+\n         // STEP 3. Region lock\n         lock(this.updatesLock.readLock(), acquiredRowLocks.isEmpty() ? 1 : acquiredRowLocks.size());\n         locked = true;\n+\n+        // From this point until memstore update this operation should not be interrupted.\n+        disableInterrupts();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5a714d32e88ef6543d2d7f575c7ae6ad18b5484"}, "originalPosition": 306}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMTIzNDY0", "url": "https://github.com/apache/hbase/pull/2574#pullrequestreview-522123464", "createdAt": "2020-11-03T00:23:18Z", "commit": {"oid": "e5a714d32e88ef6543d2d7f575c7ae6ad18b5484"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebd92f644f3bc1b33be8e63ba47f69bc580f0b0e", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/ebd92f644f3bc1b33be8e63ba47f69bc580f0b0e", "committedDate": "2020-11-03T19:30:50Z", "message": "HBASE-25212 Optionally abort requests in progress after deciding a region should close\n\nIf hbase.regionserver.close.wait.abort is set to true, interrupt RPC\nhandler threads holding the region close lock.\n\nUntil requests in progress can be aborted, wait on the region close lock\nfor a configurable interval (specified by hbase.regionserver.close.wait.time,\nin ms). If we have failed to acquire the close lock after this interval\nelapses, if allowed (also specified by hbase.regionserver.close.wait.abort),\nabort the regionserver.\n\nDefine a subset of region operations as interruptable. Track threads holding\nthe close lock transiting those operations. Set the thread interrupt status\nof tracked threads when trying to close the region. Use the thread interrupt\nstatus where safe to break out of request processing."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3464d3cb7f4bed20dee2c17780c7b57b8a85e280", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/3464d3cb7f4bed20dee2c17780c7b57b8a85e280", "committedDate": "2020-11-03T19:30:50Z", "message": "Address review feedback\n\n- Address review feedback\n- Fix spotbugs warnings\n- Fix checkstyle nit\n- Fix new unit tests, missed a needed HTU change for master branch\n- Fix more unit tests after HTU change\n- Reduce chance of race conditions in new TestHRegion units by joining on lock holder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3ddf8a7c6ba91ee9566293ac56ec0b17a9111c2", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/b3ddf8a7c6ba91ee9566293ac56ec0b17a9111c2", "committedDate": "2020-11-03T19:30:50Z", "message": "Fix more checkstyle nits"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75f9bd82a1b0ceaecfcc7921be825beb7fc33811", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/75f9bd82a1b0ceaecfcc7921be825beb7fc33811", "committedDate": "2020-11-03T19:30:50Z", "message": "Set HRegion#DEFAULT_CLOSE_WAIT_ABORT to true"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ea937c9fb054b85da0b780e8d446eaf51128ebf", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/9ea937c9fb054b85da0b780e8d446eaf51128ebf", "committedDate": "2020-11-03T19:30:50Z", "message": "- Use a smaller interval than the close wait limit when attempting to acquire\n  the region close lock. Wait for one lock acquisition attempt before interrupting\n  region opeations. Repeat interrupts at this interval until the lock is acquired\n  or the maximum close wait time has been reached. If we interrupt too soon we are\n  too aggressive. Allowing some time for operations in flight to complete is\n  reasonable. This has added benefit of retrying the interrupt attempt in the\n  event that one or more handlers were not interrupted because third party code\n  swallowed the interrupt.\n\n- Use a less conservative default close wait limit of 1 minute (60000 ms).\n\n- Address more review feedback.\n\n- Fix a race problem with TestHRegion#testCloseAbort where we may need to\n  return a valid ServerName from the mock RegionServerServices."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de723a08458fb15cbd897dcf01f7cf146d550702", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/de723a08458fb15cbd897dcf01f7cf146d550702", "committedDate": "2020-11-03T19:30:50Z", "message": "Remove some checkInterrupt calls to address review feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3159bafa664ed70399e2c02b41b4f58c1f271593", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/3159bafa664ed70399e2c02b41b4f58c1f271593", "committedDate": "2020-11-03T19:30:50Z", "message": "Protect WAL append and memstore update from interrupts when processing mutations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6eccdf7b94a5c573509618c0f3c9d194d5c354b", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/b6eccdf7b94a5c573509618c0f3c9d194d5c354b", "committedDate": "2020-11-03T19:30:50Z", "message": "Put back accidentally removed javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bedb3cf6dfb5ebbe16314d0f5f33fafce3e5ae2b", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/bedb3cf6dfb5ebbe16314d0f5f33fafce3e5ae2b", "committedDate": "2020-11-03T20:04:37Z", "message": "Call checkInterrupt before disableInterrupt to address review feedback."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e5a714d32e88ef6543d2d7f575c7ae6ad18b5484", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/e5a714d32e88ef6543d2d7f575c7ae6ad18b5484", "committedDate": "2020-10-30T21:54:37Z", "message": "Put back accidentally removed javadoc"}, "afterCommit": {"oid": "bedb3cf6dfb5ebbe16314d0f5f33fafce3e5ae2b", "author": {"user": null}, "url": "https://github.com/apache/hbase/commit/bedb3cf6dfb5ebbe16314d0f5f33fafce3e5ae2b", "committedDate": "2020-11-03T20:04:37Z", "message": "Call checkInterrupt before disableInterrupt to address review feedback."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4436, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}