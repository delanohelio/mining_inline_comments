{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4NzcxODQy", "number": 1584, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMTo0MzoxMVrOD1986w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjozNDoyNlrOD5EYAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3OTE2MTM5OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "isResolved": false, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMTo0MzoxMVrOGLqSoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjozOToxOFrOGQImXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg4MDQxNg==", "bodyText": "Should we add a lock on the merge region instead of this?", "url": "https://github.com/apache/hbase/pull/1584#discussion_r414880416", "createdAt": "2020-04-24T21:43:11Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -1846,6 +1846,16 @@ public static void deleteMergeQualifiers(Connection connection, final RegionInfo\n       qualifiers.add(qualifier);\n       delete.addColumns(getCatalogFamily(), qualifier, HConstants.LATEST_TIMESTAMP);\n     }\n+\n+    // There will be race condition that a GCMultipleMergedRegionsProcedure is scheduled while\n+    // the previous GCMultipleMergedRegionsProcedure is still going on, in this case, the second\n+    // GCMultipleMergedRegionsProcedure could delete the merged region by accident!\n+    if (qualifiers.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68e4b057a2bad7e3f13d7188cf4feca7e15a47cb"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkxNjY0Mw==", "bodyText": "Thanks Stack, where to add the lock? More context here, this issue was found with the extra frequent calling of CatalogJanitor.scan() in TestMetaFixer#testOverlap(). It finds merged regions in meta table and fires GCMultipleMergedRegionsProcedure to gc these regions. The second scan() could find the same set of merged regions in meta and keep firing GCMultipleMergedRegionsProcedures. So the first GCMultipleMergedRegionsProcedure cleans up merge qualifiers and the following one will delete the new merged region from meta table, this will result in a hole.\nIf we maintain a locks in Catalog Janitor, then it needs to wait for GCMultipleMergedRegionsProcedures and unlocks the region, this will make scan() very slow. What do you think?", "url": "https://github.com/apache/hbase/pull/1584#discussion_r414916643", "createdAt": "2020-04-24T23:26:51Z", "author": {"login": "huaxiangsun"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -1846,6 +1846,16 @@ public static void deleteMergeQualifiers(Connection connection, final RegionInfo\n       qualifiers.add(qualifier);\n       delete.addColumns(getCatalogFamily(), qualifier, HConstants.LATEST_TIMESTAMP);\n     }\n+\n+    // There will be race condition that a GCMultipleMergedRegionsProcedure is scheduled while\n+    // the previous GCMultipleMergedRegionsProcedure is still going on, in this case, the second\n+    // GCMultipleMergedRegionsProcedure could delete the merged region by accident!\n+    if (qualifiers.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg4MDQxNg=="}, "originalCommit": {"oid": "68e4b057a2bad7e3f13d7188cf4feca7e15a47cb"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTkzNzIzNA==", "bodyText": "This method is called from GCMergedRegionsProcedure and GCMulitpleMergedRegionsProcedure. I was wondering if we took a lock on the Region being Merged would it stop two overlapping GCs happening?\nThe locking mechanism I'm talking of is in Procedure. There is a method called holdLock. Procedures operating on Regions will take out a lock while they are running to prevent other procedures operating at same time. If the Procedure implementation wants to hold the lock even when it is not executing to prevent other Procedures tampering, it will set this holdLock to true.\nA few Procedures do it: TruncateTableProcedure, DeleteTableProcedure, MergeTableRegionsProcedure. GC'ing  a Procedure seems like a candidate for one Procedure only being allowed to run the Delete. Changing the GC procedure to hold lock, does it help in your test?", "url": "https://github.com/apache/hbase/pull/1584#discussion_r415937234", "createdAt": "2020-04-27T15:56:03Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -1846,6 +1846,16 @@ public static void deleteMergeQualifiers(Connection connection, final RegionInfo\n       qualifiers.add(qualifier);\n       delete.addColumns(getCatalogFamily(), qualifier, HConstants.LATEST_TIMESTAMP);\n     }\n+\n+    // There will be race condition that a GCMultipleMergedRegionsProcedure is scheduled while\n+    // the previous GCMultipleMergedRegionsProcedure is still going on, in this case, the second\n+    // GCMultipleMergedRegionsProcedure could delete the merged region by accident!\n+    if (qualifiers.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg4MDQxNg=="}, "originalCommit": {"oid": "68e4b057a2bad7e3f13d7188cf4feca7e15a47cb"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ2NDM4NQ==", "bodyText": "Thanks Stack, I will take a look at examples and come back.", "url": "https://github.com/apache/hbase/pull/1584#discussion_r417464385", "createdAt": "2020-04-29T16:52:22Z", "author": {"login": "huaxiangsun"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -1846,6 +1846,16 @@ public static void deleteMergeQualifiers(Connection connection, final RegionInfo\n       qualifiers.add(qualifier);\n       delete.addColumns(getCatalogFamily(), qualifier, HConstants.LATEST_TIMESTAMP);\n     }\n+\n+    // There will be race condition that a GCMultipleMergedRegionsProcedure is scheduled while\n+    // the previous GCMultipleMergedRegionsProcedure is still going on, in this case, the second\n+    // GCMultipleMergedRegionsProcedure could delete the merged region by accident!\n+    if (qualifiers.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg4MDQxNg=="}, "originalCommit": {"oid": "68e4b057a2bad7e3f13d7188cf4feca7e15a47cb"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODc4ODIyMQ==", "bodyText": "@saintstack I checked the code and went through what you said above. My understanding is that the lock prevents two procedures working on the same region at the same time. In this specific case, it is multiple MergeTableRegionsProcedures are submitted to clean up the merge states, so there are already locks in place. These multiple MergeTableRegionsProcedures are executed sequentially, because it does not check if there are mergeXXX qualifiers to delete, the second one could delete the child region.  To make MergeTableRegionsProcedures idempotent, we need this fix here. What do you think? There is another jira HBASE-24250 created by Andrey, where multiple MergeTableRegionsProcedures are observed in running clusters.", "url": "https://github.com/apache/hbase/pull/1584#discussion_r418788221", "createdAt": "2020-05-02T00:25:33Z", "author": {"login": "huaxiangsun"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -1846,6 +1846,16 @@ public static void deleteMergeQualifiers(Connection connection, final RegionInfo\n       qualifiers.add(qualifier);\n       delete.addColumns(getCatalogFamily(), qualifier, HConstants.LATEST_TIMESTAMP);\n     }\n+\n+    // There will be race condition that a GCMultipleMergedRegionsProcedure is scheduled while\n+    // the previous GCMultipleMergedRegionsProcedure is still going on, in this case, the second\n+    // GCMultipleMergedRegionsProcedure could delete the merged region by accident!\n+    if (qualifiers.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg4MDQxNg=="}, "originalCommit": {"oid": "68e4b057a2bad7e3f13d7188cf4feca7e15a47cb"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NTk1MA==", "bodyText": "Let me create a new issue to track the GCMulitpleMergedRegionsProcedure non-idempotent issue and come up with an unitest to show the issue.", "url": "https://github.com/apache/hbase/pull/1584#discussion_r419565950", "createdAt": "2020-05-04T16:31:05Z", "author": {"login": "huaxiangsun"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -1846,6 +1846,16 @@ public static void deleteMergeQualifiers(Connection connection, final RegionInfo\n       qualifiers.add(qualifier);\n       delete.addColumns(getCatalogFamily(), qualifier, HConstants.LATEST_TIMESTAMP);\n     }\n+\n+    // There will be race condition that a GCMultipleMergedRegionsProcedure is scheduled while\n+    // the previous GCMultipleMergedRegionsProcedure is still going on, in this case, the second\n+    // GCMultipleMergedRegionsProcedure could delete the merged region by accident!\n+    if (qualifiers.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg4MDQxNg=="}, "originalCommit": {"oid": "68e4b057a2bad7e3f13d7188cf4feca7e15a47cb"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2NzQ3MQ==", "bodyText": "ok. sounds good. Let me look at the patch again.", "url": "https://github.com/apache/hbase/pull/1584#discussion_r419567471", "createdAt": "2020-05-04T16:33:26Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -1846,6 +1846,16 @@ public static void deleteMergeQualifiers(Connection connection, final RegionInfo\n       qualifiers.add(qualifier);\n       delete.addColumns(getCatalogFamily(), qualifier, HConstants.LATEST_TIMESTAMP);\n     }\n+\n+    // There will be race condition that a GCMultipleMergedRegionsProcedure is scheduled while\n+    // the previous GCMultipleMergedRegionsProcedure is still going on, in this case, the second\n+    // GCMultipleMergedRegionsProcedure could delete the merged region by accident!\n+    if (qualifiers.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg4MDQxNg=="}, "originalCommit": {"oid": "68e4b057a2bad7e3f13d7188cf4feca7e15a47cb"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3MTI5NA==", "bodyText": "Thanks @saintstack . I create HBASE-24256 to track GCMulitpleMergedRegionsProcedure issue, will drop the fix code in this patch and upload a new patch. In HBASE-24256, I will add an unitest to show the issue.", "url": "https://github.com/apache/hbase/pull/1584#discussion_r419571294", "createdAt": "2020-05-04T16:39:18Z", "author": {"login": "huaxiangsun"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -1846,6 +1846,16 @@ public static void deleteMergeQualifiers(Connection connection, final RegionInfo\n       qualifiers.add(qualifier);\n       delete.addColumns(getCatalogFamily(), qualifier, HConstants.LATEST_TIMESTAMP);\n     }\n+\n+    // There will be race condition that a GCMultipleMergedRegionsProcedure is scheduled while\n+    // the previous GCMultipleMergedRegionsProcedure is still going on, in this case, the second\n+    // GCMultipleMergedRegionsProcedure could delete the merged region by accident!\n+    if (qualifiers.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg4MDQxNg=="}, "originalCommit": {"oid": "68e4b057a2bad7e3f13d7188cf4feca7e15a47cb"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTY3MTA0OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaFixer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjozNDoyNlrOGQIaGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMToxMzo1NFrOGSQgng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2ODE1Mw==", "bodyText": "This bit is hard to read. A comment on why <= 1?", "url": "https://github.com/apache/hbase/pull/1584#discussion_r419568153", "createdAt": "2020-05-04T16:34:26Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaFixer.java", "diffHunk": "@@ -242,17 +243,35 @@ void fixOverlaps(CatalogJanitor.Report report) throws IOException {\n     }\n     List<SortedSet<RegionInfo>> merges = new ArrayList<>();\n     SortedSet<RegionInfo> currentMergeSet = new TreeSet<>();\n+    HashSet<RegionInfo> regionsInMergeSet = new HashSet<>();\n     RegionInfo regionInfoWithlargestEndKey =  null;\n     for (Pair<RegionInfo, RegionInfo> pair: overlaps) {\n       if (regionInfoWithlargestEndKey != null) {\n         if (!isOverlap(regionInfoWithlargestEndKey, pair) ||\n             currentMergeSet.size() >= maxMergeCount) {\n-          merges.add(currentMergeSet);\n-          currentMergeSet = new TreeSet<>();\n+          if (currentMergeSet.size() <= 1) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5e00a23ddb3d60e76aa3316af8887fad4859f7e"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDIzNDg4OQ==", "bodyText": "In the case of the merge set contains only 1 region or empty, we do not need to submit this merge request as no merge is going to happen. I will update the patch with comments to explain this case.", "url": "https://github.com/apache/hbase/pull/1584#discussion_r420234889", "createdAt": "2020-05-05T16:17:30Z", "author": {"login": "huaxiangsun"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaFixer.java", "diffHunk": "@@ -242,17 +243,35 @@ void fixOverlaps(CatalogJanitor.Report report) throws IOException {\n     }\n     List<SortedSet<RegionInfo>> merges = new ArrayList<>();\n     SortedSet<RegionInfo> currentMergeSet = new TreeSet<>();\n+    HashSet<RegionInfo> regionsInMergeSet = new HashSet<>();\n     RegionInfo regionInfoWithlargestEndKey =  null;\n     for (Pair<RegionInfo, RegionInfo> pair: overlaps) {\n       if (regionInfoWithlargestEndKey != null) {\n         if (!isOverlap(regionInfoWithlargestEndKey, pair) ||\n             currentMergeSet.size() >= maxMergeCount) {\n-          merges.add(currentMergeSet);\n-          currentMergeSet = new TreeSet<>();\n+          if (currentMergeSet.size() <= 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2ODE1Mw=="}, "originalCommit": {"oid": "f5e00a23ddb3d60e76aa3316af8887fad4859f7e"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc5ODA0Ng==", "bodyText": "added comments.", "url": "https://github.com/apache/hbase/pull/1584#discussion_r421798046", "createdAt": "2020-05-07T21:13:54Z", "author": {"login": "huaxiangsun"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaFixer.java", "diffHunk": "@@ -242,17 +243,35 @@ void fixOverlaps(CatalogJanitor.Report report) throws IOException {\n     }\n     List<SortedSet<RegionInfo>> merges = new ArrayList<>();\n     SortedSet<RegionInfo> currentMergeSet = new TreeSet<>();\n+    HashSet<RegionInfo> regionsInMergeSet = new HashSet<>();\n     RegionInfo regionInfoWithlargestEndKey =  null;\n     for (Pair<RegionInfo, RegionInfo> pair: overlaps) {\n       if (regionInfoWithlargestEndKey != null) {\n         if (!isOverlap(regionInfoWithlargestEndKey, pair) ||\n             currentMergeSet.size() >= maxMergeCount) {\n-          merges.add(currentMergeSet);\n-          currentMergeSet = new TreeSet<>();\n+          if (currentMergeSet.size() <= 1) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU2ODE1Mw=="}, "originalCommit": {"oid": "f5e00a23ddb3d60e76aa3316af8887fad4859f7e"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1828, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}