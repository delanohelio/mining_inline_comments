{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4MzMzMzM5", "number": 2058, "title": "HBASE-24722 Address hbase-shell commands with unintentional return values", "bodyText": "Resolves https://issues.apache.org/jira/browse/HBASE-24722\nChangelog\n\nPrior to this commit, there were 13 commands that unintentionally return the\nnumber of lines they print (usually one). This commit ensures that they\nreturn the value documented by the help text, or nil if there is not a simple\nlogical value to return.\nFixes 6 hbase-shell commands that return String rather than TrueClass or\nFalseClass\nUse double-bang to cast truthy values to TrueClass and FalseClass so that\nruby's to_s can reliably print true or false without using ternary operators\nUpdates tests for is_disabled, is_enabled, disable_rpc_throttle,\nenable_rpc_throttle, disable_exceed_throttle_quota,\nenable_exceed_throttle_quota, clear_deadservers, snapshot_cleanup_switch,\nsnapshot_cleanup_enabled, and balancer to check return values\nAdds new tests for balance_switch, balancer_enabled, normalizer_switch,\nnormalizer_enabled, catalog_janitor_switch, catalogjanitor_enabled,\ncleaner_chore_switch, cleaner_chore_enabled, splitormerge_switch, and\nsplitormerge_enabled\n\nNote that the many assertions with explicit comparisons to booleans are intentional (ie. assert(return_value == false)). In ruby, this test makes sure that return value is actually an instance of TrueClass or FalseClass, which makes these tests much more potent. Since every ruby object can be cast to a boolean, we don't want to just assert(return_value).\nTesting\n\nOf the 19 commands updated, 17 are covered by unit testing (a number of the unit tests are introduced by this PR).\nI manually tested my changes to the 2 commands not covered by unit tests: normalize and clear_block_cache. I'd love to get these commands covered as well, but I believe that is out of scope for this ticket since testing those commands should be a little more extensive.", "createdAt": "2020-07-13T15:35:26Z", "url": "https://github.com/apache/hbase/pull/2058", "merged": true, "mergeCommit": {"oid": "4b3ef815ebe4f01e85b3534e439f0e3f91e40f9a"}, "closed": true, "closedAt": "2020-07-17T18:44:31Z", "author": {"login": "bitoffdev"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc0jCppgH2gAyNDQ4MzMzMzM5OjU4ZDMwZTA5YzBjZWI2ZjFiYWNkYzU0NGYxNjlmOGYxMjViNGExYjk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc14XBhAFqTQ1MDg3Njg4OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9", "author": {"user": {"login": "bitoffdev", "name": "Elliot"}}, "url": "https://github.com/apache/hbase/commit/58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9", "committedDate": "2020-07-13T15:19:43Z", "message": "HBASE-24722 Update commands with unintentional return values\n\n- Prior to this commit, there were 13 commands that unintentionally return the\n  number of lines they print (usually one). This commit ensures that they\n  return the value documented by the help text, or nil if there is not a simple\n  logical value to return.\n- Fixes 6 hbase-shell commands that return String rather than TrueClass or\n  FalseClass\n- Use double-bang to cast truthy values to TrueClass and FalseClass so that\n  ruby's to_s can reliably print true or false without using ternary operators\n- Updates tests for is_disabled, is_enabled, disable_rpc_throttle,\n  enable_rpc_throttle, disable_exceed_throttle_quota,\n  enable_exceed_throttle_quota, clear_deadservers, snapshot_cleanup_switch,\n  snapshot_cleanup_enabled, and balancer to check return values\n- Adds new tests for balance_switch, balancer_enabled, normalizer_switch,\n  normalizer_enabled, catalog_janitor_switch, catalogjanitor_enabled,\n  cleaner_chore_switch, cleaner_chore_enabled, splitormerge_switch, and\n  splitormerge_enabled"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3Mzg0MzI2", "url": "https://github.com/apache/hbase/pull/2058#pullrequestreview-447384326", "createdAt": "2020-07-13T15:56:36Z", "commit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTo1NjozNlrOGwvBUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTo1NjozNlrOGwvBUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc1NTIxNg==", "bodyText": "Does it make sense to put this pattern in a method?", "url": "https://github.com/apache/hbase/pull/2058#discussion_r453755216", "createdAt": "2020-07-13T15:56:36Z", "author": {"login": "madrob"}, "path": "hbase-shell/src/main/ruby/shell/commands/balancer.rb", "diffHunk": "@@ -44,7 +44,9 @@ def command(force = nil)\n         elsif !force.nil?\n           raise ArgumentError, \"Invalid argument #{force}.\"\n         end\n-        formatter.row([admin.balancer(force_balancer) ? 'true' : 'false'])\n+        did_balancer_run = !!admin.balancer(force_balancer)\n+        formatter.row([did_balancer_run.to_s])\n+        did_balancer_run", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwODc2ODg4", "url": "https://github.com/apache/hbase/pull/2058#pullrequestreview-450876888", "createdAt": "2020-07-17T18:36:13Z", "commit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODozNjoxM1rOGzdTBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODo0Mzo0M1rOGzdgqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMDU2NA==", "bodyText": "Nice idiom convertion (java to ruby)", "url": "https://github.com/apache/hbase/pull/2058#discussion_r456610564", "createdAt": "2020-07-17T18:36:13Z", "author": {"login": "saintstack"}, "path": "hbase-shell/src/main/ruby/shell/commands/balance_switch.rb", "diffHunk": "@@ -31,7 +31,7 @@ def help\n       end\n \n       def command(enableDisable)\n-        prev_state = admin.balance_switch(enableDisable) ? 'true' : 'false'\n+        prev_state = !!admin.balance_switch(enableDisable)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMTI1Mg==", "bodyText": "formatter.row returns void? Different to nil?", "url": "https://github.com/apache/hbase/pull/2058#discussion_r456611252", "createdAt": "2020-07-17T18:37:43Z", "author": {"login": "saintstack"}, "path": "hbase-shell/src/main/ruby/shell/commands/clear_block_cache.rb", "diffHunk": "@@ -33,6 +33,7 @@ def help\n \n       def command(table_name)\n         formatter.row([admin.clear_block_cache(table_name)])\n+        nil", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMTYzMg==", "bodyText": "Bug fix?", "url": "https://github.com/apache/hbase/pull/2058#discussion_r456611632", "createdAt": "2020-07-17T18:38:31Z", "author": {"login": "saintstack"}, "path": "hbase-shell/src/main/ruby/shell/commands/clear_deadservers.rb", "diffHunk": "@@ -35,18 +37,20 @@ def help\n       end\n \n       # rubocop:disable Metrics/AbcSize\n-      # rubocop:disable Metrics/MethodLength\n       def command(*dead_servers)\n         servers = admin.clear_deadservers(dead_servers)\n         if servers.size <= 0\n           formatter.row(['true'])\n+          []\n         else\n           formatter.row(['Some dead server clear failed'])\n           formatter.row(['SERVERNAME'])\n-          servers.each do |server|\n-            formatter.row([server.toString])\n+          server_names = servers.map { |server| server.toString }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxNDA1Ng==", "bodyText": "Sweet", "url": "https://github.com/apache/hbase/pull/2058#discussion_r456614056", "createdAt": "2020-07-17T18:43:43Z", "author": {"login": "saintstack"}, "path": "hbase-shell/src/test/ruby/hbase/admin_test.rb", "diffHunk": "@@ -212,13 +215,182 @@ def teardown\n     #-------------------------------------------------------------------------------\n \n     define_test 'snapshot auto cleanup should work' do\n-      command(:snapshot_cleanup_switch, true)\n-      output = capture_stdout { command(:snapshot_cleanup_enabled) }\n+      result = nil\n+      command(:snapshot_cleanup_switch, false)\n+\n+      # enable snapshot cleanup and check that the previous state is returned\n+      output = capture_stdout { result = command(:snapshot_cleanup_switch, true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that snapshot_cleanup_enabled returns the current state\n+      output = capture_stdout { result = command(:snapshot_cleanup_enabled) }\n       assert(output.include?('true'))\n+      assert(result == true)\n \n-      command(:snapshot_cleanup_switch, false)\n-      output = capture_stdout { command(:snapshot_cleanup_enabled) }\n+      # disable snapshot cleanup and check that the previous state is returned\n+      output = capture_stdout { result = command(:snapshot_cleanup_switch, false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that snapshot_cleanup_enabled returns the current state\n+      output = capture_stdout { result = command(:snapshot_cleanup_enabled) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+    end\n+\n+    #-------------------------------------------------------------------------------\n+\n+    define_test 'balancer switch should work' do\n+      result = nil\n+      command(:balance_switch, false)\n+\n+      # enable balancer and check that the previous state is returned\n+      output = capture_stdout { result = command(:balance_switch, true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that balancer_enabled returns the current state\n+      output = capture_stdout { result = command(:balancer_enabled) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # disable balancer and check that the previous state is returned\n+      output = capture_stdout { result = command(:balance_switch, false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that balancer_enabled returns the current state\n+      output = capture_stdout { result = command(:balancer_enabled) }\n       assert(output.include?('false'))\n+      assert(result == false)\n+    end\n+\n+    #-------------------------------------------------------------------------------\n+\n+    define_test 'normalizer switch should work' do\n+      result = nil\n+      command(:normalizer_switch, false)\n+\n+      # enable normalizer and check that the previous state is returned\n+      output = capture_stdout { result = command(:normalizer_switch, true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that normalizer_enabled returns the current state\n+      output = capture_stdout { result = command(:normalizer_enabled) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # disable normalizer and check that the previous state is returned\n+      output = capture_stdout { result = command(:normalizer_switch, false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that normalizer_enabled returns the current state\n+      output = capture_stdout { result = command(:normalizer_enabled) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+    end\n+\n+    #-------------------------------------------------------------------------------\n+\n+    define_test 'catalogjanitor switch should work' do\n+      result = nil\n+      command(:catalogjanitor_switch, false)\n+\n+      # enable catalogjanitor and check that the previous state is returned\n+      output = capture_stdout { result = command(:catalogjanitor_switch, true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that catalogjanitor_enabled returns the current state\n+      output = capture_stdout { result = command(:catalogjanitor_enabled) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # disable catalogjanitor and check that the previous state is returned\n+      output = capture_stdout { result = command(:catalogjanitor_switch, false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that catalogjanitor_enabled returns the current state\n+      output = capture_stdout { result = command(:catalogjanitor_enabled) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+    end\n+\n+    #-------------------------------------------------------------------------------\n+\n+    define_test 'cleaner_chore switch should work' do\n+      result = nil\n+      command(:cleaner_chore_switch, false)\n+\n+      # enable cleaner_chore and check that the previous state is returned\n+      output = capture_stdout { result = command(:cleaner_chore_switch, true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that cleaner_chore_enabled returns the current state\n+      output = capture_stdout { result = command(:cleaner_chore_enabled) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # disable cleaner_chore and check that the previous state is returned\n+      output = capture_stdout { result = command(:cleaner_chore_switch, false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that cleaner_chore_enabled returns the current state\n+      output = capture_stdout { result = command(:cleaner_chore_enabled) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+    end\n+\n+    #-------------------------------------------------------------------------------\n+\n+    define_test 'splitormerge switch should work' do\n+      # Author's note: All the other feature switches in hbase-shell only toggle one feature. This command operates on\n+      # both the \"SPLIT\" and \"MERGE\", so you will note that both code paths need coverage.\n+      result = nil\n+      command(:splitormerge_switch, 'SPLIT', false)\n+      command(:splitormerge_switch, 'MERGE', true)\n+\n+      # flip switch and check that the previous state is returned\n+      output = capture_stdout { result = command(:splitormerge_switch, 'SPLIT', true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      output = capture_stdout { result = command(:splitormerge_switch, 'MERGE', false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that splitormerge_enabled returns the current state\n+      output = capture_stdout { result = command(:splitormerge_enabled, 'SPLIT') }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      output = capture_stdout { result = command(:splitormerge_enabled, 'MERGE') }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # flip switch and check that the previous state is returned\n+      output = capture_stdout { result = command(:splitormerge_switch, 'SPLIT', false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      output = capture_stdout { result = command(:splitormerge_switch, 'MERGE', true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that splitormerge_enabled returns the current state\n+      output = capture_stdout { result = command(:splitormerge_enabled, 'SPLIT') }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      output = capture_stdout { result = command(:splitormerge_enabled, 'MERGE') }\n+      assert(output.include?('true'))\n+      assert(result == true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "originalPosition": 205}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4262, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}