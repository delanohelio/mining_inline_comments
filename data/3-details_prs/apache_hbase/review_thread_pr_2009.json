{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyNTY4OTMx", "number": 2009, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMjowMTo1MVrOEKe24w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQxMDo1NTo1M1rOELdAgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDI2Nzg3OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMjowMTo1MVrOGri9vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNjoxNjo1MVrOGs0dhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMxNDgxNQ==", "bodyText": "nit: private ?", "url": "https://github.com/apache/hbase/pull/2009#discussion_r448314815", "createdAt": "2020-07-01T12:01:51Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,88 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }\n         } else {\n           PrivateCellUtil.updateLatestStamp(cell, byteNow);\n+          deleteCells.add(cell);\n         }\n       }\n+      e.setValue(deleteCells);\n     }\n   }\n \n-  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, byte[] byteNow)\n-      throws IOException {\n-    List<Cell> result = get(get, false);\n-\n+  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, int maxVersions,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1456fa439f98e96d04eb4c60bd35ab6aabd60a7"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDA1Mg==", "bodyText": "Had not done previously because original method modified was package private. Doing now.", "url": "https://github.com/apache/hbase/pull/2009#discussion_r449650052", "createdAt": "2020-07-03T16:16:51Z", "author": {"login": "wchevreuil"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,88 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }\n         } else {\n           PrivateCellUtil.updateLatestStamp(cell, byteNow);\n+          deleteCells.add(cell);\n         }\n       }\n+      e.setValue(deleteCells);\n     }\n   }\n \n-  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, byte[] byteNow)\n-      throws IOException {\n-    List<Cell> result = get(get, false);\n-\n+  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, int maxVersions,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMxNDgxNQ=="}, "originalCommit": {"oid": "b1456fa439f98e96d04eb4c60bd35ab6aabd60a7"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDMxNjczOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMjoxNzoyMlrOGrjbrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNjoxNzowMVrOGs0dsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMjQ3OQ==", "bodyText": "nit: we can wrap it with ArrayList constructor: new ArrayList<>(deleteCells);", "url": "https://github.com/apache/hbase/pull/2009#discussion_r448322479", "createdAt": "2020-07-01T12:17:22Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,88 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }\n         } else {\n           PrivateCellUtil.updateLatestStamp(cell, byteNow);\n+          deleteCells.add(cell);\n         }\n       }\n+      e.setValue(deleteCells);\n     }\n   }\n \n-  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, byte[] byteNow)\n-      throws IOException {\n-    List<Cell> result = get(get, false);\n-\n+  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, int maxVersions,\n+      byte[] byteNow, List<Cell> deleteCells) throws IOException {\n+    List<Cell> result = new ArrayList<>();\n+    result.addAll(deleteCells);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1456fa439f98e96d04eb4c60bd35ab6aabd60a7"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDA5Ng==", "bodyText": "Yes.", "url": "https://github.com/apache/hbase/pull/2009#discussion_r449650096", "createdAt": "2020-07-03T16:17:01Z", "author": {"login": "wchevreuil"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,88 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }\n         } else {\n           PrivateCellUtil.updateLatestStamp(cell, byteNow);\n+          deleteCells.add(cell);\n         }\n       }\n+      e.setValue(deleteCells);\n     }\n   }\n \n-  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, byte[] byteNow)\n-      throws IOException {\n-    List<Cell> result = get(get, false);\n-\n+  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, int maxVersions,\n+      byte[] byteNow, List<Cell> deleteCells) throws IOException {\n+    List<Cell> result = new ArrayList<>();\n+    result.addAll(deleteCells);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyMjQ3OQ=="}, "originalCommit": {"oid": "b1456fa439f98e96d04eb4c60bd35ab6aabd60a7"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDMzMjM1OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMjoyMjoxMlrOGrjlPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNjoxNzoxNVrOGs0d5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyNDkyNA==", "bodyText": "result sorting doesn't seem useful for this condition. Can we avoid sorting for this?\nif (result.size() < count) {\n..\n..\n  deleteCells.addAll(cells);\n  return;\n}\n\nresult.sort();\n\nif (result.size() > count){\n..\n..\n}else{\n..\n}\ndeleteCells.addAll(cells);", "url": "https://github.com/apache/hbase/pull/2009#discussion_r448324924", "createdAt": "2020-07-01T12:22:12Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,88 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }\n         } else {\n           PrivateCellUtil.updateLatestStamp(cell, byteNow);\n+          deleteCells.add(cell);\n         }\n       }\n+      e.setValue(deleteCells);\n     }\n   }\n \n-  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, byte[] byteNow)\n-      throws IOException {\n-    List<Cell> result = get(get, false);\n-\n+  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, int maxVersions,\n+      byte[] byteNow, List<Cell> deleteCells) throws IOException {\n+    List<Cell> result = new ArrayList<>();\n+    result.addAll(deleteCells);\n+    Scan scan = new Scan(get);\n+    scan.setRaw(true);\n+    this.getScanner(scan).next(result);\n+    result.sort((cell1, cell2) -> {\n+      if(cell1.getTimestamp()>cell2.getTimestamp()){\n+        return -1;\n+      } else if(cell1.getTimestamp()<cell2.getTimestamp()){\n+        return 1;\n+      } else {\n+        if(CellUtil.isDelete(cell1)){\n+          return -1;\n+        } else if (CellUtil.isDelete(cell2)){\n+          return 1;\n+        }\n+      }\n+      return 0;\n+    });\n+    List<Cell> cells = new ArrayList<>();\n     if (result.size() < count) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1456fa439f98e96d04eb4c60bd35ab6aabd60a7"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDE0OA==", "bodyText": "Yes.", "url": "https://github.com/apache/hbase/pull/2009#discussion_r449650148", "createdAt": "2020-07-03T16:17:15Z", "author": {"login": "wchevreuil"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,88 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }\n         } else {\n           PrivateCellUtil.updateLatestStamp(cell, byteNow);\n+          deleteCells.add(cell);\n         }\n       }\n+      e.setValue(deleteCells);\n     }\n   }\n \n-  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, byte[] byteNow)\n-      throws IOException {\n-    List<Cell> result = get(get, false);\n-\n+  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, int maxVersions,\n+      byte[] byteNow, List<Cell> deleteCells) throws IOException {\n+    List<Cell> result = new ArrayList<>();\n+    result.addAll(deleteCells);\n+    Scan scan = new Scan(get);\n+    scan.setRaw(true);\n+    this.getScanner(scan).next(result);\n+    result.sort((cell1, cell2) -> {\n+      if(cell1.getTimestamp()>cell2.getTimestamp()){\n+        return -1;\n+      } else if(cell1.getTimestamp()<cell2.getTimestamp()){\n+        return 1;\n+      } else {\n+        if(CellUtil.isDelete(cell1)){\n+          return -1;\n+        } else if (CellUtil.isDelete(cell2)){\n+          return 1;\n+        }\n+      }\n+      return 0;\n+    });\n+    List<Cell> cells = new ArrayList<>();\n     if (result.size() < count) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMyNDkyNA=="}, "originalCommit": {"oid": "b1456fa439f98e96d04eb4c60bd35ab6aabd60a7"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDQwMzU3OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMjo0Mjo1NVrOGrkRHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxNjoxOToxM1rOGs0f-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMzNjE1Ng==", "bodyText": "Should we not deepClone cell, update timestamp and then add that cloned cell to cells list similar to above branch?", "url": "https://github.com/apache/hbase/pull/2009#discussion_r448336156", "createdAt": "2020-07-01T12:42:55Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,88 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }\n         } else {\n           PrivateCellUtil.updateLatestStamp(cell, byteNow);\n+          deleteCells.add(cell);\n         }\n       }\n+      e.setValue(deleteCells);\n     }\n   }\n \n-  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, byte[] byteNow)\n-      throws IOException {\n-    List<Cell> result = get(get, false);\n-\n+  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, int maxVersions,\n+      byte[] byteNow, List<Cell> deleteCells) throws IOException {\n+    List<Cell> result = new ArrayList<>();\n+    result.addAll(deleteCells);\n+    Scan scan = new Scan(get);\n+    scan.setRaw(true);\n+    this.getScanner(scan).next(result);\n+    result.sort((cell1, cell2) -> {\n+      if(cell1.getTimestamp()>cell2.getTimestamp()){\n+        return -1;\n+      } else if(cell1.getTimestamp()<cell2.getTimestamp()){\n+        return 1;\n+      } else {\n+        if(CellUtil.isDelete(cell1)){\n+          return -1;\n+        } else if (CellUtil.isDelete(cell2)){\n+          return 1;\n+        }\n+      }\n+      return 0;\n+    });\n+    List<Cell> cells = new ArrayList<>();\n     if (result.size() < count) {\n       // Nothing to delete\n       PrivateCellUtil.updateLatestStamp(cell, byteNow);\n-      return;\n-    }\n-    if (result.size() > count) {\n-      throw new RuntimeException(\"Unexpected size: \" + result.size());\n+      cells.add(cell);\n+      deleteCells.addAll(cells);\n+    } else if (result.size() > count) {\n+      int currentVersion = 0;\n+      long latestCellTS = Long.MAX_VALUE;\n+      for(Cell getCell : result){\n+        if(!(CellUtil.matchingFamily(getCell, cell) && CellUtil.matchingQualifier(getCell, cell))){\n+          continue;\n+        }\n+        if(!PrivateCellUtil.isDeleteType(getCell) && getCell.getTimestamp()!=latestCellTS){\n+          if (currentVersion >= maxVersions) {\n+            Cell tempCell = null;\n+            try {\n+              tempCell = PrivateCellUtil.deepClone(cell);\n+            } catch (CloneNotSupportedException e) {\n+              throw new IOException(e);\n+            }\n+            PrivateCellUtil.setTimestamp(tempCell, getCell.getTimestamp());\n+            cells.add(tempCell);\n+          } else if (currentVersion == 0) {\n+            PrivateCellUtil.setTimestamp(cell, getCell.getTimestamp());\n+            cells.add(cell);\n+          }\n+          currentVersion++;\n+        }\n+        latestCellTS = getCell.getTimestamp();\n+      }\n+\n+    } else {\n+      Cell getCell = result.get(0);\n+      PrivateCellUtil.setTimestamp(cell, getCell.getTimestamp());\n+      cells.add(cell);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1456fa439f98e96d04eb4c60bd35ab6aabd60a7"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTY1MDY4MA==", "bodyText": "It's been a while since I originally proposed this patch, but IIRC we don't need it here, because there's no extra version to fabricate a new delete marker.", "url": "https://github.com/apache/hbase/pull/2009#discussion_r449650680", "createdAt": "2020-07-03T16:19:13Z", "author": {"login": "wchevreuil"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,88 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }\n         } else {\n           PrivateCellUtil.updateLatestStamp(cell, byteNow);\n+          deleteCells.add(cell);\n         }\n       }\n+      e.setValue(deleteCells);\n     }\n   }\n \n-  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, byte[] byteNow)\n-      throws IOException {\n-    List<Cell> result = get(get, false);\n-\n+  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, int maxVersions,\n+      byte[] byteNow, List<Cell> deleteCells) throws IOException {\n+    List<Cell> result = new ArrayList<>();\n+    result.addAll(deleteCells);\n+    Scan scan = new Scan(get);\n+    scan.setRaw(true);\n+    this.getScanner(scan).next(result);\n+    result.sort((cell1, cell2) -> {\n+      if(cell1.getTimestamp()>cell2.getTimestamp()){\n+        return -1;\n+      } else if(cell1.getTimestamp()<cell2.getTimestamp()){\n+        return 1;\n+      } else {\n+        if(CellUtil.isDelete(cell1)){\n+          return -1;\n+        } else if (CellUtil.isDelete(cell2)){\n+          return 1;\n+        }\n+      }\n+      return 0;\n+    });\n+    List<Cell> cells = new ArrayList<>();\n     if (result.size() < count) {\n       // Nothing to delete\n       PrivateCellUtil.updateLatestStamp(cell, byteNow);\n-      return;\n-    }\n-    if (result.size() > count) {\n-      throw new RuntimeException(\"Unexpected size: \" + result.size());\n+      cells.add(cell);\n+      deleteCells.addAll(cells);\n+    } else if (result.size() > count) {\n+      int currentVersion = 0;\n+      long latestCellTS = Long.MAX_VALUE;\n+      for(Cell getCell : result){\n+        if(!(CellUtil.matchingFamily(getCell, cell) && CellUtil.matchingQualifier(getCell, cell))){\n+          continue;\n+        }\n+        if(!PrivateCellUtil.isDeleteType(getCell) && getCell.getTimestamp()!=latestCellTS){\n+          if (currentVersion >= maxVersions) {\n+            Cell tempCell = null;\n+            try {\n+              tempCell = PrivateCellUtil.deepClone(cell);\n+            } catch (CloneNotSupportedException e) {\n+              throw new IOException(e);\n+            }\n+            PrivateCellUtil.setTimestamp(tempCell, getCell.getTimestamp());\n+            cells.add(tempCell);\n+          } else if (currentVersion == 0) {\n+            PrivateCellUtil.setTimestamp(cell, getCell.getTimestamp());\n+            cells.add(cell);\n+          }\n+          currentVersion++;\n+        }\n+        latestCellTS = getCell.getTimestamp();\n+      }\n+\n+    } else {\n+      Cell getCell = result.get(0);\n+      PrivateCellUtil.setTimestamp(cell, getCell.getTimestamp());\n+      cells.add(cell);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMzNjE1Ng=="}, "originalCommit": {"oid": "b1456fa439f98e96d04eb4c60bd35ab6aabd60a7"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NDQxODgyOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMjo0Nzo0NVrOGrkbIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxMjo0Nzo0NVrOGrkbIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODMzODcyMQ==", "bodyText": "Would you prefer using a boolean to make single call to updateDeleteLatestVersionTimestamp?\n          boolean updateDelTs=false;\n          if (coprocessorHost != null) {\n            if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                byteNow, get)) {\n              updateDelTs=true;\n            }\n          } else {\n            updateDelTs=true;\n          }\n          if(updateDelTs){\n            updateDeleteLatestVersionTimestamp(cell, get, count,\n              this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n              byteNow, deleteCells);\n          }\n\nOnly if you feel this is more readable :)", "url": "https://github.com/apache/hbase/pull/2009#discussion_r448338721", "createdAt": "2020-07-01T12:47:45Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,88 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1456fa439f98e96d04eb4c60bd35ab6aabd60a7"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNDQ1MDU3OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQxMDo1NTo1M1rOGtBfuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxNjoxMDo1MFrOGtd6bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg2MzYxMQ==", "bodyText": "I am not sure if sorting of result is required here. If not required, rest looks good.", "url": "https://github.com/apache/hbase/pull/2009#discussion_r449863611", "createdAt": "2020-07-05T10:55:53Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,87 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }\n         } else {\n           PrivateCellUtil.updateLatestStamp(cell, byteNow);\n+          deleteCells.add(cell);\n         }\n       }\n+      e.setValue(deleteCells);\n     }\n   }\n \n-  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, byte[] byteNow)\n-      throws IOException {\n-    List<Cell> result = get(get, false);\n-\n+  private void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, int maxVersions,\n+      byte[] byteNow, List<Cell> deleteCells) throws IOException {\n+    List<Cell> result = new ArrayList<>(deleteCells);\n+    Scan scan = new Scan(get);\n+    scan.setRaw(true);\n+    this.getScanner(scan).next(result);\n+    List<Cell> cells = new ArrayList<>();\n     if (result.size() < count) {\n       // Nothing to delete\n       PrivateCellUtil.updateLatestStamp(cell, byteNow);\n-      return;\n-    }\n-    if (result.size() > count) {\n-      throw new RuntimeException(\"Unexpected size: \" + result.size());\n+      cells.add(cell);\n+      deleteCells.addAll(cells);\n+    } else if (result.size() > count) {\n+      int currentVersion = 0;\n+      long latestCellTS = Long.MAX_VALUE;\n+      result.sort((cell1, cell2) -> {\n+        if(cell1.getTimestamp()>cell2.getTimestamp()){\n+          return -1;\n+        } else if(cell1.getTimestamp()<cell2.getTimestamp()){\n+          return 1;\n+        } else {\n+          if(CellUtil.isDelete(cell1)){\n+            return -1;\n+          } else if (CellUtil.isDelete(cell2)){\n+            return 1;\n+          }\n+        }\n+        return 0;\n+      });\n+      for(Cell getCell : result){\n+        if(!(CellUtil.matchingFamily(getCell, cell) && CellUtil.matchingQualifier(getCell, cell))){\n+          continue;\n+        }\n+        if(!PrivateCellUtil.isDeleteType(getCell) && getCell.getTimestamp()!=latestCellTS){\n+          if (currentVersion >= maxVersions) {\n+            Cell tempCell = null;\n+            try {\n+              tempCell = PrivateCellUtil.deepClone(cell);\n+            } catch (CloneNotSupportedException e) {\n+              throw new IOException(e);\n+            }\n+            PrivateCellUtil.setTimestamp(tempCell, getCell.getTimestamp());\n+            cells.add(tempCell);\n+          } else if (currentVersion == 0) {\n+            PrivateCellUtil.setTimestamp(cell, getCell.getTimestamp());\n+            cells.add(cell);\n+          }\n+          currentVersion++;\n+        }\n+        latestCellTS = getCell.getTimestamp();\n+      }\n+\n+    } else {\n+      Cell getCell = result.get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9137fc7d36f5065ced735440939a016544809d46"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDMyOTE5Ng==", "bodyText": "It's not needed, because we don't have to worry about additional versions, we only need to put a single marker for current TS.", "url": "https://github.com/apache/hbase/pull/2009#discussion_r450329196", "createdAt": "2020-07-06T16:10:50Z", "author": {"login": "wchevreuil"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -3170,37 +3171,87 @@ public void prepareDeleteTimestamps(Mutation mutation, Map<byte[], List<Cell>> f\n           count = kvCount.get(qual);\n \n           Get get = new Get(CellUtil.cloneRow(cell));\n-          get.readVersions(count);\n-          get.addColumn(family, qual);\n+          get.readVersions(Integer.MAX_VALUE);\n           if (coprocessorHost != null) {\n             if (!coprocessorHost.prePrepareTimeStampForDeleteVersion(mutation, cell,\n                 byteNow, get)) {\n-              updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+              updateDeleteLatestVersionTimestamp(cell, get, count,\n+                  this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                    byteNow, deleteCells);\n+\n             }\n           } else {\n-            updateDeleteLatestVersionTimestamp(cell, get, count, byteNow);\n+            updateDeleteLatestVersionTimestamp(cell, get, count,\n+                this.htableDescriptor.getColumnFamily(family).getMaxVersions(),\n+                  byteNow, deleteCells);\n           }\n         } else {\n           PrivateCellUtil.updateLatestStamp(cell, byteNow);\n+          deleteCells.add(cell);\n         }\n       }\n+      e.setValue(deleteCells);\n     }\n   }\n \n-  void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, byte[] byteNow)\n-      throws IOException {\n-    List<Cell> result = get(get, false);\n-\n+  private void updateDeleteLatestVersionTimestamp(Cell cell, Get get, int count, int maxVersions,\n+      byte[] byteNow, List<Cell> deleteCells) throws IOException {\n+    List<Cell> result = new ArrayList<>(deleteCells);\n+    Scan scan = new Scan(get);\n+    scan.setRaw(true);\n+    this.getScanner(scan).next(result);\n+    List<Cell> cells = new ArrayList<>();\n     if (result.size() < count) {\n       // Nothing to delete\n       PrivateCellUtil.updateLatestStamp(cell, byteNow);\n-      return;\n-    }\n-    if (result.size() > count) {\n-      throw new RuntimeException(\"Unexpected size: \" + result.size());\n+      cells.add(cell);\n+      deleteCells.addAll(cells);\n+    } else if (result.size() > count) {\n+      int currentVersion = 0;\n+      long latestCellTS = Long.MAX_VALUE;\n+      result.sort((cell1, cell2) -> {\n+        if(cell1.getTimestamp()>cell2.getTimestamp()){\n+          return -1;\n+        } else if(cell1.getTimestamp()<cell2.getTimestamp()){\n+          return 1;\n+        } else {\n+          if(CellUtil.isDelete(cell1)){\n+            return -1;\n+          } else if (CellUtil.isDelete(cell2)){\n+            return 1;\n+          }\n+        }\n+        return 0;\n+      });\n+      for(Cell getCell : result){\n+        if(!(CellUtil.matchingFamily(getCell, cell) && CellUtil.matchingQualifier(getCell, cell))){\n+          continue;\n+        }\n+        if(!PrivateCellUtil.isDeleteType(getCell) && getCell.getTimestamp()!=latestCellTS){\n+          if (currentVersion >= maxVersions) {\n+            Cell tempCell = null;\n+            try {\n+              tempCell = PrivateCellUtil.deepClone(cell);\n+            } catch (CloneNotSupportedException e) {\n+              throw new IOException(e);\n+            }\n+            PrivateCellUtil.setTimestamp(tempCell, getCell.getTimestamp());\n+            cells.add(tempCell);\n+          } else if (currentVersion == 0) {\n+            PrivateCellUtil.setTimestamp(cell, getCell.getTimestamp());\n+            cells.add(cell);\n+          }\n+          currentVersion++;\n+        }\n+        latestCellTS = getCell.getTimestamp();\n+      }\n+\n+    } else {\n+      Cell getCell = result.get(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTg2MzYxMQ=="}, "originalCommit": {"oid": "9137fc7d36f5065ced735440939a016544809d46"}, "originalPosition": 100}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2894, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}