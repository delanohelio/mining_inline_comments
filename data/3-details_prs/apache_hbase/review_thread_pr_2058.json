{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4MzMzMzM5", "number": 2058, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTo1NjozNlrOEN4fcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODo0Mzo0M1rOEPo5fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyOTkyNDk3OnYy", "diffSide": "RIGHT", "path": "hbase-shell/src/main/ruby/shell/commands/balancer.rb", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNTo1NjozNlrOGwvBUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNjoxMzoyOVrOGxa7Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc1NTIxNg==", "bodyText": "Does it make sense to put this pattern in a method?", "url": "https://github.com/apache/hbase/pull/2058#discussion_r453755216", "createdAt": "2020-07-13T15:56:36Z", "author": {"login": "madrob"}, "path": "hbase-shell/src/main/ruby/shell/commands/balancer.rb", "diffHunk": "@@ -44,7 +44,9 @@ def command(force = nil)\n         elsif !force.nil?\n           raise ArgumentError, \"Invalid argument #{force}.\"\n         end\n-        formatter.row([admin.balancer(force_balancer) ? 'true' : 'false'])\n+        did_balancer_run = !!admin.balancer(force_balancer)\n+        formatter.row([did_balancer_run.to_s])\n+        did_balancer_run", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ2NzUyMQ==", "bodyText": "I think the simple implementation to encapsulate this pattern would be strange. I would rather leave this as is, and revisit the formatter more holistically as a separate ticket.", "url": "https://github.com/apache/hbase/pull/2058#discussion_r454467521", "createdAt": "2020-07-14T16:02:40Z", "author": {"login": "bitoffdev"}, "path": "hbase-shell/src/main/ruby/shell/commands/balancer.rb", "diffHunk": "@@ -44,7 +44,9 @@ def command(force = nil)\n         elsif !force.nil?\n           raise ArgumentError, \"Invalid argument #{force}.\"\n         end\n-        formatter.row([admin.balancer(force_balancer) ? 'true' : 'false'])\n+        did_balancer_run = !!admin.balancer(force_balancer)\n+        formatter.row([did_balancer_run.to_s])\n+        did_balancer_run", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc1NTIxNg=="}, "originalCommit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ3Mzc2Mg==", "bodyText": "Makes sense, can you create the follow-on issue and leave a short description?", "url": "https://github.com/apache/hbase/pull/2058#discussion_r454473762", "createdAt": "2020-07-14T16:12:15Z", "author": {"login": "madrob"}, "path": "hbase-shell/src/main/ruby/shell/commands/balancer.rb", "diffHunk": "@@ -44,7 +44,9 @@ def command(force = nil)\n         elsif !force.nil?\n           raise ArgumentError, \"Invalid argument #{force}.\"\n         end\n-        formatter.row([admin.balancer(force_balancer) ? 'true' : 'false'])\n+        did_balancer_run = !!admin.balancer(force_balancer)\n+        formatter.row([did_balancer_run.to_s])\n+        did_balancer_run", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc1NTIxNg=="}, "originalCommit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ3NDU4Mg==", "bodyText": "Will do! \ud83d\ude04", "url": "https://github.com/apache/hbase/pull/2058#discussion_r454474582", "createdAt": "2020-07-14T16:13:29Z", "author": {"login": "bitoffdev"}, "path": "hbase-shell/src/main/ruby/shell/commands/balancer.rb", "diffHunk": "@@ -44,7 +44,9 @@ def command(force = nil)\n         elsif !force.nil?\n           raise ArgumentError, \"Invalid argument #{force}.\"\n         end\n-        formatter.row([admin.balancer(force_balancer) ? 'true' : 'false'])\n+        did_balancer_run = !!admin.balancer(force_balancer)\n+        formatter.row([did_balancer_run.to_s])\n+        did_balancer_run", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc1NTIxNg=="}, "originalCommit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODMxOTk3OnYy", "diffSide": "RIGHT", "path": "hbase-shell/src/main/ruby/shell/commands/balance_switch.rb", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODozNjoxM1rOGzdTBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODozNjoxM1rOGzdTBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMDU2NA==", "bodyText": "Nice idiom convertion (java to ruby)", "url": "https://github.com/apache/hbase/pull/2058#discussion_r456610564", "createdAt": "2020-07-17T18:36:13Z", "author": {"login": "saintstack"}, "path": "hbase-shell/src/main/ruby/shell/commands/balance_switch.rb", "diffHunk": "@@ -31,7 +31,7 @@ def help\n       end\n \n       def command(enableDisable)\n-        prev_state = admin.balance_switch(enableDisable) ? 'true' : 'false'\n+        prev_state = !!admin.balance_switch(enableDisable)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODMyNDAyOnYy", "diffSide": "RIGHT", "path": "hbase-shell/src/main/ruby/shell/commands/clear_block_cache.rb", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODozNzo0M1rOGzdVtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODo1MToxNlrOGzduMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMTI1Mg==", "bodyText": "formatter.row returns void? Different to nil?", "url": "https://github.com/apache/hbase/pull/2058#discussion_r456611252", "createdAt": "2020-07-17T18:37:43Z", "author": {"login": "saintstack"}, "path": "hbase-shell/src/main/ruby/shell/commands/clear_block_cache.rb", "diffHunk": "@@ -33,6 +33,7 @@ def help\n \n       def command(table_name)\n         formatter.row([admin.clear_block_cache(table_name)])\n+        nil", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxNzUyMg==", "bodyText": "formatter.row returns the running total number of rows printed (@row_count) since the last call to formatter.header", "url": "https://github.com/apache/hbase/pull/2058#discussion_r456617522", "createdAt": "2020-07-17T18:51:16Z", "author": {"login": "bitoffdev"}, "path": "hbase-shell/src/main/ruby/shell/commands/clear_block_cache.rb", "diffHunk": "@@ -33,6 +33,7 @@ def help\n \n       def command(table_name)\n         formatter.row([admin.clear_block_cache(table_name)])\n+        nil", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMTI1Mg=="}, "originalCommit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODMyNjMxOnYy", "diffSide": "RIGHT", "path": "hbase-shell/src/main/ruby/shell/commands/clear_deadservers.rb", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODozODozMVrOGzdXMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODo1Mjo0OVrOGzdw6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMTYzMg==", "bodyText": "Bug fix?", "url": "https://github.com/apache/hbase/pull/2058#discussion_r456611632", "createdAt": "2020-07-17T18:38:31Z", "author": {"login": "saintstack"}, "path": "hbase-shell/src/main/ruby/shell/commands/clear_deadservers.rb", "diffHunk": "@@ -35,18 +37,20 @@ def help\n       end\n \n       # rubocop:disable Metrics/AbcSize\n-      # rubocop:disable Metrics/MethodLength\n       def command(*dead_servers)\n         servers = admin.clear_deadservers(dead_servers)\n         if servers.size <= 0\n           formatter.row(['true'])\n+          []\n         else\n           formatter.row(['Some dead server clear failed'])\n           formatter.row(['SERVERNAME'])\n-          servers.each do |server|\n-            formatter.row([server.toString])\n+          server_names = servers.map { |server| server.toString }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxODIxNw==", "bodyText": "This is just a change to collect all the server names as an array so that we can both print and return the list of servers that could not be cleared", "url": "https://github.com/apache/hbase/pull/2058#discussion_r456618217", "createdAt": "2020-07-17T18:52:49Z", "author": {"login": "bitoffdev"}, "path": "hbase-shell/src/main/ruby/shell/commands/clear_deadservers.rb", "diffHunk": "@@ -35,18 +37,20 @@ def help\n       end\n \n       # rubocop:disable Metrics/AbcSize\n-      # rubocop:disable Metrics/MethodLength\n       def command(*dead_servers)\n         servers = admin.clear_deadservers(dead_servers)\n         if servers.size <= 0\n           formatter.row(['true'])\n+          []\n         else\n           formatter.row(['Some dead server clear failed'])\n           formatter.row(['SERVERNAME'])\n-          servers.each do |server|\n-            formatter.row([server.toString])\n+          server_names = servers.map { |server| server.toString }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMTYzMg=="}, "originalCommit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0ODM0MTcyOnYy", "diffSide": "RIGHT", "path": "hbase-shell/src/test/ruby/hbase/admin_test.rb", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODo0Mzo0M1rOGzdgqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODo0Mzo0M1rOGzdgqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxNDA1Ng==", "bodyText": "Sweet", "url": "https://github.com/apache/hbase/pull/2058#discussion_r456614056", "createdAt": "2020-07-17T18:43:43Z", "author": {"login": "saintstack"}, "path": "hbase-shell/src/test/ruby/hbase/admin_test.rb", "diffHunk": "@@ -212,13 +215,182 @@ def teardown\n     #-------------------------------------------------------------------------------\n \n     define_test 'snapshot auto cleanup should work' do\n-      command(:snapshot_cleanup_switch, true)\n-      output = capture_stdout { command(:snapshot_cleanup_enabled) }\n+      result = nil\n+      command(:snapshot_cleanup_switch, false)\n+\n+      # enable snapshot cleanup and check that the previous state is returned\n+      output = capture_stdout { result = command(:snapshot_cleanup_switch, true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that snapshot_cleanup_enabled returns the current state\n+      output = capture_stdout { result = command(:snapshot_cleanup_enabled) }\n       assert(output.include?('true'))\n+      assert(result == true)\n \n-      command(:snapshot_cleanup_switch, false)\n-      output = capture_stdout { command(:snapshot_cleanup_enabled) }\n+      # disable snapshot cleanup and check that the previous state is returned\n+      output = capture_stdout { result = command(:snapshot_cleanup_switch, false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that snapshot_cleanup_enabled returns the current state\n+      output = capture_stdout { result = command(:snapshot_cleanup_enabled) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+    end\n+\n+    #-------------------------------------------------------------------------------\n+\n+    define_test 'balancer switch should work' do\n+      result = nil\n+      command(:balance_switch, false)\n+\n+      # enable balancer and check that the previous state is returned\n+      output = capture_stdout { result = command(:balance_switch, true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that balancer_enabled returns the current state\n+      output = capture_stdout { result = command(:balancer_enabled) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # disable balancer and check that the previous state is returned\n+      output = capture_stdout { result = command(:balance_switch, false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that balancer_enabled returns the current state\n+      output = capture_stdout { result = command(:balancer_enabled) }\n       assert(output.include?('false'))\n+      assert(result == false)\n+    end\n+\n+    #-------------------------------------------------------------------------------\n+\n+    define_test 'normalizer switch should work' do\n+      result = nil\n+      command(:normalizer_switch, false)\n+\n+      # enable normalizer and check that the previous state is returned\n+      output = capture_stdout { result = command(:normalizer_switch, true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that normalizer_enabled returns the current state\n+      output = capture_stdout { result = command(:normalizer_enabled) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # disable normalizer and check that the previous state is returned\n+      output = capture_stdout { result = command(:normalizer_switch, false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that normalizer_enabled returns the current state\n+      output = capture_stdout { result = command(:normalizer_enabled) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+    end\n+\n+    #-------------------------------------------------------------------------------\n+\n+    define_test 'catalogjanitor switch should work' do\n+      result = nil\n+      command(:catalogjanitor_switch, false)\n+\n+      # enable catalogjanitor and check that the previous state is returned\n+      output = capture_stdout { result = command(:catalogjanitor_switch, true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that catalogjanitor_enabled returns the current state\n+      output = capture_stdout { result = command(:catalogjanitor_enabled) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # disable catalogjanitor and check that the previous state is returned\n+      output = capture_stdout { result = command(:catalogjanitor_switch, false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that catalogjanitor_enabled returns the current state\n+      output = capture_stdout { result = command(:catalogjanitor_enabled) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+    end\n+\n+    #-------------------------------------------------------------------------------\n+\n+    define_test 'cleaner_chore switch should work' do\n+      result = nil\n+      command(:cleaner_chore_switch, false)\n+\n+      # enable cleaner_chore and check that the previous state is returned\n+      output = capture_stdout { result = command(:cleaner_chore_switch, true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that cleaner_chore_enabled returns the current state\n+      output = capture_stdout { result = command(:cleaner_chore_enabled) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # disable cleaner_chore and check that the previous state is returned\n+      output = capture_stdout { result = command(:cleaner_chore_switch, false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that cleaner_chore_enabled returns the current state\n+      output = capture_stdout { result = command(:cleaner_chore_enabled) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+    end\n+\n+    #-------------------------------------------------------------------------------\n+\n+    define_test 'splitormerge switch should work' do\n+      # Author's note: All the other feature switches in hbase-shell only toggle one feature. This command operates on\n+      # both the \"SPLIT\" and \"MERGE\", so you will note that both code paths need coverage.\n+      result = nil\n+      command(:splitormerge_switch, 'SPLIT', false)\n+      command(:splitormerge_switch, 'MERGE', true)\n+\n+      # flip switch and check that the previous state is returned\n+      output = capture_stdout { result = command(:splitormerge_switch, 'SPLIT', true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      output = capture_stdout { result = command(:splitormerge_switch, 'MERGE', false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that splitormerge_enabled returns the current state\n+      output = capture_stdout { result = command(:splitormerge_enabled, 'SPLIT') }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      output = capture_stdout { result = command(:splitormerge_enabled, 'MERGE') }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # flip switch and check that the previous state is returned\n+      output = capture_stdout { result = command(:splitormerge_switch, 'SPLIT', false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      output = capture_stdout { result = command(:splitormerge_switch, 'MERGE', true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that splitormerge_enabled returns the current state\n+      output = capture_stdout { result = command(:splitormerge_enabled, 'SPLIT') }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      output = capture_stdout { result = command(:splitormerge_enabled, 'MERGE') }\n+      assert(output.include?('true'))\n+      assert(result == true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9"}, "originalPosition": 205}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2786, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}