{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwODIyNTE0", "number": 2523, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNzozODoyMFrOEsuL8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMzo0NDoyN1rOEwlX2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzI5NTIxOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxNzozODoyMFrOHgHmCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODoyOToxM1rOHl8vbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0MDkwNg==", "bodyText": "This is cool. I believe this will help us avoid partial config update!", "url": "https://github.com/apache/hbase/pull/2523#discussion_r503440906", "createdAt": "2020-10-12T17:38:20Z", "author": {"login": "mnpoonia"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -71,38 +76,81 @@\n   static final String MERGE_MIN_REGION_SIZE_MB_KEY = \"hbase.normalizer.merge.min_region_size.mb\";\n   static final int DEFAULT_MERGE_MIN_REGION_SIZE_MB = 1;\n \n-  private Configuration conf;\n   private MasterServices masterServices;\n-  private boolean splitEnabled;\n-  private boolean mergeEnabled;\n-  private int minRegionCount;\n-  private Period mergeMinRegionAge;\n-  private int mergeMinRegionSizeMb;\n+\n+  /** Ensure configuration changes are applied atomically. */\n+  private final ReadWriteLock configUpdateLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"configUpdateLock\") private Configuration conf;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557c6c9719afcfe6cf45641b44ea11097387af0b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQwMzcxNw==", "bodyText": "Indeed ! Wondering if we can ensure all implementors of ConfigurationObserver can start using such lock for atomic updates of non-final fields (of course not as part of this Jira :) )", "url": "https://github.com/apache/hbase/pull/2523#discussion_r508403717", "createdAt": "2020-10-20T10:54:21Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -71,38 +76,81 @@\n   static final String MERGE_MIN_REGION_SIZE_MB_KEY = \"hbase.normalizer.merge.min_region_size.mb\";\n   static final int DEFAULT_MERGE_MIN_REGION_SIZE_MB = 1;\n \n-  private Configuration conf;\n   private MasterServices masterServices;\n-  private boolean splitEnabled;\n-  private boolean mergeEnabled;\n-  private int minRegionCount;\n-  private Period mergeMinRegionAge;\n-  private int mergeMinRegionSizeMb;\n+\n+  /** Ensure configuration changes are applied atomically. */\n+  private final ReadWriteLock configUpdateLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"configUpdateLock\") private Configuration conf;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0MDkwNg=="}, "originalCommit": {"oid": "557c6c9719afcfe6cf45641b44ea11097387af0b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg4Mzg5Nw==", "bodyText": "I'm not sure about \"all\" uses, it just seemed prudent for this use. I'm also not sure our static analysis tools honor this GuardedBy annotation, I have a TODO for myself to track this down and see if it's really supported.", "url": "https://github.com/apache/hbase/pull/2523#discussion_r508883897", "createdAt": "2020-10-20T22:45:17Z", "author": {"login": "ndimiduk"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -71,38 +76,81 @@\n   static final String MERGE_MIN_REGION_SIZE_MB_KEY = \"hbase.normalizer.merge.min_region_size.mb\";\n   static final int DEFAULT_MERGE_MIN_REGION_SIZE_MB = 1;\n \n-  private Configuration conf;\n   private MasterServices masterServices;\n-  private boolean splitEnabled;\n-  private boolean mergeEnabled;\n-  private int minRegionCount;\n-  private Period mergeMinRegionAge;\n-  private int mergeMinRegionSizeMb;\n+\n+  /** Ensure configuration changes are applied atomically. */\n+  private final ReadWriteLock configUpdateLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"configUpdateLock\") private Configuration conf;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0MDkwNg=="}, "originalCommit": {"oid": "557c6c9719afcfe6cf45641b44ea11097387af0b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTExMTI5MQ==", "bodyText": "I have learnt about GuardedBy for the first time on this PR, so I am also not sure if static analysis tools really require some work.", "url": "https://github.com/apache/hbase/pull/2523#discussion_r509111291", "createdAt": "2020-10-21T09:01:45Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -71,38 +76,81 @@\n   static final String MERGE_MIN_REGION_SIZE_MB_KEY = \"hbase.normalizer.merge.min_region_size.mb\";\n   static final int DEFAULT_MERGE_MIN_REGION_SIZE_MB = 1;\n \n-  private Configuration conf;\n   private MasterServices masterServices;\n-  private boolean splitEnabled;\n-  private boolean mergeEnabled;\n-  private int minRegionCount;\n-  private Period mergeMinRegionAge;\n-  private int mergeMinRegionSizeMb;\n+\n+  /** Ensure configuration changes are applied atomically. */\n+  private final ReadWriteLock configUpdateLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"configUpdateLock\") private Configuration conf;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0MDkwNg=="}, "originalCommit": {"oid": "557c6c9719afcfe6cf45641b44ea11097387af0b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU1NDU0MA==", "bodyText": "It seems SpotBugs does have a bug description for the improper use of GuardedBy, https://spotbugs.readthedocs.io/en/latest/bugDescriptions.html#is-field-not-guarded-against-concurrent-access-is-field-not-guarded. I wonder if it's actually implemented ;)", "url": "https://github.com/apache/hbase/pull/2523#discussion_r509554540", "createdAt": "2020-10-21T18:29:13Z", "author": {"login": "ndimiduk"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -71,38 +76,81 @@\n   static final String MERGE_MIN_REGION_SIZE_MB_KEY = \"hbase.normalizer.merge.min_region_size.mb\";\n   static final int DEFAULT_MERGE_MIN_REGION_SIZE_MB = 1;\n \n-  private Configuration conf;\n   private MasterServices masterServices;\n-  private boolean splitEnabled;\n-  private boolean mergeEnabled;\n-  private int minRegionCount;\n-  private Period mergeMinRegionAge;\n-  private int mergeMinRegionSizeMb;\n+\n+  /** Ensure configuration changes are applied atomically. */\n+  private final ReadWriteLock configUpdateLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"configUpdateLock\") private Configuration conf;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ0MDkwNg=="}, "originalCommit": {"oid": "557c6c9719afcfe6cf45641b44ea11097387af0b"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NDU1OTg0OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxMDoxNjoyN1rOHk1GjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMjo0NjoyMVrOHlT1QQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM4MDgxMg==", "bodyText": "Last 3 getters should have @VisibleForTesting ?", "url": "https://github.com/apache/hbase/pull/2523#discussion_r508380812", "createdAt": "2020-10-20T10:16:27Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -140,39 +188,76 @@ private static int parseMergeMinRegionSizeMb(final Configuration conf) {\n       key, parsedValue, settledValue);\n   }\n \n+  private static <T> void logConfigurationUpdated(final String key, final T oldValue,\n+    final T newValue) {\n+    if (!Objects.equals(oldValue, newValue)) {\n+      LOG.info(\"Updated configuration for key '{}' from {} to {}\", key, oldValue, newValue);\n+    }\n+  }\n+\n   /**\n    * Return this instance's configured value for {@value #SPLIT_ENABLED_KEY}.\n    */\n   public boolean isSplitEnabled() {\n-    return splitEnabled;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return splitEnabled;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   /**\n    * Return this instance's configured value for {@value #MERGE_ENABLED_KEY}.\n    */\n   public boolean isMergeEnabled() {\n-    return mergeEnabled;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return mergeEnabled;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   /**\n    * Return this instance's configured value for {@value #MIN_REGION_COUNT_KEY}.\n    */\n   public int getMinRegionCount() {\n-    return minRegionCount;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return minRegionCount;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   /**\n    * Return this instance's configured value for {@value #MERGE_MIN_REGION_AGE_DAYS_KEY}.\n    */\n   public Period getMergeMinRegionAge() {\n-    return mergeMinRegionAge;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return mergeMinRegionAge;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   /**\n    * Return this instance's configured value for {@value #MERGE_MIN_REGION_SIZE_MB_KEY}.\n    */\n   public int getMergeMinRegionSizeMb() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557c6c9719afcfe6cf45641b44ea11097387af0b"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg4NDI4OQ==", "bodyText": "In light of HBASE-24640, I didn't want to introduce any new uses of this annotation.", "url": "https://github.com/apache/hbase/pull/2523#discussion_r508884289", "createdAt": "2020-10-20T22:46:21Z", "author": {"login": "ndimiduk"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -140,39 +188,76 @@ private static int parseMergeMinRegionSizeMb(final Configuration conf) {\n       key, parsedValue, settledValue);\n   }\n \n+  private static <T> void logConfigurationUpdated(final String key, final T oldValue,\n+    final T newValue) {\n+    if (!Objects.equals(oldValue, newValue)) {\n+      LOG.info(\"Updated configuration for key '{}' from {} to {}\", key, oldValue, newValue);\n+    }\n+  }\n+\n   /**\n    * Return this instance's configured value for {@value #SPLIT_ENABLED_KEY}.\n    */\n   public boolean isSplitEnabled() {\n-    return splitEnabled;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return splitEnabled;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   /**\n    * Return this instance's configured value for {@value #MERGE_ENABLED_KEY}.\n    */\n   public boolean isMergeEnabled() {\n-    return mergeEnabled;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return mergeEnabled;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   /**\n    * Return this instance's configured value for {@value #MIN_REGION_COUNT_KEY}.\n    */\n   public int getMinRegionCount() {\n-    return minRegionCount;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return minRegionCount;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   /**\n    * Return this instance's configured value for {@value #MERGE_MIN_REGION_AGE_DAYS_KEY}.\n    */\n   public Period getMergeMinRegionAge() {\n-    return mergeMinRegionAge;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return mergeMinRegionAge;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   /**\n    * Return this instance's configured value for {@value #MERGE_MIN_REGION_SIZE_MB_KEY}.\n    */\n   public int getMergeMinRegionSizeMb() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODM4MDgxMg=="}, "originalCommit": {"oid": "557c6c9719afcfe6cf45641b44ea11097387af0b"}, "originalPosition": 199}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4ODUxNjUzOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQwNTo0NDo0MlrOHlbG0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQyMjo1MToyMlrOHmKZtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMzQ3NQ==", "bodyText": "Why is readLock.lock() called here? Thought writeLock is enough.", "url": "https://github.com/apache/hbase/pull/2523#discussion_r509003475", "createdAt": "2020-10-21T05:44:42Z", "author": {"login": "huaxiangsun"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -71,38 +76,81 @@\n   static final String MERGE_MIN_REGION_SIZE_MB_KEY = \"hbase.normalizer.merge.min_region_size.mb\";\n   static final int DEFAULT_MERGE_MIN_REGION_SIZE_MB = 1;\n \n-  private Configuration conf;\n   private MasterServices masterServices;\n-  private boolean splitEnabled;\n-  private boolean mergeEnabled;\n-  private int minRegionCount;\n-  private Period mergeMinRegionAge;\n-  private int mergeMinRegionSizeMb;\n+\n+  /** Ensure configuration changes are applied atomically. */\n+  private final ReadWriteLock configUpdateLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"configUpdateLock\") private Configuration conf;\n+  @GuardedBy(\"configUpdateLock\") private boolean splitEnabled;\n+  @GuardedBy(\"configUpdateLock\") private boolean mergeEnabled;\n+  @GuardedBy(\"configUpdateLock\") private int minRegionCount;\n+  @GuardedBy(\"configUpdateLock\") private Period mergeMinRegionAge;\n+  @GuardedBy(\"configUpdateLock\") private int mergeMinRegionSizeMb;\n \n   public SimpleRegionNormalizer() {\n-    splitEnabled = DEFAULT_SPLIT_ENABLED;\n-    mergeEnabled = DEFAULT_MERGE_ENABLED;\n-    minRegionCount = DEFAULT_MIN_REGION_COUNT;\n-    mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n-    mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock();\n+    try {\n+      splitEnabled = DEFAULT_SPLIT_ENABLED;\n+      mergeEnabled = DEFAULT_MERGE_ENABLED;\n+      minRegionCount = DEFAULT_MIN_REGION_COUNT;\n+      mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n+      mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    } finally {\n+      writeLock.unlock();\n+    }\n   }\n \n   @Override\n   public Configuration getConf() {\n-    return conf;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return conf;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   @Override\n   public void setConf(final Configuration conf) {\n     if (conf == null) {\n       return;\n     }\n-    this.conf = conf;\n-    splitEnabled = conf.getBoolean(SPLIT_ENABLED_KEY, DEFAULT_SPLIT_ENABLED);\n-    mergeEnabled = conf.getBoolean(MERGE_ENABLED_KEY, DEFAULT_MERGE_ENABLED);\n-    minRegionCount = parseMinRegionCount(conf);\n-    mergeMinRegionAge = parseMergeMinRegionAge(conf);\n-    mergeMinRegionSizeMb = parseMergeMinRegionSizeMb(conf);\n+\n+    final Lock readLock = configUpdateLock.readLock();\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock(); // \"a writer can acquire the read lock, but not vice-versa.\"\n+    readLock.lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557c6c9719afcfe6cf45641b44ea11097387af0b"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTEyMTUxNQ==", "bodyText": "I thought of the same initially but then realized that we don't want half updated configs when we read them with getConf() and make half correct decisions. Plus, since this is operator triggered action and not self triggered action, it's once in a while (Just in case you are more worried about threads reading conf getting blocked on readLock).\nStill, let's wait for @ndimiduk 's response in case i might have missed some improvement here.", "url": "https://github.com/apache/hbase/pull/2523#discussion_r509121515", "createdAt": "2020-10-21T09:17:06Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -71,38 +76,81 @@\n   static final String MERGE_MIN_REGION_SIZE_MB_KEY = \"hbase.normalizer.merge.min_region_size.mb\";\n   static final int DEFAULT_MERGE_MIN_REGION_SIZE_MB = 1;\n \n-  private Configuration conf;\n   private MasterServices masterServices;\n-  private boolean splitEnabled;\n-  private boolean mergeEnabled;\n-  private int minRegionCount;\n-  private Period mergeMinRegionAge;\n-  private int mergeMinRegionSizeMb;\n+\n+  /** Ensure configuration changes are applied atomically. */\n+  private final ReadWriteLock configUpdateLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"configUpdateLock\") private Configuration conf;\n+  @GuardedBy(\"configUpdateLock\") private boolean splitEnabled;\n+  @GuardedBy(\"configUpdateLock\") private boolean mergeEnabled;\n+  @GuardedBy(\"configUpdateLock\") private int minRegionCount;\n+  @GuardedBy(\"configUpdateLock\") private Period mergeMinRegionAge;\n+  @GuardedBy(\"configUpdateLock\") private int mergeMinRegionSizeMb;\n \n   public SimpleRegionNormalizer() {\n-    splitEnabled = DEFAULT_SPLIT_ENABLED;\n-    mergeEnabled = DEFAULT_MERGE_ENABLED;\n-    minRegionCount = DEFAULT_MIN_REGION_COUNT;\n-    mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n-    mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock();\n+    try {\n+      splitEnabled = DEFAULT_SPLIT_ENABLED;\n+      mergeEnabled = DEFAULT_MERGE_ENABLED;\n+      minRegionCount = DEFAULT_MIN_REGION_COUNT;\n+      mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n+      mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    } finally {\n+      writeLock.unlock();\n+    }\n   }\n \n   @Override\n   public Configuration getConf() {\n-    return conf;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return conf;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   @Override\n   public void setConf(final Configuration conf) {\n     if (conf == null) {\n       return;\n     }\n-    this.conf = conf;\n-    splitEnabled = conf.getBoolean(SPLIT_ENABLED_KEY, DEFAULT_SPLIT_ENABLED);\n-    mergeEnabled = conf.getBoolean(MERGE_ENABLED_KEY, DEFAULT_MERGE_ENABLED);\n-    minRegionCount = parseMinRegionCount(conf);\n-    mergeMinRegionAge = parseMergeMinRegionAge(conf);\n-    mergeMinRegionSizeMb = parseMergeMinRegionSizeMb(conf);\n+\n+    final Lock readLock = configUpdateLock.readLock();\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock(); // \"a writer can acquire the read lock, but not vice-versa.\"\n+    readLock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMzQ3NQ=="}, "originalCommit": {"oid": "557c6c9719afcfe6cf45641b44ea11097387af0b"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTUzODQ5Ng==", "bodyText": "Why is readLock.lock() called here? Thought writeLock is enough.\n\nInitially I thought so too, but reading the docs on ReadWriteLock, it never explicitly said that the WriteLock is exclusive for both readers and writers, it only says that it's exclusive. The best I can find is from Java Concurrency in Practice, which says (emphasis mine):\n\n... Mutual exclusion is a conservative locking strategy that prevents writer/writer and writer/reader overlap, but also prevents reader/reader overlap. In many cases, data structures are \u201cread-mostly\u201d\u2014they are mutable and are sometimes modified, but most accesses involve only reading. In these cases, it would be nice to relax the locking requirements to allow multiple readers to access the data structure at once. As long as each thread is guaranteed an up-to-date view of the data and no other thread modifies the data while the readers are viewing it, there will be no problems. This is what read-write locks allow: a resource can be accessed by multiple readers or a single writer at a time, but not both.\n\nSo I think you're correct @huaxiangsun , the write lock should be sufficient.", "url": "https://github.com/apache/hbase/pull/2523#discussion_r509538496", "createdAt": "2020-10-21T18:10:40Z", "author": {"login": "ndimiduk"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -71,38 +76,81 @@\n   static final String MERGE_MIN_REGION_SIZE_MB_KEY = \"hbase.normalizer.merge.min_region_size.mb\";\n   static final int DEFAULT_MERGE_MIN_REGION_SIZE_MB = 1;\n \n-  private Configuration conf;\n   private MasterServices masterServices;\n-  private boolean splitEnabled;\n-  private boolean mergeEnabled;\n-  private int minRegionCount;\n-  private Period mergeMinRegionAge;\n-  private int mergeMinRegionSizeMb;\n+\n+  /** Ensure configuration changes are applied atomically. */\n+  private final ReadWriteLock configUpdateLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"configUpdateLock\") private Configuration conf;\n+  @GuardedBy(\"configUpdateLock\") private boolean splitEnabled;\n+  @GuardedBy(\"configUpdateLock\") private boolean mergeEnabled;\n+  @GuardedBy(\"configUpdateLock\") private int minRegionCount;\n+  @GuardedBy(\"configUpdateLock\") private Period mergeMinRegionAge;\n+  @GuardedBy(\"configUpdateLock\") private int mergeMinRegionSizeMb;\n \n   public SimpleRegionNormalizer() {\n-    splitEnabled = DEFAULT_SPLIT_ENABLED;\n-    mergeEnabled = DEFAULT_MERGE_ENABLED;\n-    minRegionCount = DEFAULT_MIN_REGION_COUNT;\n-    mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n-    mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock();\n+    try {\n+      splitEnabled = DEFAULT_SPLIT_ENABLED;\n+      mergeEnabled = DEFAULT_MERGE_ENABLED;\n+      minRegionCount = DEFAULT_MIN_REGION_COUNT;\n+      mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n+      mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    } finally {\n+      writeLock.unlock();\n+    }\n   }\n \n   @Override\n   public Configuration getConf() {\n-    return conf;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return conf;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   @Override\n   public void setConf(final Configuration conf) {\n     if (conf == null) {\n       return;\n     }\n-    this.conf = conf;\n-    splitEnabled = conf.getBoolean(SPLIT_ENABLED_KEY, DEFAULT_SPLIT_ENABLED);\n-    mergeEnabled = conf.getBoolean(MERGE_ENABLED_KEY, DEFAULT_MERGE_ENABLED);\n-    minRegionCount = parseMinRegionCount(conf);\n-    mergeMinRegionAge = parseMergeMinRegionAge(conf);\n-    mergeMinRegionSizeMb = parseMergeMinRegionSizeMb(conf);\n+\n+    final Lock readLock = configUpdateLock.readLock();\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock(); // \"a writer can acquire the read lock, but not vice-versa.\"\n+    readLock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMzQ3NQ=="}, "originalCommit": {"oid": "557c6c9719afcfe6cf45641b44ea11097387af0b"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU5OTQ4NA==", "bodyText": "As long as each thread is guaranteed an up-to-date view of the data and no other thread modifies the data while the readers are viewing it, there will be no problems.\n\nDo we not need readLock() + writeLock() to achieve this? How can we achieve writers not updating while readers are reading conf?", "url": "https://github.com/apache/hbase/pull/2523#discussion_r509599484", "createdAt": "2020-10-21T19:11:52Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -71,38 +76,81 @@\n   static final String MERGE_MIN_REGION_SIZE_MB_KEY = \"hbase.normalizer.merge.min_region_size.mb\";\n   static final int DEFAULT_MERGE_MIN_REGION_SIZE_MB = 1;\n \n-  private Configuration conf;\n   private MasterServices masterServices;\n-  private boolean splitEnabled;\n-  private boolean mergeEnabled;\n-  private int minRegionCount;\n-  private Period mergeMinRegionAge;\n-  private int mergeMinRegionSizeMb;\n+\n+  /** Ensure configuration changes are applied atomically. */\n+  private final ReadWriteLock configUpdateLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"configUpdateLock\") private Configuration conf;\n+  @GuardedBy(\"configUpdateLock\") private boolean splitEnabled;\n+  @GuardedBy(\"configUpdateLock\") private boolean mergeEnabled;\n+  @GuardedBy(\"configUpdateLock\") private int minRegionCount;\n+  @GuardedBy(\"configUpdateLock\") private Period mergeMinRegionAge;\n+  @GuardedBy(\"configUpdateLock\") private int mergeMinRegionSizeMb;\n \n   public SimpleRegionNormalizer() {\n-    splitEnabled = DEFAULT_SPLIT_ENABLED;\n-    mergeEnabled = DEFAULT_MERGE_ENABLED;\n-    minRegionCount = DEFAULT_MIN_REGION_COUNT;\n-    mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n-    mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock();\n+    try {\n+      splitEnabled = DEFAULT_SPLIT_ENABLED;\n+      mergeEnabled = DEFAULT_MERGE_ENABLED;\n+      minRegionCount = DEFAULT_MIN_REGION_COUNT;\n+      mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n+      mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    } finally {\n+      writeLock.unlock();\n+    }\n   }\n \n   @Override\n   public Configuration getConf() {\n-    return conf;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return conf;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   @Override\n   public void setConf(final Configuration conf) {\n     if (conf == null) {\n       return;\n     }\n-    this.conf = conf;\n-    splitEnabled = conf.getBoolean(SPLIT_ENABLED_KEY, DEFAULT_SPLIT_ENABLED);\n-    mergeEnabled = conf.getBoolean(MERGE_ENABLED_KEY, DEFAULT_MERGE_ENABLED);\n-    minRegionCount = parseMinRegionCount(conf);\n-    mergeMinRegionAge = parseMergeMinRegionAge(conf);\n-    mergeMinRegionSizeMb = parseMergeMinRegionSizeMb(conf);\n+\n+    final Lock readLock = configUpdateLock.readLock();\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock(); // \"a writer can acquire the read lock, but not vice-versa.\"\n+    readLock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMzQ3NQ=="}, "originalCommit": {"oid": "557c6c9719afcfe6cf45641b44ea11097387af0b"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3MzE2OA==", "bodyText": "To me, the next sentence, This is what read-write locks allow: a resource can be accessed by multiple readers or a single writer at a time, but not both. To me, that means that by taking a writeLock, the thread holding it has exclusive access. writeLock should be enough.", "url": "https://github.com/apache/hbase/pull/2523#discussion_r509773168", "createdAt": "2020-10-21T22:44:33Z", "author": {"login": "ndimiduk"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -71,38 +76,81 @@\n   static final String MERGE_MIN_REGION_SIZE_MB_KEY = \"hbase.normalizer.merge.min_region_size.mb\";\n   static final int DEFAULT_MERGE_MIN_REGION_SIZE_MB = 1;\n \n-  private Configuration conf;\n   private MasterServices masterServices;\n-  private boolean splitEnabled;\n-  private boolean mergeEnabled;\n-  private int minRegionCount;\n-  private Period mergeMinRegionAge;\n-  private int mergeMinRegionSizeMb;\n+\n+  /** Ensure configuration changes are applied atomically. */\n+  private final ReadWriteLock configUpdateLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"configUpdateLock\") private Configuration conf;\n+  @GuardedBy(\"configUpdateLock\") private boolean splitEnabled;\n+  @GuardedBy(\"configUpdateLock\") private boolean mergeEnabled;\n+  @GuardedBy(\"configUpdateLock\") private int minRegionCount;\n+  @GuardedBy(\"configUpdateLock\") private Period mergeMinRegionAge;\n+  @GuardedBy(\"configUpdateLock\") private int mergeMinRegionSizeMb;\n \n   public SimpleRegionNormalizer() {\n-    splitEnabled = DEFAULT_SPLIT_ENABLED;\n-    mergeEnabled = DEFAULT_MERGE_ENABLED;\n-    minRegionCount = DEFAULT_MIN_REGION_COUNT;\n-    mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n-    mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock();\n+    try {\n+      splitEnabled = DEFAULT_SPLIT_ENABLED;\n+      mergeEnabled = DEFAULT_MERGE_ENABLED;\n+      minRegionCount = DEFAULT_MIN_REGION_COUNT;\n+      mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n+      mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    } finally {\n+      writeLock.unlock();\n+    }\n   }\n \n   @Override\n   public Configuration getConf() {\n-    return conf;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return conf;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   @Override\n   public void setConf(final Configuration conf) {\n     if (conf == null) {\n       return;\n     }\n-    this.conf = conf;\n-    splitEnabled = conf.getBoolean(SPLIT_ENABLED_KEY, DEFAULT_SPLIT_ENABLED);\n-    mergeEnabled = conf.getBoolean(MERGE_ENABLED_KEY, DEFAULT_MERGE_ENABLED);\n-    minRegionCount = parseMinRegionCount(conf);\n-    mergeMinRegionAge = parseMergeMinRegionAge(conf);\n-    mergeMinRegionSizeMb = parseMergeMinRegionSizeMb(conf);\n+\n+    final Lock readLock = configUpdateLock.readLock();\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock(); // \"a writer can acquire the read lock, but not vice-versa.\"\n+    readLock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMzQ3NQ=="}, "originalCommit": {"oid": "557c6c9719afcfe6cf45641b44ea11097387af0b"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3NDMzNA==", "bodyText": "But test output suggests otherwise :)", "url": "https://github.com/apache/hbase/pull/2523#discussion_r509774334", "createdAt": "2020-10-21T22:46:05Z", "author": {"login": "ndimiduk"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -71,38 +76,81 @@\n   static final String MERGE_MIN_REGION_SIZE_MB_KEY = \"hbase.normalizer.merge.min_region_size.mb\";\n   static final int DEFAULT_MERGE_MIN_REGION_SIZE_MB = 1;\n \n-  private Configuration conf;\n   private MasterServices masterServices;\n-  private boolean splitEnabled;\n-  private boolean mergeEnabled;\n-  private int minRegionCount;\n-  private Period mergeMinRegionAge;\n-  private int mergeMinRegionSizeMb;\n+\n+  /** Ensure configuration changes are applied atomically. */\n+  private final ReadWriteLock configUpdateLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"configUpdateLock\") private Configuration conf;\n+  @GuardedBy(\"configUpdateLock\") private boolean splitEnabled;\n+  @GuardedBy(\"configUpdateLock\") private boolean mergeEnabled;\n+  @GuardedBy(\"configUpdateLock\") private int minRegionCount;\n+  @GuardedBy(\"configUpdateLock\") private Period mergeMinRegionAge;\n+  @GuardedBy(\"configUpdateLock\") private int mergeMinRegionSizeMb;\n \n   public SimpleRegionNormalizer() {\n-    splitEnabled = DEFAULT_SPLIT_ENABLED;\n-    mergeEnabled = DEFAULT_MERGE_ENABLED;\n-    minRegionCount = DEFAULT_MIN_REGION_COUNT;\n-    mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n-    mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock();\n+    try {\n+      splitEnabled = DEFAULT_SPLIT_ENABLED;\n+      mergeEnabled = DEFAULT_MERGE_ENABLED;\n+      minRegionCount = DEFAULT_MIN_REGION_COUNT;\n+      mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n+      mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    } finally {\n+      writeLock.unlock();\n+    }\n   }\n \n   @Override\n   public Configuration getConf() {\n-    return conf;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return conf;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   @Override\n   public void setConf(final Configuration conf) {\n     if (conf == null) {\n       return;\n     }\n-    this.conf = conf;\n-    splitEnabled = conf.getBoolean(SPLIT_ENABLED_KEY, DEFAULT_SPLIT_ENABLED);\n-    mergeEnabled = conf.getBoolean(MERGE_ENABLED_KEY, DEFAULT_MERGE_ENABLED);\n-    minRegionCount = parseMinRegionCount(conf);\n-    mergeMinRegionAge = parseMergeMinRegionAge(conf);\n-    mergeMinRegionSizeMb = parseMergeMinRegionSizeMb(conf);\n+\n+    final Lock readLock = configUpdateLock.readLock();\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock(); // \"a writer can acquire the read lock, but not vice-versa.\"\n+    readLock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMzQ3NQ=="}, "originalCommit": {"oid": "557c6c9719afcfe6cf45641b44ea11097387af0b"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTc3ODM1Nw==", "bodyText": "Or I just did it wrong.", "url": "https://github.com/apache/hbase/pull/2523#discussion_r509778357", "createdAt": "2020-10-21T22:51:22Z", "author": {"login": "ndimiduk"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -71,38 +76,81 @@\n   static final String MERGE_MIN_REGION_SIZE_MB_KEY = \"hbase.normalizer.merge.min_region_size.mb\";\n   static final int DEFAULT_MERGE_MIN_REGION_SIZE_MB = 1;\n \n-  private Configuration conf;\n   private MasterServices masterServices;\n-  private boolean splitEnabled;\n-  private boolean mergeEnabled;\n-  private int minRegionCount;\n-  private Period mergeMinRegionAge;\n-  private int mergeMinRegionSizeMb;\n+\n+  /** Ensure configuration changes are applied atomically. */\n+  private final ReadWriteLock configUpdateLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"configUpdateLock\") private Configuration conf;\n+  @GuardedBy(\"configUpdateLock\") private boolean splitEnabled;\n+  @GuardedBy(\"configUpdateLock\") private boolean mergeEnabled;\n+  @GuardedBy(\"configUpdateLock\") private int minRegionCount;\n+  @GuardedBy(\"configUpdateLock\") private Period mergeMinRegionAge;\n+  @GuardedBy(\"configUpdateLock\") private int mergeMinRegionSizeMb;\n \n   public SimpleRegionNormalizer() {\n-    splitEnabled = DEFAULT_SPLIT_ENABLED;\n-    mergeEnabled = DEFAULT_MERGE_ENABLED;\n-    minRegionCount = DEFAULT_MIN_REGION_COUNT;\n-    mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n-    mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock();\n+    try {\n+      splitEnabled = DEFAULT_SPLIT_ENABLED;\n+      mergeEnabled = DEFAULT_MERGE_ENABLED;\n+      minRegionCount = DEFAULT_MIN_REGION_COUNT;\n+      mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n+      mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    } finally {\n+      writeLock.unlock();\n+    }\n   }\n \n   @Override\n   public Configuration getConf() {\n-    return conf;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return conf;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   @Override\n   public void setConf(final Configuration conf) {\n     if (conf == null) {\n       return;\n     }\n-    this.conf = conf;\n-    splitEnabled = conf.getBoolean(SPLIT_ENABLED_KEY, DEFAULT_SPLIT_ENABLED);\n-    mergeEnabled = conf.getBoolean(MERGE_ENABLED_KEY, DEFAULT_MERGE_ENABLED);\n-    minRegionCount = parseMinRegionCount(conf);\n-    mergeMinRegionAge = parseMergeMinRegionAge(conf);\n-    mergeMinRegionSizeMb = parseMergeMinRegionSizeMb(conf);\n+\n+    final Lock readLock = configUpdateLock.readLock();\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock(); // \"a writer can acquire the read lock, but not vice-versa.\"\n+    readLock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTAwMzQ3NQ=="}, "originalCommit": {"oid": "557c6c9719afcfe6cf45641b44ea11097387af0b"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5Mzc5NDE5OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwMzo0NDoyN1rOHmPgQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwNjowOTo1MlrOHrCXjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg2MTk1NA==", "bodyText": "Stumbled upon this change. I think there is a much simpler way to achieve this without locks and fewer lines of code (and cleaner). If we can factor all of the configs into a single object (with appropriate getters and setters if needed), something like,\nstatic class NormalizerConfig {\n  Configuration conf;\n  boolean splitEnabled;\n  private boolean mergeEnabled;\n  private Period mergeMinRegionAge;\n  private int mergeMinRegionSizeMb;\n  .......\n\n  static parseFromConfig(Conf conf);\n}\n\nprivate NormalizerConfig normalizerConf;\n\npublic void setConf(final Configuration conf) {\n   normalizerConf = parseFromConfig(conf);\n}\n\npublic boolean isSplitEnabled() {\n  return normalizerConf.isSplitEnabled();\n}\n\n\nReference assignment is atomic. So even if multiple threads call setConf(conf), each thread calls its own parseFromConfig() in it's own context, constructs the whole object and the reference assignment works cleanly. On the reader side depending on what reference is being used that point, the value is returned (ex: isSplitEnabled() above)..\nThe advantage of using these locks is the memory ordering that they enforce in methods like isSplitEnabled(). We essentially block until the reference is updated but I don't think that is a requirement here because we don't guarantee the callers of these methods (like computePlansForTable()) that they will work on the latest config while the config update is in progress (we can't guarantee that level of ordering anyway). Point here being the above approach gets rid of most code and is still not racy. WDYT.", "url": "https://github.com/apache/hbase/pull/2523#discussion_r509861954", "createdAt": "2020-10-22T03:44:27Z", "author": {"login": "bharathv"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -71,38 +76,78 @@\n   static final String MERGE_MIN_REGION_SIZE_MB_KEY = \"hbase.normalizer.merge.min_region_size.mb\";\n   static final int DEFAULT_MERGE_MIN_REGION_SIZE_MB = 1;\n \n-  private Configuration conf;\n   private MasterServices masterServices;\n-  private boolean splitEnabled;\n-  private boolean mergeEnabled;\n-  private int minRegionCount;\n-  private Period mergeMinRegionAge;\n-  private int mergeMinRegionSizeMb;\n+\n+  /** Ensure configuration changes are applied atomically. */\n+  private final ReadWriteLock configUpdateLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"configUpdateLock\") private Configuration conf;\n+  @GuardedBy(\"configUpdateLock\") private boolean splitEnabled;\n+  @GuardedBy(\"configUpdateLock\") private boolean mergeEnabled;\n+  @GuardedBy(\"configUpdateLock\") private int minRegionCount;\n+  @GuardedBy(\"configUpdateLock\") private Period mergeMinRegionAge;\n+  @GuardedBy(\"configUpdateLock\") private int mergeMinRegionSizeMb;\n \n   public SimpleRegionNormalizer() {\n-    splitEnabled = DEFAULT_SPLIT_ENABLED;\n-    mergeEnabled = DEFAULT_MERGE_ENABLED;\n-    minRegionCount = DEFAULT_MIN_REGION_COUNT;\n-    mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n-    mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock();\n+    try {\n+      splitEnabled = DEFAULT_SPLIT_ENABLED;\n+      mergeEnabled = DEFAULT_MERGE_ENABLED;\n+      minRegionCount = DEFAULT_MIN_REGION_COUNT;\n+      mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n+      mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    } finally {\n+      writeLock.unlock();\n+    }\n   }\n \n   @Override\n   public Configuration getConf() {\n-    return conf;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return conf;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   @Override\n   public void setConf(final Configuration conf) {\n     if (conf == null) {\n       return;\n     }\n-    this.conf = conf;\n-    splitEnabled = conf.getBoolean(SPLIT_ENABLED_KEY, DEFAULT_SPLIT_ENABLED);\n-    mergeEnabled = conf.getBoolean(MERGE_ENABLED_KEY, DEFAULT_MERGE_ENABLED);\n-    minRegionCount = parseMinRegionCount(conf);\n-    mergeMinRegionAge = parseMergeMinRegionAge(conf);\n-    mergeMinRegionSizeMb = parseMergeMinRegionSizeMb(conf);\n+\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a71147d4cfa2df52017e86a63a276426951d1ff"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQ5Mzc1MA==", "bodyText": "Sure @bharathv , I think that's a nice suggestion. I agree that the strict ordering guarantees provided by explicit locking are not needed here. I've pushed a new commit that unwinds the locking and uses atomic instance assignment as you suggest. Let me know what you think.", "url": "https://github.com/apache/hbase/pull/2523#discussion_r514493750", "createdAt": "2020-10-29T18:55:38Z", "author": {"login": "ndimiduk"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -71,38 +76,78 @@\n   static final String MERGE_MIN_REGION_SIZE_MB_KEY = \"hbase.normalizer.merge.min_region_size.mb\";\n   static final int DEFAULT_MERGE_MIN_REGION_SIZE_MB = 1;\n \n-  private Configuration conf;\n   private MasterServices masterServices;\n-  private boolean splitEnabled;\n-  private boolean mergeEnabled;\n-  private int minRegionCount;\n-  private Period mergeMinRegionAge;\n-  private int mergeMinRegionSizeMb;\n+\n+  /** Ensure configuration changes are applied atomically. */\n+  private final ReadWriteLock configUpdateLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"configUpdateLock\") private Configuration conf;\n+  @GuardedBy(\"configUpdateLock\") private boolean splitEnabled;\n+  @GuardedBy(\"configUpdateLock\") private boolean mergeEnabled;\n+  @GuardedBy(\"configUpdateLock\") private int minRegionCount;\n+  @GuardedBy(\"configUpdateLock\") private Period mergeMinRegionAge;\n+  @GuardedBy(\"configUpdateLock\") private int mergeMinRegionSizeMb;\n \n   public SimpleRegionNormalizer() {\n-    splitEnabled = DEFAULT_SPLIT_ENABLED;\n-    mergeEnabled = DEFAULT_MERGE_ENABLED;\n-    minRegionCount = DEFAULT_MIN_REGION_COUNT;\n-    mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n-    mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock();\n+    try {\n+      splitEnabled = DEFAULT_SPLIT_ENABLED;\n+      mergeEnabled = DEFAULT_MERGE_ENABLED;\n+      minRegionCount = DEFAULT_MIN_REGION_COUNT;\n+      mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n+      mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    } finally {\n+      writeLock.unlock();\n+    }\n   }\n \n   @Override\n   public Configuration getConf() {\n-    return conf;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return conf;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   @Override\n   public void setConf(final Configuration conf) {\n     if (conf == null) {\n       return;\n     }\n-    this.conf = conf;\n-    splitEnabled = conf.getBoolean(SPLIT_ENABLED_KEY, DEFAULT_SPLIT_ENABLED);\n-    mergeEnabled = conf.getBoolean(MERGE_ENABLED_KEY, DEFAULT_MERGE_ENABLED);\n-    minRegionCount = parseMinRegionCount(conf);\n-    mergeMinRegionAge = parseMergeMinRegionAge(conf);\n-    mergeMinRegionSizeMb = parseMergeMinRegionSizeMb(conf);\n+\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg2MTk1NA=="}, "originalCommit": {"oid": "8a71147d4cfa2df52017e86a63a276426951d1ff"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg4OTYxNA==", "bodyText": "This is cool, much simpler!", "url": "https://github.com/apache/hbase/pull/2523#discussion_r514889614", "createdAt": "2020-10-30T06:09:52Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/normalizer/SimpleRegionNormalizer.java", "diffHunk": "@@ -71,38 +76,78 @@\n   static final String MERGE_MIN_REGION_SIZE_MB_KEY = \"hbase.normalizer.merge.min_region_size.mb\";\n   static final int DEFAULT_MERGE_MIN_REGION_SIZE_MB = 1;\n \n-  private Configuration conf;\n   private MasterServices masterServices;\n-  private boolean splitEnabled;\n-  private boolean mergeEnabled;\n-  private int minRegionCount;\n-  private Period mergeMinRegionAge;\n-  private int mergeMinRegionSizeMb;\n+\n+  /** Ensure configuration changes are applied atomically. */\n+  private final ReadWriteLock configUpdateLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"configUpdateLock\") private Configuration conf;\n+  @GuardedBy(\"configUpdateLock\") private boolean splitEnabled;\n+  @GuardedBy(\"configUpdateLock\") private boolean mergeEnabled;\n+  @GuardedBy(\"configUpdateLock\") private int minRegionCount;\n+  @GuardedBy(\"configUpdateLock\") private Period mergeMinRegionAge;\n+  @GuardedBy(\"configUpdateLock\") private int mergeMinRegionSizeMb;\n \n   public SimpleRegionNormalizer() {\n-    splitEnabled = DEFAULT_SPLIT_ENABLED;\n-    mergeEnabled = DEFAULT_MERGE_ENABLED;\n-    minRegionCount = DEFAULT_MIN_REGION_COUNT;\n-    mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n-    mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock();\n+    try {\n+      splitEnabled = DEFAULT_SPLIT_ENABLED;\n+      mergeEnabled = DEFAULT_MERGE_ENABLED;\n+      minRegionCount = DEFAULT_MIN_REGION_COUNT;\n+      mergeMinRegionAge = Period.ofDays(DEFAULT_MERGE_MIN_REGION_AGE_DAYS);\n+      mergeMinRegionSizeMb = DEFAULT_MERGE_MIN_REGION_SIZE_MB;\n+    } finally {\n+      writeLock.unlock();\n+    }\n   }\n \n   @Override\n   public Configuration getConf() {\n-    return conf;\n+    final Lock readLock = configUpdateLock.readLock();\n+    readLock.lock();\n+    try {\n+      return conf;\n+    } finally {\n+      readLock.unlock();\n+    }\n   }\n \n   @Override\n   public void setConf(final Configuration conf) {\n     if (conf == null) {\n       return;\n     }\n-    this.conf = conf;\n-    splitEnabled = conf.getBoolean(SPLIT_ENABLED_KEY, DEFAULT_SPLIT_ENABLED);\n-    mergeEnabled = conf.getBoolean(MERGE_ENABLED_KEY, DEFAULT_MERGE_ENABLED);\n-    minRegionCount = parseMinRegionCount(conf);\n-    mergeMinRegionAge = parseMergeMinRegionAge(conf);\n-    mergeMinRegionSizeMb = parseMergeMinRegionSizeMb(conf);\n+\n+    final Lock writeLock = configUpdateLock.writeLock();\n+    writeLock.lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg2MTk1NA=="}, "originalCommit": {"oid": "8a71147d4cfa2df52017e86a63a276426951d1ff"}, "originalPosition": 94}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2415, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}