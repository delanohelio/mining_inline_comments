{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyNzk5NDEy", "number": 1774, "title": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region", "bodyText": "", "createdAt": "2020-05-25T15:15:50Z", "url": "https://github.com/apache/hbase/pull/1774", "merged": true, "mergeCommit": {"oid": "967b04a2a2aa4b07e23e064f1172c6230aeded1f"}, "closed": true, "closedAt": "2020-06-27T07:47:52Z", "author": {"login": "Apache9"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclCifnABqjMzNzMwMDcxNDg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcvP0xCABqjM0ODg2MzQ3ODg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "20e8aa74f7ce7543854c754d91e1567af910c5e4", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/20e8aa74f7ce7543854c754d91e1567af910c5e4", "committedDate": "2020-05-25T15:12:42Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}, "afterCommit": {"oid": "fe5a34849e61172d071f02a74e7b17b064326c54", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/fe5a34849e61172d071f02a74e7b17b064326c54", "committedDate": "2020-05-26T10:58:17Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fe5a34849e61172d071f02a74e7b17b064326c54", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/fe5a34849e61172d071f02a74e7b17b064326c54", "committedDate": "2020-05-26T10:58:17Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}, "afterCommit": {"oid": "d286a1593bf1b2e9708315f6d4050009d32c1e0f", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/d286a1593bf1b2e9708315f6d4050009d32c1e0f", "committedDate": "2020-05-26T15:39:07Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d286a1593bf1b2e9708315f6d4050009d32c1e0f", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/d286a1593bf1b2e9708315f6d4050009d32c1e0f", "committedDate": "2020-05-26T15:39:07Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}, "afterCommit": {"oid": "3a4e07df969f08994e3c4c5260a346854c098934", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/3a4e07df969f08994e3c4c5260a346854c098934", "committedDate": "2020-05-27T04:11:06Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3a4e07df969f08994e3c4c5260a346854c098934", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/3a4e07df969f08994e3c4c5260a346854c098934", "committedDate": "2020-05-27T04:11:06Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}, "afterCommit": {"oid": "f3e1b6b393b62f56af3aa3af4ab3f5d36d7defc1", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/f3e1b6b393b62f56af3aa3af4ab3f5d36d7defc1", "committedDate": "2020-05-27T15:36:01Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f3e1b6b393b62f56af3aa3af4ab3f5d36d7defc1", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/f3e1b6b393b62f56af3aa3af4ab3f5d36d7defc1", "committedDate": "2020-05-27T15:36:01Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}, "afterCommit": {"oid": "96ddfca354dcfa322a95a5151a7874d180127f8b", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/96ddfca354dcfa322a95a5151a7874d180127f8b", "committedDate": "2020-05-27T15:50:58Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "96ddfca354dcfa322a95a5151a7874d180127f8b", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/96ddfca354dcfa322a95a5151a7874d180127f8b", "committedDate": "2020-05-27T15:50:58Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}, "afterCommit": {"oid": "a0f79e992a0be1aaefc5b01528e6d152201d51b3", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/a0f79e992a0be1aaefc5b01528e6d152201d51b3", "committedDate": "2020-05-28T12:57:12Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a0f79e992a0be1aaefc5b01528e6d152201d51b3", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/a0f79e992a0be1aaefc5b01528e6d152201d51b3", "committedDate": "2020-05-28T12:57:12Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}, "afterCommit": {"oid": "805d9f502f4d7aa37eeb780c3f71f9a8432c1b01", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/805d9f502f4d7aa37eeb780c3f71f9a8432c1b01", "committedDate": "2020-05-28T14:41:02Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "805d9f502f4d7aa37eeb780c3f71f9a8432c1b01", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/805d9f502f4d7aa37eeb780c3f71f9a8432c1b01", "committedDate": "2020-05-28T14:41:02Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}, "afterCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/acc2946b315874fefa45d7853d23a8c2f52741f6", "committedDate": "2020-05-28T15:56:20Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNDA2Mzcw", "url": "https://github.com/apache/hbase/pull/1774#pullrequestreview-420406370", "createdAt": "2020-05-28T19:05:15Z", "commit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTowNToxNVrOGcCr9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTo0MDowMlrOGcDxuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1NzMzNA==", "bodyText": "This stuff committed already?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432057334", "createdAt": "2020-05-28T19:05:15Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -1403,6 +1409,21 @@ private static void deleteFromMetaTable(final Connection connection, final List<\n     }\n   }\n \n+  public static Delete removeRegionReplica(byte[] metaRow, int replicaIndexToDeleteFrom,\n+    int numReplicasToRemove) {\n+    int absoluteIndex = replicaIndexToDeleteFrom + numReplicasToRemove;\n+    long now = EnvironmentEdgeManager.currentTime();\n+    Delete deleteReplicaLocations = new Delete(metaRow);\n+    for (int i = replicaIndexToDeleteFrom; i < absoluteIndex; i++) {\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getServerColumn(i), now);\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getSeqNumColumn(i), now);\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getStartCodeColumn(i), now);\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getServerNameColumn(i), now);\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getRegionStateColumn(i), now);\n+    }\n+    return deleteReplicaLocations;\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MjU1MA==", "bodyText": "Why we need locateType now and not previously?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432062550", "createdAt": "2020-05-28T19:15:11Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -2185,4 +2206,27 @@ private static Put addSequenceNum(Put p, long openSeqNum, int replicaId) throws\n               .setValue(Bytes.toBytes(openSeqNum))\n               .build());\n   }\n+\n+  private static byte[] buildLocateRegionStartRow(TableName tableName, byte[] row,\n+    RegionLocateType locateType) {\n+    if (locateType.equals(RegionLocateType.BEFORE)) {\n+      if (Bytes.equals(row, HConstants.EMPTY_END_ROW)) {\n+        byte[] binaryTableName = tableName.getName();\n+        return Arrays.copyOf(binaryTableName, binaryTableName.length + 1);\n+      } else {\n+        return createRegionName(tableName, row, ZEROES, false);\n+      }\n+    } else {\n+      return createRegionName(tableName, row, NINES, false);\n+    }\n+  }\n+\n+  public static Scan createLocateRegionScan(TableName tableName, byte[] row,\n+    RegionLocateType locateType, int prefetchLimit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NDIyOQ==", "bodyText": "Two locators. Can we not have one?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432064229", "createdAt": "2020-05-28T19:18:27Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.AsyncMetaTableAccessor;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.MetaTableAccessor;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.TableNotFoundException;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The class for locating region for table other than meta.\n+ */\n+@InterfaceAudience.Private\n+class AsyncNonMetaTableRegionLocator extends AbstractAsyncTableRegionLocator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NTQ4Nw==", "bodyText": "An AsyncNonMetaTableRegionLocator is for user-space Regions? We also have AsyncRegionLocator... and Abstract* Do we have to have this many classes?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432065487", "createdAt": "2020-05-28T19:20:54Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.AsyncMetaTableAccessor;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.MetaTableAccessor;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.TableNotFoundException;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The class for locating region for table other than meta.\n+ */\n+@InterfaceAudience.Private\n+class AsyncNonMetaTableRegionLocator extends AbstractAsyncTableRegionLocator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NDIyOQ=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3MzQxOA==", "bodyText": "Why is this not just a case of Scan forward or Scan backward?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432073418", "createdAt": "2020-05-28T19:36:22Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -2185,4 +2206,27 @@ private static Put addSequenceNum(Put p, long openSeqNum, int replicaId) throws\n               .setValue(Bytes.toBytes(openSeqNum))\n               .build());\n   }\n+\n+  private static byte[] buildLocateRegionStartRow(TableName tableName, byte[] row,\n+    RegionLocateType locateType) {\n+    if (locateType.equals(RegionLocateType.BEFORE)) {\n+      if (Bytes.equals(row, HConstants.EMPTY_END_ROW)) {\n+        byte[] binaryTableName = tableName.getName();\n+        return Arrays.copyOf(binaryTableName, binaryTableName.length + 1);\n+      } else {\n+        return createRegionName(tableName, row, ZEROES, false);\n+      }\n+    } else {\n+      return createRegionName(tableName, row, NINES, false);\n+    }\n+  }\n+\n+  public static Scan createLocateRegionScan(TableName tableName, byte[] row,\n+    RegionLocateType locateType, int prefetchLimit) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MjU1MA=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NTE5Mg==", "bodyText": "Why we now need type?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432075192", "createdAt": "2020-05-28T19:40:02Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.HConstants.EMPTY_END_ROW;\n+import static org.apache.hadoop.hbase.client.AsyncRegionLocatorHelper.isGood;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.hadoop.hbase.HBaseIOException;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * The base class for locating region of a table.\n+ */\n+@InterfaceAudience.Private\n+abstract class AbstractAsyncTableRegionLocator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(AbstractAsyncTableRegionLocator.class);\n+\n+  protected final AsyncConnectionImpl conn;\n+\n+  protected final TableName tableName;\n+\n+  protected final int maxConcurrent;\n+\n+  protected final TableRegionLocationCache cache;\n+\n+  protected static final class LocateRequest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 62}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/acc2946b315874fefa45d7853d23a8c2f52741f6", "committedDate": "2020-05-28T15:56:20Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}, "afterCommit": {"oid": "960c288329e4f6bf9c918a556e73c927cb03fb2f", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/960c288329e4f6bf9c918a556e73c927cb03fb2f", "committedDate": "2020-05-29T02:12:23Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "960c288329e4f6bf9c918a556e73c927cb03fb2f", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/960c288329e4f6bf9c918a556e73c927cb03fb2f", "committedDate": "2020-05-29T02:12:23Z", "message": "HBASE-24389 Introduce a new master rpc service to locate meta region through root region"}, "afterCommit": {"oid": "d989e78c4264120fb06765f8e7feb6b349c11c02", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/d989e78c4264120fb06765f8e7feb6b349c11c02", "committedDate": "2020-06-02T04:19:30Z", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d989e78c4264120fb06765f8e7feb6b349c11c02", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/d989e78c4264120fb06765f8e7feb6b349c11c02", "committedDate": "2020-06-02T04:19:30Z", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region"}, "afterCommit": {"oid": "0f10bfe7a4c6a852fa56cfa479f62e2123bb5321", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/0f10bfe7a4c6a852fa56cfa479f62e2123bb5321", "committedDate": "2020-06-05T14:39:48Z", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0f10bfe7a4c6a852fa56cfa479f62e2123bb5321", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/0f10bfe7a4c6a852fa56cfa479f62e2123bb5321", "committedDate": "2020-06-05T14:39:48Z", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region"}, "afterCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "committedDate": "2020-06-08T02:50:42Z", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODg2Mjg1", "url": "https://github.com/apache/hbase/pull/1774#pullrequestreview-425886285", "createdAt": "2020-06-08T02:36:15Z", "commit": {"oid": "0f10bfe7a4c6a852fa56cfa479f62e2123bb5321"}, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMjozNjoxNVrOGgNv5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo1MzozOFrOGgOg5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMjg2OQ==", "bodyText": "Why we need this? The default is not to return offlined locations (as per the the original method impl). You ask for raw scan if you do want all including offlined.\ns/excludeOfflinedSplitParents/excludeSplitParents/ because split parents are offlined by definition?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436432869", "createdAt": "2020-06-08T02:36:15Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/AsyncMetaTableAccessor.java", "diffHunk": "@@ -170,26 +170,27 @@\n \n   /**\n    * Used to get all region locations for the specific table.\n-   * @param metaTable\n    * @param tableName table we're looking for, can be null for getting all regions\n    * @return the list of region locations. The return value will be wrapped by a\n    *         {@link CompletableFuture}.\n    */\n   public static CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(\n-      AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName) {\n+    AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName,\n+    boolean excludeOfflinedSplitParents) {\n     CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-    addListener(getTableRegionsAndLocations(metaTable, tableName, true), (locations, err) -> {\n-      if (err != null) {\n-        future.completeExceptionally(err);\n-      } else if (locations == null || locations.isEmpty()) {\n-        future.complete(Collections.emptyList());\n-      } else {\n-        List<HRegionLocation> regionLocations =\n-          locations.stream().map(loc -> new HRegionLocation(loc.getFirst(), loc.getSecond()))\n-            .collect(Collectors.toList());\n-        future.complete(regionLocations);\n-      }\n-    });\n+    addListener(getTableRegionsAndLocations(metaTable, tableName, excludeOfflinedSplitParents),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f10bfe7a4c6a852fa56cfa479f62e2123bb5321"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzNTIzNg==", "bodyText": "This is async version of\n// What happens here when 1M regions in hbase:meta? This won't scale?\n public static List<Pair<RegionInfo, ServerName>> getTableRegionsAndLocations(", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436435236", "createdAt": "2020-06-08T02:51:12Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/AsyncMetaTableAccessor.java", "diffHunk": "@@ -170,26 +170,27 @@\n \n   /**\n    * Used to get all region locations for the specific table.\n-   * @param metaTable\n    * @param tableName table we're looking for, can be null for getting all regions\n    * @return the list of region locations. The return value will be wrapped by a\n    *         {@link CompletableFuture}.\n    */\n   public static CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(\n-      AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName) {\n+    AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName,\n+    boolean excludeOfflinedSplitParents) {\n     CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-    addListener(getTableRegionsAndLocations(metaTable, tableName, true), (locations, err) -> {\n-      if (err != null) {\n-        future.completeExceptionally(err);\n-      } else if (locations == null || locations.isEmpty()) {\n-        future.complete(Collections.emptyList());\n-      } else {\n-        List<HRegionLocation> regionLocations =\n-          locations.stream().map(loc -> new HRegionLocation(loc.getFirst(), loc.getSecond()))\n-            .collect(Collectors.toList());\n-        future.complete(regionLocations);\n-      }\n-    });\n+    addListener(getTableRegionsAndLocations(metaTable, tableName, excludeOfflinedSplitParents),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMjg2OQ=="}, "originalCommit": {"oid": "0f10bfe7a4c6a852fa56cfa479f62e2123bb5321"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzNjYxOQ==", "bodyText": "'abstraction'? IIRC, this class is the access point for hbase:meta. It is all about Scans that take Visitors, Puts, and Deletes against hbase:meta; i.e. not 'abstractions'.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436436619", "createdAt": "2020-06-08T02:59:41Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -2185,4 +2206,27 @@ private static Put addSequenceNum(Put p, long openSeqNum, int replicaId) throws\n               .setValue(Bytes.toBytes(openSeqNum))\n               .build());\n   }\n+\n+  private static byte[] buildLocateRegionStartRow(TableName tableName, byte[] row,\n+    RegionLocateType locateType) {\n+    if (locateType.equals(RegionLocateType.BEFORE)) {\n+      if (Bytes.equals(row, HConstants.EMPTY_END_ROW)) {\n+        byte[] binaryTableName = tableName.getName();\n+        return Arrays.copyOf(binaryTableName, binaryTableName.length + 1);\n+      } else {\n+        return createRegionName(tableName, row, ZEROES, false);\n+      }\n+    } else {\n+      return createRegionName(tableName, row, NINES, false);\n+    }\n+  }\n+\n+  public static Scan createLocateRegionScan(TableName tableName, byte[] row,\n+    RegionLocateType locateType, int prefetchLimit) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MjU1MA=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzNjk4MA==", "bodyText": "Has to be an abstract? If so, why?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436436980", "createdAt": "2020-06-08T03:01:38Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.HConstants.EMPTY_END_ROW;\n+import static org.apache.hadoop.hbase.client.AsyncRegionLocatorHelper.isGood;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.hadoop.hbase.HBaseIOException;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * The base class for locating region of a table.\n+ */\n+@InterfaceAudience.Private\n+abstract class AbstractAsyncTableRegionLocator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(AbstractAsyncTableRegionLocator.class);\n+\n+  protected final AsyncConnectionImpl conn;\n+\n+  protected final TableName tableName;\n+\n+  protected final int maxConcurrent;\n+\n+  protected final TableRegionLocationCache cache;\n+\n+  protected static final class LocateRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NTE5Mg=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzODU0OA==", "bodyText": "hmmm... Went back and saw the locateInMeta.  This replicates the head of that method? It should use this?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436438548", "createdAt": "2020-06-08T03:12:04Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -2185,4 +2206,27 @@ private static Put addSequenceNum(Put p, long openSeqNum, int replicaId) throws\n               .setValue(Bytes.toBytes(openSeqNum))\n               .build());\n   }\n+\n+  private static byte[] buildLocateRegionStartRow(TableName tableName, byte[] row,\n+    RegionLocateType locateType) {\n+    if (locateType.equals(RegionLocateType.BEFORE)) {\n+      if (Bytes.equals(row, HConstants.EMPTY_END_ROW)) {\n+        byte[] binaryTableName = tableName.getName();\n+        return Arrays.copyOf(binaryTableName, binaryTableName.length + 1);\n+      } else {\n+        return createRegionName(tableName, row, ZEROES, false);\n+      }\n+    } else {\n+      return createRegionName(tableName, row, NINES, false);\n+    }\n+  }\n+\n+  public static Scan createLocateRegionScan(TableName tableName, byte[] row,\n+    RegionLocateType locateType, int prefetchLimit) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MjU1MA=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzOTczNQ==", "bodyText": "I see, abstract to share code between user-space and meta-space table locators.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436439735", "createdAt": "2020-06-08T03:19:32Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.HConstants.EMPTY_END_ROW;\n+import static org.apache.hadoop.hbase.client.AsyncRegionLocatorHelper.isGood;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.hadoop.hbase.HBaseIOException;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * The base class for locating region of a table.\n+ */\n+@InterfaceAudience.Private\n+abstract class AbstractAsyncTableRegionLocator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(AbstractAsyncTableRegionLocator.class);\n+\n+  protected final AsyncConnectionImpl conn;\n+\n+  protected final TableName tableName;\n+\n+  protected final int maxConcurrent;\n+\n+  protected final TableRegionLocationCache cache;\n+\n+  protected static final class LocateRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NTE5Mg=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MDEzOQ==", "bodyText": "Still this new Service? Not ConnectionRegistry?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436440139", "createdAt": "2020-06-08T03:22:00Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncMetaTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.MasterNotRunningException;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.exceptions.ClientExceptionsUtil;\n+import org.apache.hadoop.hbase.ipc.HBaseRpcController;\n+import org.apache.hadoop.hbase.ipc.ServerNotRunningYetException;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.protobuf.ByteString;\n+\n+import org.apache.hadoop.hbase.shaded.protobuf.ProtobufUtil;\n+import org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos.ClientMetaService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MDM3MQ==", "bodyText": "Ok. I'm reacting to our Interface => Abstract => Impl tiering.... We do it too often.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436440371", "createdAt": "2020-06-08T03:23:44Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.AsyncMetaTableAccessor;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.MetaTableAccessor;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.TableNotFoundException;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The class for locating region for table other than meta.\n+ */\n+@InterfaceAudience.Private\n+class AsyncNonMetaTableRegionLocator extends AbstractAsyncTableRegionLocator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NDIyOQ=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MDU0MQ==", "bodyText": "Whats this? One locator for meta and another for user-space Tables?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436440541", "createdAt": "2020-06-08T03:25:04Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRegionLocator.java", "diffHunk": "@@ -44,25 +51,51 @@\n @InterfaceAudience.Private\n class AsyncRegionLocator {\n \n-  private static final Logger LOG = LoggerFactory.getLogger(AsyncRegionLocator.class);\n+  @VisibleForTesting\n+  static final String MAX_CONCURRENT_LOCATE_REQUEST_PER_TABLE =\n+    \"hbase.client.meta.max.concurrent.locate.per.table\";\n+\n+  private static final int DEFAULT_MAX_CONCURRENT_LOCATE_REQUEST_PER_TABLE = 8;\n+\n+  @VisibleForTesting\n+  static final String MAX_CONCURRENT_LOCATE_META_REQUEST =\n+    \"hbase.client.meta.max.concurrent.locate\";\n+\n+  @VisibleForTesting\n+  static String LOCATE_PREFETCH_LIMIT = \"hbase.client.locate.prefetch.limit\";\n+\n+  private static final int DEFAULT_LOCATE_PREFETCH_LIMIT = 10;\n \n   private final HashedWheelTimer retryTimer;\n \n   private final AsyncConnectionImpl conn;\n \n-  private final AsyncMetaRegionLocator metaRegionLocator;\n+  private final int maxConcurrentLocateRequestPerTable;\n+\n+  private final int maxConcurrentLocateMetaRequest;\n+\n+  private final int locatePrefetchLimit;\n \n-  private final AsyncNonMetaRegionLocator nonMetaRegionLocator;\n+  private final boolean useMetaReplicas;\n \n-  AsyncRegionLocator(AsyncConnectionImpl conn, HashedWheelTimer retryTimer) {\n+  private final ConcurrentMap<TableName, AbstractAsyncTableRegionLocator> table2Locator =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MTU2MA==", "bodyText": "Just removed. We trying to add api in here https://docs.google.com/document/d/1OYrCfpmmLPkSa5-AepQw8hv09zNcNPaFzSXezhcMS7E/edit?ts=5ed4e463#heading=h.kxnc4cup53tk", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436441560", "createdAt": "2020-06-08T03:30:33Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionRegistry.java", "diffHunk": "@@ -31,11 +30,6 @@\n @InterfaceAudience.Private\n interface ConnectionRegistry extends Closeable {\n \n-  /**\n-   * Get the location of meta region(s).\n-   */\n-  CompletableFuture<RegionLocations> getMetaRegionLocations();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MTY3Mg==", "bodyText": "Not used any more?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436441672", "createdAt": "2020-06-08T03:31:08Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -186,24 +186,6 @@ public long getNonceGroup() {\n     return Arrays.copyOf(row, row.length + 1);\n   }\n \n-  /**\n-   * Create a row before the specified row and very close to the specified row.\n-   */\n-  static byte[] createCloseRowBefore(byte[] row) {\n-    if (row.length == 0) {\n-      return MAX_BYTE_ARRAY;\n-    }\n-    if (row[row.length - 1] == 0) {\n-      return Arrays.copyOf(row, row.length - 1);\n-    } else {\n-      byte[] nextRow = new byte[row.length + MAX_BYTE_ARRAY.length];\n-      System.arraycopy(row, 0, nextRow, 0, row.length - 1);\n-      nextRow[row.length - 1] = (byte) ((row[row.length - 1] & 0xFF) - 1);\n-      System.arraycopy(MAX_BYTE_ARRAY, 0, nextRow, row.length, MAX_BYTE_ARRAY.length);\n-      return nextRow;\n-    }\n-  }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjI0MA==", "bodyText": "Having trouble following what is going on. Excuse me.\nThis looks better. Gets RegionLocator from Connection.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436442240", "createdAt": "2020-06-08T03:35:07Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/RawAsyncHBaseAdmin.java", "diffHunk": "@@ -1105,23 +1097,7 @@ public void run(PRESP resp) {\n    * List all region locations for the specific table.\n    */\n   private CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(TableName tableName) {\n-    if (TableName.META_TABLE_NAME.equals(tableName)) {\n-      CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-      addListener(connection.registry.getMetaRegionLocations(), (metaRegions, err) -> {\n-        if (err != null) {\n-          future.completeExceptionally(err);\n-        } else if (metaRegions == null || metaRegions.isEmpty() ||\n-          metaRegions.getDefaultRegionLocation() == null) {\n-          future.completeExceptionally(new IOException(\"meta region does not found\"));\n-        } else {\n-          future.complete(Collections.singletonList(metaRegions.getDefaultRegionLocation()));\n-        }\n-      });\n-      return future;\n-    } else {\n-      // For non-meta table, we fetch all locations by scanning hbase:meta table\n-      return AsyncMetaTableAccessor.getTableHRegionLocations(metaTable, tableName);\n-    }\n+    return connection.getRegionLocator(tableName).getAllRegionLocations();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjMyNw==", "bodyText": "RegionLocator does the right thing based off table name?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436442327", "createdAt": "2020-06-08T03:35:36Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/RawAsyncHBaseAdmin.java", "diffHunk": "@@ -1105,23 +1097,7 @@ public void run(PRESP resp) {\n    * List all region locations for the specific table.\n    */\n   private CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(TableName tableName) {\n-    if (TableName.META_TABLE_NAME.equals(tableName)) {\n-      CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-      addListener(connection.registry.getMetaRegionLocations(), (metaRegions, err) -> {\n-        if (err != null) {\n-          future.completeExceptionally(err);\n-        } else if (metaRegions == null || metaRegions.isEmpty() ||\n-          metaRegions.getDefaultRegionLocation() == null) {\n-          future.completeExceptionally(new IOException(\"meta region does not found\"));\n-        } else {\n-          future.complete(Collections.singletonList(metaRegions.getDefaultRegionLocation()));\n-        }\n-      });\n-      return future;\n-    } else {\n-      // For non-meta table, we fetch all locations by scanning hbase:meta table\n-      return AsyncMetaTableAccessor.getTableHRegionLocations(metaTable, tableName);\n-    }\n+    return connection.getRegionLocator(tableName).getAllRegionLocations();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjI0MA=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MzIwMg==", "bodyText": "Why is this wanted in proto now if we had it since async came in?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436443202", "createdAt": "2020-06-08T03:40:24Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/shaded/protobuf/ProtobufUtil.java", "diffHunk": "@@ -3537,4 +3538,30 @@ public static RSGroupInfo toGroupInfo(RSGroupProtos.RSGroupInfo proto) {\n     return RSGroupProtos.RSGroupInfo.newBuilder().setName(pojo.getName()).addAllServers(hostports)\n         .addAllTables(tables).build();\n   }\n+\n+  public static MasterProtos.RegionLocateType toProtoRegionLocateType(RegionLocateType pojo) {\n+    switch (pojo) {\n+      case BEFORE:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_BEFORE;\n+      case CURRENT:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_CURRENT;\n+      case AFTER:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_AFTER;\n+      default:\n+        throw new IllegalArgumentException(\"Unknown RegionLocateType: \" + pojo);\n+    }\n+  }\n+\n+  public static RegionLocateType toRegionLocateType(MasterProtos.RegionLocateType proto) {\n+    switch (proto) {\n+      case REGION_LOCATE_TYPE_BEFORE:\n+        return RegionLocateType.BEFORE;\n+      case REGION_LOCATE_TYPE_CURRENT:\n+        return RegionLocateType.CURRENT;\n+      case REGION_LOCATE_TYPE_AFTER:\n+        return RegionLocateType.AFTER;\n+      default:\n+        throw new IllegalArgumentException(\"Unknown proto RegionLocateType: \" + proto);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0Mzg5MQ==", "bodyText": "ClientMetaService backed ConnectionRegistry?\nSo, we get one Region or all of them... nothing in-between?\nNo Scan support here because we want 'dumbed-down API' in ConnectionRegistry or in exposed ClientMetaService? We want to be able to implement hbase:meta Region locations in cache that we can serve from ZK for your ZKConnectionRegistry impl?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436443891", "createdAt": "2020-06-08T03:44:56Z", "author": {"login": "saintstack"}, "path": "hbase-protocol-shaded/src/main/protobuf/server/master/Master.proto", "diffHunk": "@@ -1284,4 +1307,16 @@ service ClientMetaService {\n    * Get current meta replicas' region locations.\n    */\n   rpc GetMetaRegionLocations(GetMetaRegionLocationsRequest) returns(GetMetaRegionLocationsResponse);\n+\n+  /**\n+   * Get meta region locations for a given row\n+   */\n+  rpc LocateMetaRegion(LocateMetaRegionRequest)\n+    returns(LocateMetaRegionResponse);\n+\n+  /**\n+   * Get all meta regions locations\n+   */\n+  rpc GetAllMetaRegionLocations(GetAllMetaRegionLocationsRequest)\n+    returns(GetAllMetaRegionLocationsResponse);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDM4NA==", "bodyText": "This is hard-coding Master as host of hbase:meta locations?\nWe have MasterRegistry and the ZKRegistry and but Master is host for all meta locations? This skirts Registry?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436444384", "createdAt": "2020-06-08T03:47:35Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/MasterObserver.java", "diffHunk": "@@ -1763,4 +1765,44 @@ default void preHasUserPermissions(ObserverContext<MasterCoprocessorEnvironment>\n   default void postHasUserPermissions(ObserverContext<MasterCoprocessorEnvironment> ctx,\n       String userName, List<Permission> permissions) throws IOException {\n   }\n+\n+  /**\n+   * Called before locating meta region.\n+   * @param ctx ctx the coprocessor instance's environment\n+   * @param row the row key to locate\n+   * @param locateType the direction of the locate operation\n+   */\n+  default void preLocateMetaRegion(ObserverContext<MasterCoprocessorEnvironment> ctx, byte[] row,\n+    RegionLocateType locateType) throws IOException {\n+  }\n+\n+  /**\n+   * Called after locating meta region.\n+   * @param ctx ctx the coprocessor instance's environment\n+   * @param row the row key to locate\n+   * @param locateType the direction of the locate operation\n+   * @param locs the locations of the given meta region, including meta replicas if any.\n+   */\n+  default void postLocateMetaRegion(ObserverContext<MasterCoprocessorEnvironment> ctx, byte[] row,\n+    RegionLocateType locateType, List<HRegionLocation> locs) throws IOException {\n+  }\n+\n+  /**\n+   * Called before getting all locations for meta regions.\n+   * @param ctx ctx the coprocessor instance's environment\n+   * @param excludeOfflinedSplitParents don't return split parents\n+   */\n+  default void preGetAllMetaRegionLocations(ObserverContext<MasterCoprocessorEnvironment> ctx,\n+    boolean excludeOfflinedSplitParents) {\n+  }\n+\n+  /**\n+   * Called after getting all locations for meta regions.\n+   * @param ctx ctx the coprocessor instance's environment\n+   * @param excludeOfflinedSplitParents don't return split parents\n+   * @param locs the locations of all meta regions, including meta replicas if any.\n+   */\n+  default void postGetAllMetaRegionLocations(ObserverContext<MasterCoprocessorEnvironment> ctx,\n+    boolean excludeOfflinedSplitParents, List<HRegionLocation> locs) {\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDU3MA==", "bodyText": "Region State is in zk?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436444570", "createdAt": "2020-06-08T03:48:48Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -868,8 +879,71 @@ protected void initializeZKBasedSystemTrackers()\n \n   // Will be overriden in test to inject customized AssignmentManager\n   @VisibleForTesting\n-  protected AssignmentManager createAssignmentManager(MasterServices master) {\n-    return new AssignmentManager(master);\n+  protected AssignmentManager createAssignmentManager(MasterServices master,\n+    MasterRegion masterRegion) {\n+    return new AssignmentManager(master, masterRegion);\n+  }\n+\n+  /**\n+   * Load the meta region state from the meta region server ZNode.\n+   * @param zkw reference to the {@link ZKWatcher} which also contains configuration and operation\n+   * @param replicaId the ID of the replica\n+   * @return regionstate\n+   * @throws KeeperException if a ZooKeeper operation fails\n+   */\n+  private static RegionState getMetaRegionState(ZKWatcher zkw, int replicaId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDY0OA==", "bodyText": "Perhaps this is old state? If so, maybe say so in doc?\nThe @return regionstate can be removed.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436444648", "createdAt": "2020-06-08T03:49:15Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -868,8 +879,71 @@ protected void initializeZKBasedSystemTrackers()\n \n   // Will be overriden in test to inject customized AssignmentManager\n   @VisibleForTesting\n-  protected AssignmentManager createAssignmentManager(MasterServices master) {\n-    return new AssignmentManager(master);\n+  protected AssignmentManager createAssignmentManager(MasterServices master,\n+    MasterRegion masterRegion) {\n+    return new AssignmentManager(master, masterRegion);\n+  }\n+\n+  /**\n+   * Load the meta region state from the meta region server ZNode.\n+   * @param zkw reference to the {@link ZKWatcher} which also contains configuration and operation\n+   * @param replicaId the ID of the replica\n+   * @return regionstate\n+   * @throws KeeperException if a ZooKeeper operation fails\n+   */\n+  private static RegionState getMetaRegionState(ZKWatcher zkw, int replicaId)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDU3MA=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTA4MQ==", "bodyText": "Don't understand.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436445081", "createdAt": "2020-06-08T03:51:48Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -3921,4 +3996,85 @@ public MetaRegionLocationCache getMetaRegionLocationCache() {\n   public RSGroupInfoManager getRSGroupInfoManager() {\n     return rsGroupInfoManager;\n   }\n+\n+  public RegionLocations locateMeta(byte[] row, RegionLocateType locateType) throws IOException {\n+    if (locateType == RegionLocateType.AFTER) {\n+      // as we know the exact row after us, so we can just create the new row, and use the same\n+      // algorithm to locate it.\n+      row = Arrays.copyOf(row, row.length + 1);\n+      locateType = RegionLocateType.CURRENT;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTQxMw==", "bodyText": "This stuff is inline in HMaster class? Not out in Meta Table Accessor?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436445413", "createdAt": "2020-06-08T03:53:38Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -3921,4 +3996,85 @@ public MetaRegionLocationCache getMetaRegionLocationCache() {\n   public RSGroupInfoManager getRSGroupInfoManager() {\n     return rsGroupInfoManager;\n   }\n+\n+  public RegionLocations locateMeta(byte[] row, RegionLocateType locateType) throws IOException {\n+    if (locateType == RegionLocateType.AFTER) {\n+      // as we know the exact row after us, so we can just create the new row, and use the same\n+      // algorithm to locate it.\n+      row = Arrays.copyOf(row, row.length + 1);\n+      locateType = RegionLocateType.CURRENT;\n+    }\n+    Scan scan =\n+      MetaTableAccessor.createLocateRegionScan(TableName.META_TABLE_NAME, row, locateType, 1);\n+    try (RegionScanner scanner = masterRegion.getScanner(scan)) {\n+      boolean moreRows;\n+      List<Cell> cells = new ArrayList<>();\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n+        }\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionLocations locs = MetaTableAccessor.getRegionLocations(result);\n+        if (locs == null || locs.getDefaultRegionLocation() == null) {\n+          LOG.warn(\"No location found when locating meta region with row='{}', locateType={}\",\n+            Bytes.toStringBinary(row), locateType);\n+          return null;\n+        }\n+        HRegionLocation loc = locs.getDefaultRegionLocation();\n+        RegionInfo info = loc.getRegion();\n+        if (info == null) {\n+          LOG.warn(\"HRegionInfo is null when locating meta region with row='{}', locateType={}\",\n+            Bytes.toStringBinary(row), locateType);\n+          return null;\n+        }\n+        if (info.isSplitParent()) {\n+          continue;\n+        }\n+        return locs;\n+      } while (moreRows);\n+      LOG.warn(\"No location available when locating meta region with row='{}', locateType={}\",\n+        Bytes.toStringBinary(row), locateType);\n+      return null;\n+    }\n+  }\n+\n+  public List<RegionLocations> getAllMetaRegionLocations(boolean excludeOfflinedSplitParents)\n+    throws IOException {\n+    Scan scan = new Scan().addFamily(HConstants.CATALOG_FAMILY);\n+    List<RegionLocations> list = new ArrayList<>();\n+    try (RegionScanner scanner = masterRegion.getScanner(scan)) {\n+      boolean moreRows;\n+      List<Cell> cells = new ArrayList<>();\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n+        }\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionLocations locs = MetaTableAccessor.getRegionLocations(result);\n+        if (locs == null) {\n+          LOG.warn(\"No locations in {}\", result);\n+          continue;\n+        }\n+        HRegionLocation loc = locs.getRegionLocation();\n+        if (loc == null) {\n+          LOG.warn(\"No non null location in {}\", result);\n+          continue;\n+        }\n+        RegionInfo info = loc.getRegion();\n+        if (info == null) {\n+          LOG.warn(\"No serialized RegionInfo in {}\", result);\n+          continue;\n+        }\n+        if (excludeOfflinedSplitParents && info.isSplitParent()) {\n+          continue;\n+        }\n+        list.add(locs);\n+      } while (moreRows);\n+    }\n+    return list;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 268}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NjQ3NDA1", "url": "https://github.com/apache/hbase/pull/1774#pullrequestreview-426647405", "createdAt": "2020-06-08T21:51:22Z", "commit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMTo1MToyM1rOGgxsCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMzowNTo0MlrOGgzVcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyMTcwNQ==", "bodyText": "master local region", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437021705", "createdAt": "2020-06-08T21:51:23Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java", "diffHunk": "@@ -2319,17 +2317,13 @@ private boolean skipReportingTransition(final RegionStateTransitionContext conte\n     if (code == TransitionCode.OPENED) {\n       Preconditions.checkArgument(hris != null && hris.length == 1);\n       if (hris[0].isMetaRegion()) {\n-        try {\n-          MetaTableLocator.setMetaLocation(getZooKeeper(), serverName,\n-              hris[0].getReplicaId(), RegionState.State.OPEN);\n-        } catch (KeeperException e) {\n-          LOG.info(\"Failed to update meta location\", e);\n-          return false;\n-        }\n+        LOG.warn(\n+          \"meta table location is stored in master local store, so we can not skip reporting\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNjAyOA==", "bodyText": "TABLENAME is 'master:store'. Should it be 'master:region'? Configs are hbase.master.store.region.* which is odd given we usually talk of region having a store, not other way around.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437026028", "createdAt": "2020-06-08T22:02:02Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/region/MasterRegionFactory.java", "diffHunk": "@@ -80,6 +83,10 @@\n   public static final byte[] PROC_FAMILY = Bytes.toBytes(\"proc\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNjY0Ng==", "bodyText": "Too late to changes this?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437026646", "createdAt": "2020-06-08T22:03:42Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/region/MasterRegionFactory.java", "diffHunk": "@@ -80,6 +83,10 @@\n   public static final byte[] PROC_FAMILY = Bytes.toBytes(\"proc\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNjAyOA=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNzE0Ng==", "bodyText": "We don't need to make sure meta is available first anymore? Or is this because we might be doing create meta table with this procedure going forward?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437027146", "createdAt": "2020-06-08T22:04:56Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/procedure/CreateTableProcedure.java", "diffHunk": "@@ -365,8 +365,6 @@ protected static void moveTempDirectoryToHBaseRoot(\n       final List<RegionInfo> regions) throws IOException {\n     assert (regions != null && regions.size() > 0) : \"expected at least 1 region, got \" + regions;\n \n-    ProcedureSyncWait.waitMetaRegions(env);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzOTMyMw==", "bodyText": "Does MasterRegistry put meta location in zk?  If not, we'd mirror to zk here anyways even if we are using MasterRegistry?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437039323", "createdAt": "2020-06-08T22:37:27Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/assignment/AssignmentManager.java", "diffHunk": "@@ -224,23 +229,52 @@ public void start() throws IOException, KeeperException {\n     // Start the Assignment Thread\n     startAssignmentThread();\n \n-    // load meta region state\n-    ZKWatcher zkw = master.getZooKeeper();\n-    // it could be null in some tests\n-    if (zkw != null) {\n-      RegionState regionState = MetaTableLocator.getMetaRegionState(zkw);\n-      RegionStateNode regionNode =\n-        regionStates.getOrCreateRegionStateNode(RegionInfoBuilder.FIRST_META_REGIONINFO);\n-      regionNode.lock();\n-      try {\n-        regionNode.setRegionLocation(regionState.getServerName());\n-        regionNode.setState(regionState.getState());\n-        if (regionNode.getProcedure() != null) {\n-          regionNode.getProcedure().stateLoaded(this, regionNode);\n+    // load meta region states.\n+    // notice that, here we will load all replicas, and in MasterMetaBootstrap we may assign new\n+    // replicas, or remove excess replicas.\n+    try (RegionScanner scanner =\n+      masterRegion.getScanner(new Scan().addFamily(HConstants.CATALOG_FAMILY))) {\n+      List<Cell> cells = new ArrayList<>();\n+      boolean moreRows;\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n         }\n-        setMetaAssigned(regionState.getRegion(), regionState.getState() == State.OPEN);\n-      } finally {\n-        regionNode.unlock();\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionStateStore\n+          .visitMetaEntry((r, regionInfo, state, regionLocation, lastHost, openSeqNum) -> {\n+            RegionStateNode regionNode = regionStates.getOrCreateRegionStateNode(regionInfo);\n+            regionNode.lock();\n+            try {\n+              regionNode.setState(state);\n+              regionNode.setLastHost(lastHost);\n+              regionNode.setRegionLocation(regionLocation);\n+              regionNode.setOpenSeqNum(openSeqNum);\n+              if (regionNode.getProcedure() != null) {\n+                regionNode.getProcedure().stateLoaded(this, regionNode);\n+              }\n+              if (RegionReplicaUtil.isDefaultReplica(regionInfo)) {\n+                setMetaAssigned(regionInfo, state == State.OPEN);\n+              }\n+            } finally {\n+              regionNode.unlock();\n+            }\n+            if (regionInfo.isFirst()) {\n+              // for compatibility, mirror the meta region state to zookeeper\n+              try {\n+                regionStateStore.mirrorMetaLocation(regionInfo, regionLocation, state);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MDUzMg==", "bodyText": "We'd not get this info from the Connection via Registry? Or is it that this is pure internal to Master? Reads the Master local Region content? If so, why the param? What internal needs this?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437040532", "createdAt": "2020-06-08T22:40:57Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterServices.java", "diffHunk": "@@ -552,4 +553,12 @@ default SplitWALManager getSplitWALManager(){\n    * @return The state of the load balancer, or false if the load balancer isn't defined.\n    */\n   boolean isBalancerOn();\n+\n+  /**\n+   * Get locations for all meta regions.\n+   * @param excludeOfflinedSplitParents don't return split parents\n+   * @return The locations of all the meta regions\n+   */\n+  List<RegionLocations> getAllMetaRegionLocations(boolean excludeOfflinedSplitParents)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MzE4OA==", "bodyText": "MasterRegion deserves own accessor. MasterRegionAccessor", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437043188", "createdAt": "2020-06-08T22:49:07Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -3921,4 +3996,85 @@ public MetaRegionLocationCache getMetaRegionLocationCache() {\n   public RSGroupInfoManager getRSGroupInfoManager() {\n     return rsGroupInfoManager;\n   }\n+\n+  public RegionLocations locateMeta(byte[] row, RegionLocateType locateType) throws IOException {\n+    if (locateType == RegionLocateType.AFTER) {\n+      // as we know the exact row after us, so we can just create the new row, and use the same\n+      // algorithm to locate it.\n+      row = Arrays.copyOf(row, row.length + 1);\n+      locateType = RegionLocateType.CURRENT;\n+    }\n+    Scan scan =\n+      MetaTableAccessor.createLocateRegionScan(TableName.META_TABLE_NAME, row, locateType, 1);\n+    try (RegionScanner scanner = masterRegion.getScanner(scan)) {\n+      boolean moreRows;\n+      List<Cell> cells = new ArrayList<>();\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n+        }\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionLocations locs = MetaTableAccessor.getRegionLocations(result);\n+        if (locs == null || locs.getDefaultRegionLocation() == null) {\n+          LOG.warn(\"No location found when locating meta region with row='{}', locateType={}\",\n+            Bytes.toStringBinary(row), locateType);\n+          return null;\n+        }\n+        HRegionLocation loc = locs.getDefaultRegionLocation();\n+        RegionInfo info = loc.getRegion();\n+        if (info == null) {\n+          LOG.warn(\"HRegionInfo is null when locating meta region with row='{}', locateType={}\",\n+            Bytes.toStringBinary(row), locateType);\n+          return null;\n+        }\n+        if (info.isSplitParent()) {\n+          continue;\n+        }\n+        return locs;\n+      } while (moreRows);\n+      LOG.warn(\"No location available when locating meta region with row='{}', locateType={}\",\n+        Bytes.toStringBinary(row), locateType);\n+      return null;\n+    }\n+  }\n+\n+  public List<RegionLocations> getAllMetaRegionLocations(boolean excludeOfflinedSplitParents)\n+    throws IOException {\n+    Scan scan = new Scan().addFamily(HConstants.CATALOG_FAMILY);\n+    List<RegionLocations> list = new ArrayList<>();\n+    try (RegionScanner scanner = masterRegion.getScanner(scan)) {\n+      boolean moreRows;\n+      List<Cell> cells = new ArrayList<>();\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n+        }\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionLocations locs = MetaTableAccessor.getRegionLocations(result);\n+        if (locs == null) {\n+          LOG.warn(\"No locations in {}\", result);\n+          continue;\n+        }\n+        HRegionLocation loc = locs.getRegionLocation();\n+        if (loc == null) {\n+          LOG.warn(\"No non null location in {}\", result);\n+          continue;\n+        }\n+        RegionInfo info = loc.getRegion();\n+        if (info == null) {\n+          LOG.warn(\"No serialized RegionInfo in {}\", result);\n+          continue;\n+        }\n+        if (excludeOfflinedSplitParents && info.isSplitParent()) {\n+          continue;\n+        }\n+        list.add(locs);\n+      } while (moreRows);\n+    }\n+    return list;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTQxMw=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0ODY5MQ==", "bodyText": "The api does not allow 'paging' through the hbase:master table Regions. Even if we prefetch the API is awkward for getting next Region.\nIf a paging API, we'd only need one method?\nI think current situation where we only get one Region because there is only one makes this API seem ok.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437048691", "createdAt": "2020-06-08T23:05:42Z", "author": {"login": "saintstack"}, "path": "hbase-protocol-shaded/src/main/protobuf/server/master/Master.proto", "diffHunk": "@@ -1284,4 +1307,16 @@ service ClientMetaService {\n    * Get current meta replicas' region locations.\n    */\n   rpc GetMetaRegionLocations(GetMetaRegionLocationsRequest) returns(GetMetaRegionLocationsResponse);\n+\n+  /**\n+   * Get meta region locations for a given row\n+   */\n+  rpc LocateMetaRegion(LocateMetaRegionRequest)\n+    returns(LocateMetaRegionResponse);\n+\n+  /**\n+   * Get all meta regions locations\n+   */\n+  rpc GetAllMetaRegionLocations(GetAllMetaRegionLocationsRequest)\n+    returns(GetAllMetaRegionLocationsResponse);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0Mzg5MQ=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2Njg1OTgx", "url": "https://github.com/apache/hbase/pull/1774#pullrequestreview-426685981", "createdAt": "2020-06-08T23:20:35Z", "commit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMzoyMDozNVrOGgzm1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMzoyMjo0MVrOGgzpSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1MzE0MQ==", "bodyText": "Could you transport this as a Scan? Convert the 'simple API' into a Scan behind the scenes so we don't have to do stuff like this?\n(I hear you on not wanting to support full Scan and have some sympathy but I am kicking against a simple API that seems arbitrary and unsatisfactory -- hence the questions. Pardon if annoying... also trying to figure what is going on in here... Takes me a while. I'm slow. Thanks).", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437053141", "createdAt": "2020-06-08T23:20:35Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/shaded/protobuf/ProtobufUtil.java", "diffHunk": "@@ -3537,4 +3538,30 @@ public static RSGroupInfo toGroupInfo(RSGroupProtos.RSGroupInfo proto) {\n     return RSGroupProtos.RSGroupInfo.newBuilder().setName(pojo.getName()).addAllServers(hostports)\n         .addAllTables(tables).build();\n   }\n+\n+  public static MasterProtos.RegionLocateType toProtoRegionLocateType(RegionLocateType pojo) {\n+    switch (pojo) {\n+      case BEFORE:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_BEFORE;\n+      case CURRENT:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_CURRENT;\n+      case AFTER:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_AFTER;\n+      default:\n+        throw new IllegalArgumentException(\"Unknown RegionLocateType: \" + pojo);\n+    }\n+  }\n+\n+  public static RegionLocateType toRegionLocateType(MasterProtos.RegionLocateType proto) {\n+    switch (proto) {\n+      case REGION_LOCATE_TYPE_BEFORE:\n+        return RegionLocateType.BEFORE;\n+      case REGION_LOCATE_TYPE_CURRENT:\n+        return RegionLocateType.CURRENT;\n+      case REGION_LOCATE_TYPE_AFTER:\n+        return RegionLocateType.AFTER;\n+      default:\n+        throw new IllegalArgumentException(\"Unknown proto RegionLocateType: \" + proto);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MzIwMg=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1Mzc3MA==", "bodyText": "Looks good.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437053770", "createdAt": "2020-06-08T23:22:41Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/RawAsyncHBaseAdmin.java", "diffHunk": "@@ -1105,23 +1097,7 @@ public void run(PRESP resp) {\n    * List all region locations for the specific table.\n    */\n   private CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(TableName tableName) {\n-    if (TableName.META_TABLE_NAME.equals(tableName)) {\n-      CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-      addListener(connection.registry.getMetaRegionLocations(), (metaRegions, err) -> {\n-        if (err != null) {\n-          future.completeExceptionally(err);\n-        } else if (metaRegions == null || metaRegions.isEmpty() ||\n-          metaRegions.getDefaultRegionLocation() == null) {\n-          future.completeExceptionally(new IOException(\"meta region does not found\"));\n-        } else {\n-          future.complete(Collections.singletonList(metaRegions.getDefaultRegionLocation()));\n-        }\n-      });\n-      return future;\n-    } else {\n-      // For non-meta table, we fetch all locations by scanning hbase:meta table\n-      return AsyncMetaTableAccessor.getTableHRegionLocations(metaTable, tableName);\n-    }\n+    return connection.getRegionLocator(tableName).getAllRegionLocations();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjI0MA=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 60}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/5ca2a98bc940cc1ccf8256c4fddce973fddea61b", "committedDate": "2020-06-08T02:50:42Z", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region"}, "afterCommit": {"oid": "1ed7861b942ee6d2ae8e56ad623ddb6ead048fee", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/1ed7861b942ee6d2ae8e56ad623ddb6ead048fee", "committedDate": "2020-06-09T03:02:35Z", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1ed7861b942ee6d2ae8e56ad623ddb6ead048fee", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/1ed7861b942ee6d2ae8e56ad623ddb6ead048fee", "committedDate": "2020-06-09T03:02:35Z", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region"}, "afterCommit": {"oid": "6a1e44c42318493cf1b013e2ef32e1a2f53e39b8", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/6a1e44c42318493cf1b013e2ef32e1a2f53e39b8", "committedDate": "2020-06-21T10:14:09Z", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6a1e44c42318493cf1b013e2ef32e1a2f53e39b8", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/6a1e44c42318493cf1b013e2ef32e1a2f53e39b8", "committedDate": "2020-06-21T10:14:09Z", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region"}, "afterCommit": {"oid": "7dfeb080a27e918c0a96b9083e0ca1d61b17cf48", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/7dfeb080a27e918c0a96b9083e0ca1d61b17cf48", "committedDate": "2020-06-24T15:08:03Z", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7dfeb080a27e918c0a96b9083e0ca1d61b17cf48", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/7dfeb080a27e918c0a96b9083e0ca1d61b17cf48", "committedDate": "2020-06-24T15:08:03Z", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region"}, "afterCommit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/ce6490ed9612cdc2e424d4a4c0827fc806d40b5e", "committedDate": "2020-06-25T15:27:10Z", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NjM0MjE4", "url": "https://github.com/apache/hbase/pull/1774#pullrequestreview-438634218", "createdAt": "2020-06-26T22:47:19Z", "commit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMjo0NzoxOVrOGpwpSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMzoxODoyM1rOGpxEfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0MTgwMA==", "bodyText": "nit... should be LocateRegionType to match the method names in here.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446441800", "createdAt": "2020-06-26T22:47:19Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/CatalogFamilyFormat.java", "diffHunk": "@@ -363,4 +370,27 @@ public static Delete removeRegionReplica(byte[] metaRow, int replicaIndexToDelet\n     }\n     return deleteReplicaLocations;\n   }\n+\n+  private static byte[] buildLocateRegionStartRow(TableName tableName, byte[] row,\n+    RegionLocateType locateType) {\n+    if (locateType.equals(RegionLocateType.BEFORE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0MzU0Mw==", "bodyText": "Trying to understand why we need to support this flag excludeOfflinedSplitParents\nSnapshots need it? Are we trying to support snapshotting hbase:meta table?\nI was going to suggest we not do this but thinking on it, it is probably a useful utility to have.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446443543", "createdAt": "2020-06-26T22:54:36Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ClientMetaTableAccessor.java", "diffHunk": "@@ -164,26 +164,27 @@ private ClientMetaTableAccessor() {\n \n   /**\n    * Used to get all region locations for the specific table.\n-   * @param metaTable\n    * @param tableName table we're looking for, can be null for getting all regions\n    * @return the list of region locations. The return value will be wrapped by a\n    *         {@link CompletableFuture}.\n    */\n   public static CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(\n-    AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName) {\n+    AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName,\n+    boolean excludeOfflinedSplitParents) {\n     CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-    addListener(getTableRegionsAndLocations(metaTable, tableName, true), (locations, err) -> {\n-      if (err != null) {\n-        future.completeExceptionally(err);\n-      } else if (locations == null || locations.isEmpty()) {\n-        future.complete(Collections.emptyList());\n-      } else {\n-        List<HRegionLocation> regionLocations =\n-          locations.stream().map(loc -> new HRegionLocation(loc.getFirst(), loc.getSecond()))\n-            .collect(Collectors.toList());\n-        future.complete(regionLocations);\n-      }\n-    });\n+    addListener(getTableRegionsAndLocations(metaTable, tableName, excludeOfflinedSplitParents),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NDY3MQ==", "bodyText": "Why TableRegion rather than Region? The 'Table' is redundant and makes this class name a mouthful?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446444671", "createdAt": "2020-06-26T22:59:30Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.HConstants.EMPTY_END_ROW;\n+import static org.apache.hadoop.hbase.client.AsyncRegionLocatorHelper.isGood;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.hadoop.hbase.HBaseIOException;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * The base class for locating region of a table.\n+ */\n+@InterfaceAudience.Private\n+abstract class AbstractAsyncTableRegionLocator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NjI3Mw==", "bodyText": "I see you are doing this....\ndelete mode 100644 hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaRegionLocator.java\ncreate mode 100644 hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaTableRegionLocator.java\n.... you want to create new classes rather than just replace the old and the TableRegion is how you distingush the new set?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446446273", "createdAt": "2020-06-26T23:07:04Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.HConstants.EMPTY_END_ROW;\n+import static org.apache.hadoop.hbase.client.AsyncRegionLocatorHelper.isGood;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.hadoop.hbase.HBaseIOException;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * The base class for locating region of a table.\n+ */\n+@InterfaceAudience.Private\n+abstract class AbstractAsyncTableRegionLocator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NDY3MQ=="}, "originalCommit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NjYyMA==", "bodyText": "Let me resolve. I see that this is just a move of code. My fault for not knowing this code well enough and realizing it not new.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446446620", "createdAt": "2020-06-26T23:08:32Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.HConstants.EMPTY_END_ROW;\n+import static org.apache.hadoop.hbase.client.AsyncRegionLocatorHelper.isGood;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.hadoop.hbase.HBaseIOException;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * The base class for locating region of a table.\n+ */\n+@InterfaceAudience.Private\n+abstract class AbstractAsyncTableRegionLocator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(AbstractAsyncTableRegionLocator.class);\n+\n+  protected final AsyncConnectionImpl conn;\n+\n+  protected final TableName tableName;\n+\n+  protected final int maxConcurrent;\n+\n+  protected final TableRegionLocationCache cache;\n+\n+  protected static final class LocateRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NTE5Mg=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0ODc2Ng==", "bodyText": "Can't return an Interface rather than Abstract class?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446448766", "createdAt": "2020-06-26T23:18:23Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRegionLocator.java", "diffHunk": "@@ -85,26 +118,41 @@ private boolean isMeta(TableName tableName) {\n     return TableName.isMetaTableName(tableName);\n   }\n \n+  private AbstractAsyncTableRegionLocator getOrCreateTableRegionLocator(TableName tableName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3da81b243c404194dab6dda8ef71be1144733067", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/3da81b243c404194dab6dda8ef71be1144733067", "committedDate": "2020-06-27T04:06:21Z", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/ce6490ed9612cdc2e424d4a4c0827fc806d40b5e", "committedDate": "2020-06-25T15:27:10Z", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region"}, "afterCommit": {"oid": "3da81b243c404194dab6dda8ef71be1144733067", "author": {"user": {"login": "Apache9", "name": "Duo Zhang"}}, "url": "https://github.com/apache/hbase/commit/3da81b243c404194dab6dda8ef71be1144733067", "committedDate": "2020-06-27T04:06:21Z", "message": "HBASE-24389 Introduce new master rpc methods to locate meta region through root region"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4739, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}