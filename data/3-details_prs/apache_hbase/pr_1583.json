{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4NzI5MzE1", "number": 1583, "title": "HBASE-24260 Add a ClusterManager that issues commands via coprocessor", "bodyText": "Implements ClusterManager that relies on the new ShellExecCoproc\nfor remote shell command execution.", "createdAt": "2020-04-24T19:35:46Z", "url": "https://github.com/apache/hbase/pull/1583", "merged": true, "mergeCommit": {"oid": "fa1890c880efc2226bf66f443090f4f9ae23fb1d"}, "closed": true, "closedAt": "2020-05-04T17:50:43Z", "author": {"login": "ndimiduk"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABca5cq2gFqTQwMDI5MjcxOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABceC5dhgBqjMzMDA5MjA0Njk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMjkyNzE4", "url": "https://github.com/apache/hbase/pull/1583#pullrequestreview-400292718", "createdAt": "2020-04-24T21:53:07Z", "commit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMTo1MzowOFrOGLqjJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQyMjo0MTozNlrOGLroIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg4NDY0NQ==", "bodyText": "port to master as a follow up?", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414884645", "createdAt": "2020-04-24T21:53:08Z", "author": {"login": "bharathv"}, "path": "hbase-endpoint/src/main/protobuf/ShellExecEndpoint.proto", "diffHunk": "@@ -0,0 +1,42 @@\n+/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5NDc5NA==", "bodyText": "nit: Move this to the top, make it a preconditions check?", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414894794", "createdAt": "2020-04-24T22:20:02Z", "author": {"login": "bharathv"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/CoprocClusterManager.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.client.ConnectionFactory;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Overrides commands to make use of Coproc where possible.\n+ */\n+@InterfaceAudience.Private\n+public class CoprocClusterManager extends HBaseClusterManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(CoprocClusterManager.class);\n+\n+  @Override\n+  protected Pair<Integer, String> exec(String hostname, ServiceType service, String... cmd)\n+    throws IOException {\n+    // we don't have ssh to log in as the service user, so wrap the command in sudo.\n+    // assumes user running the hbase process has sudo privileges to target service.\n+    final String serviceUser = getServiceUser(service);\n+    final String[] commandPrefix =\n+      !Objects.equals(serviceUser, getServiceUser(ServiceType.HBASE_MASTER))\n+        ? new String[] { \"sudo\", \"-u\", serviceUser }\n+        : new String[0];\n+    final String command = StringUtils.join(ArrayUtils.addAll(commandPrefix, cmd), \" \");\n+    LOG.info(\"Executing remote command: {}, hostname:{}\", command, hostname);\n+\n+    try (final AsyncConnection conn = ConnectionFactory.createAsyncConnection(getConf()).join()) {\n+      final AsyncAdmin admin = conn.getAdmin();\n+      final ShellExecRequest req = ShellExecRequest.newBuilder()\n+        .setCommand(command)\n+        .build();\n+\n+      final ShellExecResponse resp;\n+      switch(service) {\n+        case HBASE_MASTER:\n+          // TODO: what happens if the intended action was killing a backup master?\n+          resp = masterExec(admin, req);\n+          break;\n+        case HBASE_REGIONSERVER:\n+          final ServerName targetHost = resolveRegionServerName(admin, hostname);\n+          resp = regionServerExec(admin, req, targetHost);\n+          break;\n+        default:\n+          throw unsupportedServiceType(service);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5NjI5MA==", "bodyText": "Is this possible given the check in L72?", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414896290", "createdAt": "2020-04-24T22:24:09Z", "author": {"login": "bharathv"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/CoprocClusterManager.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.client.ConnectionFactory;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Overrides commands to make use of Coproc where possible.\n+ */\n+@InterfaceAudience.Private\n+public class CoprocClusterManager extends HBaseClusterManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(CoprocClusterManager.class);\n+\n+  @Override\n+  protected Pair<Integer, String> exec(String hostname, ServiceType service, String... cmd)\n+    throws IOException {\n+    // we don't have ssh to log in as the service user, so wrap the command in sudo.\n+    // assumes user running the hbase process has sudo privileges to target service.\n+    final String serviceUser = getServiceUser(service);\n+    final String[] commandPrefix =\n+      !Objects.equals(serviceUser, getServiceUser(ServiceType.HBASE_MASTER))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5Nzc1OA==", "bodyText": "nit: odd indentation", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414897758", "createdAt": "2020-04-24T22:28:09Z", "author": {"login": "bharathv"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5ODk2MQ==", "bodyText": "Don't fully understand this, is there a race?", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414898961", "createdAt": "2020-04-24T22:31:34Z", "author": {"login": "bharathv"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);\n+    final long sleepDuration = conf.getLong(ASYNC_DELAY_KEY, DEFAULT_ASYNC_DELAY);\n+    workerPool.submit(() -> {\n+      try {\n+        // sleep first so that the RPC can ACK.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5OTA3NA==", "bodyText": "LOG.error?", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414899074", "createdAt": "2020-04-24T22:31:51Z", "author": {"login": "bharathv"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);\n+    final long sleepDuration = conf.getLong(ASYNC_DELAY_KEY, DEFAULT_ASYNC_DELAY);\n+    workerPool.submit(() -> {\n+      try {\n+        // sleep first so that the RPC can ACK.\n+        Thread.sleep(sleepDuration);\n+        doExec(shell, ShellExecResponse.newBuilder());\n+      } catch (InterruptedException e) {\n+        LOG.info(\"Interrupted before launching process.\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5OTEyOQ==", "bodyText": "LOG.error?", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414899129", "createdAt": "2020-04-24T22:32:02Z", "author": {"login": "bharathv"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);\n+    final long sleepDuration = conf.getLong(ASYNC_DELAY_KEY, DEFAULT_ASYNC_DELAY);\n+    workerPool.submit(() -> {\n+      try {\n+        // sleep first so that the RPC can ACK.\n+        Thread.sleep(sleepDuration);\n+        doExec(shell, ShellExecResponse.newBuilder());\n+      } catch (InterruptedException e) {\n+        LOG.info(\"Interrupted before launching process.\", e);\n+      } catch (IOException e) {\n+        LOG.info(\"Failure launching process\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5OTk5Mw==", "bodyText": "This doesn't look right to me, shouldn't this be predicated on whether the thread above is successful? (You probably need to chain them?.. thenApply()...)", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414899993", "createdAt": "2020-04-24T22:34:31Z", "author": {"login": "bharathv"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);\n+    final long sleepDuration = conf.getLong(ASYNC_DELAY_KEY, DEFAULT_ASYNC_DELAY);\n+    workerPool.submit(() -> {\n+      try {\n+        // sleep first so that the RPC can ACK.\n+        Thread.sleep(sleepDuration);\n+        doExec(shell, ShellExecResponse.newBuilder());\n+      } catch (InterruptedException e) {\n+        LOG.info(\"Interrupted before launching process.\", e);\n+      } catch (IOException e) {\n+        LOG.info(\"Failure launching process\", e);\n+      }\n+    });\n+    done.run(ShellExecResponse.newBuilder().build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMDYzMg==", "bodyText": "nit: I think in a true async mode, this should be async too :-)", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414900632", "createdAt": "2020-04-24T22:36:24Z", "author": {"login": "bharathv"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMDk4MQ==", "bodyText": "LOG.err()", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414900981", "createdAt": "2020-04-24T22:37:30Z", "author": {"login": "bharathv"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);\n+    final long sleepDuration = conf.getLong(ASYNC_DELAY_KEY, DEFAULT_ASYNC_DELAY);\n+    workerPool.submit(() -> {\n+      try {\n+        // sleep first so that the RPC can ACK.\n+        Thread.sleep(sleepDuration);\n+        doExec(shell, ShellExecResponse.newBuilder());\n+      } catch (InterruptedException e) {\n+        LOG.info(\"Interrupted before launching process.\", e);\n+      } catch (IOException e) {\n+        LOG.info(\"Failure launching process\", e);\n+      }\n+    });\n+    done.run(ShellExecResponse.newBuilder().build());\n+  }\n+\n+  private Shell.ShellCommandExecutor prepareShell(\n+    final ShellExecRequest request,\n+    final boolean async\n+  ) {\n+    final String command = request.getCommand();\n+    if (StringUtils.isBlank(command)) {\n+      throw new RuntimeException(\"Request contained an empty command.\");\n+    }\n+    final String msgFmt = \"Executing command\"\n+      + (async ? \" on a background thread\" : \"\") + \": {}\";\n+    LOG.info(msgFmt, command);\n+    final String[] subShellCmd = new String[] { \"/usr/bin/env\", \"bash\", \"-c\", command };\n+    return new Shell.ShellCommandExecutor(subShellCmd);\n+  }\n+\n+  private ShellExecResponse.Builder doExec(\n+    final Shell.ShellCommandExecutor shell,\n+    final ShellExecResponse.Builder builder\n+  ) throws IOException {\n+    try {\n+      shell.execute();\n+      builder\n+        .setExitCode(shell.getExitCode())\n+        .setStdout(shell.getOutput());\n+    } catch (Shell.ExitCodeException e) {\n+      LOG.info(\"Launched process failed\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMjMwNQ==", "bodyText": "How about reading back using a coprocessorCommand too? that checks the stdout codepaths (cat foo)", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414902305", "createdAt": "2020-04-24T22:41:36Z", "author": {"login": "bharathv"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/TestShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+/**\n+ * Test for the {@link ShellExecCoproc}.\n+ */\n+@Category(MediumTests.class)\n+public class TestShellExecCoproc {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule testRule =\n+    HBaseClassTestRule.forClass(TestShellExecCoproc.class);\n+\n+  @ClassRule\n+  public static final MiniClusterRule miniClusterRule = MiniClusterRule.newBuilder()\n+    .setConfiguration(createConfiguration())\n+    .build();\n+\n+  @Rule\n+  public final ConnectionRule connectionRule =\n+    new ConnectionRule(miniClusterRule::createConnection);\n+\n+  @Test\n+  public void testShellExec() {\n+    final AsyncConnection conn = connectionRule.getConnection();\n+    final AsyncAdmin admin = conn.getAdmin();\n+\n+    final String command = \"echo -n \\\"hello world\\\"\";\n+    final ShellExecRequest req = ShellExecRequest.newBuilder()\n+      .setCommand(command)\n+      .build();\n+    final ShellExecResponse resp = admin\n+      .<ShellExecService.Stub, ShellExecResponse>coprocessorService(\n+        ShellExecService::newStub,\n+        (stub, controller, callback) -> stub.shellExec(controller, req, callback))\n+      .join();\n+    assertEquals(0, resp.getExitCode());\n+    assertEquals(\"hello world\", resp.getStdout());\n+  }\n+\n+  @Test\n+  public void testShellExecAsync() throws IOException {\n+    final AsyncConnection conn = connectionRule.getConnection();\n+    final AsyncAdmin admin = conn.getAdmin();\n+\n+    final File testDataDir = ensureTestDataDirExists(miniClusterRule.getTestingUtility());\n+    final File testFile = new File(testDataDir, \"shell_exec_async.txt\");\n+    assertTrue(testFile.createNewFile());\n+    assertEquals(0, testFile.length());\n+\n+    final String command = \"echo \\\"hello world\\\" >> \" + testFile.getAbsolutePath();\n+    final ShellExecRequest req = ShellExecRequest.newBuilder()\n+      .setCommand(command)\n+      .build();\n+    admin.<ShellExecService.Stub, ShellExecResponse>coprocessorService(\n+      ShellExecService::newStub,\n+      (stub, controller, callback) -> stub.shellExecAsync(controller, req, callback))\n+      .join();\n+\n+    Waiter.waitFor(conn.getConfiguration(), 5_000, () -> testFile.length() > 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMzUzNjkz", "url": "https://github.com/apache/hbase/pull/1583#pullrequestreview-400353693", "createdAt": "2020-04-25T03:52:39Z", "commit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwMzo1NjowNlrOGLvx4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNVQwNjoxMDoyM1rOGLxGsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk3MDMzOQ==", "bodyText": "Do we need the command again? Otherwise the output and exit code may not be related to command easily.\nLOG.info(\"Executed remote command: '{}', exit code: {}, output: {}\", command, ...)", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414970339", "createdAt": "2020-04-25T03:56:06Z", "author": {"login": "liuml07"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/CoprocClusterManager.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.client.ConnectionFactory;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Overrides commands to make use of Coproc where possible.\n+ */\n+@InterfaceAudience.Private\n+public class CoprocClusterManager extends HBaseClusterManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(CoprocClusterManager.class);\n+\n+  @Override\n+  protected Pair<Integer, String> exec(String hostname, ServiceType service, String... cmd)\n+    throws IOException {\n+    // we don't have ssh to log in as the service user, so wrap the command in sudo.\n+    // assumes user running the hbase process has sudo privileges to target service.\n+    final String serviceUser = getServiceUser(service);\n+    final String[] commandPrefix =\n+      !Objects.equals(serviceUser, getServiceUser(ServiceType.HBASE_MASTER))\n+        ? new String[] { \"sudo\", \"-u\", serviceUser }\n+        : new String[0];\n+    final String command = StringUtils.join(ArrayUtils.addAll(commandPrefix, cmd), \" \");\n+    LOG.info(\"Executing remote command: {}, hostname:{}\", command, hostname);\n+\n+    try (final AsyncConnection conn = ConnectionFactory.createAsyncConnection(getConf()).join()) {\n+      final AsyncAdmin admin = conn.getAdmin();\n+      final ShellExecRequest req = ShellExecRequest.newBuilder()\n+        .setCommand(command)\n+        .build();\n+\n+      final ShellExecResponse resp;\n+      switch(service) {\n+        case HBASE_MASTER:\n+          // TODO: what happens if the intended action was killing a backup master?\n+          resp = masterExec(admin, req);\n+          break;\n+        case HBASE_REGIONSERVER:\n+          final ServerName targetHost = resolveRegionServerName(admin, hostname);\n+          resp = regionServerExec(admin, req, targetHost);\n+          break;\n+        default:\n+          throw unsupportedServiceType(service);\n+      }\n+\n+      LOG.info(\"Executed remote command, exit code:{} , output:{}\", resp.getExitCode(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk3Mjk3Ng==", "bodyText": "Replace hbase.it.shellexeccoproc.async.delay with hbase.it.shellexeccoproc.async.delay.ms so we know this is for milliseconds?", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414972976", "createdAt": "2020-04-25T04:12:37Z", "author": {"login": "liuml07"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5MTMyMw==", "bodyText": "By\n    final String content = Optional.of(testFile.toPath())\n      .map(val -> {\n        try {\n          return Files.readAllLines(val);\n        } catch (IOException e) {\n          return null;\n        }\n      })\n      .map(val -> StringUtils.join(val, \"\"))\n      .map(String::trim)\n      .orElseThrow(() -> new RuntimeException(\"Unable to parse file content\"));\n    assertEquals(\"hello world\", content);\n\nDo you mean:\n    final String content = new String(Files.readAllBytes(testFile.toPath()));\n    assertEquals(\"hello world\\n\", content);", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414991323", "createdAt": "2020-04-25T06:05:48Z", "author": {"login": "liuml07"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/TestShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+/**\n+ * Test for the {@link ShellExecCoproc}.\n+ */\n+@Category(MediumTests.class)\n+public class TestShellExecCoproc {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule testRule =\n+    HBaseClassTestRule.forClass(TestShellExecCoproc.class);\n+\n+  @ClassRule\n+  public static final MiniClusterRule miniClusterRule = MiniClusterRule.newBuilder()\n+    .setConfiguration(createConfiguration())\n+    .build();\n+\n+  @Rule\n+  public final ConnectionRule connectionRule =\n+    new ConnectionRule(miniClusterRule::createConnection);\n+\n+  @Test\n+  public void testShellExec() {\n+    final AsyncConnection conn = connectionRule.getConnection();\n+    final AsyncAdmin admin = conn.getAdmin();\n+\n+    final String command = \"echo -n \\\"hello world\\\"\";\n+    final ShellExecRequest req = ShellExecRequest.newBuilder()\n+      .setCommand(command)\n+      .build();\n+    final ShellExecResponse resp = admin\n+      .<ShellExecService.Stub, ShellExecResponse>coprocessorService(\n+        ShellExecService::newStub,\n+        (stub, controller, callback) -> stub.shellExec(controller, req, callback))\n+      .join();\n+    assertEquals(0, resp.getExitCode());\n+    assertEquals(\"hello world\", resp.getStdout());\n+  }\n+\n+  @Test\n+  public void testShellExecAsync() throws IOException {\n+    final AsyncConnection conn = connectionRule.getConnection();\n+    final AsyncAdmin admin = conn.getAdmin();\n+\n+    final File testDataDir = ensureTestDataDirExists(miniClusterRule.getTestingUtility());\n+    final File testFile = new File(testDataDir, \"shell_exec_async.txt\");\n+    assertTrue(testFile.createNewFile());\n+    assertEquals(0, testFile.length());\n+\n+    final String command = \"echo \\\"hello world\\\" >> \" + testFile.getAbsolutePath();\n+    final ShellExecRequest req = ShellExecRequest.newBuilder()\n+      .setCommand(command)\n+      .build();\n+    admin.<ShellExecService.Stub, ShellExecResponse>coprocessorService(\n+      ShellExecService::newStub,\n+      (stub, controller, callback) -> stub.shellExecAsync(controller, req, callback))\n+      .join();\n+\n+    Waiter.waitFor(conn.getConfiguration(), 5_000, () -> testFile.length() > 0);\n+    final String content = Optional.of(testFile.toPath())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5MTU2Mg==", "bodyText": "This seems a good idea. Just concerned both testFile and cat can be empty, so...", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414991562", "createdAt": "2020-04-25T06:07:06Z", "author": {"login": "liuml07"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/TestShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+/**\n+ * Test for the {@link ShellExecCoproc}.\n+ */\n+@Category(MediumTests.class)\n+public class TestShellExecCoproc {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule testRule =\n+    HBaseClassTestRule.forClass(TestShellExecCoproc.class);\n+\n+  @ClassRule\n+  public static final MiniClusterRule miniClusterRule = MiniClusterRule.newBuilder()\n+    .setConfiguration(createConfiguration())\n+    .build();\n+\n+  @Rule\n+  public final ConnectionRule connectionRule =\n+    new ConnectionRule(miniClusterRule::createConnection);\n+\n+  @Test\n+  public void testShellExec() {\n+    final AsyncConnection conn = connectionRule.getConnection();\n+    final AsyncAdmin admin = conn.getAdmin();\n+\n+    final String command = \"echo -n \\\"hello world\\\"\";\n+    final ShellExecRequest req = ShellExecRequest.newBuilder()\n+      .setCommand(command)\n+      .build();\n+    final ShellExecResponse resp = admin\n+      .<ShellExecService.Stub, ShellExecResponse>coprocessorService(\n+        ShellExecService::newStub,\n+        (stub, controller, callback) -> stub.shellExec(controller, req, callback))\n+      .join();\n+    assertEquals(0, resp.getExitCode());\n+    assertEquals(\"hello world\", resp.getStdout());\n+  }\n+\n+  @Test\n+  public void testShellExecAsync() throws IOException {\n+    final AsyncConnection conn = connectionRule.getConnection();\n+    final AsyncAdmin admin = conn.getAdmin();\n+\n+    final File testDataDir = ensureTestDataDirExists(miniClusterRule.getTestingUtility());\n+    final File testFile = new File(testDataDir, \"shell_exec_async.txt\");\n+    assertTrue(testFile.createNewFile());\n+    assertEquals(0, testFile.length());\n+\n+    final String command = \"echo \\\"hello world\\\" >> \" + testFile.getAbsolutePath();\n+    final ShellExecRequest req = ShellExecRequest.newBuilder()\n+      .setCommand(command)\n+      .build();\n+    admin.<ShellExecService.Stub, ShellExecResponse>coprocessorService(\n+      ShellExecService::newStub,\n+      (stub, controller, callback) -> stub.shellExecAsync(controller, req, callback))\n+      .join();\n+\n+    Waiter.waitFor(conn.getConfiguration(), 5_000, () -> testFile.length() > 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMjMwNQ=="}, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5MTk3Mw==", "bodyText": "It's possible because HBASE_REGIONSERVER results in new String[0]?", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414991973", "createdAt": "2020-04-25T06:09:47Z", "author": {"login": "liuml07"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/CoprocClusterManager.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.client.ConnectionFactory;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Overrides commands to make use of Coproc where possible.\n+ */\n+@InterfaceAudience.Private\n+public class CoprocClusterManager extends HBaseClusterManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(CoprocClusterManager.class);\n+\n+  @Override\n+  protected Pair<Integer, String> exec(String hostname, ServiceType service, String... cmd)\n+    throws IOException {\n+    // we don't have ssh to log in as the service user, so wrap the command in sudo.\n+    // assumes user running the hbase process has sudo privileges to target service.\n+    final String serviceUser = getServiceUser(service);\n+    final String[] commandPrefix =\n+      !Objects.equals(serviceUser, getServiceUser(ServiceType.HBASE_MASTER))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5NjI5MA=="}, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5MjA0OQ==", "bodyText": "nit: replace /** with /*", "url": "https://github.com/apache/hbase/pull/1583#discussion_r414992049", "createdAt": "2020-04-25T06:10:23Z", "author": {"login": "liuml07"}, "path": "hbase-endpoint/src/main/protobuf/ShellExecEndpoint.proto", "diffHunk": "@@ -0,0 +1,42 @@\n+/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMTQ0NjU1", "url": "https://github.com/apache/hbase/pull/1583#pullrequestreview-401144655", "createdAt": "2020-04-27T16:56:00Z", "commit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNjo1NjowMFrOGMtoiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yN1QxNzoxMTozOVrOGMuUvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4Mzc1Mw==", "bodyText": "Yes. I initially coded this up on master, but porting it to branch-2.3 I discovered this hbase-endpoint module is different (doesn't exist), so I continued development here.", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415983753", "createdAt": "2020-04-27T16:56:00Z", "author": {"login": "ndimiduk"}, "path": "hbase-endpoint/src/main/protobuf/ShellExecEndpoint.proto", "diffHunk": "@@ -0,0 +1,42 @@\n+/**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg4NDY0NQ=="}, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4Mzk2OQ==", "bodyText": "nod", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415983969", "createdAt": "2020-04-27T16:56:15Z", "author": {"login": "ndimiduk"}, "path": "hbase-endpoint/src/main/protobuf/ShellExecEndpoint.proto", "diffHunk": "@@ -0,0 +1,42 @@\n+/**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5MjA0OQ=="}, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4NjQ3NQ==", "bodyText": "Is this possible given the check in L72?\n\nSeems it's possible someone is running master and region server as different users but in the same group. Obviously not the default.", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415986475", "createdAt": "2020-04-27T16:59:21Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/CoprocClusterManager.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.client.ConnectionFactory;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Overrides commands to make use of Coproc where possible.\n+ */\n+@InterfaceAudience.Private\n+public class CoprocClusterManager extends HBaseClusterManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(CoprocClusterManager.class);\n+\n+  @Override\n+  protected Pair<Integer, String> exec(String hostname, ServiceType service, String... cmd)\n+    throws IOException {\n+    // we don't have ssh to log in as the service user, so wrap the command in sudo.\n+    // assumes user running the hbase process has sudo privileges to target service.\n+    final String serviceUser = getServiceUser(service);\n+    final String[] commandPrefix =\n+      !Objects.equals(serviceUser, getServiceUser(ServiceType.HBASE_MASTER))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5NjI5MA=="}, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4NjU5OA==", "bodyText": "Sure.", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415986598", "createdAt": "2020-04-27T16:59:31Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/CoprocClusterManager.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.client.ConnectionFactory;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Overrides commands to make use of Coproc where possible.\n+ */\n+@InterfaceAudience.Private\n+public class CoprocClusterManager extends HBaseClusterManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(CoprocClusterManager.class);\n+\n+  @Override\n+  protected Pair<Integer, String> exec(String hostname, ServiceType service, String... cmd)\n+    throws IOException {\n+    // we don't have ssh to log in as the service user, so wrap the command in sudo.\n+    // assumes user running the hbase process has sudo privileges to target service.\n+    final String serviceUser = getServiceUser(service);\n+    final String[] commandPrefix =\n+      !Objects.equals(serviceUser, getServiceUser(ServiceType.HBASE_MASTER))\n+        ? new String[] { \"sudo\", \"-u\", serviceUser }\n+        : new String[0];\n+    final String command = StringUtils.join(ArrayUtils.addAll(commandPrefix, cmd), \" \");\n+    LOG.info(\"Executing remote command: {}, hostname:{}\", command, hostname);\n+\n+    try (final AsyncConnection conn = ConnectionFactory.createAsyncConnection(getConf()).join()) {\n+      final AsyncAdmin admin = conn.getAdmin();\n+      final ShellExecRequest req = ShellExecRequest.newBuilder()\n+        .setCommand(command)\n+        .build();\n+\n+      final ShellExecResponse resp;\n+      switch(service) {\n+        case HBASE_MASTER:\n+          // TODO: what happens if the intended action was killing a backup master?\n+          resp = masterExec(admin, req);\n+          break;\n+        case HBASE_REGIONSERVER:\n+          final ServerName targetHost = resolveRegionServerName(admin, hostname);\n+          resp = regionServerExec(admin, req, targetHost);\n+          break;\n+        default:\n+          throw unsupportedServiceType(service);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5NDc5NA=="}, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4NzY0NA==", "bodyText": "Depends on if you log the thread name as well. Sure, it doesn't hurt. Although, since we call the async method, there's no response code or output available. Should just truncate the log message.", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415987644", "createdAt": "2020-04-27T17:00:59Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/CoprocClusterManager.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+import java.util.Objects;\n+import org.apache.commons.lang3.ArrayUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.client.ConnectionFactory;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Overrides commands to make use of Coproc where possible.\n+ */\n+@InterfaceAudience.Private\n+public class CoprocClusterManager extends HBaseClusterManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(CoprocClusterManager.class);\n+\n+  @Override\n+  protected Pair<Integer, String> exec(String hostname, ServiceType service, String... cmd)\n+    throws IOException {\n+    // we don't have ssh to log in as the service user, so wrap the command in sudo.\n+    // assumes user running the hbase process has sudo privileges to target service.\n+    final String serviceUser = getServiceUser(service);\n+    final String[] commandPrefix =\n+      !Objects.equals(serviceUser, getServiceUser(ServiceType.HBASE_MASTER))\n+        ? new String[] { \"sudo\", \"-u\", serviceUser }\n+        : new String[0];\n+    final String command = StringUtils.join(ArrayUtils.addAll(commandPrefix, cmd), \" \");\n+    LOG.info(\"Executing remote command: {}, hostname:{}\", command, hostname);\n+\n+    try (final AsyncConnection conn = ConnectionFactory.createAsyncConnection(getConf()).join()) {\n+      final AsyncAdmin admin = conn.getAdmin();\n+      final ShellExecRequest req = ShellExecRequest.newBuilder()\n+        .setCommand(command)\n+        .build();\n+\n+      final ShellExecResponse resp;\n+      switch(service) {\n+        case HBASE_MASTER:\n+          // TODO: what happens if the intended action was killing a backup master?\n+          resp = masterExec(admin, req);\n+          break;\n+        case HBASE_REGIONSERVER:\n+          final ServerName targetHost = resolveRegionServerName(admin, hostname);\n+          resp = regionServerExec(admin, req, targetHost);\n+          break;\n+        default:\n+          throw unsupportedServiceType(service);\n+      }\n+\n+      LOG.info(\"Executed remote command, exit code:{} , output:{}\", resp.getExitCode(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk3MDMzOQ=="}, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4OTI4MQ==", "bodyText": "I don't see it. You don't like the extra newlines?", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415989281", "createdAt": "2020-04-27T17:03:18Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5Nzc1OA=="}, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk4OTU5Mw==", "bodyText": "nod", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415989593", "createdAt": "2020-04-27T17:03:43Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk3Mjk3Ng=="}, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5MDM5Nw==", "bodyText": "The request is async in that the response is disconnected from the caller. It's more like a \"set-and-forget\" kind of method invocation. We submit the work to the background thread and there's no avenue for the caller to see the results.", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415990397", "createdAt": "2020-04-27T17:04:57Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMDYzMg=="}, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5MTc3OA==", "bodyText": "Yes. The primary use-case is for the process to call kill -9 on itself. If we hold up the RPC waiting for a response, it never comes because the process dies. Then the client retry mechanism sends the RPC again, this time to the new active master, until we run out of masters.\nOur client doesn't let us say \"this RPC is intended for this one host only.\" So we get the above behavior. By making the invocation a set-and-forget, with a delay on execution, I'm giving the RPC a change to ACK back to the client before the host terminates itself.", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415991778", "createdAt": "2020-04-27T17:06:50Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);\n+    final long sleepDuration = conf.getLong(ASYNC_DELAY_KEY, DEFAULT_ASYNC_DELAY);\n+    workerPool.submit(() -> {\n+      try {\n+        // sleep first so that the RPC can ACK.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5ODk2MQ=="}, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5MjE4NQ==", "bodyText": "I don't think interruption is an error. I buy warn though.", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415992185", "createdAt": "2020-04-27T17:07:28Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);\n+    final long sleepDuration = conf.getLong(ASYNC_DELAY_KEY, DEFAULT_ASYNC_DELAY);\n+    workerPool.submit(() -> {\n+      try {\n+        // sleep first so that the RPC can ACK.\n+        Thread.sleep(sleepDuration);\n+        doExec(shell, ShellExecResponse.newBuilder());\n+      } catch (InterruptedException e) {\n+        LOG.info(\"Interrupted before launching process.\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5OTA3NA=="}, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5MzEwMA==", "bodyText": "See my earlier comment. This isn't async in the CompletableFuture sense. It's a call without a response.", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415993100", "createdAt": "2020-04-27T17:08:52Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);\n+    final long sleepDuration = conf.getLong(ASYNC_DELAY_KEY, DEFAULT_ASYNC_DELAY);\n+    workerPool.submit(() -> {\n+      try {\n+        // sleep first so that the RPC can ACK.\n+        Thread.sleep(sleepDuration);\n+        doExec(shell, ShellExecResponse.newBuilder());\n+      } catch (InterruptedException e) {\n+        LOG.info(\"Interrupted before launching process.\", e);\n+      } catch (IOException e) {\n+        LOG.info(\"Failure launching process\", e);\n+      }\n+    });\n+    done.run(ShellExecResponse.newBuilder().build());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg5OTk5Mw=="}, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5MzMyNA==", "bodyText": "Yep.", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415993324", "createdAt": "2020-04-27T17:09:12Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/ShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import com.google.protobuf.RpcCallback;\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.Service;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.coprocessor.MasterCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionServerCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.ipc.CoprocessorRpcUtils;\n+import org.apache.hadoop.util.Shell;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+/**\n+ * Receives shell commands from the client and executes them blindly.\n+ */\n+@InterfaceAudience.Private\n+public class ShellExecCoproc\n+  extends ShellExecEndpoint.ShellExecService\n+  implements MasterCoprocessor, RegionServerCoprocessor {\n+  private static final Logger LOG = LoggerFactory.getLogger(ShellExecCoproc.class);\n+\n+  public static final String ASYNC_DELAY_KEY = \"hbase.it.shellexeccoproc.async.delay\";\n+  public static final long DEFAULT_ASYNC_DELAY = 1_000;\n+\n+  private final ExecutorService workerPool;\n+  private Configuration conf;\n+\n+  public ShellExecCoproc() {\n+    workerPool = Executors.newSingleThreadExecutor(\n+      new ThreadFactoryBuilder()\n+        .setNameFormat(ShellExecCoproc.class.getSimpleName() + \"-{}\")\n+        .setDaemon(true)\n+        .setUncaughtExceptionHandler((t, e) -> LOG.warn(\"Thread {} threw\", t, e))\n+        .build());\n+  }\n+\n+  @Override\n+  public Iterable<Service> getServices() {\n+    return Collections.singletonList(this);\n+  }\n+\n+  @Override\n+  public void start(CoprocessorEnvironment env) {\n+    conf = env.getConfiguration();\n+  }\n+\n+  @Override\n+  public void shellExec(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, false);\n+\n+    ShellExecResponse.Builder builder = ShellExecResponse.newBuilder();\n+    try {\n+      builder = doExec(shell, builder);\n+    } catch (IOException e) {\n+      LOG.info(\"Failure launching process\", e);\n+      CoprocessorRpcUtils.setControllerException(controller, e);\n+    }\n+\n+    done.run(builder.build());\n+  }\n+\n+  @Override\n+  public void shellExecAsync(\n+    final RpcController controller,\n+    final ShellExecRequest request,\n+    final RpcCallback<ShellExecResponse> done\n+  ) {\n+    final Shell.ShellCommandExecutor shell = prepareShell(request, true);\n+    final long sleepDuration = conf.getLong(ASYNC_DELAY_KEY, DEFAULT_ASYNC_DELAY);\n+    workerPool.submit(() -> {\n+      try {\n+        // sleep first so that the RPC can ACK.\n+        Thread.sleep(sleepDuration);\n+        doExec(shell, ShellExecResponse.newBuilder());\n+      } catch (InterruptedException e) {\n+        LOG.info(\"Interrupted before launching process.\", e);\n+      } catch (IOException e) {\n+        LOG.info(\"Failure launching process\", e);\n+      }\n+    });\n+    done.run(ShellExecResponse.newBuilder().build());\n+  }\n+\n+  private Shell.ShellCommandExecutor prepareShell(\n+    final ShellExecRequest request,\n+    final boolean async\n+  ) {\n+    final String command = request.getCommand();\n+    if (StringUtils.isBlank(command)) {\n+      throw new RuntimeException(\"Request contained an empty command.\");\n+    }\n+    final String msgFmt = \"Executing command\"\n+      + (async ? \" on a background thread\" : \"\") + \": {}\";\n+    LOG.info(msgFmt, command);\n+    final String[] subShellCmd = new String[] { \"/usr/bin/env\", \"bash\", \"-c\", command };\n+    return new Shell.ShellCommandExecutor(subShellCmd);\n+  }\n+\n+  private ShellExecResponse.Builder doExec(\n+    final Shell.ShellCommandExecutor shell,\n+    final ShellExecResponse.Builder builder\n+  ) throws IOException {\n+    try {\n+      shell.execute();\n+      builder\n+        .setExitCode(shell.getExitCode())\n+        .setStdout(shell.getOutput());\n+    } catch (Shell.ExitCodeException e) {\n+      LOG.info(\"Launched process failed\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMDk4MQ=="}, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5NDU2NA==", "bodyText": "How about reading back using a coprocessorCommand too? that checks the stdout codepaths (cat foo)\n\nThat would be testing the non-\"async\" method, which is out of scope of this test.", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415994564", "createdAt": "2020-04-27T17:11:02Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/TestShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+/**\n+ * Test for the {@link ShellExecCoproc}.\n+ */\n+@Category(MediumTests.class)\n+public class TestShellExecCoproc {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule testRule =\n+    HBaseClassTestRule.forClass(TestShellExecCoproc.class);\n+\n+  @ClassRule\n+  public static final MiniClusterRule miniClusterRule = MiniClusterRule.newBuilder()\n+    .setConfiguration(createConfiguration())\n+    .build();\n+\n+  @Rule\n+  public final ConnectionRule connectionRule =\n+    new ConnectionRule(miniClusterRule::createConnection);\n+\n+  @Test\n+  public void testShellExec() {\n+    final AsyncConnection conn = connectionRule.getConnection();\n+    final AsyncAdmin admin = conn.getAdmin();\n+\n+    final String command = \"echo -n \\\"hello world\\\"\";\n+    final ShellExecRequest req = ShellExecRequest.newBuilder()\n+      .setCommand(command)\n+      .build();\n+    final ShellExecResponse resp = admin\n+      .<ShellExecService.Stub, ShellExecResponse>coprocessorService(\n+        ShellExecService::newStub,\n+        (stub, controller, callback) -> stub.shellExec(controller, req, callback))\n+      .join();\n+    assertEquals(0, resp.getExitCode());\n+    assertEquals(\"hello world\", resp.getStdout());\n+  }\n+\n+  @Test\n+  public void testShellExecAsync() throws IOException {\n+    final AsyncConnection conn = connectionRule.getConnection();\n+    final AsyncAdmin admin = conn.getAdmin();\n+\n+    final File testDataDir = ensureTestDataDirExists(miniClusterRule.getTestingUtility());\n+    final File testFile = new File(testDataDir, \"shell_exec_async.txt\");\n+    assertTrue(testFile.createNewFile());\n+    assertEquals(0, testFile.length());\n+\n+    final String command = \"echo \\\"hello world\\\" >> \" + testFile.getAbsolutePath();\n+    final ShellExecRequest req = ShellExecRequest.newBuilder()\n+      .setCommand(command)\n+      .build();\n+    admin.<ShellExecService.Stub, ShellExecResponse>coprocessorService(\n+      ShellExecService::newStub,\n+      (stub, controller, callback) -> stub.shellExecAsync(controller, req, callback))\n+      .join();\n+\n+    Waiter.waitFor(conn.getConfiguration(), 5_000, () -> testFile.length() > 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDkwMjMwNQ=="}, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk5NTA3MA==", "bodyText": "Well, add in a trim, but yes, I suppose I do. Thanks :)", "url": "https://github.com/apache/hbase/pull/1583#discussion_r415995070", "createdAt": "2020-04-27T17:11:39Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/TestShellExecCoproc.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+/**\n+ * Test for the {@link ShellExecCoproc}.\n+ */\n+@Category(MediumTests.class)\n+public class TestShellExecCoproc {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule testRule =\n+    HBaseClassTestRule.forClass(TestShellExecCoproc.class);\n+\n+  @ClassRule\n+  public static final MiniClusterRule miniClusterRule = MiniClusterRule.newBuilder()\n+    .setConfiguration(createConfiguration())\n+    .build();\n+\n+  @Rule\n+  public final ConnectionRule connectionRule =\n+    new ConnectionRule(miniClusterRule::createConnection);\n+\n+  @Test\n+  public void testShellExec() {\n+    final AsyncConnection conn = connectionRule.getConnection();\n+    final AsyncAdmin admin = conn.getAdmin();\n+\n+    final String command = \"echo -n \\\"hello world\\\"\";\n+    final ShellExecRequest req = ShellExecRequest.newBuilder()\n+      .setCommand(command)\n+      .build();\n+    final ShellExecResponse resp = admin\n+      .<ShellExecService.Stub, ShellExecResponse>coprocessorService(\n+        ShellExecService::newStub,\n+        (stub, controller, callback) -> stub.shellExec(controller, req, callback))\n+      .join();\n+    assertEquals(0, resp.getExitCode());\n+    assertEquals(\"hello world\", resp.getStdout());\n+  }\n+\n+  @Test\n+  public void testShellExecAsync() throws IOException {\n+    final AsyncConnection conn = connectionRule.getConnection();\n+    final AsyncAdmin admin = conn.getAdmin();\n+\n+    final File testDataDir = ensureTestDataDirExists(miniClusterRule.getTestingUtility());\n+    final File testFile = new File(testDataDir, \"shell_exec_async.txt\");\n+    assertTrue(testFile.createNewFile());\n+    assertEquals(0, testFile.length());\n+\n+    final String command = \"echo \\\"hello world\\\" >> \" + testFile.getAbsolutePath();\n+    final ShellExecRequest req = ShellExecRequest.newBuilder()\n+      .setCommand(command)\n+      .build();\n+    admin.<ShellExecService.Stub, ShellExecResponse>coprocessorService(\n+      ShellExecService::newStub,\n+      (stub, controller, callback) -> stub.shellExecAsync(controller, req, callback))\n+      .join();\n+\n+    Waiter.waitFor(conn.getConfiguration(), 5_000, () -> testFile.length() > 0);\n+    final String content = Optional.of(testFile.toPath())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDk5MTMyMw=="}, "originalCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b"}, "originalPosition": 98}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d2f14b585778bb1af1158a8da208145f464b2a7b", "author": {"user": {"login": "ndimiduk", "name": "Nick Dimiduk"}}, "url": "https://github.com/apache/hbase/commit/d2f14b585778bb1af1158a8da208145f464b2a7b", "committedDate": "2020-04-24T19:32:15Z", "message": "HBASE-24260 Add a ClusterManager that issues commands via coprocessor\n\nImplements `ClusterManager` that relies on the new `ShellExecCoproc`\nfor remote shell command execution."}, "afterCommit": {"oid": "aed6fb2b6e3962cefac4512eadc17453b3e60070", "author": {"user": {"login": "ndimiduk", "name": "Nick Dimiduk"}}, "url": "https://github.com/apache/hbase/commit/aed6fb2b6e3962cefac4512eadc17453b3e60070", "committedDate": "2020-04-29T22:17:04Z", "message": "HBASE-24260 Add a ClusterManager that issues commands via coprocessor\n\nImplements `ClusterManager` that relies on the new\n`ShellExecEndpointCoprocessor` for remote shell command execution."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMDkzMjU5", "url": "https://github.com/apache/hbase/pull/1583#pullrequestreview-403093259", "createdAt": "2020-04-29T22:47:39Z", "commit": {"oid": "aed6fb2b6e3962cefac4512eadc17453b3e60070"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMjo0Nzo0MFrOGOTwbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMjo0Nzo0MFrOGOTwbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1Njk0Mg==", "bodyText": "stdout() could potentially spam the logs? Consider including it a lower logging level.", "url": "https://github.com/apache/hbase/pull/1583#discussion_r417656942", "createdAt": "2020-04-29T22:47:40Z", "author": {"login": "bharathv"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/CoprocClusterManager.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.hadoop.hbase.client.AsyncAdmin;\n+import org.apache.hadoop.hbase.client.AsyncConnection;\n+import org.apache.hadoop.hbase.client.ConnectionFactory;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecRequest;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecResponse;\n+import org.apache.hadoop.hbase.coprocessor.protobuf.generated.ShellExecEndpoint.ShellExecService;\n+import org.apache.hadoop.hbase.util.Pair;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Overrides commands to make use of coprocessor where possible. Only supports actions taken\n+ * against Master and Region Server hosts.\n+ */\n+@InterfaceAudience.Private\n+@SuppressWarnings(\"unused\") // no way to test this without a distributed cluster.\n+public class CoprocClusterManager extends HBaseClusterManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(CoprocClusterManager.class);\n+  private static final Set<ServiceType> supportedServices = buildSupportedServicesSet();\n+\n+  @Override\n+  protected Pair<Integer, String> exec(String hostname, ServiceType service, String... cmd)\n+    throws IOException {\n+    if (!supportedServices.contains(service)) {\n+      throw unsupportedServiceType(service);\n+    }\n+\n+    // We only support actions vs. Master or Region Server processes. We're issuing those actions\n+    // via the coprocessor that's running within those processes. Thus, there's no support for\n+    // honoring the configured service user.\n+    final String command = StringUtils.join(cmd, \" \");\n+    LOG.info(\"Executing remote command: {}, hostname:{}\", command, hostname);\n+\n+    try (final AsyncConnection conn = ConnectionFactory.createAsyncConnection(getConf()).join()) {\n+      final AsyncAdmin admin = conn.getAdmin();\n+      final ShellExecRequest req = ShellExecRequest.newBuilder()\n+        .setCommand(command)\n+        .setAwaitResponse(false)\n+        .build();\n+\n+      final ShellExecResponse resp;\n+      switch(service) {\n+        case HBASE_MASTER:\n+          // What happens if the intended action was killing a backup master? Right now we have\n+          // no `RestartBackupMasterAction` so it's probably fine.\n+          resp = masterExec(admin, req);\n+          break;\n+        case HBASE_REGIONSERVER:\n+          final ServerName targetHost = resolveRegionServerName(admin, hostname);\n+          resp = regionServerExec(admin, req, targetHost);\n+          break;\n+        default:\n+          throw new RuntimeException(\"should not happen\");\n+      }\n+\n+      LOG.info(\"Executed remote command: {}, exit code:{} , output:{}\", command, resp.getExitCode(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aed6fb2b6e3962cefac4512eadc17453b3e60070"}, "originalPosition": 82}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aed6fb2b6e3962cefac4512eadc17453b3e60070", "author": {"user": {"login": "ndimiduk", "name": "Nick Dimiduk"}}, "url": "https://github.com/apache/hbase/commit/aed6fb2b6e3962cefac4512eadc17453b3e60070", "committedDate": "2020-04-29T22:17:04Z", "message": "HBASE-24260 Add a ClusterManager that issues commands via coprocessor\n\nImplements `ClusterManager` that relies on the new\n`ShellExecEndpointCoprocessor` for remote shell command execution."}, "afterCommit": {"oid": "7fbbda6aad0083abc8eaf3269da65f36c6e3d231", "author": {"user": {"login": "ndimiduk", "name": "Nick Dimiduk"}}, "url": "https://github.com/apache/hbase/commit/7fbbda6aad0083abc8eaf3269da65f36c6e3d231", "committedDate": "2020-04-30T23:32:10Z", "message": "HBASE-24260 Add a ClusterManager that issues commands via coprocessor\n\nImplements `ClusterManager` that relies on the new\n`ShellExecEndpointCoprocessor` for remote shell command execution."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8274663b9658486ff5de995557e1a6a3372ee15", "author": {"user": {"login": "ndimiduk", "name": "Nick Dimiduk"}}, "url": "https://github.com/apache/hbase/commit/f8274663b9658486ff5de995557e1a6a3372ee15", "committedDate": "2020-05-04T17:18:46Z", "message": "HBASE-24260 Add a ClusterManager that issues commands via coprocessor\n\nImplements `ClusterManager` that relies on the new\n`ShellExecEndpointCoprocessor` for remote shell command execution.\n\nSigned-off-by: Bharath Vissapragada <bharathv@apache.org>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7fbbda6aad0083abc8eaf3269da65f36c6e3d231", "author": {"user": {"login": "ndimiduk", "name": "Nick Dimiduk"}}, "url": "https://github.com/apache/hbase/commit/7fbbda6aad0083abc8eaf3269da65f36c6e3d231", "committedDate": "2020-04-30T23:32:10Z", "message": "HBASE-24260 Add a ClusterManager that issues commands via coprocessor\n\nImplements `ClusterManager` that relies on the new\n`ShellExecEndpointCoprocessor` for remote shell command execution."}, "afterCommit": {"oid": "f8274663b9658486ff5de995557e1a6a3372ee15", "author": {"user": {"login": "ndimiduk", "name": "Nick Dimiduk"}}, "url": "https://github.com/apache/hbase/commit/f8274663b9658486ff5de995557e1a6a3372ee15", "committedDate": "2020-05-04T17:18:46Z", "message": "HBASE-24260 Add a ClusterManager that issues commands via coprocessor\n\nImplements `ClusterManager` that relies on the new\n`ShellExecEndpointCoprocessor` for remote shell command execution.\n\nSigned-off-by: Bharath Vissapragada <bharathv@apache.org>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2227, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}