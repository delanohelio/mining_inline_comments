{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI3NTUzMjU5", "number": 2709, "title": "HBASE-25307 ThreadLocal pooling leads to NullPointerException (#2685)", "bodyText": "PoolMap does not discard any elements anymore. If an element is put,\nit always stores it. The reason: it stores expensive resources (rpc\nconnections) which would lead to resource leak if we simple discard it.\nRpcClients can reference netty ByteBufs which are reference counted.\nResource cleanup is done by AbstractRpcClient.cleanupIdleConnections().\nPoolMap does not implement Map interface anymore, so ensuring\nthread-safety has become easier. Put method is replaced with getOrCreate().\nThreadLocalPool doesn't use ThreadLocal class anymore. It stores\nresources on thread basis, but it doesn't remove values when a thread\nexits. Again, proper cleanup is done by cleanupIdleConnections().\n\nSigned-off-by: Sean Busbey busbey@apache.org\nSigned-off-by: Wellington Chevreuil wellington.chevreuil@gmail.com", "createdAt": "2020-11-25T16:11:47Z", "url": "https://github.com/apache/hbase/pull/2709", "merged": true, "mergeCommit": {"oid": "b75b772bc6e5dad59ec8e051b6169e94896759f6"}, "closed": true, "closedAt": "2020-11-30T11:36:08Z", "author": {"login": "meszibalu"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdgDFwigFqTUzODc3NjA4NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdgfw21AFqTUzOTcwMDY4NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4Nzc2MDg0", "url": "https://github.com/apache/hbase/pull/2709#pullrequestreview-538776084", "createdAt": "2020-11-25T18:58:48Z", "commit": {"oid": "508efac6bc4e22c227d15c14a4729cdb465d9d9d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxODo1ODo0OVrOH6AYBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxODo1ODo0OVrOH6AYBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4NTYwNg==", "bodyText": "one important property of the Reusable pool is that things came out of the pool while being used, which essentially ensured a given resource was only ever in use by a single thread at a time (presuming whatever checked the resource out did not make it visible to multiple threads). So under contention we'd have a number of copies of the resource on par with the number of accessors (similar to the ThreadLocal pool) but when the contention passed we wouldn't keep them around.\nI'm trying to see if we made use of this property or not.", "url": "https://github.com/apache/hbase/pull/2709#discussion_r530585606", "createdAt": "2020-11-25T18:58:49Z", "author": {"login": "busbey"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/util/PoolMap.java", "diffHunk": "@@ -270,58 +195,16 @@ public static PoolType fuzzyMatch(String name) {\n \n   protected Pool<V> createPool() {\n     switch (poolType) {\n-    case Reusable:\n-      return new ReusablePool<>(poolMaxSize);\n-    case RoundRobin:\n-      return new RoundRobinPool<>(poolMaxSize);\n-    case ThreadLocal:\n-      return new ThreadLocalPool<>();\n-    }\n-    return null;\n-  }\n-\n-  /**\n-   * The <code>ReusablePool</code> represents a {@link PoolMap.Pool} that builds\n-   * on the {@link java.util.LinkedList} class. It essentially allows resources to be\n-   * checked out, at which point it is removed from this pool. When the resource\n-   * is no longer required, it should be returned to the pool in order to be\n-   * reused.\n-   *\n-   * <p>\n-   * If {@link #maxSize} is set to {@link Integer#MAX_VALUE}, then the size of\n-   * the pool is unbounded. Otherwise, it caps the number of consumers that can\n-   * check out a resource from this pool to the (non-zero positive) value\n-   * specified in {@link #maxSize}.\n-   * </p>\n-   *\n-   * @param <R>\n-   *          the type of the resource\n-   */\n-  @SuppressWarnings(\"serial\")\n-  public static class ReusablePool<R> extends ConcurrentLinkedQueue<R> implements Pool<R> {\n-    private int maxSize;\n-\n-    public ReusablePool(int maxSize) {\n-      this.maxSize = maxSize;\n-\n-    }\n-\n-    @Override\n-    public R get() {\n-      return poll();\n-    }\n-\n-    @Override\n-    public R put(R resource) {\n-      if (super.size() < maxSize) {\n-        add(resource);\n-      }\n-      return null;\n-    }\n-\n-    @Override\n-    public Collection<R> values() {\n-      return this;\n+      case Reusable:\n+        /* Reusable pool is the same as a 1 element round robin pool. It returns the same element\n+         * until it is removed. */\n+        return new RoundRobinPool<>(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "508efac6bc4e22c227d15c14a4729cdb465d9d9d"}, "originalPosition": 324}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM4ODA0ODEy", "url": "https://github.com/apache/hbase/pull/2709#pullrequestreview-538804812", "createdAt": "2020-11-25T19:48:45Z", "commit": {"oid": "508efac6bc4e22c227d15c14a4729cdb465d9d9d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c06f11f6d6b8173b7ba6030473710903d61347a", "author": {"user": {"login": "meszibalu", "name": "Balazs Meszaros"}}, "url": "https://github.com/apache/hbase/commit/6c06f11f6d6b8173b7ba6030473710903d61347a", "committedDate": "2020-11-26T12:06:45Z", "message": "HBASE-25307 ThreadLocal pooling leads to NullPointerException (#2685)\n\n* PoolMap does not discard any elements anymore. If an element is put,\nit always stores it. The reason: it stores expensive resources (rpc\nconnections) which would lead to resource leak if we simple discard it.\nRpcClients can reference netty ByteBufs which are reference counted.\nResource cleanup is done by AbstractRpcClient.cleanupIdleConnections().\n* PoolMap does not implement Map interface anymore, so ensuring\nthread-safety has become easier. Put method is replaced with getOrCreate().\n* ThreadLocalPool doesn't use ThreadLocal class anymore. It stores\nresources on thread basis, but it doesn't remove values when a thread\nexits. Again, proper cleanup is done by cleanupIdleConnections().\n\nSigned-off-by: Sean Busbey <busbey@apache.org>\nSigned-off-by: Wellington Chevreuil <wellington.chevreuil@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "508efac6bc4e22c227d15c14a4729cdb465d9d9d", "author": {"user": {"login": "meszibalu", "name": "Balazs Meszaros"}}, "url": "https://github.com/apache/hbase/commit/508efac6bc4e22c227d15c14a4729cdb465d9d9d", "committedDate": "2020-11-25T16:10:32Z", "message": "HBASE-25307 ThreadLocal pooling leads to NullPointerException (#2685)\n\n* PoolMap does not discard any elements anymore. If an element is put,\nit always stores it. The reason: it stores expensive resources (rpc\nconnections) which would lead to resource leak if we simple discard it.\nRpcClients can reference netty ByteBufs which are reference counted.\nResource cleanup is done by AbstractRpcClient.cleanupIdleConnections().\n* PoolMap does not implement Map interface anymore, so ensuring\nthread-safety has become easier. Put method is replaced with getOrCreate().\n* ThreadLocalPool doesn't use ThreadLocal class anymore. It stores\nresources on thread basis, but it doesn't remove values when a thread\nexits. Again, proper cleanup is done by cleanupIdleConnections().\n\nSigned-off-by: Sean Busbey <busbey@apache.org>\nSigned-off-by: Wellington Chevreuil <wellington.chevreuil@gmail.com>"}, "afterCommit": {"oid": "6c06f11f6d6b8173b7ba6030473710903d61347a", "author": {"user": {"login": "meszibalu", "name": "Balazs Meszaros"}}, "url": "https://github.com/apache/hbase/commit/6c06f11f6d6b8173b7ba6030473710903d61347a", "committedDate": "2020-11-26T12:06:45Z", "message": "HBASE-25307 ThreadLocal pooling leads to NullPointerException (#2685)\n\n* PoolMap does not discard any elements anymore. If an element is put,\nit always stores it. The reason: it stores expensive resources (rpc\nconnections) which would lead to resource leak if we simple discard it.\nRpcClients can reference netty ByteBufs which are reference counted.\nResource cleanup is done by AbstractRpcClient.cleanupIdleConnections().\n* PoolMap does not implement Map interface anymore, so ensuring\nthread-safety has become easier. Put method is replaced with getOrCreate().\n* ThreadLocalPool doesn't use ThreadLocal class anymore. It stores\nresources on thread basis, but it doesn't remove values when a thread\nexits. Again, proper cleanup is done by cleanupIdleConnections().\n\nSigned-off-by: Sean Busbey <busbey@apache.org>\nSigned-off-by: Wellington Chevreuil <wellington.chevreuil@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5NzAwNjg0", "url": "https://github.com/apache/hbase/pull/2709#pullrequestreview-539700684", "createdAt": "2020-11-27T04:23:14Z", "commit": {"oid": "6c06f11f6d6b8173b7ba6030473710903d61347a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1760, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}