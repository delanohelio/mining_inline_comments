{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwMzkxMTU2", "number": 1600, "title": "HBASE-24274 `RESTApiClusterManager` attempts to deserialize response using serialization API", "bodyText": "Use the correct GSON API for deserializing service responses. Add\nsimple unit test covering a very limited selection of the overall API\nsurface area, just enough to ensure deserialization works.\nAssuming this works for you folks, I'll port to appropriate branches.", "createdAt": "2020-04-28T22:20:27Z", "url": "https://github.com/apache/hbase/pull/1600", "merged": true, "mergeCommit": {"oid": "bd27542a45a43feefa9a1c267a7af6c86c7023a8"}, "closed": true, "closedAt": "2020-04-29T20:09:04Z", "author": {"login": "ndimiduk"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABccLtTYABqjMyODIzNzczOTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcceI_YABqjMyODYyNzUzODM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a9b037b9de81dbb019072f0a1279b4d93552e8c", "author": {"user": {"login": "ndimiduk", "name": "Nick Dimiduk"}}, "url": "https://github.com/apache/hbase/commit/0a9b037b9de81dbb019072f0a1279b4d93552e8c", "committedDate": "2020-04-28T22:11:37Z", "message": "HBASE-24274 `RESTApiClusterManager` attempts to deserialize response using serialization API\n\nUse the correct GSON API for deserializing service responses. Add\nsimple unit test covering a very limited selection of the overall API\nsurface area, just enough to ensure deserialization works."}, "afterCommit": {"oid": "64df57cf6647d0edaa3a52a883a74ba6eadbd411", "author": {"user": {"login": "ndimiduk", "name": "Nick Dimiduk"}}, "url": "https://github.com/apache/hbase/commit/64df57cf6647d0edaa3a52a883a74ba6eadbd411", "committedDate": "2020-04-28T22:34:14Z", "message": "HBASE-24274 `RESTApiClusterManager` attempts to deserialize response using serialization API\n\nUse the correct GSON API for deserializing service responses. Add\nsimple unit test covering a very limited selection of the overall API\nsurface area, just enough to ensure deserialization works."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMzY2MDA5", "url": "https://github.com/apache/hbase/pull/1600#pullrequestreview-402366009", "createdAt": "2020-04-29T05:04:25Z", "commit": {"oid": "64df57cf6647d0edaa3a52a883a74ba6eadbd411"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNTowNDoyNVrOGNv13Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNTowNzozMVrOGNv4wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2ODUwOQ==", "bodyText": "For sure we need each of these?", "url": "https://github.com/apache/hbase/pull/1600#discussion_r417068509", "createdAt": "2020-04-29T05:04:25Z", "author": {"login": "saintstack"}, "path": "hbase-it/pom.xml", "diffHunk": "@@ -253,6 +253,21 @@\n       <groupId>log4j</groupId>\n       <artifactId>log4j</artifactId>\n     </dependency>\n+    <dependency>\n+      <artifactId>javax.servlet-api</artifactId>\n+      <groupId>javax.servlet</groupId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.eclipse.jetty</groupId>\n+      <artifactId>jetty-server</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.eclipse.jetty</groupId>\n+      <artifactId>jetty-util</artifactId>\n+      <scope>test</scope>\n+    </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64df57cf6647d0edaa3a52a883a74ba6eadbd411"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2ODkyMw==", "bodyText": "Fancy!", "url": "https://github.com/apache/hbase/pull/1600#discussion_r417068923", "createdAt": "2020-04-29T05:06:16Z", "author": {"login": "saintstack"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/MockHttpApiRule.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.BiConsumer;\n+import java.util.regex.Pattern;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.RequestLog;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.server.Slf4jRequestLog;\n+import org.eclipse.jetty.server.handler.AbstractHandler;\n+import org.eclipse.jetty.util.RegexSet;\n+import org.junit.rules.ExternalResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A {@link org.junit.Rule} that manages a simple http server. The caller registers request\n+ * handlers to URI path regexp.\n+ */\n+public class MockHttpApiRule extends ExternalResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MockHttpApiRule.class);\n+\n+  private MockHandler handler;\n+  private Server server;\n+\n+  /**\n+   * Register a callback handler for the specified path target.\n+   */\n+  public MockHttpApiRule addRegistration(\n+    final String pathRegex,\n+    final BiConsumer<String, HttpServletResponse> responder\n+  ) {\n+    handler.register(pathRegex, responder);\n+    return this;\n+  }\n+\n+  /**\n+   * Shortcut method for calling {@link #addRegistration(String, BiConsumer)} with a 200 response.\n+   */\n+  public MockHttpApiRule registerOk(final String pathRegex, final String responseBody) {\n+    return addRegistration(pathRegex, (target, resp) -> {\n+      try {\n+        resp.setStatus(HttpServletResponse.SC_OK);\n+        resp.setCharacterEncoding(\"UTF-8\");\n+        resp.setContentType(MediaType.APPLICATION_JSON_TYPE.toString());\n+        final PrintWriter writer = resp.getWriter();\n+        writer.write(responseBody);\n+        writer.flush();\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+    });\n+  }\n+\n+  public void clearRegistrations() {\n+    handler.clearRegistrations();\n+  }\n+\n+  /**\n+   * Retrieve the service URI for this service.\n+   */\n+  public URI getURI() {\n+    if (server == null || !server.isRunning()) {\n+      throw new IllegalStateException(\"server is not running\");\n+    }\n+    return server.getURI();\n+  }\n+\n+  @Override\n+  protected void before() throws Exception {\n+    handler = new MockHandler();\n+    server = new Server();\n+    final ServerConnector http = new ServerConnector(server);\n+    http.setHost(\"localhost\");\n+    server.addConnector(http);\n+    server.setStopAtShutdown(true);\n+    server.setHandler(handler);\n+    server.setRequestLog(buildRequestLog());\n+    server.start();\n+  }\n+\n+  @Override\n+  protected void after() {\n+    try {\n+      server.stop();\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private static RequestLog buildRequestLog() {\n+    final Slf4jRequestLog requestLog = new Slf4jRequestLog();\n+    requestLog.setLoggerName(LOG.getName() + \".RequestLog\");\n+    requestLog.setExtended(true);\n+    return requestLog;\n+  }\n+\n+  private static class MockHandler extends AbstractHandler {\n+\n+    private final ReadWriteLock responseMappingLock = new ReentrantReadWriteLock();\n+    private final Map<String, BiConsumer<String, HttpServletResponse>> responseMapping =\n+      new HashMap<>();\n+    private final RegexSet regexSet = new RegexSet();\n+\n+    void register(\n+      final String pathRegex,\n+      final BiConsumer<String, HttpServletResponse> responder\n+    ) {\n+      LOG.debug(\"Registering responder to '{}'\", pathRegex);\n+      responseMappingLock.writeLock().lock();\n+      try {\n+        responseMapping.put(pathRegex, responder);\n+        regexSet.add(pathRegex);\n+      } finally {\n+        responseMappingLock.writeLock().unlock();\n+      }\n+    }\n+\n+    void clearRegistrations() {\n+      LOG.debug(\"Clearing registrations\");\n+      responseMappingLock.writeLock().lock();\n+      try {\n+        responseMapping.clear();\n+        regexSet.clear();\n+      } finally {\n+        responseMappingLock.writeLock().unlock();\n+      }\n+    }\n+\n+    @Override\n+    public void handle(\n+      final String target,\n+      final Request baseRequest,\n+      final HttpServletRequest request,\n+      final HttpServletResponse response\n+    ) {\n+      responseMappingLock.readLock().lock();\n+      try {\n+        if (!regexSet.matches(target)) {\n+          response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n+          return;\n+        }\n+        responseMapping.entrySet()\n+          .stream()\n+          .filter(e -> Pattern.matches(e.getKey(), target))\n+          .findAny()\n+          .map(Map.Entry::getValue)\n+          .orElseThrow(() -> noMatchFound(target))\n+          .accept(target, response);\n+      } finally {\n+        responseMappingLock.readLock().unlock();\n+      }\n+    }\n+\n+    private static RuntimeException noMatchFound(final String target) {\n+      return new RuntimeException(\n+        String.format(\"Target path '%s' matches no registered regex.\", target));\n+    }\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64df57cf6647d0edaa3a52a883a74ba6eadbd411"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2OTI0OQ==", "bodyText": "oh. it never worked?", "url": "https://github.com/apache/hbase/pull/1600#discussion_r417069249", "createdAt": "2020-04-29T05:07:31Z", "author": {"login": "saintstack"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/RESTApiClusterManager.java", "diffHunk": "@@ -334,7 +334,7 @@ public String toString() {\n     roleServiceType.put(ServiceType.HBASE_REGIONSERVER, Service.HBASE);\n   }\n \n-  private enum Service {\n+  enum Service {\n     HBASE, HDFS, MAPREDUCE\n   }\n }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64df57cf6647d0edaa3a52a883a74ba6eadbd411"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyODgxMTI4", "url": "https://github.com/apache/hbase/pull/1600#pullrequestreview-402881128", "createdAt": "2020-04-29T17:24:13Z", "commit": {"oid": "64df57cf6647d0edaa3a52a883a74ba6eadbd411"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNzoyNDoxNFrOGOJPgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNzoyOTowOFrOGOJbXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ4NDY3Mg==", "bodyText": "I gathered this list manually, looking at the classes imported in MockHttpApiRule. I could probably do without jetty-util and RegexSet if you prefer.", "url": "https://github.com/apache/hbase/pull/1600#discussion_r417484672", "createdAt": "2020-04-29T17:24:14Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/pom.xml", "diffHunk": "@@ -253,6 +253,21 @@\n       <groupId>log4j</groupId>\n       <artifactId>log4j</artifactId>\n     </dependency>\n+    <dependency>\n+      <artifactId>javax.servlet-api</artifactId>\n+      <groupId>javax.servlet</groupId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.eclipse.jetty</groupId>\n+      <artifactId>jetty-server</artifactId>\n+      <scope>test</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>org.eclipse.jetty</groupId>\n+      <artifactId>jetty-util</artifactId>\n+      <scope>test</scope>\n+    </dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2ODUwOQ=="}, "originalCommit": {"oid": "64df57cf6647d0edaa3a52a883a74ba6eadbd411"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ4NTIwMw==", "bodyText": "Maybe this eventually gets moved into wherever else we have http clients that need testing.", "url": "https://github.com/apache/hbase/pull/1600#discussion_r417485203", "createdAt": "2020-04-29T17:25:04Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/MockHttpApiRule.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.net.URI;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+import java.util.function.BiConsumer;\n+import java.util.regex.Pattern;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.core.MediaType;\n+import org.eclipse.jetty.server.Request;\n+import org.eclipse.jetty.server.RequestLog;\n+import org.eclipse.jetty.server.Server;\n+import org.eclipse.jetty.server.ServerConnector;\n+import org.eclipse.jetty.server.Slf4jRequestLog;\n+import org.eclipse.jetty.server.handler.AbstractHandler;\n+import org.eclipse.jetty.util.RegexSet;\n+import org.junit.rules.ExternalResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A {@link org.junit.Rule} that manages a simple http server. The caller registers request\n+ * handlers to URI path regexp.\n+ */\n+public class MockHttpApiRule extends ExternalResource {\n+  private static final Logger LOG = LoggerFactory.getLogger(MockHttpApiRule.class);\n+\n+  private MockHandler handler;\n+  private Server server;\n+\n+  /**\n+   * Register a callback handler for the specified path target.\n+   */\n+  public MockHttpApiRule addRegistration(\n+    final String pathRegex,\n+    final BiConsumer<String, HttpServletResponse> responder\n+  ) {\n+    handler.register(pathRegex, responder);\n+    return this;\n+  }\n+\n+  /**\n+   * Shortcut method for calling {@link #addRegistration(String, BiConsumer)} with a 200 response.\n+   */\n+  public MockHttpApiRule registerOk(final String pathRegex, final String responseBody) {\n+    return addRegistration(pathRegex, (target, resp) -> {\n+      try {\n+        resp.setStatus(HttpServletResponse.SC_OK);\n+        resp.setCharacterEncoding(\"UTF-8\");\n+        resp.setContentType(MediaType.APPLICATION_JSON_TYPE.toString());\n+        final PrintWriter writer = resp.getWriter();\n+        writer.write(responseBody);\n+        writer.flush();\n+      } catch (IOException e) {\n+        throw new RuntimeException(e);\n+      }\n+    });\n+  }\n+\n+  public void clearRegistrations() {\n+    handler.clearRegistrations();\n+  }\n+\n+  /**\n+   * Retrieve the service URI for this service.\n+   */\n+  public URI getURI() {\n+    if (server == null || !server.isRunning()) {\n+      throw new IllegalStateException(\"server is not running\");\n+    }\n+    return server.getURI();\n+  }\n+\n+  @Override\n+  protected void before() throws Exception {\n+    handler = new MockHandler();\n+    server = new Server();\n+    final ServerConnector http = new ServerConnector(server);\n+    http.setHost(\"localhost\");\n+    server.addConnector(http);\n+    server.setStopAtShutdown(true);\n+    server.setHandler(handler);\n+    server.setRequestLog(buildRequestLog());\n+    server.start();\n+  }\n+\n+  @Override\n+  protected void after() {\n+    try {\n+      server.stop();\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private static RequestLog buildRequestLog() {\n+    final Slf4jRequestLog requestLog = new Slf4jRequestLog();\n+    requestLog.setLoggerName(LOG.getName() + \".RequestLog\");\n+    requestLog.setExtended(true);\n+    return requestLog;\n+  }\n+\n+  private static class MockHandler extends AbstractHandler {\n+\n+    private final ReadWriteLock responseMappingLock = new ReentrantReadWriteLock();\n+    private final Map<String, BiConsumer<String, HttpServletResponse>> responseMapping =\n+      new HashMap<>();\n+    private final RegexSet regexSet = new RegexSet();\n+\n+    void register(\n+      final String pathRegex,\n+      final BiConsumer<String, HttpServletResponse> responder\n+    ) {\n+      LOG.debug(\"Registering responder to '{}'\", pathRegex);\n+      responseMappingLock.writeLock().lock();\n+      try {\n+        responseMapping.put(pathRegex, responder);\n+        regexSet.add(pathRegex);\n+      } finally {\n+        responseMappingLock.writeLock().unlock();\n+      }\n+    }\n+\n+    void clearRegistrations() {\n+      LOG.debug(\"Clearing registrations\");\n+      responseMappingLock.writeLock().lock();\n+      try {\n+        responseMapping.clear();\n+        regexSet.clear();\n+      } finally {\n+        responseMappingLock.writeLock().unlock();\n+      }\n+    }\n+\n+    @Override\n+    public void handle(\n+      final String target,\n+      final Request baseRequest,\n+      final HttpServletRequest request,\n+      final HttpServletResponse response\n+    ) {\n+      responseMappingLock.readLock().lock();\n+      try {\n+        if (!regexSet.matches(target)) {\n+          response.setStatus(HttpServletResponse.SC_NOT_FOUND);\n+          return;\n+        }\n+        responseMapping.entrySet()\n+          .stream()\n+          .filter(e -> Pattern.matches(e.getKey(), target))\n+          .findAny()\n+          .map(Map.Entry::getValue)\n+          .orElseThrow(() -> noMatchFound(target))\n+          .accept(target, response);\n+      } finally {\n+        responseMappingLock.readLock().unlock();\n+      }\n+    }\n+\n+    private static RuntimeException noMatchFound(final String target) {\n+      return new RuntimeException(\n+        String.format(\"Target path '%s' matches no registered regex.\", target));\n+    }\n+  }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2ODkyMw=="}, "originalCommit": {"oid": "64df57cf6647d0edaa3a52a883a74ba6eadbd411"}, "originalPosition": 187}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ4NjMxNg==", "bodyText": "This is the meat of the fix. toJsonTree is for serializing an object to json, not for reading an object from json. It was returning a JsonPrimitive<String> instead of parsing the string content.", "url": "https://github.com/apache/hbase/pull/1600#discussion_r417486316", "createdAt": "2020-04-29T17:26:48Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/RESTApiClusterManager.java", "diffHunk": "@@ -238,16 +236,18 @@ private String getHostId(String hostname) throws IOException {\n \n   // Execute GET against URI, returning a JsonNode object to be traversed.\n   private JsonElement getJsonNodeFromURIGet(URI uri) throws IOException {\n-    LOG.info(\"Executing GET against \" + uri + \"...\");\n-    WebTarget webTarget = client.target(uri);\n-    Invocation.Builder invocationBuilder = webTarget.request(MediaType.APPLICATION_JSON);\n-    Response response = invocationBuilder.get();\n+    LOG.debug(\"Executing GET against \" + uri + \"...\");\n+    final Response response = client.target(uri)\n+      .request(MediaType.APPLICATION_JSON_TYPE)\n+      .get();\n     int statusCode = response.getStatus();\n     if (statusCode != Response.Status.OK.getStatusCode()) {\n       throw new HTTPException(statusCode);\n     }\n     // This API folds information as the value to an \"items\" attribute.\n-    return GSON.toJsonTree(response.readEntity(String.class)).getAsJsonObject().get(\"items\");\n+    return parser.parse(response.readEntity(String.class))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64df57cf6647d0edaa3a52a883a74ba6eadbd411"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ4NjQ3NA==", "bodyText": "I suspect it worked before the switch to GSON.", "url": "https://github.com/apache/hbase/pull/1600#discussion_r417486474", "createdAt": "2020-04-29T17:27:05Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/RESTApiClusterManager.java", "diffHunk": "@@ -334,7 +334,7 @@ public String toString() {\n     roleServiceType.put(ServiceType.HBASE_REGIONSERVER, Service.HBASE);\n   }\n \n-  private enum Service {\n+  enum Service {\n     HBASE, HDFS, MAPREDUCE\n   }\n }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA2OTI0OQ=="}, "originalCommit": {"oid": "64df57cf6647d0edaa3a52a883a74ba6eadbd411"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQ4NzcxMQ==", "bodyText": "Building these json strings by hand is awful. Maybe better to populate maps, or define POJOs? None of it is particularly elegant.", "url": "https://github.com/apache/hbase/pull/1600#discussion_r417487711", "createdAt": "2020-04-29T17:29:08Z", "author": {"login": "ndimiduk"}, "path": "hbase-it/src/test/java/org/apache/hadoop/hbase/TestRESTApiClusterManager.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import static org.junit.Assert.assertTrue;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ClusterManager.ServiceType;\n+import org.apache.hadoop.hbase.RESTApiClusterManager.Service;\n+import org.apache.hadoop.hbase.testclassification.SmallTests;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.TestName;\n+\n+@Category(SmallTests.class)\n+public class TestRESTApiClusterManager {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule testRule =\n+    HBaseClassTestRule.forClass(TestRESTApiClusterManager.class);\n+\n+  @ClassRule\n+  public static MockHttpApiRule mockHttpApi = new MockHttpApiRule();\n+\n+  @Rule\n+  public final TestName testName = new TestName();\n+\n+  private static HBaseCommonTestingUtility testingUtility;\n+  private ClusterManager clusterManager;\n+\n+  @BeforeClass\n+  public static void beforeClass() {\n+    testingUtility = new HBaseCommonTestingUtility();\n+    configureClusterManager(testingUtility.getConfiguration());\n+  }\n+\n+  @Before\n+  public void before() {\n+    mockHttpApi.clearRegistrations();\n+    final Configuration methodConf = new Configuration(testingUtility.getConfiguration());\n+    methodConf.set(\"hbase.it.clustermanager.restapi.clustername\", testName.getMethodName());\n+    clusterManager = new RESTApiClusterManager();\n+    clusterManager.setConf(methodConf);\n+  }\n+\n+  @Test\n+  public void isRunningPositive() throws IOException {\n+    final String clusterName = testName.getMethodName();\n+    final String hostName = \"somehost\";\n+    final String serviceName = \"hbase\";\n+    final String hostId = \"some-id\";\n+    registerServiceName(clusterName, Service.HBASE, serviceName);\n+    registerHost(hostName, hostId);\n+    final Map<String, String> hostProperties = new HashMap<>();\n+    hostProperties.put(\"roleState\", \"STARTED\");\n+    hostProperties.put(\"healthSummary\", \"GOOD\");\n+    registerHostProperties(\n+      clusterName, serviceName, hostId, ServiceType.HBASE_MASTER, hostProperties);\n+    assertTrue(clusterManager.isRunning(ServiceType.HBASE_MASTER, hostName, -1));\n+  }\n+\n+  private static void configureClusterManager(final Configuration conf) {\n+    conf.set(\"hbase.it.clustermanager.restapi.hostname\", mockHttpApi.getURI().toString());\n+  }\n+\n+  private static void registerServiceName(\n+    final String clusterName,\n+    final Service service,\n+    final String serviceName\n+  ) {\n+    final String target = String.format(\"^/api/v6/clusters/%s/services\", clusterName);\n+    final String response = String.format(\n+      \"{ \\\"items\\\": [ { \\\"type\\\": \\\"%s\\\", \\\"name\\\": \\\"%s\\\" } ] }\", service, serviceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64df57cf6647d0edaa3a52a883a74ba6eadbd411"}, "originalPosition": 94}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53579a3ca66a9b6995b6227925e7e669647ec7b6", "author": {"user": {"login": "ndimiduk", "name": "Nick Dimiduk"}}, "url": "https://github.com/apache/hbase/commit/53579a3ca66a9b6995b6227925e7e669647ec7b6", "committedDate": "2020-04-29T20:02:01Z", "message": "HBASE-24274 `RESTApiClusterManager` attempts to deserialize response using serialization API\n\nUse the correct GSON API for deserializing service responses. Add\nsimple unit test covering a very limited selection of the overall API\nsurface area, just enough to ensure deserialization works.\n\nSigned-off-by: stack <stack@apache.org>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "64df57cf6647d0edaa3a52a883a74ba6eadbd411", "author": {"user": {"login": "ndimiduk", "name": "Nick Dimiduk"}}, "url": "https://github.com/apache/hbase/commit/64df57cf6647d0edaa3a52a883a74ba6eadbd411", "committedDate": "2020-04-28T22:34:14Z", "message": "HBASE-24274 `RESTApiClusterManager` attempts to deserialize response using serialization API\n\nUse the correct GSON API for deserializing service responses. Add\nsimple unit test covering a very limited selection of the overall API\nsurface area, just enough to ensure deserialization works."}, "afterCommit": {"oid": "53579a3ca66a9b6995b6227925e7e669647ec7b6", "author": {"user": {"login": "ndimiduk", "name": "Nick Dimiduk"}}, "url": "https://github.com/apache/hbase/commit/53579a3ca66a9b6995b6227925e7e669647ec7b6", "committedDate": "2020-04-29T20:02:01Z", "message": "HBASE-24274 `RESTApiClusterManager` attempts to deserialize response using serialization API\n\nUse the correct GSON API for deserializing service responses. Add\nsimple unit test covering a very limited selection of the overall API\nsurface area, just enough to ensure deserialization works.\n\nSigned-off-by: stack <stack@apache.org>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2261, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}