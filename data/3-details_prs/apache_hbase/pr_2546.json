{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNTUxNDc4", "number": 2546, "title": "HBASE-24813 ReplicationSource should clear buffer usage on Replicatio\u2026", "bodyText": "\u2026nSourceManager upon termination (rebased after HBASE-25117)", "createdAt": "2020-10-14T18:09:24Z", "url": "https://github.com/apache/hbase/pull/2546", "merged": true, "mergeCommit": {"oid": "85842634e518155db3c964bf15555291d5fbdd45"}, "closed": true, "closedAt": "2021-01-05T10:21:27Z", "author": {"login": "wchevreuil"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdShL7VAH2gAyNTAzNTUxNDc4OjhjNDljMWJjMTc1YzU4YmQ2MmM4NTdlYjM4NjNkZGVmYmM1NTI0Njk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdboyxbgFqTUyODY4MjI1MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8c49c1bc175c58bd62c857eb3863ddefbc552469", "author": {"user": {"login": "wchevreuil", "name": "Wellington Ramos Chevreuil"}}, "url": "https://github.com/apache/hbase/commit/8c49c1bc175c58bd62c857eb3863ddefbc552469", "committedDate": "2020-10-14T18:07:46Z", "message": "HBASE-24813 ReplicationSource should clear buffer usage on ReplicationSourceManager upon termination (rebased after HBASE-25117)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5MDI5MTc3", "url": "https://github.com/apache/hbase/pull/2546#pullrequestreview-509029177", "createdAt": "2020-10-15T06:24:54Z", "commit": {"oid": "8c49c1bc175c58bd62c857eb3863ddefbc552469"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwNjoyNDo1NFrOHhywtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwNjoyNDo1NFrOHhywtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE5NjcyNA==", "bodyText": "If move \"stop\" here, the HBASE-25117 problem still exist?", "url": "https://github.com/apache/hbase/pull/2546#discussion_r505196724", "createdAt": "2020-10-15T06:24:54Z", "author": {"login": "infraio"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -712,8 +707,14 @@ public void terminate(String reason, Exception cause, boolean clearMetrics,\n           worker.entryReader.interrupt();\n         }\n       }\n+      //If worker is already stopped but there was still entries batched,\n+      //we need to clear buffer used for non processed entries\n+      worker.clearWALEntryBatch();\n     }\n \n+    if (this.replicationEndpoint != null) {\n+      this.replicationEndpoint.stop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c49c1bc175c58bd62c857eb3863ddefbc552469"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af8166f4548a19cb29f405ff716905498680791d", "author": {"user": {"login": "wchevreuil", "name": "Wellington Ramos Chevreuil"}}, "url": "https://github.com/apache/hbase/commit/af8166f4548a19cb29f405ff716905498680791d", "committedDate": "2020-10-19T10:30:37Z", "message": "addressing Guanghao's comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NDk5MDY4", "url": "https://github.com/apache/hbase/pull/2546#pullrequestreview-526499068", "createdAt": "2020-11-09T17:42:11Z", "commit": {"oid": "8c49c1bc175c58bd62c857eb3863ddefbc552469"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzo0MjoxMVrOHv6Nfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzo0MjoxMVrOHv6Nfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTk5ODg0Nw==", "bodyText": "please add if (LOG.isTrace) { LOG.trace..}", "url": "https://github.com/apache/hbase/pull/2546#discussion_r519998847", "createdAt": "2020-11-09T17:42:11Z", "author": {"login": "esteban"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceShipper.java", "diffHunk": "@@ -325,4 +327,53 @@ void stopWorker() {\n   public boolean isFinished() {\n     return state == WorkerState.FINISHED;\n   }\n+\n+  /**\n+   * Attempts to properly update <code>ReplicationSourceManager.totalBufferUser</code>,\n+   * in case there were unprocessed entries batched by the reader to the shipper,\n+   * but the shipper didn't manage to ship those because the replication source is being terminated.\n+   * In that case, it iterates through the batched entries and decrease the pending\n+   * entries size from <code>ReplicationSourceManager.totalBufferUser</code>\n+   * <p/>\n+   * <b>NOTES</b>\n+   * 1) This method should only be called upon replication source termination.\n+   * It blocks waiting for both shipper and reader threads termination,\n+   * to make sure no race conditions\n+   * when updating <code>ReplicationSourceManager.totalBufferUser</code>.\n+   *\n+   * 2) It <b>does not</b> attempt to terminate reader and shipper threads. Those <b>must</b>\n+   * have been triggered interruption/termination prior to calling this method.\n+   */\n+  void clearWALEntryBatch() {\n+    long timeout = System.currentTimeMillis() + this.shipEditsTimeout;\n+    while(this.isAlive() || this.entryReader.isAlive()){\n+      try {\n+        if (System.currentTimeMillis() >= timeout) {\n+          LOG.warn(\"Interrupting source thread for peer {} without cleaning buffer usage \"\n+            + \"because clearWALEntryBatch method timed out whilst waiting reader/shipper \"\n+            + \"thread to stop.\", this.source.getPeerId());\n+          Thread.currentThread().interrupt();\n+        } else {\n+          // Wait both shipper and reader threads to stop\n+          Thread.sleep(this.sleepForRetries);\n+        }\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"{} Interrupted while waiting {} to stop on clearWALEntryBatch: {}\",\n+          this.source.getPeerId(), this.getName(), e);\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+    LongAccumulator totalToDecrement = new LongAccumulator((a,b) -> a + b, 0);\n+    entryReader.entryBatchQueue.forEach(w -> {\n+      entryReader.entryBatchQueue.remove(w);\n+      w.getWalEntries().forEach(e -> {\n+        long entrySizeExcludeBulkLoad = entryReader.getEntrySizeExcludeBulkLoad(e);\n+        totalToDecrement.accumulate(entrySizeExcludeBulkLoad);\n+      });\n+    });\n+\n+    LOG.trace(\"Decrementing totalBufferUsed by {}B while stopping Replication WAL Readers.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c49c1bc175c58bd62c857eb3863ddefbc552469"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NTA1MDMz", "url": "https://github.com/apache/hbase/pull/2546#pullrequestreview-526505033", "createdAt": "2020-11-09T17:49:31Z", "commit": {"oid": "8c49c1bc175c58bd62c857eb3863ddefbc552469"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzo0OTozMlrOHv6fmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxNzo0OTozMlrOHv6fmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDAwMzQ4Mg==", "bodyText": "Shouldn't be just INFO? Also, I think it might be better tho handle those InterruptedException inside ReplicationSource.terminate().", "url": "https://github.com/apache/hbase/pull/2546#discussion_r520003482", "createdAt": "2020-11-09T17:49:32Z", "author": {"login": "esteban"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceShipper.java", "diffHunk": "@@ -325,4 +327,53 @@ void stopWorker() {\n   public boolean isFinished() {\n     return state == WorkerState.FINISHED;\n   }\n+\n+  /**\n+   * Attempts to properly update <code>ReplicationSourceManager.totalBufferUser</code>,\n+   * in case there were unprocessed entries batched by the reader to the shipper,\n+   * but the shipper didn't manage to ship those because the replication source is being terminated.\n+   * In that case, it iterates through the batched entries and decrease the pending\n+   * entries size from <code>ReplicationSourceManager.totalBufferUser</code>\n+   * <p/>\n+   * <b>NOTES</b>\n+   * 1) This method should only be called upon replication source termination.\n+   * It blocks waiting for both shipper and reader threads termination,\n+   * to make sure no race conditions\n+   * when updating <code>ReplicationSourceManager.totalBufferUser</code>.\n+   *\n+   * 2) It <b>does not</b> attempt to terminate reader and shipper threads. Those <b>must</b>\n+   * have been triggered interruption/termination prior to calling this method.\n+   */\n+  void clearWALEntryBatch() {\n+    long timeout = System.currentTimeMillis() + this.shipEditsTimeout;\n+    while(this.isAlive() || this.entryReader.isAlive()){\n+      try {\n+        if (System.currentTimeMillis() >= timeout) {\n+          LOG.warn(\"Interrupting source thread for peer {} without cleaning buffer usage \"\n+            + \"because clearWALEntryBatch method timed out whilst waiting reader/shipper \"\n+            + \"thread to stop.\", this.source.getPeerId());\n+          Thread.currentThread().interrupt();\n+        } else {\n+          // Wait both shipper and reader threads to stop\n+          Thread.sleep(this.sleepForRetries);\n+        }\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"{} Interrupted while waiting {} to stop on clearWALEntryBatch: {}\",\n+          this.source.getPeerId(), this.getName(), e);\n+        Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c49c1bc175c58bd62c857eb3863ddefbc552469"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2OTA1MjM0", "url": "https://github.com/apache/hbase/pull/2546#pullrequestreview-526905234", "createdAt": "2020-11-10T06:58:24Z", "commit": {"oid": "af8166f4548a19cb29f405ff716905498680791d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwNjo1ODoyNFrOHwOj7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwOTowNzowOVrOHwSn_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDMzMjI2OA==", "bodyText": "If a worker is doing some async work when it is asked to stop and can take time. then I think we should keep the implementation as it was done before, like ask all to stop at once and then wait. because if no. of workers gets large due to backlog and someone changes wait time config to 10s of seconds, then removePeer command/procedure has to wait for a long time (no. of workers * (sleep time + time for clearWalEntryBatch) ) to terminate the replication source.", "url": "https://github.com/apache/hbase/pull/2546#discussion_r520332268", "createdAt": "2020-11-10T06:58:24Z", "author": {"login": "ankitsinghal"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -684,17 +684,17 @@ public void terminate(String reason, Exception cause, boolean clearMetrics,\n       Threads.shutdown(initThread, this.sleepForRetries);\n     }\n     Collection<ReplicationSourceShipper> workers = workerThreads.values();\n-    for (ReplicationSourceShipper worker : workers) {\n-      worker.stopWorker();\n-      if(worker.entryReader != null) {\n-        worker.entryReader.setReaderRunning(false);\n-      }\n-    }\n+\n \n     if (this.replicationEndpoint != null) {\n       this.replicationEndpoint.stop();\n     }\n+\n     for (ReplicationSourceShipper worker : workers) {\n+      worker.stopWorker();\n+      if (worker.entryReader != null) {\n+        worker.entryReader.setReaderRunning(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8166f4548a19cb29f405ff716905498680791d"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM2MDMxMQ==", "bodyText": "It is a best practice to avoid Collection.remove(object) while iterating, to be agnostic to collection's iterator implementation as some can throw ConcurrentModificationException in such a scenario, instead use Iterator.remove()", "url": "https://github.com/apache/hbase/pull/2546#discussion_r520360311", "createdAt": "2020-11-10T08:03:08Z", "author": {"login": "ankitsinghal"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceShipper.java", "diffHunk": "@@ -325,4 +327,53 @@ void stopWorker() {\n   public boolean isFinished() {\n     return state == WorkerState.FINISHED;\n   }\n+\n+  /**\n+   * Attempts to properly update <code>ReplicationSourceManager.totalBufferUser</code>,\n+   * in case there were unprocessed entries batched by the reader to the shipper,\n+   * but the shipper didn't manage to ship those because the replication source is being terminated.\n+   * In that case, it iterates through the batched entries and decrease the pending\n+   * entries size from <code>ReplicationSourceManager.totalBufferUser</code>\n+   * <p/>\n+   * <b>NOTES</b>\n+   * 1) This method should only be called upon replication source termination.\n+   * It blocks waiting for both shipper and reader threads termination,\n+   * to make sure no race conditions\n+   * when updating <code>ReplicationSourceManager.totalBufferUser</code>.\n+   *\n+   * 2) It <b>does not</b> attempt to terminate reader and shipper threads. Those <b>must</b>\n+   * have been triggered interruption/termination prior to calling this method.\n+   */\n+  void clearWALEntryBatch() {\n+    long timeout = System.currentTimeMillis() + this.shipEditsTimeout;\n+    while(this.isAlive() || this.entryReader.isAlive()){\n+      try {\n+        if (System.currentTimeMillis() >= timeout) {\n+          LOG.warn(\"Interrupting source thread for peer {} without cleaning buffer usage \"\n+            + \"because clearWALEntryBatch method timed out whilst waiting reader/shipper \"\n+            + \"thread to stop.\", this.source.getPeerId());\n+          Thread.currentThread().interrupt();\n+        } else {\n+          // Wait both shipper and reader threads to stop\n+          Thread.sleep(this.sleepForRetries);\n+        }\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"{} Interrupted while waiting {} to stop on clearWALEntryBatch: {}\",\n+          this.source.getPeerId(), this.getName(), e);\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+    LongAccumulator totalToDecrement = new LongAccumulator((a,b) -> a + b, 0);\n+    entryReader.entryBatchQueue.forEach(w -> {\n+      entryReader.entryBatchQueue.remove(w);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8166f4548a19cb29f405ff716905498680791d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM2MzEwOA==", "bodyText": "we may also need to update global metric (tracking memory used for these edits ) here\nlong   newBufferUsed = source.getSourceManager().getTotalBufferUsed().addAndGet(-totalToDecrement.longValue()); \nsource.getSourceManager().getGlobalMetrics().setWALReaderEditsBufferBytes(newBufferUsed);", "url": "https://github.com/apache/hbase/pull/2546#discussion_r520363108", "createdAt": "2020-11-10T08:08:36Z", "author": {"login": "ankitsinghal"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceShipper.java", "diffHunk": "@@ -325,4 +327,53 @@ void stopWorker() {\n   public boolean isFinished() {\n     return state == WorkerState.FINISHED;\n   }\n+\n+  /**\n+   * Attempts to properly update <code>ReplicationSourceManager.totalBufferUser</code>,\n+   * in case there were unprocessed entries batched by the reader to the shipper,\n+   * but the shipper didn't manage to ship those because the replication source is being terminated.\n+   * In that case, it iterates through the batched entries and decrease the pending\n+   * entries size from <code>ReplicationSourceManager.totalBufferUser</code>\n+   * <p/>\n+   * <b>NOTES</b>\n+   * 1) This method should only be called upon replication source termination.\n+   * It blocks waiting for both shipper and reader threads termination,\n+   * to make sure no race conditions\n+   * when updating <code>ReplicationSourceManager.totalBufferUser</code>.\n+   *\n+   * 2) It <b>does not</b> attempt to terminate reader and shipper threads. Those <b>must</b>\n+   * have been triggered interruption/termination prior to calling this method.\n+   */\n+  void clearWALEntryBatch() {\n+    long timeout = System.currentTimeMillis() + this.shipEditsTimeout;\n+    while(this.isAlive() || this.entryReader.isAlive()){\n+      try {\n+        if (System.currentTimeMillis() >= timeout) {\n+          LOG.warn(\"Interrupting source thread for peer {} without cleaning buffer usage \"\n+            + \"because clearWALEntryBatch method timed out whilst waiting reader/shipper \"\n+            + \"thread to stop.\", this.source.getPeerId());\n+          Thread.currentThread().interrupt();\n+        } else {\n+          // Wait both shipper and reader threads to stop\n+          Thread.sleep(this.sleepForRetries);\n+        }\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"{} Interrupted while waiting {} to stop on clearWALEntryBatch: {}\",\n+          this.source.getPeerId(), this.getName(), e);\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+    LongAccumulator totalToDecrement = new LongAccumulator((a,b) -> a + b, 0);\n+    entryReader.entryBatchQueue.forEach(w -> {\n+      entryReader.entryBatchQueue.remove(w);\n+      w.getWalEntries().forEach(e -> {\n+        long entrySizeExcludeBulkLoad = entryReader.getEntrySizeExcludeBulkLoad(e);\n+        totalToDecrement.accumulate(entrySizeExcludeBulkLoad);\n+      });\n+    });\n+\n+    LOG.trace(\"Decrementing totalBufferUsed by {}B while stopping Replication WAL Readers.\",\n+      totalToDecrement.longValue());\n+    source.getSourceManager().getTotalBufferUsed().addAndGet(-totalToDecrement.longValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8166f4548a19cb29f405ff716905498680791d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM4NzMzNQ==", "bodyText": "nit: refer Static Method using classname, ReplicationSourceWALReader. getEntrySizeExcludeBulkLoad()", "url": "https://github.com/apache/hbase/pull/2546#discussion_r520387335", "createdAt": "2020-11-10T08:48:53Z", "author": {"login": "ankitsinghal"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceShipper.java", "diffHunk": "@@ -325,4 +327,53 @@ void stopWorker() {\n   public boolean isFinished() {\n     return state == WorkerState.FINISHED;\n   }\n+\n+  /**\n+   * Attempts to properly update <code>ReplicationSourceManager.totalBufferUser</code>,\n+   * in case there were unprocessed entries batched by the reader to the shipper,\n+   * but the shipper didn't manage to ship those because the replication source is being terminated.\n+   * In that case, it iterates through the batched entries and decrease the pending\n+   * entries size from <code>ReplicationSourceManager.totalBufferUser</code>\n+   * <p/>\n+   * <b>NOTES</b>\n+   * 1) This method should only be called upon replication source termination.\n+   * It blocks waiting for both shipper and reader threads termination,\n+   * to make sure no race conditions\n+   * when updating <code>ReplicationSourceManager.totalBufferUser</code>.\n+   *\n+   * 2) It <b>does not</b> attempt to terminate reader and shipper threads. Those <b>must</b>\n+   * have been triggered interruption/termination prior to calling this method.\n+   */\n+  void clearWALEntryBatch() {\n+    long timeout = System.currentTimeMillis() + this.shipEditsTimeout;\n+    while(this.isAlive() || this.entryReader.isAlive()){\n+      try {\n+        if (System.currentTimeMillis() >= timeout) {\n+          LOG.warn(\"Interrupting source thread for peer {} without cleaning buffer usage \"\n+            + \"because clearWALEntryBatch method timed out whilst waiting reader/shipper \"\n+            + \"thread to stop.\", this.source.getPeerId());\n+          Thread.currentThread().interrupt();\n+        } else {\n+          // Wait both shipper and reader threads to stop\n+          Thread.sleep(this.sleepForRetries);\n+        }\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"{} Interrupted while waiting {} to stop on clearWALEntryBatch: {}\",\n+          this.source.getPeerId(), this.getName(), e);\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+    LongAccumulator totalToDecrement = new LongAccumulator((a,b) -> a + b, 0);\n+    entryReader.entryBatchQueue.forEach(w -> {\n+      entryReader.entryBatchQueue.remove(w);\n+      w.getWalEntries().forEach(e -> {\n+        long entrySizeExcludeBulkLoad = entryReader.getEntrySizeExcludeBulkLoad(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8166f4548a19cb29f405ff716905498680791d"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDM5ODg0NQ==", "bodyText": "why do we need additional interrupt here when ReplicationSource.terminate() is already interrupted the worker thread prior to clearWALEntryBatch method call?", "url": "https://github.com/apache/hbase/pull/2546#discussion_r520398845", "createdAt": "2020-11-10T09:07:09Z", "author": {"login": "ankitsinghal"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceShipper.java", "diffHunk": "@@ -325,4 +327,53 @@ void stopWorker() {\n   public boolean isFinished() {\n     return state == WorkerState.FINISHED;\n   }\n+\n+  /**\n+   * Attempts to properly update <code>ReplicationSourceManager.totalBufferUser</code>,\n+   * in case there were unprocessed entries batched by the reader to the shipper,\n+   * but the shipper didn't manage to ship those because the replication source is being terminated.\n+   * In that case, it iterates through the batched entries and decrease the pending\n+   * entries size from <code>ReplicationSourceManager.totalBufferUser</code>\n+   * <p/>\n+   * <b>NOTES</b>\n+   * 1) This method should only be called upon replication source termination.\n+   * It blocks waiting for both shipper and reader threads termination,\n+   * to make sure no race conditions\n+   * when updating <code>ReplicationSourceManager.totalBufferUser</code>.\n+   *\n+   * 2) It <b>does not</b> attempt to terminate reader and shipper threads. Those <b>must</b>\n+   * have been triggered interruption/termination prior to calling this method.\n+   */\n+  void clearWALEntryBatch() {\n+    long timeout = System.currentTimeMillis() + this.shipEditsTimeout;\n+    while(this.isAlive() || this.entryReader.isAlive()){\n+      try {\n+        if (System.currentTimeMillis() >= timeout) {\n+          LOG.warn(\"Interrupting source thread for peer {} without cleaning buffer usage \"\n+            + \"because clearWALEntryBatch method timed out whilst waiting reader/shipper \"\n+            + \"thread to stop.\", this.source.getPeerId());\n+          Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af8166f4548a19cb29f405ff716905498680791d"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9dafe5f3f3c9261eea0d242b0c7c8c7d5016909f", "author": {"user": {"login": "wchevreuil", "name": "Wellington Ramos Chevreuil"}}, "url": "https://github.com/apache/hbase/commit/9dafe5f3f3c9261eea0d242b0c7c8c7d5016909f", "committedDate": "2020-11-10T19:07:12Z", "message": "adding latest review suggestions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e5c77b4e70c08b012d010ea4207dd9399a95deb", "author": {"user": {"login": "wchevreuil", "name": "Wellington Ramos Chevreuil"}}, "url": "https://github.com/apache/hbase/commit/8e5c77b4e70c08b012d010ea4207dd9399a95deb", "committedDate": "2020-11-11T18:23:58Z", "message": "Addressing addtional suggestions and fixing UT errors."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI4NjgyMjUw", "url": "https://github.com/apache/hbase/pull/2546#pullrequestreview-528682250", "createdAt": "2020-11-12T02:04:44Z", "commit": {"oid": "8e5c77b4e70c08b012d010ea4207dd9399a95deb"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwMjowNDo0NFrOHxmYCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQwMjowNDo0NFrOHxmYCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc3MTAxNw==", "bodyText": "please restore interrupt flag here (Thread.currentThread().interrupt();) and then return.", "url": "https://github.com/apache/hbase/pull/2546#discussion_r521771017", "createdAt": "2020-11-12T02:04:44Z", "author": {"login": "ankitsinghal"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceShipper.java", "diffHunk": "@@ -325,4 +327,56 @@ void stopWorker() {\n   public boolean isFinished() {\n     return state == WorkerState.FINISHED;\n   }\n+\n+  /**\n+   * Attempts to properly update <code>ReplicationSourceManager.totalBufferUser</code>,\n+   * in case there were unprocessed entries batched by the reader to the shipper,\n+   * but the shipper didn't manage to ship those because the replication source is being terminated.\n+   * In that case, it iterates through the batched entries and decrease the pending\n+   * entries size from <code>ReplicationSourceManager.totalBufferUser</code>\n+   * <p/>\n+   * <b>NOTES</b>\n+   * 1) This method should only be called upon replication source termination.\n+   * It blocks waiting for both shipper and reader threads termination,\n+   * to make sure no race conditions\n+   * when updating <code>ReplicationSourceManager.totalBufferUser</code>.\n+   *\n+   * 2) It <b>does not</b> attempt to terminate reader and shipper threads. Those <b>must</b>\n+   * have been triggered interruption/termination prior to calling this method.\n+   */\n+  void clearWALEntryBatch() {\n+    long timeout = System.currentTimeMillis() + this.shipEditsTimeout;\n+    while(this.isAlive() || this.entryReader.isAlive()){\n+      try {\n+        if (System.currentTimeMillis() >= timeout) {\n+          LOG.warn(\"Shipper clearWALEntryBatch method timed out whilst waiting reader/shipper \"\n+            + \"thread to stop. Not cleaning buffer usage. Shipper alive: {}; Reader alive: {}\",\n+            this.source.getPeerId(), this.isAlive(), this.entryReader.isAlive());\n+          return;\n+        } else {\n+          // Wait both shipper and reader threads to stop\n+          Thread.sleep(this.sleepForRetries);\n+        }\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"{} Interrupted while waiting {} to stop on clearWALEntryBatch. \"\n+            + \"Not cleaning buffer usage: {}\", this.source.getPeerId(), this.getName(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e5c77b4e70c08b012d010ea4207dd9399a95deb"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4382, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}