{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4NzM3NTky", "number": 2582, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo1NDo0M1rOE0qqWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzowOToyNVrOE6IAyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjYwMzc3OnYy", "diffSide": "RIGHT", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/SizeCachedKeyValue.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo1NDo0M1rOHshAVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQwNzozNTozM1rOHviDAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MDE0OA==", "bodyText": "Just call this() the next constructor", "url": "https://github.com/apache/hbase/pull/2582#discussion_r516440148", "createdAt": "2020-11-03T05:54:43Z", "author": {"login": "anoopsjohn"}, "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/SizeCachedKeyValue.java", "diffHunk": "@@ -39,12 +39,22 @@\n   private short rowLen;\n   private int keyLen;\n \n-  public SizeCachedKeyValue(byte[] bytes, int offset, int length, long seqId) {\n+  public SizeCachedKeyValue(byte[] bytes, int offset, int length, long seqId, int keyLen) {\n     super(bytes, offset, length);\n     // We will read all these cached values at least once. Initialize now itself so that we can\n     // avoid uninitialized checks with every time call\n-    rowLen = super.getRowLength();\n-    keyLen = super.getKeyLength();\n+    this.rowLen = super.getRowLength();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzkxOTY0Ng==", "bodyText": "I tried this actually but from the this() constructor calling the super.getRowLength is not allowed. Hence I went with this simple way.", "url": "https://github.com/apache/hbase/pull/2582#discussion_r517919646", "createdAt": "2020-11-05T09:48:27Z", "author": {"login": "ramkrish86"}, "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/SizeCachedKeyValue.java", "diffHunk": "@@ -39,12 +39,22 @@\n   private short rowLen;\n   private int keyLen;\n \n-  public SizeCachedKeyValue(byte[] bytes, int offset, int length, long seqId) {\n+  public SizeCachedKeyValue(byte[] bytes, int offset, int length, long seqId, int keyLen) {\n     super(bytes, offset, length);\n     // We will read all these cached values at least once. Initialize now itself so that we can\n     // avoid uninitialized checks with every time call\n-    rowLen = super.getRowLength();\n-    keyLen = super.getKeyLength();\n+    this.rowLen = super.getRowLength();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MDE0OA=="}, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYwMjk0Nw==", "bodyText": "ok", "url": "https://github.com/apache/hbase/pull/2582#discussion_r519602947", "createdAt": "2020-11-09T07:35:33Z", "author": {"login": "anoopsjohn"}, "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/SizeCachedKeyValue.java", "diffHunk": "@@ -39,12 +39,22 @@\n   private short rowLen;\n   private int keyLen;\n \n-  public SizeCachedKeyValue(byte[] bytes, int offset, int length, long seqId) {\n+  public SizeCachedKeyValue(byte[] bytes, int offset, int length, long seqId, int keyLen) {\n     super(bytes, offset, length);\n     // We will read all these cached values at least once. Initialize now itself so that we can\n     // avoid uninitialized checks with every time call\n-    rowLen = super.getRowLength();\n-    keyLen = super.getKeyLength();\n+    this.rowLen = super.getRowLength();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MDE0OA=="}, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjYwOTA2OnYy", "diffSide": "RIGHT", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/SizeCachedNoTagsByteBufferKeyValue.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo1Nzo1NlrOHshDKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo1Nzo1NlrOHshDKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MDg3Mg==", "bodyText": "nit: many empty rows.", "url": "https://github.com/apache/hbase/pull/2582#discussion_r516440872", "createdAt": "2020-11-03T05:57:56Z", "author": {"login": "anoopsjohn"}, "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/SizeCachedNoTagsByteBufferKeyValue.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * This Cell is an implementation of {@link ByteBufferExtendedCell} where the data resides in\n+ * off heap/ on heap ByteBuffer\n+ */\n+@InterfaceAudience.Private\n+public class SizeCachedNoTagsByteBufferKeyValue extends NoTagsByteBufferKeyValue {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjYxMDMxOnYy", "diffSide": "RIGHT", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/SizeCachedNoTagsByteBufferKeyValue.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo1ODo0NlrOHshD3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo1ODo0NlrOHshD3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MTA1NQ==", "bodyText": "Call next constructor this()", "url": "https://github.com/apache/hbase/pull/2582#discussion_r516441055", "createdAt": "2020-11-03T05:58:46Z", "author": {"login": "anoopsjohn"}, "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/SizeCachedNoTagsByteBufferKeyValue.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * This Cell is an implementation of {@link ByteBufferExtendedCell} where the data resides in\n+ * off heap/ on heap ByteBuffer\n+ */\n+@InterfaceAudience.Private\n+public class SizeCachedNoTagsByteBufferKeyValue extends NoTagsByteBufferKeyValue {\n+\n+\n+  private short rowLen;\n+  private int keyLen;\n+\n+  public static final int FIXED_OVERHEAD = Bytes.SIZEOF_SHORT + Bytes.SIZEOF_INT;\n+\n+  public SizeCachedNoTagsByteBufferKeyValue(ByteBuffer buf, int offset, int length, long seqId,\n+      int keyLen) {\n+    super(buf, offset, length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjYxMTU3OnYy", "diffSide": "RIGHT", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/SizeCachedByteBufferKeyValue.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo1OTozMVrOHshEiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNTo1OTozMVrOHshEiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MTIyNw==", "bodyText": "call next this() constructor", "url": "https://github.com/apache/hbase/pull/2582#discussion_r516441227", "createdAt": "2020-11-03T05:59:31Z", "author": {"login": "anoopsjohn"}, "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/SizeCachedByteBufferKeyValue.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * This Cell is an implementation of {@link ByteBufferExtendedCell} where the data resides in\n+ * off heap/ on heap ByteBuffer\n+ */\n+@InterfaceAudience.Private\n+public class SizeCachedByteBufferKeyValue extends ByteBufferKeyValue {\n+\n+  private short rowLen;\n+  private int keyLen;\n+\n+  public static final int FIXED_OVERHEAD = Bytes.SIZEOF_SHORT + Bytes.SIZEOF_INT;\n+\n+  public SizeCachedByteBufferKeyValue(ByteBuffer buf, int offset, int length, long seqId, int keyLen) {\n+    super(buf, offset, length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjYxMzAwOnYy", "diffSide": "RIGHT", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/SizeCachedByteBufferKeyValue.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNjowMDoxM1rOHshFSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNjowMDoxM1rOHshFSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ0MTQxOA==", "bodyText": "nit : Better we keep static fields above the instance members. Check for all new classes", "url": "https://github.com/apache/hbase/pull/2582#discussion_r516441418", "createdAt": "2020-11-03T06:00:13Z", "author": {"login": "anoopsjohn"}, "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/SizeCachedByteBufferKeyValue.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * This Cell is an implementation of {@link ByteBufferExtendedCell} where the data resides in\n+ * off heap/ on heap ByteBuffer\n+ */\n+@InterfaceAudience.Private\n+public class SizeCachedByteBufferKeyValue extends ByteBufferKeyValue {\n+\n+  private short rowLen;\n+  private int keyLen;\n+\n+  public static final int FIXED_OVERHEAD = Bytes.SIZEOF_SHORT + Bytes.SIZEOF_INT;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjgxNDEyOnYy", "diffSide": "RIGHT", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/RowIndexSeekerV1.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNzo0MDo1N1rOHsi2WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNzo0MDo1N1rOHsi2WA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3MDM2MA==", "bodyText": "Its ok not to get here but leave that to be decoded within SizeCachedKeyValue.  So we can remove this TODO  IMO", "url": "https://github.com/apache/hbase/pull/2582#discussion_r516470360", "createdAt": "2020-11-03T07:40:57Z", "author": {"login": "anoopsjohn"}, "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/io/encoding/RowIndexSeekerV1.java", "diffHunk": "@@ -359,26 +361,30 @@ public Cell toCell() {\n         // TODO : reduce the varieties of KV here. Check if based on a boolean\n         // we can handle the 'no tags' case.\n         if (tagsLength > 0) {\n+          // TODO : getRow len here.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjgyMDgzOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNzo0MzozMlrOHsi6Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMDozODo1MVrOHvojxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3MTM0Mw==", "bodyText": "Whats the adv of decode rowLen here than in setKey()?  If the rowLen was already decoded for some other reason ya make sense to pass it than recalc later. But here am not fully sure", "url": "https://github.com/apache/hbase/pull/2582#discussion_r516471343", "createdAt": "2020-11-03T07:43:32Z", "author": {"login": "anoopsjohn"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java", "diffHunk": "@@ -554,8 +559,10 @@ protected int blockSeek(Cell key, boolean seekBefore) {\n               + \" path=\" + reader.getPath());\n         }\n         offsetFromPos += Bytes.SIZEOF_LONG;\n+        rowLen = ((blockBuffer.getByteAfterPosition(offsetFromPos) & 0xff) << 8)\n+            ^ (blockBuffer.getByteAfterPosition(offsetFromPos + 1) & 0xff);\n         blockBuffer.asSubByteBuffer(blockBuffer.position() + offsetFromPos, klen, pair);\n-        bufBackedKeyOnlyKv.setKey(pair.getFirst(), pair.getSecond(), klen);\n+        bufBackedKeyOnlyKv.setKey(pair.getFirst(), pair.getSecond(), klen, (short)rowLen);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzkzNTI3NA==", "bodyText": "IMO the rowLen is anyway getting decoded in the setKey method. And the same we can reuse and have it for rowLen. So I think it is better to have it decoded earlier. Because that rowLen decoding is happening per cell.", "url": "https://github.com/apache/hbase/pull/2582#discussion_r517935274", "createdAt": "2020-11-05T10:12:33Z", "author": {"login": "ramkrish86"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java", "diffHunk": "@@ -554,8 +559,10 @@ protected int blockSeek(Cell key, boolean seekBefore) {\n               + \" path=\" + reader.getPath());\n         }\n         offsetFromPos += Bytes.SIZEOF_LONG;\n+        rowLen = ((blockBuffer.getByteAfterPosition(offsetFromPos) & 0xff) << 8)\n+            ^ (blockBuffer.getByteAfterPosition(offsetFromPos + 1) & 0xff);\n         blockBuffer.asSubByteBuffer(blockBuffer.position() + offsetFromPos, klen, pair);\n-        bufBackedKeyOnlyKv.setKey(pair.getFirst(), pair.getSecond(), klen);\n+        bufBackedKeyOnlyKv.setKey(pair.getFirst(), pair.getSecond(), klen, (short)rowLen);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3MTM0Mw=="}, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTYwMjExNg==", "bodyText": "I see how the usage is helpful.  While seek to a key within the seek while loop, we decode and keep the state of rowLen. Once seek is done and called getCell() there we dont have to decode again but reuse the saved state. make sense.  Though I have a comment.\nUse BB#getShortAfterPosition() instead of having extra logic here.  that will be even perf wise better both in MBB and SBB", "url": "https://github.com/apache/hbase/pull/2582#discussion_r519602116", "createdAt": "2020-11-09T07:33:22Z", "author": {"login": "anoopsjohn"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java", "diffHunk": "@@ -554,8 +559,10 @@ protected int blockSeek(Cell key, boolean seekBefore) {\n               + \" path=\" + reader.getPath());\n         }\n         offsetFromPos += Bytes.SIZEOF_LONG;\n+        rowLen = ((blockBuffer.getByteAfterPosition(offsetFromPos) & 0xff) << 8)\n+            ^ (blockBuffer.getByteAfterPosition(offsetFromPos + 1) & 0xff);\n         blockBuffer.asSubByteBuffer(blockBuffer.position() + offsetFromPos, klen, pair);\n-        bufBackedKeyOnlyKv.setKey(pair.getFirst(), pair.getSecond(), klen);\n+        bufBackedKeyOnlyKv.setKey(pair.getFirst(), pair.getSecond(), klen, (short)rowLen);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3MTM0Mw=="}, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTcwOTYzNw==", "bodyText": "Use BB#getShortAfterPosition() instead of having extra logic here. that will be even perf wise better both in MBB and SBB\nYou mean instead of getByteAfterPosition getting called 2 times just use getShortAfterPosition()?", "url": "https://github.com/apache/hbase/pull/2582#discussion_r519709637", "createdAt": "2020-11-09T10:38:51Z", "author": {"login": "ramkrish86"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java", "diffHunk": "@@ -554,8 +559,10 @@ protected int blockSeek(Cell key, boolean seekBefore) {\n               + \" path=\" + reader.getPath());\n         }\n         offsetFromPos += Bytes.SIZEOF_LONG;\n+        rowLen = ((blockBuffer.getByteAfterPosition(offsetFromPos) & 0xff) << 8)\n+            ^ (blockBuffer.getByteAfterPosition(offsetFromPos + 1) & 0xff);\n         blockBuffer.asSubByteBuffer(blockBuffer.position() + offsetFromPos, klen, pair);\n-        bufBackedKeyOnlyKv.setKey(pair.getFirst(), pair.getSecond(), klen);\n+        bufBackedKeyOnlyKv.setKey(pair.getFirst(), pair.getSecond(), klen, (short)rowLen);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3MTM0Mw=="}, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjgyMzUwOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwNzo0NDozNVrOHsi70Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQwNjozNzowOVrOHuhxDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3MTc2MQ==", "bodyText": "Ya here also as currKeyLen is already calculated we can pass.. But let rowLen be decoded within SizeCachedKeyValue only.  We can avoid all these changes", "url": "https://github.com/apache/hbase/pull/2582#discussion_r516471761", "createdAt": "2020-11-03T07:44:35Z", "author": {"login": "anoopsjohn"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java", "diffHunk": "@@ -790,23 +797,28 @@ public Cell getCell() {\n         // we can handle the 'no tags' case.\n         if (currTagsLen > 0) {\n           ret = new SizeCachedKeyValue(blockBuffer.array(),\n-              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId);\n+              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId, currKeyLen,\n+              rowLen);\n         } else {\n           ret = new SizeCachedNoTagsKeyValue(blockBuffer.array(),\n-              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId);\n+              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId, currKeyLen,\n+              rowLen);\n         }\n       } else {\n         ByteBuffer buf = blockBuffer.asSubByteBuffer(cellBufSize);\n         if (buf.isDirect()) {\n-          ret = currTagsLen > 0 ? new ByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId)\n-              : new NoTagsByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId);\n+          ret = currTagsLen > 0\n+              ? new SizeCachedByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId,\n+                  currKeyLen, rowLen)\n+              : new SizeCachedNoTagsByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId,\n+                  currKeyLen, rowLen);\n         } else {\n           if (currTagsLen > 0) {\n             ret = new SizeCachedKeyValue(buf.array(), buf.arrayOffset() + buf.position(),\n-                cellBufSize, seqId);\n+                cellBufSize, seqId, currKeyLen, rowLen);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODAzNjY4Mw==", "bodyText": "Here too the rowLen is already there. Any specific reason you feel this need not be decoded.", "url": "https://github.com/apache/hbase/pull/2582#discussion_r518036683", "createdAt": "2020-11-05T13:08:04Z", "author": {"login": "ramkrish86"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java", "diffHunk": "@@ -790,23 +797,28 @@ public Cell getCell() {\n         // we can handle the 'no tags' case.\n         if (currTagsLen > 0) {\n           ret = new SizeCachedKeyValue(blockBuffer.array(),\n-              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId);\n+              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId, currKeyLen,\n+              rowLen);\n         } else {\n           ret = new SizeCachedNoTagsKeyValue(blockBuffer.array(),\n-              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId);\n+              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId, currKeyLen,\n+              rowLen);\n         }\n       } else {\n         ByteBuffer buf = blockBuffer.asSubByteBuffer(cellBufSize);\n         if (buf.isDirect()) {\n-          ret = currTagsLen > 0 ? new ByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId)\n-              : new NoTagsByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId);\n+          ret = currTagsLen > 0\n+              ? new SizeCachedByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId,\n+                  currKeyLen, rowLen)\n+              : new SizeCachedNoTagsByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId,\n+                  currKeyLen, rowLen);\n         } else {\n           if (currTagsLen > 0) {\n             ret = new SizeCachedKeyValue(buf.array(), buf.arrayOffset() + buf.position(),\n-                cellBufSize, seqId);\n+                cellBufSize, seqId, currKeyLen, rowLen);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3MTc2MQ=="}, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU0MDE1NQ==", "bodyText": "Any advantage we get because of doing here?  Because in one place, while constructing this KV objects, we decode the value and set as a state var and pass in constructor.  For keyLen, ya we already decoded there (before this patch) we pass that for reuse.  But for rowLen its not that way na..  So why to change the critical part of HFile reader adding new byte[] state? Better avoid.", "url": "https://github.com/apache/hbase/pull/2582#discussion_r518540155", "createdAt": "2020-11-06T06:02:21Z", "author": {"login": "anoopsjohn"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java", "diffHunk": "@@ -790,23 +797,28 @@ public Cell getCell() {\n         // we can handle the 'no tags' case.\n         if (currTagsLen > 0) {\n           ret = new SizeCachedKeyValue(blockBuffer.array(),\n-              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId);\n+              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId, currKeyLen,\n+              rowLen);\n         } else {\n           ret = new SizeCachedNoTagsKeyValue(blockBuffer.array(),\n-              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId);\n+              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId, currKeyLen,\n+              rowLen);\n         }\n       } else {\n         ByteBuffer buf = blockBuffer.asSubByteBuffer(cellBufSize);\n         if (buf.isDirect()) {\n-          ret = currTagsLen > 0 ? new ByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId)\n-              : new NoTagsByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId);\n+          ret = currTagsLen > 0\n+              ? new SizeCachedByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId,\n+                  currKeyLen, rowLen)\n+              : new SizeCachedNoTagsByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId,\n+                  currKeyLen, rowLen);\n         } else {\n           if (currTagsLen > 0) {\n             ret = new SizeCachedKeyValue(buf.array(), buf.arrayOffset() + buf.position(),\n-                cellBufSize, seqId);\n+                cellBufSize, seqId, currKeyLen, rowLen);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3MTc2MQ=="}, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU0NjQyNg==", "bodyText": "If you see my previous commit - I got the rowLen also in blockSeek and the readKeyValue() method to pass it to the SizeCachedKV variants. That was mainly just to ensure that we get rowLen while doing the KV parsing itself rather than KV creation. Now in the last commit since I was already doing that rowLen related change I changed the BBKV also so that we don't need to parse it there.", "url": "https://github.com/apache/hbase/pull/2582#discussion_r518546426", "createdAt": "2020-11-06T06:24:48Z", "author": {"login": "ramkrish86"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java", "diffHunk": "@@ -790,23 +797,28 @@ public Cell getCell() {\n         // we can handle the 'no tags' case.\n         if (currTagsLen > 0) {\n           ret = new SizeCachedKeyValue(blockBuffer.array(),\n-              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId);\n+              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId, currKeyLen,\n+              rowLen);\n         } else {\n           ret = new SizeCachedNoTagsKeyValue(blockBuffer.array(),\n-              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId);\n+              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId, currKeyLen,\n+              rowLen);\n         }\n       } else {\n         ByteBuffer buf = blockBuffer.asSubByteBuffer(cellBufSize);\n         if (buf.isDirect()) {\n-          ret = currTagsLen > 0 ? new ByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId)\n-              : new NoTagsByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId);\n+          ret = currTagsLen > 0\n+              ? new SizeCachedByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId,\n+                  currKeyLen, rowLen)\n+              : new SizeCachedNoTagsByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId,\n+                  currKeyLen, rowLen);\n         } else {\n           if (currTagsLen > 0) {\n             ret = new SizeCachedKeyValue(buf.array(), buf.arrayOffset() + buf.position(),\n-                cellBufSize, seqId);\n+                cellBufSize, seqId, currKeyLen, rowLen);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3MTc2MQ=="}, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU0NjYwMg==", "bodyText": "So why to change the critical part of HFile reader adding new byte[] state\n\n\nSorry. When you mean byte[] state - are you saying we are adding a new byte[] as state variable?", "url": "https://github.com/apache/hbase/pull/2582#discussion_r518546602", "createdAt": "2020-11-06T06:25:22Z", "author": {"login": "ramkrish86"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java", "diffHunk": "@@ -790,23 +797,28 @@ public Cell getCell() {\n         // we can handle the 'no tags' case.\n         if (currTagsLen > 0) {\n           ret = new SizeCachedKeyValue(blockBuffer.array(),\n-              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId);\n+              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId, currKeyLen,\n+              rowLen);\n         } else {\n           ret = new SizeCachedNoTagsKeyValue(blockBuffer.array(),\n-              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId);\n+              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId, currKeyLen,\n+              rowLen);\n         }\n       } else {\n         ByteBuffer buf = blockBuffer.asSubByteBuffer(cellBufSize);\n         if (buf.isDirect()) {\n-          ret = currTagsLen > 0 ? new ByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId)\n-              : new NoTagsByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId);\n+          ret = currTagsLen > 0\n+              ? new SizeCachedByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId,\n+                  currKeyLen, rowLen)\n+              : new SizeCachedNoTagsByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId,\n+                  currKeyLen, rowLen);\n         } else {\n           if (currTagsLen > 0) {\n             ret = new SizeCachedKeyValue(buf.array(), buf.arrayOffset() + buf.position(),\n-                cellBufSize, seqId);\n+                cellBufSize, seqId, currKeyLen, rowLen);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3MTc2MQ=="}, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU0OTc3NA==", "bodyText": "Sorry not rowKey... Ya new rowLen state. My bad.  What is the real adv of this rowLen decoding happening at the Reader class?(and set to a state var)", "url": "https://github.com/apache/hbase/pull/2582#discussion_r518549774", "createdAt": "2020-11-06T06:37:09Z", "author": {"login": "anoopsjohn"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileReaderImpl.java", "diffHunk": "@@ -790,23 +797,28 @@ public Cell getCell() {\n         // we can handle the 'no tags' case.\n         if (currTagsLen > 0) {\n           ret = new SizeCachedKeyValue(blockBuffer.array(),\n-              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId);\n+              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId, currKeyLen,\n+              rowLen);\n         } else {\n           ret = new SizeCachedNoTagsKeyValue(blockBuffer.array(),\n-              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId);\n+              blockBuffer.arrayOffset() + blockBuffer.position(), cellBufSize, seqId, currKeyLen,\n+              rowLen);\n         }\n       } else {\n         ByteBuffer buf = blockBuffer.asSubByteBuffer(cellBufSize);\n         if (buf.isDirect()) {\n-          ret = currTagsLen > 0 ? new ByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId)\n-              : new NoTagsByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId);\n+          ret = currTagsLen > 0\n+              ? new SizeCachedByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId,\n+                  currKeyLen, rowLen)\n+              : new SizeCachedNoTagsByteBufferKeyValue(buf, buf.position(), cellBufSize, seqId,\n+                  currKeyLen, rowLen);\n         } else {\n           if (currTagsLen > 0) {\n             ret = new SizeCachedKeyValue(buf.array(), buf.arrayOffset() + buf.position(),\n-                cellBufSize, seqId);\n+                cellBufSize, seqId, currKeyLen, rowLen);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3MTc2MQ=="}, "originalCommit": {"oid": "e8d2002e0d78fbf8239a660624ca97cdc67fbf24"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5Mzg0MTM5OnYy", "diffSide": "RIGHT", "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/SizeCachedByteBufferKeyValue.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzowOToyNVrOH0_6Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNzozMTowMVrOH4vMyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNTEwNg==", "bodyText": "double-checking -- no need to consider the instance variables for equals and hashCode ?", "url": "https://github.com/apache/hbase/pull/2582#discussion_r525335106", "createdAt": "2020-11-17T17:09:25Z", "author": {"login": "ndimiduk"}, "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/SizeCachedByteBufferKeyValue.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * This Cell is an implementation of {@link ByteBufferExtendedCell} where the data resides in\n+ * off heap/ on heap ByteBuffer\n+ */\n+@InterfaceAudience.Private\n+public class SizeCachedByteBufferKeyValue extends ByteBufferKeyValue {\n+\n+  public static final int FIXED_OVERHEAD = Bytes.SIZEOF_SHORT + Bytes.SIZEOF_INT;\n+  private short rowLen;\n+  private int keyLen;\n+\n+  public SizeCachedByteBufferKeyValue(ByteBuffer buf, int offset, int length, long seqId,\n+      int keyLen) {\n+    super(buf, offset, length);\n+    // We will read all these cached values at least once. Initialize now itself so that we can\n+    // avoid uninitialized checks with every time call\n+    this.rowLen = super.getRowLength();\n+    this.keyLen = keyLen;\n+    setSequenceId(seqId);\n+  }\n+\n+  public SizeCachedByteBufferKeyValue(ByteBuffer buf, int offset, int length, long seqId,\n+      int keyLen, short rowLen) {\n+    super(buf, offset, length);\n+    // We will read all these cached values at least once. Initialize now itself so that we can\n+    // avoid uninitialized checks with every time call\n+    this.rowLen = rowLen;\n+    this.keyLen = keyLen;\n+    setSequenceId(seqId);\n+  }\n+\n+  @Override\n+  public short getRowLength() {\n+    return rowLen;\n+  }\n+\n+  @Override\n+  public int getKeyLength() {\n+    return this.keyLen;\n+  }\n+\n+  @Override\n+  public long heapSize() {\n+    return super.heapSize() + FIXED_OVERHEAD;\n+  }\n+\n+  /**\n+   * Override by just returning the length for saving cost of method dispatching. If not, it will\n+   * call {@link ExtendedCell#getSerializedSize()} firstly, then forward to\n+   * {@link SizeCachedKeyValue#getSerializedSize(boolean)}. (See HBASE-21657)\n+   */\n+  @Override\n+  public int getSerializedSize() {\n+    return this.length;\n+  }\n+\n+  @Override\n+  public boolean equals(Object other) {\n+    return super.equals(other);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26c192114be33828a4fa9042a7cb5a9f2df957cf"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI1NTYyNw==", "bodyText": "Actually not needed it is basically for the spot bugs report we had to add that.", "url": "https://github.com/apache/hbase/pull/2582#discussion_r529255627", "createdAt": "2020-11-24T07:31:01Z", "author": {"login": "ramkrish86"}, "path": "hbase-common/src/main/java/org/apache/hadoop/hbase/SizeCachedByteBufferKeyValue.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase;\n+\n+import java.nio.ByteBuffer;\n+\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * This Cell is an implementation of {@link ByteBufferExtendedCell} where the data resides in\n+ * off heap/ on heap ByteBuffer\n+ */\n+@InterfaceAudience.Private\n+public class SizeCachedByteBufferKeyValue extends ByteBufferKeyValue {\n+\n+  public static final int FIXED_OVERHEAD = Bytes.SIZEOF_SHORT + Bytes.SIZEOF_INT;\n+  private short rowLen;\n+  private int keyLen;\n+\n+  public SizeCachedByteBufferKeyValue(ByteBuffer buf, int offset, int length, long seqId,\n+      int keyLen) {\n+    super(buf, offset, length);\n+    // We will read all these cached values at least once. Initialize now itself so that we can\n+    // avoid uninitialized checks with every time call\n+    this.rowLen = super.getRowLength();\n+    this.keyLen = keyLen;\n+    setSequenceId(seqId);\n+  }\n+\n+  public SizeCachedByteBufferKeyValue(ByteBuffer buf, int offset, int length, long seqId,\n+      int keyLen, short rowLen) {\n+    super(buf, offset, length);\n+    // We will read all these cached values at least once. Initialize now itself so that we can\n+    // avoid uninitialized checks with every time call\n+    this.rowLen = rowLen;\n+    this.keyLen = keyLen;\n+    setSequenceId(seqId);\n+  }\n+\n+  @Override\n+  public short getRowLength() {\n+    return rowLen;\n+  }\n+\n+  @Override\n+  public int getKeyLength() {\n+    return this.keyLen;\n+  }\n+\n+  @Override\n+  public long heapSize() {\n+    return super.heapSize() + FIXED_OVERHEAD;\n+  }\n+\n+  /**\n+   * Override by just returning the length for saving cost of method dispatching. If not, it will\n+   * call {@link ExtendedCell#getSerializedSize()} firstly, then forward to\n+   * {@link SizeCachedKeyValue#getSerializedSize(boolean)}. (See HBASE-21657)\n+   */\n+  @Override\n+  public int getSerializedSize() {\n+    return this.length;\n+  }\n+\n+  @Override\n+  public boolean equals(Object other) {\n+    return super.equals(other);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTMzNTEwNg=="}, "originalCommit": {"oid": "26c192114be33828a4fa9042a7cb5a9f2df957cf"}, "originalPosition": 83}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2465, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}