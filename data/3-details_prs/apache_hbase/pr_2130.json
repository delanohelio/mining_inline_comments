{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1OTIwMTMz", "number": 2130, "title": "HBASE-24765: Dynamic master discovery", "bodyText": "This patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either 5mins or any registry RPC failure.\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed.", "createdAt": "2020-07-23T19:53:33Z", "url": "https://github.com/apache/hbase/pull/2130", "merged": true, "mergeCommit": {"oid": "01cf60067c48490910745b2e15554b762e790757"}, "closed": true, "closedAt": "2020-08-25T22:09:04Z", "author": {"login": "bharathv"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc34W40ABqjM1ODIxMTMyNjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCYAprgBqjM2OTAzNjM5MDE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8febac15a24e798a75eef675b7ef11e7102fd84a", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/8febac15a24e798a75eef675b7ef11e7102fd84a", "committedDate": "2020-07-23T19:49:21Z", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either 5mins or any registry RPC failure.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed."}, "afterCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/36fe586bb715c6e0372d0575ae73c59b0886d3aa", "committedDate": "2020-07-23T23:51:25Z", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either 5mins or any registry RPC failure.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0ODk2MDA4", "url": "https://github.com/apache/hbase/pull/2130#pullrequestreview-454896008", "createdAt": "2020-07-24T13:42:30Z", "commit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxMzo0MjozMFrOG2v0Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNDo1ODoyMFrOG2ysJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA1OTcxMQ==", "bodyText": "We are planning to have a cache with ZKWatcher for backupMasters ZNode right? I believe as of now, we don't subscribe for any event.", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460059711", "createdAt": "2020-07-24T13:42:30Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2931,6 +2935,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n     return resp.build();\n   }\n \n+  @Override\n+  public GetMastersResponse getMasters(RpcController rpcController, GetMastersRequest request)\n+      throws ServiceException {\n+    GetMastersResponse.Builder resp = GetMastersResponse.newBuilder();\n+    // Active master\n+    Optional<ServerName> serverName = master.getActiveMaster();\n+    serverName.ifPresent(name -> resp.addMasterServers(GetMastersResponseEntry.newBuilder()\n+        .setServerName(ProtobufUtil.toServerName(name)).setIsActive(true).build()));\n+    // Backup masters\n+    try {\n+      // TODO: Cache the backup masters to avoid a ZK RPC for each getMasters() call.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA3Mzc4OA==", "bodyText": "Don't want to use SingleThreadExecutor.submit()?", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460073788", "createdAt": "2020-07-24T14:05:50Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +129,50 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    Runnable masterEndPointRefresher = () -> {\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(WAIT_TIME_OUT_MS);\n+          }\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(getMasters().get());\n+          populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);\n+          break;\n+        } catch (ExecutionException | IOException e) {\n+          LOG.debug(\"Error populating latest list of masters.\", e);\n+        }\n+      }\n+    };\n+    masterAddrRefresherThread = Threads.newDaemonThreadFactory(\n+        \"MasterRegistry refresh end-points\").newThread(masterEndPointRefresher);\n+    masterAddrRefresherThread.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA3NTU0Nw==", "bodyText": "Can you please use guava library's ThreadFactoryBuilder? So far the consensus on HBASE-24750 is to get rid of our internally maintained ThreadFactory :)", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460075547", "createdAt": "2020-07-24T14:08:46Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +129,50 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    Runnable masterEndPointRefresher = () -> {\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(WAIT_TIME_OUT_MS);\n+          }\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(getMasters().get());\n+          populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);\n+          break;\n+        } catch (ExecutionException | IOException e) {\n+          LOG.debug(\"Error populating latest list of masters.\", e);\n+        }\n+      }\n+    };\n+    masterAddrRefresherThread = Threads.newDaemonThreadFactory(\n+        \"MasterRegistry refresh end-points\").newThread(masterEndPointRefresher);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA5MTA1OA==", "bodyText": "nit: avoid space in Thread prefix name?", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460091058", "createdAt": "2020-07-24T14:33:00Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +129,50 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    Runnable masterEndPointRefresher = () -> {\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(WAIT_TIME_OUT_MS);\n+          }\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(getMasters().get());\n+          populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);\n+          break;\n+        } catch (ExecutionException | IOException e) {\n+          LOG.debug(\"Error populating latest list of masters.\", e);\n+        }\n+      }\n+    };\n+    masterAddrRefresherThread = Threads.newDaemonThreadFactory(\n+        \"MasterRegistry refresh end-points\").newThread(masterEndPointRefresher);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA5MjU3MA==", "bodyText": "newMasters2.contains(activeMaster.getServerName())", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460092570", "createdAt": "2020-07-24T14:35:29Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMasterRegistry.java", "diffHunk": "@@ -126,4 +131,46 @@ public void testRegistryRPCs() throws Exception {\n       }\n     }\n   }\n+\n+  /**\n+   * Tests that the list of masters configured in the MasterRegistry is dynamically refreshed in the\n+   * event of errors.\n+   */\n+  @Test\n+  public void testDynamicMasterConfigurationRefresh() throws Exception {\n+    Configuration conf = new Configuration(TEST_UTIL.getConfiguration());\n+    String currentMasterAddrs = Preconditions.checkNotNull(conf.get(HConstants.MASTER_ADDRS_KEY));\n+    HMaster activeMaster = TEST_UTIL.getHBaseCluster().getMaster();\n+    String clusterId = activeMaster.getClusterId();\n+    // Add a non-working master\n+    ServerName badServer = ServerName.valueOf(\"localhost\", 1234, -1);\n+    conf.set(HConstants.MASTER_ADDRS_KEY, badServer.toShortString() + \",\" + currentMasterAddrs);\n+    // Set the hedging fan out so that all masters are queried.\n+    conf.setInt(MasterRegistry.MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY, 4);\n+    try (MasterRegistry registry = new MasterRegistry(conf)) {\n+      final Set<ServerName> masters = registry.getParsedMasterServers();\n+      assertTrue(masters.contains(badServer));\n+      // Make a registry RPC, this should trigger a refresh since one of the hedged RPC fails.\n+      assertEquals(registry.getClusterId().get(), clusterId);\n+      // Wait for new set of masters to be populated.\n+      TEST_UTIL.waitFor(5000,\n+          (Waiter.Predicate<Exception>) () -> !registry.getParsedMasterServers().equals(masters));\n+      // new set of masters should not include the bad server\n+      final Set<ServerName> newMasters = registry.getParsedMasterServers();\n+      // Bad one should be out.\n+      assertEquals(3, newMasters.size());\n+      assertFalse(newMasters.contains(badServer));\n+      // Kill the active master\n+      activeMaster.stopMaster();\n+      TEST_UTIL.waitFor(10000,\n+        () -> TEST_UTIL.getMiniHBaseCluster().getLiveMasterThreads().size() == 2);\n+      assertEquals(registry.getClusterId().get(), clusterId);\n+      // Make another registry RPC call which should trigger another refresh.\n+      TEST_UTIL.waitFor(100000, (Waiter.Predicate<Exception>) () ->\n+          registry.getParsedMasterServers().size() == 2);\n+      final Set<ServerName> newMasters2 = registry.getParsedMasterServers();\n+      assertEquals(2, newMasters2.size());\n+      assertFalse(newMasters2.contains(activeMaster));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA5NDQ1OA==", "bodyText": "nit: upto you if you want to use ExplainingPredicate to throw Exception with specific message", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460094458", "createdAt": "2020-07-24T14:38:37Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMasterRegistry.java", "diffHunk": "@@ -126,4 +131,46 @@ public void testRegistryRPCs() throws Exception {\n       }\n     }\n   }\n+\n+  /**\n+   * Tests that the list of masters configured in the MasterRegistry is dynamically refreshed in the\n+   * event of errors.\n+   */\n+  @Test\n+  public void testDynamicMasterConfigurationRefresh() throws Exception {\n+    Configuration conf = new Configuration(TEST_UTIL.getConfiguration());\n+    String currentMasterAddrs = Preconditions.checkNotNull(conf.get(HConstants.MASTER_ADDRS_KEY));\n+    HMaster activeMaster = TEST_UTIL.getHBaseCluster().getMaster();\n+    String clusterId = activeMaster.getClusterId();\n+    // Add a non-working master\n+    ServerName badServer = ServerName.valueOf(\"localhost\", 1234, -1);\n+    conf.set(HConstants.MASTER_ADDRS_KEY, badServer.toShortString() + \",\" + currentMasterAddrs);\n+    // Set the hedging fan out so that all masters are queried.\n+    conf.setInt(MasterRegistry.MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY, 4);\n+    try (MasterRegistry registry = new MasterRegistry(conf)) {\n+      final Set<ServerName> masters = registry.getParsedMasterServers();\n+      assertTrue(masters.contains(badServer));\n+      // Make a registry RPC, this should trigger a refresh since one of the hedged RPC fails.\n+      assertEquals(registry.getClusterId().get(), clusterId);\n+      // Wait for new set of masters to be populated.\n+      TEST_UTIL.waitFor(5000,\n+          (Waiter.Predicate<Exception>) () -> !registry.getParsedMasterServers().equals(masters));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA5NjQwMQ==", "bodyText": "After stopping activeMaster, maybe add an extra check to confirm list contains one Active and one Backup?", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460096401", "createdAt": "2020-07-24T14:41:53Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMasterRegistry.java", "diffHunk": "@@ -126,4 +131,46 @@ public void testRegistryRPCs() throws Exception {\n       }\n     }\n   }\n+\n+  /**\n+   * Tests that the list of masters configured in the MasterRegistry is dynamically refreshed in the\n+   * event of errors.\n+   */\n+  @Test\n+  public void testDynamicMasterConfigurationRefresh() throws Exception {\n+    Configuration conf = new Configuration(TEST_UTIL.getConfiguration());\n+    String currentMasterAddrs = Preconditions.checkNotNull(conf.get(HConstants.MASTER_ADDRS_KEY));\n+    HMaster activeMaster = TEST_UTIL.getHBaseCluster().getMaster();\n+    String clusterId = activeMaster.getClusterId();\n+    // Add a non-working master\n+    ServerName badServer = ServerName.valueOf(\"localhost\", 1234, -1);\n+    conf.set(HConstants.MASTER_ADDRS_KEY, badServer.toShortString() + \",\" + currentMasterAddrs);\n+    // Set the hedging fan out so that all masters are queried.\n+    conf.setInt(MasterRegistry.MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY, 4);\n+    try (MasterRegistry registry = new MasterRegistry(conf)) {\n+      final Set<ServerName> masters = registry.getParsedMasterServers();\n+      assertTrue(masters.contains(badServer));\n+      // Make a registry RPC, this should trigger a refresh since one of the hedged RPC fails.\n+      assertEquals(registry.getClusterId().get(), clusterId);\n+      // Wait for new set of masters to be populated.\n+      TEST_UTIL.waitFor(5000,\n+          (Waiter.Predicate<Exception>) () -> !registry.getParsedMasterServers().equals(masters));\n+      // new set of masters should not include the bad server\n+      final Set<ServerName> newMasters = registry.getParsedMasterServers();\n+      // Bad one should be out.\n+      assertEquals(3, newMasters.size());\n+      assertFalse(newMasters.contains(badServer));\n+      // Kill the active master\n+      activeMaster.stopMaster();\n+      TEST_UTIL.waitFor(10000,\n+        () -> TEST_UTIL.getMiniHBaseCluster().getLiveMasterThreads().size() == 2);\n+      assertEquals(registry.getClusterId().get(), clusterId);\n+      // Make another registry RPC call which should trigger another refresh.\n+      TEST_UTIL.waitFor(100000, (Waiter.Predicate<Exception>) () ->\n+          registry.getParsedMasterServers().size() == 2);\n+      final Set<ServerName> newMasters2 = registry.getParsedMasterServers();\n+      assertEquals(2, newMasters2.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEwNjc5MQ==", "bodyText": "For any generic RPC failure, we want to expedite populating masters with another RPC call.\nLet's say there are some sequence of events:\n\ngetClusterId() RPC call failed\nmaster refresher thread was in waiting state, so we notify it and it will trigger getMasters() call\nthe call fails again and we notify refreshMasters but no one is waiting on it, notify is ignored\nmaster refresher thread again waits for 5 min before populating masters.\n\nDo we really want step 4 to wait for 5 min (assuming no other RPC call happens and masters list is stale)? Maybe we can expedite populating masters with the help of AtomicBoolean check (and also avoid synchronized + wait calls i.e 5 min wait)?\nEven if we have network issue, we don't want to delay populate masters by 5 min right?", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460106791", "createdAt": "2020-07-24T14:58:20Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -170,6 +214,11 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     callable.call(controller, stub, resp -> {\n       if (controller.failed()) {\n         future.completeExceptionally(controller.getFailed());\n+        // RPC has failed, trigger a refresh of master end points. We can have some spurious\n+        // refreshes, but that is okay since the RPC is not expensive and not in a hot path.\n+        synchronized (refreshMasters) {\n+          refreshMasters.notify();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0OTkwODM1", "url": "https://github.com/apache/hbase/pull/2130#pullrequestreview-454990835", "createdAt": "2020-07-24T15:40:52Z", "commit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTo0MDo1MlrOG20R-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTo0MDo1MlrOG20R-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzMjg1OQ==", "bodyText": "Maybe we can expedite populating masters with the help of AtomicBoolean check\n\nNot sure I follow this, mind rephrasing?\n\nassuming no other RPC call happens and masters list is stale\n\nIf not other RPC call happens, it doesn't matter if the list is stale or not?\n\nEven if we have network issue, we don't want to delay populate masters by 5 min right?\n\nNot sure I follow, if we have a network issue, how can we populate?", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460132859", "createdAt": "2020-07-24T15:40:52Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -170,6 +214,11 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     callable.call(controller, stub, resp -> {\n       if (controller.failed()) {\n         future.completeExceptionally(controller.getFailed());\n+        // RPC has failed, trigger a refresh of master end points. We can have some spurious\n+        // refreshes, but that is okay since the RPC is not expensive and not in a hot path.\n+        synchronized (refreshMasters) {\n+          refreshMasters.notify();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEwNjc5MQ=="}, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MzgxNTY0", "url": "https://github.com/apache/hbase/pull/2130#pullrequestreview-455381564", "createdAt": "2020-07-26T17:24:00Z", "commit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxNzoyNDowMFrOG3N4lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxNzoyNzo0M1rOG3N6Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MjM0Mw==", "bodyText": "Maybe we can expedite populating masters with the help of AtomicBoolean check\n\nNot sure I follow this, mind rephrasing?\n\nI meant to say if refresh thread misses this notify because it is already done waiting on refreshMasters, for the next loop, it should not again wait 5 min on refreshMasters and rather quickly perform RPC call to populate masters.\n\n\nEven if we have network issue, we don't want to delay populate masters by 5 min right?\n\nNot sure I follow, if we have a network issue, how can we populate?\n\nI meant same as above that even if network issue causes notify to refresh thread when it was already past waiting state, maybe next time the thread better quickly make an RPC call rather than waiting 5 min on refreshMasters. But yes, for network issues, we will keep making RPC calls without any progress.\n\nIf not other RPC call happens, it doesn't matter if the list is stale or not?\n\nHmm that's true.", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460552343", "createdAt": "2020-07-26T17:24:00Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -170,6 +214,11 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     callable.call(controller, stub, resp -> {\n       if (controller.failed()) {\n         future.completeExceptionally(controller.getFailed());\n+        // RPC has failed, trigger a refresh of master end points. We can have some spurious\n+        // refreshes, but that is okay since the RPC is not expensive and not in a hot path.\n+        synchronized (refreshMasters) {\n+          refreshMasters.notify();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEwNjc5MQ=="}, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MjcyNg==", "bodyText": "nit: static final here? Anyways, MasterRegistry is singleton right? (if not by design, but by usage)", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460552726", "createdAt": "2020-07-26T17:27:43Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -89,11 +97,17 @@\n   private final int hedgedReadFanOut;\n \n   // Configured list of masters to probe the meta information from.\n-  private final ImmutableMap<ServerName, ClientMetaService.Interface> masterAddr2Stub;\n+  private volatile ImmutableMap<ServerName, ClientMetaService.Interface> masterAddr2Stub;\n \n   // RPC client used to talk to the masters.\n   private final RpcClient rpcClient;\n   private final RpcControllerFactory rpcControllerFactory;\n+  private final int rpcTimeoutMs;\n+  // For synchronizing on refreshing the master end-points\n+  private final Object refreshMasters = new Object();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2ODM4MDA4", "url": "https://github.com/apache/hbase/pull/2130#pullrequestreview-456838008", "createdAt": "2020-07-28T17:07:48Z", "commit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzowNzo0OFrOG4WPuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxNzowNzo0OFrOG4WPuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTczNzkxMw==", "bodyText": "I meant to say if refresh thread misses this notify because it is already done waiting on refreshMasters, for the next loop, it should not again wait 5 min on refreshMasters and rather quickly perform RPC call to populate masters.\n\nI don't think thats needed. If the thread has just fetched the masters (in cases where it missed the notification), it is very unlikely that something new has been added/removed. Typically this is a very rare event, probably less rare in K8s environment than DC deployments but even then I don't think things usually change for days if not weeks.", "url": "https://github.com/apache/hbase/pull/2130#discussion_r461737913", "createdAt": "2020-07-28T17:07:48Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -170,6 +214,11 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     callable.call(controller, stub, resp -> {\n       if (controller.failed()) {\n         future.completeExceptionally(controller.getFailed());\n+        // RPC has failed, trigger a refresh of master end points. We can have some spurious\n+        // refreshes, but that is okay since the RPC is not expensive and not in a hot path.\n+        synchronized (refreshMasters) {\n+          refreshMasters.notify();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEwNjc5MQ=="}, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwMjQ4Mjgw", "url": "https://github.com/apache/hbase/pull/2130#pullrequestreview-460248280", "createdAt": "2020-08-03T18:25:56Z", "commit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxODoyNTo1N1rOG7ELzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wM1QxODo0NjozMVrOG7EyHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4NzcyNQ==", "bodyText": "Can you say more here? Why is it that the internal RPCs that keep the master list up to date are sufficient to skip a call to \"GetClusterId\"? Can you provide a \"see also\" comment that points the reader off to the counting logic, or at least the counter that this condition protects?", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464587725", "createdAt": "2020-08-03T18:25:57Z", "author": {"login": "ndimiduk"}, "path": "hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestMasterRegistryHedgedReads.java", "diffHunk": "@@ -121,6 +121,11 @@ public boolean hasCellBlockSupport() {\n     @Override\n     public void callMethod(MethodDescriptor method, RpcController controller, Message request,\n       Message responsePrototype, RpcCallback<Message> done) {\n+      if (!method.getName().equals(\"GetClusterId\")) {\n+        // Master registry internally runs other RPCs to keep the master list up to date. This check", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4ODkzNg==", "bodyText": "You sure that any failure should require refreshing the list? A mechanism wherein RPC failure results in more RPCs has me suspicious...", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464588936", "createdAt": "2020-08-03T18:28:20Z", "author": {"login": "ndimiduk"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -170,6 +214,11 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     callable.call(controller, stub, resp -> {\n       if (controller.failed()) {\n         future.completeExceptionally(controller.getFailed());\n+        // RPC has failed, trigger a refresh of master end points. We can have some spurious", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NDE3NQ==", "bodyText": "Should this interrupt be accompanied by a shutdown of the managing thread pool? Maybe in an attached exception handler. Or it's okay to leave the pool as abandoned, on the assumption that there was only the single thread in the pool and the whole process is being terminated.", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464594175", "createdAt": "2020-08-03T18:39:28Z", "author": {"login": "ndimiduk"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +129,50 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    Runnable masterEndPointRefresher = () -> {\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(WAIT_TIME_OUT_MS);\n+          }\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(getMasters().get());\n+          populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NTY5NA==", "bodyText": "Oh, reading below, there is no thread pool. I +1 Viraj's suggestion of a single thread executor service.", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464595694", "createdAt": "2020-08-03T18:42:43Z", "author": {"login": "ndimiduk"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +129,50 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    Runnable masterEndPointRefresher = () -> {\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(WAIT_TIME_OUT_MS);\n+          }\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(getMasters().get());\n+          populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NDE3NQ=="}, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NjY3NA==", "bodyText": "Should the thread be started in the constructor? Now I see that ConnectionRegistry defines a close() but not a start() :(", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464596674", "createdAt": "2020-08-03T18:44:49Z", "author": {"login": "ndimiduk"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +129,50 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    Runnable masterEndPointRefresher = () -> {\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(WAIT_TIME_OUT_MS);\n+          }\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(getMasters().get());\n+          populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);\n+          break;\n+        } catch (ExecutionException | IOException e) {\n+          LOG.debug(\"Error populating latest list of masters.\", e);\n+        }\n+      }\n+    };\n+    masterAddrRefresherThread = Threads.newDaemonThreadFactory(\n+        \"MasterRegistry refresh end-points\").newThread(masterEndPointRefresher);\n+    masterAddrRefresherThread.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NzUzMg==", "bodyText": "Where would I find metrics regarding calls to getMasters()? I suppose either client or server-side would be good.", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464597532", "createdAt": "2020-08-03T18:46:31Z", "author": {"login": "ndimiduk"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +129,50 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    Runnable masterEndPointRefresher = () -> {\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(WAIT_TIME_OUT_MS);\n+          }\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(getMasters().get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 91}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/36fe586bb715c6e0372d0575ae73c59b0886d3aa", "committedDate": "2020-07-23T23:51:25Z", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either 5mins or any registry RPC failure.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed."}, "afterCommit": {"oid": "f7ae049a724dc132c15f2735c1b670a88604e99a", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/f7ae049a724dc132c15f2735c1b670a88604e99a", "committedDate": "2020-08-04T16:07:24Z", "message": "Address review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxNjIyMDQ4", "url": "https://github.com/apache/hbase/pull/2130#pullrequestreview-461622048", "createdAt": "2020-08-05T12:38:41Z", "commit": {"oid": "f7ae049a724dc132c15f2735c1b670a88604e99a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMjozODo0MVrOG8HyQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxMjozODo0MVrOG8HyQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5NTI5Nw==", "bodyText": "nit: MasterRegistry-refresh-end-points-%d or MasterRegistry-refresh-pool-%d ?", "url": "https://github.com/apache/hbase/pull/2130#discussion_r465695297", "createdAt": "2020-08-05T12:38:41Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +132,49 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    masterAddrRefresher = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()\n+        .setNameFormat(\"MasterRegistry refresh end-points\").setDaemon(true).build());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7ae049a724dc132c15f2735c1b670a88604e99a"}, "originalPosition": 89}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f7ae049a724dc132c15f2735c1b670a88604e99a", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/f7ae049a724dc132c15f2735c1b670a88604e99a", "committedDate": "2020-08-04T16:07:24Z", "message": "Address review comments"}, "afterCommit": {"oid": "fb3465140b1d33cd8638330db90343f859c22a54", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/fb3465140b1d33cd8638330db90343f859c22a54", "committedDate": "2020-08-10T08:04:13Z", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either periodic (5 mins) or any registry RPC failure.\n\nUpdates the client side connection metrics to maintain a counter\nper RPC type so that clients have visibility into counts grouped\nby RPC method name.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0MDI3NDM4", "url": "https://github.com/apache/hbase/pull/2130#pullrequestreview-464027438", "createdAt": "2020-08-10T08:07:22Z", "commit": {"oid": "fb3465140b1d33cd8638330db90343f859c22a54"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fb3465140b1d33cd8638330db90343f859c22a54", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/fb3465140b1d33cd8638330db90343f859c22a54", "committedDate": "2020-08-10T08:04:13Z", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either periodic (5 mins) or any registry RPC failure.\n\nUpdates the client side connection metrics to maintain a counter\nper RPC type so that clients have visibility into counts grouped\nby RPC method name.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed."}, "afterCommit": {"oid": "14eae44b3e43cd8da9f10841cd56cd21ea9c567b", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/14eae44b3e43cd8da9f10841cd56cd21ea9c567b", "committedDate": "2020-08-10T16:26:27Z", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either periodic (5 mins) or any registry RPC failure.\n\nUpdates the client side connection metrics to maintain a counter\nper RPC type so that clients have visibility into counts grouped\nby RPC method name.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "14eae44b3e43cd8da9f10841cd56cd21ea9c567b", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/14eae44b3e43cd8da9f10841cd56cd21ea9c567b", "committedDate": "2020-08-10T16:26:27Z", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either periodic (5 mins) or any registry RPC failure.\n\nUpdates the client side connection metrics to maintain a counter\nper RPC type so that clients have visibility into counts grouped\nby RPC method name.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed."}, "afterCommit": {"oid": "48157bbfec66e850357f9056d48eb7c84041ed91", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/48157bbfec66e850357f9056d48eb7c84041ed91", "committedDate": "2020-08-10T17:56:39Z", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either periodic (5 mins) or any registry RPC failure.\n\nUpdates the client side connection metrics to maintain a counter\nper RPC type so that clients have visibility into counts grouped\nby RPC method name.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTM0NTM3", "url": "https://github.com/apache/hbase/pull/2130#pullrequestreview-467134537", "createdAt": "2020-08-13T21:13:40Z", "commit": {"oid": "48157bbfec66e850357f9056d48eb7c84041ed91"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMToxMzo0MVrOHAd6CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMToxMzo0MVrOHAd6CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI1MjA0MA==", "bodyText": "Sorry I didn't notice this earlier. Maybe a ScheduledThreadPoolExecutor would simplify your scheduling need?", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470252040", "createdAt": "2020-08-13T21:13:41Z", "author": {"login": "ndimiduk"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterAddressRefresher.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.base.Preconditions;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos.ClientMetaService;\n+\n+/**\n+ * Thread safe utility that keeps master end points used by {@link MasterRegistry} up to date. This\n+ * uses the RPC {@link ClientMetaService#getMasters} to fetch the latest list of registered masters.\n+ * By default the refresh happens periodically (configured via\n+ * {@link #PERIODIC_REFRESH_INTERVAL_SECS}). The refresh can also be triggered on demand via\n+ * {@link #refreshNow()}. To prevent a flood of on-demand refreshes we expect that any attempts two\n+ * should be spaced at least {@link #MIN_SECS_BETWEEN_REFRESHES} seconds apart.\n+ */\n+@InterfaceAudience.Private\n+public class MasterAddressRefresher implements Closeable {\n+  private static final Logger LOG = LoggerFactory.getLogger(MasterAddressRefresher.class);\n+  public static final String PERIODIC_REFRESH_INTERVAL_SECS =\n+      \"hbase.client.master_registry.refresh_interval_secs\";\n+  private static final int PERIODIC_REFRESH_INTERVAL_SECS_DEFAULT = 300;\n+  public static final String MIN_SECS_BETWEEN_REFRESHES =\n+      \"hbase.client.master_registry.min_secs_between_refreshes\";\n+  private static final long MIN_SECS_BETWEEN_REFRESHES_DEFAULT = 60;\n+\n+  private final ExecutorService pool;\n+  private final MasterRegistry registry;\n+  private final long periodicRefreshMs;\n+  private final long timeBetweenRefreshesMs;\n+  private final Object refreshMasters = new Object();\n+\n+  @Override\n+  public void close() {\n+    pool.shutdownNow();\n+  }\n+\n+  /**\n+   * Thread that refreshes the master end points until it is interrupted via {@link #close()}.\n+   * Multiple callers attempting to refresh at the same time synchronize on {@link #refreshMasters}.\n+   */\n+  private class RefreshThread implements Runnable {\n+    @Override\n+    public void run() {\n+      long lastRpcTs = 0;\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(periodicRefreshMs);\n+          }\n+          long currentTs = EnvironmentEdgeManager.currentTime();\n+          if (lastRpcTs != 0 && currentTs - lastRpcTs <= timeBetweenRefreshesMs) {\n+            continue;\n+          }\n+          lastRpcTs = currentTs;\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(registry.getMasters().get());\n+          registry.populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);\n+          break;\n+        } catch (ExecutionException | IOException e) {\n+          LOG.debug(\"Error populating latest list of masters.\", e);\n+        }\n+      }\n+    }\n+  }\n+\n+  MasterAddressRefresher(Configuration conf, MasterRegistry registry) {\n+    pool = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48157bbfec66e850357f9056d48eb7c84041ed91"}, "originalPosition": 103}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NjE2MzIz", "url": "https://github.com/apache/hbase/pull/2130#pullrequestreview-454616323", "createdAt": "2020-07-24T03:24:06Z", "commit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQwMzoyNDowNlrOG2iGtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwMTo1Mzo0NFrOHAk-qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNTA2MQ==", "bodyText": "Usually a notify without any flag will have strange race problem...\nAt least let's have a 'triggerRefresh' flag to guard redundant notification?", "url": "https://github.com/apache/hbase/pull/2130#discussion_r459835061", "createdAt": "2020-07-24T03:24:06Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -170,6 +214,11 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     callable.call(controller, stub, resp -> {\n       if (controller.failed()) {\n         future.completeExceptionally(controller.getFailed());\n+        // RPC has failed, trigger a refresh of master end points. We can have some spurious\n+        // refreshes, but that is okay since the RPC is not expensive and not in a hot path.\n+        synchronized (refreshMasters) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNTIwOA==", "bodyText": "I think we can test the exception type? Only if it is a connect exception, we will refresh the address list?", "url": "https://github.com/apache/hbase/pull/2130#discussion_r459835208", "createdAt": "2020-07-24T03:24:53Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -170,6 +214,11 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     callable.call(controller, stub, resp -> {\n       if (controller.failed()) {\n         future.completeExceptionally(controller.getFailed());\n+        // RPC has failed, trigger a refresh of master end points. We can have some spurious", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNTQ0Ng==", "bodyText": "I think here we should assign masterAddr2Stub to a local variable before using it?", "url": "https://github.com/apache/hbase/pull/2130#discussion_r459835446", "createdAt": "2020-07-24T03:26:05Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -226,17 +276,19 @@ private IOException badResponse(String debug) {\n \n   private <T extends Message> CompletableFuture<T> call(Callable<T> callable,\n     Predicate<T> isValidResp, String debug) {\n+    Set<ServerName> masterServers = masterAddr2Stub.keySet();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNTgxMA==", "bodyText": "Do not need to be public?", "url": "https://github.com/apache/hbase/pull/2130#discussion_r459835810", "createdAt": "2020-07-24T03:28:15Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -259,17 +311,40 @@ private RegionLocations transformMetaRegionLocations(GetMetaRegionLocationsRespo\n       .thenApply(GetClusterIdResponse::getClusterId);\n   }\n \n-  private ServerName transformServerName(GetActiveMasterResponse resp) {\n-    return ProtobufUtil.toServerName(resp.getServerName());\n+  private static boolean hasActiveMaster(GetMastersResponse resp) {\n+    List<GetMastersResponseEntry> activeMasters =\n+        resp.getMasterServersList().stream().filter(GetMastersResponseEntry::getIsActive).collect(\n+        Collectors.toList());\n+    return activeMasters.size() == 1;\n+  }\n+\n+  private static ServerName filterActiveMaster(GetMastersResponse resp) {\n+    List<GetMastersResponseEntry> activeMasters =\n+        resp.getMasterServersList().stream().filter(GetMastersResponseEntry::getIsActive).collect(\n+            Collectors.toList());\n+    Preconditions.checkState(activeMasters.size() == 1);\n+    return ProtobufUtil.toServerName(activeMasters.get(0).getServerName());\n   }\n \n   @Override\n   public CompletableFuture<ServerName> getActiveMaster() {\n     return this\n-      .<GetActiveMasterResponse> call(\n-        (c, s, d) -> s.getActiveMaster(c, GetActiveMasterRequest.getDefaultInstance(), d),\n-        GetActiveMasterResponse::hasServerName, \"getActiveMaster()\")\n-      .thenApply(this::transformServerName);\n+      .<GetMastersResponse> call(\n+        (c, s, d) -> s.getMasters(c, GetMastersRequest.getDefaultInstance(), d),\n+        MasterRegistry::hasActiveMaster, \"getMasters()\")\n+      .thenApply(MasterRegistry::filterActiveMaster);\n+  }\n+\n+  private static List<ServerName> transformServerNames(GetMastersResponse resp) {\n+    return resp.getMasterServersList().stream().map(s -> ProtobufUtil.toServerName(\n+        s.getServerName())).collect(Collectors.toList());\n+  }\n+\n+  public CompletableFuture<List<ServerName>> getMasters() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNjI4Mw==", "bodyText": "Do we want to make it configurable?", "url": "https://github.com/apache/hbase/pull/2130#discussion_r459836283", "createdAt": "2020-07-24T03:31:03Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -89,11 +97,17 @@\n   private final int hedgedReadFanOut;\n \n   // Configured list of masters to probe the meta information from.\n-  private final ImmutableMap<ServerName, ClientMetaService.Interface> masterAddr2Stub;\n+  private volatile ImmutableMap<ServerName, ClientMetaService.Interface> masterAddr2Stub;\n \n   // RPC client used to talk to the masters.\n   private final RpcClient rpcClient;\n   private final RpcControllerFactory rpcControllerFactory;\n+  private final int rpcTimeoutMs;\n+  // For synchronizing on refreshing the master end-points\n+  private final Object refreshMasters = new Object();\n+  // Refreshed every WAIT_TIME_OUT_MS or unless explicitly invoked.\n+  private static final int WAIT_TIME_OUT_MS = 5 * 60 * 1000; // 5 mins", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNjYxMQ==", "bodyText": "I prefer we add a stop flag for the Registry and test it to determine whether we should quit.", "url": "https://github.com/apache/hbase/pull/2130#discussion_r459836611", "createdAt": "2020-07-24T03:32:43Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +129,50 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    Runnable masterEndPointRefresher = () -> {\n+      while (!Thread.interrupted()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNjkwMA==", "bodyText": "This is a behavior change? I do not think we will throw IllegalStateException when there is no active master before this patch?", "url": "https://github.com/apache/hbase/pull/2130#discussion_r459836900", "createdAt": "2020-07-24T03:34:31Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -259,17 +311,40 @@ private RegionLocations transformMetaRegionLocations(GetMetaRegionLocationsRespo\n       .thenApply(GetClusterIdResponse::getClusterId);\n   }\n \n-  private ServerName transformServerName(GetActiveMasterResponse resp) {\n-    return ProtobufUtil.toServerName(resp.getServerName());\n+  private static boolean hasActiveMaster(GetMastersResponse resp) {\n+    List<GetMastersResponseEntry> activeMasters =\n+        resp.getMasterServersList().stream().filter(GetMastersResponseEntry::getIsActive).collect(\n+        Collectors.toList());\n+    return activeMasters.size() == 1;\n+  }\n+\n+  private static ServerName filterActiveMaster(GetMastersResponse resp) {\n+    List<GetMastersResponseEntry> activeMasters =\n+        resp.getMasterServersList().stream().filter(GetMastersResponseEntry::getIsActive).collect(\n+            Collectors.toList());\n+    Preconditions.checkState(activeMasters.size() == 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNzM2NA==", "bodyText": "I think this should be done in this patch, as now this method will replace the old getActiveMaster method, which makes it not only be used in our internal refresh but also be used by end users, we should not let users still have the ability to harmmer zookeeper...", "url": "https://github.com/apache/hbase/pull/2130#discussion_r459837364", "createdAt": "2020-07-24T03:37:04Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2931,6 +2935,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n     return resp.build();\n   }\n \n+  @Override\n+  public GetMastersResponse getMasters(RpcController rpcController, GetMastersRequest request)\n+      throws ServiceException {\n+    GetMastersResponse.Builder resp = GetMastersResponse.newBuilder();\n+    // Active master\n+    Optional<ServerName> serverName = master.getActiveMaster();\n+    serverName.ifPresent(name -> resp.addMasterServers(GetMastersResponseEntry.newBuilder()\n+        .setServerName(ProtobufUtil.toServerName(name)).setIsActive(true).build()));\n+    // Backup masters\n+    try {\n+      // TODO: Cache the backup masters to avoid a ZK RPC for each getMasters() call.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM2NzkxMg==", "bodyText": "I think this could be a follow on issue. Let's get this feature in first as I think it is very useful for a long running service which depends on HBase? I have an idea on making use of the HashedWheelTimeoutTimer to do the refreshing work, will file an improvement issue if I have time.", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470367912", "createdAt": "2020-08-14T01:53:44Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterAddressRefresher.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.base.Preconditions;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos.ClientMetaService;\n+\n+/**\n+ * Thread safe utility that keeps master end points used by {@link MasterRegistry} up to date. This\n+ * uses the RPC {@link ClientMetaService#getMasters} to fetch the latest list of registered masters.\n+ * By default the refresh happens periodically (configured via\n+ * {@link #PERIODIC_REFRESH_INTERVAL_SECS}). The refresh can also be triggered on demand via\n+ * {@link #refreshNow()}. To prevent a flood of on-demand refreshes we expect that any attempts two\n+ * should be spaced at least {@link #MIN_SECS_BETWEEN_REFRESHES} seconds apart.\n+ */\n+@InterfaceAudience.Private\n+public class MasterAddressRefresher implements Closeable {\n+  private static final Logger LOG = LoggerFactory.getLogger(MasterAddressRefresher.class);\n+  public static final String PERIODIC_REFRESH_INTERVAL_SECS =\n+      \"hbase.client.master_registry.refresh_interval_secs\";\n+  private static final int PERIODIC_REFRESH_INTERVAL_SECS_DEFAULT = 300;\n+  public static final String MIN_SECS_BETWEEN_REFRESHES =\n+      \"hbase.client.master_registry.min_secs_between_refreshes\";\n+  private static final long MIN_SECS_BETWEEN_REFRESHES_DEFAULT = 60;\n+\n+  private final ExecutorService pool;\n+  private final MasterRegistry registry;\n+  private final long periodicRefreshMs;\n+  private final long timeBetweenRefreshesMs;\n+  private final Object refreshMasters = new Object();\n+\n+  @Override\n+  public void close() {\n+    pool.shutdownNow();\n+  }\n+\n+  /**\n+   * Thread that refreshes the master end points until it is interrupted via {@link #close()}.\n+   * Multiple callers attempting to refresh at the same time synchronize on {@link #refreshMasters}.\n+   */\n+  private class RefreshThread implements Runnable {\n+    @Override\n+    public void run() {\n+      long lastRpcTs = 0;\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(periodicRefreshMs);\n+          }\n+          long currentTs = EnvironmentEdgeManager.currentTime();\n+          if (lastRpcTs != 0 && currentTs - lastRpcTs <= timeBetweenRefreshesMs) {\n+            continue;\n+          }\n+          lastRpcTs = currentTs;\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(registry.getMasters().get());\n+          registry.populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);\n+          break;\n+        } catch (ExecutionException | IOException e) {\n+          LOG.debug(\"Error populating latest list of masters.\", e);\n+        }\n+      }\n+    }\n+  }\n+\n+  MasterAddressRefresher(Configuration conf, MasterRegistry registry) {\n+    pool = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI1MjA0MA=="}, "originalCommit": {"oid": "48157bbfec66e850357f9056d48eb7c84041ed91"}, "originalPosition": 103}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MzE5NTU2", "url": "https://github.com/apache/hbase/pull/2130#pullrequestreview-467319556", "createdAt": "2020-08-14T05:42:38Z", "commit": {"oid": "48157bbfec66e850357f9056d48eb7c84041ed91"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQwNTo0MjozOVrOHAoO8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNFQxNjozNjoxNFrOHA7OVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQyMTIzMw==", "bodyText": "Whats your idea? Just curious.", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470421233", "createdAt": "2020-08-14T05:42:39Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterAddressRefresher.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.base.Preconditions;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos.ClientMetaService;\n+\n+/**\n+ * Thread safe utility that keeps master end points used by {@link MasterRegistry} up to date. This\n+ * uses the RPC {@link ClientMetaService#getMasters} to fetch the latest list of registered masters.\n+ * By default the refresh happens periodically (configured via\n+ * {@link #PERIODIC_REFRESH_INTERVAL_SECS}). The refresh can also be triggered on demand via\n+ * {@link #refreshNow()}. To prevent a flood of on-demand refreshes we expect that any attempts two\n+ * should be spaced at least {@link #MIN_SECS_BETWEEN_REFRESHES} seconds apart.\n+ */\n+@InterfaceAudience.Private\n+public class MasterAddressRefresher implements Closeable {\n+  private static final Logger LOG = LoggerFactory.getLogger(MasterAddressRefresher.class);\n+  public static final String PERIODIC_REFRESH_INTERVAL_SECS =\n+      \"hbase.client.master_registry.refresh_interval_secs\";\n+  private static final int PERIODIC_REFRESH_INTERVAL_SECS_DEFAULT = 300;\n+  public static final String MIN_SECS_BETWEEN_REFRESHES =\n+      \"hbase.client.master_registry.min_secs_between_refreshes\";\n+  private static final long MIN_SECS_BETWEEN_REFRESHES_DEFAULT = 60;\n+\n+  private final ExecutorService pool;\n+  private final MasterRegistry registry;\n+  private final long periodicRefreshMs;\n+  private final long timeBetweenRefreshesMs;\n+  private final Object refreshMasters = new Object();\n+\n+  @Override\n+  public void close() {\n+    pool.shutdownNow();\n+  }\n+\n+  /**\n+   * Thread that refreshes the master end points until it is interrupted via {@link #close()}.\n+   * Multiple callers attempting to refresh at the same time synchronize on {@link #refreshMasters}.\n+   */\n+  private class RefreshThread implements Runnable {\n+    @Override\n+    public void run() {\n+      long lastRpcTs = 0;\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(periodicRefreshMs);\n+          }\n+          long currentTs = EnvironmentEdgeManager.currentTime();\n+          if (lastRpcTs != 0 && currentTs - lastRpcTs <= timeBetweenRefreshesMs) {\n+            continue;\n+          }\n+          lastRpcTs = currentTs;\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(registry.getMasters().get());\n+          registry.populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);\n+          break;\n+        } catch (ExecutionException | IOException e) {\n+          LOG.debug(\"Error populating latest list of masters.\", e);\n+        }\n+      }\n+    }\n+  }\n+\n+  MasterAddressRefresher(Configuration conf, MasterRegistry registry) {\n+    pool = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI1MjA0MA=="}, "originalCommit": {"oid": "48157bbfec66e850357f9056d48eb7c84041ed91"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQyMTYwOQ==", "bodyText": "Ya, that was what I wanted to do originally, but I thought the rpc is cheap and it doesn't hurt to do for any exception and left it this way. Let me add it, I don't have a strong preference.", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470421609", "createdAt": "2020-08-14T05:44:02Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -170,6 +214,11 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     callable.call(controller, stub, resp -> {\n       if (controller.failed()) {\n         future.completeExceptionally(controller.getFailed());\n+        // RPC has failed, trigger a refresh of master end points. We can have some spurious", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNTIwOA=="}, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcyNDkyNQ==", "bodyText": "Right, done.", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470724925", "createdAt": "2020-08-14T16:21:09Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -226,17 +276,19 @@ private IOException badResponse(String debug) {\n \n   private <T extends Message> CompletableFuture<T> call(Callable<T> callable,\n     Predicate<T> isValidResp, String debug) {\n+    Set<ServerName> masterServers = masterAddr2Stub.keySet();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNTQ0Ng=="}, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcyNTYyMg==", "bodyText": "Done.", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470725622", "createdAt": "2020-08-14T16:22:28Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -259,17 +311,40 @@ private RegionLocations transformMetaRegionLocations(GetMetaRegionLocationsRespo\n       .thenApply(GetClusterIdResponse::getClusterId);\n   }\n \n-  private ServerName transformServerName(GetActiveMasterResponse resp) {\n-    return ProtobufUtil.toServerName(resp.getServerName());\n+  private static boolean hasActiveMaster(GetMastersResponse resp) {\n+    List<GetMastersResponseEntry> activeMasters =\n+        resp.getMasterServersList().stream().filter(GetMastersResponseEntry::getIsActive).collect(\n+        Collectors.toList());\n+    return activeMasters.size() == 1;\n+  }\n+\n+  private static ServerName filterActiveMaster(GetMastersResponse resp) {\n+    List<GetMastersResponseEntry> activeMasters =\n+        resp.getMasterServersList().stream().filter(GetMastersResponseEntry::getIsActive).collect(\n+            Collectors.toList());\n+    Preconditions.checkState(activeMasters.size() == 1);\n+    return ProtobufUtil.toServerName(activeMasters.get(0).getServerName());\n   }\n \n   @Override\n   public CompletableFuture<ServerName> getActiveMaster() {\n     return this\n-      .<GetActiveMasterResponse> call(\n-        (c, s, d) -> s.getActiveMaster(c, GetActiveMasterRequest.getDefaultInstance(), d),\n-        GetActiveMasterResponse::hasServerName, \"getActiveMaster()\")\n-      .thenApply(this::transformServerName);\n+      .<GetMastersResponse> call(\n+        (c, s, d) -> s.getMasters(c, GetMastersRequest.getDefaultInstance(), d),\n+        MasterRegistry::hasActiveMaster, \"getMasters()\")\n+      .thenApply(MasterRegistry::filterActiveMaster);\n+  }\n+\n+  private static List<ServerName> transformServerNames(GetMastersResponse resp) {\n+    return resp.getMasterServersList().stream().map(s -> ProtobufUtil.toServerName(\n+        s.getServerName())).collect(Collectors.toList());\n+  }\n+\n+  public CompletableFuture<List<ServerName>> getMasters() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNTgxMA=="}, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcyODMxOQ==", "bodyText": "Don't think so. If you see getActiveMaster() call, \"hasActiveMaster\" is applied on the response. If that fails, we throw right away. This is only called on \"thenApply()\" which filters the output. Given the way the code is structured, I had to do it twice (since the call() takes a predicate that returns a boolean).", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470728319", "createdAt": "2020-08-14T16:27:59Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -259,17 +311,40 @@ private RegionLocations transformMetaRegionLocations(GetMetaRegionLocationsRespo\n       .thenApply(GetClusterIdResponse::getClusterId);\n   }\n \n-  private ServerName transformServerName(GetActiveMasterResponse resp) {\n-    return ProtobufUtil.toServerName(resp.getServerName());\n+  private static boolean hasActiveMaster(GetMastersResponse resp) {\n+    List<GetMastersResponseEntry> activeMasters =\n+        resp.getMasterServersList().stream().filter(GetMastersResponseEntry::getIsActive).collect(\n+        Collectors.toList());\n+    return activeMasters.size() == 1;\n+  }\n+\n+  private static ServerName filterActiveMaster(GetMastersResponse resp) {\n+    List<GetMastersResponseEntry> activeMasters =\n+        resp.getMasterServersList().stream().filter(GetMastersResponseEntry::getIsActive).collect(\n+            Collectors.toList());\n+    Preconditions.checkState(activeMasters.size() == 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNjkwMA=="}, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczMjM3NQ==", "bodyText": "I have a separate patch for this, didn't want to scope creep this one. Mind if do a separate PR? I will back port them together.", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470732375", "createdAt": "2020-08-14T16:36:14Z", "author": {"login": "bharathv"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2931,6 +2935,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n     return resp.build();\n   }\n \n+  @Override\n+  public GetMastersResponse getMasters(RpcController rpcController, GetMastersRequest request)\n+      throws ServiceException {\n+    GetMastersResponse.Builder resp = GetMastersResponse.newBuilder();\n+    // Active master\n+    Optional<ServerName> serverName = master.getActiveMaster();\n+    serverName.ifPresent(name -> resp.addMasterServers(GetMastersResponseEntry.newBuilder()\n+        .setServerName(ProtobufUtil.toServerName(name)).setIsActive(true).build()));\n+    // Backup masters\n+    try {\n+      // TODO: Cache the backup masters to avoid a ZK RPC for each getMasters() call.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNzM2NA=="}, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 32}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "48157bbfec66e850357f9056d48eb7c84041ed91", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/48157bbfec66e850357f9056d48eb7c84041ed91", "committedDate": "2020-08-10T17:56:39Z", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either periodic (5 mins) or any registry RPC failure.\n\nUpdates the client side connection metrics to maintain a counter\nper RPC type so that clients have visibility into counts grouped\nby RPC method name.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed."}, "afterCommit": {"oid": "e46dfcef4c3b6e70f34d48835d5837e698815a79", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/e46dfcef4c3b6e70f34d48835d5837e698815a79", "committedDate": "2020-08-14T20:35:18Z", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either periodic (5 mins) or any registry RPC failure.\n\nUpdates the client side connection metrics to maintain a counter\nper RPC type so that clients have visibility into counts grouped\nby RPC method name.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e46dfcef4c3b6e70f34d48835d5837e698815a79", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/e46dfcef4c3b6e70f34d48835d5837e698815a79", "committedDate": "2020-08-14T20:35:18Z", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either periodic (5 mins) or any registry RPC failure.\n\nUpdates the client side connection metrics to maintain a counter\nper RPC type so that clients have visibility into counts grouped\nby RPC method name.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed."}, "afterCommit": {"oid": "6cd028727d93eb34df1f01080e9e01f39ecd3242", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/6cd028727d93eb34df1f01080e9e01f39ecd3242", "committedDate": "2020-08-17T07:25:37Z", "message": "Cache backup masters in ActiveMasterManager"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MjI5MTE1", "url": "https://github.com/apache/hbase/pull/2130#pullrequestreview-468229115", "createdAt": "2020-08-17T07:30:34Z", "commit": {"oid": "6cd028727d93eb34df1f01080e9e01f39ecd3242"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwNjEwODgw", "url": "https://github.com/apache/hbase/pull/2130#pullrequestreview-470610880", "createdAt": "2020-08-19T16:08:25Z", "commit": {"oid": "6cd028727d93eb34df1f01080e9e01f39ecd3242"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMjg4MTgz", "url": "https://github.com/apache/hbase/pull/2130#pullrequestreview-471288183", "createdAt": "2020-08-20T06:43:26Z", "commit": {"oid": "6cd028727d93eb34df1f01080e9e01f39ecd3242"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjo0MzoyNlrOHDttqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQwNjo0NzoxMVrOHDt5GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1Njc0NA==", "bodyText": "Introduce a global HashedWheelTimeoutTimer to be used at client side. Now there is one in AsyncConnectionImpl, but in MasterRegistry we can not depend on AsyncConnection so we should move it to another place.\nAnd schedule a timer task to HashedWheelTimeoutTimer to do the refresh. To avoid blocking the thread, we could make use of async rpc call.", "url": "https://github.com/apache/hbase/pull/2130#discussion_r473656744", "createdAt": "2020-08-20T06:43:26Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterAddressRefresher.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.base.Preconditions;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos.ClientMetaService;\n+\n+/**\n+ * Thread safe utility that keeps master end points used by {@link MasterRegistry} up to date. This\n+ * uses the RPC {@link ClientMetaService#getMasters} to fetch the latest list of registered masters.\n+ * By default the refresh happens periodically (configured via\n+ * {@link #PERIODIC_REFRESH_INTERVAL_SECS}). The refresh can also be triggered on demand via\n+ * {@link #refreshNow()}. To prevent a flood of on-demand refreshes we expect that any attempts two\n+ * should be spaced at least {@link #MIN_SECS_BETWEEN_REFRESHES} seconds apart.\n+ */\n+@InterfaceAudience.Private\n+public class MasterAddressRefresher implements Closeable {\n+  private static final Logger LOG = LoggerFactory.getLogger(MasterAddressRefresher.class);\n+  public static final String PERIODIC_REFRESH_INTERVAL_SECS =\n+      \"hbase.client.master_registry.refresh_interval_secs\";\n+  private static final int PERIODIC_REFRESH_INTERVAL_SECS_DEFAULT = 300;\n+  public static final String MIN_SECS_BETWEEN_REFRESHES =\n+      \"hbase.client.master_registry.min_secs_between_refreshes\";\n+  private static final long MIN_SECS_BETWEEN_REFRESHES_DEFAULT = 60;\n+\n+  private final ExecutorService pool;\n+  private final MasterRegistry registry;\n+  private final long periodicRefreshMs;\n+  private final long timeBetweenRefreshesMs;\n+  private final Object refreshMasters = new Object();\n+\n+  @Override\n+  public void close() {\n+    pool.shutdownNow();\n+  }\n+\n+  /**\n+   * Thread that refreshes the master end points until it is interrupted via {@link #close()}.\n+   * Multiple callers attempting to refresh at the same time synchronize on {@link #refreshMasters}.\n+   */\n+  private class RefreshThread implements Runnable {\n+    @Override\n+    public void run() {\n+      long lastRpcTs = 0;\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(periodicRefreshMs);\n+          }\n+          long currentTs = EnvironmentEdgeManager.currentTime();\n+          if (lastRpcTs != 0 && currentTs - lastRpcTs <= timeBetweenRefreshesMs) {\n+            continue;\n+          }\n+          lastRpcTs = currentTs;\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(registry.getMasters().get());\n+          registry.populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);\n+          break;\n+        } catch (ExecutionException | IOException e) {\n+          LOG.debug(\"Error populating latest list of masters.\", e);\n+        }\n+      }\n+    }\n+  }\n+\n+  MasterAddressRefresher(Configuration conf, MasterRegistry registry) {\n+    pool = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI1MjA0MA=="}, "originalCommit": {"oid": "48157bbfec66e850357f9056d48eb7c84041ed91"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1OTY3Mw==", "bodyText": "But I do not think we will throw IllegalStateException? Usually we will throw IOException here? IllegalStateException is an unchecked exception...", "url": "https://github.com/apache/hbase/pull/2130#discussion_r473659673", "createdAt": "2020-08-20T06:47:11Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -259,17 +311,40 @@ private RegionLocations transformMetaRegionLocations(GetMetaRegionLocationsRespo\n       .thenApply(GetClusterIdResponse::getClusterId);\n   }\n \n-  private ServerName transformServerName(GetActiveMasterResponse resp) {\n-    return ProtobufUtil.toServerName(resp.getServerName());\n+  private static boolean hasActiveMaster(GetMastersResponse resp) {\n+    List<GetMastersResponseEntry> activeMasters =\n+        resp.getMasterServersList().stream().filter(GetMastersResponseEntry::getIsActive).collect(\n+        Collectors.toList());\n+    return activeMasters.size() == 1;\n+  }\n+\n+  private static ServerName filterActiveMaster(GetMastersResponse resp) {\n+    List<GetMastersResponseEntry> activeMasters =\n+        resp.getMasterServersList().stream().filter(GetMastersResponseEntry::getIsActive).collect(\n+            Collectors.toList());\n+    Preconditions.checkState(activeMasters.size() == 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNjkwMA=="}, "originalCommit": {"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa"}, "originalPosition": 207}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6cd028727d93eb34df1f01080e9e01f39ecd3242", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/6cd028727d93eb34df1f01080e9e01f39ecd3242", "committedDate": "2020-08-17T07:25:37Z", "message": "Cache backup masters in ActiveMasterManager"}, "afterCommit": {"oid": "f0c146fe40c4b59d294971b8916aff2f724c6808", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/f0c146fe40c4b59d294971b8916aff2f724c6808", "committedDate": "2020-08-24T05:04:23Z", "message": "Cache backup masters in ActiveMasterManager"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4Njk3MjUy", "url": "https://github.com/apache/hbase/pull/2130#pullrequestreview-468697252", "createdAt": "2020-08-17T17:57:29Z", "commit": {"oid": "6cd028727d93eb34df1f01080e9e01f39ecd3242"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNzo1NzoyOVrOHB0DgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQwOTowMToyMFrOHFa0Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2MzQ4OQ==", "bodyText": "nit: TimeUnit.SECONDS.toMillis(conf.getLong(,))", "url": "https://github.com/apache/hbase/pull/2130#discussion_r471663489", "createdAt": "2020-08-17T17:57:29Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterAddressRefresher.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.base.Preconditions;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos.ClientMetaService;\n+\n+/**\n+ * Thread safe utility that keeps master end points used by {@link MasterRegistry} up to date. This\n+ * uses the RPC {@link ClientMetaService#getMasters} to fetch the latest list of registered masters.\n+ * By default the refresh happens periodically (configured via\n+ * {@link #PERIODIC_REFRESH_INTERVAL_SECS}). The refresh can also be triggered on demand via\n+ * {@link #refreshNow()}. To prevent a flood of on-demand refreshes we expect that any attempts two\n+ * should be spaced at least {@link #MIN_SECS_BETWEEN_REFRESHES} seconds apart.\n+ */\n+@InterfaceAudience.Private\n+public class MasterAddressRefresher implements Closeable {\n+  private static final Logger LOG = LoggerFactory.getLogger(MasterAddressRefresher.class);\n+  public static final String PERIODIC_REFRESH_INTERVAL_SECS =\n+      \"hbase.client.master_registry.refresh_interval_secs\";\n+  private static final int PERIODIC_REFRESH_INTERVAL_SECS_DEFAULT = 300;\n+  public static final String MIN_SECS_BETWEEN_REFRESHES =\n+      \"hbase.client.master_registry.min_secs_between_refreshes\";\n+  private static final long MIN_SECS_BETWEEN_REFRESHES_DEFAULT = 60;\n+\n+  private final ExecutorService pool;\n+  private final MasterRegistry registry;\n+  private final long periodicRefreshMs;\n+  private final long timeBetweenRefreshesMs;\n+  private final Object refreshMasters = new Object();\n+\n+  @Override\n+  public void close() {\n+    pool.shutdownNow();\n+  }\n+\n+  /**\n+   * Thread that refreshes the master end points until it is interrupted via {@link #close()}.\n+   * Multiple callers attempting to refresh at the same time synchronize on {@link #refreshMasters}.\n+   */\n+  private class RefreshThread implements Runnable {\n+    @Override\n+    public void run() {\n+      long lastRpcTs = 0;\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(periodicRefreshMs);\n+          }\n+          long currentTs = EnvironmentEdgeManager.currentTime();\n+          if (lastRpcTs != 0 && currentTs - lastRpcTs <= timeBetweenRefreshesMs) {\n+            continue;\n+          }\n+          lastRpcTs = currentTs;\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(registry.getMasters().get());\n+          registry.populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);\n+          break;\n+        } catch (ExecutionException | IOException e) {\n+          LOG.debug(\"Error populating latest list of masters.\", e);\n+        }\n+      }\n+    }\n+  }\n+\n+  MasterAddressRefresher(Configuration conf, MasterRegistry registry) {\n+    pool = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()\n+        .setNameFormat(\"master-registry-refresh-end-points\").setDaemon(true).build());\n+    periodicRefreshMs = 1000 * conf.getLong(PERIODIC_REFRESH_INTERVAL_SECS,\n+        PERIODIC_REFRESH_INTERVAL_SECS_DEFAULT);\n+    timeBetweenRefreshesMs = 1000 * conf.getLong(MIN_SECS_BETWEEN_REFRESHES,\n+        MIN_SECS_BETWEEN_REFRESHES_DEFAULT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd028727d93eb34df1f01080e9e01f39ecd3242"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2NDU0NA==", "bodyText": "nit: keep this int similar to PERIODIC_REFRESH_INTERVAL_SECS_DEFAULT?", "url": "https://github.com/apache/hbase/pull/2130#discussion_r471664544", "createdAt": "2020-08-17T17:59:28Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterAddressRefresher.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.base.Preconditions;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos.ClientMetaService;\n+\n+/**\n+ * Thread safe utility that keeps master end points used by {@link MasterRegistry} up to date. This\n+ * uses the RPC {@link ClientMetaService#getMasters} to fetch the latest list of registered masters.\n+ * By default the refresh happens periodically (configured via\n+ * {@link #PERIODIC_REFRESH_INTERVAL_SECS}). The refresh can also be triggered on demand via\n+ * {@link #refreshNow()}. To prevent a flood of on-demand refreshes we expect that any attempts two\n+ * should be spaced at least {@link #MIN_SECS_BETWEEN_REFRESHES} seconds apart.\n+ */\n+@InterfaceAudience.Private\n+public class MasterAddressRefresher implements Closeable {\n+  private static final Logger LOG = LoggerFactory.getLogger(MasterAddressRefresher.class);\n+  public static final String PERIODIC_REFRESH_INTERVAL_SECS =\n+      \"hbase.client.master_registry.refresh_interval_secs\";\n+  private static final int PERIODIC_REFRESH_INTERVAL_SECS_DEFAULT = 300;\n+  public static final String MIN_SECS_BETWEEN_REFRESHES =\n+      \"hbase.client.master_registry.min_secs_between_refreshes\";\n+  private static final long MIN_SECS_BETWEEN_REFRESHES_DEFAULT = 60;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd028727d93eb34df1f01080e9e01f39ecd3242"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2NzIyMA==", "bodyText": "We are aborting refresh by breaking out of the loop and basically, we are done refreshing master stubs. Better to log this at ERROR?", "url": "https://github.com/apache/hbase/pull/2130#discussion_r471667220", "createdAt": "2020-08-17T18:04:43Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterAddressRefresher.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.base.Preconditions;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos.ClientMetaService;\n+\n+/**\n+ * Thread safe utility that keeps master end points used by {@link MasterRegistry} up to date. This\n+ * uses the RPC {@link ClientMetaService#getMasters} to fetch the latest list of registered masters.\n+ * By default the refresh happens periodically (configured via\n+ * {@link #PERIODIC_REFRESH_INTERVAL_SECS}). The refresh can also be triggered on demand via\n+ * {@link #refreshNow()}. To prevent a flood of on-demand refreshes we expect that any attempts two\n+ * should be spaced at least {@link #MIN_SECS_BETWEEN_REFRESHES} seconds apart.\n+ */\n+@InterfaceAudience.Private\n+public class MasterAddressRefresher implements Closeable {\n+  private static final Logger LOG = LoggerFactory.getLogger(MasterAddressRefresher.class);\n+  public static final String PERIODIC_REFRESH_INTERVAL_SECS =\n+      \"hbase.client.master_registry.refresh_interval_secs\";\n+  private static final int PERIODIC_REFRESH_INTERVAL_SECS_DEFAULT = 300;\n+  public static final String MIN_SECS_BETWEEN_REFRESHES =\n+      \"hbase.client.master_registry.min_secs_between_refreshes\";\n+  private static final long MIN_SECS_BETWEEN_REFRESHES_DEFAULT = 60;\n+\n+  private final ExecutorService pool;\n+  private final MasterRegistry registry;\n+  private final long periodicRefreshMs;\n+  private final long timeBetweenRefreshesMs;\n+  private final Object refreshMasters = new Object();\n+\n+  @Override\n+  public void close() {\n+    pool.shutdownNow();\n+  }\n+\n+  /**\n+   * Thread that refreshes the master end points until it is interrupted via {@link #close()}.\n+   * Multiple callers attempting to refresh at the same time synchronize on {@link #refreshMasters}.\n+   */\n+  private class RefreshThread implements Runnable {\n+    @Override\n+    public void run() {\n+      long lastRpcTs = 0;\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(periodicRefreshMs);\n+          }\n+          long currentTs = EnvironmentEdgeManager.currentTime();\n+          if (lastRpcTs != 0 && currentTs - lastRpcTs <= timeBetweenRefreshesMs) {\n+            continue;\n+          }\n+          lastRpcTs = currentTs;\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(registry.getMasters().get());\n+          registry.populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6cd028727d93eb34df1f01080e9e01f39ecd3242"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0NDI0Nw==", "bodyText": "nit: return Collections.emptyList();", "url": "https://github.com/apache/hbase/pull/2130#discussion_r475444247", "createdAt": "2020-08-24T09:01:20Z", "author": {"login": "virajjasani"}, "path": "hbase-zookeeper/src/main/java/org/apache/hadoop/hbase/zookeeper/MasterAddressTracker.java", "diffHunk": "@@ -278,4 +282,59 @@ public static boolean deleteIfEquals(ZKWatcher zkw, final String content) {\n \n     return false;\n   }\n+\n+  public List<ServerName> getBackupMasters() throws InterruptedIOException {\n+    return getBackupMastersAndRenewWatch(watcher);\n+  }\n+\n+  /**\n+   * Retrieves the list of registered backup masters and renews a watch on the znode for children\n+   * updates.\n+   * @param zkw Zookeeper watcher to use\n+   * @return List of backup masters.\n+   * @throws InterruptedIOException\n+   */\n+  public static List<ServerName> getBackupMastersAndRenewWatch(\n+      ZKWatcher zkw) throws InterruptedIOException {\n+    // Build Set of backup masters from ZK nodes\n+    List<String> backupMasterStrings;\n+    try {\n+      backupMasterStrings = ZKUtil.listChildrenAndWatchForNewChildren(zkw,\n+          zkw.getZNodePaths().backupMasterAddressesZNode);\n+    } catch (KeeperException e) {\n+      LOG.warn(zkw.prefix(\"Unable to list backup servers\"), e);\n+      backupMasterStrings = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0c146fe40c4b59d294971b8916aff2f724c6808"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNzEyNjg0", "url": "https://github.com/apache/hbase/pull/2130#pullrequestreview-473712684", "createdAt": "2020-08-24T17:30:57Z", "commit": {"oid": "97375bc394ce3b3f85236acce6a1bd6ea883de43"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NDY3MzEy", "url": "https://github.com/apache/hbase/pull/2130#pullrequestreview-474467312", "createdAt": "2020-08-25T13:13:54Z", "commit": {"oid": "97375bc394ce3b3f85236acce6a1bd6ea883de43"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "275a38e1533eafa1d4bd1d50c13bcecd9a397ea8", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/275a38e1533eafa1d4bd1d50c13bcecd9a397ea8", "committedDate": "2020-08-25T14:22:11Z", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either periodic (5 mins) or any registry RPC failure.\nMaster server information is cached in masters to avoid repeated\nZK lookups.\n\nUpdates the client side connection metrics to maintain a counter\nper RPC type so that clients have visibility into counts grouped\nby RPC method name.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed.\n\nSigned-off-by: Nick Dimiduk <ndimiduk@apache.org>\nSigned-off-by: Viraj Jasani <vjasani@apache.org>\nSigned-off-by: Duo Zhang <zhangduo@apache.org>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "97375bc394ce3b3f85236acce6a1bd6ea883de43", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/97375bc394ce3b3f85236acce6a1bd6ea883de43", "committedDate": "2020-08-24T17:11:50Z", "message": "Address review comments."}, "afterCommit": {"oid": "275a38e1533eafa1d4bd1d50c13bcecd9a397ea8", "author": {"user": {"login": "bharathv", "name": "Bharath Vissapragada"}}, "url": "https://github.com/apache/hbase/commit/275a38e1533eafa1d4bd1d50c13bcecd9a397ea8", "committedDate": "2020-08-25T14:22:11Z", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either periodic (5 mins) or any registry RPC failure.\nMaster server information is cached in masters to avoid repeated\nZK lookups.\n\nUpdates the client side connection metrics to maintain a counter\nper RPC type so that clients have visibility into counts grouped\nby RPC method name.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed.\n\nSigned-off-by: Nick Dimiduk <ndimiduk@apache.org>\nSigned-off-by: Viraj Jasani <vjasani@apache.org>\nSigned-off-by: Duo Zhang <zhangduo@apache.org>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4062, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}