{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5Mzk1MzA4", "number": 1593, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjo1MDoyM1rOD5Ex0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzo1MzowMlrOD5n0Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTczNzEyOnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjo1MDoyM1rOGQJCUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjo1MDoyM1rOGQJCUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3ODQ1MA==", "bodyText": "nit: HConstant stuff need to be updated.", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419578450", "createdAt": "2020-05-04T16:50:23Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -61,53 +65,79 @@\n /**\n  * Master based registry implementation. Makes RPCs to the configured master addresses from config\n  * {@value org.apache.hadoop.hbase.HConstants#MASTER_ADDRS_KEY}.\n- *\n+ * <p/>\n  * It supports hedged reads, which can be enabled by setting\n  * {@value org.apache.hadoop.hbase.HConstants#MASTER_REGISTRY_ENABLE_HEDGED_READS_KEY} to True. Fan", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTgwODA1OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzowNzoyNVrOGQJttg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzozNjoxNlrOGQ_a3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU4OTU1OA==", "bodyText": "Starting to wonder, why this didn't get flagged in tests. I guess there is some test hole with token based auth..", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419589558", "createdAt": "2020-05-04T17:07:25Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -61,53 +65,79 @@\n /**\n  * Master based registry implementation. Makes RPCs to the configured master addresses from config\n  * {@value org.apache.hadoop.hbase.HConstants#MASTER_ADDRS_KEY}.\n- *\n+ * <p/>\n  * It supports hedged reads, which can be enabled by setting\n  * {@value org.apache.hadoop.hbase.HConstants#MASTER_REGISTRY_ENABLE_HEDGED_READS_KEY} to True. Fan\n  * out the requests batch is controlled by\n  * {@value org.apache.hadoop.hbase.HConstants#HBASE_RPCS_HEDGED_REQS_FANOUT_KEY}.\n- *\n+ * <p/>\n  * TODO: Handle changes to the configuration dynamically without having to restart the client.\n  */\n @InterfaceAudience.Private\n public class MasterRegistry implements ConnectionRegistry {\n+\n+  /** Configuration key that controls the fan out of requests **/\n+  public static final String MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY =\n+    \"hbase.client.master_registry.hedged.fanout\";\n+\n+  /** Default value for the fan out of hedged requests. **/\n+  public static final int MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT = 2;\n+\n   private static final String MASTER_ADDRS_CONF_SEPARATOR = \",\";\n \n+  private final int hedgedReadFanOut;\n+\n   // Configured list of masters to probe the meta information from.\n-  private final Set<ServerName> masterServers;\n+  private final Set<ServerName> masterAddrs;\n+\n+  private final List<ClientMetaService.Interface> masterStubs;\n \n   // RPC client used to talk to the masters.\n   private final RpcClient rpcClient;\n   private final RpcControllerFactory rpcControllerFactory;\n-  private final int rpcTimeoutMs;\n-\n-  MasterRegistry(Configuration conf) throws UnknownHostException {\n-    boolean hedgedReadsEnabled = conf.getBoolean(MASTER_REGISTRY_ENABLE_HEDGED_READS_KEY,\n-        MASTER_REGISTRY_ENABLE_HEDGED_READS_DEFAULT);\n-    Configuration finalConf;\n-    if (!hedgedReadsEnabled) {\n-      // If hedged reads are disabled, it is equivalent to setting a fan out of 1. We make a copy of\n-      // the configuration so that other places reusing this reference is not affected.\n-      finalConf = new Configuration(conf);\n-      finalConf.setInt(HConstants.HBASE_RPCS_HEDGED_REQS_FANOUT_KEY, 1);\n-    } else {\n-      finalConf = conf;\n+\n+  /**\n+   * Parses the list of master addresses from the provided configuration. Supported format is comma\n+   * separated host[:port] values. If no port number if specified, default master port is assumed.\n+   * @param conf Configuration to parse from.\n+   */\n+  private static Set<ServerName> parseMasterAddrs(Configuration conf) throws UnknownHostException {\n+    Set<ServerName> masterAddrs = new HashSet<>();\n+    String configuredMasters = getMasterAddr(conf);\n+    for (String masterAddr : configuredMasters.split(MASTER_ADDRS_CONF_SEPARATOR)) {\n+      HostAndPort masterHostPort =\n+        HostAndPort.fromString(masterAddr.trim()).withDefaultPort(HConstants.DEFAULT_MASTER_PORT);\n+      masterAddrs.add(ServerName.valueOf(masterHostPort.toString(), ServerName.NON_STARTCODE));\n     }\n-    if (conf.get(MASTER_ADDRS_KEY) != null) {\n-      finalConf.set(MASTER_ADDRS_KEY, conf.get(MASTER_ADDRS_KEY));\n+    Preconditions.checkArgument(!masterAddrs.isEmpty(), \"At least one master address is needed\");\n+    return masterAddrs;\n+  }\n+\n+  MasterRegistry(Configuration conf) throws IOException {\n+    this.hedgedReadFanOut = conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n+      MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT);\n+    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+      conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n+    // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5OTc5OA==", "bodyText": "Just because we do not have a test where MasterRegistry is enabled and we use cluster id to select authentication. Most tests in HBase do not need authentication.", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419799798", "createdAt": "2020-05-05T00:12:00Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -61,53 +65,79 @@\n /**\n  * Master based registry implementation. Makes RPCs to the configured master addresses from config\n  * {@value org.apache.hadoop.hbase.HConstants#MASTER_ADDRS_KEY}.\n- *\n+ * <p/>\n  * It supports hedged reads, which can be enabled by setting\n  * {@value org.apache.hadoop.hbase.HConstants#MASTER_REGISTRY_ENABLE_HEDGED_READS_KEY} to True. Fan\n  * out the requests batch is controlled by\n  * {@value org.apache.hadoop.hbase.HConstants#HBASE_RPCS_HEDGED_REQS_FANOUT_KEY}.\n- *\n+ * <p/>\n  * TODO: Handle changes to the configuration dynamically without having to restart the client.\n  */\n @InterfaceAudience.Private\n public class MasterRegistry implements ConnectionRegistry {\n+\n+  /** Configuration key that controls the fan out of requests **/\n+  public static final String MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY =\n+    \"hbase.client.master_registry.hedged.fanout\";\n+\n+  /** Default value for the fan out of hedged requests. **/\n+  public static final int MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT = 2;\n+\n   private static final String MASTER_ADDRS_CONF_SEPARATOR = \",\";\n \n+  private final int hedgedReadFanOut;\n+\n   // Configured list of masters to probe the meta information from.\n-  private final Set<ServerName> masterServers;\n+  private final Set<ServerName> masterAddrs;\n+\n+  private final List<ClientMetaService.Interface> masterStubs;\n \n   // RPC client used to talk to the masters.\n   private final RpcClient rpcClient;\n   private final RpcControllerFactory rpcControllerFactory;\n-  private final int rpcTimeoutMs;\n-\n-  MasterRegistry(Configuration conf) throws UnknownHostException {\n-    boolean hedgedReadsEnabled = conf.getBoolean(MASTER_REGISTRY_ENABLE_HEDGED_READS_KEY,\n-        MASTER_REGISTRY_ENABLE_HEDGED_READS_DEFAULT);\n-    Configuration finalConf;\n-    if (!hedgedReadsEnabled) {\n-      // If hedged reads are disabled, it is equivalent to setting a fan out of 1. We make a copy of\n-      // the configuration so that other places reusing this reference is not affected.\n-      finalConf = new Configuration(conf);\n-      finalConf.setInt(HConstants.HBASE_RPCS_HEDGED_REQS_FANOUT_KEY, 1);\n-    } else {\n-      finalConf = conf;\n+\n+  /**\n+   * Parses the list of master addresses from the provided configuration. Supported format is comma\n+   * separated host[:port] values. If no port number if specified, default master port is assumed.\n+   * @param conf Configuration to parse from.\n+   */\n+  private static Set<ServerName> parseMasterAddrs(Configuration conf) throws UnknownHostException {\n+    Set<ServerName> masterAddrs = new HashSet<>();\n+    String configuredMasters = getMasterAddr(conf);\n+    for (String masterAddr : configuredMasters.split(MASTER_ADDRS_CONF_SEPARATOR)) {\n+      HostAndPort masterHostPort =\n+        HostAndPort.fromString(masterAddr.trim()).withDefaultPort(HConstants.DEFAULT_MASTER_PORT);\n+      masterAddrs.add(ServerName.valueOf(masterHostPort.toString(), ServerName.NON_STARTCODE));\n     }\n-    if (conf.get(MASTER_ADDRS_KEY) != null) {\n-      finalConf.set(MASTER_ADDRS_KEY, conf.get(MASTER_ADDRS_KEY));\n+    Preconditions.checkArgument(!masterAddrs.isEmpty(), \"At least one master address is needed\");\n+    return masterAddrs;\n+  }\n+\n+  MasterRegistry(Configuration conf) throws IOException {\n+    this.hedgedReadFanOut = conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n+      MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT);\n+    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+      conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n+    // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU4OTU1OA=="}, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ2OTQ2OA==", "bodyText": "Ya, thats what I meant.", "url": "https://github.com/apache/hbase/pull/1593#discussion_r420469468", "createdAt": "2020-05-05T23:36:16Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -61,53 +65,79 @@\n /**\n  * Master based registry implementation. Makes RPCs to the configured master addresses from config\n  * {@value org.apache.hadoop.hbase.HConstants#MASTER_ADDRS_KEY}.\n- *\n+ * <p/>\n  * It supports hedged reads, which can be enabled by setting\n  * {@value org.apache.hadoop.hbase.HConstants#MASTER_REGISTRY_ENABLE_HEDGED_READS_KEY} to True. Fan\n  * out the requests batch is controlled by\n  * {@value org.apache.hadoop.hbase.HConstants#HBASE_RPCS_HEDGED_REQS_FANOUT_KEY}.\n- *\n+ * <p/>\n  * TODO: Handle changes to the configuration dynamically without having to restart the client.\n  */\n @InterfaceAudience.Private\n public class MasterRegistry implements ConnectionRegistry {\n+\n+  /** Configuration key that controls the fan out of requests **/\n+  public static final String MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY =\n+    \"hbase.client.master_registry.hedged.fanout\";\n+\n+  /** Default value for the fan out of hedged requests. **/\n+  public static final int MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT = 2;\n+\n   private static final String MASTER_ADDRS_CONF_SEPARATOR = \",\";\n \n+  private final int hedgedReadFanOut;\n+\n   // Configured list of masters to probe the meta information from.\n-  private final Set<ServerName> masterServers;\n+  private final Set<ServerName> masterAddrs;\n+\n+  private final List<ClientMetaService.Interface> masterStubs;\n \n   // RPC client used to talk to the masters.\n   private final RpcClient rpcClient;\n   private final RpcControllerFactory rpcControllerFactory;\n-  private final int rpcTimeoutMs;\n-\n-  MasterRegistry(Configuration conf) throws UnknownHostException {\n-    boolean hedgedReadsEnabled = conf.getBoolean(MASTER_REGISTRY_ENABLE_HEDGED_READS_KEY,\n-        MASTER_REGISTRY_ENABLE_HEDGED_READS_DEFAULT);\n-    Configuration finalConf;\n-    if (!hedgedReadsEnabled) {\n-      // If hedged reads are disabled, it is equivalent to setting a fan out of 1. We make a copy of\n-      // the configuration so that other places reusing this reference is not affected.\n-      finalConf = new Configuration(conf);\n-      finalConf.setInt(HConstants.HBASE_RPCS_HEDGED_REQS_FANOUT_KEY, 1);\n-    } else {\n-      finalConf = conf;\n+\n+  /**\n+   * Parses the list of master addresses from the provided configuration. Supported format is comma\n+   * separated host[:port] values. If no port number if specified, default master port is assumed.\n+   * @param conf Configuration to parse from.\n+   */\n+  private static Set<ServerName> parseMasterAddrs(Configuration conf) throws UnknownHostException {\n+    Set<ServerName> masterAddrs = new HashSet<>();\n+    String configuredMasters = getMasterAddr(conf);\n+    for (String masterAddr : configuredMasters.split(MASTER_ADDRS_CONF_SEPARATOR)) {\n+      HostAndPort masterHostPort =\n+        HostAndPort.fromString(masterAddr.trim()).withDefaultPort(HConstants.DEFAULT_MASTER_PORT);\n+      masterAddrs.add(ServerName.valueOf(masterHostPort.toString(), ServerName.NON_STARTCODE));\n     }\n-    if (conf.get(MASTER_ADDRS_KEY) != null) {\n-      finalConf.set(MASTER_ADDRS_KEY, conf.get(MASTER_ADDRS_KEY));\n+    Preconditions.checkArgument(!masterAddrs.isEmpty(), \"At least one master address is needed\");\n+    return masterAddrs;\n+  }\n+\n+  MasterRegistry(Configuration conf) throws IOException {\n+    this.hedgedReadFanOut = conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n+      MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT);\n+    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+      conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n+    // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU4OTU1OA=="}, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTgzMzIxOnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzoxMzozNlrOGQJ82g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMTozMDoyOFrOGQXy-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5MzQzNA==", "bodyText": "nit: Add a comment that this async, because of the way we are creating the stubs, just to clarify?", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419593434", "createdAt": "2020-05-04T17:13:36Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -117,105 +147,97 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     return String.format(\"%s:%d\", hostname, port);\n   }\n \n-  /**\n-   * @return Stub needed to make RPC using a hedged channel to the master end points.\n-   */\n-  private ClientMetaService.Interface getMasterStub() throws IOException {\n-    return ClientMetaService.newStub(\n-        rpcClient.createHedgedRpcChannel(masterServers, User.getCurrent(), rpcTimeoutMs));\n+  @FunctionalInterface\n+  private interface Callable<T> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgyMDI4MA==", "bodyText": "We have a RpcCallback in the parameters so I think it is enough to show that this is asynchronous?", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419820280", "createdAt": "2020-05-05T01:30:28Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -117,105 +147,97 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     return String.format(\"%s:%d\", hostname, port);\n   }\n \n-  /**\n-   * @return Stub needed to make RPC using a hedged channel to the master end points.\n-   */\n-  private ClientMetaService.Interface getMasterStub() throws IOException {\n-    return ClientMetaService.newStub(\n-        rpcClient.createHedgedRpcChannel(masterServers, User.getCurrent(), rpcTimeoutMs));\n+  @FunctionalInterface\n+  private interface Callable<T> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5MzQzNA=="}, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTg1MDc3OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzoxODoxMFrOGQKHsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMzowNjo1N1rOGQZBxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5NjIxMA==", "bodyText": "I think this could use a comment around logic.., without that, would be difficult to follow.", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419596210", "createdAt": "2020-05-04T17:18:10Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -117,105 +147,97 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     return String.format(\"%s:%d\", hostname, port);\n   }\n \n-  /**\n-   * @return Stub needed to make RPC using a hedged channel to the master end points.\n-   */\n-  private ClientMetaService.Interface getMasterStub() throws IOException {\n-    return ClientMetaService.newStub(\n-        rpcClient.createHedgedRpcChannel(masterServers, User.getCurrent(), rpcTimeoutMs));\n+  @FunctionalInterface\n+  private interface Callable<T> {\n+    void call(HBaseRpcController controller, ClientMetaService.Interface stub, RpcCallback<T> done);\n   }\n \n-  /**\n-   * Parses the list of master addresses from the provided configuration. Supported format is\n-   * comma separated host[:port] values. If no port number if specified, default master port is\n-   * assumed.\n-   * @param conf Configuration to parse from.\n-   */\n-  private void parseMasterAddrs(Configuration conf) throws UnknownHostException {\n-    String configuredMasters = getMasterAddr(conf);\n-    for (String masterAddr: configuredMasters.split(MASTER_ADDRS_CONF_SEPARATOR)) {\n-      HostAndPort masterHostPort =\n-          HostAndPort.fromString(masterAddr.trim()).withDefaultPort(HConstants.DEFAULT_MASTER_PORT);\n-      masterServers.add(ServerName.valueOf(masterHostPort.toString(), ServerName.NON_STARTCODE));\n-    }\n-    Preconditions.checkArgument(!masterServers.isEmpty(), \"At least one master address is needed\");\n+  private <T extends Message> CompletableFuture<T> call(ClientMetaService.Interface stub,\n+    Callable<T> callable) {\n+    HBaseRpcController controller = rpcControllerFactory.newController();\n+    CompletableFuture<T> future = new CompletableFuture<>();\n+    callable.call(controller, stub, resp -> {\n+      if (controller.failed()) {\n+        future.completeExceptionally(controller.getFailed());\n+      } else {\n+        future.complete(resp);\n+      }\n+    });\n+    return future;\n   }\n \n-  @VisibleForTesting\n-  public Set<ServerName> getParsedMasterServers() {\n-    return Collections.unmodifiableSet(masterServers);\n+  private IOException badResponse(String debug) {\n+    return new IOException(String.format(\"Invalid result for request %s. Will be retried\", debug));\n   }\n \n-  /**\n-   * Returns a call back that can be passed along to the non-blocking rpc call. It is invoked once\n-   * the rpc finishes and the response is propagated to the passed future.\n-   * @param future Result future to which the rpc response is propagated.\n-   * @param isValidResp Checks if the rpc response has a valid result.\n-   * @param transformResult Transforms the result to a different form as expected by callers.\n-   * @param hrc RpcController instance for this rpc.\n-   * @param debug Debug message passed along to the caller in case of exceptions.\n-   * @param <T> RPC result type.\n-   * @param <R> Transformed type of the result.\n-   * @return A call back that can be embedded in the non-blocking rpc call.\n-   */\n-  private <T, R> RpcCallback<T> getRpcCallBack(CompletableFuture<R> future,\n-      Predicate<T> isValidResp, Function<T, R> transformResult, HBaseRpcController hrc,\n-      final String debug) {\n-    return rpcResult -> {\n-      if (rpcResult == null) {\n-        future.completeExceptionally(\n-            new MasterRegistryFetchException(masterServers, hrc.getFailed()));\n-        return;\n-      }\n-      if (!isValidResp.test(rpcResult)) {\n-        // Rpc returned ok, but result was malformed.\n-        future.completeExceptionally(new IOException(\n-            String.format(\"Invalid result for request %s. Will be retried\", debug)));\n-        return;\n-      }\n-      future.complete(transformResult.apply(rpcResult));\n-    };\n+  // send requests concurrently to hedgedReadsFanout masters\n+  private <T extends Message> void groupCall(CompletableFuture<T> future, int startIndexInclusive,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg0MDQ1NA==", "bodyText": "I added more comments for this method.", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419840454", "createdAt": "2020-05-05T03:06:57Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -117,105 +147,97 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     return String.format(\"%s:%d\", hostname, port);\n   }\n \n-  /**\n-   * @return Stub needed to make RPC using a hedged channel to the master end points.\n-   */\n-  private ClientMetaService.Interface getMasterStub() throws IOException {\n-    return ClientMetaService.newStub(\n-        rpcClient.createHedgedRpcChannel(masterServers, User.getCurrent(), rpcTimeoutMs));\n+  @FunctionalInterface\n+  private interface Callable<T> {\n+    void call(HBaseRpcController controller, ClientMetaService.Interface stub, RpcCallback<T> done);\n   }\n \n-  /**\n-   * Parses the list of master addresses from the provided configuration. Supported format is\n-   * comma separated host[:port] values. If no port number if specified, default master port is\n-   * assumed.\n-   * @param conf Configuration to parse from.\n-   */\n-  private void parseMasterAddrs(Configuration conf) throws UnknownHostException {\n-    String configuredMasters = getMasterAddr(conf);\n-    for (String masterAddr: configuredMasters.split(MASTER_ADDRS_CONF_SEPARATOR)) {\n-      HostAndPort masterHostPort =\n-          HostAndPort.fromString(masterAddr.trim()).withDefaultPort(HConstants.DEFAULT_MASTER_PORT);\n-      masterServers.add(ServerName.valueOf(masterHostPort.toString(), ServerName.NON_STARTCODE));\n-    }\n-    Preconditions.checkArgument(!masterServers.isEmpty(), \"At least one master address is needed\");\n+  private <T extends Message> CompletableFuture<T> call(ClientMetaService.Interface stub,\n+    Callable<T> callable) {\n+    HBaseRpcController controller = rpcControllerFactory.newController();\n+    CompletableFuture<T> future = new CompletableFuture<>();\n+    callable.call(controller, stub, resp -> {\n+      if (controller.failed()) {\n+        future.completeExceptionally(controller.getFailed());\n+      } else {\n+        future.complete(resp);\n+      }\n+    });\n+    return future;\n   }\n \n-  @VisibleForTesting\n-  public Set<ServerName> getParsedMasterServers() {\n-    return Collections.unmodifiableSet(masterServers);\n+  private IOException badResponse(String debug) {\n+    return new IOException(String.format(\"Invalid result for request %s. Will be retried\", debug));\n   }\n \n-  /**\n-   * Returns a call back that can be passed along to the non-blocking rpc call. It is invoked once\n-   * the rpc finishes and the response is propagated to the passed future.\n-   * @param future Result future to which the rpc response is propagated.\n-   * @param isValidResp Checks if the rpc response has a valid result.\n-   * @param transformResult Transforms the result to a different form as expected by callers.\n-   * @param hrc RpcController instance for this rpc.\n-   * @param debug Debug message passed along to the caller in case of exceptions.\n-   * @param <T> RPC result type.\n-   * @param <R> Transformed type of the result.\n-   * @return A call back that can be embedded in the non-blocking rpc call.\n-   */\n-  private <T, R> RpcCallback<T> getRpcCallBack(CompletableFuture<R> future,\n-      Predicate<T> isValidResp, Function<T, R> transformResult, HBaseRpcController hrc,\n-      final String debug) {\n-    return rpcResult -> {\n-      if (rpcResult == null) {\n-        future.completeExceptionally(\n-            new MasterRegistryFetchException(masterServers, hrc.getFailed()));\n-        return;\n-      }\n-      if (!isValidResp.test(rpcResult)) {\n-        // Rpc returned ok, but result was malformed.\n-        future.completeExceptionally(new IOException(\n-            String.format(\"Invalid result for request %s. Will be retried\", debug)));\n-        return;\n-      }\n-      future.complete(transformResult.apply(rpcResult));\n-    };\n+  // send requests concurrently to hedgedReadsFanout masters\n+  private <T extends Message> void groupCall(CompletableFuture<T> future, int startIndexInclusive,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5NjIxMA=="}, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTkzNzMyOnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzo0MDoyOFrOGQK9pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzo0MDoyOFrOGQK9pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxMDAyMg==", "bodyText": "Randomize the master addrs so that the client RPC pattern is non-deterministic?", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419610022", "createdAt": "2020-05-04T17:40:28Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -61,53 +65,79 @@\n /**\n  * Master based registry implementation. Makes RPCs to the configured master addresses from config\n  * {@value org.apache.hadoop.hbase.HConstants#MASTER_ADDRS_KEY}.\n- *\n+ * <p/>\n  * It supports hedged reads, which can be enabled by setting\n  * {@value org.apache.hadoop.hbase.HConstants#MASTER_REGISTRY_ENABLE_HEDGED_READS_KEY} to True. Fan\n  * out the requests batch is controlled by\n  * {@value org.apache.hadoop.hbase.HConstants#HBASE_RPCS_HEDGED_REQS_FANOUT_KEY}.\n- *\n+ * <p/>\n  * TODO: Handle changes to the configuration dynamically without having to restart the client.\n  */\n @InterfaceAudience.Private\n public class MasterRegistry implements ConnectionRegistry {\n+\n+  /** Configuration key that controls the fan out of requests **/\n+  public static final String MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY =\n+    \"hbase.client.master_registry.hedged.fanout\";\n+\n+  /** Default value for the fan out of hedged requests. **/\n+  public static final int MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT = 2;\n+\n   private static final String MASTER_ADDRS_CONF_SEPARATOR = \",\";\n \n+  private final int hedgedReadFanOut;\n+\n   // Configured list of masters to probe the meta information from.\n-  private final Set<ServerName> masterServers;\n+  private final Set<ServerName> masterAddrs;\n+\n+  private final List<ClientMetaService.Interface> masterStubs;\n \n   // RPC client used to talk to the masters.\n   private final RpcClient rpcClient;\n   private final RpcControllerFactory rpcControllerFactory;\n-  private final int rpcTimeoutMs;\n-\n-  MasterRegistry(Configuration conf) throws UnknownHostException {\n-    boolean hedgedReadsEnabled = conf.getBoolean(MASTER_REGISTRY_ENABLE_HEDGED_READS_KEY,\n-        MASTER_REGISTRY_ENABLE_HEDGED_READS_DEFAULT);\n-    Configuration finalConf;\n-    if (!hedgedReadsEnabled) {\n-      // If hedged reads are disabled, it is equivalent to setting a fan out of 1. We make a copy of\n-      // the configuration so that other places reusing this reference is not affected.\n-      finalConf = new Configuration(conf);\n-      finalConf.setInt(HConstants.HBASE_RPCS_HEDGED_REQS_FANOUT_KEY, 1);\n-    } else {\n-      finalConf = conf;\n+\n+  /**\n+   * Parses the list of master addresses from the provided configuration. Supported format is comma\n+   * separated host[:port] values. If no port number if specified, default master port is assumed.\n+   * @param conf Configuration to parse from.\n+   */\n+  private static Set<ServerName> parseMasterAddrs(Configuration conf) throws UnknownHostException {\n+    Set<ServerName> masterAddrs = new HashSet<>();\n+    String configuredMasters = getMasterAddr(conf);\n+    for (String masterAddr : configuredMasters.split(MASTER_ADDRS_CONF_SEPARATOR)) {\n+      HostAndPort masterHostPort =\n+        HostAndPort.fromString(masterAddr.trim()).withDefaultPort(HConstants.DEFAULT_MASTER_PORT);\n+      masterAddrs.add(ServerName.valueOf(masterHostPort.toString(), ServerName.NON_STARTCODE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTk4MDc1OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzo1MTo1NlrOGQLZJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMToyNzoxN1rOGQXv2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNzA2MQ==", "bodyText": "nit: add a debug log?", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419617061", "createdAt": "2020-05-04T17:51:56Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -117,105 +147,97 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     return String.format(\"%s:%d\", hostname, port);\n   }\n \n-  /**\n-   * @return Stub needed to make RPC using a hedged channel to the master end points.\n-   */\n-  private ClientMetaService.Interface getMasterStub() throws IOException {\n-    return ClientMetaService.newStub(\n-        rpcClient.createHedgedRpcChannel(masterServers, User.getCurrent(), rpcTimeoutMs));\n+  @FunctionalInterface\n+  private interface Callable<T> {\n+    void call(HBaseRpcController controller, ClientMetaService.Interface stub, RpcCallback<T> done);\n   }\n \n-  /**\n-   * Parses the list of master addresses from the provided configuration. Supported format is\n-   * comma separated host[:port] values. If no port number if specified, default master port is\n-   * assumed.\n-   * @param conf Configuration to parse from.\n-   */\n-  private void parseMasterAddrs(Configuration conf) throws UnknownHostException {\n-    String configuredMasters = getMasterAddr(conf);\n-    for (String masterAddr: configuredMasters.split(MASTER_ADDRS_CONF_SEPARATOR)) {\n-      HostAndPort masterHostPort =\n-          HostAndPort.fromString(masterAddr.trim()).withDefaultPort(HConstants.DEFAULT_MASTER_PORT);\n-      masterServers.add(ServerName.valueOf(masterHostPort.toString(), ServerName.NON_STARTCODE));\n-    }\n-    Preconditions.checkArgument(!masterServers.isEmpty(), \"At least one master address is needed\");\n+  private <T extends Message> CompletableFuture<T> call(ClientMetaService.Interface stub,\n+    Callable<T> callable) {\n+    HBaseRpcController controller = rpcControllerFactory.newController();\n+    CompletableFuture<T> future = new CompletableFuture<>();\n+    callable.call(controller, stub, resp -> {\n+      if (controller.failed()) {\n+        future.completeExceptionally(controller.getFailed());\n+      } else {\n+        future.complete(resp);\n+      }\n+    });\n+    return future;\n   }\n \n-  @VisibleForTesting\n-  public Set<ServerName> getParsedMasterServers() {\n-    return Collections.unmodifiableSet(masterServers);\n+  private IOException badResponse(String debug) {\n+    return new IOException(String.format(\"Invalid result for request %s. Will be retried\", debug));\n   }\n \n-  /**\n-   * Returns a call back that can be passed along to the non-blocking rpc call. It is invoked once\n-   * the rpc finishes and the response is propagated to the passed future.\n-   * @param future Result future to which the rpc response is propagated.\n-   * @param isValidResp Checks if the rpc response has a valid result.\n-   * @param transformResult Transforms the result to a different form as expected by callers.\n-   * @param hrc RpcController instance for this rpc.\n-   * @param debug Debug message passed along to the caller in case of exceptions.\n-   * @param <T> RPC result type.\n-   * @param <R> Transformed type of the result.\n-   * @return A call back that can be embedded in the non-blocking rpc call.\n-   */\n-  private <T, R> RpcCallback<T> getRpcCallBack(CompletableFuture<R> future,\n-      Predicate<T> isValidResp, Function<T, R> transformResult, HBaseRpcController hrc,\n-      final String debug) {\n-    return rpcResult -> {\n-      if (rpcResult == null) {\n-        future.completeExceptionally(\n-            new MasterRegistryFetchException(masterServers, hrc.getFailed()));\n-        return;\n-      }\n-      if (!isValidResp.test(rpcResult)) {\n-        // Rpc returned ok, but result was malformed.\n-        future.completeExceptionally(new IOException(\n-            String.format(\"Invalid result for request %s. Will be retried\", debug)));\n-        return;\n-      }\n-      future.complete(transformResult.apply(rpcResult));\n-    };\n+  // send requests concurrently to hedgedReadsFanout masters\n+  private <T extends Message> void groupCall(CompletableFuture<T> future, int startIndexInclusive,\n+    Callable<T> callable, Predicate<T> isValidResp, String debug,\n+    ConcurrentLinkedQueue<Throwable> errors) {\n+    int endIndexExclusive = Math.min(startIndexInclusive + hedgedReadFanOut, masterStubs.size());\n+    AtomicInteger remaining = new AtomicInteger(endIndexExclusive - startIndexInclusive);\n+    for (int i = startIndexInclusive; i < endIndexExclusive; i++) {\n+      addListener(call(masterStubs.get(i), callable), (r, e) -> {\n+        // a simple check to skip all the later operations earlier\n+        if (future.isDone()) {\n+          return;\n+        }\n+        if (e == null && !isValidResp.test(r)) {\n+          e = badResponse(debug);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgxOTQ4Mw==", "bodyText": "The message is already contained in the exception?", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419819483", "createdAt": "2020-05-05T01:27:17Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -117,105 +147,97 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     return String.format(\"%s:%d\", hostname, port);\n   }\n \n-  /**\n-   * @return Stub needed to make RPC using a hedged channel to the master end points.\n-   */\n-  private ClientMetaService.Interface getMasterStub() throws IOException {\n-    return ClientMetaService.newStub(\n-        rpcClient.createHedgedRpcChannel(masterServers, User.getCurrent(), rpcTimeoutMs));\n+  @FunctionalInterface\n+  private interface Callable<T> {\n+    void call(HBaseRpcController controller, ClientMetaService.Interface stub, RpcCallback<T> done);\n   }\n \n-  /**\n-   * Parses the list of master addresses from the provided configuration. Supported format is\n-   * comma separated host[:port] values. If no port number if specified, default master port is\n-   * assumed.\n-   * @param conf Configuration to parse from.\n-   */\n-  private void parseMasterAddrs(Configuration conf) throws UnknownHostException {\n-    String configuredMasters = getMasterAddr(conf);\n-    for (String masterAddr: configuredMasters.split(MASTER_ADDRS_CONF_SEPARATOR)) {\n-      HostAndPort masterHostPort =\n-          HostAndPort.fromString(masterAddr.trim()).withDefaultPort(HConstants.DEFAULT_MASTER_PORT);\n-      masterServers.add(ServerName.valueOf(masterHostPort.toString(), ServerName.NON_STARTCODE));\n-    }\n-    Preconditions.checkArgument(!masterServers.isEmpty(), \"At least one master address is needed\");\n+  private <T extends Message> CompletableFuture<T> call(ClientMetaService.Interface stub,\n+    Callable<T> callable) {\n+    HBaseRpcController controller = rpcControllerFactory.newController();\n+    CompletableFuture<T> future = new CompletableFuture<>();\n+    callable.call(controller, stub, resp -> {\n+      if (controller.failed()) {\n+        future.completeExceptionally(controller.getFailed());\n+      } else {\n+        future.complete(resp);\n+      }\n+    });\n+    return future;\n   }\n \n-  @VisibleForTesting\n-  public Set<ServerName> getParsedMasterServers() {\n-    return Collections.unmodifiableSet(masterServers);\n+  private IOException badResponse(String debug) {\n+    return new IOException(String.format(\"Invalid result for request %s. Will be retried\", debug));\n   }\n \n-  /**\n-   * Returns a call back that can be passed along to the non-blocking rpc call. It is invoked once\n-   * the rpc finishes and the response is propagated to the passed future.\n-   * @param future Result future to which the rpc response is propagated.\n-   * @param isValidResp Checks if the rpc response has a valid result.\n-   * @param transformResult Transforms the result to a different form as expected by callers.\n-   * @param hrc RpcController instance for this rpc.\n-   * @param debug Debug message passed along to the caller in case of exceptions.\n-   * @param <T> RPC result type.\n-   * @param <R> Transformed type of the result.\n-   * @return A call back that can be embedded in the non-blocking rpc call.\n-   */\n-  private <T, R> RpcCallback<T> getRpcCallBack(CompletableFuture<R> future,\n-      Predicate<T> isValidResp, Function<T, R> transformResult, HBaseRpcController hrc,\n-      final String debug) {\n-    return rpcResult -> {\n-      if (rpcResult == null) {\n-        future.completeExceptionally(\n-            new MasterRegistryFetchException(masterServers, hrc.getFailed()));\n-        return;\n-      }\n-      if (!isValidResp.test(rpcResult)) {\n-        // Rpc returned ok, but result was malformed.\n-        future.completeExceptionally(new IOException(\n-            String.format(\"Invalid result for request %s. Will be retried\", debug)));\n-        return;\n-      }\n-      future.complete(transformResult.apply(rpcResult));\n-    };\n+  // send requests concurrently to hedgedReadsFanout masters\n+  private <T extends Message> void groupCall(CompletableFuture<T> future, int startIndexInclusive,\n+    Callable<T> callable, Predicate<T> isValidResp, String debug,\n+    ConcurrentLinkedQueue<Throwable> errors) {\n+    int endIndexExclusive = Math.min(startIndexInclusive + hedgedReadFanOut, masterStubs.size());\n+    AtomicInteger remaining = new AtomicInteger(endIndexExclusive - startIndexInclusive);\n+    for (int i = startIndexInclusive; i < endIndexExclusive; i++) {\n+      addListener(call(masterStubs.get(i), callable), (r, e) -> {\n+        // a simple check to skip all the later operations earlier\n+        if (future.isDone()) {\n+          return;\n+        }\n+        if (e == null && !isValidResp.test(r)) {\n+          e = badResponse(debug);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxNzA2MQ=="}, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 236}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMTk4ODc4OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzo1NDowMFrOGQLeMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzo0MDo0M1rOGQ_geg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxODM1NA==", "bodyText": "nit: technically these are not retries right? Instead wrap all the errors in to MasterRegistryFetch..?", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419618354", "createdAt": "2020-05-04T17:54:00Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -117,105 +147,97 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     return String.format(\"%s:%d\", hostname, port);\n   }\n \n-  /**\n-   * @return Stub needed to make RPC using a hedged channel to the master end points.\n-   */\n-  private ClientMetaService.Interface getMasterStub() throws IOException {\n-    return ClientMetaService.newStub(\n-        rpcClient.createHedgedRpcChannel(masterServers, User.getCurrent(), rpcTimeoutMs));\n+  @FunctionalInterface\n+  private interface Callable<T> {\n+    void call(HBaseRpcController controller, ClientMetaService.Interface stub, RpcCallback<T> done);\n   }\n \n-  /**\n-   * Parses the list of master addresses from the provided configuration. Supported format is\n-   * comma separated host[:port] values. If no port number if specified, default master port is\n-   * assumed.\n-   * @param conf Configuration to parse from.\n-   */\n-  private void parseMasterAddrs(Configuration conf) throws UnknownHostException {\n-    String configuredMasters = getMasterAddr(conf);\n-    for (String masterAddr: configuredMasters.split(MASTER_ADDRS_CONF_SEPARATOR)) {\n-      HostAndPort masterHostPort =\n-          HostAndPort.fromString(masterAddr.trim()).withDefaultPort(HConstants.DEFAULT_MASTER_PORT);\n-      masterServers.add(ServerName.valueOf(masterHostPort.toString(), ServerName.NON_STARTCODE));\n-    }\n-    Preconditions.checkArgument(!masterServers.isEmpty(), \"At least one master address is needed\");\n+  private <T extends Message> CompletableFuture<T> call(ClientMetaService.Interface stub,\n+    Callable<T> callable) {\n+    HBaseRpcController controller = rpcControllerFactory.newController();\n+    CompletableFuture<T> future = new CompletableFuture<>();\n+    callable.call(controller, stub, resp -> {\n+      if (controller.failed()) {\n+        future.completeExceptionally(controller.getFailed());\n+      } else {\n+        future.complete(resp);\n+      }\n+    });\n+    return future;\n   }\n \n-  @VisibleForTesting\n-  public Set<ServerName> getParsedMasterServers() {\n-    return Collections.unmodifiableSet(masterServers);\n+  private IOException badResponse(String debug) {\n+    return new IOException(String.format(\"Invalid result for request %s. Will be retried\", debug));\n   }\n \n-  /**\n-   * Returns a call back that can be passed along to the non-blocking rpc call. It is invoked once\n-   * the rpc finishes and the response is propagated to the passed future.\n-   * @param future Result future to which the rpc response is propagated.\n-   * @param isValidResp Checks if the rpc response has a valid result.\n-   * @param transformResult Transforms the result to a different form as expected by callers.\n-   * @param hrc RpcController instance for this rpc.\n-   * @param debug Debug message passed along to the caller in case of exceptions.\n-   * @param <T> RPC result type.\n-   * @param <R> Transformed type of the result.\n-   * @return A call back that can be embedded in the non-blocking rpc call.\n-   */\n-  private <T, R> RpcCallback<T> getRpcCallBack(CompletableFuture<R> future,\n-      Predicate<T> isValidResp, Function<T, R> transformResult, HBaseRpcController hrc,\n-      final String debug) {\n-    return rpcResult -> {\n-      if (rpcResult == null) {\n-        future.completeExceptionally(\n-            new MasterRegistryFetchException(masterServers, hrc.getFailed()));\n-        return;\n-      }\n-      if (!isValidResp.test(rpcResult)) {\n-        // Rpc returned ok, but result was malformed.\n-        future.completeExceptionally(new IOException(\n-            String.format(\"Invalid result for request %s. Will be retried\", debug)));\n-        return;\n-      }\n-      future.complete(transformResult.apply(rpcResult));\n-    };\n+  // send requests concurrently to hedgedReadsFanout masters\n+  private <T extends Message> void groupCall(CompletableFuture<T> future, int startIndexInclusive,\n+    Callable<T> callable, Predicate<T> isValidResp, String debug,\n+    ConcurrentLinkedQueue<Throwable> errors) {\n+    int endIndexExclusive = Math.min(startIndexInclusive + hedgedReadFanOut, masterStubs.size());\n+    AtomicInteger remaining = new AtomicInteger(endIndexExclusive - startIndexInclusive);\n+    for (int i = startIndexInclusive; i < endIndexExclusive; i++) {\n+      addListener(call(masterStubs.get(i), callable), (r, e) -> {\n+        // a simple check to skip all the later operations earlier\n+        if (future.isDone()) {\n+          return;\n+        }\n+        if (e == null && !isValidResp.test(r)) {\n+          e = badResponse(debug);\n+        }\n+        if (e != null) {\n+          // make sure when remaining reaches 0 we have all exceptions in the errors queue\n+          errors.add(e);\n+          if (remaining.decrementAndGet() == 0) {\n+            if (endIndexExclusive == masterStubs.size()) {\n+              // we are done, complete the future with exception\n+              RetriesExhaustedException ex = new RetriesExhaustedException(\"masters\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg0MDM1NA==", "bodyText": "The RetriesExhaustedException is used to wrap all the exceptions and then it will be wrapped by the MasterRegistryFetchException to include all the master addresses.", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419840354", "createdAt": "2020-05-05T03:06:23Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -117,105 +147,97 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     return String.format(\"%s:%d\", hostname, port);\n   }\n \n-  /**\n-   * @return Stub needed to make RPC using a hedged channel to the master end points.\n-   */\n-  private ClientMetaService.Interface getMasterStub() throws IOException {\n-    return ClientMetaService.newStub(\n-        rpcClient.createHedgedRpcChannel(masterServers, User.getCurrent(), rpcTimeoutMs));\n+  @FunctionalInterface\n+  private interface Callable<T> {\n+    void call(HBaseRpcController controller, ClientMetaService.Interface stub, RpcCallback<T> done);\n   }\n \n-  /**\n-   * Parses the list of master addresses from the provided configuration. Supported format is\n-   * comma separated host[:port] values. If no port number if specified, default master port is\n-   * assumed.\n-   * @param conf Configuration to parse from.\n-   */\n-  private void parseMasterAddrs(Configuration conf) throws UnknownHostException {\n-    String configuredMasters = getMasterAddr(conf);\n-    for (String masterAddr: configuredMasters.split(MASTER_ADDRS_CONF_SEPARATOR)) {\n-      HostAndPort masterHostPort =\n-          HostAndPort.fromString(masterAddr.trim()).withDefaultPort(HConstants.DEFAULT_MASTER_PORT);\n-      masterServers.add(ServerName.valueOf(masterHostPort.toString(), ServerName.NON_STARTCODE));\n-    }\n-    Preconditions.checkArgument(!masterServers.isEmpty(), \"At least one master address is needed\");\n+  private <T extends Message> CompletableFuture<T> call(ClientMetaService.Interface stub,\n+    Callable<T> callable) {\n+    HBaseRpcController controller = rpcControllerFactory.newController();\n+    CompletableFuture<T> future = new CompletableFuture<>();\n+    callable.call(controller, stub, resp -> {\n+      if (controller.failed()) {\n+        future.completeExceptionally(controller.getFailed());\n+      } else {\n+        future.complete(resp);\n+      }\n+    });\n+    return future;\n   }\n \n-  @VisibleForTesting\n-  public Set<ServerName> getParsedMasterServers() {\n-    return Collections.unmodifiableSet(masterServers);\n+  private IOException badResponse(String debug) {\n+    return new IOException(String.format(\"Invalid result for request %s. Will be retried\", debug));\n   }\n \n-  /**\n-   * Returns a call back that can be passed along to the non-blocking rpc call. It is invoked once\n-   * the rpc finishes and the response is propagated to the passed future.\n-   * @param future Result future to which the rpc response is propagated.\n-   * @param isValidResp Checks if the rpc response has a valid result.\n-   * @param transformResult Transforms the result to a different form as expected by callers.\n-   * @param hrc RpcController instance for this rpc.\n-   * @param debug Debug message passed along to the caller in case of exceptions.\n-   * @param <T> RPC result type.\n-   * @param <R> Transformed type of the result.\n-   * @return A call back that can be embedded in the non-blocking rpc call.\n-   */\n-  private <T, R> RpcCallback<T> getRpcCallBack(CompletableFuture<R> future,\n-      Predicate<T> isValidResp, Function<T, R> transformResult, HBaseRpcController hrc,\n-      final String debug) {\n-    return rpcResult -> {\n-      if (rpcResult == null) {\n-        future.completeExceptionally(\n-            new MasterRegistryFetchException(masterServers, hrc.getFailed()));\n-        return;\n-      }\n-      if (!isValidResp.test(rpcResult)) {\n-        // Rpc returned ok, but result was malformed.\n-        future.completeExceptionally(new IOException(\n-            String.format(\"Invalid result for request %s. Will be retried\", debug)));\n-        return;\n-      }\n-      future.complete(transformResult.apply(rpcResult));\n-    };\n+  // send requests concurrently to hedgedReadsFanout masters\n+  private <T extends Message> void groupCall(CompletableFuture<T> future, int startIndexInclusive,\n+    Callable<T> callable, Predicate<T> isValidResp, String debug,\n+    ConcurrentLinkedQueue<Throwable> errors) {\n+    int endIndexExclusive = Math.min(startIndexInclusive + hedgedReadFanOut, masterStubs.size());\n+    AtomicInteger remaining = new AtomicInteger(endIndexExclusive - startIndexInclusive);\n+    for (int i = startIndexInclusive; i < endIndexExclusive; i++) {\n+      addListener(call(masterStubs.get(i), callable), (r, e) -> {\n+        // a simple check to skip all the later operations earlier\n+        if (future.isDone()) {\n+          return;\n+        }\n+        if (e == null && !isValidResp.test(r)) {\n+          e = badResponse(debug);\n+        }\n+        if (e != null) {\n+          // make sure when remaining reaches 0 we have all exceptions in the errors queue\n+          errors.add(e);\n+          if (remaining.decrementAndGet() == 0) {\n+            if (endIndexExclusive == masterStubs.size()) {\n+              // we are done, complete the future with exception\n+              RetriesExhaustedException ex = new RetriesExhaustedException(\"masters\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxODM1NA=="}, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3MDkwNg==", "bodyText": "Ya, my question was about the word \"retries\". That will show up in the exception message (IIUC). These give a false impression that things are being retried, right (when in reality they are hedged, in some sense).", "url": "https://github.com/apache/hbase/pull/1593#discussion_r420470906", "createdAt": "2020-05-05T23:40:43Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -117,105 +147,97 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     return String.format(\"%s:%d\", hostname, port);\n   }\n \n-  /**\n-   * @return Stub needed to make RPC using a hedged channel to the master end points.\n-   */\n-  private ClientMetaService.Interface getMasterStub() throws IOException {\n-    return ClientMetaService.newStub(\n-        rpcClient.createHedgedRpcChannel(masterServers, User.getCurrent(), rpcTimeoutMs));\n+  @FunctionalInterface\n+  private interface Callable<T> {\n+    void call(HBaseRpcController controller, ClientMetaService.Interface stub, RpcCallback<T> done);\n   }\n \n-  /**\n-   * Parses the list of master addresses from the provided configuration. Supported format is\n-   * comma separated host[:port] values. If no port number if specified, default master port is\n-   * assumed.\n-   * @param conf Configuration to parse from.\n-   */\n-  private void parseMasterAddrs(Configuration conf) throws UnknownHostException {\n-    String configuredMasters = getMasterAddr(conf);\n-    for (String masterAddr: configuredMasters.split(MASTER_ADDRS_CONF_SEPARATOR)) {\n-      HostAndPort masterHostPort =\n-          HostAndPort.fromString(masterAddr.trim()).withDefaultPort(HConstants.DEFAULT_MASTER_PORT);\n-      masterServers.add(ServerName.valueOf(masterHostPort.toString(), ServerName.NON_STARTCODE));\n-    }\n-    Preconditions.checkArgument(!masterServers.isEmpty(), \"At least one master address is needed\");\n+  private <T extends Message> CompletableFuture<T> call(ClientMetaService.Interface stub,\n+    Callable<T> callable) {\n+    HBaseRpcController controller = rpcControllerFactory.newController();\n+    CompletableFuture<T> future = new CompletableFuture<>();\n+    callable.call(controller, stub, resp -> {\n+      if (controller.failed()) {\n+        future.completeExceptionally(controller.getFailed());\n+      } else {\n+        future.complete(resp);\n+      }\n+    });\n+    return future;\n   }\n \n-  @VisibleForTesting\n-  public Set<ServerName> getParsedMasterServers() {\n-    return Collections.unmodifiableSet(masterServers);\n+  private IOException badResponse(String debug) {\n+    return new IOException(String.format(\"Invalid result for request %s. Will be retried\", debug));\n   }\n \n-  /**\n-   * Returns a call back that can be passed along to the non-blocking rpc call. It is invoked once\n-   * the rpc finishes and the response is propagated to the passed future.\n-   * @param future Result future to which the rpc response is propagated.\n-   * @param isValidResp Checks if the rpc response has a valid result.\n-   * @param transformResult Transforms the result to a different form as expected by callers.\n-   * @param hrc RpcController instance for this rpc.\n-   * @param debug Debug message passed along to the caller in case of exceptions.\n-   * @param <T> RPC result type.\n-   * @param <R> Transformed type of the result.\n-   * @return A call back that can be embedded in the non-blocking rpc call.\n-   */\n-  private <T, R> RpcCallback<T> getRpcCallBack(CompletableFuture<R> future,\n-      Predicate<T> isValidResp, Function<T, R> transformResult, HBaseRpcController hrc,\n-      final String debug) {\n-    return rpcResult -> {\n-      if (rpcResult == null) {\n-        future.completeExceptionally(\n-            new MasterRegistryFetchException(masterServers, hrc.getFailed()));\n-        return;\n-      }\n-      if (!isValidResp.test(rpcResult)) {\n-        // Rpc returned ok, but result was malformed.\n-        future.completeExceptionally(new IOException(\n-            String.format(\"Invalid result for request %s. Will be retried\", debug)));\n-        return;\n-      }\n-      future.complete(transformResult.apply(rpcResult));\n-    };\n+  // send requests concurrently to hedgedReadsFanout masters\n+  private <T extends Message> void groupCall(CompletableFuture<T> future, int startIndexInclusive,\n+    Callable<T> callable, Predicate<T> isValidResp, String debug,\n+    ConcurrentLinkedQueue<Throwable> errors) {\n+    int endIndexExclusive = Math.min(startIndexInclusive + hedgedReadFanOut, masterStubs.size());\n+    AtomicInteger remaining = new AtomicInteger(endIndexExclusive - startIndexInclusive);\n+    for (int i = startIndexInclusive; i < endIndexExclusive; i++) {\n+      addListener(call(masterStubs.get(i), callable), (r, e) -> {\n+        // a simple check to skip all the later operations earlier\n+        if (future.isDone()) {\n+          return;\n+        }\n+        if (e == null && !isValidResp.test(r)) {\n+          e = badResponse(debug);\n+        }\n+        if (e != null) {\n+          // make sure when remaining reaches 0 we have all exceptions in the errors queue\n+          errors.add(e);\n+          if (remaining.decrementAndGet() == 0) {\n+            if (endIndexExclusive == masterStubs.size()) {\n+              // we are done, complete the future with exception\n+              RetriesExhaustedException ex = new RetriesExhaustedException(\"masters\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYxODM1NA=="}, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMjAwMjQ0OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzo1NzoyNFrOGQLmxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzo1MDoxN1rOGQ_r4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYyMDU1MQ==", "bodyText": "What happens to the hedged calls? Shouldn't they be canceled?", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419620551", "createdAt": "2020-05-04T17:57:24Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -117,105 +147,97 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     return String.format(\"%s:%d\", hostname, port);\n   }\n \n-  /**\n-   * @return Stub needed to make RPC using a hedged channel to the master end points.\n-   */\n-  private ClientMetaService.Interface getMasterStub() throws IOException {\n-    return ClientMetaService.newStub(\n-        rpcClient.createHedgedRpcChannel(masterServers, User.getCurrent(), rpcTimeoutMs));\n+  @FunctionalInterface\n+  private interface Callable<T> {\n+    void call(HBaseRpcController controller, ClientMetaService.Interface stub, RpcCallback<T> done);\n   }\n \n-  /**\n-   * Parses the list of master addresses from the provided configuration. Supported format is\n-   * comma separated host[:port] values. If no port number if specified, default master port is\n-   * assumed.\n-   * @param conf Configuration to parse from.\n-   */\n-  private void parseMasterAddrs(Configuration conf) throws UnknownHostException {\n-    String configuredMasters = getMasterAddr(conf);\n-    for (String masterAddr: configuredMasters.split(MASTER_ADDRS_CONF_SEPARATOR)) {\n-      HostAndPort masterHostPort =\n-          HostAndPort.fromString(masterAddr.trim()).withDefaultPort(HConstants.DEFAULT_MASTER_PORT);\n-      masterServers.add(ServerName.valueOf(masterHostPort.toString(), ServerName.NON_STARTCODE));\n-    }\n-    Preconditions.checkArgument(!masterServers.isEmpty(), \"At least one master address is needed\");\n+  private <T extends Message> CompletableFuture<T> call(ClientMetaService.Interface stub,\n+    Callable<T> callable) {\n+    HBaseRpcController controller = rpcControllerFactory.newController();\n+    CompletableFuture<T> future = new CompletableFuture<>();\n+    callable.call(controller, stub, resp -> {\n+      if (controller.failed()) {\n+        future.completeExceptionally(controller.getFailed());\n+      } else {\n+        future.complete(resp);\n+      }\n+    });\n+    return future;\n   }\n \n-  @VisibleForTesting\n-  public Set<ServerName> getParsedMasterServers() {\n-    return Collections.unmodifiableSet(masterServers);\n+  private IOException badResponse(String debug) {\n+    return new IOException(String.format(\"Invalid result for request %s. Will be retried\", debug));\n   }\n \n-  /**\n-   * Returns a call back that can be passed along to the non-blocking rpc call. It is invoked once\n-   * the rpc finishes and the response is propagated to the passed future.\n-   * @param future Result future to which the rpc response is propagated.\n-   * @param isValidResp Checks if the rpc response has a valid result.\n-   * @param transformResult Transforms the result to a different form as expected by callers.\n-   * @param hrc RpcController instance for this rpc.\n-   * @param debug Debug message passed along to the caller in case of exceptions.\n-   * @param <T> RPC result type.\n-   * @param <R> Transformed type of the result.\n-   * @return A call back that can be embedded in the non-blocking rpc call.\n-   */\n-  private <T, R> RpcCallback<T> getRpcCallBack(CompletableFuture<R> future,\n-      Predicate<T> isValidResp, Function<T, R> transformResult, HBaseRpcController hrc,\n-      final String debug) {\n-    return rpcResult -> {\n-      if (rpcResult == null) {\n-        future.completeExceptionally(\n-            new MasterRegistryFetchException(masterServers, hrc.getFailed()));\n-        return;\n-      }\n-      if (!isValidResp.test(rpcResult)) {\n-        // Rpc returned ok, but result was malformed.\n-        future.completeExceptionally(new IOException(\n-            String.format(\"Invalid result for request %s. Will be retried\", debug)));\n-        return;\n-      }\n-      future.complete(transformResult.apply(rpcResult));\n-    };\n+  // send requests concurrently to hedgedReadsFanout masters\n+  private <T extends Message> void groupCall(CompletableFuture<T> future, int startIndexInclusive,\n+    Callable<T> callable, Predicate<T> isValidResp, String debug,\n+    ConcurrentLinkedQueue<Throwable> errors) {\n+    int endIndexExclusive = Math.min(startIndexInclusive + hedgedReadFanOut, masterStubs.size());\n+    AtomicInteger remaining = new AtomicInteger(endIndexExclusive - startIndexInclusive);\n+    for (int i = startIndexInclusive; i < endIndexExclusive; i++) {\n+      addListener(call(masterStubs.get(i), callable), (r, e) -> {\n+        // a simple check to skip all the later operations earlier\n+        if (future.isDone()) {\n+          return;\n+        }\n+        if (e == null && !isValidResp.test(r)) {\n+          e = badResponse(debug);\n+        }\n+        if (e != null) {\n+          // make sure when remaining reaches 0 we have all exceptions in the errors queue\n+          errors.add(e);\n+          if (remaining.decrementAndGet() == 0) {\n+            if (endIndexExclusive == masterStubs.size()) {\n+              // we are done, complete the future with exception\n+              RetriesExhaustedException ex = new RetriesExhaustedException(\"masters\",\n+                masterStubs.size(), new ArrayList<>(errors));\n+              future.completeExceptionally(new MasterRegistryFetchException(masterAddrs, ex));\n+            } else {\n+              groupCall(future, endIndexExclusive, callable, isValidResp, debug, errors);\n+            }\n+          }\n+        } else {\n+          // do not need to decrement the counter any more as we have already finished the future.\n+          future.complete(r);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwMDYzMA==", "bodyText": "There is no way to cancel a already sent rpc call, our rpc framework does not support this feature. For read replica feature there is a delay for the secondary replica calls so we have a chance to cancel the local delayed task but here, we just sent the request out.", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419800630", "createdAt": "2020-05-05T00:14:29Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -117,105 +147,97 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     return String.format(\"%s:%d\", hostname, port);\n   }\n \n-  /**\n-   * @return Stub needed to make RPC using a hedged channel to the master end points.\n-   */\n-  private ClientMetaService.Interface getMasterStub() throws IOException {\n-    return ClientMetaService.newStub(\n-        rpcClient.createHedgedRpcChannel(masterServers, User.getCurrent(), rpcTimeoutMs));\n+  @FunctionalInterface\n+  private interface Callable<T> {\n+    void call(HBaseRpcController controller, ClientMetaService.Interface stub, RpcCallback<T> done);\n   }\n \n-  /**\n-   * Parses the list of master addresses from the provided configuration. Supported format is\n-   * comma separated host[:port] values. If no port number if specified, default master port is\n-   * assumed.\n-   * @param conf Configuration to parse from.\n-   */\n-  private void parseMasterAddrs(Configuration conf) throws UnknownHostException {\n-    String configuredMasters = getMasterAddr(conf);\n-    for (String masterAddr: configuredMasters.split(MASTER_ADDRS_CONF_SEPARATOR)) {\n-      HostAndPort masterHostPort =\n-          HostAndPort.fromString(masterAddr.trim()).withDefaultPort(HConstants.DEFAULT_MASTER_PORT);\n-      masterServers.add(ServerName.valueOf(masterHostPort.toString(), ServerName.NON_STARTCODE));\n-    }\n-    Preconditions.checkArgument(!masterServers.isEmpty(), \"At least one master address is needed\");\n+  private <T extends Message> CompletableFuture<T> call(ClientMetaService.Interface stub,\n+    Callable<T> callable) {\n+    HBaseRpcController controller = rpcControllerFactory.newController();\n+    CompletableFuture<T> future = new CompletableFuture<>();\n+    callable.call(controller, stub, resp -> {\n+      if (controller.failed()) {\n+        future.completeExceptionally(controller.getFailed());\n+      } else {\n+        future.complete(resp);\n+      }\n+    });\n+    return future;\n   }\n \n-  @VisibleForTesting\n-  public Set<ServerName> getParsedMasterServers() {\n-    return Collections.unmodifiableSet(masterServers);\n+  private IOException badResponse(String debug) {\n+    return new IOException(String.format(\"Invalid result for request %s. Will be retried\", debug));\n   }\n \n-  /**\n-   * Returns a call back that can be passed along to the non-blocking rpc call. It is invoked once\n-   * the rpc finishes and the response is propagated to the passed future.\n-   * @param future Result future to which the rpc response is propagated.\n-   * @param isValidResp Checks if the rpc response has a valid result.\n-   * @param transformResult Transforms the result to a different form as expected by callers.\n-   * @param hrc RpcController instance for this rpc.\n-   * @param debug Debug message passed along to the caller in case of exceptions.\n-   * @param <T> RPC result type.\n-   * @param <R> Transformed type of the result.\n-   * @return A call back that can be embedded in the non-blocking rpc call.\n-   */\n-  private <T, R> RpcCallback<T> getRpcCallBack(CompletableFuture<R> future,\n-      Predicate<T> isValidResp, Function<T, R> transformResult, HBaseRpcController hrc,\n-      final String debug) {\n-    return rpcResult -> {\n-      if (rpcResult == null) {\n-        future.completeExceptionally(\n-            new MasterRegistryFetchException(masterServers, hrc.getFailed()));\n-        return;\n-      }\n-      if (!isValidResp.test(rpcResult)) {\n-        // Rpc returned ok, but result was malformed.\n-        future.completeExceptionally(new IOException(\n-            String.format(\"Invalid result for request %s. Will be retried\", debug)));\n-        return;\n-      }\n-      future.complete(transformResult.apply(rpcResult));\n-    };\n+  // send requests concurrently to hedgedReadsFanout masters\n+  private <T extends Message> void groupCall(CompletableFuture<T> future, int startIndexInclusive,\n+    Callable<T> callable, Predicate<T> isValidResp, String debug,\n+    ConcurrentLinkedQueue<Throwable> errors) {\n+    int endIndexExclusive = Math.min(startIndexInclusive + hedgedReadFanOut, masterStubs.size());\n+    AtomicInteger remaining = new AtomicInteger(endIndexExclusive - startIndexInclusive);\n+    for (int i = startIndexInclusive; i < endIndexExclusive; i++) {\n+      addListener(call(masterStubs.get(i), callable), (r, e) -> {\n+        // a simple check to skip all the later operations earlier\n+        if (future.isDone()) {\n+          return;\n+        }\n+        if (e == null && !isValidResp.test(r)) {\n+          e = badResponse(debug);\n+        }\n+        if (e != null) {\n+          // make sure when remaining reaches 0 we have all exceptions in the errors queue\n+          errors.add(e);\n+          if (remaining.decrementAndGet() == 0) {\n+            if (endIndexExclusive == masterStubs.size()) {\n+              // we are done, complete the future with exception\n+              RetriesExhaustedException ex = new RetriesExhaustedException(\"masters\",\n+                masterStubs.size(), new ArrayList<>(errors));\n+              future.completeExceptionally(new MasterRegistryFetchException(masterAddrs, ex));\n+            } else {\n+              groupCall(future, endIndexExclusive, callable, isValidResp, debug, errors);\n+            }\n+          }\n+        } else {\n+          // do not need to decrement the counter any more as we have already finished the future.\n+          future.complete(r);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYyMDU1MQ=="}, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3MzgyNw==", "bodyText": "I was thinking about Call#setException(), which cleans up the caller state and propagates the exception to the the future callback? For example, if a master is hung and the RPC is hung, that state would be cleaned up quicker.", "url": "https://github.com/apache/hbase/pull/1593#discussion_r420473827", "createdAt": "2020-05-05T23:50:17Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -117,105 +147,97 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     return String.format(\"%s:%d\", hostname, port);\n   }\n \n-  /**\n-   * @return Stub needed to make RPC using a hedged channel to the master end points.\n-   */\n-  private ClientMetaService.Interface getMasterStub() throws IOException {\n-    return ClientMetaService.newStub(\n-        rpcClient.createHedgedRpcChannel(masterServers, User.getCurrent(), rpcTimeoutMs));\n+  @FunctionalInterface\n+  private interface Callable<T> {\n+    void call(HBaseRpcController controller, ClientMetaService.Interface stub, RpcCallback<T> done);\n   }\n \n-  /**\n-   * Parses the list of master addresses from the provided configuration. Supported format is\n-   * comma separated host[:port] values. If no port number if specified, default master port is\n-   * assumed.\n-   * @param conf Configuration to parse from.\n-   */\n-  private void parseMasterAddrs(Configuration conf) throws UnknownHostException {\n-    String configuredMasters = getMasterAddr(conf);\n-    for (String masterAddr: configuredMasters.split(MASTER_ADDRS_CONF_SEPARATOR)) {\n-      HostAndPort masterHostPort =\n-          HostAndPort.fromString(masterAddr.trim()).withDefaultPort(HConstants.DEFAULT_MASTER_PORT);\n-      masterServers.add(ServerName.valueOf(masterHostPort.toString(), ServerName.NON_STARTCODE));\n-    }\n-    Preconditions.checkArgument(!masterServers.isEmpty(), \"At least one master address is needed\");\n+  private <T extends Message> CompletableFuture<T> call(ClientMetaService.Interface stub,\n+    Callable<T> callable) {\n+    HBaseRpcController controller = rpcControllerFactory.newController();\n+    CompletableFuture<T> future = new CompletableFuture<>();\n+    callable.call(controller, stub, resp -> {\n+      if (controller.failed()) {\n+        future.completeExceptionally(controller.getFailed());\n+      } else {\n+        future.complete(resp);\n+      }\n+    });\n+    return future;\n   }\n \n-  @VisibleForTesting\n-  public Set<ServerName> getParsedMasterServers() {\n-    return Collections.unmodifiableSet(masterServers);\n+  private IOException badResponse(String debug) {\n+    return new IOException(String.format(\"Invalid result for request %s. Will be retried\", debug));\n   }\n \n-  /**\n-   * Returns a call back that can be passed along to the non-blocking rpc call. It is invoked once\n-   * the rpc finishes and the response is propagated to the passed future.\n-   * @param future Result future to which the rpc response is propagated.\n-   * @param isValidResp Checks if the rpc response has a valid result.\n-   * @param transformResult Transforms the result to a different form as expected by callers.\n-   * @param hrc RpcController instance for this rpc.\n-   * @param debug Debug message passed along to the caller in case of exceptions.\n-   * @param <T> RPC result type.\n-   * @param <R> Transformed type of the result.\n-   * @return A call back that can be embedded in the non-blocking rpc call.\n-   */\n-  private <T, R> RpcCallback<T> getRpcCallBack(CompletableFuture<R> future,\n-      Predicate<T> isValidResp, Function<T, R> transformResult, HBaseRpcController hrc,\n-      final String debug) {\n-    return rpcResult -> {\n-      if (rpcResult == null) {\n-        future.completeExceptionally(\n-            new MasterRegistryFetchException(masterServers, hrc.getFailed()));\n-        return;\n-      }\n-      if (!isValidResp.test(rpcResult)) {\n-        // Rpc returned ok, but result was malformed.\n-        future.completeExceptionally(new IOException(\n-            String.format(\"Invalid result for request %s. Will be retried\", debug)));\n-        return;\n-      }\n-      future.complete(transformResult.apply(rpcResult));\n-    };\n+  // send requests concurrently to hedgedReadsFanout masters\n+  private <T extends Message> void groupCall(CompletableFuture<T> future, int startIndexInclusive,\n+    Callable<T> callable, Predicate<T> isValidResp, String debug,\n+    ConcurrentLinkedQueue<Throwable> errors) {\n+    int endIndexExclusive = Math.min(startIndexInclusive + hedgedReadFanOut, masterStubs.size());\n+    AtomicInteger remaining = new AtomicInteger(endIndexExclusive - startIndexInclusive);\n+    for (int i = startIndexInclusive; i < endIndexExclusive; i++) {\n+      addListener(call(masterStubs.get(i), callable), (r, e) -> {\n+        // a simple check to skip all the later operations earlier\n+        if (future.isDone()) {\n+          return;\n+        }\n+        if (e == null && !isValidResp.test(r)) {\n+          e = badResponse(debug);\n+        }\n+        if (e != null) {\n+          // make sure when remaining reaches 0 we have all exceptions in the errors queue\n+          errors.add(e);\n+          if (remaining.decrementAndGet() == 0) {\n+            if (endIndexExclusive == masterStubs.size()) {\n+              // we are done, complete the future with exception\n+              RetriesExhaustedException ex = new RetriesExhaustedException(\"masters\",\n+                masterStubs.size(), new ArrayList<>(errors));\n+              future.completeExceptionally(new MasterRegistryFetchException(masterAddrs, ex));\n+            } else {\n+              groupCall(future, endIndexExclusive, callable, isValidResp, debug, errors);\n+            }\n+          }\n+        } else {\n+          // do not need to decrement the counter any more as we have already finished the future.\n+          future.complete(r);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTYyMDU1MQ=="}, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMjU4MjI5OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMDozNjo0OVrOGQRN6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMDozNjo0OVrOGQRN6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxMjQ5MQ==", "bodyText": "stubs and addresses should be tied?", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419712491", "createdAt": "2020-05-04T20:36:49Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -61,53 +65,79 @@\n /**\n  * Master based registry implementation. Makes RPCs to the configured master addresses from config\n  * {@value org.apache.hadoop.hbase.HConstants#MASTER_ADDRS_KEY}.\n- *\n+ * <p/>\n  * It supports hedged reads, which can be enabled by setting\n  * {@value org.apache.hadoop.hbase.HConstants#MASTER_REGISTRY_ENABLE_HEDGED_READS_KEY} to True. Fan\n  * out the requests batch is controlled by\n  * {@value org.apache.hadoop.hbase.HConstants#HBASE_RPCS_HEDGED_REQS_FANOUT_KEY}.\n- *\n+ * <p/>\n  * TODO: Handle changes to the configuration dynamically without having to restart the client.\n  */\n @InterfaceAudience.Private\n public class MasterRegistry implements ConnectionRegistry {\n+\n+  /** Configuration key that controls the fan out of requests **/\n+  public static final String MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY =\n+    \"hbase.client.master_registry.hedged.fanout\";\n+\n+  /** Default value for the fan out of hedged requests. **/\n+  public static final int MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT = 2;\n+\n   private static final String MASTER_ADDRS_CONF_SEPARATOR = \",\";\n \n+  private final int hedgedReadFanOut;\n+\n   // Configured list of masters to probe the meta information from.\n-  private final Set<ServerName> masterServers;\n+  private final Set<ServerName> masterAddrs;\n+\n+  private final List<ClientMetaService.Interface> masterStubs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMjYxMzk0OnYy", "diffSide": "LEFT", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/ipc/AbstractTestIPC.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMDo0NTo1OVrOGQRhVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwMDoxNjoyMlrOGQWodA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxNzQ2Mw==", "bodyText": "These tests moved elsewhere? We need test of the hedged read still.", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419717463", "createdAt": "2020-05-04T20:45:59Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/ipc/AbstractTestIPC.java", "diffHunk": "@@ -367,105 +363,6 @@ public void testAsyncEcho() throws IOException {\n     }\n   }\n \n-  /**\n-   * Tests the various request fan out values using a simple RPC hedged across a mix of running and\n-   * failing servers.\n-   */\n-  @Test\n-  @Ignore\n-  public void testHedgedAsyncEcho() throws Exception {\n-    // Hedging is not supported for blocking connection types.\n-    Assume.assumeFalse(this instanceof TestBlockingIPC);\n-    List<RpcServer> rpcServers = new ArrayList<>();\n-    List<InetSocketAddress> addresses = new ArrayList<>();\n-    // Create a mix of running and failing servers.\n-    final int numRunningServers = 5;\n-    final int numFailingServers = 3;\n-    final int numServers = numRunningServers + numFailingServers;\n-    for (int i = 0; i < numRunningServers; i++) {\n-      RpcServer rpcServer = createRpcServer(null, \"testRpcServer\" + i,\n-          Lists.newArrayList(new RpcServer.BlockingServiceAndInterface(\n-          SERVICE, null)), new InetSocketAddress(\"localhost\", 0), CONF,\n-          new FifoRpcScheduler(CONF, 1));\n-      rpcServer.start();\n-      addresses.add(rpcServer.getListenerAddress());\n-      rpcServers.add(rpcServer);\n-    }\n-    for (int i = 0; i < numFailingServers; i++) {\n-      RpcServer rpcServer = createTestFailingRpcServer(null, \"testFailingRpcServer\" + i,\n-          Lists.newArrayList(new RpcServer.BlockingServiceAndInterface(\n-          SERVICE, null)), new InetSocketAddress(\"localhost\", 0), CONF,\n-          new FifoRpcScheduler(CONF, 1));\n-      rpcServer.start();\n-      addresses.add(rpcServer.getListenerAddress());\n-      rpcServers.add(rpcServer);\n-    }\n-    Configuration conf = HBaseConfiguration.create();\n-    try (AbstractRpcClient<?> client = createRpcClient(conf)) {\n-      // Try out various fan out values starting from 1 -> numServers.\n-      for (int reqFanOut = 1; reqFanOut <= numServers; reqFanOut++) {\n-        // Update the client's underlying conf, should be ok for the test.\n-        LOG.debug(\"Testing with request fan out: \" + reqFanOut);\n-        conf.setInt(HConstants.HBASE_RPCS_HEDGED_REQS_FANOUT_KEY, reqFanOut);\n-        Interface stub = newStub(client, addresses);\n-        BlockingRpcCallback<EchoResponseProto> done = new BlockingRpcCallback<>();\n-        stub.echo(new HBaseRpcControllerImpl(),\n-            EchoRequestProto.newBuilder().setMessage(\"hello\").build(), done);\n-        TestProtos.EchoResponseProto responseProto = done.get();\n-        assertNotNull(responseProto);\n-        assertEquals(\"hello\", responseProto.getMessage());\n-        LOG.debug(\"Ended test with request fan out: \" + reqFanOut);\n-      }\n-    } finally {\n-      for (RpcServer rpcServer: rpcServers) {\n-        rpcServer.stop();\n-      }\n-    }\n-  }\n-\n-  @Test\n-  public void testHedgedAsyncTimeouts() throws Exception {\n-    // Hedging is not supported for blocking connection types.\n-    Assume.assumeFalse(this instanceof TestBlockingIPC);\n-    List<RpcServer> rpcServers = new ArrayList<>();\n-    List<InetSocketAddress> addresses = new ArrayList<>();\n-    final int numServers = 3;\n-    for (int i = 0; i < numServers; i++) {\n-      RpcServer rpcServer = createRpcServer(null, \"testTimeoutRpcServer\" + i,\n-          Lists.newArrayList(new RpcServer.BlockingServiceAndInterface(\n-          SERVICE, null)), new InetSocketAddress(\"localhost\", 0), CONF,\n-          new FifoRpcScheduler(CONF, 1));\n-      rpcServer.start();\n-      addresses.add(rpcServer.getListenerAddress());\n-      rpcServers.add(rpcServer);\n-    }\n-    Configuration conf = HBaseConfiguration.create();\n-    int timeout = 100;\n-    int pauseTime = 1000;\n-    try (AbstractRpcClient<?> client = createRpcClient(conf)) {\n-      // Try out various fan out values starting from 1 -> numServers.\n-      for (int reqFanOut = 1; reqFanOut <= numServers; reqFanOut++) {\n-        // Update the client's underlying conf, should be ok for the test.\n-        LOG.debug(\"Testing with request fan out: \" + reqFanOut);\n-        conf.setInt(HConstants.HBASE_RPCS_HEDGED_REQS_FANOUT_KEY, reqFanOut);\n-        Interface stub = newStub(client, addresses);\n-        HBaseRpcController pcrc = new HBaseRpcControllerImpl();\n-        pcrc.setCallTimeout(timeout);\n-        BlockingRpcCallback<EmptyResponseProto> callback = new BlockingRpcCallback<>();\n-        stub.pause(pcrc, PauseRequestProto.newBuilder().setMs(pauseTime).build(), callback);\n-        assertNull(callback.get());\n-        // Make sure the controller has the right exception propagated.\n-        assertTrue(pcrc.getFailed() instanceof CallTimeoutException);\n-        LOG.debug(\"Ended test with request fan out: \" + reqFanOut);\n-      }\n-    } finally {\n-      for (RpcServer rpcServer: rpcServers) {\n-        rpcServer.stop();\n-      }\n-    }\n-  }\n-\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTgwMTIwNA==", "bodyText": "We do not have hedge reads support for rpc so just removed them. Let me see if we can directly test the logic in MasterRegistry.", "url": "https://github.com/apache/hbase/pull/1593#discussion_r419801204", "createdAt": "2020-05-05T00:16:22Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/ipc/AbstractTestIPC.java", "diffHunk": "@@ -367,105 +363,6 @@ public void testAsyncEcho() throws IOException {\n     }\n   }\n \n-  /**\n-   * Tests the various request fan out values using a simple RPC hedged across a mix of running and\n-   * failing servers.\n-   */\n-  @Test\n-  @Ignore\n-  public void testHedgedAsyncEcho() throws Exception {\n-    // Hedging is not supported for blocking connection types.\n-    Assume.assumeFalse(this instanceof TestBlockingIPC);\n-    List<RpcServer> rpcServers = new ArrayList<>();\n-    List<InetSocketAddress> addresses = new ArrayList<>();\n-    // Create a mix of running and failing servers.\n-    final int numRunningServers = 5;\n-    final int numFailingServers = 3;\n-    final int numServers = numRunningServers + numFailingServers;\n-    for (int i = 0; i < numRunningServers; i++) {\n-      RpcServer rpcServer = createRpcServer(null, \"testRpcServer\" + i,\n-          Lists.newArrayList(new RpcServer.BlockingServiceAndInterface(\n-          SERVICE, null)), new InetSocketAddress(\"localhost\", 0), CONF,\n-          new FifoRpcScheduler(CONF, 1));\n-      rpcServer.start();\n-      addresses.add(rpcServer.getListenerAddress());\n-      rpcServers.add(rpcServer);\n-    }\n-    for (int i = 0; i < numFailingServers; i++) {\n-      RpcServer rpcServer = createTestFailingRpcServer(null, \"testFailingRpcServer\" + i,\n-          Lists.newArrayList(new RpcServer.BlockingServiceAndInterface(\n-          SERVICE, null)), new InetSocketAddress(\"localhost\", 0), CONF,\n-          new FifoRpcScheduler(CONF, 1));\n-      rpcServer.start();\n-      addresses.add(rpcServer.getListenerAddress());\n-      rpcServers.add(rpcServer);\n-    }\n-    Configuration conf = HBaseConfiguration.create();\n-    try (AbstractRpcClient<?> client = createRpcClient(conf)) {\n-      // Try out various fan out values starting from 1 -> numServers.\n-      for (int reqFanOut = 1; reqFanOut <= numServers; reqFanOut++) {\n-        // Update the client's underlying conf, should be ok for the test.\n-        LOG.debug(\"Testing with request fan out: \" + reqFanOut);\n-        conf.setInt(HConstants.HBASE_RPCS_HEDGED_REQS_FANOUT_KEY, reqFanOut);\n-        Interface stub = newStub(client, addresses);\n-        BlockingRpcCallback<EchoResponseProto> done = new BlockingRpcCallback<>();\n-        stub.echo(new HBaseRpcControllerImpl(),\n-            EchoRequestProto.newBuilder().setMessage(\"hello\").build(), done);\n-        TestProtos.EchoResponseProto responseProto = done.get();\n-        assertNotNull(responseProto);\n-        assertEquals(\"hello\", responseProto.getMessage());\n-        LOG.debug(\"Ended test with request fan out: \" + reqFanOut);\n-      }\n-    } finally {\n-      for (RpcServer rpcServer: rpcServers) {\n-        rpcServer.stop();\n-      }\n-    }\n-  }\n-\n-  @Test\n-  public void testHedgedAsyncTimeouts() throws Exception {\n-    // Hedging is not supported for blocking connection types.\n-    Assume.assumeFalse(this instanceof TestBlockingIPC);\n-    List<RpcServer> rpcServers = new ArrayList<>();\n-    List<InetSocketAddress> addresses = new ArrayList<>();\n-    final int numServers = 3;\n-    for (int i = 0; i < numServers; i++) {\n-      RpcServer rpcServer = createRpcServer(null, \"testTimeoutRpcServer\" + i,\n-          Lists.newArrayList(new RpcServer.BlockingServiceAndInterface(\n-          SERVICE, null)), new InetSocketAddress(\"localhost\", 0), CONF,\n-          new FifoRpcScheduler(CONF, 1));\n-      rpcServer.start();\n-      addresses.add(rpcServer.getListenerAddress());\n-      rpcServers.add(rpcServer);\n-    }\n-    Configuration conf = HBaseConfiguration.create();\n-    int timeout = 100;\n-    int pauseTime = 1000;\n-    try (AbstractRpcClient<?> client = createRpcClient(conf)) {\n-      // Try out various fan out values starting from 1 -> numServers.\n-      for (int reqFanOut = 1; reqFanOut <= numServers; reqFanOut++) {\n-        // Update the client's underlying conf, should be ok for the test.\n-        LOG.debug(\"Testing with request fan out: \" + reqFanOut);\n-        conf.setInt(HConstants.HBASE_RPCS_HEDGED_REQS_FANOUT_KEY, reqFanOut);\n-        Interface stub = newStub(client, addresses);\n-        HBaseRpcController pcrc = new HBaseRpcControllerImpl();\n-        pcrc.setCallTimeout(timeout);\n-        BlockingRpcCallback<EmptyResponseProto> callback = new BlockingRpcCallback<>();\n-        stub.pause(pcrc, PauseRequestProto.newBuilder().setMs(pauseTime).build(), callback);\n-        assertNull(callback.get());\n-        // Make sure the controller has the right exception propagated.\n-        assertTrue(pcrc.getFailed() instanceof CallTimeoutException);\n-        LOG.debug(\"Ended test with request fan out: \" + reqFanOut);\n-      }\n-    } finally {\n-      for (RpcServer rpcServer: rpcServers) {\n-        rpcServer.stop();\n-      }\n-    }\n-  }\n-\n-", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxNzQ2Mw=="}, "originalCommit": {"oid": "131b708b1d8d9df811f390e39e639ae44dbd1d77"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzQ3NzM0OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzo1MzowMlrOGQ_vPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMzo1MzowMlrOGQ_vPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ3NDY4NQ==", "bodyText": "nit: javadoc for method formatting /**", "url": "https://github.com/apache/hbase/pull/1593#discussion_r420474685", "createdAt": "2020-05-05T23:53:02Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -118,104 +150,111 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n   }\n \n   /**\n-   * @return Stub needed to make RPC using a hedged channel to the master end points.\n+   * For describing the actual asynchronous rpc call.\n+   * <p/>\n+   * Typically, you can use lambda expression to implement this interface as\n+   *\n+   * <pre>\n+   * (c, s, d) -> s.xxx(c, your request here, d)\n+   * </pre>\n    */\n-  private ClientMetaService.Interface getMasterStub() throws IOException {\n-    return ClientMetaService.newStub(\n-        rpcClient.createHedgedRpcChannel(masterServers, User.getCurrent(), rpcTimeoutMs));\n+  @FunctionalInterface\n+  private interface Callable<T> {\n+    void call(HBaseRpcController controller, ClientMetaService.Interface stub, RpcCallback<T> done);\n   }\n \n-  /**\n-   * Parses the list of master addresses from the provided configuration. Supported format is\n-   * comma separated host[:port] values. If no port number if specified, default master port is\n-   * assumed.\n-   * @param conf Configuration to parse from.\n-   */\n-  private void parseMasterAddrs(Configuration conf) throws UnknownHostException {\n-    String configuredMasters = getMasterAddr(conf);\n-    for (String masterAddr: configuredMasters.split(MASTER_ADDRS_CONF_SEPARATOR)) {\n-      HostAndPort masterHostPort =\n-          HostAndPort.fromString(masterAddr.trim()).withDefaultPort(HConstants.DEFAULT_MASTER_PORT);\n-      masterServers.add(ServerName.valueOf(masterHostPort.toString(), ServerName.NON_STARTCODE));\n-    }\n-    Preconditions.checkArgument(!masterServers.isEmpty(), \"At least one master address is needed\");\n+  private <T extends Message> CompletableFuture<T> call(ClientMetaService.Interface stub,\n+    Callable<T> callable) {\n+    HBaseRpcController controller = rpcControllerFactory.newController();\n+    CompletableFuture<T> future = new CompletableFuture<>();\n+    callable.call(controller, stub, resp -> {\n+      if (controller.failed()) {\n+        future.completeExceptionally(controller.getFailed());\n+      } else {\n+        future.complete(resp);\n+      }\n+    });\n+    return future;\n   }\n \n-  @VisibleForTesting\n-  public Set<ServerName> getParsedMasterServers() {\n-    return Collections.unmodifiableSet(masterServers);\n+  private IOException badResponse(String debug) {\n+    return new IOException(String.format(\"Invalid result for request %s. Will be retried\", debug));\n   }\n \n-  /**\n-   * Returns a call back that can be passed along to the non-blocking rpc call. It is invoked once\n-   * the rpc finishes and the response is propagated to the passed future.\n-   * @param future Result future to which the rpc response is propagated.\n-   * @param isValidResp Checks if the rpc response has a valid result.\n-   * @param transformResult Transforms the result to a different form as expected by callers.\n-   * @param hrc RpcController instance for this rpc.\n-   * @param debug Debug message passed along to the caller in case of exceptions.\n-   * @param <T> RPC result type.\n-   * @param <R> Transformed type of the result.\n-   * @return A call back that can be embedded in the non-blocking rpc call.\n-   */\n-  private <T, R> RpcCallback<T> getRpcCallBack(CompletableFuture<R> future,\n-      Predicate<T> isValidResp, Function<T, R> transformResult, HBaseRpcController hrc,\n-      final String debug) {\n-    return rpcResult -> {\n-      if (rpcResult == null) {\n-        future.completeExceptionally(\n-            new MasterRegistryFetchException(masterServers, hrc.getFailed()));\n-        return;\n-      }\n-      if (!isValidResp.test(rpcResult)) {\n-        // Rpc returned ok, but result was malformed.\n-        future.completeExceptionally(new IOException(\n-            String.format(\"Invalid result for request %s. Will be retried\", debug)));\n-        return;\n-      }\n-      future.complete(transformResult.apply(rpcResult));\n-    };\n+  // send requests concurrently to hedgedReadsFanout masters. If any of the request is succeeded, we", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2529df12ca326d84e4b9591474c847ea8269bfa"}, "originalPosition": 233}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1834, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}