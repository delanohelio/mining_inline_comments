{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyNzk5NDEy", "number": 1774, "reviewThreads": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTowNToxNVrOEAovNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMzoxODoyM1rOEJShJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTAyOTAwOnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTowNToxNVrOGcCr9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwMDoyNjo0NVrOGcLCtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1NzMzNA==", "bodyText": "This stuff committed already?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432057334", "createdAt": "2020-05-28T19:05:15Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -1403,6 +1409,21 @@ private static void deleteFromMetaTable(final Connection connection, final List<\n     }\n   }\n \n+  public static Delete removeRegionReplica(byte[] metaRow, int replicaIndexToDeleteFrom,\n+    int numReplicasToRemove) {\n+    int absoluteIndex = replicaIndexToDeleteFrom + numReplicasToRemove;\n+    long now = EnvironmentEdgeManager.currentTime();\n+    Delete deleteReplicaLocations = new Delete(metaRow);\n+    for (int i = replicaIndexToDeleteFrom; i < absoluteIndex; i++) {\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getServerColumn(i), now);\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getSeqNumColumn(i), now);\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getStartCodeColumn(i), now);\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getServerNameColumn(i), now);\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getRegionStateColumn(i), now);\n+    }\n+    return deleteReplicaLocations;\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5NDIzMQ==", "bodyText": "No. This is for supportting MasterMetaBootstrap. We do not touch this class in the previous PR.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432194231", "createdAt": "2020-05-29T00:26:45Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -1403,6 +1409,21 @@ private static void deleteFromMetaTable(final Connection connection, final List<\n     }\n   }\n \n+  public static Delete removeRegionReplica(byte[] metaRow, int replicaIndexToDeleteFrom,\n+    int numReplicasToRemove) {\n+    int absoluteIndex = replicaIndexToDeleteFrom + numReplicasToRemove;\n+    long now = EnvironmentEdgeManager.currentTime();\n+    Delete deleteReplicaLocations = new Delete(metaRow);\n+    for (int i = replicaIndexToDeleteFrom; i < absoluteIndex; i++) {\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getServerColumn(i), now);\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getSeqNumColumn(i), now);\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getStartCodeColumn(i), now);\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getServerNameColumn(i), now);\n+      deleteReplicaLocations.addColumns(getCatalogFamily(), getRegionStateColumn(i), now);\n+    }\n+    return deleteReplicaLocations;\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA1NzMzNA=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTA2MTQ1OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOToxNToxMVrOGcDAVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMzozMDowNVrOGg3jow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MjU1MA==", "bodyText": "Why we need locateType now and not previously?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432062550", "createdAt": "2020-05-28T19:15:11Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -2185,4 +2206,27 @@ private static Put addSequenceNum(Put p, long openSeqNum, int replicaId) throws\n               .setValue(Bytes.toBytes(openSeqNum))\n               .build());\n   }\n+\n+  private static byte[] buildLocateRegionStartRow(TableName tableName, byte[] row,\n+    RegionLocateType locateType) {\n+    if (locateType.equals(RegionLocateType.BEFORE)) {\n+      if (Bytes.equals(row, HConstants.EMPTY_END_ROW)) {\n+        byte[] binaryTableName = tableName.getName();\n+        return Arrays.copyOf(binaryTableName, binaryTableName.length + 1);\n+      } else {\n+        return createRegionName(tableName, row, ZEROES, false);\n+      }\n+    } else {\n+      return createRegionName(tableName, row, NINES, false);\n+    }\n+  }\n+\n+  public static Scan createLocateRegionScan(TableName tableName, byte[] row,\n+    RegionLocateType locateType, int prefetchLimit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3MzQxOA==", "bodyText": "Why is this not just a case of Scan forward or Scan backward?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432073418", "createdAt": "2020-05-28T19:36:22Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -2185,4 +2206,27 @@ private static Put addSequenceNum(Put p, long openSeqNum, int replicaId) throws\n               .setValue(Bytes.toBytes(openSeqNum))\n               .build());\n   }\n+\n+  private static byte[] buildLocateRegionStartRow(TableName tableName, byte[] row,\n+    RegionLocateType locateType) {\n+    if (locateType.equals(RegionLocateType.BEFORE)) {\n+      if (Bytes.equals(row, HConstants.EMPTY_END_ROW)) {\n+        byte[] binaryTableName = tableName.getName();\n+        return Arrays.copyOf(binaryTableName, binaryTableName.length + 1);\n+      } else {\n+        return createRegionName(tableName, row, ZEROES, false);\n+      }\n+    } else {\n+      return createRegionName(tableName, row, NINES, false);\n+    }\n+  }\n+\n+  public static Scan createLocateRegionScan(TableName tableName, byte[] row,\n+    RegionLocateType locateType, int prefetchLimit) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MjU1MA=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5NDAxNQ==", "bodyText": "This is for abstraction, at this layer we do not care whether you are doing scan or what ever else, The only thing I care is how you want to locate a region through the given row, i.e, the direction.\nAnd we have this logic, at least for two years after we introduced async client. If you are talking about the code before async client, the locating logic is placed everywhere in code, which is not good.\nFor supporting reverse scan, we have special logic to locate to the previous region in this class\nhttps://github.com/apache/hbase/blob/branch-2/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ReversedScannerCallable.java", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432194015", "createdAt": "2020-05-29T00:25:52Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -2185,4 +2206,27 @@ private static Put addSequenceNum(Put p, long openSeqNum, int replicaId) throws\n               .setValue(Bytes.toBytes(openSeqNum))\n               .build());\n   }\n+\n+  private static byte[] buildLocateRegionStartRow(TableName tableName, byte[] row,\n+    RegionLocateType locateType) {\n+    if (locateType.equals(RegionLocateType.BEFORE)) {\n+      if (Bytes.equals(row, HConstants.EMPTY_END_ROW)) {\n+        byte[] binaryTableName = tableName.getName();\n+        return Arrays.copyOf(binaryTableName, binaryTableName.length + 1);\n+      } else {\n+        return createRegionName(tableName, row, ZEROES, false);\n+      }\n+    } else {\n+      return createRegionName(tableName, row, NINES, false);\n+    }\n+  }\n+\n+  public static Scan createLocateRegionScan(TableName tableName, byte[] row,\n+    RegionLocateType locateType, int prefetchLimit) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MjU1MA=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzNjYxOQ==", "bodyText": "'abstraction'? IIRC, this class is the access point for hbase:meta. It is all about Scans that take Visitors, Puts, and Deletes against hbase:meta; i.e. not 'abstractions'.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436436619", "createdAt": "2020-06-08T02:59:41Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -2185,4 +2206,27 @@ private static Put addSequenceNum(Put p, long openSeqNum, int replicaId) throws\n               .setValue(Bytes.toBytes(openSeqNum))\n               .build());\n   }\n+\n+  private static byte[] buildLocateRegionStartRow(TableName tableName, byte[] row,\n+    RegionLocateType locateType) {\n+    if (locateType.equals(RegionLocateType.BEFORE)) {\n+      if (Bytes.equals(row, HConstants.EMPTY_END_ROW)) {\n+        byte[] binaryTableName = tableName.getName();\n+        return Arrays.copyOf(binaryTableName, binaryTableName.length + 1);\n+      } else {\n+        return createRegionName(tableName, row, ZEROES, false);\n+      }\n+    } else {\n+      return createRegionName(tableName, row, NINES, false);\n+    }\n+  }\n+\n+  public static Scan createLocateRegionScan(TableName tableName, byte[] row,\n+    RegionLocateType locateType, int prefetchLimit) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MjU1MA=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzODU0OA==", "bodyText": "hmmm... Went back and saw the locateInMeta.  This replicates the head of that method? It should use this?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436438548", "createdAt": "2020-06-08T03:12:04Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -2185,4 +2206,27 @@ private static Put addSequenceNum(Put p, long openSeqNum, int replicaId) throws\n               .setValue(Bytes.toBytes(openSeqNum))\n               .build());\n   }\n+\n+  private static byte[] buildLocateRegionStartRow(TableName tableName, byte[] row,\n+    RegionLocateType locateType) {\n+    if (locateType.equals(RegionLocateType.BEFORE)) {\n+      if (Bytes.equals(row, HConstants.EMPTY_END_ROW)) {\n+        byte[] binaryTableName = tableName.getName();\n+        return Arrays.copyOf(binaryTableName, binaryTableName.length + 1);\n+      } else {\n+        return createRegionName(tableName, row, ZEROES, false);\n+      }\n+    } else {\n+      return createRegionName(tableName, row, NINES, false);\n+    }\n+  }\n+\n+  public static Scan createLocateRegionScan(TableName tableName, byte[] row,\n+    RegionLocateType locateType, int prefetchLimit) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MjU1MA=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzg1OQ==", "bodyText": "We could be better orginzation of these methods in follow on patches, i.e, moving this method to other places to not mess up the MetaTableAccessor. I do not have strong feelings that this method must be put here.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437117859", "createdAt": "2020-06-09T03:30:05Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/MetaTableAccessor.java", "diffHunk": "@@ -2185,4 +2206,27 @@ private static Put addSequenceNum(Put p, long openSeqNum, int replicaId) throws\n               .setValue(Bytes.toBytes(openSeqNum))\n               .build());\n   }\n+\n+  private static byte[] buildLocateRegionStartRow(TableName tableName, byte[] row,\n+    RegionLocateType locateType) {\n+    if (locateType.equals(RegionLocateType.BEFORE)) {\n+      if (Bytes.equals(row, HConstants.EMPTY_END_ROW)) {\n+        byte[] binaryTableName = tableName.getName();\n+        return Arrays.copyOf(binaryTableName, binaryTableName.length + 1);\n+      } else {\n+        return createRegionName(tableName, row, ZEROES, false);\n+      }\n+    } else {\n+      return createRegionName(tableName, row, NINES, false);\n+    }\n+  }\n+\n+  public static Scan createLocateRegionScan(TableName tableName, byte[] row,\n+    RegionLocateType locateType, int prefetchLimit) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2MjU1MA=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTA3MTQ4OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaTableRegionLocator.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOToxODoyN1rOGcDG5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzoyMzo0NFrOGgONMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NDIyOQ==", "bodyText": "Two locators. Can we not have one?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432064229", "createdAt": "2020-05-28T19:18:27Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.AsyncMetaTableAccessor;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.MetaTableAccessor;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.TableNotFoundException;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The class for locating region for table other than meta.\n+ */\n+@InterfaceAudience.Private\n+class AsyncNonMetaTableRegionLocator extends AbstractAsyncTableRegionLocator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NTQ4Nw==", "bodyText": "An AsyncNonMetaTableRegionLocator is for user-space Regions? We also have AsyncRegionLocator... and Abstract* Do we have to have this many classes?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432065487", "createdAt": "2020-05-28T19:20:54Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.AsyncMetaTableAccessor;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.MetaTableAccessor;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.TableNotFoundException;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The class for locating region for table other than meta.\n+ */\n+@InterfaceAudience.Private\n+class AsyncNonMetaTableRegionLocator extends AbstractAsyncTableRegionLocator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NDIyOQ=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5MDEyNw==", "bodyText": "We do have these locators before this patch. Th AsyncRegionLocator is for the general interface to communicate with upper layer, and in the past, we have AsyncMetaRegionLocator and AsyncNonMetaRegionLocator, for dealing with meta table and non meta table.\nIn this patch, the old stuff in AsyncMetaRegionLocator has all been purged, and most of the logic in AsyncNonMetaRegionLocator have been moved to AsyncRegionLocator and AbstractAsyncTableRegionLocator. The latter one is created for sharing code between meta table and non meta table.\nWe can put all these logics in a single class, as all class inherits can also be done by a if in the code. But I think doing this is an anti-pattern in java, as it will introduce very big classes, which is already a big problem in HBase(think of the old AsyncProcess class, it is a nightmare to me...).", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432190127", "createdAt": "2020-05-29T00:10:44Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.AsyncMetaTableAccessor;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.MetaTableAccessor;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.TableNotFoundException;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The class for locating region for table other than meta.\n+ */\n+@InterfaceAudience.Private\n+class AsyncNonMetaTableRegionLocator extends AbstractAsyncTableRegionLocator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NDIyOQ=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MDM3MQ==", "bodyText": "Ok. I'm reacting to our Interface => Abstract => Impl tiering.... We do it too often.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436440371", "createdAt": "2020-06-08T03:23:44Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.AsyncMetaTableAccessor;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.MetaTableAccessor;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.TableNotFoundException;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The class for locating region for table other than meta.\n+ */\n+@InterfaceAudience.Private\n+class AsyncNonMetaTableRegionLocator extends AbstractAsyncTableRegionLocator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA2NDIyOQ=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTEzNzg4OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTo0MDowMlrOGcDxuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMzowODozMlrOGpw8HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NTE5Mg==", "bodyText": "Why we now need type?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432075192", "createdAt": "2020-05-28T19:40:02Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.HConstants.EMPTY_END_ROW;\n+import static org.apache.hadoop.hbase.client.AsyncRegionLocatorHelper.isGood;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.hadoop.hbase.HBaseIOException;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * The base class for locating region of a table.\n+ */\n+@InterfaceAudience.Private\n+abstract class AbstractAsyncTableRegionLocator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(AbstractAsyncTableRegionLocator.class);\n+\n+  protected final AsyncConnectionImpl conn;\n+\n+  protected final TableName tableName;\n+\n+  protected final int maxConcurrent;\n+\n+  protected final TableRegionLocationCache cache;\n+\n+  protected static final class LocateRequest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE4ODEyMQ==", "bodyText": "Not now, the locateType is introduced at the same time with async client, for isolating all the locating related logic from upper layer. The magic is to construct different Scan object, with modified startRow, or include/exclude the startRow.\nWe have to support this, one of the most important reason is for supporting reverse scan, where we need to locate the region before the current region, but what we have is the start row of the current region, which is not part of the region before, so we need to use LocateType.BEFORE to get the location.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r432188121", "createdAt": "2020-05-29T00:03:23Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.HConstants.EMPTY_END_ROW;\n+import static org.apache.hadoop.hbase.client.AsyncRegionLocatorHelper.isGood;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.hadoop.hbase.HBaseIOException;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * The base class for locating region of a table.\n+ */\n+@InterfaceAudience.Private\n+abstract class AbstractAsyncTableRegionLocator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(AbstractAsyncTableRegionLocator.class);\n+\n+  protected final AsyncConnectionImpl conn;\n+\n+  protected final TableName tableName;\n+\n+  protected final int maxConcurrent;\n+\n+  protected final TableRegionLocationCache cache;\n+\n+  protected static final class LocateRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NTE5Mg=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzNjk4MA==", "bodyText": "Has to be an abstract? If so, why?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436436980", "createdAt": "2020-06-08T03:01:38Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.HConstants.EMPTY_END_ROW;\n+import static org.apache.hadoop.hbase.client.AsyncRegionLocatorHelper.isGood;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.hadoop.hbase.HBaseIOException;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * The base class for locating region of a table.\n+ */\n+@InterfaceAudience.Private\n+abstract class AbstractAsyncTableRegionLocator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(AbstractAsyncTableRegionLocator.class);\n+\n+  protected final AsyncConnectionImpl conn;\n+\n+  protected final TableName tableName;\n+\n+  protected final int maxConcurrent;\n+\n+  protected final TableRegionLocationCache cache;\n+\n+  protected static final class LocateRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NTE5Mg=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzOTczNQ==", "bodyText": "I see, abstract to share code between user-space and meta-space table locators.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436439735", "createdAt": "2020-06-08T03:19:32Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.HConstants.EMPTY_END_ROW;\n+import static org.apache.hadoop.hbase.client.AsyncRegionLocatorHelper.isGood;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.hadoop.hbase.HBaseIOException;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * The base class for locating region of a table.\n+ */\n+@InterfaceAudience.Private\n+abstract class AbstractAsyncTableRegionLocator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(AbstractAsyncTableRegionLocator.class);\n+\n+  protected final AsyncConnectionImpl conn;\n+\n+  protected final TableName tableName;\n+\n+  protected final int maxConcurrent;\n+\n+  protected final TableRegionLocationCache cache;\n+\n+  protected static final class LocateRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NTE5Mg=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NjYyMA==", "bodyText": "Let me resolve. I see that this is just a move of code. My fault for not knowing this code well enough and realizing it not new.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446446620", "createdAt": "2020-06-26T23:08:32Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.HConstants.EMPTY_END_ROW;\n+import static org.apache.hadoop.hbase.client.AsyncRegionLocatorHelper.isGood;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.hadoop.hbase.HBaseIOException;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * The base class for locating region of a table.\n+ */\n+@InterfaceAudience.Private\n+abstract class AbstractAsyncTableRegionLocator {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(AbstractAsyncTableRegionLocator.class);\n+\n+  protected final AsyncConnectionImpl conn;\n+\n+  protected final TableName tableName;\n+\n+  protected final int maxConcurrent;\n+\n+  protected final TableRegionLocationCache cache;\n+\n+  protected static final class LocateRequest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA3NTE5Mg=="}, "originalCommit": {"oid": "acc2946b315874fefa45d7853d23a8c2f52741f6"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODgwMTMxOnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/AsyncMetaTableAccessor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMjozNjoxNVrOGgNv5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjoxNToyN1rOGgQYTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMjg2OQ==", "bodyText": "Why we need this? The default is not to return offlined locations (as per the the original method impl). You ask for raw scan if you do want all including offlined.\ns/excludeOfflinedSplitParents/excludeSplitParents/ because split parents are offlined by definition?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436432869", "createdAt": "2020-06-08T02:36:15Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/AsyncMetaTableAccessor.java", "diffHunk": "@@ -170,26 +170,27 @@\n \n   /**\n    * Used to get all region locations for the specific table.\n-   * @param metaTable\n    * @param tableName table we're looking for, can be null for getting all regions\n    * @return the list of region locations. The return value will be wrapped by a\n    *         {@link CompletableFuture}.\n    */\n   public static CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(\n-      AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName) {\n+    AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName,\n+    boolean excludeOfflinedSplitParents) {\n     CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-    addListener(getTableRegionsAndLocations(metaTable, tableName, true), (locations, err) -> {\n-      if (err != null) {\n-        future.completeExceptionally(err);\n-      } else if (locations == null || locations.isEmpty()) {\n-        future.complete(Collections.emptyList());\n-      } else {\n-        List<HRegionLocation> regionLocations =\n-          locations.stream().map(loc -> new HRegionLocation(loc.getFirst(), loc.getSecond()))\n-            .collect(Collectors.toList());\n-        future.complete(regionLocations);\n-      }\n-    });\n+    addListener(getTableRegionsAndLocations(metaTable, tableName, excludeOfflinedSplitParents),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f10bfe7a4c6a852fa56cfa479f62e2123bb5321"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzNTIzNg==", "bodyText": "This is async version of\n// What happens here when 1M regions in hbase:meta? This won't scale?\n public static List<Pair<RegionInfo, ServerName>> getTableRegionsAndLocations(", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436435236", "createdAt": "2020-06-08T02:51:12Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/AsyncMetaTableAccessor.java", "diffHunk": "@@ -170,26 +170,27 @@\n \n   /**\n    * Used to get all region locations for the specific table.\n-   * @param metaTable\n    * @param tableName table we're looking for, can be null for getting all regions\n    * @return the list of region locations. The return value will be wrapped by a\n    *         {@link CompletableFuture}.\n    */\n   public static CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(\n-      AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName) {\n+    AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName,\n+    boolean excludeOfflinedSplitParents) {\n     CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-    addListener(getTableRegionsAndLocations(metaTable, tableName, true), (locations, err) -> {\n-      if (err != null) {\n-        future.completeExceptionally(err);\n-      } else if (locations == null || locations.isEmpty()) {\n-        future.complete(Collections.emptyList());\n-      } else {\n-        List<HRegionLocation> regionLocations =\n-          locations.stream().map(loc -> new HRegionLocation(loc.getFirst(), loc.getSecond()))\n-            .collect(Collectors.toList());\n-        future.complete(regionLocations);\n-      }\n-    });\n+    addListener(getTableRegionsAndLocations(metaTable, tableName, excludeOfflinedSplitParents),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMjg2OQ=="}, "originalCommit": {"oid": "0f10bfe7a4c6a852fa56cfa479f62e2123bb5321"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NTk4Mw==", "bodyText": "At least for snapshot, we need to get the split parent.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436475983", "createdAt": "2020-06-08T06:15:27Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/AsyncMetaTableAccessor.java", "diffHunk": "@@ -170,26 +170,27 @@\n \n   /**\n    * Used to get all region locations for the specific table.\n-   * @param metaTable\n    * @param tableName table we're looking for, can be null for getting all regions\n    * @return the list of region locations. The return value will be wrapped by a\n    *         {@link CompletableFuture}.\n    */\n   public static CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(\n-      AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName) {\n+    AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName,\n+    boolean excludeOfflinedSplitParents) {\n     CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-    addListener(getTableRegionsAndLocations(metaTable, tableName, true), (locations, err) -> {\n-      if (err != null) {\n-        future.completeExceptionally(err);\n-      } else if (locations == null || locations.isEmpty()) {\n-        future.complete(Collections.emptyList());\n-      } else {\n-        List<HRegionLocation> regionLocations =\n-          locations.stream().map(loc -> new HRegionLocation(loc.getFirst(), loc.getSecond()))\n-            .collect(Collectors.toList());\n-        future.complete(regionLocations);\n-      }\n-    });\n+    addListener(getTableRegionsAndLocations(metaTable, tableName, excludeOfflinedSplitParents),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMjg2OQ=="}, "originalCommit": {"oid": "0f10bfe7a4c6a852fa56cfa479f62e2123bb5321"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODg0OTAzOnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncMetaTableRegionLocator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzoyMjowMFrOGgOMSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjoyMDo0MVrOGgQeJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MDEzOQ==", "bodyText": "Still this new Service? Not ConnectionRegistry?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436440139", "createdAt": "2020-06-08T03:22:00Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncMetaTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.MasterNotRunningException;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.exceptions.ClientExceptionsUtil;\n+import org.apache.hadoop.hbase.ipc.HBaseRpcController;\n+import org.apache.hadoop.hbase.ipc.ServerNotRunningYetException;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.protobuf.ByteString;\n+\n+import org.apache.hadoop.hbase.shaded.protobuf.ProtobufUtil;\n+import org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos.ClientMetaService;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NzQ3Ng==", "bodyText": "Just add two methods to the ClientMetaService, which is used by MasterConnectionRegistry. As said in the design doc, we can implement the logic in ConnectionRegistry, but can be a follow on issue, as we also need to support this in ZKConnectionRegistry, which is not necessary to make things work but will make a patch even bigger...", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436477476", "createdAt": "2020-06-08T06:20:41Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncMetaTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.MasterNotRunningException;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.exceptions.ClientExceptionsUtil;\n+import org.apache.hadoop.hbase.ipc.HBaseRpcController;\n+import org.apache.hadoop.hbase.ipc.ServerNotRunningYetException;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.protobuf.ByteString;\n+\n+import org.apache.hadoop.hbase.shaded.protobuf.ProtobufUtil;\n+import org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos.ClientMetaService;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MDEzOQ=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODg1MTY0OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRegionLocator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzoyNTowNFrOGgON3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjoyMjoxOVrOGgQgJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MDU0MQ==", "bodyText": "Whats this? One locator for meta and another for user-space Tables?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436440541", "createdAt": "2020-06-08T03:25:04Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRegionLocator.java", "diffHunk": "@@ -44,25 +51,51 @@\n @InterfaceAudience.Private\n class AsyncRegionLocator {\n \n-  private static final Logger LOG = LoggerFactory.getLogger(AsyncRegionLocator.class);\n+  @VisibleForTesting\n+  static final String MAX_CONCURRENT_LOCATE_REQUEST_PER_TABLE =\n+    \"hbase.client.meta.max.concurrent.locate.per.table\";\n+\n+  private static final int DEFAULT_MAX_CONCURRENT_LOCATE_REQUEST_PER_TABLE = 8;\n+\n+  @VisibleForTesting\n+  static final String MAX_CONCURRENT_LOCATE_META_REQUEST =\n+    \"hbase.client.meta.max.concurrent.locate\";\n+\n+  @VisibleForTesting\n+  static String LOCATE_PREFETCH_LIMIT = \"hbase.client.locate.prefetch.limit\";\n+\n+  private static final int DEFAULT_LOCATE_PREFETCH_LIMIT = 10;\n \n   private final HashedWheelTimer retryTimer;\n \n   private final AsyncConnectionImpl conn;\n \n-  private final AsyncMetaRegionLocator metaRegionLocator;\n+  private final int maxConcurrentLocateRequestPerTable;\n+\n+  private final int maxConcurrentLocateMetaRequest;\n+\n+  private final int locatePrefetchLimit;\n \n-  private final AsyncNonMetaRegionLocator nonMetaRegionLocator;\n+  private final boolean useMetaReplicas;\n \n-  AsyncRegionLocator(AsyncConnectionImpl conn, HashedWheelTimer retryTimer) {\n+  private final ConcurrentMap<TableName, AbstractAsyncTableRegionLocator> table2Locator =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3Nzk4OA==", "bodyText": "Every table will have a locator. The cache is in the locator, and the concurrency locating limit is also implemented per table. We make it abstract is because we use different ways to locate meta and other table regions.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436477988", "createdAt": "2020-06-08T06:22:19Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRegionLocator.java", "diffHunk": "@@ -44,25 +51,51 @@\n @InterfaceAudience.Private\n class AsyncRegionLocator {\n \n-  private static final Logger LOG = LoggerFactory.getLogger(AsyncRegionLocator.class);\n+  @VisibleForTesting\n+  static final String MAX_CONCURRENT_LOCATE_REQUEST_PER_TABLE =\n+    \"hbase.client.meta.max.concurrent.locate.per.table\";\n+\n+  private static final int DEFAULT_MAX_CONCURRENT_LOCATE_REQUEST_PER_TABLE = 8;\n+\n+  @VisibleForTesting\n+  static final String MAX_CONCURRENT_LOCATE_META_REQUEST =\n+    \"hbase.client.meta.max.concurrent.locate\";\n+\n+  @VisibleForTesting\n+  static String LOCATE_PREFETCH_LIMIT = \"hbase.client.locate.prefetch.limit\";\n+\n+  private static final int DEFAULT_LOCATE_PREFETCH_LIMIT = 10;\n \n   private final HashedWheelTimer retryTimer;\n \n   private final AsyncConnectionImpl conn;\n \n-  private final AsyncMetaRegionLocator metaRegionLocator;\n+  private final int maxConcurrentLocateRequestPerTable;\n+\n+  private final int maxConcurrentLocateMetaRequest;\n+\n+  private final int locatePrefetchLimit;\n \n-  private final AsyncNonMetaRegionLocator nonMetaRegionLocator;\n+  private final boolean useMetaReplicas;\n \n-  AsyncRegionLocator(AsyncConnectionImpl conn, HashedWheelTimer retryTimer) {\n+  private final ConcurrentMap<TableName, AbstractAsyncTableRegionLocator> table2Locator =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MDU0MQ=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODg1ODU1OnYy", "diffSide": "LEFT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionRegistry.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzozMDozM1rOGgOR2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjozNDo1NlrOGgQwKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MTU2MA==", "bodyText": "Just removed. We trying to add api in here https://docs.google.com/document/d/1OYrCfpmmLPkSa5-AepQw8hv09zNcNPaFzSXezhcMS7E/edit?ts=5ed4e463#heading=h.kxnc4cup53tk", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436441560", "createdAt": "2020-06-08T03:30:33Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionRegistry.java", "diffHunk": "@@ -31,11 +30,6 @@\n @InterfaceAudience.Private\n interface ConnectionRegistry extends Closeable {\n \n-  /**\n-   * Get the location of meta region(s).\n-   */\n-  CompletableFuture<RegionLocations> getMetaRegionLocations();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MjA5MA==", "bodyText": "Can do this in https://issues.apache.org/jira/browse/HBASE-24459", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436482090", "createdAt": "2020-06-08T06:34:56Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionRegistry.java", "diffHunk": "@@ -31,11 +30,6 @@\n @InterfaceAudience.Private\n interface ConnectionRegistry extends Closeable {\n \n-  /**\n-   * Get the location of meta region(s).\n-   */\n-  CompletableFuture<RegionLocations> getMetaRegionLocations();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MTU2MA=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODg1OTM2OnYy", "diffSide": "LEFT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzozMTowOFrOGgOSSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzozMTowOFrOGgOSSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MTY3Mg==", "bodyText": "Not used any more?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436441672", "createdAt": "2020-06-08T03:31:08Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -186,24 +186,6 @@ public long getNonceGroup() {\n     return Arrays.copyOf(row, row.length + 1);\n   }\n \n-  /**\n-   * Create a row before the specified row and very close to the specified row.\n-   */\n-  static byte[] createCloseRowBefore(byte[] row) {\n-    if (row.length == 0) {\n-      return MAX_BYTE_ARRAY;\n-    }\n-    if (row[row.length - 1] == 0) {\n-      return Arrays.copyOf(row, row.length - 1);\n-    } else {\n-      byte[] nextRow = new byte[row.length + MAX_BYTE_ARRAY.length];\n-      System.arraycopy(row, 0, nextRow, 0, row.length - 1);\n-      nextRow[row.length - 1] = (byte) ((row[row.length - 1] & 0xFF) - 1);\n-      System.arraycopy(MAX_BYTE_ARRAY, 0, nextRow, row.length, MAX_BYTE_ARRAY.length);\n-      return nextRow;\n-    }\n-  }\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODg2MzA5OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/RawAsyncHBaseAdmin.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzozNTowN1rOGgOUgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMzoyMjo0MVrOGgzpSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjI0MA==", "bodyText": "Having trouble following what is going on. Excuse me.\nThis looks better. Gets RegionLocator from Connection.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436442240", "createdAt": "2020-06-08T03:35:07Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/RawAsyncHBaseAdmin.java", "diffHunk": "@@ -1105,23 +1097,7 @@ public void run(PRESP resp) {\n    * List all region locations for the specific table.\n    */\n   private CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(TableName tableName) {\n-    if (TableName.META_TABLE_NAME.equals(tableName)) {\n-      CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-      addListener(connection.registry.getMetaRegionLocations(), (metaRegions, err) -> {\n-        if (err != null) {\n-          future.completeExceptionally(err);\n-        } else if (metaRegions == null || metaRegions.isEmpty() ||\n-          metaRegions.getDefaultRegionLocation() == null) {\n-          future.completeExceptionally(new IOException(\"meta region does not found\"));\n-        } else {\n-          future.complete(Collections.singletonList(metaRegions.getDefaultRegionLocation()));\n-        }\n-      });\n-      return future;\n-    } else {\n-      // For non-meta table, we fetch all locations by scanning hbase:meta table\n-      return AsyncMetaTableAccessor.getTableHRegionLocations(metaTable, tableName);\n-    }\n+    return connection.getRegionLocator(tableName).getAllRegionLocations();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjMyNw==", "bodyText": "RegionLocator does the right thing based off table name?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436442327", "createdAt": "2020-06-08T03:35:36Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/RawAsyncHBaseAdmin.java", "diffHunk": "@@ -1105,23 +1097,7 @@ public void run(PRESP resp) {\n    * List all region locations for the specific table.\n    */\n   private CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(TableName tableName) {\n-    if (TableName.META_TABLE_NAME.equals(tableName)) {\n-      CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-      addListener(connection.registry.getMetaRegionLocations(), (metaRegions, err) -> {\n-        if (err != null) {\n-          future.completeExceptionally(err);\n-        } else if (metaRegions == null || metaRegions.isEmpty() ||\n-          metaRegions.getDefaultRegionLocation() == null) {\n-          future.completeExceptionally(new IOException(\"meta region does not found\"));\n-        } else {\n-          future.complete(Collections.singletonList(metaRegions.getDefaultRegionLocation()));\n-        }\n-      });\n-      return future;\n-    } else {\n-      // For non-meta table, we fetch all locations by scanning hbase:meta table\n-      return AsyncMetaTableAccessor.getTableHRegionLocations(metaTable, tableName);\n-    }\n+    return connection.getRegionLocator(tableName).getAllRegionLocations();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjI0MA=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MzM3Mg==", "bodyText": "The problem is that, for meta table we can not use the methods from ConnectionRegistry any more as now we could have multiple meta regions, so we change to use RegionLocator, and the RegionLocator could also deal with normal tables, so here we can unify them together.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436483372", "createdAt": "2020-06-08T06:38:35Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/RawAsyncHBaseAdmin.java", "diffHunk": "@@ -1105,23 +1097,7 @@ public void run(PRESP resp) {\n    * List all region locations for the specific table.\n    */\n   private CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(TableName tableName) {\n-    if (TableName.META_TABLE_NAME.equals(tableName)) {\n-      CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-      addListener(connection.registry.getMetaRegionLocations(), (metaRegions, err) -> {\n-        if (err != null) {\n-          future.completeExceptionally(err);\n-        } else if (metaRegions == null || metaRegions.isEmpty() ||\n-          metaRegions.getDefaultRegionLocation() == null) {\n-          future.completeExceptionally(new IOException(\"meta region does not found\"));\n-        } else {\n-          future.complete(Collections.singletonList(metaRegions.getDefaultRegionLocation()));\n-        }\n-      });\n-      return future;\n-    } else {\n-      // For non-meta table, we fetch all locations by scanning hbase:meta table\n-      return AsyncMetaTableAccessor.getTableHRegionLocations(metaTable, tableName);\n-    }\n+    return connection.getRegionLocator(tableName).getAllRegionLocations();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjI0MA=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1Mzc3MA==", "bodyText": "Looks good.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437053770", "createdAt": "2020-06-08T23:22:41Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/RawAsyncHBaseAdmin.java", "diffHunk": "@@ -1105,23 +1097,7 @@ public void run(PRESP resp) {\n    * List all region locations for the specific table.\n    */\n   private CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(TableName tableName) {\n-    if (TableName.META_TABLE_NAME.equals(tableName)) {\n-      CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-      addListener(connection.registry.getMetaRegionLocations(), (metaRegions, err) -> {\n-        if (err != null) {\n-          future.completeExceptionally(err);\n-        } else if (metaRegions == null || metaRegions.isEmpty() ||\n-          metaRegions.getDefaultRegionLocation() == null) {\n-          future.completeExceptionally(new IOException(\"meta region does not found\"));\n-        } else {\n-          future.complete(Collections.singletonList(metaRegions.getDefaultRegionLocation()));\n-        }\n-      });\n-      return future;\n-    } else {\n-      // For non-meta table, we fetch all locations by scanning hbase:meta table\n-      return AsyncMetaTableAccessor.getTableHRegionLocations(metaTable, tableName);\n-    }\n+    return connection.getRegionLocator(tableName).getAllRegionLocations();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MjI0MA=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODg2OTg4OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/shaded/protobuf/ProtobufUtil.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo0MDoyNFrOGgOYQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMzoyMDozNVrOGgzm1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MzIwMg==", "bodyText": "Why is this wanted in proto now if we had it since async came in?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436443202", "createdAt": "2020-06-08T03:40:24Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/shaded/protobuf/ProtobufUtil.java", "diffHunk": "@@ -3537,4 +3538,30 @@ public static RSGroupInfo toGroupInfo(RSGroupProtos.RSGroupInfo proto) {\n     return RSGroupProtos.RSGroupInfo.newBuilder().setName(pojo.getName()).addAllServers(hostports)\n         .addAllTables(tables).build();\n   }\n+\n+  public static MasterProtos.RegionLocateType toProtoRegionLocateType(RegionLocateType pojo) {\n+    switch (pojo) {\n+      case BEFORE:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_BEFORE;\n+      case CURRENT:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_CURRENT;\n+      case AFTER:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_AFTER;\n+      default:\n+        throw new IllegalArgumentException(\"Unknown RegionLocateType: \" + pojo);\n+    }\n+  }\n+\n+  public static RegionLocateType toRegionLocateType(MasterProtos.RegionLocateType proto) {\n+    switch (proto) {\n+      case REGION_LOCATE_TYPE_BEFORE:\n+        return RegionLocateType.BEFORE;\n+      case REGION_LOCATE_TYPE_CURRENT:\n+        return RegionLocateType.CURRENT;\n+      case REGION_LOCATE_TYPE_AFTER:\n+        return RegionLocateType.AFTER;\n+      default:\n+        throw new IllegalArgumentException(\"Unknown proto RegionLocateType: \" + proto);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4Nzg1Ng==", "bodyText": "Because we introduced two new methods for locating meta? We do not need this before when locating meta, as there is only one meta region. And for locating normal regions, the code for supporting this 'locateType' is at client side, as we will scan the meta table. The 'locateType' will only effect the value of the startKey and also the inclusive/exclusive of the startKey.\nAnd here, as explained several times, I do not want to add full scan support when locating meta, so we have to pass the locateType as a parameter.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436487856", "createdAt": "2020-06-08T06:50:40Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/shaded/protobuf/ProtobufUtil.java", "diffHunk": "@@ -3537,4 +3538,30 @@ public static RSGroupInfo toGroupInfo(RSGroupProtos.RSGroupInfo proto) {\n     return RSGroupProtos.RSGroupInfo.newBuilder().setName(pojo.getName()).addAllServers(hostports)\n         .addAllTables(tables).build();\n   }\n+\n+  public static MasterProtos.RegionLocateType toProtoRegionLocateType(RegionLocateType pojo) {\n+    switch (pojo) {\n+      case BEFORE:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_BEFORE;\n+      case CURRENT:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_CURRENT;\n+      case AFTER:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_AFTER;\n+      default:\n+        throw new IllegalArgumentException(\"Unknown RegionLocateType: \" + pojo);\n+    }\n+  }\n+\n+  public static RegionLocateType toRegionLocateType(MasterProtos.RegionLocateType proto) {\n+    switch (proto) {\n+      case REGION_LOCATE_TYPE_BEFORE:\n+        return RegionLocateType.BEFORE;\n+      case REGION_LOCATE_TYPE_CURRENT:\n+        return RegionLocateType.CURRENT;\n+      case REGION_LOCATE_TYPE_AFTER:\n+        return RegionLocateType.AFTER;\n+      default:\n+        throw new IllegalArgumentException(\"Unknown proto RegionLocateType: \" + proto);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MzIwMg=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA1MzE0MQ==", "bodyText": "Could you transport this as a Scan? Convert the 'simple API' into a Scan behind the scenes so we don't have to do stuff like this?\n(I hear you on not wanting to support full Scan and have some sympathy but I am kicking against a simple API that seems arbitrary and unsatisfactory -- hence the questions. Pardon if annoying... also trying to figure what is going on in here... Takes me a while. I'm slow. Thanks).", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437053141", "createdAt": "2020-06-08T23:20:35Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/shaded/protobuf/ProtobufUtil.java", "diffHunk": "@@ -3537,4 +3538,30 @@ public static RSGroupInfo toGroupInfo(RSGroupProtos.RSGroupInfo proto) {\n     return RSGroupProtos.RSGroupInfo.newBuilder().setName(pojo.getName()).addAllServers(hostports)\n         .addAllTables(tables).build();\n   }\n+\n+  public static MasterProtos.RegionLocateType toProtoRegionLocateType(RegionLocateType pojo) {\n+    switch (pojo) {\n+      case BEFORE:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_BEFORE;\n+      case CURRENT:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_CURRENT;\n+      case AFTER:\n+        return MasterProtos.RegionLocateType.REGION_LOCATE_TYPE_AFTER;\n+      default:\n+        throw new IllegalArgumentException(\"Unknown RegionLocateType: \" + pojo);\n+    }\n+  }\n+\n+  public static RegionLocateType toRegionLocateType(MasterProtos.RegionLocateType proto) {\n+    switch (proto) {\n+      case REGION_LOCATE_TYPE_BEFORE:\n+        return RegionLocateType.BEFORE;\n+      case REGION_LOCATE_TYPE_CURRENT:\n+        return RegionLocateType.CURRENT;\n+      case REGION_LOCATE_TYPE_AFTER:\n+        return RegionLocateType.AFTER;\n+      default:\n+        throw new IllegalArgumentException(\"Unknown proto RegionLocateType: \" + proto);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MzIwMg=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODg3NDM1OnYy", "diffSide": "RIGHT", "path": "hbase-protocol-shaded/src/main/protobuf/server/master/Master.proto", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo0NDo1NlrOGgOa8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMjo0NTowNlrOGg25DA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0Mzg5MQ==", "bodyText": "ClientMetaService backed ConnectionRegistry?\nSo, we get one Region or all of them... nothing in-between?\nNo Scan support here because we want 'dumbed-down API' in ConnectionRegistry or in exposed ClientMetaService? We want to be able to implement hbase:meta Region locations in cache that we can serve from ZK for your ZKConnectionRegistry impl?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436443891", "createdAt": "2020-06-08T03:44:56Z", "author": {"login": "saintstack"}, "path": "hbase-protocol-shaded/src/main/protobuf/server/master/Master.proto", "diffHunk": "@@ -1284,4 +1307,16 @@ service ClientMetaService {\n    * Get current meta replicas' region locations.\n    */\n   rpc GetMetaRegionLocations(GetMetaRegionLocationsRequest) returns(GetMetaRegionLocationsResponse);\n+\n+  /**\n+   * Get meta region locations for a given row\n+   */\n+  rpc LocateMetaRegion(LocateMetaRegionRequest)\n+    returns(LocateMetaRegionResponse);\n+\n+  /**\n+   * Get all meta regions locations\n+   */\n+  rpc GetAllMetaRegionLocations(GetAllMetaRegionLocationsRequest)\n+    returns(GetAllMetaRegionLocationsResponse);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTE0NA==", "bodyText": "I think for now it is fine? Later we could add something like prefetch to the protobuf message if we want to load more than 1 regions per call.\nKeep the interface simple is important for implementing cache server. In general, if we only support these two methods, we could just use an in memory map to cache the locations(just like waht we have done in client side meta cache), but if we want to support Scan, then probably we can only make use of a whole HRegion implementation...", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436485144", "createdAt": "2020-06-08T06:43:29Z", "author": {"login": "Apache9"}, "path": "hbase-protocol-shaded/src/main/protobuf/server/master/Master.proto", "diffHunk": "@@ -1284,4 +1307,16 @@ service ClientMetaService {\n    * Get current meta replicas' region locations.\n    */\n   rpc GetMetaRegionLocations(GetMetaRegionLocationsRequest) returns(GetMetaRegionLocationsResponse);\n+\n+  /**\n+   * Get meta region locations for a given row\n+   */\n+  rpc LocateMetaRegion(LocateMetaRegionRequest)\n+    returns(LocateMetaRegionResponse);\n+\n+  /**\n+   * Get all meta regions locations\n+   */\n+  rpc GetAllMetaRegionLocations(GetAllMetaRegionLocationsRequest)\n+    returns(GetAllMetaRegionLocationsResponse);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0Mzg5MQ=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0ODY5MQ==", "bodyText": "The api does not allow 'paging' through the hbase:master table Regions. Even if we prefetch the API is awkward for getting next Region.\nIf a paging API, we'd only need one method?\nI think current situation where we only get one Region because there is only one makes this API seem ok.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437048691", "createdAt": "2020-06-08T23:05:42Z", "author": {"login": "saintstack"}, "path": "hbase-protocol-shaded/src/main/protobuf/server/master/Master.proto", "diffHunk": "@@ -1284,4 +1307,16 @@ service ClientMetaService {\n    * Get current meta replicas' region locations.\n    */\n   rpc GetMetaRegionLocations(GetMetaRegionLocationsRequest) returns(GetMetaRegionLocationsResponse);\n+\n+  /**\n+   * Get meta region locations for a given row\n+   */\n+  rpc LocateMetaRegion(LocateMetaRegionRequest)\n+    returns(LocateMetaRegionResponse);\n+\n+  /**\n+   * Get all meta regions locations\n+   */\n+  rpc GetAllMetaRegionLocations(GetAllMetaRegionLocationsRequest)\n+    returns(GetAllMetaRegionLocationsResponse);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0Mzg5MQ=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNjk1Ng==", "bodyText": "There is a locateMeta method, which is to be used at the normal read/write path, to support locating a meta region with specific key. And what I said above, about the prefetch, is to add a prefetch parameter for the locateMeta method, not for the GetAllMetaRegionLocations method.\nThe GetAllMetaRegionLocations method are mainly designed to have two usages, one is for other cache servers to pull all the content so it can serve the locateMeta requests from client, another is for some maintainance methods, such as RegionLocator.getAllRegionLocations. We should not call this method for in normal read write path.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437106956", "createdAt": "2020-06-09T02:45:06Z", "author": {"login": "Apache9"}, "path": "hbase-protocol-shaded/src/main/protobuf/server/master/Master.proto", "diffHunk": "@@ -1284,4 +1307,16 @@ service ClientMetaService {\n    * Get current meta replicas' region locations.\n    */\n   rpc GetMetaRegionLocations(GetMetaRegionLocationsRequest) returns(GetMetaRegionLocationsResponse);\n+\n+  /**\n+   * Get meta region locations for a given row\n+   */\n+  rpc LocateMetaRegion(LocateMetaRegionRequest)\n+    returns(LocateMetaRegionResponse);\n+\n+  /**\n+   * Get all meta regions locations\n+   */\n+  rpc GetAllMetaRegionLocations(GetAllMetaRegionLocationsRequest)\n+    returns(GetAllMetaRegionLocationsResponse);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0Mzg5MQ=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODg3NzgyOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/MasterObserver.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo0NzozNVrOGgOc4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0NDo1OFrOGgQ-Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDM4NA==", "bodyText": "This is hard-coding Master as host of hbase:meta locations?\nWe have MasterRegistry and the ZKRegistry and but Master is host for all meta locations? This skirts Registry?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436444384", "createdAt": "2020-06-08T03:47:35Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/MasterObserver.java", "diffHunk": "@@ -1763,4 +1765,44 @@ default void preHasUserPermissions(ObserverContext<MasterCoprocessorEnvironment>\n   default void postHasUserPermissions(ObserverContext<MasterCoprocessorEnvironment> ctx,\n       String userName, List<Permission> permissions) throws IOException {\n   }\n+\n+  /**\n+   * Called before locating meta region.\n+   * @param ctx ctx the coprocessor instance's environment\n+   * @param row the row key to locate\n+   * @param locateType the direction of the locate operation\n+   */\n+  default void preLocateMetaRegion(ObserverContext<MasterCoprocessorEnvironment> ctx, byte[] row,\n+    RegionLocateType locateType) throws IOException {\n+  }\n+\n+  /**\n+   * Called after locating meta region.\n+   * @param ctx ctx the coprocessor instance's environment\n+   * @param row the row key to locate\n+   * @param locateType the direction of the locate operation\n+   * @param locs the locations of the given meta region, including meta replicas if any.\n+   */\n+  default void postLocateMetaRegion(ObserverContext<MasterCoprocessorEnvironment> ctx, byte[] row,\n+    RegionLocateType locateType, List<HRegionLocation> locs) throws IOException {\n+  }\n+\n+  /**\n+   * Called before getting all locations for meta regions.\n+   * @param ctx ctx the coprocessor instance's environment\n+   * @param excludeOfflinedSplitParents don't return split parents\n+   */\n+  default void preGetAllMetaRegionLocations(ObserverContext<MasterCoprocessorEnvironment> ctx,\n+    boolean excludeOfflinedSplitParents) {\n+  }\n+\n+  /**\n+   * Called after getting all locations for meta regions.\n+   * @param ctx ctx the coprocessor instance's environment\n+   * @param excludeOfflinedSplitParents don't return split parents\n+   * @param locs the locations of all meta regions, including meta replicas if any.\n+   */\n+  default void postGetAllMetaRegionLocations(ObserverContext<MasterCoprocessorEnvironment> ctx,\n+    boolean excludeOfflinedSplitParents, List<HRegionLocation> locs) {\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTYzNQ==", "bodyText": "These ConnectionRegistries are only used at client side, not for master side. Before this patch, we just store the location of meta in zk, which is also hard coded at master.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436485635", "createdAt": "2020-06-08T06:44:58Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/MasterObserver.java", "diffHunk": "@@ -1763,4 +1765,44 @@ default void preHasUserPermissions(ObserverContext<MasterCoprocessorEnvironment>\n   default void postHasUserPermissions(ObserverContext<MasterCoprocessorEnvironment> ctx,\n       String userName, List<Permission> permissions) throws IOException {\n   }\n+\n+  /**\n+   * Called before locating meta region.\n+   * @param ctx ctx the coprocessor instance's environment\n+   * @param row the row key to locate\n+   * @param locateType the direction of the locate operation\n+   */\n+  default void preLocateMetaRegion(ObserverContext<MasterCoprocessorEnvironment> ctx, byte[] row,\n+    RegionLocateType locateType) throws IOException {\n+  }\n+\n+  /**\n+   * Called after locating meta region.\n+   * @param ctx ctx the coprocessor instance's environment\n+   * @param row the row key to locate\n+   * @param locateType the direction of the locate operation\n+   * @param locs the locations of the given meta region, including meta replicas if any.\n+   */\n+  default void postLocateMetaRegion(ObserverContext<MasterCoprocessorEnvironment> ctx, byte[] row,\n+    RegionLocateType locateType, List<HRegionLocation> locs) throws IOException {\n+  }\n+\n+  /**\n+   * Called before getting all locations for meta regions.\n+   * @param ctx ctx the coprocessor instance's environment\n+   * @param excludeOfflinedSplitParents don't return split parents\n+   */\n+  default void preGetAllMetaRegionLocations(ObserverContext<MasterCoprocessorEnvironment> ctx,\n+    boolean excludeOfflinedSplitParents) {\n+  }\n+\n+  /**\n+   * Called after getting all locations for meta regions.\n+   * @param ctx ctx the coprocessor instance's environment\n+   * @param excludeOfflinedSplitParents don't return split parents\n+   * @param locs the locations of all meta regions, including meta replicas if any.\n+   */\n+  default void postGetAllMetaRegionLocations(ObserverContext<MasterCoprocessorEnvironment> ctx,\n+    boolean excludeOfflinedSplitParents, List<HRegionLocation> locs) {\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDM4NA=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODg3OTAwOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo0ODo0OFrOGgOdmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNjo0NjowOVrOGgQ_sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDU3MA==", "bodyText": "Region State is in zk?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436444570", "createdAt": "2020-06-08T03:48:48Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -868,8 +879,71 @@ protected void initializeZKBasedSystemTrackers()\n \n   // Will be overriden in test to inject customized AssignmentManager\n   @VisibleForTesting\n-  protected AssignmentManager createAssignmentManager(MasterServices master) {\n-    return new AssignmentManager(master);\n+  protected AssignmentManager createAssignmentManager(MasterServices master,\n+    MasterRegion masterRegion) {\n+    return new AssignmentManager(master, masterRegion);\n+  }\n+\n+  /**\n+   * Load the meta region state from the meta region server ZNode.\n+   * @param zkw reference to the {@link ZKWatcher} which also contains configuration and operation\n+   * @param replicaId the ID of the replica\n+   * @return regionstate\n+   * @throws KeeperException if a ZooKeeper operation fails\n+   */\n+  private static RegionState getMetaRegionState(ZKWatcher zkw, int replicaId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDY0OA==", "bodyText": "Perhaps this is old state? If so, maybe say so in doc?\nThe @return regionstate can be removed.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436444648", "createdAt": "2020-06-08T03:49:15Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -868,8 +879,71 @@ protected void initializeZKBasedSystemTrackers()\n \n   // Will be overriden in test to inject customized AssignmentManager\n   @VisibleForTesting\n-  protected AssignmentManager createAssignmentManager(MasterServices master) {\n-    return new AssignmentManager(master);\n+  protected AssignmentManager createAssignmentManager(MasterServices master,\n+    MasterRegion masterRegion) {\n+    return new AssignmentManager(master, masterRegion);\n+  }\n+\n+  /**\n+   * Load the meta region state from the meta region server ZNode.\n+   * @param zkw reference to the {@link ZKWatcher} which also contains configuration and operation\n+   * @param replicaId the ID of the replica\n+   * @return regionstate\n+   * @throws KeeperException if a ZooKeeper operation fails\n+   */\n+  private static RegionState getMetaRegionState(ZKWatcher zkw, int replicaId)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDU3MA=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NjA2NQ==", "bodyText": "For migrating the meta location from zk to the new local root table.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436486065", "createdAt": "2020-06-08T06:46:09Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -868,8 +879,71 @@ protected void initializeZKBasedSystemTrackers()\n \n   // Will be overriden in test to inject customized AssignmentManager\n   @VisibleForTesting\n-  protected AssignmentManager createAssignmentManager(MasterServices master) {\n-    return new AssignmentManager(master);\n+  protected AssignmentManager createAssignmentManager(MasterServices master,\n+    MasterRegion masterRegion) {\n+    return new AssignmentManager(master, masterRegion);\n+  }\n+\n+  /**\n+   * Load the meta region state from the meta region server ZNode.\n+   * @param zkw reference to the {@link ZKWatcher} which also contains configuration and operation\n+   * @param replicaId the ID of the replica\n+   * @return regionstate\n+   * @throws KeeperException if a ZooKeeper operation fails\n+   */\n+  private static RegionState getMetaRegionState(ZKWatcher zkw, int replicaId)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NDU3MA=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODg4MjIzOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo1MTo0OFrOGgOfmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo1MTo0OFrOGgOfmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTA4MQ==", "bodyText": "Don't understand.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436445081", "createdAt": "2020-06-08T03:51:48Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -3921,4 +3996,85 @@ public MetaRegionLocationCache getMetaRegionLocationCache() {\n   public RSGroupInfoManager getRSGroupInfoManager() {\n     return rsGroupInfoManager;\n   }\n+\n+  public RegionLocations locateMeta(byte[] row, RegionLocateType locateType) throws IOException {\n+    if (locateType == RegionLocateType.AFTER) {\n+      // as we know the exact row after us, so we can just create the new row, and use the same\n+      // algorithm to locate it.\n+      row = Arrays.copyOf(row, row.length + 1);\n+      locateType = RegionLocateType.CURRENT;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODg4NDYwOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwMzo1MzozOFrOGgOg5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNTo1NjozNVrOGhl3Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTQxMw==", "bodyText": "This stuff is inline in HMaster class? Not out in Meta Table Accessor?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436445413", "createdAt": "2020-06-08T03:53:38Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -3921,4 +3996,85 @@ public MetaRegionLocationCache getMetaRegionLocationCache() {\n   public RSGroupInfoManager getRSGroupInfoManager() {\n     return rsGroupInfoManager;\n   }\n+\n+  public RegionLocations locateMeta(byte[] row, RegionLocateType locateType) throws IOException {\n+    if (locateType == RegionLocateType.AFTER) {\n+      // as we know the exact row after us, so we can just create the new row, and use the same\n+      // algorithm to locate it.\n+      row = Arrays.copyOf(row, row.length + 1);\n+      locateType = RegionLocateType.CURRENT;\n+    }\n+    Scan scan =\n+      MetaTableAccessor.createLocateRegionScan(TableName.META_TABLE_NAME, row, locateType, 1);\n+    try (RegionScanner scanner = masterRegion.getScanner(scan)) {\n+      boolean moreRows;\n+      List<Cell> cells = new ArrayList<>();\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n+        }\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionLocations locs = MetaTableAccessor.getRegionLocations(result);\n+        if (locs == null || locs.getDefaultRegionLocation() == null) {\n+          LOG.warn(\"No location found when locating meta region with row='{}', locateType={}\",\n+            Bytes.toStringBinary(row), locateType);\n+          return null;\n+        }\n+        HRegionLocation loc = locs.getDefaultRegionLocation();\n+        RegionInfo info = loc.getRegion();\n+        if (info == null) {\n+          LOG.warn(\"HRegionInfo is null when locating meta region with row='{}', locateType={}\",\n+            Bytes.toStringBinary(row), locateType);\n+          return null;\n+        }\n+        if (info.isSplitParent()) {\n+          continue;\n+        }\n+        return locs;\n+      } while (moreRows);\n+      LOG.warn(\"No location available when locating meta region with row='{}', locateType={}\",\n+        Bytes.toStringBinary(row), locateType);\n+      return null;\n+    }\n+  }\n+\n+  public List<RegionLocations> getAllMetaRegionLocations(boolean excludeOfflinedSplitParents)\n+    throws IOException {\n+    Scan scan = new Scan().addFamily(HConstants.CATALOG_FAMILY);\n+    List<RegionLocations> list = new ArrayList<>();\n+    try (RegionScanner scanner = masterRegion.getScanner(scan)) {\n+      boolean moreRows;\n+      List<Cell> cells = new ArrayList<>();\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n+        }\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionLocations locs = MetaTableAccessor.getRegionLocations(result);\n+        if (locs == null) {\n+          LOG.warn(\"No locations in {}\", result);\n+          continue;\n+        }\n+        HRegionLocation loc = locs.getRegionLocation();\n+        if (loc == null) {\n+          LOG.warn(\"No non null location in {}\", result);\n+          continue;\n+        }\n+        RegionInfo info = loc.getRegion();\n+        if (info == null) {\n+          LOG.warn(\"No serialized RegionInfo in {}\", result);\n+          continue;\n+        }\n+        if (excludeOfflinedSplitParents && info.isSplitParent()) {\n+          continue;\n+        }\n+        list.add(locs);\n+      } while (moreRows);\n+    }\n+    return list;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4OTM1MA==", "bodyText": "The logic is similar, that's why I also use several methods from MetaTableAccessor. But here we are scanning a region, not a table, so the API is a bit different. And at client side, now we will use the async API, which is also a bit different. You can see AsyncNonMetaTableRegionLocator.onScanNext.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r436489350", "createdAt": "2020-06-08T06:54:29Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -3921,4 +3996,85 @@ public MetaRegionLocationCache getMetaRegionLocationCache() {\n   public RSGroupInfoManager getRSGroupInfoManager() {\n     return rsGroupInfoManager;\n   }\n+\n+  public RegionLocations locateMeta(byte[] row, RegionLocateType locateType) throws IOException {\n+    if (locateType == RegionLocateType.AFTER) {\n+      // as we know the exact row after us, so we can just create the new row, and use the same\n+      // algorithm to locate it.\n+      row = Arrays.copyOf(row, row.length + 1);\n+      locateType = RegionLocateType.CURRENT;\n+    }\n+    Scan scan =\n+      MetaTableAccessor.createLocateRegionScan(TableName.META_TABLE_NAME, row, locateType, 1);\n+    try (RegionScanner scanner = masterRegion.getScanner(scan)) {\n+      boolean moreRows;\n+      List<Cell> cells = new ArrayList<>();\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n+        }\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionLocations locs = MetaTableAccessor.getRegionLocations(result);\n+        if (locs == null || locs.getDefaultRegionLocation() == null) {\n+          LOG.warn(\"No location found when locating meta region with row='{}', locateType={}\",\n+            Bytes.toStringBinary(row), locateType);\n+          return null;\n+        }\n+        HRegionLocation loc = locs.getDefaultRegionLocation();\n+        RegionInfo info = loc.getRegion();\n+        if (info == null) {\n+          LOG.warn(\"HRegionInfo is null when locating meta region with row='{}', locateType={}\",\n+            Bytes.toStringBinary(row), locateType);\n+          return null;\n+        }\n+        if (info.isSplitParent()) {\n+          continue;\n+        }\n+        return locs;\n+      } while (moreRows);\n+      LOG.warn(\"No location available when locating meta region with row='{}', locateType={}\",\n+        Bytes.toStringBinary(row), locateType);\n+      return null;\n+    }\n+  }\n+\n+  public List<RegionLocations> getAllMetaRegionLocations(boolean excludeOfflinedSplitParents)\n+    throws IOException {\n+    Scan scan = new Scan().addFamily(HConstants.CATALOG_FAMILY);\n+    List<RegionLocations> list = new ArrayList<>();\n+    try (RegionScanner scanner = masterRegion.getScanner(scan)) {\n+      boolean moreRows;\n+      List<Cell> cells = new ArrayList<>();\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n+        }\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionLocations locs = MetaTableAccessor.getRegionLocations(result);\n+        if (locs == null) {\n+          LOG.warn(\"No locations in {}\", result);\n+          continue;\n+        }\n+        HRegionLocation loc = locs.getRegionLocation();\n+        if (loc == null) {\n+          LOG.warn(\"No non null location in {}\", result);\n+          continue;\n+        }\n+        RegionInfo info = loc.getRegion();\n+        if (info == null) {\n+          LOG.warn(\"No serialized RegionInfo in {}\", result);\n+          continue;\n+        }\n+        if (excludeOfflinedSplitParents && info.isSplitParent()) {\n+          continue;\n+        }\n+        list.add(locs);\n+      } while (moreRows);\n+    }\n+    return list;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTQxMw=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MzE4OA==", "bodyText": "MasterRegion deserves own accessor. MasterRegionAccessor", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437043188", "createdAt": "2020-06-08T22:49:07Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -3921,4 +3996,85 @@ public MetaRegionLocationCache getMetaRegionLocationCache() {\n   public RSGroupInfoManager getRSGroupInfoManager() {\n     return rsGroupInfoManager;\n   }\n+\n+  public RegionLocations locateMeta(byte[] row, RegionLocateType locateType) throws IOException {\n+    if (locateType == RegionLocateType.AFTER) {\n+      // as we know the exact row after us, so we can just create the new row, and use the same\n+      // algorithm to locate it.\n+      row = Arrays.copyOf(row, row.length + 1);\n+      locateType = RegionLocateType.CURRENT;\n+    }\n+    Scan scan =\n+      MetaTableAccessor.createLocateRegionScan(TableName.META_TABLE_NAME, row, locateType, 1);\n+    try (RegionScanner scanner = masterRegion.getScanner(scan)) {\n+      boolean moreRows;\n+      List<Cell> cells = new ArrayList<>();\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n+        }\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionLocations locs = MetaTableAccessor.getRegionLocations(result);\n+        if (locs == null || locs.getDefaultRegionLocation() == null) {\n+          LOG.warn(\"No location found when locating meta region with row='{}', locateType={}\",\n+            Bytes.toStringBinary(row), locateType);\n+          return null;\n+        }\n+        HRegionLocation loc = locs.getDefaultRegionLocation();\n+        RegionInfo info = loc.getRegion();\n+        if (info == null) {\n+          LOG.warn(\"HRegionInfo is null when locating meta region with row='{}', locateType={}\",\n+            Bytes.toStringBinary(row), locateType);\n+          return null;\n+        }\n+        if (info.isSplitParent()) {\n+          continue;\n+        }\n+        return locs;\n+      } while (moreRows);\n+      LOG.warn(\"No location available when locating meta region with row='{}', locateType={}\",\n+        Bytes.toStringBinary(row), locateType);\n+      return null;\n+    }\n+  }\n+\n+  public List<RegionLocations> getAllMetaRegionLocations(boolean excludeOfflinedSplitParents)\n+    throws IOException {\n+    Scan scan = new Scan().addFamily(HConstants.CATALOG_FAMILY);\n+    List<RegionLocations> list = new ArrayList<>();\n+    try (RegionScanner scanner = masterRegion.getScanner(scan)) {\n+      boolean moreRows;\n+      List<Cell> cells = new ArrayList<>();\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n+        }\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionLocations locs = MetaTableAccessor.getRegionLocations(result);\n+        if (locs == null) {\n+          LOG.warn(\"No locations in {}\", result);\n+          continue;\n+        }\n+        HRegionLocation loc = locs.getRegionLocation();\n+        if (loc == null) {\n+          LOG.warn(\"No non null location in {}\", result);\n+          continue;\n+        }\n+        RegionInfo info = loc.getRegion();\n+        if (info == null) {\n+          LOG.warn(\"No serialized RegionInfo in {}\", result);\n+          continue;\n+        }\n+        if (excludeOfflinedSplitParents && info.isSplitParent()) {\n+          continue;\n+        }\n+        list.add(locs);\n+      } while (moreRows);\n+    }\n+    return list;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTQxMw=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3Nzc3MQ==", "bodyText": "Can do this in a follow on issue? And the difference here is that, MasterRegion is not only used as root table, it is also usedas procedure store, which does not have the same access pattern.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437077771", "createdAt": "2020-06-09T00:52:05Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -3921,4 +3996,85 @@ public MetaRegionLocationCache getMetaRegionLocationCache() {\n   public RSGroupInfoManager getRSGroupInfoManager() {\n     return rsGroupInfoManager;\n   }\n+\n+  public RegionLocations locateMeta(byte[] row, RegionLocateType locateType) throws IOException {\n+    if (locateType == RegionLocateType.AFTER) {\n+      // as we know the exact row after us, so we can just create the new row, and use the same\n+      // algorithm to locate it.\n+      row = Arrays.copyOf(row, row.length + 1);\n+      locateType = RegionLocateType.CURRENT;\n+    }\n+    Scan scan =\n+      MetaTableAccessor.createLocateRegionScan(TableName.META_TABLE_NAME, row, locateType, 1);\n+    try (RegionScanner scanner = masterRegion.getScanner(scan)) {\n+      boolean moreRows;\n+      List<Cell> cells = new ArrayList<>();\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n+        }\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionLocations locs = MetaTableAccessor.getRegionLocations(result);\n+        if (locs == null || locs.getDefaultRegionLocation() == null) {\n+          LOG.warn(\"No location found when locating meta region with row='{}', locateType={}\",\n+            Bytes.toStringBinary(row), locateType);\n+          return null;\n+        }\n+        HRegionLocation loc = locs.getDefaultRegionLocation();\n+        RegionInfo info = loc.getRegion();\n+        if (info == null) {\n+          LOG.warn(\"HRegionInfo is null when locating meta region with row='{}', locateType={}\",\n+            Bytes.toStringBinary(row), locateType);\n+          return null;\n+        }\n+        if (info.isSplitParent()) {\n+          continue;\n+        }\n+        return locs;\n+      } while (moreRows);\n+      LOG.warn(\"No location available when locating meta region with row='{}', locateType={}\",\n+        Bytes.toStringBinary(row), locateType);\n+      return null;\n+    }\n+  }\n+\n+  public List<RegionLocations> getAllMetaRegionLocations(boolean excludeOfflinedSplitParents)\n+    throws IOException {\n+    Scan scan = new Scan().addFamily(HConstants.CATALOG_FAMILY);\n+    List<RegionLocations> list = new ArrayList<>();\n+    try (RegionScanner scanner = masterRegion.getScanner(scan)) {\n+      boolean moreRows;\n+      List<Cell> cells = new ArrayList<>();\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n+        }\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionLocations locs = MetaTableAccessor.getRegionLocations(result);\n+        if (locs == null) {\n+          LOG.warn(\"No locations in {}\", result);\n+          continue;\n+        }\n+        HRegionLocation loc = locs.getRegionLocation();\n+        if (loc == null) {\n+          LOG.warn(\"No non null location in {}\", result);\n+          continue;\n+        }\n+        RegionInfo info = loc.getRegion();\n+        if (info == null) {\n+          LOG.warn(\"No serialized RegionInfo in {}\", result);\n+          continue;\n+        }\n+        if (excludeOfflinedSplitParents && info.isSplitParent()) {\n+          continue;\n+        }\n+        list.add(locs);\n+      } while (moreRows);\n+    }\n+    return list;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTQxMw=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3NjQ4Nw==", "bodyText": "Can be follow-on.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437876487", "createdAt": "2020-06-10T05:56:35Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -3921,4 +3996,85 @@ public MetaRegionLocationCache getMetaRegionLocationCache() {\n   public RSGroupInfoManager getRSGroupInfoManager() {\n     return rsGroupInfoManager;\n   }\n+\n+  public RegionLocations locateMeta(byte[] row, RegionLocateType locateType) throws IOException {\n+    if (locateType == RegionLocateType.AFTER) {\n+      // as we know the exact row after us, so we can just create the new row, and use the same\n+      // algorithm to locate it.\n+      row = Arrays.copyOf(row, row.length + 1);\n+      locateType = RegionLocateType.CURRENT;\n+    }\n+    Scan scan =\n+      MetaTableAccessor.createLocateRegionScan(TableName.META_TABLE_NAME, row, locateType, 1);\n+    try (RegionScanner scanner = masterRegion.getScanner(scan)) {\n+      boolean moreRows;\n+      List<Cell> cells = new ArrayList<>();\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n+        }\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionLocations locs = MetaTableAccessor.getRegionLocations(result);\n+        if (locs == null || locs.getDefaultRegionLocation() == null) {\n+          LOG.warn(\"No location found when locating meta region with row='{}', locateType={}\",\n+            Bytes.toStringBinary(row), locateType);\n+          return null;\n+        }\n+        HRegionLocation loc = locs.getDefaultRegionLocation();\n+        RegionInfo info = loc.getRegion();\n+        if (info == null) {\n+          LOG.warn(\"HRegionInfo is null when locating meta region with row='{}', locateType={}\",\n+            Bytes.toStringBinary(row), locateType);\n+          return null;\n+        }\n+        if (info.isSplitParent()) {\n+          continue;\n+        }\n+        return locs;\n+      } while (moreRows);\n+      LOG.warn(\"No location available when locating meta region with row='{}', locateType={}\",\n+        Bytes.toStringBinary(row), locateType);\n+      return null;\n+    }\n+  }\n+\n+  public List<RegionLocations> getAllMetaRegionLocations(boolean excludeOfflinedSplitParents)\n+    throws IOException {\n+    Scan scan = new Scan().addFamily(HConstants.CATALOG_FAMILY);\n+    List<RegionLocations> list = new ArrayList<>();\n+    try (RegionScanner scanner = masterRegion.getScanner(scan)) {\n+      boolean moreRows;\n+      List<Cell> cells = new ArrayList<>();\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n+        }\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionLocations locs = MetaTableAccessor.getRegionLocations(result);\n+        if (locs == null) {\n+          LOG.warn(\"No locations in {}\", result);\n+          continue;\n+        }\n+        HRegionLocation loc = locs.getRegionLocation();\n+        if (loc == null) {\n+          LOG.warn(\"No non null location in {}\", result);\n+          continue;\n+        }\n+        RegionInfo info = loc.getRegion();\n+        if (info == null) {\n+          LOG.warn(\"No serialized RegionInfo in {}\", result);\n+          continue;\n+        }\n+        if (excludeOfflinedSplitParents && info.isSplitParent()) {\n+          continue;\n+        }\n+        list.add(locs);\n+      } while (moreRows);\n+    }\n+    return list;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0NTQxMw=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 268}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjUxODE5OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMTo1MToyM1rOGgxsCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMTo1MToyM1rOGgxsCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyMTcwNQ==", "bodyText": "master local region", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437021705", "createdAt": "2020-06-08T21:51:23Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegionServer.java", "diffHunk": "@@ -2319,17 +2317,13 @@ private boolean skipReportingTransition(final RegionStateTransitionContext conte\n     if (code == TransitionCode.OPENED) {\n       Preconditions.checkArgument(hris != null && hris.length == 1);\n       if (hris[0].isMetaRegion()) {\n-        try {\n-          MetaTableLocator.setMetaLocation(getZooKeeper(), serverName,\n-              hris[0].getReplicaId(), RegionState.State.OPEN);\n-        } catch (KeeperException e) {\n-          LOG.info(\"Failed to update meta location\", e);\n-          return false;\n-        }\n+        LOG.warn(\n+          \"meta table location is stored in master local store, so we can not skip reporting\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjU0NTg5OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/region/MasterRegionFactory.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMjowMjowMlrOGgx87A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMjoyMDo0OVrOGg2hcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNjAyOA==", "bodyText": "TABLENAME is 'master:store'. Should it be 'master:region'? Configs are hbase.master.store.region.* which is odd given we usually talk of region having a store, not other way around.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437026028", "createdAt": "2020-06-08T22:02:02Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/region/MasterRegionFactory.java", "diffHunk": "@@ -80,6 +83,10 @@\n   public static final byte[] PROC_FAMILY = Bytes.toBytes(\"proc\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNjY0Ng==", "bodyText": "Too late to changes this?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437026646", "createdAt": "2020-06-08T22:03:42Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/region/MasterRegionFactory.java", "diffHunk": "@@ -80,6 +83,10 @@\n   public static final byte[] PROC_FAMILY = Bytes.toBytes(\"proc\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNjAyOA=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3ODMxOA==", "bodyText": "I think the 'store' here does not mean HRegion, it is something like the 'ProcedureStore'.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437078318", "createdAt": "2020-06-09T00:54:18Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/region/MasterRegionFactory.java", "diffHunk": "@@ -80,6 +83,10 @@\n   public static final byte[] PROC_FAMILY = Bytes.toBytes(\"proc\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNjAyOA=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwMDkxNQ==", "bodyText": "Maybe later we have other implementations then we will change the configs to hbase.master.store.<alternate implementation>,*", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437100915", "createdAt": "2020-06-09T02:20:49Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/region/MasterRegionFactory.java", "diffHunk": "@@ -80,6 +83,10 @@\n   public static final byte[] PROC_FAMILY = Bytes.toBytes(\"proc\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNjAyOA=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjU1MjczOnYy", "diffSide": "LEFT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/procedure/CreateTableProcedure.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMjowNDo1NlrOGgyBSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNTo1NTozNlrOGhl1sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNzE0Ng==", "bodyText": "We don't need to make sure meta is available first anymore? Or is this because we might be doing create meta table with this procedure going forward?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437027146", "createdAt": "2020-06-08T22:04:56Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/procedure/CreateTableProcedure.java", "diffHunk": "@@ -365,8 +365,6 @@ protected static void moveTempDirectoryToHBaseRoot(\n       final List<RegionInfo> regions) throws IOException {\n     assert (regions != null && regions.size() > 0) : \"expected at least 1 region, got \" + regions;\n \n-    ProcedureSyncWait.waitMetaRegions(env);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MTE5OQ==", "bodyText": "If we have multiple meta regions, I do not think it is a good idea to wait for them all being online? And the implementation will be much cmore omplicated, as in the past we just need a simple event and setMetaAssigned and setMetaUnassigned. But if we have multiple meta regions, we need to know the exact count of meta regions and do counting here?And we also need to deal with split/merge which could change the count.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437081199", "createdAt": "2020-06-09T01:05:41Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/procedure/CreateTableProcedure.java", "diffHunk": "@@ -365,8 +365,6 @@ protected static void moveTempDirectoryToHBaseRoot(\n       final List<RegionInfo> regions) throws IOException {\n     assert (regions != null && regions.size() > 0) : \"expected at least 1 region, got \" + regions;\n \n-    ProcedureSyncWait.waitMetaRegions(env);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNzE0Ng=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3NjE0NQ==", "bodyText": "Ok. Work to do here.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437876145", "createdAt": "2020-06-10T05:55:36Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/procedure/CreateTableProcedure.java", "diffHunk": "@@ -365,8 +365,6 @@ protected static void moveTempDirectoryToHBaseRoot(\n       final List<RegionInfo> regions) throws IOException {\n     assert (regions != null && regions.size() > 0) : \"expected at least 1 region, got \" + regions;\n \n-    ProcedureSyncWait.waitMetaRegions(env);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNzE0Ng=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjYzMjEwOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/assignment/AssignmentManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMjozNzoyN1rOGgyw2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMDo1Njo1NlrOGg1Lug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzOTMyMw==", "bodyText": "Does MasterRegistry put meta location in zk?  If not, we'd mirror to zk here anyways even if we are using MasterRegistry?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437039323", "createdAt": "2020-06-08T22:37:27Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/assignment/AssignmentManager.java", "diffHunk": "@@ -224,23 +229,52 @@ public void start() throws IOException, KeeperException {\n     // Start the Assignment Thread\n     startAssignmentThread();\n \n-    // load meta region state\n-    ZKWatcher zkw = master.getZooKeeper();\n-    // it could be null in some tests\n-    if (zkw != null) {\n-      RegionState regionState = MetaTableLocator.getMetaRegionState(zkw);\n-      RegionStateNode regionNode =\n-        regionStates.getOrCreateRegionStateNode(RegionInfoBuilder.FIRST_META_REGIONINFO);\n-      regionNode.lock();\n-      try {\n-        regionNode.setRegionLocation(regionState.getServerName());\n-        regionNode.setState(regionState.getState());\n-        if (regionNode.getProcedure() != null) {\n-          regionNode.getProcedure().stateLoaded(this, regionNode);\n+    // load meta region states.\n+    // notice that, here we will load all replicas, and in MasterMetaBootstrap we may assign new\n+    // replicas, or remove excess replicas.\n+    try (RegionScanner scanner =\n+      masterRegion.getScanner(new Scan().addFamily(HConstants.CATALOG_FAMILY))) {\n+      List<Cell> cells = new ArrayList<>();\n+      boolean moreRows;\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n         }\n-        setMetaAssigned(regionState.getRegion(), regionState.getState() == State.OPEN);\n-      } finally {\n-        regionNode.unlock();\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionStateStore\n+          .visitMetaEntry((r, regionInfo, state, regionLocation, lastHost, openSeqNum) -> {\n+            RegionStateNode regionNode = regionStates.getOrCreateRegionStateNode(regionInfo);\n+            regionNode.lock();\n+            try {\n+              regionNode.setState(state);\n+              regionNode.setLastHost(lastHost);\n+              regionNode.setRegionLocation(regionLocation);\n+              regionNode.setOpenSeqNum(openSeqNum);\n+              if (regionNode.getProcedure() != null) {\n+                regionNode.getProcedure().stateLoaded(this, regionNode);\n+              }\n+              if (RegionReplicaUtil.isDefaultReplica(regionInfo)) {\n+                setMetaAssigned(regionInfo, state == State.OPEN);\n+              }\n+            } finally {\n+              regionNode.unlock();\n+            }\n+            if (regionInfo.isFirst()) {\n+              // for compatibility, mirror the meta region state to zookeeper\n+              try {\n+                regionStateStore.mirrorMetaLocation(regionInfo, regionLocation, state);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3ODk3MA==", "bodyText": "As said earlier, ConnectionRegistry is only a read only interface used at client side, where MasterRegsitry is an implementation of ConnectionRegistry, so it will not write anything to zk. The mirror of the location here is to keep compatible with old clients, where they expect meta location is still on zk.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437078970", "createdAt": "2020-06-09T00:56:56Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/assignment/AssignmentManager.java", "diffHunk": "@@ -224,23 +229,52 @@ public void start() throws IOException, KeeperException {\n     // Start the Assignment Thread\n     startAssignmentThread();\n \n-    // load meta region state\n-    ZKWatcher zkw = master.getZooKeeper();\n-    // it could be null in some tests\n-    if (zkw != null) {\n-      RegionState regionState = MetaTableLocator.getMetaRegionState(zkw);\n-      RegionStateNode regionNode =\n-        regionStates.getOrCreateRegionStateNode(RegionInfoBuilder.FIRST_META_REGIONINFO);\n-      regionNode.lock();\n-      try {\n-        regionNode.setRegionLocation(regionState.getServerName());\n-        regionNode.setState(regionState.getState());\n-        if (regionNode.getProcedure() != null) {\n-          regionNode.getProcedure().stateLoaded(this, regionNode);\n+    // load meta region states.\n+    // notice that, here we will load all replicas, and in MasterMetaBootstrap we may assign new\n+    // replicas, or remove excess replicas.\n+    try (RegionScanner scanner =\n+      masterRegion.getScanner(new Scan().addFamily(HConstants.CATALOG_FAMILY))) {\n+      List<Cell> cells = new ArrayList<>();\n+      boolean moreRows;\n+      do {\n+        moreRows = scanner.next(cells);\n+        if (cells.isEmpty()) {\n+          continue;\n         }\n-        setMetaAssigned(regionState.getRegion(), regionState.getState() == State.OPEN);\n-      } finally {\n-        regionNode.unlock();\n+        Result result = Result.create(cells);\n+        cells.clear();\n+        RegionStateStore\n+          .visitMetaEntry((r, regionInfo, state, regionLocation, lastHost, openSeqNum) -> {\n+            RegionStateNode regionNode = regionStates.getOrCreateRegionStateNode(regionInfo);\n+            regionNode.lock();\n+            try {\n+              regionNode.setState(state);\n+              regionNode.setLastHost(lastHost);\n+              regionNode.setRegionLocation(regionLocation);\n+              regionNode.setOpenSeqNum(openSeqNum);\n+              if (regionNode.getProcedure() != null) {\n+                regionNode.getProcedure().stateLoaded(this, regionNode);\n+              }\n+              if (RegionReplicaUtil.isDefaultReplica(regionInfo)) {\n+                setMetaAssigned(regionInfo, state == State.OPEN);\n+              }\n+            } finally {\n+              regionNode.unlock();\n+            }\n+            if (regionInfo.isFirst()) {\n+              // for compatibility, mirror the meta region state to zookeeper\n+              try {\n+                regionStateStore.mirrorMetaLocation(regionInfo, regionLocation, state);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAzOTMyMw=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjYzOTg3OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterServices.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQyMjo0MDo1N1rOGgy1lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNTo1Mzo0NFrOGhlzTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MDUzMg==", "bodyText": "We'd not get this info from the Connection via Registry? Or is it that this is pure internal to Master? Reads the Master local Region content? If so, why the param? What internal needs this?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437040532", "createdAt": "2020-06-08T22:40:57Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterServices.java", "diffHunk": "@@ -552,4 +553,12 @@ default SplitWALManager getSplitWALManager(){\n    * @return The state of the load balancer, or false if the load balancer isn't defined.\n    */\n   boolean isBalancerOn();\n+\n+  /**\n+   * Get locations for all meta regions.\n+   * @param excludeOfflinedSplitParents don't return split parents\n+   * @return The locations of all the meta regions\n+   */\n+  List<RegionLocations> getAllMetaRegionLocations(boolean excludeOfflinedSplitParents)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4MDI2MA==", "bodyText": "The ConnectionRegistry need to call this method to get the location. I still need to say, ConnectionRegistry is an interface which is only used at client side, it is not something at the bottom to support the cluster. Now the location of meta is stored in a master local region, you have to provide an rpc method for ConnectionRegistry to get the location...\nOn the parameter, maybe we do not need it in the rpc interface, for now, as in the RegionLocator interface there is no way to pass this parameter. But when doing snapshot, we do need to get the split parent. And maybe for HBCK we also need to get these things? Not sure, if you do not like it we can remove it. Can add it back later when necessary.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437080260", "createdAt": "2020-06-09T01:01:54Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterServices.java", "diffHunk": "@@ -552,4 +553,12 @@ default SplitWALManager getSplitWALManager(){\n    * @return The state of the load balancer, or false if the load balancer isn't defined.\n    */\n   boolean isBalancerOn();\n+\n+  /**\n+   * Get locations for all meta regions.\n+   * @param excludeOfflinedSplitParents don't return split parents\n+   * @return The locations of all the meta regions\n+   */\n+  List<RegionLocations> getAllMetaRegionLocations(boolean excludeOfflinedSplitParents)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MDUzMg=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg3NTUzMw==", "bodyText": "Ok. Helps. I dislike this parameter. It has the smell of 'more' params being needed as we progress... but perhaps not... We have method like this already over in Meta Accessor.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r437875533", "createdAt": "2020-06-10T05:53:44Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterServices.java", "diffHunk": "@@ -552,4 +553,12 @@ default SplitWALManager getSplitWALManager(){\n    * @return The state of the load balancer, or false if the load balancer isn't defined.\n    */\n   boolean isBalancerOn();\n+\n+  /**\n+   * Get locations for all meta regions.\n+   * @param excludeOfflinedSplitParents don't return split parents\n+   * @return The locations of all the meta regions\n+   */\n+  List<RegionLocations> getAllMetaRegionLocations(boolean excludeOfflinedSplitParents)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA0MDUzMg=="}, "originalCommit": {"oid": "5ca2a98bc940cc1ccf8256c4fddce973fddea61b"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTcxNDM2OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/CatalogFamilyFormat.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMjo0NzoxOVrOGpwpSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMjowODo0NFrOGpydqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0MTgwMA==", "bodyText": "nit... should be LocateRegionType to match the method names in here.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446441800", "createdAt": "2020-06-26T22:47:19Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/CatalogFamilyFormat.java", "diffHunk": "@@ -363,4 +370,27 @@ public static Delete removeRegionReplica(byte[] metaRow, int replicaIndexToDelet\n     }\n     return deleteReplicaLocations;\n   }\n+\n+  private static byte[] buildLocateRegionStartRow(TableName tableName, byte[] row,\n+    RegionLocateType locateType) {\n+    if (locateType.equals(RegionLocateType.BEFORE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3MTU5NA==", "bodyText": "You mean the 'RegionLocateType'? Or just change the method name?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446471594", "createdAt": "2020-06-27T02:08:44Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/CatalogFamilyFormat.java", "diffHunk": "@@ -363,4 +370,27 @@ public static Delete removeRegionReplica(byte[] metaRow, int replicaIndexToDelet\n     }\n     return deleteReplicaLocations;\n   }\n+\n+  private static byte[] buildLocateRegionStartRow(TableName tableName, byte[] row,\n+    RegionLocateType locateType) {\n+    if (locateType.equals(RegionLocateType.BEFORE)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0MTgwMA=="}, "originalCommit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTcyNTc2OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ClientMetaTableAccessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMjo1NDozNlrOGpwwFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMjowNzozN1rOGpydXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0MzU0Mw==", "bodyText": "Trying to understand why we need to support this flag excludeOfflinedSplitParents\nSnapshots need it? Are we trying to support snapshotting hbase:meta table?\nI was going to suggest we not do this but thinking on it, it is probably a useful utility to have.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446443543", "createdAt": "2020-06-26T22:54:36Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ClientMetaTableAccessor.java", "diffHunk": "@@ -164,26 +164,27 @@ private ClientMetaTableAccessor() {\n \n   /**\n    * Used to get all region locations for the specific table.\n-   * @param metaTable\n    * @param tableName table we're looking for, can be null for getting all regions\n    * @return the list of region locations. The return value will be wrapped by a\n    *         {@link CompletableFuture}.\n    */\n   public static CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(\n-    AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName) {\n+    AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName,\n+    boolean excludeOfflinedSplitParents) {\n     CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-    addListener(getTableRegionsAndLocations(metaTable, tableName, true), (locations, err) -> {\n-      if (err != null) {\n-        future.completeExceptionally(err);\n-      } else if (locations == null || locations.isEmpty()) {\n-        future.complete(Collections.emptyList());\n-      } else {\n-        List<HRegionLocation> regionLocations =\n-          locations.stream().map(loc -> new HRegionLocation(loc.getFirst(), loc.getSecond()))\n-            .collect(Collectors.toList());\n-        future.complete(regionLocations);\n-      }\n-    });\n+    addListener(getTableRegionsAndLocations(metaTable, tableName, excludeOfflinedSplitParents),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3MTUxOA==", "bodyText": "At least in the Snapshot related code, we have special support for meta table. So at master side, we need to expose this parameter. On whether to expose this parameter at RPC level, I'm not sure yet. In the current design, the cache server will use the rpc method to fetch all the records in root table, maybe it is good to set this parameter to true so they will get all the records? Not sure.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446471518", "createdAt": "2020-06-27T02:07:37Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ClientMetaTableAccessor.java", "diffHunk": "@@ -164,26 +164,27 @@ private ClientMetaTableAccessor() {\n \n   /**\n    * Used to get all region locations for the specific table.\n-   * @param metaTable\n    * @param tableName table we're looking for, can be null for getting all regions\n    * @return the list of region locations. The return value will be wrapped by a\n    *         {@link CompletableFuture}.\n    */\n   public static CompletableFuture<List<HRegionLocation>> getTableHRegionLocations(\n-    AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName) {\n+    AsyncTable<AdvancedScanResultConsumer> metaTable, TableName tableName,\n+    boolean excludeOfflinedSplitParents) {\n     CompletableFuture<List<HRegionLocation>> future = new CompletableFuture<>();\n-    addListener(getTableRegionsAndLocations(metaTable, tableName, true), (locations, err) -> {\n-      if (err != null) {\n-        future.completeExceptionally(err);\n-      } else if (locations == null || locations.isEmpty()) {\n-        future.complete(Collections.emptyList());\n-      } else {\n-        List<HRegionLocation> regionLocations =\n-          locations.stream().map(loc -> new HRegionLocation(loc.getFirst(), loc.getSecond()))\n-            .collect(Collectors.toList());\n-        future.complete(regionLocations);\n-      }\n-    });\n+    addListener(getTableRegionsAndLocations(metaTable, tableName, excludeOfflinedSplitParents),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0MzU0Mw=="}, "originalCommit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTczMzI0OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMjo1OTozMFrOGpw0fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMjowNjozOFrOGpyc8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NDY3MQ==", "bodyText": "Why TableRegion rather than Region? The 'Table' is redundant and makes this class name a mouthful?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446444671", "createdAt": "2020-06-26T22:59:30Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.HConstants.EMPTY_END_ROW;\n+import static org.apache.hadoop.hbase.client.AsyncRegionLocatorHelper.isGood;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.hadoop.hbase.HBaseIOException;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * The base class for locating region of a table.\n+ */\n+@InterfaceAudience.Private\n+abstract class AbstractAsyncTableRegionLocator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NjI3Mw==", "bodyText": "I see you are doing this....\ndelete mode 100644 hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaRegionLocator.java\ncreate mode 100644 hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncNonMetaTableRegionLocator.java\n.... you want to create new classes rather than just replace the old and the TableRegion is how you distingush the new set?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446446273", "createdAt": "2020-06-26T23:07:04Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.HConstants.EMPTY_END_ROW;\n+import static org.apache.hadoop.hbase.client.AsyncRegionLocatorHelper.isGood;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.hadoop.hbase.HBaseIOException;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * The base class for locating region of a table.\n+ */\n+@InterfaceAudience.Private\n+abstract class AbstractAsyncTableRegionLocator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NDY3MQ=="}, "originalCommit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3MTQxMA==", "bodyText": "The AbstractAsyncTableRegionLocator has a cache in it, for caching the location of regions of a table. That's why I added a 'Table' in the class name.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446471410", "createdAt": "2020-06-27T02:06:38Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AbstractAsyncTableRegionLocator.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import static org.apache.hadoop.hbase.HConstants.EMPTY_END_ROW;\n+import static org.apache.hadoop.hbase.client.AsyncRegionLocatorHelper.isGood;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.createClosestRowAfter;\n+\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.commons.lang3.ObjectUtils;\n+import org.apache.hadoop.hbase.HBaseIOException;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * The base class for locating region of a table.\n+ */\n+@InterfaceAudience.Private\n+abstract class AbstractAsyncTableRegionLocator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0NDY3MQ=="}, "originalCommit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTc2MDM5OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRegionLocator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMzoxODoyM1rOGpxEfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwMjowOTowM1rOGpyd2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0ODc2Ng==", "bodyText": "Can't return an Interface rather than Abstract class?", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446448766", "createdAt": "2020-06-26T23:18:23Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRegionLocator.java", "diffHunk": "@@ -85,26 +118,41 @@ private boolean isMeta(TableName tableName) {\n     return TableName.isMetaTableName(tableName);\n   }\n \n+  private AbstractAsyncTableRegionLocator getOrCreateTableRegionLocator(TableName tableName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ3MTY0Mg==", "bodyText": "This is internal so just use the implementation class directly. Can have an interface later if we think it is useful.", "url": "https://github.com/apache/hbase/pull/1774#discussion_r446471642", "createdAt": "2020-06-27T02:09:03Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRegionLocator.java", "diffHunk": "@@ -85,26 +118,41 @@ private boolean isMeta(TableName tableName) {\n     return TableName.isMetaTableName(tableName);\n   }\n \n+  private AbstractAsyncTableRegionLocator getOrCreateTableRegionLocator(TableName tableName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ0ODc2Ng=="}, "originalCommit": {"oid": "ce6490ed9612cdc2e424d4a4c0827fc806d40b5e"}, "originalPosition": 93}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3041, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}