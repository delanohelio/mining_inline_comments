{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI0NzA2ODMz", "number": 2685, "title": "HBASE-25307 ThreadLocal pooling leads to NullPointerException", "bodyText": "PoolMap does not discard any elements anymore. If an element is put,\nit always stores it. The reason: it stores expensive resources (rpc\nconnections) which would lead to resource leak if we simple discard it.\nRpcClients can reference netty ByteBufs which are reference counted.\nResource cleanup is done by AbstractRpcClient.cleanupIdleConnections().\nRemoved concurrency from PoolMap. It is called only from\nAbstractRpcClient in synchronized blocks, so it doesn't have to be\nthread-safe.\nMax size is a hint for RoundRobinPool. Until maxSize is not reached,\nit will force users to create new resources. So it works the same as\nbefore, but it does not prevent putting more elements then maxSize.\nThreadLocalPool doesn't uses ThreadLocal class anymore. It stores\nresources on thread basis, but it doesn't remove values when a thread\nexits. Again, proper cleanup is done by cleanupIdleConnections().", "createdAt": "2020-11-20T13:30:39Z", "url": "https://github.com/apache/hbase/pull/2685", "merged": true, "mergeCommit": {"oid": "094aadcddaf96d078c768e2f9d922418c6a07ddc"}, "closed": true, "closedAt": "2020-11-25T10:10:28Z", "author": {"login": "meszibalu"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdeXP40AH2gAyNTI0NzA2ODMzOmIyZjcwZmYxZTk1MzQ3NjI1NzIwYjAzNDgwOThkNjFjNjFjOWE3NDI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdfuo0FAH2gAyNTI0NzA2ODMzOjczZjY0YzhjMmYxOWIzNjNmNzJjZTAyODE4ZmRjYTQ5Yjk2MmZlZjU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b2f70ff1e95347625720b0348098d61c61c9a742", "author": {"user": {"login": "meszibalu", "name": "Balazs Meszaros"}}, "url": "https://github.com/apache/hbase/commit/b2f70ff1e95347625720b0348098d61c61c9a742", "committedDate": "2020-11-20T13:20:08Z", "message": "HBASE-25307 ThreadLocal pooling leads to NullPointerException\n\n* PoolMap does not discard any elements anymore. If an element is put,\nit always stores it. The reason: it stores expensive resources (rpc\nconnections) which would lead to resource leak if we simple discard it.\nRpcClients can reference netty ByteBufs which are reference counted.\nResource cleanup is done by AbstractRpcClient.cleanupIdleConnections().\n* Removed concurrency from PoolMap. It is called only from\nAbstractRpcClient in synchronized blocks, so it doesn't have to be\nthread-safe.\n* Max size is a hint for RoundRobinPool. Until maxSize is not reached,\nit will force users to create new resources. So it works the same as\nbefore, but it does not prevent putting more elements then maxSize.\n* ThreadLocalPool doesn't uses ThreadLocal class anymore. It stores\nresources on thread basis, but it doesn't remove values when a thread\nexits. Again, proper cleanup is done by cleanupIdleConnections()."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NTM4ODg2", "url": "https://github.com/apache/hbase/pull/2685#pullrequestreview-535538886", "createdAt": "2020-11-20T15:41:43Z", "commit": {"oid": "b2f70ff1e95347625720b0348098d61c61c9a742"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNTo0MTo0M1rOH3U8Gw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNTo0ODo1N1rOH3VQJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc3Njc5NQ==", "bodyText": "I know it was already returning null before this PR, but for compliance with Map interface definition, we should rather return pools.remove(key)", "url": "https://github.com/apache/hbase/pull/2685#discussion_r527776795", "createdAt": "2020-11-20T15:41:43Z", "author": {"login": "wchevreuil"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/util/PoolMap.java", "diffHunk": "@@ -85,18 +83,17 @@ public V put(K key, V value) {\n   @SuppressWarnings(\"unchecked\")\n   @Override\n   public V remove(Object key) {\n-    Pool<V> pool = pools.remove(key);\n-    if (pool != null) {\n-      removeValue((K) key, pool.get());\n-    }\n+    pools.remove(key);\n     return null;\n   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2f70ff1e95347625720b0348098d61c61c9a742"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc3OTM2MQ==", "bodyText": "nit: exits, not exists", "url": "https://github.com/apache/hbase/pull/2685#discussion_r527779361", "createdAt": "2020-11-20T15:45:10Z", "author": {"login": "wchevreuil"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/util/PoolMap.java", "diffHunk": "@@ -275,43 +272,70 @@ public static PoolType fuzzyMatch(String name) {\n    *\n    */\n   @SuppressWarnings(\"serial\")\n-  static class RoundRobinPool<R> extends CopyOnWriteArrayList<R> implements Pool<R> {\n-    private int maxSize;\n-    private int nextResource = 0;\n+  static class RoundRobinPool<R> implements Pool<R> {\n+    private final List<R> resources;\n+    private final int maxSize;\n+\n+    private int nextIndex;\n \n     public RoundRobinPool(int maxSize) {\n+      if (maxSize <= 0) {\n+        throw new IllegalArgumentException(\"maxSize must be positive\");\n+      }\n+\n+      resources = new ArrayList<>(maxSize);\n       this.maxSize = maxSize;\n     }\n \n     @Override\n-    public R put(R resource) {\n-      if (super.size() < maxSize) {\n-        add(resource);\n+    public R get() {\n+      int size = resources.size();\n+\n+      /* letting pool to grow */\n+      if (size < maxSize) {\n+        return null;\n       }\n+\n+      R resource = resources.get(nextIndex);\n+\n+      /* at this point size cannot be 0 */\n+      nextIndex = (nextIndex + 1) % size;\n+\n+      return resource;\n+    }\n+\n+    @Override\n+    public R put(R resource) {\n+      resources.add(resource);\n       return null;\n     }\n \n     @Override\n-    public R get() {\n-      if (super.size() < maxSize) {\n-        return null;\n-      }\n-      nextResource %= super.size();\n-      R resource = get(nextResource++);\n-      return resource;\n+    public boolean remove(R resource) {\n+      return resources.remove(resource);\n+    }\n+\n+    @Override\n+    public void clear() {\n+      resources.clear();\n     }\n \n     @Override\n     public Collection<R> values() {\n-      return this;\n+      return resources;\n     }\n \n+    @Override\n+    public int size() {\n+      return resources.size();\n+    }\n   }\n \n   /**\n    * The <code>ThreadLocalPool</code> represents a {@link PoolMap.Pool} that\n-   * builds on the {@link ThreadLocal} class. It essentially binds the resource\n-   * to the thread from which it is accessed.\n+   * works similarly to {@link ThreadLocal} class. It essentially binds the resource\n+   * to the thread from which it is accessed. It doesn't remove resources when a thread exists,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2f70ff1e95347625720b0348098d61c61c9a742"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzc4MTkyNg==", "bodyText": "Should we rename this class entirely? ThreadLocal in the name may mislead developers into thinking this fully behaves like a ThreadLocal.", "url": "https://github.com/apache/hbase/pull/2685#discussion_r527781926", "createdAt": "2020-11-20T15:48:57Z", "author": {"login": "wchevreuil"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/util/PoolMap.java", "diffHunk": "@@ -321,62 +345,44 @@ public R get() {\n    * @param <R>\n    *          the type of the resource\n    */\n-  static class ThreadLocalPool<R> extends ThreadLocal<R> implements Pool<R> {\n-    private static final Map<ThreadLocalPool<?>, AtomicInteger> poolSizes = new HashMap<>();\n+  static class ThreadLocalPool<R> implements Pool<R> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2f70ff1e95347625720b0348098d61c61c9a742"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NDUxNDA5", "url": "https://github.com/apache/hbase/pull/2685#pullrequestreview-535451409", "createdAt": "2020-11-20T14:01:35Z", "commit": {"oid": "b2f70ff1e95347625720b0348098d61c61c9a742"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNDowMTozNVrOH3Q1Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQxNjo0OTo1NlrOH3XuPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTQ0Nw==", "bodyText": "include in the message that we're ignoring the passed config and using 1.", "url": "https://github.com/apache/hbase/pull/2685#discussion_r527709447", "createdAt": "2020-11-20T14:01:35Z", "author": {"login": "busbey"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/ipc/AbstractRpcClient.java", "diffHunk": "@@ -294,7 +294,14 @@ private static CompressionCodec getCompressor(final Configuration conf) {\n    * @return the maximum pool size\n    */\n   private static int getPoolSize(Configuration config) {\n-    return config.getInt(HConstants.HBASE_CLIENT_IPC_POOL_SIZE, 1);\n+    int poolSize = config.getInt(HConstants.HBASE_CLIENT_IPC_POOL_SIZE, 1);\n+\n+    if (poolSize <= 0) {\n+      LOG.warn(\"{} must be positive.\", HConstants.HBASE_CLIENT_IPC_POOL_SIZE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2f70ff1e95347625720b0348098d61c61c9a742"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzczMzUxOA==", "bodyText": "PoolMap here, yeah?", "url": "https://github.com/apache/hbase/pull/2685#discussion_r527733518", "createdAt": "2020-11-20T14:36:21Z", "author": {"login": "busbey"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/util/PoolMap.java", "diffHunk": "@@ -45,6 +38,11 @@\n  * key. A size of {@link Integer#MAX_VALUE} is interpreted as an unbounded pool.\n  * </p>\n  *\n+ * <p>\n+ * Pool is not thread-safe. It must be synchronized when used by multiple threads. Pool also does", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2f70ff1e95347625720b0348098d61c61c9a742"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgxNjY0OQ==", "bodyText": "should we be returning null? I don't see any place we actually use the returned value.", "url": "https://github.com/apache/hbase/pull/2685#discussion_r527816649", "createdAt": "2020-11-20T16:41:43Z", "author": {"login": "busbey"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/util/PoolMap.java", "diffHunk": "@@ -275,43 +272,70 @@ public static PoolType fuzzyMatch(String name) {\n    *\n    */\n   @SuppressWarnings(\"serial\")\n-  static class RoundRobinPool<R> extends CopyOnWriteArrayList<R> implements Pool<R> {\n-    private int maxSize;\n-    private int nextResource = 0;\n+  static class RoundRobinPool<R> implements Pool<R> {\n+    private final List<R> resources;\n+    private final int maxSize;\n+\n+    private int nextIndex;\n \n     public RoundRobinPool(int maxSize) {\n+      if (maxSize <= 0) {\n+        throw new IllegalArgumentException(\"maxSize must be positive\");\n+      }\n+\n+      resources = new ArrayList<>(maxSize);\n       this.maxSize = maxSize;\n     }\n \n     @Override\n-    public R put(R resource) {\n-      if (super.size() < maxSize) {\n-        add(resource);\n+    public R get() {\n+      int size = resources.size();\n+\n+      /* letting pool to grow */\n+      if (size < maxSize) {\n+        return null;\n       }\n+\n+      R resource = resources.get(nextIndex);\n+\n+      /* at this point size cannot be 0 */\n+      nextIndex = (nextIndex + 1) % size;\n+\n+      return resource;\n+    }\n+\n+    @Override\n+    public R put(R resource) {\n+      resources.add(resource);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2f70ff1e95347625720b0348098d61c61c9a742"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzgyMjM5OA==", "bodyText": "this feels backwards, since we return null to indicate that something outside of the pool should create another pooled resource.\nCan we define the Pool interface such that a given instance of Pool can handle this creation as an internal detail? something analogous to TheadLocal's initialize method?", "url": "https://github.com/apache/hbase/pull/2685#discussion_r527822398", "createdAt": "2020-11-20T16:49:56Z", "author": {"login": "busbey"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/util/PoolMap.java", "diffHunk": "@@ -275,43 +272,70 @@ public static PoolType fuzzyMatch(String name) {\n    *\n    */\n   @SuppressWarnings(\"serial\")\n-  static class RoundRobinPool<R> extends CopyOnWriteArrayList<R> implements Pool<R> {\n-    private int maxSize;\n-    private int nextResource = 0;\n+  static class RoundRobinPool<R> implements Pool<R> {\n+    private final List<R> resources;\n+    private final int maxSize;\n+\n+    private int nextIndex;\n \n     public RoundRobinPool(int maxSize) {\n+      if (maxSize <= 0) {\n+        throw new IllegalArgumentException(\"maxSize must be positive\");\n+      }\n+\n+      resources = new ArrayList<>(maxSize);\n       this.maxSize = maxSize;\n     }\n \n     @Override\n-    public R put(R resource) {\n-      if (super.size() < maxSize) {\n-        add(resource);\n+    public R get() {\n+      int size = resources.size();\n+\n+      /* letting pool to grow */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2f70ff1e95347625720b0348098d61c61c9a742"}, "originalPosition": 90}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6af78a3f9f900a273512aeb55e3c6615f7925a2", "author": {"user": {"login": "meszibalu", "name": "Balazs Meszaros"}}, "url": "https://github.com/apache/hbase/commit/d6af78a3f9f900a273512aeb55e3c6615f7925a2", "committedDate": "2020-11-20T19:39:44Z", "message": "Addressed review comments. Modified commit message below:\n\nHBASE-25307 ThreadLocal pooling leads to NullPointerException\n\n* PoolMap does not discard any elements anymore. If an element is put,\nit always stores it. The reason: it stores expensive resources (rpc\nconnections) which would lead to resource leak if we simple discard it.\nRpcClients can reference netty ByteBufs which are reference counted.\nResource cleanup is done by AbstractRpcClient.cleanupIdleConnections().\n* PoolMap does not implement Map interface anymore, so ensuring\nthread-safety become easier. Put method is replaced with getOrCreate().\n* ThreadLocalPool doesn't uses ThreadLocal class anymore. It stores\nresources on thread basis, but it doesn't remove values when a thread\nexits. Again, proper cleanup is done by cleanupIdleConnections()."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzcxNzg0", "url": "https://github.com/apache/hbase/pull/2685#pullrequestreview-535771784", "createdAt": "2020-11-20T20:58:44Z", "commit": {"oid": "d6af78a3f9f900a273512aeb55e3c6615f7925a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMDo1ODo0NVrOH3ghsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMDo1ODo0NVrOH3ghsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2NjY0Mw==", "bodyText": "Do we still need this method? I don't see it getting used in AbstractRpcClient?", "url": "https://github.com/apache/hbase/pull/2685#discussion_r527966643", "createdAt": "2020-11-20T20:58:45Z", "author": {"login": "busbey"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/util/PoolMap.java", "diffHunk": "@@ -45,177 +36,138 @@\n  * key. A size of {@link Integer#MAX_VALUE} is interpreted as an unbounded pool.\n  * </p>\n  *\n+ * <p>\n+ * PoolMap is thread-safe. It does not remove elements automatically. Unused resources\n+ * must be closed and removed explicitly.\n+ * </p>\n+ *\n  * @param <K>\n  *          the type of the key to the resource\n  * @param <V>\n  *          the type of the resource being pooled\n  */\n @InterfaceAudience.Private\n-public class PoolMap<K, V> implements Map<K, V> {\n-  private PoolType poolType;\n-\n-  private int poolMaxSize;\n-\n-  private Map<K, Pool<V>> pools = new ConcurrentHashMap<>();\n-\n-  public PoolMap(PoolType poolType) {\n-    this.poolType = poolType;\n-  }\n-\n-  public PoolMap(PoolType poolType, int poolMaxSize) {\n-    this.poolType = poolType;\n-    this.poolMaxSize = poolMaxSize;\n+public class PoolMap<K, V> {\n+  private final Map<K, Pool<V>> pools;\n+  private final PoolType poolType;\n+  private final int poolMaxSize;\n+\n+   public PoolMap(PoolType poolType, int poolMaxSize) {\n+     pools = new HashMap<>();\n+     this.poolType = poolType;\n+     this.poolMaxSize = poolMaxSize;\n   }\n \n-  @Override\n-  public V get(Object key) {\n-    Pool<V> pool = pools.get(key);\n-    return pool != null ? pool.get() : null;\n+  public V getOrCreate(K key, PoolResourceSupplier<V> supplier) throws IOException {\n+     synchronized (pools) {\n+       Pool<V> pool = pools.get(key);\n+\n+       if (pool == null) {\n+         pool = createPool();\n+         pools.put(key, pool);\n+       }\n+\n+       try {\n+         return pool.getOrCreate(supplier);\n+       } catch (IOException | RuntimeException | Error e) {\n+         if (pool.size() == 0) {\n+           pools.remove(key);\n+         }\n+\n+         throw e;\n+       }\n+     }\n   }\n+  public boolean remove(K key, V value) {\n+    synchronized (pools) {\n+      Pool<V> pool = pools.get(key);\n \n-  @Override\n-  public V put(K key, V value) {\n-    Pool<V> pool = pools.get(key);\n-    if (pool == null) {\n-      pools.put(key, pool = createPool());\n-    }\n-    return pool != null ? pool.put(value) : null;\n-  }\n+      if (pool == null) {\n+        return false;\n+      }\n \n-  @SuppressWarnings(\"unchecked\")\n-  @Override\n-  public V remove(Object key) {\n-    Pool<V> pool = pools.remove(key);\n-    if (pool != null) {\n-      removeValue((K) key, pool.get());\n-    }\n-    return null;\n-  }\n+      boolean removed = pool.remove(value);\n \n-  public boolean removeValue(K key, V value) {\n-    Pool<V> pool = pools.get(key);\n-    boolean res = false;\n-    if (pool != null) {\n-      res = pool.remove(value);\n-      if (res && pool.size() == 0) {\n+      if (removed && pool.size() == 0) {\n         pools.remove(key);\n       }\n+\n+      return removed;\n     }\n-    return res;\n   }\n \n-  @Override\n-  public Collection<V> values() {\n-    Collection<V> values = new ArrayList<>();\n-    for (Pool<V> pool : pools.values()) {\n-      Collection<V> poolValues = pool.values();\n-      if (poolValues != null) {\n-        values.addAll(poolValues);\n-      }\n+  public void remove(K key) {\n+    synchronized (pools) {\n+      pools.remove(key);\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6af78a3f9f900a273512aeb55e3c6615f7925a2"}, "originalPosition": 137}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzcyNzc0", "url": "https://github.com/apache/hbase/pull/2685#pullrequestreview-535772774", "createdAt": "2020-11-20T21:00:30Z", "commit": {"oid": "d6af78a3f9f900a273512aeb55e3c6615f7925a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMTowMDozMFrOH3gk3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMTowMDozMFrOH3gk3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2NzQ1NA==", "bodyText": "now that this is thread-safe can we remove the synchronization around the instance that's in AbstractRpcClient?", "url": "https://github.com/apache/hbase/pull/2685#discussion_r527967454", "createdAt": "2020-11-20T21:00:30Z", "author": {"login": "busbey"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/util/PoolMap.java", "diffHunk": "@@ -45,177 +36,138 @@\n  * key. A size of {@link Integer#MAX_VALUE} is interpreted as an unbounded pool.\n  * </p>\n  *\n+ * <p>\n+ * PoolMap is thread-safe. It does not remove elements automatically. Unused resources\n+ * must be closed and removed explicitly.\n+ * </p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6af78a3f9f900a273512aeb55e3c6615f7925a2"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzczODcw", "url": "https://github.com/apache/hbase/pull/2685#pullrequestreview-535773870", "createdAt": "2020-11-20T21:02:28Z", "commit": {"oid": "d6af78a3f9f900a273512aeb55e3c6615f7925a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMTowMjoyOVrOH3goCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMTowMjoyOVrOH3goCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk2ODI2NQ==", "bodyText": "we still need this? don't see it getting used in AbstractRpcClient", "url": "https://github.com/apache/hbase/pull/2685#discussion_r527968265", "createdAt": "2020-11-20T21:02:29Z", "author": {"login": "busbey"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/util/PoolMap.java", "diffHunk": "@@ -45,177 +36,138 @@\n  * key. A size of {@link Integer#MAX_VALUE} is interpreted as an unbounded pool.\n  * </p>\n  *\n+ * <p>\n+ * PoolMap is thread-safe. It does not remove elements automatically. Unused resources\n+ * must be closed and removed explicitly.\n+ * </p>\n+ *\n  * @param <K>\n  *          the type of the key to the resource\n  * @param <V>\n  *          the type of the resource being pooled\n  */\n @InterfaceAudience.Private\n-public class PoolMap<K, V> implements Map<K, V> {\n-  private PoolType poolType;\n-\n-  private int poolMaxSize;\n-\n-  private Map<K, Pool<V>> pools = new ConcurrentHashMap<>();\n-\n-  public PoolMap(PoolType poolType) {\n-    this.poolType = poolType;\n-  }\n-\n-  public PoolMap(PoolType poolType, int poolMaxSize) {\n-    this.poolType = poolType;\n-    this.poolMaxSize = poolMaxSize;\n+public class PoolMap<K, V> {\n+  private final Map<K, Pool<V>> pools;\n+  private final PoolType poolType;\n+  private final int poolMaxSize;\n+\n+   public PoolMap(PoolType poolType, int poolMaxSize) {\n+     pools = new HashMap<>();\n+     this.poolType = poolType;\n+     this.poolMaxSize = poolMaxSize;\n   }\n \n-  @Override\n-  public V get(Object key) {\n-    Pool<V> pool = pools.get(key);\n-    return pool != null ? pool.get() : null;\n+  public V getOrCreate(K key, PoolResourceSupplier<V> supplier) throws IOException {\n+     synchronized (pools) {\n+       Pool<V> pool = pools.get(key);\n+\n+       if (pool == null) {\n+         pool = createPool();\n+         pools.put(key, pool);\n+       }\n+\n+       try {\n+         return pool.getOrCreate(supplier);\n+       } catch (IOException | RuntimeException | Error e) {\n+         if (pool.size() == 0) {\n+           pools.remove(key);\n+         }\n+\n+         throw e;\n+       }\n+     }\n   }\n+  public boolean remove(K key, V value) {\n+    synchronized (pools) {\n+      Pool<V> pool = pools.get(key);\n \n-  @Override\n-  public V put(K key, V value) {\n-    Pool<V> pool = pools.get(key);\n-    if (pool == null) {\n-      pools.put(key, pool = createPool());\n-    }\n-    return pool != null ? pool.put(value) : null;\n-  }\n+      if (pool == null) {\n+        return false;\n+      }\n \n-  @SuppressWarnings(\"unchecked\")\n-  @Override\n-  public V remove(Object key) {\n-    Pool<V> pool = pools.remove(key);\n-    if (pool != null) {\n-      removeValue((K) key, pool.get());\n-    }\n-    return null;\n-  }\n+      boolean removed = pool.remove(value);\n \n-  public boolean removeValue(K key, V value) {\n-    Pool<V> pool = pools.get(key);\n-    boolean res = false;\n-    if (pool != null) {\n-      res = pool.remove(value);\n-      if (res && pool.size() == 0) {\n+      if (removed && pool.size() == 0) {\n         pools.remove(key);\n       }\n+\n+      return removed;\n     }\n-    return res;\n   }\n \n-  @Override\n-  public Collection<V> values() {\n-    Collection<V> values = new ArrayList<>();\n-    for (Pool<V> pool : pools.values()) {\n-      Collection<V> poolValues = pool.values();\n-      if (poolValues != null) {\n-        values.addAll(poolValues);\n-      }\n+  public void remove(K key) {\n+    synchronized (pools) {\n+      pools.remove(key);\n     }\n-    return values;\n   }\n \n-  public Collection<V> values(K key) {\n-    Collection<V> values = new ArrayList<>();\n-    Pool<V> pool = pools.get(key);\n-    if (pool != null) {\n-      Collection<V> poolValues = pool.values();\n-      if (poolValues != null) {\n-        values.addAll(poolValues);\n+  public List<V> values() {\n+    List<V> values = new ArrayList<>();\n+\n+    synchronized (pools) {\n+      for (Pool<V> pool : pools.values()) {\n+        Collection<V> poolValues = pool.values();\n+        if (poolValues != null) {\n+          values.addAll(poolValues);\n+        }\n       }\n     }\n+\n     return values;\n   }\n \n+  public List<V> values(K key) {\n+    synchronized (pools) {\n+      Pool<V> pool = pools.get(key);\n \n-  @Override\n-  public boolean isEmpty() {\n-    return pools.isEmpty();\n+      if (pool == null) {\n+        return Collections.emptyList();\n+      } else {\n+        return new ArrayList<>(pool.values());\n+      }\n+    }\n   }\n \n-  @Override\n   public int size() {\n-    return pools.size();\n+    synchronized (pools) {\n+      return pools.size();\n+    }\n   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6af78a3f9f900a273512aeb55e3c6615f7925a2"}, "originalPosition": 184}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzkxMTc5", "url": "https://github.com/apache/hbase/pull/2685#pullrequestreview-535791179", "createdAt": "2020-11-20T21:32:30Z", "commit": {"oid": "d6af78a3f9f900a273512aeb55e3c6615f7925a2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMTozMjozMFrOH3heqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMTozMjozMFrOH3heqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk4MjI0OQ==", "bodyText": "I think this won't work in combination with the existing cleanupIdleConnections method. Since it'll be called from the idle connection sweeper's pool of threads it won't be from the threads that made the rpc requests so the \"myself\" key here will always be wrong.", "url": "https://github.com/apache/hbase/pull/2685#discussion_r527982249", "createdAt": "2020-11-20T21:32:30Z", "author": {"login": "busbey"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/util/PoolMap.java", "diffHunk": "@@ -321,62 +297,45 @@ public R get() {\n    * @param <R>\n    *          the type of the resource\n    */\n-  static class ThreadLocalPool<R> extends ThreadLocal<R> implements Pool<R> {\n-    private static final Map<ThreadLocalPool<?>, AtomicInteger> poolSizes = new HashMap<>();\n+  static class ThreadLocalPool<R> implements Pool<R> {\n+    private final Map<Thread, R> resources;\n \n     public ThreadLocalPool() {\n+      resources = new HashMap<>();\n     }\n \n     @Override\n-    public R put(R resource) {\n-      R previousResource = get();\n-      if (previousResource == null) {\n-        AtomicInteger poolSize = poolSizes.get(this);\n-        if (poolSize == null) {\n-          poolSizes.put(this, poolSize = new AtomicInteger(0));\n-        }\n-        poolSize.incrementAndGet();\n-      }\n-      this.set(resource);\n-      return previousResource;\n-    }\n+    public R getOrCreate(PoolResourceSupplier<R> supplier) throws IOException {\n+      Thread myself = Thread.currentThread();\n+      R resource = resources.get(myself);\n \n-    @Override\n-    public void remove() {\n-      super.remove();\n-      AtomicInteger poolSize = poolSizes.get(this);\n-      if (poolSize != null) {\n-        poolSize.decrementAndGet();\n+      if (resource == null) {\n+        resource = createResource(supplier);\n+        resources.put(myself, resource);\n       }\n+\n+      return resource;\n     }\n \n     @Override\n-    public int size() {\n-      AtomicInteger poolSize = poolSizes.get(this);\n-      return poolSize != null ? poolSize.get() : 0;\n+    public boolean remove(R resource) {\n+      Thread myself = Thread.currentThread();\n+      return resources.remove(myself, resource);\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6af78a3f9f900a273512aeb55e3c6615f7925a2"}, "originalPosition": 430}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d4e5bf88aa682ba668fe15b0c60b5cfceaa8578", "author": {"user": {"login": "meszibalu", "name": "Balazs Meszaros"}}, "url": "https://github.com/apache/hbase/commit/5d4e5bf88aa682ba668fe15b0c60b5cfceaa8578", "committedDate": "2020-11-22T08:41:41Z", "message": "address review comments, remove unused methods"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3NDk2MDcw", "url": "https://github.com/apache/hbase/pull/2685#pullrequestreview-537496070", "createdAt": "2020-11-24T13:35:51Z", "commit": {"oid": "5d4e5bf88aa682ba668fe15b0c60b5cfceaa8578"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMzozNTo1MVrOH5BG5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMzo0NzoxN1rOH5Bkww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU0OTAzMA==", "bodyText": "nit: a comment in the javadoc for this test that says \"There is no pool cap for the ThreadLocalPool\" or a change in the test name to e.g. testNoPoolCap would make this test easier to follow.", "url": "https://github.com/apache/hbase/pull/2685#discussion_r529549030", "createdAt": "2020-11-24T13:35:51Z", "author": {"login": "busbey"}, "path": "hbase-client/src/test/java/org/apache/hadoop/hbase/util/TestThreadLocalPoolMap.java", "diffHunk": "@@ -43,42 +43,42 @@ protected PoolType getPoolType() {\n   }\n \n   @Test\n-  public void testSingleThreadedClient() throws InterruptedException, ExecutionException {\n+  public void testSingleThreadedClient() throws InterruptedException {\n     Random rand = ThreadLocalRandom.current();\n-    String randomKey = String.valueOf(rand.nextInt());\n-    String randomValue = String.valueOf(rand.nextInt());\n-    // As long as the pool is not full, we should get back what we put\n-    runThread(randomKey, randomValue, randomValue);\n-    assertEquals(1, poolMap.size(randomKey));\n+    String key = \"key\";\n+    String value = \"value\";\n+    runThread(key, () -> value, value);\n+    assertEquals(1, poolMap.values().size());\n   }\n \n   @Test\n-  public void testMultiThreadedClients() throws InterruptedException, ExecutionException {\n-    Random rand = ThreadLocalRandom.current();\n-    // As long as the pool is not full, we should get back what we put\n-    for (int i = 0; i < POOL_SIZE; i++) {\n-      String randomKey = String.valueOf(rand.nextInt());\n-      String randomValue = String.valueOf(rand.nextInt());\n-      runThread(randomKey, randomValue, randomValue);\n-      assertEquals(1, poolMap.size(randomKey));\n+  public void testMultiThreadedClients() throws InterruptedException {\n+    for (int i = 0; i < KEY_COUNT; i++) {\n+      String key = Integer.toString(i);\n+      String value = Integer.toString(2 * i);\n+      runThread(key, () -> value, value);\n     }\n-    String randomKey = String.valueOf(rand.nextInt());\n+\n+    assertEquals(KEY_COUNT, poolMap.values().size());\n+    poolMap.clear();\n+\n+    String key = \"key\";\n     for (int i = 0; i < POOL_SIZE; i++) {\n-      String randomValue = String.valueOf(rand.nextInt());\n-      runThread(randomKey, randomValue, randomValue);\n-      assertEquals(i + 1, poolMap.size(randomKey));\n+      String value = Integer.toString(i);\n+      runThread(key, () -> value, value);\n     }\n+\n+    assertEquals(POOL_SIZE, poolMap.values().size());\n   }\n \n   @Test\n-  public void testPoolCap() throws InterruptedException, ExecutionException {\n-    Random rand = ThreadLocalRandom.current();\n-    String randomKey = String.valueOf(rand.nextInt());\n+  public void testPoolCap() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d4e5bf88aa682ba668fe15b0c60b5cfceaa8578"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1NTA3OQ==", "bodyText": "we should drop the \"as long as the pool is not full\" comment here. This first stanza is testing \"as long as we use distinct keys we should get get back the supplied value\" and \"we end up with 1 value per pool\".", "url": "https://github.com/apache/hbase/pull/2685#discussion_r529555079", "createdAt": "2020-11-24T13:44:53Z", "author": {"login": "busbey"}, "path": "hbase-client/src/test/java/org/apache/hadoop/hbase/util/TestRoundRobinPoolMap.java", "diffHunk": "@@ -45,58 +46,53 @@ protected PoolType getPoolType() {\n   }\n \n   @Test\n-  public void testSingleThreadedClient() throws InterruptedException, ExecutionException {\n-    Random rand = ThreadLocalRandom.current();\n-    String randomKey = String.valueOf(rand.nextInt());\n-    String randomValue = String.valueOf(rand.nextInt());\n-    // As long as the pool is not full, we'll get null back.\n-    // This forces the user to create new values that can be used to populate\n-    // the pool.\n-    runThread(randomKey, randomValue, null);\n-    assertEquals(1, poolMap.size(randomKey));\n+  public void testSingleThreadedClient() throws InterruptedException {\n+    String key = \"key\";\n+    String value = \"value\";\n+    // As long as the pool is not full, get calls the supplier\n+    runThread(key, () -> value, value);\n+    assertEquals(1, poolMap.values().size());\n   }\n \n   @Test\n-  public void testMultiThreadedClients() throws InterruptedException, ExecutionException {\n-    Random rand = ThreadLocalRandom.current();\n-    for (int i = 0; i < POOL_SIZE; i++) {\n-      String randomKey = String.valueOf(rand.nextInt());\n-      String randomValue = String.valueOf(rand.nextInt());\n-      // As long as the pool is not full, we'll get null back\n-      runThread(randomKey, randomValue, null);\n-      // As long as we use distinct keys, each pool will have one value\n-      assertEquals(1, poolMap.size(randomKey));\n+  public void testMultiThreadedClients() throws InterruptedException {\n+    for (int i = 0; i < KEY_COUNT; i++) {\n+      String key = Integer.toString(i);\n+      String value = Integer.toString(2 * i);\n+      // As long as the pool is not full, we'll get the supplied value back\n+      runThread(key, () -> value, value);\n     }\n+\n+    assertEquals(KEY_COUNT, poolMap.values().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d4e5bf88aa682ba668fe15b0c60b5cfceaa8578"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTU1NjY3NQ==", "bodyText": "this would be a stronger test for the ThreadLocalPool if we made each of these distinct key lookups in a single thread. a TODO note for later?", "url": "https://github.com/apache/hbase/pull/2685#discussion_r529556675", "createdAt": "2020-11-24T13:47:17Z", "author": {"login": "busbey"}, "path": "hbase-client/src/test/java/org/apache/hadoop/hbase/util/TestThreadLocalPoolMap.java", "diffHunk": "@@ -43,42 +43,42 @@ protected PoolType getPoolType() {\n   }\n \n   @Test\n-  public void testSingleThreadedClient() throws InterruptedException, ExecutionException {\n+  public void testSingleThreadedClient() throws InterruptedException {\n     Random rand = ThreadLocalRandom.current();\n-    String randomKey = String.valueOf(rand.nextInt());\n-    String randomValue = String.valueOf(rand.nextInt());\n-    // As long as the pool is not full, we should get back what we put\n-    runThread(randomKey, randomValue, randomValue);\n-    assertEquals(1, poolMap.size(randomKey));\n+    String key = \"key\";\n+    String value = \"value\";\n+    runThread(key, () -> value, value);\n+    assertEquals(1, poolMap.values().size());\n   }\n \n   @Test\n-  public void testMultiThreadedClients() throws InterruptedException, ExecutionException {\n-    Random rand = ThreadLocalRandom.current();\n-    // As long as the pool is not full, we should get back what we put\n-    for (int i = 0; i < POOL_SIZE; i++) {\n-      String randomKey = String.valueOf(rand.nextInt());\n-      String randomValue = String.valueOf(rand.nextInt());\n-      runThread(randomKey, randomValue, randomValue);\n-      assertEquals(1, poolMap.size(randomKey));\n+  public void testMultiThreadedClients() throws InterruptedException {\n+    for (int i = 0; i < KEY_COUNT; i++) {\n+      String key = Integer.toString(i);\n+      String value = Integer.toString(2 * i);\n+      runThread(key, () -> value, value);\n     }\n-    String randomKey = String.valueOf(rand.nextInt());\n+\n+    assertEquals(KEY_COUNT, poolMap.values().size());\n+    poolMap.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d4e5bf88aa682ba668fe15b0c60b5cfceaa8578"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ebbc0d0238771fa635641decb4baced80ce61bb", "author": {"user": {"login": "meszibalu", "name": "Balazs Meszaros"}}, "url": "https://github.com/apache/hbase/commit/2ebbc0d0238771fa635641decb4baced80ce61bb", "committedDate": "2020-11-24T16:23:49Z", "message": "test refactor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3NzkxMzcy", "url": "https://github.com/apache/hbase/pull/2685#pullrequestreview-537791372", "createdAt": "2020-11-24T18:24:27Z", "commit": {"oid": "2ebbc0d0238771fa635641decb4baced80ce61bb"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxODoyNDoyOFrOH5Pu5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxODozMjozMlrOH5QCSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc4ODY0Nw==", "bodyText": "nit: this second line is wrong. the first value is now 0 and not 1, and runThread doesn't exist.", "url": "https://github.com/apache/hbase/pull/2685#discussion_r529788647", "createdAt": "2020-11-24T18:24:28Z", "author": {"login": "busbey"}, "path": "hbase-client/src/test/java/org/apache/hadoop/hbase/util/TestRoundRobinPoolMap.java", "diffHunk": "@@ -45,58 +52,104 @@ protected PoolType getPoolType() {\n   }\n \n   @Test\n-  public void testSingleThreadedClient() throws InterruptedException, ExecutionException {\n-    Random rand = ThreadLocalRandom.current();\n-    String randomKey = String.valueOf(rand.nextInt());\n-    String randomValue = String.valueOf(rand.nextInt());\n-    // As long as the pool is not full, we'll get null back.\n-    // This forces the user to create new values that can be used to populate\n-    // the pool.\n-    runThread(randomKey, randomValue, null);\n-    assertEquals(1, poolMap.size(randomKey));\n+  public void testGetOrCreate() throws IOException {\n+    String key = \"key\";\n+    String value = \"value\";\n+    String result = poolMap.getOrCreate(key, () -> value);\n+\n+    assertEquals(value, result);\n+    assertEquals(1, poolMap.values().size());\n+  }\n+\n+  @Test\n+  public void testMultipleKeys() throws IOException {\n+    for (int i = 0; i < KEY_COUNT; i++) {\n+      String key = Integer.toString(i);\n+      String value = Integer.toString(2 * i);\n+      String result = poolMap.getOrCreate(key, () -> value);\n+\n+      assertEquals(value, result);\n+    }\n+\n+    assertEquals(KEY_COUNT, poolMap.values().size());\n+  }\n+\n+  @Test\n+  public void testMultipleValues() throws IOException {\n+    String key = \"key\";\n+\n+    for (int i = 0; i < POOL_SIZE; i++) {\n+      String value = Integer.toString(i);\n+      String result = poolMap.getOrCreate(key, () -> value);\n+\n+      assertEquals(value, result);\n+    }\n+\n+    assertEquals(POOL_SIZE, poolMap.values().size());\n   }\n \n   @Test\n-  public void testMultiThreadedClients() throws InterruptedException, ExecutionException {\n-    Random rand = ThreadLocalRandom.current();\n+  public void testRoundRobin() throws IOException {\n+    String key = \"key\";\n+\n     for (int i = 0; i < POOL_SIZE; i++) {\n-      String randomKey = String.valueOf(rand.nextInt());\n-      String randomValue = String.valueOf(rand.nextInt());\n-      // As long as the pool is not full, we'll get null back\n-      runThread(randomKey, randomValue, null);\n-      // As long as we use distinct keys, each pool will have one value\n-      assertEquals(1, poolMap.size(randomKey));\n+      String value = Integer.toString(i);\n+      poolMap.getOrCreate(key, () -> value);\n     }\n-    poolMap.clear();\n-    String randomKey = String.valueOf(rand.nextInt());\n-    for (int i = 0; i < POOL_SIZE - 1; i++) {\n-      String randomValue = String.valueOf(rand.nextInt());\n-      // As long as the pool is not full, we'll get null back\n-      runThread(randomKey, randomValue, null);\n-      // since we use the same key, the pool size should grow\n-      assertEquals(i + 1, poolMap.size(randomKey));\n+\n+    assertEquals(POOL_SIZE, poolMap.values().size());\n+\n+    // pool is filled, get() should return elements round robin order\n+    // starting from 1, because the first get was called by runThread()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ebbc0d0238771fa635641decb4baced80ce61bb"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc5MzYwOQ==", "bodyText": "this is a great test.", "url": "https://github.com/apache/hbase/pull/2685#discussion_r529793609", "createdAt": "2020-11-24T18:32:32Z", "author": {"login": "busbey"}, "path": "hbase-client/src/test/java/org/apache/hadoop/hbase/util/TestRoundRobinPoolMap.java", "diffHunk": "@@ -45,58 +52,104 @@ protected PoolType getPoolType() {\n   }\n \n   @Test\n-  public void testSingleThreadedClient() throws InterruptedException, ExecutionException {\n-    Random rand = ThreadLocalRandom.current();\n-    String randomKey = String.valueOf(rand.nextInt());\n-    String randomValue = String.valueOf(rand.nextInt());\n-    // As long as the pool is not full, we'll get null back.\n-    // This forces the user to create new values that can be used to populate\n-    // the pool.\n-    runThread(randomKey, randomValue, null);\n-    assertEquals(1, poolMap.size(randomKey));\n+  public void testGetOrCreate() throws IOException {\n+    String key = \"key\";\n+    String value = \"value\";\n+    String result = poolMap.getOrCreate(key, () -> value);\n+\n+    assertEquals(value, result);\n+    assertEquals(1, poolMap.values().size());\n+  }\n+\n+  @Test\n+  public void testMultipleKeys() throws IOException {\n+    for (int i = 0; i < KEY_COUNT; i++) {\n+      String key = Integer.toString(i);\n+      String value = Integer.toString(2 * i);\n+      String result = poolMap.getOrCreate(key, () -> value);\n+\n+      assertEquals(value, result);\n+    }\n+\n+    assertEquals(KEY_COUNT, poolMap.values().size());\n+  }\n+\n+  @Test\n+  public void testMultipleValues() throws IOException {\n+    String key = \"key\";\n+\n+    for (int i = 0; i < POOL_SIZE; i++) {\n+      String value = Integer.toString(i);\n+      String result = poolMap.getOrCreate(key, () -> value);\n+\n+      assertEquals(value, result);\n+    }\n+\n+    assertEquals(POOL_SIZE, poolMap.values().size());\n   }\n \n   @Test\n-  public void testMultiThreadedClients() throws InterruptedException, ExecutionException {\n-    Random rand = ThreadLocalRandom.current();\n+  public void testRoundRobin() throws IOException {\n+    String key = \"key\";\n+\n     for (int i = 0; i < POOL_SIZE; i++) {\n-      String randomKey = String.valueOf(rand.nextInt());\n-      String randomValue = String.valueOf(rand.nextInt());\n-      // As long as the pool is not full, we'll get null back\n-      runThread(randomKey, randomValue, null);\n-      // As long as we use distinct keys, each pool will have one value\n-      assertEquals(1, poolMap.size(randomKey));\n+      String value = Integer.toString(i);\n+      poolMap.getOrCreate(key, () -> value);\n     }\n-    poolMap.clear();\n-    String randomKey = String.valueOf(rand.nextInt());\n-    for (int i = 0; i < POOL_SIZE - 1; i++) {\n-      String randomValue = String.valueOf(rand.nextInt());\n-      // As long as the pool is not full, we'll get null back\n-      runThread(randomKey, randomValue, null);\n-      // since we use the same key, the pool size should grow\n-      assertEquals(i + 1, poolMap.size(randomKey));\n+\n+    assertEquals(POOL_SIZE, poolMap.values().size());\n+\n+    // pool is filled, get() should return elements round robin order\n+    // starting from 1, because the first get was called by runThread()\n+    for (int i = 0; i < 2 * POOL_SIZE; i++) {\n+      String expected = Integer.toString(i % POOL_SIZE);\n+      assertEquals(expected, poolMap.getOrCreate(key, () -> {\n+        throw new IOException(\"must not call me\");\n+      }));\n     }\n-    // at the end of the day, there should be as many values as we put\n-    assertEquals(POOL_SIZE - 1, poolMap.size(randomKey));\n+\n+    assertEquals(POOL_SIZE, poolMap.values().size());\n   }\n \n   @Test\n-  public void testPoolCap() throws InterruptedException, ExecutionException {\n-    Random rand = ThreadLocalRandom.current();\n-    String randomKey = String.valueOf(rand.nextInt());\n-    List<String> randomValues = new ArrayList<>();\n-    for (int i = 0; i < POOL_SIZE * 2; i++) {\n-      String randomValue = String.valueOf(rand.nextInt());\n-      randomValues.add(randomValue);\n-      if (i < POOL_SIZE - 1) {\n-        // As long as the pool is not full, we'll get null back\n-        runThread(randomKey, randomValue, null);\n-      } else {\n-        // when the pool becomes full, we expect the value we get back to be\n-        // what we put earlier, in round-robin order\n-        runThread(randomKey, randomValue, randomValues.get((i - POOL_SIZE + 1) % POOL_SIZE));\n+  public void testMultiThreadedRoundRobin() throws ExecutionException, InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2ebbc0d0238771fa635641decb4baced80ce61bb"}, "originalPosition": 125}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73f64c8c2f19b363f72ce02818fdca49b962fef5", "author": {"user": {"login": "meszibalu", "name": "Balazs Meszaros"}}, "url": "https://github.com/apache/hbase/commit/73f64c8c2f19b363f72ce02818fdca49b962fef5", "committedDate": "2020-11-24T19:09:06Z", "message": "fix comment"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4963, "cost": 1, "resetAt": "2021-10-28T18:00:02Z"}}}