{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUxOTY0NTg4", "number": 2095, "reviewThreads": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxNzowNTo1MFrOEP30PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxODowMzozOVrOEQvNBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDc4NTg4OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxNzowNTo1MFrOGzw5hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNjozNzo0MlrOGz7FCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzMTcxNw==", "bodyText": "By any chance, subsequent execution with error can produce NPE here? e.g first thread encounters error, sets futureRef to null and second one when calls completeExceptionally(), it calls it on null?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456931717", "createdAt": "2020-07-19T17:05:50Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -652,4 +626,160 @@ static void setCoprocessorError(RpcController controller, Throwable error) {\n       controller.setFailed(error.toString());\n     }\n   }\n+\n+  public static RegionLocations locateRow(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    Map.Entry<byte[], RegionLocations> entry = cache.floorEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    byte[] endKey = loc.getRegion().getEndKey();\n+    if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.CURRENT, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static RegionLocations locateRowBefore(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    boolean isEmptyStopRow = isEmptyStopRow(row);\n+    Map.Entry<byte[], RegionLocations> entry =\n+      isEmptyStopRow ? cache.lastEntry() : cache.lowerEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n+      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static void tryClearMasterStubCache(IOException error,\n+    ClientMetaService.Interface currentStub, AtomicReference<ClientMetaService.Interface> stub) {\n+    if (ClientExceptionsUtil.isConnectionException(error) ||\n+      error instanceof ServerNotRunningYetException) {\n+      stub.compareAndSet(currentStub, null);\n+    }\n+  }\n+\n+  public static <T> CompletableFuture<T> getMasterStub(ConnectionRegistry registry,\n+    AtomicReference<T> stub, AtomicReference<CompletableFuture<T>> stubMakeFuture,\n+    RpcClient rpcClient, User user, long rpcTimeout, TimeUnit unit,\n+    Function<RpcChannel, T> stubMaker, String type) {\n+    return getOrFetch(stub, stubMakeFuture, () -> {\n+      CompletableFuture<T> future = new CompletableFuture<>();\n+      addListener(registry.getActiveMaster(), (addr, error) -> {\n+        if (error != null) {\n+          future.completeExceptionally(error);\n+        } else if (addr == null) {\n+          future.completeExceptionally(new MasterNotRunningException(\n+            \"ZooKeeper available but no active master location found\"));\n+        } else {\n+          LOG.debug(\"The fetched master address is {}\", addr);\n+          try {\n+            future.complete(stubMaker.apply(\n+              rpcClient.createRpcChannel(addr, user, toIntNoOverflow(unit.toMillis(rpcTimeout)))));\n+          } catch (IOException e) {\n+            future.completeExceptionally(e);\n+          }\n+        }\n+\n+      });\n+      return future;\n+    }, type);\n+  }\n+\n+  private static <T> CompletableFuture<T> getOrFetch(AtomicReference<T> cacheRef,\n+    AtomicReference<CompletableFuture<T>> futureRef, \n+    Supplier<CompletableFuture<T>> fetch, String type) {\n+    for (;;) {\n+      T cachedValue = cacheRef.get();\n+      if (cachedValue != null) {\n+        return CompletableFuture.completedFuture(cachedValue);\n+      }\n+      LOG.trace(\"{} cache is null, try fetching from registry\", type);\n+      if (futureRef.compareAndSet(null, new CompletableFuture<>())) {\n+        LOG.debug(\"Start fetching {} from registry\", type);\n+        CompletableFuture<T> future = futureRef.get();\n+        addListener(fetch.get(), (value, error) -> {\n+          if (error != null) {\n+            LOG.debug(\"Failed to fetch {} from registry\", type, error);\n+            futureRef.getAndSet(null).completeExceptionally(error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzAwMTczNg==", "bodyText": "You can see the whole method. We have done null check when calling futureRef.get() below.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457001736", "createdAt": "2020-07-20T02:54:04Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -652,4 +626,160 @@ static void setCoprocessorError(RpcController controller, Throwable error) {\n       controller.setFailed(error.toString());\n     }\n   }\n+\n+  public static RegionLocations locateRow(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    Map.Entry<byte[], RegionLocations> entry = cache.floorEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    byte[] endKey = loc.getRegion().getEndKey();\n+    if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.CURRENT, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static RegionLocations locateRowBefore(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    boolean isEmptyStopRow = isEmptyStopRow(row);\n+    Map.Entry<byte[], RegionLocations> entry =\n+      isEmptyStopRow ? cache.lastEntry() : cache.lowerEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n+      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static void tryClearMasterStubCache(IOException error,\n+    ClientMetaService.Interface currentStub, AtomicReference<ClientMetaService.Interface> stub) {\n+    if (ClientExceptionsUtil.isConnectionException(error) ||\n+      error instanceof ServerNotRunningYetException) {\n+      stub.compareAndSet(currentStub, null);\n+    }\n+  }\n+\n+  public static <T> CompletableFuture<T> getMasterStub(ConnectionRegistry registry,\n+    AtomicReference<T> stub, AtomicReference<CompletableFuture<T>> stubMakeFuture,\n+    RpcClient rpcClient, User user, long rpcTimeout, TimeUnit unit,\n+    Function<RpcChannel, T> stubMaker, String type) {\n+    return getOrFetch(stub, stubMakeFuture, () -> {\n+      CompletableFuture<T> future = new CompletableFuture<>();\n+      addListener(registry.getActiveMaster(), (addr, error) -> {\n+        if (error != null) {\n+          future.completeExceptionally(error);\n+        } else if (addr == null) {\n+          future.completeExceptionally(new MasterNotRunningException(\n+            \"ZooKeeper available but no active master location found\"));\n+        } else {\n+          LOG.debug(\"The fetched master address is {}\", addr);\n+          try {\n+            future.complete(stubMaker.apply(\n+              rpcClient.createRpcChannel(addr, user, toIntNoOverflow(unit.toMillis(rpcTimeout)))));\n+          } catch (IOException e) {\n+            future.completeExceptionally(e);\n+          }\n+        }\n+\n+      });\n+      return future;\n+    }, type);\n+  }\n+\n+  private static <T> CompletableFuture<T> getOrFetch(AtomicReference<T> cacheRef,\n+    AtomicReference<CompletableFuture<T>> futureRef, \n+    Supplier<CompletableFuture<T>> fetch, String type) {\n+    for (;;) {\n+      T cachedValue = cacheRef.get();\n+      if (cachedValue != null) {\n+        return CompletableFuture.completedFuture(cachedValue);\n+      }\n+      LOG.trace(\"{} cache is null, try fetching from registry\", type);\n+      if (futureRef.compareAndSet(null, new CompletableFuture<>())) {\n+        LOG.debug(\"Start fetching {} from registry\", type);\n+        CompletableFuture<T> future = futureRef.get();\n+        addListener(fetch.get(), (value, error) -> {\n+          if (error != null) {\n+            LOG.debug(\"Failed to fetch {} from registry\", type, error);\n+            futureRef.getAndSet(null).completeExceptionally(error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzMTcxNw=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA5ODUwNg==", "bodyText": "With futureRef.compareAndSet(null, val), we are good here.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457098506", "createdAt": "2020-07-20T06:37:42Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -652,4 +626,160 @@ static void setCoprocessorError(RpcController controller, Throwable error) {\n       controller.setFailed(error.toString());\n     }\n   }\n+\n+  public static RegionLocations locateRow(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    Map.Entry<byte[], RegionLocations> entry = cache.floorEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    byte[] endKey = loc.getRegion().getEndKey();\n+    if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.CURRENT, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static RegionLocations locateRowBefore(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    boolean isEmptyStopRow = isEmptyStopRow(row);\n+    Map.Entry<byte[], RegionLocations> entry =\n+      isEmptyStopRow ? cache.lastEntry() : cache.lowerEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n+      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static void tryClearMasterStubCache(IOException error,\n+    ClientMetaService.Interface currentStub, AtomicReference<ClientMetaService.Interface> stub) {\n+    if (ClientExceptionsUtil.isConnectionException(error) ||\n+      error instanceof ServerNotRunningYetException) {\n+      stub.compareAndSet(currentStub, null);\n+    }\n+  }\n+\n+  public static <T> CompletableFuture<T> getMasterStub(ConnectionRegistry registry,\n+    AtomicReference<T> stub, AtomicReference<CompletableFuture<T>> stubMakeFuture,\n+    RpcClient rpcClient, User user, long rpcTimeout, TimeUnit unit,\n+    Function<RpcChannel, T> stubMaker, String type) {\n+    return getOrFetch(stub, stubMakeFuture, () -> {\n+      CompletableFuture<T> future = new CompletableFuture<>();\n+      addListener(registry.getActiveMaster(), (addr, error) -> {\n+        if (error != null) {\n+          future.completeExceptionally(error);\n+        } else if (addr == null) {\n+          future.completeExceptionally(new MasterNotRunningException(\n+            \"ZooKeeper available but no active master location found\"));\n+        } else {\n+          LOG.debug(\"The fetched master address is {}\", addr);\n+          try {\n+            future.complete(stubMaker.apply(\n+              rpcClient.createRpcChannel(addr, user, toIntNoOverflow(unit.toMillis(rpcTimeout)))));\n+          } catch (IOException e) {\n+            future.completeExceptionally(e);\n+          }\n+        }\n+\n+      });\n+      return future;\n+    }, type);\n+  }\n+\n+  private static <T> CompletableFuture<T> getOrFetch(AtomicReference<T> cacheRef,\n+    AtomicReference<CompletableFuture<T>> futureRef, \n+    Supplier<CompletableFuture<T>> fetch, String type) {\n+    for (;;) {\n+      T cachedValue = cacheRef.get();\n+      if (cachedValue != null) {\n+        return CompletableFuture.completedFuture(cachedValue);\n+      }\n+      LOG.trace(\"{} cache is null, try fetching from registry\", type);\n+      if (futureRef.compareAndSet(null, new CompletableFuture<>())) {\n+        LOG.debug(\"Start fetching {} from registry\", type);\n+        CompletableFuture<T> future = futureRef.get();\n+        addListener(fetch.get(), (value, error) -> {\n+          if (error != null) {\n+            LOG.debug(\"Failed to fetch {} from registry\", type, error);\n+            futureRef.getAndSet(null).completeExceptionally(error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzMTcxNw=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 301}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDc5NTk4OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ZKConnectionRegistry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxNzoxOTowM1rOGzw-UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxNzoxOTowM1rOGzw-UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzMjk0NQ==", "bodyText": "nit: Since we have multiple Interface in MasterProtos, would you prefer providing ClientMetaService.Interface for better readability? i.e AtomicReference<ClientMetaService.Interface> and AtomicReference<CompletableFuture<ClientMetaService.Interface>>\nNo strong opinion though.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456932945", "createdAt": "2020-07-19T17:19:03Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ZKConnectionRegistry.java", "diffHunk": "@@ -59,9 +74,29 @@\n \n   private final ZNodePaths znodePaths;\n \n-  ZKConnectionRegistry(Configuration conf) {\n+  private final AtomicReference<Interface> stub = new AtomicReference<>();\n+\n+  private final AtomicReference<CompletableFuture<Interface>> stubMakeFuture =\n+    new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDgyMDIxOnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxNzo0OToyN1rOGzxJ0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwODozMjo1MlrOGz_zmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNTg5MA==", "bodyText": "Similar to above methods, we can use generics here also:\n  public static <T extends ClientMetaService.Interface> CompletableFuture<List<HRegionLocation>> getAllMetaRegionLocations(\n    boolean excludeOfflinedSplitParents, CompletableFuture<T> getStubFuture,\n    AtomicReference<T> stubRef, RpcControllerFactory rpcControllerFactory, int callTimeoutMs) {\n\n&\n  public static<T extends ClientMetaService.Interface> void tryClearMasterStubCache(IOException error,\n    T currentStub, AtomicReference<T> stub) {\n\nBeing Utils class, this might suit well, thought?\nBut if you feel this is overkill, we are good without that change.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456935890", "createdAt": "2020-07-19T17:49:27Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -652,4 +626,160 @@ static void setCoprocessorError(RpcController controller, Throwable error) {\n       controller.setFailed(error.toString());\n     }\n   }\n+\n+  public static RegionLocations locateRow(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    Map.Entry<byte[], RegionLocations> entry = cache.floorEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    byte[] endKey = loc.getRegion().getEndKey();\n+    if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.CURRENT, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static RegionLocations locateRowBefore(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    boolean isEmptyStopRow = isEmptyStopRow(row);\n+    Map.Entry<byte[], RegionLocations> entry =\n+      isEmptyStopRow ? cache.lastEntry() : cache.lowerEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n+      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static void tryClearMasterStubCache(IOException error,\n+    ClientMetaService.Interface currentStub, AtomicReference<ClientMetaService.Interface> stub) {\n+    if (ClientExceptionsUtil.isConnectionException(error) ||\n+      error instanceof ServerNotRunningYetException) {\n+      stub.compareAndSet(currentStub, null);\n+    }\n+  }\n+\n+  public static <T> CompletableFuture<T> getMasterStub(ConnectionRegistry registry,\n+    AtomicReference<T> stub, AtomicReference<CompletableFuture<T>> stubMakeFuture,\n+    RpcClient rpcClient, User user, long rpcTimeout, TimeUnit unit,\n+    Function<RpcChannel, T> stubMaker, String type) {\n+    return getOrFetch(stub, stubMakeFuture, () -> {\n+      CompletableFuture<T> future = new CompletableFuture<>();\n+      addListener(registry.getActiveMaster(), (addr, error) -> {\n+        if (error != null) {\n+          future.completeExceptionally(error);\n+        } else if (addr == null) {\n+          future.completeExceptionally(new MasterNotRunningException(\n+            \"ZooKeeper available but no active master location found\"));\n+        } else {\n+          LOG.debug(\"The fetched master address is {}\", addr);\n+          try {\n+            future.complete(stubMaker.apply(\n+              rpcClient.createRpcChannel(addr, user, toIntNoOverflow(unit.toMillis(rpcTimeout)))));\n+          } catch (IOException e) {\n+            future.completeExceptionally(e);\n+          }\n+        }\n+\n+      });\n+      return future;\n+    }, type);\n+  }\n+\n+  private static <T> CompletableFuture<T> getOrFetch(AtomicReference<T> cacheRef,\n+    AtomicReference<CompletableFuture<T>> futureRef, \n+    Supplier<CompletableFuture<T>> fetch, String type) {\n+    for (;;) {\n+      T cachedValue = cacheRef.get();\n+      if (cachedValue != null) {\n+        return CompletableFuture.completedFuture(cachedValue);\n+      }\n+      LOG.trace(\"{} cache is null, try fetching from registry\", type);\n+      if (futureRef.compareAndSet(null, new CompletableFuture<>())) {\n+        LOG.debug(\"Start fetching {} from registry\", type);\n+        CompletableFuture<T> future = futureRef.get();\n+        addListener(fetch.get(), (value, error) -> {\n+          if (error != null) {\n+            LOG.debug(\"Failed to fetch {} from registry\", type, error);\n+            futureRef.getAndSet(null).completeExceptionally(error);\n+            return;\n+          }\n+          LOG.debug(\"The fetched {} is {}\", type, value);\n+          // Here we update cache before reset future, so it is possible that someone can get a\n+          // stale value. Consider this:\n+          // 1. update cacheRef\n+          // 2. someone clears the cache and relocates again\n+          // 3. the futureRef is not null so the old future is used.\n+          // 4. we clear futureRef and complete the future in it with the value being\n+          // cleared in step 2.\n+          // But we do not think it is a big deal as it rarely happens, and even if it happens, the\n+          // caller will retry again later, no correctness problems.\n+          cacheRef.set(value);\n+          futureRef.set(null);\n+          future.complete(value);\n+        });\n+        return future;\n+      } else {\n+        CompletableFuture<T> future = futureRef.get();\n+        if (future != null) {\n+          return future;\n+        }\n+      }\n+    }\n+  }\n+\n+  public static CompletableFuture<List<HRegionLocation>> getAllMetaRegionLocations(\n+    boolean excludeOfflinedSplitParents,\n+    CompletableFuture<ClientMetaService.Interface> getStubFuture,\n+    AtomicReference<ClientMetaService.Interface> stubRef,\n+    RpcControllerFactory rpcControllerFactory, int callTimeoutMs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 332}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4ODYwNQ==", "bodyText": "The class is IA.Private so I think we could do this later when we really have the requirement?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456988605", "createdAt": "2020-07-20T01:50:50Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -652,4 +626,160 @@ static void setCoprocessorError(RpcController controller, Throwable error) {\n       controller.setFailed(error.toString());\n     }\n   }\n+\n+  public static RegionLocations locateRow(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    Map.Entry<byte[], RegionLocations> entry = cache.floorEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    byte[] endKey = loc.getRegion().getEndKey();\n+    if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.CURRENT, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static RegionLocations locateRowBefore(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    boolean isEmptyStopRow = isEmptyStopRow(row);\n+    Map.Entry<byte[], RegionLocations> entry =\n+      isEmptyStopRow ? cache.lastEntry() : cache.lowerEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n+      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static void tryClearMasterStubCache(IOException error,\n+    ClientMetaService.Interface currentStub, AtomicReference<ClientMetaService.Interface> stub) {\n+    if (ClientExceptionsUtil.isConnectionException(error) ||\n+      error instanceof ServerNotRunningYetException) {\n+      stub.compareAndSet(currentStub, null);\n+    }\n+  }\n+\n+  public static <T> CompletableFuture<T> getMasterStub(ConnectionRegistry registry,\n+    AtomicReference<T> stub, AtomicReference<CompletableFuture<T>> stubMakeFuture,\n+    RpcClient rpcClient, User user, long rpcTimeout, TimeUnit unit,\n+    Function<RpcChannel, T> stubMaker, String type) {\n+    return getOrFetch(stub, stubMakeFuture, () -> {\n+      CompletableFuture<T> future = new CompletableFuture<>();\n+      addListener(registry.getActiveMaster(), (addr, error) -> {\n+        if (error != null) {\n+          future.completeExceptionally(error);\n+        } else if (addr == null) {\n+          future.completeExceptionally(new MasterNotRunningException(\n+            \"ZooKeeper available but no active master location found\"));\n+        } else {\n+          LOG.debug(\"The fetched master address is {}\", addr);\n+          try {\n+            future.complete(stubMaker.apply(\n+              rpcClient.createRpcChannel(addr, user, toIntNoOverflow(unit.toMillis(rpcTimeout)))));\n+          } catch (IOException e) {\n+            future.completeExceptionally(e);\n+          }\n+        }\n+\n+      });\n+      return future;\n+    }, type);\n+  }\n+\n+  private static <T> CompletableFuture<T> getOrFetch(AtomicReference<T> cacheRef,\n+    AtomicReference<CompletableFuture<T>> futureRef, \n+    Supplier<CompletableFuture<T>> fetch, String type) {\n+    for (;;) {\n+      T cachedValue = cacheRef.get();\n+      if (cachedValue != null) {\n+        return CompletableFuture.completedFuture(cachedValue);\n+      }\n+      LOG.trace(\"{} cache is null, try fetching from registry\", type);\n+      if (futureRef.compareAndSet(null, new CompletableFuture<>())) {\n+        LOG.debug(\"Start fetching {} from registry\", type);\n+        CompletableFuture<T> future = futureRef.get();\n+        addListener(fetch.get(), (value, error) -> {\n+          if (error != null) {\n+            LOG.debug(\"Failed to fetch {} from registry\", type, error);\n+            futureRef.getAndSet(null).completeExceptionally(error);\n+            return;\n+          }\n+          LOG.debug(\"The fetched {} is {}\", type, value);\n+          // Here we update cache before reset future, so it is possible that someone can get a\n+          // stale value. Consider this:\n+          // 1. update cacheRef\n+          // 2. someone clears the cache and relocates again\n+          // 3. the futureRef is not null so the old future is used.\n+          // 4. we clear futureRef and complete the future in it with the value being\n+          // cleared in step 2.\n+          // But we do not think it is a big deal as it rarely happens, and even if it happens, the\n+          // caller will retry again later, no correctness problems.\n+          cacheRef.set(value);\n+          futureRef.set(null);\n+          future.complete(value);\n+        });\n+        return future;\n+      } else {\n+        CompletableFuture<T> future = futureRef.get();\n+        if (future != null) {\n+          return future;\n+        }\n+      }\n+    }\n+  }\n+\n+  public static CompletableFuture<List<HRegionLocation>> getAllMetaRegionLocations(\n+    boolean excludeOfflinedSplitParents,\n+    CompletableFuture<ClientMetaService.Interface> getStubFuture,\n+    AtomicReference<ClientMetaService.Interface> stubRef,\n+    RpcControllerFactory rpcControllerFactory, int callTimeoutMs) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNTg5MA=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 332}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE3NTk2MA==", "bodyText": "Sure, that is fine.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457175960", "createdAt": "2020-07-20T08:32:52Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -652,4 +626,160 @@ static void setCoprocessorError(RpcController controller, Throwable error) {\n       controller.setFailed(error.toString());\n     }\n   }\n+\n+  public static RegionLocations locateRow(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    Map.Entry<byte[], RegionLocations> entry = cache.floorEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    byte[] endKey = loc.getRegion().getEndKey();\n+    if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.CURRENT, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static RegionLocations locateRowBefore(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    boolean isEmptyStopRow = isEmptyStopRow(row);\n+    Map.Entry<byte[], RegionLocations> entry =\n+      isEmptyStopRow ? cache.lastEntry() : cache.lowerEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n+      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static void tryClearMasterStubCache(IOException error,\n+    ClientMetaService.Interface currentStub, AtomicReference<ClientMetaService.Interface> stub) {\n+    if (ClientExceptionsUtil.isConnectionException(error) ||\n+      error instanceof ServerNotRunningYetException) {\n+      stub.compareAndSet(currentStub, null);\n+    }\n+  }\n+\n+  public static <T> CompletableFuture<T> getMasterStub(ConnectionRegistry registry,\n+    AtomicReference<T> stub, AtomicReference<CompletableFuture<T>> stubMakeFuture,\n+    RpcClient rpcClient, User user, long rpcTimeout, TimeUnit unit,\n+    Function<RpcChannel, T> stubMaker, String type) {\n+    return getOrFetch(stub, stubMakeFuture, () -> {\n+      CompletableFuture<T> future = new CompletableFuture<>();\n+      addListener(registry.getActiveMaster(), (addr, error) -> {\n+        if (error != null) {\n+          future.completeExceptionally(error);\n+        } else if (addr == null) {\n+          future.completeExceptionally(new MasterNotRunningException(\n+            \"ZooKeeper available but no active master location found\"));\n+        } else {\n+          LOG.debug(\"The fetched master address is {}\", addr);\n+          try {\n+            future.complete(stubMaker.apply(\n+              rpcClient.createRpcChannel(addr, user, toIntNoOverflow(unit.toMillis(rpcTimeout)))));\n+          } catch (IOException e) {\n+            future.completeExceptionally(e);\n+          }\n+        }\n+\n+      });\n+      return future;\n+    }, type);\n+  }\n+\n+  private static <T> CompletableFuture<T> getOrFetch(AtomicReference<T> cacheRef,\n+    AtomicReference<CompletableFuture<T>> futureRef, \n+    Supplier<CompletableFuture<T>> fetch, String type) {\n+    for (;;) {\n+      T cachedValue = cacheRef.get();\n+      if (cachedValue != null) {\n+        return CompletableFuture.completedFuture(cachedValue);\n+      }\n+      LOG.trace(\"{} cache is null, try fetching from registry\", type);\n+      if (futureRef.compareAndSet(null, new CompletableFuture<>())) {\n+        LOG.debug(\"Start fetching {} from registry\", type);\n+        CompletableFuture<T> future = futureRef.get();\n+        addListener(fetch.get(), (value, error) -> {\n+          if (error != null) {\n+            LOG.debug(\"Failed to fetch {} from registry\", type, error);\n+            futureRef.getAndSet(null).completeExceptionally(error);\n+            return;\n+          }\n+          LOG.debug(\"The fetched {} is {}\", type, value);\n+          // Here we update cache before reset future, so it is possible that someone can get a\n+          // stale value. Consider this:\n+          // 1. update cacheRef\n+          // 2. someone clears the cache and relocates again\n+          // 3. the futureRef is not null so the old future is used.\n+          // 4. we clear futureRef and complete the future in it with the value being\n+          // cleared in step 2.\n+          // But we do not think it is a big deal as it rarely happens, and even if it happens, the\n+          // caller will retry again later, no correctness problems.\n+          cacheRef.set(value);\n+          futureRef.set(null);\n+          future.complete(value);\n+        });\n+        return future;\n+      } else {\n+        CompletableFuture<T> future = futureRef.get();\n+        if (future != null) {\n+          return future;\n+        }\n+      }\n+    }\n+  }\n+\n+  public static CompletableFuture<List<HRegionLocation>> getAllMetaRegionLocations(\n+    boolean excludeOfflinedSplitParents,\n+    CompletableFuture<ClientMetaService.Interface> getStubFuture,\n+    AtomicReference<ClientMetaService.Interface> stubRef,\n+    RpcControllerFactory rpcControllerFactory, int callTimeoutMs) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNTg5MA=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 332}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDgzMjM2OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxODowNDo0N1rOGzxPvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTo1MzozNlrOGz5t4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNzQwNw==", "bodyText": "Since this is used for MasterService.Interface and ClientMetaService.Interface, we can call the method something generic? maybe just getStub()?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456937407", "createdAt": "2020-07-19T18:04:47Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -652,4 +626,160 @@ static void setCoprocessorError(RpcController controller, Throwable error) {\n       controller.setFailed(error.toString());\n     }\n   }\n+\n+  public static RegionLocations locateRow(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    Map.Entry<byte[], RegionLocations> entry = cache.floorEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    byte[] endKey = loc.getRegion().getEndKey();\n+    if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.CURRENT, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static RegionLocations locateRowBefore(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    boolean isEmptyStopRow = isEmptyStopRow(row);\n+    Map.Entry<byte[], RegionLocations> entry =\n+      isEmptyStopRow ? cache.lastEntry() : cache.lowerEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n+      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static void tryClearMasterStubCache(IOException error,\n+    ClientMetaService.Interface currentStub, AtomicReference<ClientMetaService.Interface> stub) {\n+    if (ClientExceptionsUtil.isConnectionException(error) ||\n+      error instanceof ServerNotRunningYetException) {\n+      stub.compareAndSet(currentStub, null);\n+    }\n+  }\n+\n+  public static <T> CompletableFuture<T> getMasterStub(ConnectionRegistry registry,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4ODgxOQ==", "bodyText": "They are both interfaces where master implements. You can see that in the implementation, we just call registry.getActiveMaster...", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456988819", "createdAt": "2020-07-20T01:51:49Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -652,4 +626,160 @@ static void setCoprocessorError(RpcController controller, Throwable error) {\n       controller.setFailed(error.toString());\n     }\n   }\n+\n+  public static RegionLocations locateRow(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    Map.Entry<byte[], RegionLocations> entry = cache.floorEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    byte[] endKey = loc.getRegion().getEndKey();\n+    if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.CURRENT, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static RegionLocations locateRowBefore(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    boolean isEmptyStopRow = isEmptyStopRow(row);\n+    Map.Entry<byte[], RegionLocations> entry =\n+      isEmptyStopRow ? cache.lastEntry() : cache.lowerEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n+      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static void tryClearMasterStubCache(IOException error,\n+    ClientMetaService.Interface currentStub, AtomicReference<ClientMetaService.Interface> stub) {\n+    if (ClientExceptionsUtil.isConnectionException(error) ||\n+      error instanceof ServerNotRunningYetException) {\n+      stub.compareAndSet(currentStub, null);\n+    }\n+  }\n+\n+  public static <T> CompletableFuture<T> getMasterStub(ConnectionRegistry registry,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNzQwNw=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA3NjE5NQ==", "bodyText": "Yes in that viewpoint, getMasterStub() makes more sense. I was just thinking about Interface that we use here.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457076195", "createdAt": "2020-07-20T05:53:36Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -652,4 +626,160 @@ static void setCoprocessorError(RpcController controller, Throwable error) {\n       controller.setFailed(error.toString());\n     }\n   }\n+\n+  public static RegionLocations locateRow(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    Map.Entry<byte[], RegionLocations> entry = cache.floorEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    byte[] endKey = loc.getRegion().getEndKey();\n+    if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.CURRENT, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static RegionLocations locateRowBefore(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    boolean isEmptyStopRow = isEmptyStopRow(row);\n+    Map.Entry<byte[], RegionLocations> entry =\n+      isEmptyStopRow ? cache.lastEntry() : cache.lowerEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n+      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static void tryClearMasterStubCache(IOException error,\n+    ClientMetaService.Interface currentStub, AtomicReference<ClientMetaService.Interface> stub) {\n+    if (ClientExceptionsUtil.isConnectionException(error) ||\n+      error instanceof ServerNotRunningYetException) {\n+      stub.compareAndSet(currentStub, null);\n+    }\n+  }\n+\n+  public static <T> CompletableFuture<T> getMasterStub(ConnectionRegistry registry,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNzQwNw=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 259}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDgzNjk3OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxODoxMDowMFrOGzxR6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxODoxMDowMFrOGzxR6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzNzk2Mg==", "bodyText": "nit: IOException is redundant", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456937962", "createdAt": "2020-07-19T18:10:00Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -2318,19 +2333,17 @@ public long createSystemTable(final TableDescriptor tableDescriptor) throws IOEx\n     return procId;\n   }\n \n-  private void startActiveMasterManager(int infoPort) throws KeeperException {\n+  private void startActiveMasterManager(int infoPort) throws KeeperException, IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDg0NzAyOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxODoyMjozMVrOGzxW4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxODoyMjozMVrOGzxW4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzOTIzMg==", "bodyText": "Yes, this seems better, hopefully with not too much of perf impact when MasterRpcServices access it.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456939232", "createdAt": "2020-07-19T18:22:31Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -376,12 +376,11 @@ public void run() {\n   // manager of assignment nodes in zookeeper\n   private AssignmentManager assignmentManager;\n \n-\n   /**\n    * Cache for the meta region replica's locations. Also tracks their changes to avoid stale\n    * cache entries.\n    */\n-  private final MetaRegionLocationCache metaRegionLocationCache;\n+  private volatile MetaLocationCache metaLocationCache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDg0OTUyOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxODoyNTo0M1rOGzxYGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxODoyNTo0M1rOGzxYGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzOTU0Nw==", "bodyText": "nit: replace with lambda?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456939547", "createdAt": "2020-07-19T18:25:43Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -634,6 +631,27 @@ protected String getUseThisHostnameInstead(Configuration conf) {\n   @Override\n   public void run() {\n     try {\n+      // we have to do this in a background thread as for a fresh new cluster, we need to become\n+      // active master first to set the cluster id so we can initialize the cluster connection.\n+      // for backup master, we need to use async cluster connection to connect to active master for\n+      // fetching the content of root table, to serve the locate meta requests from client.\n+      Threads.setDaemonThreadRunning(new Thread() {\n+\n+        @Override\n+        public void run() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDg1MDY5OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxODoyNzoxNFrOGzxYpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxODoyNzoxNFrOGzxYpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjkzOTY4NA==", "bodyText": "For else part, maybe we can have trace log?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456939684", "createdAt": "2020-07-19T18:27:14Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/HMaster.java", "diffHunk": "@@ -634,6 +631,27 @@ protected String getUseThisHostnameInstead(Configuration conf) {\n   @Override\n   public void run() {\n     try {\n+      // we have to do this in a background thread as for a fresh new cluster, we need to become\n+      // active master first to set the cluster id so we can initialize the cluster connection.\n+      // for backup master, we need to use async cluster connection to connect to active master for\n+      // fetching the content of root table, to serve the locate meta requests from client.\n+      Threads.setDaemonThreadRunning(new Thread() {\n+\n+        @Override\n+        public void run() {\n+          for (;;) {\n+            try {\n+              if (!Strings.isNullOrEmpty(ZKClusterId.readClusterIdZNode(zooKeeper))) {\n+                setupClusterConnection();\n+                break;\n+              }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDg1NzUyOnYy", "diffSide": "LEFT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxODozNjoxMVrOGzxb6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTo0ODo0MVrOGz5kJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MDUyMw==", "bodyText": "This method getMetaRegionLocations() is no longer being called from MasterRegistry.\nMasterRegistry.getMetaRegionLocations() is not in use:\n  public CompletableFuture<RegionLocations> getMetaRegionLocations()\n\nOther rpc calls i.e locateMetaRegion()  &  getAllMetaRegionLocations() are in use.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456940523", "createdAt": "2020-07-19T18:36:11Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -3276,11 +3290,16 @@ public LocateMetaRegionResponse locateMetaRegion(RpcController controller,\n     byte[] row = request.getRow().toByteArray();\n     RegionLocateType locateType = ProtobufUtil.toRegionLocateType(request.getLocateType());\n     try {\n-      master.checkServiceStarted();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5MDI4OQ==", "bodyText": "It is used by old MasterRegistry. It has already been released in 2.3.0 so we can not remove it, we need to keep compatible.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456990289", "createdAt": "2020-07-20T01:58:40Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -3276,11 +3290,16 @@ public LocateMetaRegionResponse locateMetaRegion(RpcController controller,\n     byte[] row = request.getRow().toByteArray();\n     RegionLocateType locateType = ProtobufUtil.toRegionLocateType(request.getLocateType());\n     try {\n-      master.checkServiceStarted();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MDUyMw=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA3MzcwMA==", "bodyText": "Oh yes this is for backward compatibility.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457073700", "createdAt": "2020-07-20T05:48:41Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -3276,11 +3290,16 @@ public LocateMetaRegionResponse locateMetaRegion(RpcController controller,\n     byte[] row = request.getRow().toByteArray();\n     RegionLocateType locateType = ProtobufUtil.toRegionLocateType(request.getLocateType());\n     try {\n-      master.checkServiceStarted();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MDUyMw=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDg2NTYzOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxODo0NjoyM1rOGzxfzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMzozMToxNVrOGz2ATQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MTUxNg==", "bodyText": "We are never expecting null cache for backup masters right?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456941516", "createdAt": "2020-07-19T18:46:23Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -3305,24 +3324,31 @@ public GetAllMetaRegionLocationsResponse getAllMetaRegionLocations(RpcController\n     GetAllMetaRegionLocationsRequest request) throws ServiceException {\n     boolean excludeOfflinedSplitParents = request.getExcludeOfflinedSplitParents();\n     try {\n-      master.checkServiceStarted();\n       if (master.getMasterCoprocessorHost() != null) {\n         master.getMasterCoprocessorHost().preGetAllMetaRegionLocations(excludeOfflinedSplitParents);\n       }\n-      List<RegionLocations> locs = master.getAllMetaRegionLocations(excludeOfflinedSplitParents);\n-      List<HRegionLocation> list = new ArrayList<>();\n-      GetAllMetaRegionLocationsResponse.Builder builder =\n-        GetAllMetaRegionLocationsResponse.newBuilder();\n-      if (locs != null) {\n-        for (RegionLocations ls : locs) {\n-          for (HRegionLocation loc : ls) {\n-            if (loc != null) {\n-              builder.addMetaLocations(ProtobufUtil.toRegionLocation(loc));\n-              list.add(loc);\n+      MetaLocationCache cache = master.getMetaLocationCache();\n+      List<HRegionLocation> list;\n+      if (cache != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzAxNTM3Mw==", "bodyText": "For backup masters it will not be null. Active master will set it to null to let requests go to the master local region directly.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457015373", "createdAt": "2020-07-20T03:31:15Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -3305,24 +3324,31 @@ public GetAllMetaRegionLocationsResponse getAllMetaRegionLocations(RpcController\n     GetAllMetaRegionLocationsRequest request) throws ServiceException {\n     boolean excludeOfflinedSplitParents = request.getExcludeOfflinedSplitParents();\n     try {\n-      master.checkServiceStarted();\n       if (master.getMasterCoprocessorHost() != null) {\n         master.getMasterCoprocessorHost().preGetAllMetaRegionLocations(excludeOfflinedSplitParents);\n       }\n-      List<RegionLocations> locs = master.getAllMetaRegionLocations(excludeOfflinedSplitParents);\n-      List<HRegionLocation> list = new ArrayList<>();\n-      GetAllMetaRegionLocationsResponse.Builder builder =\n-        GetAllMetaRegionLocationsResponse.newBuilder();\n-      if (locs != null) {\n-        for (RegionLocations ls : locs) {\n-          for (HRegionLocation loc : ls) {\n-            if (loc != null) {\n-              builder.addMetaLocations(ProtobufUtil.toRegionLocation(loc));\n-              list.add(loc);\n+      MetaLocationCache cache = master.getMetaLocationCache();\n+      List<HRegionLocation> list;\n+      if (cache != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MTUxNg=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MDg2NzAyOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xOVQxODo0ODo0NlrOGzxgfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMzozMjozMlrOGz2CEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MTY5NA==", "bodyText": "nit: holder = new CacheHolder(locs)", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456941694", "createdAt": "2020-07-19T18:48:46Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));\n+    }\n+  }\n+\n+  private volatile CacheHolder holder;\n+\n+  private volatile boolean stopped = false;\n+\n+  MetaLocationCache(MasterServices master) {\n+    int syncIntervalSeconds =\n+      master.getConfiguration().getInt(SYNC_INTERVAL_SECONDS, DEFAULT_SYNC_INTERVAL_SECONDS);\n+    int fetchTimeoutMs =\n+      master.getConfiguration().getInt(FETCH_TIMEOUT_MS, DEFAULT_FETCH_TIMEOUT_MS);\n+    master.getChoreService().scheduleChore(new ScheduledChore(\n+      getClass().getSimpleName() + \"-Sync-Chore\", this, syncIntervalSeconds, 0, TimeUnit.SECONDS) {\n+\n+      @Override\n+      protected void chore() {\n+        AsyncClusterConnection conn = master.getAsyncClusterConnection();\n+        if (conn != null) {\n+          addListener(conn.getAllMetaRegionLocations(fetchTimeoutMs), (locs, error) -> {\n+            if (error != null) {\n+              LOG.warn(\"Failed to fetch all meta region locations from active master\", error);\n+              return;\n+            }\n+            CacheHolder ch = new CacheHolder(locs);\n+            holder = ch;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTY4NQ==", "bodyText": "I believe thats for thread-safety of holder", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456981685", "createdAt": "2020-07-20T01:10:50Z", "author": {"login": "bharathv"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));\n+    }\n+  }\n+\n+  private volatile CacheHolder holder;\n+\n+  private volatile boolean stopped = false;\n+\n+  MetaLocationCache(MasterServices master) {\n+    int syncIntervalSeconds =\n+      master.getConfiguration().getInt(SYNC_INTERVAL_SECONDS, DEFAULT_SYNC_INTERVAL_SECONDS);\n+    int fetchTimeoutMs =\n+      master.getConfiguration().getInt(FETCH_TIMEOUT_MS, DEFAULT_FETCH_TIMEOUT_MS);\n+    master.getChoreService().scheduleChore(new ScheduledChore(\n+      getClass().getSimpleName() + \"-Sync-Chore\", this, syncIntervalSeconds, 0, TimeUnit.SECONDS) {\n+\n+      @Override\n+      protected void chore() {\n+        AsyncClusterConnection conn = master.getAsyncClusterConnection();\n+        if (conn != null) {\n+          addListener(conn.getAllMetaRegionLocations(fetchTimeoutMs), (locs, error) -> {\n+            if (error != null) {\n+              LOG.warn(\"Failed to fetch all meta region locations from active master\", error);\n+              return;\n+            }\n+            CacheHolder ch = new CacheHolder(locs);\n+            holder = ch;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MTY5NA=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzAxNTgyNw==", "bodyText": "A simple assign maybe OK. Let me check the logic here. Maybe at the first place the initialization code is not a simple 'new CacheHolder' so I declared a local var for it...", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457015827", "createdAt": "2020-07-20T03:32:32Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));\n+    }\n+  }\n+\n+  private volatile CacheHolder holder;\n+\n+  private volatile boolean stopped = false;\n+\n+  MetaLocationCache(MasterServices master) {\n+    int syncIntervalSeconds =\n+      master.getConfiguration().getInt(SYNC_INTERVAL_SECONDS, DEFAULT_SYNC_INTERVAL_SECONDS);\n+    int fetchTimeoutMs =\n+      master.getConfiguration().getInt(FETCH_TIMEOUT_MS, DEFAULT_FETCH_TIMEOUT_MS);\n+    master.getChoreService().scheduleChore(new ScheduledChore(\n+      getClass().getSimpleName() + \"-Sync-Chore\", this, syncIntervalSeconds, 0, TimeUnit.SECONDS) {\n+\n+      @Override\n+      protected void chore() {\n+        AsyncClusterConnection conn = master.getAsyncClusterConnection();\n+        if (conn != null) {\n+          addListener(conn.getAllMetaRegionLocations(fetchTimeoutMs), (locs, error) -> {\n+            if (error != null) {\n+              LOG.warn(\"Failed to fetch all meta region locations from active master\", error);\n+              return;\n+            }\n+            CacheHolder ch = new CacheHolder(locs);\n+            holder = ch;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk0MTY5NA=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTEyNzY2OnYy", "diffSide": "LEFT", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMetaRegionLocationCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMDoxMzowNlrOGzzecw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMDoxMzowNlrOGzzecw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3MzkzOQ==", "bodyText": "I think you can also remove MetaRegionLocationCache implementation..", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456973939", "createdAt": "2020-07-20T00:13:06Z", "author": {"login": "bharathv"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMetaRegionLocationCache.java", "diffHunk": "@@ -1,191 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.hadoop.hbase.client;\n-\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertFalse;\n-\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.List;\n-import org.apache.hadoop.conf.Configuration;\n-import org.apache.hadoop.hbase.HBaseClassTestRule;\n-import org.apache.hadoop.hbase.HBaseTestingUtility;\n-import org.apache.hadoop.hbase.HConstants;\n-import org.apache.hadoop.hbase.HRegionLocation;\n-import org.apache.hadoop.hbase.MultithreadedTestUtil;\n-import org.apache.hadoop.hbase.ServerName;\n-import org.apache.hadoop.hbase.master.HMaster;\n-import org.apache.hadoop.hbase.master.MetaRegionLocationCache;\n-import org.apache.hadoop.hbase.master.RegionState;\n-import org.apache.hadoop.hbase.testclassification.MasterTests;\n-import org.apache.hadoop.hbase.testclassification.SmallTests;\n-import org.apache.hadoop.hbase.util.JVMClusterUtil;\n-import org.apache.hadoop.hbase.zookeeper.MetaTableLocator;\n-import org.apache.hadoop.hbase.zookeeper.ZKUtil;\n-import org.apache.hadoop.hbase.zookeeper.ZKWatcher;\n-import org.apache.hadoop.hbase.zookeeper.ZNodePaths;\n-import org.junit.AfterClass;\n-import org.junit.BeforeClass;\n-import org.junit.ClassRule;\n-import org.junit.Test;\n-import org.junit.experimental.categories.Category;\n-\n-import org.apache.hbase.thirdparty.com.google.common.io.Closeables;\n-\n-@Category({ SmallTests.class, MasterTests.class })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTEzNTM4OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionRegistry.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMDoyMToyNVrOGzziSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjozODo0N1rOG1AiWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3NDkyMA==", "bodyText": "Should we consider merging the both the APIs to fetch meta locations into a single RPC call to keep this interface simple and clean? Right now it maps 1:1 to the requirements of RegionLocator API.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456974920", "createdAt": "2020-07-20T00:21:25Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionRegistry.java", "diffHunk": "@@ -18,21 +18,36 @@\n package org.apache.hadoop.hbase.client;\n \n import java.io.Closeable;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n import org.apache.hadoop.hbase.ServerName;\n import org.apache.yetus.audience.InterfaceAudience;\n \n /**\n  * Registry for meta information needed for connection setup to a HBase cluster. Implementations\n- * hold cluster information such as this cluster's id, location of hbase:meta, etc..\n- * Internal use only.\n+ * hold cluster information such as this cluster's id, location of hbase:meta, etc.. Internal use\n+ * only.\n  */\n @InterfaceAudience.Private\n interface ConnectionRegistry extends Closeable {\n \n+  /**\n+   * Get location of meta region for the given {@code row}.\n+   */\n+  CompletableFuture<RegionLocations> locateMeta(byte[] row, RegionLocateType locateType);\n+\n+  /**\n+   * Get all meta region locations, including the location of secondary regions.\n+   * @param excludeOfflinedSplitParents whether to include split parent.\n+   */\n+  CompletableFuture<List<HRegionLocation>>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5MDk0OA==", "bodyText": "I think it is fine? The locateMeta method will be called much more than getAllMetaRegionLocations, if we merge them into one method, the parameters will be more complicated.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456990948", "createdAt": "2020-07-20T02:01:48Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionRegistry.java", "diffHunk": "@@ -18,21 +18,36 @@\n package org.apache.hadoop.hbase.client;\n \n import java.io.Closeable;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n import org.apache.hadoop.hbase.ServerName;\n import org.apache.yetus.audience.InterfaceAudience;\n \n /**\n  * Registry for meta information needed for connection setup to a HBase cluster. Implementations\n- * hold cluster information such as this cluster's id, location of hbase:meta, etc..\n- * Internal use only.\n+ * hold cluster information such as this cluster's id, location of hbase:meta, etc.. Internal use\n+ * only.\n  */\n @InterfaceAudience.Private\n interface ConnectionRegistry extends Closeable {\n \n+  /**\n+   * Get location of meta region for the given {@code row}.\n+   */\n+  CompletableFuture<RegionLocations> locateMeta(byte[] row, RegionLocateType locateType);\n+\n+  /**\n+   * Get all meta region locations, including the location of secondary regions.\n+   * @param excludeOfflinedSplitParents whether to include split parent.\n+   */\n+  CompletableFuture<List<HRegionLocation>>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3NDkyMA=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE4Nzg0NA==", "bodyText": "I think it's fine to keep them separate, logically it might make sense to combine them but given that Rpc service interface also has the same separation, here we can maintain it for easy mapping. Yes it is 1:1 with RPC call, but still looks simple. Anyways, I don't have strong preference here.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457187844", "createdAt": "2020-07-20T08:48:25Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionRegistry.java", "diffHunk": "@@ -18,21 +18,36 @@\n package org.apache.hadoop.hbase.client;\n \n import java.io.Closeable;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n import org.apache.hadoop.hbase.ServerName;\n import org.apache.yetus.audience.InterfaceAudience;\n \n /**\n  * Registry for meta information needed for connection setup to a HBase cluster. Implementations\n- * hold cluster information such as this cluster's id, location of hbase:meta, etc..\n- * Internal use only.\n+ * hold cluster information such as this cluster's id, location of hbase:meta, etc.. Internal use\n+ * only.\n  */\n @InterfaceAudience.Private\n interface ConnectionRegistry extends Closeable {\n \n+  /**\n+   * Get location of meta region for the given {@code row}.\n+   */\n+  CompletableFuture<RegionLocations> locateMeta(byte[] row, RegionLocateType locateType);\n+\n+  /**\n+   * Get all meta region locations, including the location of secondary regions.\n+   * @param excludeOfflinedSplitParents whether to include split parent.\n+   */\n+  CompletableFuture<List<HRegionLocation>>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3NDkyMA=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIzNjUwNA==", "bodyText": "Yeah, noted previously that there is overlap with RegionLocator API. One bother is that RL is public. CR is not (though I think changing it after release will be troublesome..)", "url": "https://github.com/apache/hbase/pull/2095#discussion_r458236504", "createdAt": "2020-07-21T16:38:47Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionRegistry.java", "diffHunk": "@@ -18,21 +18,36 @@\n package org.apache.hadoop.hbase.client;\n \n import java.io.Closeable;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n import org.apache.hadoop.hbase.ServerName;\n import org.apache.yetus.audience.InterfaceAudience;\n \n /**\n  * Registry for meta information needed for connection setup to a HBase cluster. Implementations\n- * hold cluster information such as this cluster's id, location of hbase:meta, etc..\n- * Internal use only.\n+ * hold cluster information such as this cluster's id, location of hbase:meta, etc.. Internal use\n+ * only.\n  */\n @InterfaceAudience.Private\n interface ConnectionRegistry extends Closeable {\n \n+  /**\n+   * Get location of meta region for the given {@code row}.\n+   */\n+  CompletableFuture<RegionLocations> locateMeta(byte[] row, RegionLocateType locateType);\n+\n+  /**\n+   * Get all meta region locations, including the location of secondary regions.\n+   * @param excludeOfflinedSplitParents whether to include split parent.\n+   */\n+  CompletableFuture<List<HRegionLocation>>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3NDkyMA=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTE2MTAzOnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ZKConnectionRegistry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMDo0ODoyM1rOGzzv2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMDo0ODoyM1rOGzzv2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3ODM5NA==", "bodyText": "rpcClient.close()?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456978394", "createdAt": "2020-07-20T00:48:23Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ZKConnectionRegistry.java", "diffHunk": "@@ -229,6 +264,45 @@ private void getMetaRegionLocation(CompletableFuture<RegionLocations> future,\n       });\n   }\n \n+  private CompletableFuture<Interface> getStub() {\n+    return ConnectionUtils.getMasterStub(this, stub, stubMakeFuture, rpcClient, user,\n+      readRpcTimeoutNs, TimeUnit.NANOSECONDS, ClientMetaService::newStub, \"ClientMetaService\");\n+  }\n+\n+  @Override\n+  public CompletableFuture<RegionLocations> locateMeta(byte[] row, RegionLocateType locateType) {\n+    CompletableFuture<RegionLocations> future = new CompletableFuture<>();\n+    addListener(getStub(), (stub, error) -> {\n+      if (error != null) {\n+        future.completeExceptionally(error);\n+        return;\n+      }\n+      HBaseRpcController controller = rpcControllerFactory.newController();\n+      stub.locateMetaRegion(controller,\n+        LocateMetaRegionRequest.newBuilder().setRow(ByteString.copyFrom(row))\n+          .setLocateType(ProtobufUtil.toProtoRegionLocateType(locateType)).build(),\n+        resp -> {\n+          if (controller.failed()) {\n+            IOException ex = controller.getFailed();\n+            ConnectionUtils.tryClearMasterStubCache(ex, stub, ZKConnectionRegistry.this.stub);\n+            future.completeExceptionally(ex);\n+            return;\n+          }\n+          RegionLocations locs = new RegionLocations(resp.getMetaLocationsList().stream()\n+            .map(ProtobufUtil::toRegionLocation).collect(Collectors.toList()));\n+          future.complete(locs);\n+        });\n+    });\n+    return future;\n+  }\n+\n+  @Override\n+  public CompletableFuture<List<HRegionLocation>>\n+    getAllMetaRegionLocations(boolean excludeOfflinedSplitParents) {\n+    return ConnectionUtils.getAllMetaRegionLocations(excludeOfflinedSplitParents, getStub(), stub,\n+      rpcControllerFactory, -1);\n+  }\n+\n   @Override\n   public void close() {\n     zk.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTE2MzcxOnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ZKConnectionRegistry.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMDo1MDo0OFrOGzzxRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMDo1MDo0OFrOGzzxRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3ODc1OA==", "bodyText": "nit: call it cachedStub or something?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456978758", "createdAt": "2020-07-20T00:50:48Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ZKConnectionRegistry.java", "diffHunk": "@@ -59,9 +74,29 @@\n \n   private final ZNodePaths znodePaths;\n \n-  ZKConnectionRegistry(Configuration conf) {\n+  private final AtomicReference<Interface> stub = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTE2NjQ2OnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMDo1MzoyMlrOGzzypQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwODozMjozNFrOGz_yrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3OTEwOQ==", "bodyText": "I liked @saintstack's idea in the design doc where we can ask active master for the list of available masters and load balance the RPCs. I think that can be used both here (to randomize the master we are talking to) and in master registry to always maintain a fresh list of masters and only use the initial list of masters a seed input.\n(I can quickly add that feature if everyone is okay with it).", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456979109", "createdAt": "2020-07-20T00:53:22Z", "author": {"login": "bharathv"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -652,4 +626,160 @@ static void setCoprocessorError(RpcController controller, Throwable error) {\n       controller.setFailed(error.toString());\n     }\n   }\n+\n+  public static RegionLocations locateRow(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    Map.Entry<byte[], RegionLocations> entry = cache.floorEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    byte[] endKey = loc.getRegion().getEndKey();\n+    if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.CURRENT, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static RegionLocations locateRowBefore(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    boolean isEmptyStopRow = isEmptyStopRow(row);\n+    Map.Entry<byte[], RegionLocations> entry =\n+      isEmptyStopRow ? cache.lastEntry() : cache.lowerEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n+      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static void tryClearMasterStubCache(IOException error,\n+    ClientMetaService.Interface currentStub, AtomicReference<ClientMetaService.Interface> stub) {\n+    if (ClientExceptionsUtil.isConnectionException(error) ||\n+      error instanceof ServerNotRunningYetException) {\n+      stub.compareAndSet(currentStub, null);\n+    }\n+  }\n+\n+  public static <T> CompletableFuture<T> getMasterStub(ConnectionRegistry registry,\n+    AtomicReference<T> stub, AtomicReference<CompletableFuture<T>> stubMakeFuture,\n+    RpcClient rpcClient, User user, long rpcTimeout, TimeUnit unit,\n+    Function<RpcChannel, T> stubMaker, String type) {\n+    return getOrFetch(stub, stubMakeFuture, () -> {\n+      CompletableFuture<T> future = new CompletableFuture<>();\n+      addListener(registry.getActiveMaster(), (addr, error) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5NDMxNA==", "bodyText": "+1. Can file another issue for it.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456994314", "createdAt": "2020-07-20T02:18:39Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -652,4 +626,160 @@ static void setCoprocessorError(RpcController controller, Throwable error) {\n       controller.setFailed(error.toString());\n     }\n   }\n+\n+  public static RegionLocations locateRow(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    Map.Entry<byte[], RegionLocations> entry = cache.floorEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    byte[] endKey = loc.getRegion().getEndKey();\n+    if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.CURRENT, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static RegionLocations locateRowBefore(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    boolean isEmptyStopRow = isEmptyStopRow(row);\n+    Map.Entry<byte[], RegionLocations> entry =\n+      isEmptyStopRow ? cache.lastEntry() : cache.lowerEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n+      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static void tryClearMasterStubCache(IOException error,\n+    ClientMetaService.Interface currentStub, AtomicReference<ClientMetaService.Interface> stub) {\n+    if (ClientExceptionsUtil.isConnectionException(error) ||\n+      error instanceof ServerNotRunningYetException) {\n+      stub.compareAndSet(currentStub, null);\n+    }\n+  }\n+\n+  public static <T> CompletableFuture<T> getMasterStub(ConnectionRegistry registry,\n+    AtomicReference<T> stub, AtomicReference<CompletableFuture<T>> stubMakeFuture,\n+    RpcClient rpcClient, User user, long rpcTimeout, TimeUnit unit,\n+    Function<RpcChannel, T> stubMaker, String type) {\n+    return getOrFetch(stub, stubMakeFuture, () -> {\n+      CompletableFuture<T> future = new CompletableFuture<>();\n+      addListener(registry.getActiveMaster(), (addr, error) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3OTEwOQ=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE3NTcyNw==", "bodyText": "+1", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457175727", "createdAt": "2020-07-20T08:32:34Z", "author": {"login": "virajjasani"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionUtils.java", "diffHunk": "@@ -652,4 +626,160 @@ static void setCoprocessorError(RpcController controller, Throwable error) {\n       controller.setFailed(error.toString());\n     }\n   }\n+\n+  public static RegionLocations locateRow(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    Map.Entry<byte[], RegionLocations> entry = cache.floorEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    byte[] endKey = loc.getRegion().getEndKey();\n+    if (isEmptyStopRow(endKey) || Bytes.compareTo(row, endKey) < 0) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.CURRENT, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static RegionLocations locateRowBefore(NavigableMap<byte[], RegionLocations> cache,\n+    TableName tableName, byte[] row, int replicaId) {\n+    boolean isEmptyStopRow = isEmptyStopRow(row);\n+    Map.Entry<byte[], RegionLocations> entry =\n+      isEmptyStopRow ? cache.lastEntry() : cache.lowerEntry(row);\n+    if (entry == null) {\n+      return null;\n+    }\n+    RegionLocations locs = entry.getValue();\n+    HRegionLocation loc = locs.getRegionLocation(replicaId);\n+    if (loc == null) {\n+      return null;\n+    }\n+    if (isEmptyStopRow(loc.getRegion().getEndKey()) ||\n+      (!isEmptyStopRow && Bytes.compareTo(loc.getRegion().getEndKey(), row) >= 0)) {\n+      if (LOG.isTraceEnabled()) {\n+        LOG.trace(\"Found {} in cache for {}, row='{}', locateType={}, replicaId={}\", loc, tableName,\n+          Bytes.toStringBinary(row), RegionLocateType.BEFORE, replicaId);\n+      }\n+      return locs;\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  public static void tryClearMasterStubCache(IOException error,\n+    ClientMetaService.Interface currentStub, AtomicReference<ClientMetaService.Interface> stub) {\n+    if (ClientExceptionsUtil.isConnectionException(error) ||\n+      error instanceof ServerNotRunningYetException) {\n+      stub.compareAndSet(currentStub, null);\n+    }\n+  }\n+\n+  public static <T> CompletableFuture<T> getMasterStub(ConnectionRegistry registry,\n+    AtomicReference<T> stub, AtomicReference<CompletableFuture<T>> stubMakeFuture,\n+    RpcClient rpcClient, User user, long rpcTimeout, TimeUnit unit,\n+    Function<RpcChannel, T> stubMaker, String type) {\n+    return getOrFetch(stub, stubMakeFuture, () -> {\n+      CompletableFuture<T> future = new CompletableFuture<>();\n+      addListener(registry.getActiveMaster(), (addr, error) -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk3OTEwOQ=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 265}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTE4MDkxOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "isResolved": false, "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMTowNjozNlrOGzz6KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMDozMjowOVrOG1Of_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTAzMw==", "bodyText": "Why do we need the else part? It looks like the cache runs on all masters ?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456981033", "createdAt": "2020-07-20T01:06:36Z", "author": {"login": "bharathv"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2928,13 +2928,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n \n   @Override\n   public GetMetaRegionLocationsResponse getMetaRegionLocations(RpcController rpcController,\n-      GetMetaRegionLocationsRequest request) throws ServiceException {\n-    GetMetaRegionLocationsResponse.Builder response = GetMetaRegionLocationsResponse.newBuilder();\n-    Optional<List<HRegionLocation>> metaLocations =\n-        master.getMetaRegionLocationCache().getMetaRegionLocations();\n-    metaLocations.ifPresent(hRegionLocations -> hRegionLocations.forEach(\n-      location -> response.addMetaLocations(ProtobufUtil.toRegionLocation(location))));\n-    return response.build();\n+    GetMetaRegionLocationsRequest request) throws ServiceException {\n+    MetaLocationCache cache = master.getMetaLocationCache();\n+    RegionLocations locs;\n+    try {\n+      if (cache != null) {\n+        locs = cache.locateMeta(HConstants.EMPTY_BYTE_ARRAY, RegionLocateType.CURRENT);\n+      } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk5NDc4MA==", "bodyText": "The design is when master becomes active, we will serve the requests by the local master region dreictly, so we will set cache to null after we successfully initialize the master local region. This is important as backup masters will also use the getAllMetaRegionLocations method to sync from active master.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456994780", "createdAt": "2020-07-20T02:20:38Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2928,13 +2928,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n \n   @Override\n   public GetMetaRegionLocationsResponse getMetaRegionLocations(RpcController rpcController,\n-      GetMetaRegionLocationsRequest request) throws ServiceException {\n-    GetMetaRegionLocationsResponse.Builder response = GetMetaRegionLocationsResponse.newBuilder();\n-    Optional<List<HRegionLocation>> metaLocations =\n-        master.getMetaRegionLocationCache().getMetaRegionLocations();\n-    metaLocations.ifPresent(hRegionLocations -> hRegionLocations.forEach(\n-      location -> response.addMetaLocations(ProtobufUtil.toRegionLocation(location))));\n-    return response.build();\n+    GetMetaRegionLocationsRequest request) throws ServiceException {\n+    MetaLocationCache cache = master.getMetaLocationCache();\n+    RegionLocations locs;\n+    try {\n+      if (cache != null) {\n+        locs = cache.locateMeta(HConstants.EMPTY_BYTE_ARRAY, RegionLocateType.CURRENT);\n+      } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTAzMw=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc1NzExNg==", "bodyText": "Ah got it, I missed that part in the first iteration, I think you could roll that logic into the cache to keep the lifecycle simple (since the cache already has access to the master and we can check if master.isActive()). That way all the callers only use the cache and we can avoid the logic in finishMasterInitialization logic.\nAlso as discussed in the design doc, would be nice to have an actual versioned cache that avoids round trips if nothing changes (for the future). The 1s pull seems a bit aggressive but is fine as a stop-gap I guess.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457757116", "createdAt": "2020-07-20T23:59:13Z", "author": {"login": "bharathv"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2928,13 +2928,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n \n   @Override\n   public GetMetaRegionLocationsResponse getMetaRegionLocations(RpcController rpcController,\n-      GetMetaRegionLocationsRequest request) throws ServiceException {\n-    GetMetaRegionLocationsResponse.Builder response = GetMetaRegionLocationsResponse.newBuilder();\n-    Optional<List<HRegionLocation>> metaLocations =\n-        master.getMetaRegionLocationCache().getMetaRegionLocations();\n-    metaLocations.ifPresent(hRegionLocations -> hRegionLocations.forEach(\n-      location -> response.addMetaLocations(ProtobufUtil.toRegionLocation(location))));\n-    return response.build();\n+    GetMetaRegionLocationsRequest request) throws ServiceException {\n+    MetaLocationCache cache = master.getMetaLocationCache();\n+    RegionLocations locs;\n+    try {\n+      if (cache != null) {\n+        locs = cache.locateMeta(HConstants.EMPTY_BYTE_ARRAY, RegionLocateType.CURRENT);\n+      } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTAzMw=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc4OTk0MQ==", "bodyText": "Yes, will try to do this as a follow on. Maybe need to introduce another method for doing this, as the return value should have a way tell the upper layer there is no change, and also we should not have the excludeOfflineSplitParent option for this method, otherwise the semantice will be confusing.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457789941", "createdAt": "2020-07-21T01:56:08Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2928,13 +2928,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n \n   @Override\n   public GetMetaRegionLocationsResponse getMetaRegionLocations(RpcController rpcController,\n-      GetMetaRegionLocationsRequest request) throws ServiceException {\n-    GetMetaRegionLocationsResponse.Builder response = GetMetaRegionLocationsResponse.newBuilder();\n-    Optional<List<HRegionLocation>> metaLocations =\n-        master.getMetaRegionLocationCache().getMetaRegionLocations();\n-    metaLocations.ifPresent(hRegionLocations -> hRegionLocations.forEach(\n-      location -> response.addMetaLocations(ProtobufUtil.toRegionLocation(location))));\n-    return response.build();\n+    GetMetaRegionLocationsRequest request) throws ServiceException {\n+    MetaLocationCache cache = master.getMetaLocationCache();\n+    RegionLocations locs;\n+    try {\n+      if (cache != null) {\n+        locs = cache.locateMeta(HConstants.EMPTY_BYTE_ARRAY, RegionLocateType.CURRENT);\n+      } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTAzMw=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5Mjc3OQ==", "bodyText": "And on the cache stuff, at least we need to stop the chore after switching to active master? And for active master, we will not get from cache any more, still using the cache will be a bit confusing.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457792779", "createdAt": "2020-07-21T02:06:36Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2928,13 +2928,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n \n   @Override\n   public GetMetaRegionLocationsResponse getMetaRegionLocations(RpcController rpcController,\n-      GetMetaRegionLocationsRequest request) throws ServiceException {\n-    GetMetaRegionLocationsResponse.Builder response = GetMetaRegionLocationsResponse.newBuilder();\n-    Optional<List<HRegionLocation>> metaLocations =\n-        master.getMetaRegionLocationCache().getMetaRegionLocations();\n-    metaLocations.ifPresent(hRegionLocations -> hRegionLocations.forEach(\n-      location -> response.addMetaLocations(ProtobufUtil.toRegionLocation(location))));\n-    return response.build();\n+    GetMetaRegionLocationsRequest request) throws ServiceException {\n+    MetaLocationCache cache = master.getMetaLocationCache();\n+    RegionLocations locs;\n+    try {\n+      if (cache != null) {\n+        locs = cache.locateMeta(HConstants.EMPTY_BYTE_ARRAY, RegionLocateType.CURRENT);\n+      } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTAzMw=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4NzczMg==", "bodyText": "Serving from NavigableMap should be faster than fetch from local Region? For this reason would we want to do like @bharathv  suggests (can be follow-on)", "url": "https://github.com/apache/hbase/pull/2095#discussion_r458287732", "createdAt": "2020-07-21T18:01:07Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2928,13 +2928,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n \n   @Override\n   public GetMetaRegionLocationsResponse getMetaRegionLocations(RpcController rpcController,\n-      GetMetaRegionLocationsRequest request) throws ServiceException {\n-    GetMetaRegionLocationsResponse.Builder response = GetMetaRegionLocationsResponse.newBuilder();\n-    Optional<List<HRegionLocation>> metaLocations =\n-        master.getMetaRegionLocationCache().getMetaRegionLocations();\n-    metaLocations.ifPresent(hRegionLocations -> hRegionLocations.forEach(\n-      location -> response.addMetaLocations(ProtobufUtil.toRegionLocation(location))));\n-    return response.build();\n+    GetMetaRegionLocationsRequest request) throws ServiceException {\n+    MetaLocationCache cache = master.getMetaLocationCache();\n+    RegionLocations locs;\n+    try {\n+      if (cache != null) {\n+        locs = cache.locateMeta(HConstants.EMPTY_BYTE_ARRAY, RegionLocateType.CURRENT);\n+      } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTAzMw=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1NzkzNg==", "bodyText": "What @bharathv mean is we can reuse the cache interface to simpilify the code, not for performance. After switching to active master we should serve the requests with local region, as we do not want to keep a cache at active master which could be stale?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r458457936", "createdAt": "2020-07-22T00:05:41Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2928,13 +2928,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n \n   @Override\n   public GetMetaRegionLocationsResponse getMetaRegionLocations(RpcController rpcController,\n-      GetMetaRegionLocationsRequest request) throws ServiceException {\n-    GetMetaRegionLocationsResponse.Builder response = GetMetaRegionLocationsResponse.newBuilder();\n-    Optional<List<HRegionLocation>> metaLocations =\n-        master.getMetaRegionLocationCache().getMetaRegionLocations();\n-    metaLocations.ifPresent(hRegionLocations -> hRegionLocations.forEach(\n-      location -> response.addMetaLocations(ProtobufUtil.toRegionLocation(location))));\n-    return response.build();\n+    GetMetaRegionLocationsRequest request) throws ServiceException {\n+    MetaLocationCache cache = master.getMetaLocationCache();\n+    RegionLocations locs;\n+    try {\n+      if (cache != null) {\n+        locs = cache.locateMeta(HConstants.EMPTY_BYTE_ARRAY, RegionLocateType.CURRENT);\n+      } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTAzMw=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2MTg0NQ==", "bodyText": "I was talking performance. Why would a cache on active Region be stale? Why would it not be updated on write the Region?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r458461845", "createdAt": "2020-07-22T00:19:35Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2928,13 +2928,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n \n   @Override\n   public GetMetaRegionLocationsResponse getMetaRegionLocations(RpcController rpcController,\n-      GetMetaRegionLocationsRequest request) throws ServiceException {\n-    GetMetaRegionLocationsResponse.Builder response = GetMetaRegionLocationsResponse.newBuilder();\n-    Optional<List<HRegionLocation>> metaLocations =\n-        master.getMetaRegionLocationCache().getMetaRegionLocations();\n-    metaLocations.ifPresent(hRegionLocations -> hRegionLocations.forEach(\n-      location -> response.addMetaLocations(ProtobufUtil.toRegionLocation(location))));\n-    return response.build();\n+    GetMetaRegionLocationsRequest request) throws ServiceException {\n+    MetaLocationCache cache = master.getMetaLocationCache();\n+    RegionLocations locs;\n+    try {\n+      if (cache != null) {\n+        locs = cache.locateMeta(HConstants.EMPTY_BYTE_ARRAY, RegionLocateType.CURRENT);\n+      } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTAzMw=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2NTI3Nw==", "bodyText": "Now the cache is running as a side logic besides the core. Making it always sync with the local region will mess up the code when updating local region, especially that the local region is not for storing root. Since we could also set the family to in memory, I do not think the performance will be much better so I do not think it is worth to also introduce a cache for active master. No big gain but the code will be much complicated.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r458465277", "createdAt": "2020-07-22T00:32:09Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2928,13 +2928,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n \n   @Override\n   public GetMetaRegionLocationsResponse getMetaRegionLocations(RpcController rpcController,\n-      GetMetaRegionLocationsRequest request) throws ServiceException {\n-    GetMetaRegionLocationsResponse.Builder response = GetMetaRegionLocationsResponse.newBuilder();\n-    Optional<List<HRegionLocation>> metaLocations =\n-        master.getMetaRegionLocationCache().getMetaRegionLocations();\n-    metaLocations.ifPresent(hRegionLocations -> hRegionLocations.forEach(\n-      location -> response.addMetaLocations(ProtobufUtil.toRegionLocation(location))));\n-    return response.build();\n+    GetMetaRegionLocationsRequest request) throws ServiceException {\n+    MetaLocationCache cache = master.getMetaLocationCache();\n+    RegionLocations locs;\n+    try {\n+      if (cache != null) {\n+        locs = cache.locateMeta(HConstants.EMPTY_BYTE_ARRAY, RegionLocateType.CURRENT);\n+      } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTAzMw=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTE4NjQ3OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMToxMTo0NVrOGzz9RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMToxMTo0NVrOGzz9RQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MTgyOQ==", "bodyText": "nit: conn reference can be cached once", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456981829", "createdAt": "2020-07-20T01:11:45Z", "author": {"login": "bharathv"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));\n+    }\n+  }\n+\n+  private volatile CacheHolder holder;\n+\n+  private volatile boolean stopped = false;\n+\n+  MetaLocationCache(MasterServices master) {\n+    int syncIntervalSeconds =\n+      master.getConfiguration().getInt(SYNC_INTERVAL_SECONDS, DEFAULT_SYNC_INTERVAL_SECONDS);\n+    int fetchTimeoutMs =\n+      master.getConfiguration().getInt(FETCH_TIMEOUT_MS, DEFAULT_FETCH_TIMEOUT_MS);\n+    master.getChoreService().scheduleChore(new ScheduledChore(\n+      getClass().getSimpleName() + \"-Sync-Chore\", this, syncIntervalSeconds, 0, TimeUnit.SECONDS) {\n+\n+      @Override\n+      protected void chore() {\n+        AsyncClusterConnection conn = master.getAsyncClusterConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1MTE4ODU0OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwMToxMzo1OVrOGzz-jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQwNTo0NjoxNVrOGz5fVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MjE1OQ==", "bodyText": "We need any tests to test sync / timeout etc of this cache?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r456982159", "createdAt": "2020-07-20T01:13:59Z", "author": {"login": "bharathv"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzA3MjQ2OA==", "bodyText": "Will do.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457072468", "createdAt": "2020-07-20T05:46:15Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njk4MjE1OQ=="}, "originalCommit": {"oid": "7099bdd8a6344d2c0d9a6f9013b08108257096ca"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDEzMjcxOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMzo0OTowM1rOG0NjTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxMzo0OTowM1rOG0NjTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQwMTE2NA==", "bodyText": "nit: final ?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457401164", "createdAt": "2020-07-20T13:49:03Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfoBuilder;\n+import org.apache.hadoop.hbase.testclassification.MasterTests;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.apache.hadoop.hbase.util.FutureUtils;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category({ MasterTests.class, MediumTests.class })\n+public class TestMetaLocationCache {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule CLASS_RULE =\n+    HBaseClassTestRule.forClass(TestMetaFixerNoCluster.class);\n+\n+  private static Configuration CONF = HBaseConfiguration.create();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e3f6b8ca1231e9d702da607d9775a3e58bea033"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDMwMzk4OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNDoxNjo0MFrOG0PHRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNDoxNjo0MFrOG0PHRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQyNjc1Nw==", "bodyText": "typo: TestMetaLocationCache", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457426757", "createdAt": "2020-07-20T14:16:40Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionInfoBuilder;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.testclassification.MasterTests;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.FutureUtils;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category({ MasterTests.class, MediumTests.class })\n+public class TestMetaLocationCache {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule CLASS_RULE =\n+    HBaseClassTestRule.forClass(TestMetaFixerNoCluster.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c7fd65482301a1bc6c4890b74633d18a365b9b2"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDMzMDIzOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNDoyMTowNlrOG0PWrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNDoyMDo0OVrOG0njCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQzMDcwMA==", "bodyText": "Since we are dealing with Mocks only, this can be SmallTests?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457430700", "createdAt": "2020-07-20T14:21:06Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionInfoBuilder;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.testclassification.MasterTests;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.FutureUtils;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category({ MasterTests.class, MediumTests.class })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5MDU2Nw==", "bodyText": "Not sure, we have sleep in the tests.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457790567", "createdAt": "2020-07-21T01:58:16Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionInfoBuilder;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.testclassification.MasterTests;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.FutureUtils;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category({ MasterTests.class, MediumTests.class })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQzMDcwMA=="}, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNzA4Mg==", "bodyText": "Sure, MediumTests is fine since we have sleep.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457827082", "createdAt": "2020-07-21T04:20:49Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionInfoBuilder;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.testclassification.MasterTests;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.FutureUtils;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category({ MasterTests.class, MediumTests.class })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQzMDcwMA=="}, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDM0NTYzOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNDoyMzoxN1rOG0PfOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNDoyMzoxN1rOG0PfOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQzMjg5MQ==", "bodyText": "nit: we can assign value right here and keep this static final", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457432891", "createdAt": "2020-07-20T14:23:17Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionInfoBuilder;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.testclassification.MasterTests;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.FutureUtils;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category({ MasterTests.class, MediumTests.class })\n+public class TestMetaLocationCache {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule CLASS_RULE =\n+    HBaseClassTestRule.forClass(TestMetaLocationCache.class);\n+\n+  private static Configuration CONF = HBaseConfiguration.create();\n+\n+  private static ChoreService CHORE_SERVICE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDM0NzIzOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNDoyMzozMlrOG0PgJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNDoyMzozMlrOG0PgJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQzMzEyNw==", "bodyText": "nit: final", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457433127", "createdAt": "2020-07-20T14:23:32Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/master/TestMetaLocationCache.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ChoreService;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseConfiguration;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionInfoBuilder;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.testclassification.MasterTests;\n+import org.apache.hadoop.hbase.testclassification.MediumTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.util.FutureUtils;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+\n+@Category({ MasterTests.class, MediumTests.class })\n+public class TestMetaLocationCache {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule CLASS_RULE =\n+    HBaseClassTestRule.forClass(TestMetaLocationCache.class);\n+\n+  private static Configuration CONF = HBaseConfiguration.create();\n+\n+  private static ChoreService CHORE_SERVICE;\n+\n+  private static byte[] SPLIT = Bytes.toBytes(\"a\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NDQ1MTQ3OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMFQxNDozOTo0NlrOG0Qdaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwNDoyMzozOVrOG0nl4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ0ODgxMQ==", "bodyText": "LOG.error might fit well? Also, what if this chore keeps getting error multiple times? That could mean due to some issue with RPC call, backup masters will serve stale data? Should we rather make this a high priority issue and stop backup masters if we get error say 30-60 times in a consecutive manner?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457448811", "createdAt": "2020-07-20T14:39:46Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));\n+    }\n+  }\n+\n+  private volatile CacheHolder holder;\n+\n+  private volatile boolean stopped = false;\n+\n+  MetaLocationCache(MasterServices master) {\n+    int syncIntervalSeconds =\n+      master.getConfiguration().getInt(SYNC_INTERVAL_SECONDS, DEFAULT_SYNC_INTERVAL_SECONDS);\n+    int fetchTimeoutMs =\n+      master.getConfiguration().getInt(FETCH_TIMEOUT_MS, DEFAULT_FETCH_TIMEOUT_MS);\n+    master.getChoreService().scheduleChore(new ScheduledChore(\n+      getClass().getSimpleName() + \"-Sync-Chore\", this, syncIntervalSeconds, 0, TimeUnit.SECONDS) {\n+\n+      @Override\n+      protected void chore() {\n+        AsyncClusterConnection conn = master.getAsyncClusterConnection();\n+        if (conn != null) {\n+          addListener(conn.getAllMetaRegionLocations(fetchTimeoutMs), (locs, error) -> {\n+            if (error != null) {\n+              LOG.warn(\"Failed to fetch all meta region locations from active master\", error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5MDQzMQ==", "bodyText": "Can be a follow on I think. Agree that if active master is down for a long time, we should avoid flooding the log file.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457790431", "createdAt": "2020-07-21T01:57:47Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));\n+    }\n+  }\n+\n+  private volatile CacheHolder holder;\n+\n+  private volatile boolean stopped = false;\n+\n+  MetaLocationCache(MasterServices master) {\n+    int syncIntervalSeconds =\n+      master.getConfiguration().getInt(SYNC_INTERVAL_SECONDS, DEFAULT_SYNC_INTERVAL_SECONDS);\n+    int fetchTimeoutMs =\n+      master.getConfiguration().getInt(FETCH_TIMEOUT_MS, DEFAULT_FETCH_TIMEOUT_MS);\n+    master.getChoreService().scheduleChore(new ScheduledChore(\n+      getClass().getSimpleName() + \"-Sync-Chore\", this, syncIntervalSeconds, 0, TimeUnit.SECONDS) {\n+\n+      @Override\n+      protected void chore() {\n+        AsyncClusterConnection conn = master.getAsyncClusterConnection();\n+        if (conn != null) {\n+          addListener(conn.getAllMetaRegionLocations(fetchTimeoutMs), (locs, error) -> {\n+            if (error != null) {\n+              LOG.warn(\"Failed to fetch all meta region locations from active master\", error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ0ODgxMQ=="}, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyNzgxMQ==", "bodyText": "Sure, we can take it up on follow-up Jira.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r457827811", "createdAt": "2020-07-21T04:23:39Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));\n+    }\n+  }\n+\n+  private volatile CacheHolder holder;\n+\n+  private volatile boolean stopped = false;\n+\n+  MetaLocationCache(MasterServices master) {\n+    int syncIntervalSeconds =\n+      master.getConfiguration().getInt(SYNC_INTERVAL_SECONDS, DEFAULT_SYNC_INTERVAL_SECONDS);\n+    int fetchTimeoutMs =\n+      master.getConfiguration().getInt(FETCH_TIMEOUT_MS, DEFAULT_FETCH_TIMEOUT_MS);\n+    master.getChoreService().scheduleChore(new ScheduledChore(\n+      getClass().getSimpleName() + \"-Sync-Chore\", this, syncIntervalSeconds, 0, TimeUnit.SECONDS) {\n+\n+      @Override\n+      protected void chore() {\n+        AsyncClusterConnection conn = master.getAsyncClusterConnection();\n+        if (conn != null) {\n+          addListener(conn.getAllMetaRegionLocations(fetchTimeoutMs), (locs, error) -> {\n+            if (error != null) {\n+              LOG.warn(\"Failed to fetch all meta region locations from active master\", error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzQ0ODgxMQ=="}, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTQ5MDMwOnYy", "diffSide": "RIGHT", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionRegistry.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNjoyNzo0NFrOG1AGxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMDozNToxNVrOG1OjVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyOTQ0Nw==", "bodyText": "Seems arbitrary that we do ROOT location in here but location for hbase:meta is elsewhere and if they want to do 'caching'/'replicas', they'd use a different system.\nOr is idea that this cache of location be generalized? Or for ROOT only?\nImplementations could get RS stubs I suppose so don't have to go to Master to get meta Locations?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r458229447", "createdAt": "2020-07-21T16:27:44Z", "author": {"login": "saintstack"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionRegistry.java", "diffHunk": "@@ -18,21 +18,36 @@\n package org.apache.hadoop.hbase.client;\n \n import java.io.Closeable;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n import org.apache.hadoop.hbase.ServerName;\n import org.apache.yetus.audience.InterfaceAudience;\n \n /**\n  * Registry for meta information needed for connection setup to a HBase cluster. Implementations\n- * hold cluster information such as this cluster's id, location of hbase:meta, etc..\n- * Internal use only.\n+ * hold cluster information such as this cluster's id, location of hbase:meta, etc.. Internal use\n+ * only.\n  */\n @InterfaceAudience.Private\n interface ConnectionRegistry extends Closeable {\n \n+  /**\n+   * Get location of meta region for the given {@code row}.\n+   */\n+  CompletableFuture<RegionLocations> locateMeta(byte[] row, RegionLocateType locateType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2NjEzNA==", "bodyText": "I do not think it is arbitrary. Before we have root table, meta location is here and user locations are elsewhere. The point here, is that, what things in HBase are called 'bootstraping' things. In the past it is meta, and now, it is root.\nAnd see my plan below, my plan is to store the bootstraping things on the HA masters, so do not want to envolve RS in, let's keep them within masters.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r458466134", "createdAt": "2020-07-22T00:35:15Z", "author": {"login": "Apache9"}, "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ConnectionRegistry.java", "diffHunk": "@@ -18,21 +18,36 @@\n package org.apache.hadoop.hbase.client;\n \n import java.io.Closeable;\n+import java.util.List;\n import java.util.concurrent.CompletableFuture;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n import org.apache.hadoop.hbase.ServerName;\n import org.apache.yetus.audience.InterfaceAudience;\n \n /**\n  * Registry for meta information needed for connection setup to a HBase cluster. Implementations\n- * hold cluster information such as this cluster's id, location of hbase:meta, etc..\n- * Internal use only.\n+ * hold cluster information such as this cluster's id, location of hbase:meta, etc.. Internal use\n+ * only.\n  */\n @InterfaceAudience.Private\n interface ConnectionRegistry extends Closeable {\n \n+  /**\n+   * Get location of meta region for the given {@code row}.\n+   */\n+  CompletableFuture<RegionLocations> locateMeta(byte[] row, RegionLocateType locateType);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODIyOTQ0Nw=="}, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1OTg2MDU0OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxODowMzozOVrOG1DwSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMDoyODozNVrOG1OcOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4OTIyNA==", "bodyText": "Needs to be meta comparator?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r458289224", "createdAt": "2020-07-21T18:03:39Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1ODEzNw==", "bodyText": "No. We just use start keys as the map key so a bytes comparator is enough.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r458458137", "createdAt": "2020-07-22T00:06:30Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4OTIyNA=="}, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2MDkwNw==", "bodyText": "Whats the start key look like then in ROOT? Does it not have tablename as prefix with ',' separators? Don't you want \"TABLENAME,....\" to sort after \"TABLENAME,....\"?", "url": "https://github.com/apache/hbase/pull/2095#discussion_r458460907", "createdAt": "2020-07-22T00:16:19Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4OTIyNA=="}, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2NDMxMw==", "bodyText": "Oh yes, you are right. So the current implementation at client side should also be changed. When caching locations of meta or root we should use meta comparator.", "url": "https://github.com/apache/hbase/pull/2095#discussion_r458464313", "createdAt": "2020-07-22T00:28:35Z", "author": {"login": "Apache9"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MetaLocationCache.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.master;\n+\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRow;\n+import static org.apache.hadoop.hbase.client.ConnectionUtils.locateRowBefore;\n+import static org.apache.hadoop.hbase.util.FutureUtils.addListener;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.SortedSet;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import org.apache.hadoop.hbase.HRegionLocation;\n+import org.apache.hadoop.hbase.RegionLocations;\n+import org.apache.hadoop.hbase.ScheduledChore;\n+import org.apache.hadoop.hbase.Stoppable;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.client.AsyncClusterConnection;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.RegionLocateType;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.hbase.thirdparty.com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * A cache of meta region locations.\n+ */\n+@InterfaceAudience.Private\n+class MetaLocationCache implements Stoppable {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(MetaLocationCache.class);\n+\n+  @VisibleForTesting\n+  static final String SYNC_INTERVAL_SECONDS =\n+    \"hbase.master.meta-location-cache.sync-interval-seconds\";\n+\n+  // default sync every 1 second.\n+  @VisibleForTesting\n+  static final int DEFAULT_SYNC_INTERVAL_SECONDS = 1;\n+\n+  private static final String FETCH_TIMEOUT_MS =\n+    \"hbase.master.meta-location-cache.fetch-timeout-ms\";\n+\n+  // default timeout 1 second\n+  private static final int DEFAULT_FETCH_TIMEOUT_MS = 1000;\n+\n+  private static final class CacheHolder {\n+\n+    final NavigableMap<byte[], RegionLocations> cache;\n+\n+    final List<HRegionLocation> all;\n+\n+    CacheHolder(List<HRegionLocation> all) {\n+      this.all = Collections.unmodifiableList(all);\n+      NavigableMap<byte[], SortedSet<HRegionLocation>> startKeyToLocs =\n+        new TreeMap<>(Bytes.BYTES_COMPARATOR);\n+      for (HRegionLocation loc : all) {\n+        if (loc.getRegion().isSplitParent()) {\n+          continue;\n+        }\n+        startKeyToLocs.computeIfAbsent(loc.getRegion().getStartKey(),\n+          k -> new TreeSet<>((l1, l2) -> l1.getRegion().compareTo(l2.getRegion()))).add(loc);\n+      }\n+      this.cache = startKeyToLocs.entrySet().stream().collect(Collectors.collectingAndThen(\n+        Collectors.toMap(Map.Entry::getKey, e -> new RegionLocations(e.getValue()), (u, v) -> {\n+          throw new IllegalStateException();\n+        }, () -> new TreeMap<>(Bytes.BYTES_COMPARATOR)), Collections::unmodifiableNavigableMap));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI4OTIyNA=="}, "originalCommit": {"oid": "4e0cd933d7c2b619b34a75bdc196d5be47fe2184"}, "originalPosition": 91}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2815, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}