{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMzMTMyMjE0", "number": 2741, "title": "HBASE-25364 Redo the getMidPoint() in HFileWriterImpl to get rid of t\u2026", "bodyText": "\u2026he double comparison process\nThere is a TODO like this \"TODO: Redo so only a single pass over the arrays rather than one to  compare and then a second composing midpoint.\" in getMidpoint()  of class \u200bHFileWriteImpl\u200b\nThe old logic compares the left byte array and the right byte array twice\uff1a\n\nA comparison is performed before composing MinimumMidpointArray\nDuring composing of MinimumMidpointArray, bytes were comparing again\n\nMy optimization  combines them into one", "createdAt": "2020-12-06T03:29:35Z", "url": "https://github.com/apache/hbase/pull/2741", "merged": true, "mergeCommit": {"oid": "3e743df6d06d3e1835963f4f4bea0f478f8c931e"}, "closed": true, "closedAt": "2021-02-10T16:31:07Z", "author": {"login": "GeorryHuang"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdjYXBRgH2gAyNTMzMTMyMjE0OjQzNjMyOWE2MGE0NzdkYjc2ZDIxYTQ1OGE4NTdkMjBkZWZlMjMxN2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdj6QGkAFqTU0NjQzMTkyOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "436329a60a477db76d21a458a857d20defe2317e", "author": {"user": {"login": "GeorryHuang", "name": null}}, "url": "https://github.com/apache/hbase/commit/436329a60a477db76d21a458a857d20defe2317e", "committedDate": "2020-12-06T03:27:27Z", "message": "HBASE-25364 Redo the getMidPoint() in HFileWriterImpl to get rid of the double comparison process"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NzA4ODI1", "url": "https://github.com/apache/hbase/pull/2741#pullrequestreview-545708825", "createdAt": "2020-12-06T14:04:46Z", "commit": {"oid": "436329a60a477db76d21a458a857d20defe2317e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQxNDowNDo0N1rOIAKqZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQxNDowNDo0N1rOIAKqZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA0NTYwNA==", "bodyText": "The logic here is different from original?", "url": "https://github.com/apache/hbase/pull/2741#discussion_r537045604", "createdAt": "2020-12-06T14:04:47Z", "author": {"login": "nyl3532016"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java", "diffHunk": "@@ -380,143 +378,146 @@ public static Cell getMidpoint(final CellComparator comparator, final Cell left,\n     if (comparator instanceof MetaCellComparator) {\n       return right;\n     }\n-    int diff = comparator.compareRows(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left row sorts after right row; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n     byte[] midRow;\n     boolean bufferBacked = left instanceof ByteBufferExtendedCell\n         && right instanceof ByteBufferExtendedCell;\n-    if (diff < 0) {\n-      // Left row is < right row.\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n-            ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(),\n-            left.getRowLength(), right.getRowArray(), right.getRowOffset(), right.getRowLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n+        ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(), left.getRowLength(),\n+        right.getRowArray(), right.getRowOffset(), right.getRowLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRow(midRow);\n     }\n-    // Rows are same. Compare on families.\n-    diff = comparator.compareFamilies(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left family sorts after right family; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n-            ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n-            left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n-            right.getFamilyLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and then a mid sort family.\n+    //Rows are same. Compare on families.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n+        ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n+        left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n+        right.getFamilyLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowFamily(right, midRow, 0, midRow.length);\n     }\n     // Families are same. Compare on qualifiers.\n-    diff = comparator.compareQualifiers(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left qualifier sorts after right qualifier; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n-            ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n-            left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n-            right.getQualifierLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and family and then a mid sort qualifier.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n+        ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n+        left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n+        right.getQualifierLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowCol(right, midRow, 0, midRow.length);\n     }\n     // No opportunity for optimization. Just return right key.\n     return right;\n   }\n \n   /**\n+   * Try to get a byte array that falls between left and right as short as possible with\n+   * lexicographical order;\n+   *\n    * @return Return a new array that is between left and right and minimally\n-   *         sized else just return null as indicator that we could not create a\n-   *         mid point.\n+   *         sized else just return null if left == right.\n    */\n   private static byte[] getMinimumMidpointArray(final byte[] leftArray, final int leftOffset,\n       final int leftLength, final byte[] rightArray, final int rightOffset, final int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength\n-        && leftArray[leftOffset + diffIdx] == rightArray[rightOffset + diffIdx]) {\n-      diffIdx++;\n-    }\n-    byte[] minimumMidpointArray = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minimumMidpointArray = new byte[diffIdx + 1];\n-      System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = leftArray[leftOffset + diffIdx];\n-      if ((0xff & diffByte) < 0xff && (diffByte + 1) < (rightArray[rightOffset + diffIdx] & 0xff)) {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx);\n-        minimumMidpointArray[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      byte leftByte = leftArray[leftOffset + diffIdx];\n+      byte rightByte = rightArray[rightOffset + diffIdx];\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;\n+        return minimumMidpointArray;\n       } else {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n+        //left == right\n+        return null;\n       }\n     }\n+    //Note that left[diffIdx] can never be equal to 0xff since left < right\n+    byte[] minimumMidpointArray = new byte[diffIdx + 1];\n+    System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx + 1);\n+    minimumMidpointArray[diffIdx] = (byte) (minimumMidpointArray[diffIdx] + 1);\n     return minimumMidpointArray;\n   }\n \n+  /**\n+   * Try to create a new byte array that falls between left and right as short as possible with\n+   * lexicographical order.\n+   *\n+   * @return Return a new array that is between left and right and minimally\n+   *         sized else just return null if left == right.\n+   */\n   private static byte[] getMinimumMidpointArray(ByteBuffer left, int leftOffset, int leftLength,\n       ByteBuffer right, int rightOffset, int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength && ByteBufferUtils.toByte(left,\n-        leftOffset + diffIdx) == ByteBufferUtils.toByte(right, rightOffset + diffIdx)) {\n-      diffIdx++;\n-    }\n-    byte[] minMidpoint = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minMidpoint = new byte[diffIdx + 1];\n-      ByteBufferUtils.copyFromBufferToArray(minMidpoint, right, rightOffset, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n-      if ((0xff & diffByte) < 0xff\n-          && (diffByte + 1) < (ByteBufferUtils.toByte(right, rightOffset + diffIdx) & 0xff)) {\n-        minMidpoint = new byte[diffIdx + 1];\n-        ByteBufferUtils.copyFromBufferToArray(minMidpoint, left, leftOffset, 0, diffIdx);\n-        minMidpoint[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      int leftByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n+      int rightByte = ByteBufferUtils.toByte(right, rightOffset + diffIdx);\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        ByteBufferUtils\n+          .copyFromBufferToArray(minimumMidpointArray, right, rightOffset, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;\n+        return minimumMidpointArray;\n       } else {\n-        minMidpoint = new byte[diffIdx + 1];\n-        ByteBufferUtils.copyFromBufferToArray(minMidpoint, right, rightOffset, 0, diffIdx + 1);\n+        //left == right\n+        return null;\n       }\n     }\n-    return minMidpoint;\n+    //Note that left[diffIdx] can never be equal to 0xff since left < right", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "436329a60a477db76d21a458a857d20defe2317e"}, "originalPosition": 251}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NzA5MDY3", "url": "https://github.com/apache/hbase/pull/2741#pullrequestreview-545709067", "createdAt": "2020-12-06T14:07:00Z", "commit": {"oid": "436329a60a477db76d21a458a857d20defe2317e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQxNDowNzowMFrOIAKr8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQxNDowNzowMFrOIAKr8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA0NjAwMg==", "bodyText": "Here is different from original?", "url": "https://github.com/apache/hbase/pull/2741#discussion_r537046002", "createdAt": "2020-12-06T14:07:00Z", "author": {"login": "nyl3532016"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java", "diffHunk": "@@ -380,143 +378,146 @@ public static Cell getMidpoint(final CellComparator comparator, final Cell left,\n     if (comparator instanceof MetaCellComparator) {\n       return right;\n     }\n-    int diff = comparator.compareRows(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left row sorts after right row; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n     byte[] midRow;\n     boolean bufferBacked = left instanceof ByteBufferExtendedCell\n         && right instanceof ByteBufferExtendedCell;\n-    if (diff < 0) {\n-      // Left row is < right row.\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n-            ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(),\n-            left.getRowLength(), right.getRowArray(), right.getRowOffset(), right.getRowLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n+        ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(), left.getRowLength(),\n+        right.getRowArray(), right.getRowOffset(), right.getRowLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRow(midRow);\n     }\n-    // Rows are same. Compare on families.\n-    diff = comparator.compareFamilies(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left family sorts after right family; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n-            ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n-            left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n-            right.getFamilyLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and then a mid sort family.\n+    //Rows are same. Compare on families.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n+        ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n+        left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n+        right.getFamilyLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowFamily(right, midRow, 0, midRow.length);\n     }\n     // Families are same. Compare on qualifiers.\n-    diff = comparator.compareQualifiers(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left qualifier sorts after right qualifier; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n-            ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n-            left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n-            right.getQualifierLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and family and then a mid sort qualifier.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n+        ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n+        left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n+        right.getQualifierLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowCol(right, midRow, 0, midRow.length);\n     }\n     // No opportunity for optimization. Just return right key.\n     return right;\n   }\n \n   /**\n+   * Try to get a byte array that falls between left and right as short as possible with\n+   * lexicographical order;\n+   *\n    * @return Return a new array that is between left and right and minimally\n-   *         sized else just return null as indicator that we could not create a\n-   *         mid point.\n+   *         sized else just return null if left == right.\n    */\n   private static byte[] getMinimumMidpointArray(final byte[] leftArray, final int leftOffset,\n       final int leftLength, final byte[] rightArray, final int rightOffset, final int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength\n-        && leftArray[leftOffset + diffIdx] == rightArray[rightOffset + diffIdx]) {\n-      diffIdx++;\n-    }\n-    byte[] minimumMidpointArray = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minimumMidpointArray = new byte[diffIdx + 1];\n-      System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = leftArray[leftOffset + diffIdx];\n-      if ((0xff & diffByte) < 0xff && (diffByte + 1) < (rightArray[rightOffset + diffIdx] & 0xff)) {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx);\n-        minimumMidpointArray[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      byte leftByte = leftArray[leftOffset + diffIdx];\n+      byte rightByte = rightArray[rightOffset + diffIdx];\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;\n+        return minimumMidpointArray;\n       } else {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n+        //left == right\n+        return null;\n       }\n     }\n+    //Note that left[diffIdx] can never be equal to 0xff since left < right\n+    byte[] minimumMidpointArray = new byte[diffIdx + 1];\n+    System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx + 1);\n+    minimumMidpointArray[diffIdx] = (byte) (minimumMidpointArray[diffIdx] + 1);\n     return minimumMidpointArray;\n   }\n \n+  /**\n+   * Try to create a new byte array that falls between left and right as short as possible with\n+   * lexicographical order.\n+   *\n+   * @return Return a new array that is between left and right and minimally\n+   *         sized else just return null if left == right.\n+   */\n   private static byte[] getMinimumMidpointArray(ByteBuffer left, int leftOffset, int leftLength,\n       ByteBuffer right, int rightOffset, int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength && ByteBufferUtils.toByte(left,\n-        leftOffset + diffIdx) == ByteBufferUtils.toByte(right, rightOffset + diffIdx)) {\n-      diffIdx++;\n-    }\n-    byte[] minMidpoint = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minMidpoint = new byte[diffIdx + 1];\n-      ByteBufferUtils.copyFromBufferToArray(minMidpoint, right, rightOffset, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n-      if ((0xff & diffByte) < 0xff\n-          && (diffByte + 1) < (ByteBufferUtils.toByte(right, rightOffset + diffIdx) & 0xff)) {\n-        minMidpoint = new byte[diffIdx + 1];\n-        ByteBufferUtils.copyFromBufferToArray(minMidpoint, left, leftOffset, 0, diffIdx);\n-        minMidpoint[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      int leftByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n+      int rightByte = ByteBufferUtils.toByte(right, rightOffset + diffIdx);\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        ByteBufferUtils\n+          .copyFromBufferToArray(minimumMidpointArray, right, rightOffset, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "436329a60a477db76d21a458a857d20defe2317e"}, "originalPosition": 241}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NDMxOTI5", "url": "https://github.com/apache/hbase/pull/2741#pullrequestreview-546431929", "createdAt": "2020-12-07T18:43:46Z", "commit": {"oid": "436329a60a477db76d21a458a857d20defe2317e"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0Mzo0N1rOIA1Fsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxODo0Mzo0N1rOIA1Fsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0MDcyMg==", "bodyText": "From HBASE-10800 ... By our Ramkrishna", "url": "https://github.com/apache/hbase/pull/2741#discussion_r537740722", "createdAt": "2020-12-07T18:43:47Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java", "diffHunk": "@@ -366,8 +366,6 @@ private void finishBlock() throws IOException {\n    */\n   public static Cell getMidpoint(final CellComparator comparator, final Cell left,\n       final Cell right) {\n-    // TODO: Redo so only a single pass over the arrays rather than one to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "436329a60a477db76d21a458a857d20defe2317e"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1795, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}