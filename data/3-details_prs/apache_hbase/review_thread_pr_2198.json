{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzMDA1NDY0", "number": 2198, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNDo1Njo0NlrOEVc1-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODowMzowMVrOEVhSsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTI4MTIwOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/WALEntryFilter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNDo1Njo0NlrOG8NhwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDo0OTozMVrOG8aF_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc4OTM3Ng==", "bodyText": "For system tables we return null Entry. Good to consider return type Optional<Entry> here?\nMaybe as follow up task?", "url": "https://github.com/apache/hbase/pull/2198#discussion_r465789376", "createdAt": "2020-08-05T14:56:46Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/WALEntryFilter.java", "diffHunk": "@@ -49,5 +47,5 @@\n    * @return a (possibly modified) Entry to use. Returning null or an entry with no cells will cause\n    *         the entry to be skipped for replication.\n    */\n-  public Entry filter(Entry entry);\n+  Entry filter(Entry entry);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bafff990e6a06aff532582ea39f618db67afbbdf"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NTI2Mw==", "bodyText": "This is how it works now.... no Optional. Will leave it in this patch. Thanks.", "url": "https://github.com/apache/hbase/pull/2198#discussion_r465995263", "createdAt": "2020-08-05T20:49:31Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/WALEntryFilter.java", "diffHunk": "@@ -49,5 +47,5 @@\n    * @return a (possibly modified) Entry to use. Returning null or an entry with no cells will cause\n    *         the entry to be skipped for replication.\n    */\n-  public Entry filter(Entry entry);\n+  Entry filter(Entry entry);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc4OTM3Ng=="}, "originalCommit": {"oid": "bafff990e6a06aff532582ea39f618db67afbbdf"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTI5NzAzOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/replication/regionserver/TestReplicationSource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMDoxNVrOG8Nr3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMDoxNVrOG8Nr3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5MTk2Ng==", "bodyText": "nit: just in case if you like assertSame(e, wef.filter(e))", "url": "https://github.com/apache/hbase/pull/2198#discussion_r465791966", "createdAt": "2020-08-05T15:00:15Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/replication/regionserver/TestReplicationSource.java", "diffHunk": "@@ -108,16 +107,100 @@ public static void tearDownAfterClass() throws Exception {\n     TEST_UTIL.shutdownMiniDFSCluster();\n   }\n \n+  /**\n+   * Test the default ReplicationSource skips queuing hbase:meta WAL files.\n+   */\n+  @Test\n+  public void testDefaultSkipsMetaWAL() throws IOException {\n+    ReplicationSource rs = new ReplicationSource();\n+    Configuration conf = new Configuration(TEST_UTIL.getConfiguration());\n+    conf.setInt(\"replication.source.maxretriesmultiplier\", 1);\n+    ReplicationPeer mockPeer = Mockito.mock(ReplicationPeer.class);\n+    Mockito.when(mockPeer.getConfiguration()).thenReturn(conf);\n+    Mockito.when(mockPeer.getPeerBandwidth()).thenReturn(0L);\n+    ReplicationPeerConfig peerConfig = Mockito.mock(ReplicationPeerConfig.class);\n+    Mockito.when(peerConfig.getReplicationEndpointImpl()).\n+      thenReturn(DoNothingReplicationEndpoint.class.getName());\n+    Mockito.when(mockPeer.getPeerConfig()).thenReturn(peerConfig);\n+    ReplicationSourceManager manager = Mockito.mock(ReplicationSourceManager.class);\n+    Mockito.when(manager.getTotalBufferUsed()).thenReturn(new AtomicLong());\n+    String queueId = \"qid\";\n+    RegionServerServices rss =\n+      TEST_UTIL.createMockRegionServerService(ServerName.parseServerName(\"a.b.c,1,1\"));\n+    rs.init(conf, null, manager, null, mockPeer, rss, queueId, null,\n+      p -> OptionalLong.empty(), new MetricsSource(queueId));\n+    try {\n+      rs.startup();\n+      assertTrue(rs.isSourceActive());\n+      assertEquals(0, rs.getSourceMetrics().getSizeOfLogQueue());\n+      rs.enqueueLog(new Path(\"a.1\" + META_WAL_PROVIDER_ID));\n+      assertEquals(0, rs.getSourceMetrics().getSizeOfLogQueue());\n+      rs.enqueueLog(new Path(\"a.1\"));\n+      assertEquals(1, rs.getSourceMetrics().getSizeOfLogQueue());\n+    } finally {\n+      rs.terminate(\"Done\");\n+      rss.stop(\"Done\");\n+    }\n+  }\n+\n+  /**\n+   * Test that we filter out meta edits, etc.\n+   */\n+  @Test\n+  public void testWALEntryFilter() throws IOException {\n+    // To get the fully constructed default WALEntryFilter, need to create a ReplicationSource\n+    // instance and init it.\n+    ReplicationSource rs = new ReplicationSource();\n+    UUID uuid = UUID.randomUUID();\n+    Configuration conf = new Configuration(TEST_UTIL.getConfiguration());\n+    ReplicationPeer mockPeer = Mockito.mock(ReplicationPeer.class);\n+    Mockito.when(mockPeer.getConfiguration()).thenReturn(conf);\n+    Mockito.when(mockPeer.getPeerBandwidth()).thenReturn(0L);\n+    ReplicationPeerConfig peerConfig = Mockito.mock(ReplicationPeerConfig.class);\n+    Mockito.when(peerConfig.getReplicationEndpointImpl()).\n+      thenReturn(DoNothingReplicationEndpoint.class.getName());\n+    Mockito.when(mockPeer.getPeerConfig()).thenReturn(peerConfig);\n+    ReplicationSourceManager manager = Mockito.mock(ReplicationSourceManager.class);\n+    Mockito.when(manager.getTotalBufferUsed()).thenReturn(new AtomicLong());\n+    String queueId = \"qid\";\n+    RegionServerServices rss =\n+      TEST_UTIL.createMockRegionServerService(ServerName.parseServerName(\"a.b.c,1,1\"));\n+    rs.init(conf, null, manager, null, mockPeer, rss, queueId,\n+      uuid, p -> OptionalLong.empty(), new MetricsSource(queueId));\n+    try {\n+      rs.startup();\n+      TEST_UTIL.waitFor(30000, () -> rs.getWalEntryFilter() != null);\n+      WALEntryFilter wef = rs.getWalEntryFilter();\n+      // Test non-system WAL edit.\n+      WAL.Entry e = new WAL.Entry(new WALKeyImpl(HConstants.EMPTY_BYTE_ARRAY,\n+        TableName.valueOf(\"test\"), -1), new WALEdit());\n+      assertTrue(wef.filter(e) == e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bafff990e6a06aff532582ea39f618db67afbbdf"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwOTMxMjgyOnYy", "diffSide": "RIGHT", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/replication/regionserver/TestReplicationSource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNTowMzo1MVrOG8N2FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDo0ODoyOVrOG8aD-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDU4MA==", "bodyText": "nit: redundant", "url": "https://github.com/apache/hbase/pull/2198#discussion_r465794580", "createdAt": "2020-08-05T15:03:51Z", "author": {"login": "virajjasani"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/replication/regionserver/TestReplicationSource.java", "diffHunk": "@@ -295,7 +356,40 @@ protected void stopServiceThreads() {\n     }\n   }\n \n-  // Test HBASE-20497\n+  /**\n+   * Deadend Endpoint. Does nothing.\n+   */\n+  public static class DoNothingReplicationEndpoint extends HBaseInterClusterReplicationEndpoint {\n+    private final UUID uuid = UUID.randomUUID();\n+\n+    @Override public void init(Context context) throws IOException {\n+      this.ctx = context;\n+      return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bafff990e6a06aff532582ea39f618db67afbbdf"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NDc0NA==", "bodyText": "Yes. Fixed. Thanks.", "url": "https://github.com/apache/hbase/pull/2198#discussion_r465994744", "createdAt": "2020-08-05T20:48:29Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/replication/regionserver/TestReplicationSource.java", "diffHunk": "@@ -295,7 +356,40 @@ protected void stopServiceThreads() {\n     }\n   }\n \n-  // Test HBASE-20497\n+  /**\n+   * Deadend Endpoint. Does nothing.\n+   */\n+  public static class DoNothingReplicationEndpoint extends HBaseInterClusterReplicationEndpoint {\n+    private final UUID uuid = UUID.randomUUID();\n+\n+    @Override public void init(Context context) throws IOException {\n+      this.ctx = context;\n+      return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDU4MA=="}, "originalCommit": {"oid": "bafff990e6a06aff532582ea39f618db67afbbdf"}, "originalPosition": 316}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMDAxMDA5OnYy", "diffSide": "RIGHT", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxODowMzowMVrOG8UwKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMDo0Nzo0OFrOG8aC0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwNzc1Mg==", "bodyText": "Are we changing this config name also in this patch?", "url": "https://github.com/apache/hbase/pull/2198#discussion_r465907752", "createdAt": "2020-08-05T18:03:01Z", "author": {"login": "anoopsjohn"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -194,30 +232,34 @@ private void decorateConf() {\n   }\n \n   @Override\n-  public void enqueueLog(Path log) {\n-    String logPrefix = AbstractFSWALProvider.getWALPrefixFromWALName(log.getName());\n+  public void enqueueLog(Path wal) {\n+    if (!this.filterInWALs.test(wal)) {\n+      LOG.trace(\"NOT replicating {}\", wal);\n+      return;\n+    }\n+    String logPrefix = AbstractFSWALProvider.getWALPrefixFromWALName(wal.getName());\n     PriorityBlockingQueue<Path> queue = queues.get(logPrefix);\n     if (queue == null) {\n       queue = new PriorityBlockingQueue<>(queueSizePerGroup, new LogsComparator());\n       queues.put(logPrefix, queue);\n       if (this.isSourceActive() && this.walEntryFilter != null) {\n         // new wal group observed after source startup, start a new worker thread to track it\n-        // notice: it's possible that log enqueued when this.running is set but worker thread\n+        // notice: it's possible that wal enqueued when this.running is set but worker thread\n         // still not launched, so it's necessary to check workerThreads before start the worker\n         tryStartNewShipper(logPrefix, queue);\n       }\n     }\n-    queue.put(log);\n+    queue.put(wal);\n     if (LOG.isTraceEnabled()) {\n-      LOG.trace(\"{} Added log file {} to queue of source {}.\", logPeerId(), logPrefix,\n+      LOG.trace(\"{} Added wal {} to queue of source {}.\", logPeerId(), logPrefix,\n         this.replicationQueueInfo.getQueueId());\n     }\n     this.metrics.incrSizeOfLogQueue();\n-    // This will log a warning for each new log that gets created above the warn threshold\n+    // This will wal a warning for each new wal that gets created above the warn threshold\n     int queueSize = queue.size();\n     if (queueSize > this.logQueueWarnThreshold) {\n       LOG.warn(\"{} WAL group {} queue size: {} exceeds value of \"\n-          + \"replication.source.log.queue.warn: {}\", logPeerId(),\n+          + \"replication.source.wal.queue.warn: {}\", logPeerId(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bafff990e6a06aff532582ea39f618db67afbbdf"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NDQ0OQ==", "bodyText": "Good catch. Thanks. Let me restore.", "url": "https://github.com/apache/hbase/pull/2198#discussion_r465994449", "createdAt": "2020-08-05T20:47:48Z", "author": {"login": "saintstack"}, "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -194,30 +232,34 @@ private void decorateConf() {\n   }\n \n   @Override\n-  public void enqueueLog(Path log) {\n-    String logPrefix = AbstractFSWALProvider.getWALPrefixFromWALName(log.getName());\n+  public void enqueueLog(Path wal) {\n+    if (!this.filterInWALs.test(wal)) {\n+      LOG.trace(\"NOT replicating {}\", wal);\n+      return;\n+    }\n+    String logPrefix = AbstractFSWALProvider.getWALPrefixFromWALName(wal.getName());\n     PriorityBlockingQueue<Path> queue = queues.get(logPrefix);\n     if (queue == null) {\n       queue = new PriorityBlockingQueue<>(queueSizePerGroup, new LogsComparator());\n       queues.put(logPrefix, queue);\n       if (this.isSourceActive() && this.walEntryFilter != null) {\n         // new wal group observed after source startup, start a new worker thread to track it\n-        // notice: it's possible that log enqueued when this.running is set but worker thread\n+        // notice: it's possible that wal enqueued when this.running is set but worker thread\n         // still not launched, so it's necessary to check workerThreads before start the worker\n         tryStartNewShipper(logPrefix, queue);\n       }\n     }\n-    queue.put(log);\n+    queue.put(wal);\n     if (LOG.isTraceEnabled()) {\n-      LOG.trace(\"{} Added log file {} to queue of source {}.\", logPeerId(), logPrefix,\n+      LOG.trace(\"{} Added wal {} to queue of source {}.\", logPeerId(), logPrefix,\n         this.replicationQueueInfo.getQueueId());\n     }\n     this.metrics.incrSizeOfLogQueue();\n-    // This will log a warning for each new log that gets created above the warn threshold\n+    // This will wal a warning for each new wal that gets created above the warn threshold\n     int queueSize = queue.size();\n     if (queueSize > this.logQueueWarnThreshold) {\n       LOG.warn(\"{} WAL group {} queue size: {} exceeds value of \"\n-          + \"replication.source.log.queue.warn: {}\", logPeerId(),\n+          + \"replication.source.wal.queue.warn: {}\", logPeerId(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwNzc1Mg=="}, "originalCommit": {"oid": "bafff990e6a06aff532582ea39f618db67afbbdf"}, "originalPosition": 138}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2746, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}