{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzOTYyMDk3", "number": 18555, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNTo0MDo0M1rOEFl2Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoxMzoyOFrOEGa3ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Mjk4NDI3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/rest/RestClientBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNTo0MDo0M1rOGj32sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNTo0MDo0M1rOGj32sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI2ODQ2Ng==", "bodyText": "Are we leaving this?", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r440268466", "createdAt": "2020-06-15T15:40:43Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/rest/RestClientBuilder.java", "diffHunk": "@@ -25,7 +25,7 @@\n      *\n      * @return The REST {@link Client} object.\n      */\n-    public static Client newClient() {\n+    public static Client newClient() { // todo: create a DotConfigMap that wraps the config and allows to reuse this class on non-dotcms contexts", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48e47307b1f9ddd707129e1997e7b487ce6539df"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Mjk4NTg0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/publisher/pusher/PushPublisher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxNTo0MToxMlrOGj331A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxODozNVrOGkpw3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI2ODc1Ng==", "bodyText": "Are we leaving this todo?", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r440268756", "createdAt": "2020-06-15T15:41:12Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/publisher/pusher/PushPublisher.java", "diffHunk": "@@ -350,7 +351,7 @@ private String getFormattedPort(String port){\n      * @return\n      * @throws IOException\n      */\n-\tpublic static Optional<String> retriveEndpointKeyDigest(final PublishingEndPoint endpoint) throws IOException {\n+\tpublic static Optional<String> retriveEndpointKeyDigest(final PublishingEndPoint endpoint) throws IOException { // todo: create a method that allows to receives a key and use the com.dotcms.util.security.Encryptor instead PublicEncryptionFactory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "48e47307b1f9ddd707129e1997e7b487ce6539df"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4NjE3NA==", "bodyText": "done d06b4af#diff-4b87c1c8d652c1a1bc15505b07076e25L354", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441086174", "createdAt": "2020-06-16T19:18:35Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/publisher/pusher/PushPublisher.java", "diffHunk": "@@ -350,7 +351,7 @@ private String getFormattedPort(String port){\n      * @return\n      * @throws IOException\n      */\n-\tpublic static Optional<String> retriveEndpointKeyDigest(final PublishingEndPoint endpoint) throws IOException {\n+\tpublic static Optional<String> retriveEndpointKeyDigest(final PublishingEndPoint endpoint) throws IOException { // todo: create a method that allows to receives a key and use the com.dotcms.util.security.Encryptor instead PublicEncryptionFactory", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI2ODc1Ng=="}, "originalCommit": {"oid": "48e47307b1f9ddd707129e1997e7b487ce6539df"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzYxOTAwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/publisher/pusher/PushPublisher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODozOTowOFrOGj-JjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTo1MToyNFrOGkqz8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MTU5Ng==", "bodyText": "Missing Javadoc", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r440371596", "createdAt": "2020-06-15T18:39:08Z", "author": {"login": "jcastro-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/publisher/pusher/PushPublisher.java", "diffHunk": "@@ -350,15 +353,16 @@ private String getFormattedPort(String port){\n      * @return\n      * @throws IOException\n      */\n-\tpublic static Optional<String> retriveEndpointKeyDigest(final PublishingEndPoint endpoint) throws IOException {\n-\t  \n-\t  if(endpoint==null || endpoint.getAuthKey() ==null) {\n-\t    Logger.warn(PushPublisher.class,\"Endpoint or endpoint key is null:\" + endpoint);\n-\t    return Optional.empty();\n-\t  }\n-\t  \n-\t  String token = PublicEncryptionFactory.decryptString(endpoint.getAuthKey().toString());\n-\t\tString key = null;\n+\tpublic static Optional<String> retriveEndpointKeyDigest(final PublishingEndPoint endpoint)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d1727a7af57fc681541d9aa72fbddcbc4357de3"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwMzM0Ng==", "bodyText": "1aa6ff7#diff-4b87c1c8d652c1a1bc15505b07076e25R351", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441103346", "createdAt": "2020-06-16T19:51:24Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/publisher/pusher/PushPublisher.java", "diffHunk": "@@ -350,15 +353,16 @@ private String getFormattedPort(String port){\n      * @return\n      * @throws IOException\n      */\n-\tpublic static Optional<String> retriveEndpointKeyDigest(final PublishingEndPoint endpoint) throws IOException {\n-\t  \n-\t  if(endpoint==null || endpoint.getAuthKey() ==null) {\n-\t    Logger.warn(PushPublisher.class,\"Endpoint or endpoint key is null:\" + endpoint);\n-\t    return Optional.empty();\n-\t  }\n-\t  \n-\t  String token = PublicEncryptionFactory.decryptString(endpoint.getAuthKey().toString());\n-\t\tString key = null;\n+\tpublic static Optional<String> retriveEndpointKeyDigest(final PublishingEndPoint endpoint)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MTU5Ng=="}, "originalCommit": {"oid": "1d1727a7af57fc681541d9aa72fbddcbc4357de3"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzYyNTE0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/liferay/portal/model/User.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODo0MDo1OFrOGj-NdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToyOToxNlrOGkqG4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MjU5Nw==", "bodyText": "This class only has blank spaces. Consider reverting it.", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r440372597", "createdAt": "2020-06-15T18:40:58Z", "author": {"login": "jcastro-dotcms"}, "path": "dotCMS/src/main/java/com/liferay/portal/model/User.java", "diffHunk": "@@ -300,11 +300,10 @@ public void setModificationDate(final Date modificationDate) {\n         setModified(true);\r\n     }\r\n \r\n-  public boolean isAnonymousUser(){\r\n+  \tpublic boolean isAnonymousUser(){\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d1727a7af57fc681541d9aa72fbddcbc4357de3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA5MTgwOQ==", "bodyText": "javadoc also 53df03a#diff-c944100d5305df9ed32bfd3b81e7ca81R307", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441091809", "createdAt": "2020-06-16T19:29:16Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/liferay/portal/model/User.java", "diffHunk": "@@ -300,11 +300,10 @@ public void setModificationDate(final Date modificationDate) {\n         setModified(true);\r\n     }\r\n \r\n-  public boolean isAnonymousUser(){\r\n+  \tpublic boolean isAnonymousUser(){\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MjU5Nw=="}, "originalCommit": {"oid": "1d1727a7af57fc681541d9aa72fbddcbc4357de3"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MzYzMDY0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODo0MjozMVrOGj-Qvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTo1MTozNlrOGkq0Rw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MzQzOQ==", "bodyText": "Include endpointId and bundleNameSent variables in error logging. Use the same error message for both the logging and the exception's message", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r440373439", "createdAt": "2020-06-15T18:42:31Z", "author": {"login": "jcastro-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -45,140 +54,178 @@\n      * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n      * to the {@link PublishThread Publish Thread}.\n      *\n-     * @param fileName       File name to be published\n-     * @param auth_token_enc Authentication token\n-     * @param groupId        Group who sent the Bundle\n-     * @param endpointId     End-point who sent the Bundle\n-\t * @param type\t\t\t response type\n-\t * @param callback \t\t response callback\n-\t * @param bundleName\t The name for the Bundle to publish\n-\t * @param forcePush \t true/false to Force the push\n-     * @param req            HttpRequest\n+     * @param fileName        File name to be published\n+     * @param authTokenDigest Authentication token\n+     * @param groupId         Group who sent the Bundle\n+     * @param endpointId      End-point who sent the Bundle\n+\t * @param type\t\t\t  response type\n+\t * @param callback \t\t  response callback\n+\t * @param bundleName\t  The name for the Bundle to publish\n+\t * @param forcePush \t  true/false to Force the push\n+     * @param request         {@link HttpServletRequest}\n+\t * @param response        {@link HttpServletResponse}\n      * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n      * @see PublishThread\n      */\n     @POST\n     @Path (\"/publish\")\n     @Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\t@Produces(MediaType.APPLICATION_JSON)\n \tpublic Response publish(\n-\t\t\t@QueryParam(\"FILE_NAME\") String fileName,\n-\t\t\t@QueryParam(\"AUTH_TOKEN\") String auth_token_digest,\n-\t\t\t@QueryParam(\"GROUP_ID\") String groupId,\n-\t\t\t@QueryParam(\"ENDPOINT_ID\") String endpointId,\n-\t\t\t@QueryParam(\"type\") String type,\n-\t\t\t@QueryParam(\"callback\") String callback,\n-\t\t\t@QueryParam(\"BUNDLE_NAME\") String bundleName,\n-\t\t\t@QueryParam(\"FORCE_PUSH\") final boolean forcePush,\n-\t\t\t@Context HttpServletRequest req\n-\t) {\n+\t\t\t@QueryParam(\"FILE_NAME\")   final String fileName,\n+\t\t\t@QueryParam(\"AUTH_TOKEN\")  final String authTokenDigest,\n+\t\t\t@QueryParam(\"GROUP_ID\")    final String groupId,\n+\t\t\t@QueryParam(\"ENDPOINT_ID\") final String endpointId,\n+\t\t\t@QueryParam(\"type\")        final String type,\n+\t\t\t@QueryParam(\"callback\")    final String callback,\n+\t\t\t@QueryParam(\"BUNDLE_NAME\") final String bundleName,\n+\t\t\t@QueryParam(\"FORCE_PUSH\")  final boolean forcePush,\n+\t\t\t@Context final HttpServletRequest  request,\n+\t\t\t@Context final HttpServletResponse response\n+\t) throws Exception {\n+\t\tfinal ResourceResponse responseResource = new ResourceResponse(\n+\t\t\t\tCollectionsUtils.map(\"type\", type, \"callback\", callback));\n+\t\tfinal String remoteIP = UtilMethods.isSet(request.getRemoteHost())?\n+\t\t\t\trequest.getRemoteHost() : request.getRemoteAddr();\n+\t\tfinal PublishingEndPoint sendingEndPointByAddress =\n+\t\t\t\tthis.endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n+\n+\t\tfinal boolean isPPByToken = sendingEndPointByAddress == null;\n+\n+\t\tif (isPPByToken && authTokenDigest == null) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" JWT token expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t}\n+\n+\t\tif (request.getInputStream().isFinished()) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" bundle expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_BAD_REQUEST);\n+\t\t}\n+\n+\t\tfinal InitDataObject initDataObject = this.init(authTokenDigest, request, response);\n+\n+\t\tif (isPPByToken && null == initDataObject || !this.isAdmin(initDataObject.getUser())) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" not permission\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t} else if (!isPPByToken &&\n+\t\t\t\t(sendingEndPointByAddress == null || !isValidToken(authTokenDigest, remoteIP, sendingEndPointByAddress))) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t}\n+\n+\t\tfinal Bundle bundle = this.publishBundle(fileName, groupId, endpointId, bundleName,\n+\t\t\t\tforcePush, request, remoteIP, sendingEndPointByAddress);\n+\n+\t\tif (isPPByToken && bundle != null) {\n+\t\t\treturn Response.ok((bundle)).build();\n+\t\t} else {\n+\t\t\treturn Response.ok().build();\n+\t\t}\n+\t}\n+\n+\n+\tfinal InitDataObject init (final String authTokenDigest, final HttpServletRequest  request,\n+\t\t\t\t\t\t\t   final HttpServletResponse response) {\n+\n     \ttry {\n-    \t\ttry (InputStream bundleStream = req.getInputStream()) {\n-\t\t        //Creating an utility response object\n-\t\t        Map<String, String> paramsMap = new HashMap<String, String>();\n-\t\t        paramsMap.put( \"type\", type );\n-\t\t        paramsMap.put( \"callback\", callback );\n-\t\t        ResourceResponse responseResource = new ResourceResponse( paramsMap );\n-\n-\t\t\t\tString remoteIP = \"\";\n-\t\t\t\ttry {\n-\n-\t\t\t\t\tremoteIP = req.getRemoteHost();\n-\t\t\t\t\tif(!UtilMethods.isSet(remoteIP))\n-\t\t\t\t\t\tremoteIP = req.getRemoteAddr();\n-\n-\t\t\t\t\tHibernateUtil.startTransaction();\n-\n-\t\t\t\t\tPublishingEndPoint mySelf = endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n-\n-\t\t\t\t\tif(mySelf==null || !isValidToken(auth_token_digest, remoteIP, mySelf)) {\n-\t\t\t\t\t\tbundleStream.close();\n-\t\t\t\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n-\t\t\t\t\t\t\n-\t\t        return responseResource.responseError( HttpStatus.SC_UNAUTHORIZED );\n-\t\t       }\n-\n-\t\t\t\t\tString bundlePath = ConfigUtils.getBundlePath()+File.separator+MY_TEMP;\n-\t\t\t\t\tString bundleFolder = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n-\n-\t\t            PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable( mySelf.getId(), mySelf.getId(), bundleFolder, true );\n-\n-\t\t            if(bundleName.trim().length()>0) {\n-\t\t\t\t\t    // save bundle if it doesn't exists\n-\t\t                Bundle foundBundle = APILocator.getBundleAPI().getBundleById( bundleFolder );\n-\t\t                if ( foundBundle == null || foundBundle.getId() == null ) {\n-\t\t                    Bundle bundle = new Bundle();\n-\t\t\t\t\t\t\tbundle.setId(bundleFolder);\n-\t\t\t\t\t\t\tbundle.setName(bundleName);\n-\t\t\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n-\t\t\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n-\t\t\t\t\t\t\tbundle.setForcePush(forcePush);\n-\t\t                    APILocator.getBundleAPI().saveBundle(bundle);\n-\t\t\t\t\t    }\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t//Write file on FS\n-\t\t\t\t\tFileUtil.writeToFile(bundleStream, bundlePath+fileName);\n-\n-\t\t\t\t\t//Start thread\n-\t\t\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n-\t\t\t\t\t\tnew Thread(new PublishThread(fileName, groupId, endpointId, status)).start();\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tHibernateUtil.commitTransaction();\n-\n-\t\t\t\t\treturn Response.status(HttpStatus.SC_OK).build();\n-\t\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class, \"Error caused by remote call of: \"+remoteIP);\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.closeSession();\n-\t\t            } catch (DotHibernateException e) {\n-\t\t                Logger.error(this, \"error close session\",e);\n-\t\t            }\n+\t\t\treturn new WebResource.InitBuilder().\n+\t\t\t\t\trejectWhenNoUser(false). // it would be a soft validation so not reject\n+\t\t\t\t\trequestAndResponse(\n+\t\t\t\t\tnew HttpHeaderHandlerHttpServletRequestWrapper(request,\n+\t\t\t\t\t\t\tCollectionsUtils.map(\n+\t\t\t\t\t\t\t\t\t\"Authorization\", (name, value) -> // if the authorization is set, uses it, otherwise try with the secret (could be a jwt)\n+\t\t\t\t\t\t\t\t\t\t\tUtilMethods.isSet(value) ? value : JsonWebTokenAuthCredentialProcessor.BEARER + authTokenDigest\n+\t\t\t\t\t\t\t)), response).init();\n+\t\t}catch (Exception e) {\n+    \t\treturn null;\n+\t\t}\n+\n+\t}\n+\n+\n+\t@WrapInTransaction\n+\tprivate Bundle publishBundle(final String fileNameSent,\n+\t\t\t\t\t\t\t\t  final String groupId,\n+\t\t\t\t\t\t\t\t  final String endpointId,\n+\t\t\t\t\t\t\t\t  final String bundleNameSent,\n+\t\t\t\t\t\t\t\t  final boolean forcePush,\n+\t\t\t\t\t\t\t\t  final HttpServletRequest request,\n+\t\t\t\t\t\t\t\t  final String remoteIP,\n+\t\t\t\t\t\t\t\t  final PublishingEndPoint sendingEndPointByAddress) throws Exception {\n+\n+    \tfinal String fileName = UtilMethods.isSet(fileNameSent) ? fileNameSent : generatedBundleFileName();\n+\t\tfinal String bundleName =  UtilMethods.isSet(bundleNameSent) ? bundleNameSent : fileName;\n+\n+\t\tBundle bundle = null;\n+\n+\t\ttry (InputStream bundleStream = request.getInputStream()) {\n+\n+\t\t\tfinal String bundlePath         = ConfigUtils.getBundlePath()+ File.separator + MY_TEMP;\n+\t\t\tfinal String bundleFolder       = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n+\t\t\tfinal String sendingEndPoint = sendingEndPointByAddress != null ? sendingEndPointByAddress.getId() : remoteIP;\n+\t\t\tfinal PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable(\n+\t\t\t\t\tsendingEndPoint, sendingEndPoint, bundleFolder, true);\n+\n+\t\t\tif(bundleName.trim().length() > 0) {\n+\t\t\t\t// save bundle if it doesn't exists\n+\t\t\t\tbundle = APILocator.getBundleAPI().getBundleById(bundleFolder);\n+\t\t\t\tif (bundle == null || bundle.getId() == null) {\n+\n+\t\t\t\t\tbundle = new Bundle();\n+\t\t\t\t\tbundle.setId(bundleFolder);\n+\t\t\t\t\tbundle.setName(bundleName);\n+\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n+\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n+\t\t\t\t\tbundle.setForcePush(forcePush);\n+\t\t\t\t\tAPILocator.getBundleAPI().saveBundle(bundle);\n \t\t\t\t}\n-    \t\t}\n-    \t} catch (IOException e) {\n-    \t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-    \t}\n+\t\t\t}\n+\n+\t\t\t//Write file on FS\n+\t\t\tFileUtil.writeToFile(bundleStream, bundlePath + fileName);\n+\n+\t\t\t//Start thread\n \n-\t\treturn Response.status(HttpStatus.SC_INTERNAL_SERVER_ERROR).build();\n+\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n+\t\t\t\tDotConcurrentFactory.getInstance()\n+\t\t\t\t\t\t.getSubmitter()\n+\t\t\t\t\t\t.submit(new PublishThread(fileName, groupId, endpointId, status));\n+\t\t\t}\n+\n+\t\t\treturn bundle;\n+\t\t} catch (Exception e) {\n+\n+\t\t\tLogger.error(PublisherQueueJob.class, \"Error caused by remote call of: \"+remoteIP);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1d1727a7af57fc681541d9aa72fbddcbc4357de3"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTEwMzQzMQ==", "bodyText": "1aa6ff7#diff-4beff38a2c10d3a1c1843475075d0893R198", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441103431", "createdAt": "2020-06-16T19:51:36Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -45,140 +54,178 @@\n      * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n      * to the {@link PublishThread Publish Thread}.\n      *\n-     * @param fileName       File name to be published\n-     * @param auth_token_enc Authentication token\n-     * @param groupId        Group who sent the Bundle\n-     * @param endpointId     End-point who sent the Bundle\n-\t * @param type\t\t\t response type\n-\t * @param callback \t\t response callback\n-\t * @param bundleName\t The name for the Bundle to publish\n-\t * @param forcePush \t true/false to Force the push\n-     * @param req            HttpRequest\n+     * @param fileName        File name to be published\n+     * @param authTokenDigest Authentication token\n+     * @param groupId         Group who sent the Bundle\n+     * @param endpointId      End-point who sent the Bundle\n+\t * @param type\t\t\t  response type\n+\t * @param callback \t\t  response callback\n+\t * @param bundleName\t  The name for the Bundle to publish\n+\t * @param forcePush \t  true/false to Force the push\n+     * @param request         {@link HttpServletRequest}\n+\t * @param response        {@link HttpServletResponse}\n      * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n      * @see PublishThread\n      */\n     @POST\n     @Path (\"/publish\")\n     @Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\t@Produces(MediaType.APPLICATION_JSON)\n \tpublic Response publish(\n-\t\t\t@QueryParam(\"FILE_NAME\") String fileName,\n-\t\t\t@QueryParam(\"AUTH_TOKEN\") String auth_token_digest,\n-\t\t\t@QueryParam(\"GROUP_ID\") String groupId,\n-\t\t\t@QueryParam(\"ENDPOINT_ID\") String endpointId,\n-\t\t\t@QueryParam(\"type\") String type,\n-\t\t\t@QueryParam(\"callback\") String callback,\n-\t\t\t@QueryParam(\"BUNDLE_NAME\") String bundleName,\n-\t\t\t@QueryParam(\"FORCE_PUSH\") final boolean forcePush,\n-\t\t\t@Context HttpServletRequest req\n-\t) {\n+\t\t\t@QueryParam(\"FILE_NAME\")   final String fileName,\n+\t\t\t@QueryParam(\"AUTH_TOKEN\")  final String authTokenDigest,\n+\t\t\t@QueryParam(\"GROUP_ID\")    final String groupId,\n+\t\t\t@QueryParam(\"ENDPOINT_ID\") final String endpointId,\n+\t\t\t@QueryParam(\"type\")        final String type,\n+\t\t\t@QueryParam(\"callback\")    final String callback,\n+\t\t\t@QueryParam(\"BUNDLE_NAME\") final String bundleName,\n+\t\t\t@QueryParam(\"FORCE_PUSH\")  final boolean forcePush,\n+\t\t\t@Context final HttpServletRequest  request,\n+\t\t\t@Context final HttpServletResponse response\n+\t) throws Exception {\n+\t\tfinal ResourceResponse responseResource = new ResourceResponse(\n+\t\t\t\tCollectionsUtils.map(\"type\", type, \"callback\", callback));\n+\t\tfinal String remoteIP = UtilMethods.isSet(request.getRemoteHost())?\n+\t\t\t\trequest.getRemoteHost() : request.getRemoteAddr();\n+\t\tfinal PublishingEndPoint sendingEndPointByAddress =\n+\t\t\t\tthis.endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n+\n+\t\tfinal boolean isPPByToken = sendingEndPointByAddress == null;\n+\n+\t\tif (isPPByToken && authTokenDigest == null) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" JWT token expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t}\n+\n+\t\tif (request.getInputStream().isFinished()) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" bundle expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_BAD_REQUEST);\n+\t\t}\n+\n+\t\tfinal InitDataObject initDataObject = this.init(authTokenDigest, request, response);\n+\n+\t\tif (isPPByToken && null == initDataObject || !this.isAdmin(initDataObject.getUser())) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" not permission\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t} else if (!isPPByToken &&\n+\t\t\t\t(sendingEndPointByAddress == null || !isValidToken(authTokenDigest, remoteIP, sendingEndPointByAddress))) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t}\n+\n+\t\tfinal Bundle bundle = this.publishBundle(fileName, groupId, endpointId, bundleName,\n+\t\t\t\tforcePush, request, remoteIP, sendingEndPointByAddress);\n+\n+\t\tif (isPPByToken && bundle != null) {\n+\t\t\treturn Response.ok((bundle)).build();\n+\t\t} else {\n+\t\t\treturn Response.ok().build();\n+\t\t}\n+\t}\n+\n+\n+\tfinal InitDataObject init (final String authTokenDigest, final HttpServletRequest  request,\n+\t\t\t\t\t\t\t   final HttpServletResponse response) {\n+\n     \ttry {\n-    \t\ttry (InputStream bundleStream = req.getInputStream()) {\n-\t\t        //Creating an utility response object\n-\t\t        Map<String, String> paramsMap = new HashMap<String, String>();\n-\t\t        paramsMap.put( \"type\", type );\n-\t\t        paramsMap.put( \"callback\", callback );\n-\t\t        ResourceResponse responseResource = new ResourceResponse( paramsMap );\n-\n-\t\t\t\tString remoteIP = \"\";\n-\t\t\t\ttry {\n-\n-\t\t\t\t\tremoteIP = req.getRemoteHost();\n-\t\t\t\t\tif(!UtilMethods.isSet(remoteIP))\n-\t\t\t\t\t\tremoteIP = req.getRemoteAddr();\n-\n-\t\t\t\t\tHibernateUtil.startTransaction();\n-\n-\t\t\t\t\tPublishingEndPoint mySelf = endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n-\n-\t\t\t\t\tif(mySelf==null || !isValidToken(auth_token_digest, remoteIP, mySelf)) {\n-\t\t\t\t\t\tbundleStream.close();\n-\t\t\t\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n-\t\t\t\t\t\t\n-\t\t        return responseResource.responseError( HttpStatus.SC_UNAUTHORIZED );\n-\t\t       }\n-\n-\t\t\t\t\tString bundlePath = ConfigUtils.getBundlePath()+File.separator+MY_TEMP;\n-\t\t\t\t\tString bundleFolder = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n-\n-\t\t            PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable( mySelf.getId(), mySelf.getId(), bundleFolder, true );\n-\n-\t\t            if(bundleName.trim().length()>0) {\n-\t\t\t\t\t    // save bundle if it doesn't exists\n-\t\t                Bundle foundBundle = APILocator.getBundleAPI().getBundleById( bundleFolder );\n-\t\t                if ( foundBundle == null || foundBundle.getId() == null ) {\n-\t\t                    Bundle bundle = new Bundle();\n-\t\t\t\t\t\t\tbundle.setId(bundleFolder);\n-\t\t\t\t\t\t\tbundle.setName(bundleName);\n-\t\t\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n-\t\t\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n-\t\t\t\t\t\t\tbundle.setForcePush(forcePush);\n-\t\t                    APILocator.getBundleAPI().saveBundle(bundle);\n-\t\t\t\t\t    }\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t//Write file on FS\n-\t\t\t\t\tFileUtil.writeToFile(bundleStream, bundlePath+fileName);\n-\n-\t\t\t\t\t//Start thread\n-\t\t\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n-\t\t\t\t\t\tnew Thread(new PublishThread(fileName, groupId, endpointId, status)).start();\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tHibernateUtil.commitTransaction();\n-\n-\t\t\t\t\treturn Response.status(HttpStatus.SC_OK).build();\n-\t\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class, \"Error caused by remote call of: \"+remoteIP);\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.closeSession();\n-\t\t            } catch (DotHibernateException e) {\n-\t\t                Logger.error(this, \"error close session\",e);\n-\t\t            }\n+\t\t\treturn new WebResource.InitBuilder().\n+\t\t\t\t\trejectWhenNoUser(false). // it would be a soft validation so not reject\n+\t\t\t\t\trequestAndResponse(\n+\t\t\t\t\tnew HttpHeaderHandlerHttpServletRequestWrapper(request,\n+\t\t\t\t\t\t\tCollectionsUtils.map(\n+\t\t\t\t\t\t\t\t\t\"Authorization\", (name, value) -> // if the authorization is set, uses it, otherwise try with the secret (could be a jwt)\n+\t\t\t\t\t\t\t\t\t\t\tUtilMethods.isSet(value) ? value : JsonWebTokenAuthCredentialProcessor.BEARER + authTokenDigest\n+\t\t\t\t\t\t\t)), response).init();\n+\t\t}catch (Exception e) {\n+    \t\treturn null;\n+\t\t}\n+\n+\t}\n+\n+\n+\t@WrapInTransaction\n+\tprivate Bundle publishBundle(final String fileNameSent,\n+\t\t\t\t\t\t\t\t  final String groupId,\n+\t\t\t\t\t\t\t\t  final String endpointId,\n+\t\t\t\t\t\t\t\t  final String bundleNameSent,\n+\t\t\t\t\t\t\t\t  final boolean forcePush,\n+\t\t\t\t\t\t\t\t  final HttpServletRequest request,\n+\t\t\t\t\t\t\t\t  final String remoteIP,\n+\t\t\t\t\t\t\t\t  final PublishingEndPoint sendingEndPointByAddress) throws Exception {\n+\n+    \tfinal String fileName = UtilMethods.isSet(fileNameSent) ? fileNameSent : generatedBundleFileName();\n+\t\tfinal String bundleName =  UtilMethods.isSet(bundleNameSent) ? bundleNameSent : fileName;\n+\n+\t\tBundle bundle = null;\n+\n+\t\ttry (InputStream bundleStream = request.getInputStream()) {\n+\n+\t\t\tfinal String bundlePath         = ConfigUtils.getBundlePath()+ File.separator + MY_TEMP;\n+\t\t\tfinal String bundleFolder       = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n+\t\t\tfinal String sendingEndPoint = sendingEndPointByAddress != null ? sendingEndPointByAddress.getId() : remoteIP;\n+\t\t\tfinal PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable(\n+\t\t\t\t\tsendingEndPoint, sendingEndPoint, bundleFolder, true);\n+\n+\t\t\tif(bundleName.trim().length() > 0) {\n+\t\t\t\t// save bundle if it doesn't exists\n+\t\t\t\tbundle = APILocator.getBundleAPI().getBundleById(bundleFolder);\n+\t\t\t\tif (bundle == null || bundle.getId() == null) {\n+\n+\t\t\t\t\tbundle = new Bundle();\n+\t\t\t\t\tbundle.setId(bundleFolder);\n+\t\t\t\t\tbundle.setName(bundleName);\n+\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n+\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n+\t\t\t\t\tbundle.setForcePush(forcePush);\n+\t\t\t\t\tAPILocator.getBundleAPI().saveBundle(bundle);\n \t\t\t\t}\n-    \t\t}\n-    \t} catch (IOException e) {\n-    \t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-    \t}\n+\t\t\t}\n+\n+\t\t\t//Write file on FS\n+\t\t\tFileUtil.writeToFile(bundleStream, bundlePath + fileName);\n+\n+\t\t\t//Start thread\n \n-\t\treturn Response.status(HttpStatus.SC_INTERNAL_SERVER_ERROR).build();\n+\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n+\t\t\t\tDotConcurrentFactory.getInstance()\n+\t\t\t\t\t\t.getSubmitter()\n+\t\t\t\t\t\t.submit(new PublishThread(fileName, groupId, endpointId, status));\n+\t\t\t}\n+\n+\t\t\treturn bundle;\n+\t\t} catch (Exception e) {\n+\n+\t\t\tLogger.error(PublisherQueueJob.class, \"Error caused by remote call of: \"+remoteIP);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MzQzOQ=="}, "originalCommit": {"oid": "1d1727a7af57fc681541d9aa72fbddcbc4357de3"}, "originalPosition": 287}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTY3MDQ0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoxMzoyM1rOGlND-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoxMzoyM1rOGlND-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2NDUwNw==", "bodyText": "Codacy found an issue: Ternary operators that can be simplified with || or &&", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441664507", "createdAt": "2020-06-17T16:13:23Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -45,140 +47,182 @@\n      * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n      * to the {@link PublishThread Publish Thread}.\n      *\n-     * @param fileName       File name to be published\n-     * @param auth_token_enc Authentication token\n-     * @param groupId        Group who sent the Bundle\n-     * @param endpointId     End-point who sent the Bundle\n-\t * @param type\t\t\t response type\n-\t * @param callback \t\t response callback\n-\t * @param bundleName\t The name for the Bundle to publish\n-\t * @param forcePush \t true/false to Force the push\n-     * @param req            HttpRequest\n+     * @param fileName        File name to be published\n+     * @param authTokenDigest Authentication token\n+     * @param groupId         Group who sent the Bundle\n+     * @param endpointId      End-point who sent the Bundle\n+\t * @param type\t\t\t  response type\n+\t * @param callback \t\t  response callback\n+\t * @param bundleName\t  The name for the Bundle to publish\n+\t * @param forcePush \t  true/false to Force the push\n+     * @param request         {@link HttpServletRequest}\n+\t * @param response        {@link HttpServletResponse}\n      * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n      * @see PublishThread\n      */\n     @POST\n     @Path (\"/publish\")\n     @Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\t@Produces(MediaType.APPLICATION_JSON)\n \tpublic Response publish(\n-\t\t\t@QueryParam(\"FILE_NAME\") String fileName,\n-\t\t\t@QueryParam(\"AUTH_TOKEN\") String auth_token_digest,\n-\t\t\t@QueryParam(\"GROUP_ID\") String groupId,\n-\t\t\t@QueryParam(\"ENDPOINT_ID\") String endpointId,\n-\t\t\t@QueryParam(\"type\") String type,\n-\t\t\t@QueryParam(\"callback\") String callback,\n-\t\t\t@QueryParam(\"BUNDLE_NAME\") String bundleName,\n-\t\t\t@QueryParam(\"FORCE_PUSH\") final boolean forcePush,\n-\t\t\t@Context HttpServletRequest req\n-\t) {\n+\t\t\t@QueryParam(\"FILE_NAME\")   final String fileName,\n+\t\t\t@QueryParam(\"AUTH_TOKEN\")  final String authTokenDigest,\n+\t\t\t@QueryParam(\"GROUP_ID\")    final String groupId,\n+\t\t\t@QueryParam(\"ENDPOINT_ID\") final String endpointId,\n+\t\t\t@QueryParam(\"type\")        final String type,\n+\t\t\t@QueryParam(\"callback\")    final String callback,\n+\t\t\t@QueryParam(\"BUNDLE_NAME\") final String bundleName,\n+\t\t\t@QueryParam(\"FORCE_PUSH\")  final boolean forcePush,\n+\t\t\t@Context final HttpServletRequest  request,\n+\t\t\t@Context final HttpServletResponse response\n+\t) throws Exception {\n+\t\tfinal ResourceResponse responseResource = new ResourceResponse(\n+\t\t\t\tCollectionsUtils.map(\"type\", type, \"callback\", callback));\n+\t\tfinal String remoteIP = UtilMethods.isSet(request.getRemoteHost())?\n+\t\t\t\trequest.getRemoteHost() : request.getRemoteAddr();\n+\t\tfinal PublishingEndPoint sendingEndPointByAddress =\n+\t\t\t\tthis.endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n+\n+\t\tfinal boolean isPPByToken = sendingEndPointByAddress == null;\n+\n+\t\tif (isPPByToken && authTokenDigest == null) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" JWT token expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t}\n+\n+\t\tif (request.getInputStream().isFinished()) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" bundle expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_BAD_REQUEST);\n+\t\t}\n+\n+\t\tfinal InitDataObject initDataObject = this.init(authTokenDigest, request, response);\n+\n+\t\tif (isPPByToken && null == initDataObject || !this.isAdmin(initDataObject.getUser())) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" not permission\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t} else if (!isPPByToken &&\n+\t\t\t\t(sendingEndPointByAddress == null || !isValidToken(authTokenDigest, remoteIP, sendingEndPointByAddress))) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t}\n+\n+\t\tfinal Bundle bundle = this.publishBundle(fileName, groupId, endpointId, bundleName,\n+\t\t\t\tforcePush, request, remoteIP, sendingEndPointByAddress);\n+\n+\t\tif (isPPByToken && bundle != null) {\n+\t\t\treturn Response.ok(bundle).build();\n+\t\t} else {\n+\t\t\treturn Response.ok().build();\n+\t\t}\n+\t}\n+\n+\n+\tfinal InitDataObject init (final String authTokenDigest, final HttpServletRequest  request,\n+\t\t\t\t\t\t\t   final HttpServletResponse response) {\n+\n     \ttry {\n-    \t\ttry (InputStream bundleStream = req.getInputStream()) {\n-\t\t        //Creating an utility response object\n-\t\t        Map<String, String> paramsMap = new HashMap<String, String>();\n-\t\t        paramsMap.put( \"type\", type );\n-\t\t        paramsMap.put( \"callback\", callback );\n-\t\t        ResourceResponse responseResource = new ResourceResponse( paramsMap );\n-\n-\t\t\t\tString remoteIP = \"\";\n-\t\t\t\ttry {\n-\n-\t\t\t\t\tremoteIP = req.getRemoteHost();\n-\t\t\t\t\tif(!UtilMethods.isSet(remoteIP))\n-\t\t\t\t\t\tremoteIP = req.getRemoteAddr();\n-\n-\t\t\t\t\tHibernateUtil.startTransaction();\n-\n-\t\t\t\t\tPublishingEndPoint mySelf = endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n-\n-\t\t\t\t\tif(mySelf==null || !isValidToken(auth_token_digest, remoteIP, mySelf)) {\n-\t\t\t\t\t\tbundleStream.close();\n-\t\t\t\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n-\t\t\t\t\t\t\n-\t\t        return responseResource.responseError( HttpStatus.SC_UNAUTHORIZED );\n-\t\t       }\n-\n-\t\t\t\t\tString bundlePath = ConfigUtils.getBundlePath()+File.separator+MY_TEMP;\n-\t\t\t\t\tString bundleFolder = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n-\n-\t\t            PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable( mySelf.getId(), mySelf.getId(), bundleFolder, true );\n-\n-\t\t            if(bundleName.trim().length()>0) {\n-\t\t\t\t\t    // save bundle if it doesn't exists\n-\t\t                Bundle foundBundle = APILocator.getBundleAPI().getBundleById( bundleFolder );\n-\t\t                if ( foundBundle == null || foundBundle.getId() == null ) {\n-\t\t                    Bundle bundle = new Bundle();\n-\t\t\t\t\t\t\tbundle.setId(bundleFolder);\n-\t\t\t\t\t\t\tbundle.setName(bundleName);\n-\t\t\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n-\t\t\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n-\t\t\t\t\t\t\tbundle.setForcePush(forcePush);\n-\t\t                    APILocator.getBundleAPI().saveBundle(bundle);\n-\t\t\t\t\t    }\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t//Write file on FS\n-\t\t\t\t\tFileUtil.writeToFile(bundleStream, bundlePath+fileName);\n-\n-\t\t\t\t\t//Start thread\n-\t\t\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n-\t\t\t\t\t\tnew Thread(new PublishThread(fileName, groupId, endpointId, status)).start();\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tHibernateUtil.commitTransaction();\n-\n-\t\t\t\t\treturn Response.status(HttpStatus.SC_OK).build();\n-\t\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class, \"Error caused by remote call of: \"+remoteIP);\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.closeSession();\n-\t\t            } catch (DotHibernateException e) {\n-\t\t                Logger.error(this, \"error close session\",e);\n-\t\t            }\n+\t\t\treturn new WebResource.InitBuilder().\n+\t\t\t\t\trejectWhenNoUser(false). // it would be a soft validation so not reject\n+\t\t\t\t\trequestAndResponse(\n+\t\t\t\t\tnew HttpHeaderHandlerHttpServletRequestWrapper(request,\n+\t\t\t\t\t\t\tCollectionsUtils.map(\n+\t\t\t\t\t\t\t\t\t\"Authorization\", (name, value) -> // if the authorization is set, uses it, otherwise try with the secret (could be a jwt)\n+\t\t\t\t\t\t\t\t\t\t\tUtilMethods.isSet(value) ? value : JsonWebTokenAuthCredentialProcessor.BEARER + authTokenDigest\n+\t\t\t\t\t\t\t)), response).init();\n+\t\t}catch (Exception e) {\n+    \t\treturn null;\n+\t\t}\n+\n+\t}\n+\n+\n+\t@WrapInTransaction\n+\tprivate Bundle publishBundle(final String fileNameSent,\n+\t\t\t\t\t\t\t\t  final String groupId,\n+\t\t\t\t\t\t\t\t  final String endpointId,\n+\t\t\t\t\t\t\t\t  final String bundleNameSent,\n+\t\t\t\t\t\t\t\t  final boolean forcePush,\n+\t\t\t\t\t\t\t\t  final HttpServletRequest request,\n+\t\t\t\t\t\t\t\t  final String remoteIP,\n+\t\t\t\t\t\t\t\t  final PublishingEndPoint sendingEndPointByAddress) throws Exception {\n+\n+    \tfinal String fileName = UtilMethods.isSet(fileNameSent) ? fileNameSent : generatedBundleFileName();\n+\t\tfinal String bundleName =  UtilMethods.isSet(bundleNameSent) ? bundleNameSent : fileName;\n+\n+\t\tBundle bundle = null;\n+\n+\t\ttry (InputStream bundleStream = request.getInputStream()) {\n+\n+\t\t\tfinal String bundlePath         = ConfigUtils.getBundlePath()+ File.separator + MY_TEMP;\n+\t\t\tfinal String bundleFolder       = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n+\t\t\tfinal String sendingEndPoint = sendingEndPointByAddress != null ? sendingEndPointByAddress.getId() : remoteIP;\n+\t\t\tfinal PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable(\n+\t\t\t\t\tsendingEndPoint, sendingEndPoint, bundleFolder, true);\n+\n+\t\t\tif(bundleName.trim().length() > 0) {\n+\t\t\t\t// save bundle if it doesn't exists\n+\t\t\t\tbundle = APILocator.getBundleAPI().getBundleById(bundleFolder);\n+\t\t\t\tif (bundle == null || bundle.getId() == null) {\n+\n+\t\t\t\t\tbundle = new Bundle();\n+\t\t\t\t\tbundle.setId(bundleFolder);\n+\t\t\t\t\tbundle.setName(bundleName);\n+\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n+\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n+\t\t\t\t\tbundle.setForcePush(forcePush);\n+\t\t\t\t\tAPILocator.getBundleAPI().saveBundle(bundle);\n \t\t\t\t}\n-    \t\t}\n-    \t} catch (IOException e) {\n-    \t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-    \t}\n+\t\t\t}\n+\n+\t\t\t//Write file on FS\n+\t\t\tFileUtil.writeToFile(bundleStream, bundlePath + fileName);\n+\n+\t\t\t//Start thread\n \n-\t\treturn Response.status(HttpStatus.SC_INTERNAL_SERVER_ERROR).build();\n+\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n+\n+\t\t\t\tDotConcurrentFactory.getInstance()\n+\t\t\t\t\t\t.getSubmitter()\n+\t\t\t\t\t\t.submit(new PublishThread(fileName, groupId, endpointId, status));\n+\t\t\t}\n+\n+\t\t\treturn bundle;\n+\t\t} catch (Exception e) {\n+\n+\t\t\tLogger.error(\n+\t\t\t\t\tPublisherQueueJob.class,\n+\t\t\t\t\tString.format(\"Error caused by remote call of: Remote IP - %s, bundle name - %s, end point- %s\",\n+\t\t\t\t\t\t\tremoteIP, bundleNameSent,  endpointId));\n+\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n+\t\t\tthrow e;\n+\t\t}\n \t}\n \n-    /**\n+\tprivate String generatedBundleFileName() {\n+\t\treturn String.format(\"bundle_%d.tar.gz\", System.currentTimeMillis());\n+\t}\n+\n+\tprivate boolean isAdmin(final User user) {\n+\n+    \treturn null != user && user.isBackendUser() && user.isAdmin();\n+\t}\n+\n+\t/**\n      * Validates a received token\n      *\n      * @param token    Token to validate\n      * @param remoteIP Sender IP\n-     * @param mySelf   Current end point\n+     * @param publishingEndPoint   Current end point\n      * @return True if valid\n      * @throws IOException If fails reading the security token\n      */\n-    public static boolean isValidToken ( String token, String remoteIP, PublishingEndPoint mySelf ) throws IOException {\n+    public static boolean isValidToken (final String token,\n+\t\t\t\t\t\t\t\t\t\tfinal String remoteIP,\n+\t\t\t\t\t\t\t\t\t\tfinal PublishingEndPoint publishingEndPoint) throws IOException {\n \n         //My key\n-        Optional<String> myKey=PushPublisher.retriveEndpointKeyDigest(mySelf);\n-        if(!myKey.isPresent()) {\n-          return false;\n-        }\n-\n-\n-        return token.equals( myKey.get() );\n+        final  Optional<String> endpointKeyDigest = PushPublisher.retriveEndpointKeyDigest(publishingEndPoint);\n+        return endpointKeyDigest.isPresent()? token.equals( endpointKeyDigest.get() ): false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f78a9461e29a8df741584afb11b0eaaaba0b84"}, "originalPosition": 334}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTY3MDU0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoxMzoyNFrOGlNEDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoxMzoyNFrOGlNEDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2NDUyNA==", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441664524", "createdAt": "2020-06-17T16:13:24Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -45,140 +47,182 @@\n      * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n      * to the {@link PublishThread Publish Thread}.\n      *\n-     * @param fileName       File name to be published\n-     * @param auth_token_enc Authentication token\n-     * @param groupId        Group who sent the Bundle\n-     * @param endpointId     End-point who sent the Bundle\n-\t * @param type\t\t\t response type\n-\t * @param callback \t\t response callback\n-\t * @param bundleName\t The name for the Bundle to publish\n-\t * @param forcePush \t true/false to Force the push\n-     * @param req            HttpRequest\n+     * @param fileName        File name to be published\n+     * @param authTokenDigest Authentication token\n+     * @param groupId         Group who sent the Bundle\n+     * @param endpointId      End-point who sent the Bundle\n+\t * @param type\t\t\t  response type\n+\t * @param callback \t\t  response callback\n+\t * @param bundleName\t  The name for the Bundle to publish\n+\t * @param forcePush \t  true/false to Force the push\n+     * @param request         {@link HttpServletRequest}\n+\t * @param response        {@link HttpServletResponse}\n      * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n      * @see PublishThread\n      */\n     @POST\n     @Path (\"/publish\")\n     @Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\t@Produces(MediaType.APPLICATION_JSON)\n \tpublic Response publish(\n-\t\t\t@QueryParam(\"FILE_NAME\") String fileName,\n-\t\t\t@QueryParam(\"AUTH_TOKEN\") String auth_token_digest,\n-\t\t\t@QueryParam(\"GROUP_ID\") String groupId,\n-\t\t\t@QueryParam(\"ENDPOINT_ID\") String endpointId,\n-\t\t\t@QueryParam(\"type\") String type,\n-\t\t\t@QueryParam(\"callback\") String callback,\n-\t\t\t@QueryParam(\"BUNDLE_NAME\") String bundleName,\n-\t\t\t@QueryParam(\"FORCE_PUSH\") final boolean forcePush,\n-\t\t\t@Context HttpServletRequest req\n-\t) {\n+\t\t\t@QueryParam(\"FILE_NAME\")   final String fileName,\n+\t\t\t@QueryParam(\"AUTH_TOKEN\")  final String authTokenDigest,\n+\t\t\t@QueryParam(\"GROUP_ID\")    final String groupId,\n+\t\t\t@QueryParam(\"ENDPOINT_ID\") final String endpointId,\n+\t\t\t@QueryParam(\"type\")        final String type,\n+\t\t\t@QueryParam(\"callback\")    final String callback,\n+\t\t\t@QueryParam(\"BUNDLE_NAME\") final String bundleName,\n+\t\t\t@QueryParam(\"FORCE_PUSH\")  final boolean forcePush,\n+\t\t\t@Context final HttpServletRequest  request,\n+\t\t\t@Context final HttpServletResponse response\n+\t) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f78a9461e29a8df741584afb11b0eaaaba0b84"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTY3MDYwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoxMzoyNVrOGlNEFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoxMzoyNVrOGlNEFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2NDUzNA==", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441664534", "createdAt": "2020-06-17T16:13:25Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -45,140 +47,182 @@\n      * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n      * to the {@link PublishThread Publish Thread}.\n      *\n-     * @param fileName       File name to be published\n-     * @param auth_token_enc Authentication token\n-     * @param groupId        Group who sent the Bundle\n-     * @param endpointId     End-point who sent the Bundle\n-\t * @param type\t\t\t response type\n-\t * @param callback \t\t response callback\n-\t * @param bundleName\t The name for the Bundle to publish\n-\t * @param forcePush \t true/false to Force the push\n-     * @param req            HttpRequest\n+     * @param fileName        File name to be published\n+     * @param authTokenDigest Authentication token\n+     * @param groupId         Group who sent the Bundle\n+     * @param endpointId      End-point who sent the Bundle\n+\t * @param type\t\t\t  response type\n+\t * @param callback \t\t  response callback\n+\t * @param bundleName\t  The name for the Bundle to publish\n+\t * @param forcePush \t  true/false to Force the push\n+     * @param request         {@link HttpServletRequest}\n+\t * @param response        {@link HttpServletResponse}\n      * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n      * @see PublishThread\n      */\n     @POST\n     @Path (\"/publish\")\n     @Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\t@Produces(MediaType.APPLICATION_JSON)\n \tpublic Response publish(\n-\t\t\t@QueryParam(\"FILE_NAME\") String fileName,\n-\t\t\t@QueryParam(\"AUTH_TOKEN\") String auth_token_digest,\n-\t\t\t@QueryParam(\"GROUP_ID\") String groupId,\n-\t\t\t@QueryParam(\"ENDPOINT_ID\") String endpointId,\n-\t\t\t@QueryParam(\"type\") String type,\n-\t\t\t@QueryParam(\"callback\") String callback,\n-\t\t\t@QueryParam(\"BUNDLE_NAME\") String bundleName,\n-\t\t\t@QueryParam(\"FORCE_PUSH\") final boolean forcePush,\n-\t\t\t@Context HttpServletRequest req\n-\t) {\n+\t\t\t@QueryParam(\"FILE_NAME\")   final String fileName,\n+\t\t\t@QueryParam(\"AUTH_TOKEN\")  final String authTokenDigest,\n+\t\t\t@QueryParam(\"GROUP_ID\")    final String groupId,\n+\t\t\t@QueryParam(\"ENDPOINT_ID\") final String endpointId,\n+\t\t\t@QueryParam(\"type\")        final String type,\n+\t\t\t@QueryParam(\"callback\")    final String callback,\n+\t\t\t@QueryParam(\"BUNDLE_NAME\") final String bundleName,\n+\t\t\t@QueryParam(\"FORCE_PUSH\")  final boolean forcePush,\n+\t\t\t@Context final HttpServletRequest  request,\n+\t\t\t@Context final HttpServletResponse response\n+\t) throws Exception {\n+\t\tfinal ResourceResponse responseResource = new ResourceResponse(\n+\t\t\t\tCollectionsUtils.map(\"type\", type, \"callback\", callback));\n+\t\tfinal String remoteIP = UtilMethods.isSet(request.getRemoteHost())?\n+\t\t\t\trequest.getRemoteHost() : request.getRemoteAddr();\n+\t\tfinal PublishingEndPoint sendingEndPointByAddress =\n+\t\t\t\tthis.endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n+\n+\t\tfinal boolean isPPByToken = sendingEndPointByAddress == null;\n+\n+\t\tif (isPPByToken && authTokenDigest == null) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" JWT token expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t}\n+\n+\t\tif (request.getInputStream().isFinished()) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" bundle expected\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_BAD_REQUEST);\n+\t\t}\n+\n+\t\tfinal InitDataObject initDataObject = this.init(authTokenDigest, request, response);\n+\n+\t\tif (isPPByToken && null == initDataObject || !this.isAdmin(initDataObject.getUser())) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" not permission\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t} else if (!isPPByToken &&\n+\t\t\t\t(sendingEndPointByAddress == null || !isValidToken(authTokenDigest, remoteIP, sendingEndPointByAddress))) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n+\t\t\treturn responseResource.responseError(HttpStatus.SC_UNAUTHORIZED);\n+\t\t}\n+\n+\t\tfinal Bundle bundle = this.publishBundle(fileName, groupId, endpointId, bundleName,\n+\t\t\t\tforcePush, request, remoteIP, sendingEndPointByAddress);\n+\n+\t\tif (isPPByToken && bundle != null) {\n+\t\t\treturn Response.ok(bundle).build();\n+\t\t} else {\n+\t\t\treturn Response.ok().build();\n+\t\t}\n+\t}\n+\n+\n+\tfinal InitDataObject init (final String authTokenDigest, final HttpServletRequest  request,\n+\t\t\t\t\t\t\t   final HttpServletResponse response) {\n+\n     \ttry {\n-    \t\ttry (InputStream bundleStream = req.getInputStream()) {\n-\t\t        //Creating an utility response object\n-\t\t        Map<String, String> paramsMap = new HashMap<String, String>();\n-\t\t        paramsMap.put( \"type\", type );\n-\t\t        paramsMap.put( \"callback\", callback );\n-\t\t        ResourceResponse responseResource = new ResourceResponse( paramsMap );\n-\n-\t\t\t\tString remoteIP = \"\";\n-\t\t\t\ttry {\n-\n-\t\t\t\t\tremoteIP = req.getRemoteHost();\n-\t\t\t\t\tif(!UtilMethods.isSet(remoteIP))\n-\t\t\t\t\t\tremoteIP = req.getRemoteAddr();\n-\n-\t\t\t\t\tHibernateUtil.startTransaction();\n-\n-\t\t\t\t\tPublishingEndPoint mySelf = endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n-\n-\t\t\t\t\tif(mySelf==null || !isValidToken(auth_token_digest, remoteIP, mySelf)) {\n-\t\t\t\t\t\tbundleStream.close();\n-\t\t\t\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" invalid endpoint or token\");\n-\t\t\t\t\t\t\n-\t\t        return responseResource.responseError( HttpStatus.SC_UNAUTHORIZED );\n-\t\t       }\n-\n-\t\t\t\t\tString bundlePath = ConfigUtils.getBundlePath()+File.separator+MY_TEMP;\n-\t\t\t\t\tString bundleFolder = fileName.substring(0, fileName.indexOf(\".tar.gz\"));\n-\n-\t\t            PublishAuditStatus status = PublishAuditAPI.getInstance().updateAuditTable( mySelf.getId(), mySelf.getId(), bundleFolder, true );\n-\n-\t\t            if(bundleName.trim().length()>0) {\n-\t\t\t\t\t    // save bundle if it doesn't exists\n-\t\t                Bundle foundBundle = APILocator.getBundleAPI().getBundleById( bundleFolder );\n-\t\t                if ( foundBundle == null || foundBundle.getId() == null ) {\n-\t\t                    Bundle bundle = new Bundle();\n-\t\t\t\t\t\t\tbundle.setId(bundleFolder);\n-\t\t\t\t\t\t\tbundle.setName(bundleName);\n-\t\t\t\t\t\t\tbundle.setPublishDate(Calendar.getInstance().getTime());\n-\t\t\t\t\t\t\tbundle.setOwner(APILocator.getUserAPI().getSystemUser().getUserId());\n-\t\t\t\t\t\t\tbundle.setForcePush(forcePush);\n-\t\t                    APILocator.getBundleAPI().saveBundle(bundle);\n-\t\t\t\t\t    }\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t//Write file on FS\n-\t\t\t\t\tFileUtil.writeToFile(bundleStream, bundlePath+fileName);\n-\n-\t\t\t\t\t//Start thread\n-\t\t\t\t\tif(!status.getStatus().equals(Status.PUBLISHING_BUNDLE)) {\n-\t\t\t\t\t\tnew Thread(new PublishThread(fileName, groupId, endpointId, status)).start();\n-\t\t\t\t\t}\n-\n-\t\t\t\t\tHibernateUtil.commitTransaction();\n-\n-\t\t\t\t\treturn Response.status(HttpStatus.SC_OK).build();\n-\t\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.rollbackTransaction();\n-\t\t            } catch (DotHibernateException e1) {\n-\t\t                Logger.error(this, \"error rollback\",e1);\n-\t\t            }\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class, \"Error caused by remote call of: \"+remoteIP);\n-\t\t\t\t\tLogger.error(PublisherQueueJob.class,e.getMessage(),e);\n-\t\t\t\t}\n-\t\t\t\tfinally {\n-\t\t\t\t    try {\n-\t\t                HibernateUtil.closeSession();\n-\t\t            } catch (DotHibernateException e) {\n-\t\t                Logger.error(this, \"error close session\",e);\n-\t\t            }\n+\t\t\treturn new WebResource.InitBuilder().\n+\t\t\t\t\trejectWhenNoUser(false). // it would be a soft validation so not reject\n+\t\t\t\t\trequestAndResponse(\n+\t\t\t\t\tnew HttpHeaderHandlerHttpServletRequestWrapper(request,\n+\t\t\t\t\t\t\tCollectionsUtils.map(\n+\t\t\t\t\t\t\t\t\t\"Authorization\", (name, value) -> // if the authorization is set, uses it, otherwise try with the secret (could be a jwt)\n+\t\t\t\t\t\t\t\t\t\t\tUtilMethods.isSet(value) ? value : JsonWebTokenAuthCredentialProcessor.BEARER + authTokenDigest\n+\t\t\t\t\t\t\t)), response).init();\n+\t\t}catch (Exception e) {\n+    \t\treturn null;\n+\t\t}\n+\n+\t}\n+\n+\n+\t@WrapInTransaction\n+\tprivate Bundle publishBundle(final String fileNameSent,\n+\t\t\t\t\t\t\t\t  final String groupId,\n+\t\t\t\t\t\t\t\t  final String endpointId,\n+\t\t\t\t\t\t\t\t  final String bundleNameSent,\n+\t\t\t\t\t\t\t\t  final boolean forcePush,\n+\t\t\t\t\t\t\t\t  final HttpServletRequest request,\n+\t\t\t\t\t\t\t\t  final String remoteIP,\n+\t\t\t\t\t\t\t\t  final PublishingEndPoint sendingEndPointByAddress) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f78a9461e29a8df741584afb11b0eaaaba0b84"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTY3MDY2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoxMzoyNlrOGlNEIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoxMzoyNlrOGlNEIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2NDU0NQ==", "bodyText": "Codacy found an issue: Avoid unused imports such as 'javax.ws.rs'", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441664545", "createdAt": "2020-06-17T16:13:26Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -8,27 +12,25 @@\n import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n import com.dotcms.publisher.endpoint.business.PublishingEndPointAPI;\n import com.dotcms.publisher.pusher.PushPublisher;\n-import javax.ws.rs.Consumes;\n-import javax.ws.rs.POST;\n-import javax.ws.rs.Path;\n-import javax.ws.rs.QueryParam;\n+\n+import javax.servlet.http.HttpServletResponse;\n+import javax.ws.rs.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f78a9461e29a8df741584afb11b0eaaaba0b84"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTY3MDc3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoxMzoyOFrOGlNEMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoxMzoyOFrOGlNEMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2NDU2MQ==", "bodyText": "Codacy found an issue: The String literal \"Push Publishing failed from \" appears 4 times in this file; the first occurrence is on line 94", "url": "https://github.com/dotCMS/core/pull/18555#discussion_r441664561", "createdAt": "2020-06-17T16:13:28Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/BundlePublisherResource.java", "diffHunk": "@@ -45,140 +47,182 @@\n      * server on this end point and if the security tokens match. If all the validations are correct the bundle will be add it<br/>\n      * to the {@link PublishThread Publish Thread}.\n      *\n-     * @param fileName       File name to be published\n-     * @param auth_token_enc Authentication token\n-     * @param groupId        Group who sent the Bundle\n-     * @param endpointId     End-point who sent the Bundle\n-\t * @param type\t\t\t response type\n-\t * @param callback \t\t response callback\n-\t * @param bundleName\t The name for the Bundle to publish\n-\t * @param forcePush \t true/false to Force the push\n-     * @param req            HttpRequest\n+     * @param fileName        File name to be published\n+     * @param authTokenDigest Authentication token\n+     * @param groupId         Group who sent the Bundle\n+     * @param endpointId      End-point who sent the Bundle\n+\t * @param type\t\t\t  response type\n+\t * @param callback \t\t  response callback\n+\t * @param bundleName\t  The name for the Bundle to publish\n+\t * @param forcePush \t  true/false to Force the push\n+     * @param request         {@link HttpServletRequest}\n+\t * @param response        {@link HttpServletResponse}\n      * @return Returns a {@link Response} object with a 200 status code if success or a 500 error code if anything fails on the Publish process\n      * @see PublishThread\n      */\n     @POST\n     @Path (\"/publish\")\n     @Consumes(MediaType.APPLICATION_OCTET_STREAM)\n+\t@Produces(MediaType.APPLICATION_JSON)\n \tpublic Response publish(\n-\t\t\t@QueryParam(\"FILE_NAME\") String fileName,\n-\t\t\t@QueryParam(\"AUTH_TOKEN\") String auth_token_digest,\n-\t\t\t@QueryParam(\"GROUP_ID\") String groupId,\n-\t\t\t@QueryParam(\"ENDPOINT_ID\") String endpointId,\n-\t\t\t@QueryParam(\"type\") String type,\n-\t\t\t@QueryParam(\"callback\") String callback,\n-\t\t\t@QueryParam(\"BUNDLE_NAME\") String bundleName,\n-\t\t\t@QueryParam(\"FORCE_PUSH\") final boolean forcePush,\n-\t\t\t@Context HttpServletRequest req\n-\t) {\n+\t\t\t@QueryParam(\"FILE_NAME\")   final String fileName,\n+\t\t\t@QueryParam(\"AUTH_TOKEN\")  final String authTokenDigest,\n+\t\t\t@QueryParam(\"GROUP_ID\")    final String groupId,\n+\t\t\t@QueryParam(\"ENDPOINT_ID\") final String endpointId,\n+\t\t\t@QueryParam(\"type\")        final String type,\n+\t\t\t@QueryParam(\"callback\")    final String callback,\n+\t\t\t@QueryParam(\"BUNDLE_NAME\") final String bundleName,\n+\t\t\t@QueryParam(\"FORCE_PUSH\")  final boolean forcePush,\n+\t\t\t@Context final HttpServletRequest  request,\n+\t\t\t@Context final HttpServletResponse response\n+\t) throws Exception {\n+\t\tfinal ResourceResponse responseResource = new ResourceResponse(\n+\t\t\t\tCollectionsUtils.map(\"type\", type, \"callback\", callback));\n+\t\tfinal String remoteIP = UtilMethods.isSet(request.getRemoteHost())?\n+\t\t\t\trequest.getRemoteHost() : request.getRemoteAddr();\n+\t\tfinal PublishingEndPoint sendingEndPointByAddress =\n+\t\t\t\tthis.endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n+\n+\t\tfinal boolean isPPByToken = sendingEndPointByAddress == null;\n+\n+\t\tif (isPPByToken && authTokenDigest == null) {\n+\t\t\tLogger.error(this.getClass(), \"Push Publishing failed from \" + remoteIP + \" JWT token expected\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80f78a9461e29a8df741584afb11b0eaaaba0b84"}, "originalPosition": 106}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2104, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}