{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI3MjIyOTk0", "number": 18584, "title": "#18576 spring cleanup of starter import / reindex error handling", "bodyText": "This is a bit of housekeeping (not a rewrite) on how the starter is generated and how it is imported.\nremoved most of the broken db locking/transaction stuff from the StartupTasksExecutor and importing a starter is now transactional.\nmoved the Import and Export Utils to their own classes and renamed them ImportStarterUtil and ExportStarterUtil\nWhen serializing and deserializing objects as XML, I am using the BundleUtil which handles writing XML 1.0 correctly.\nHeavy cleanup (though not a complete rewrite) on the ImportStarterUtil.  It is better but there is risk that I might have been to aggressive and missed something.\nI have starters and data sets that cannot be imported and/or reindexed without these changes. Reach out to me if you are looking to test one of them.", "createdAt": "2020-06-03T14:01:11Z", "url": "https://github.com/dotCMS/core/pull/18584", "merged": true, "mergeCommit": {"oid": "91b79533377c6787a9a840dd79314cc33ce97df0"}, "closed": true, "closedAt": "2020-06-17T17:49:07Z", "author": {"login": "wezell"}, "timelineItems": {"totalCount": 59, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnp14EgH2gAyNDI3MjIyOTk0OmYxMWIyMzZiMDA1NDlmNmQyYjMzMjk5NTQ3M2NkYmVlYThhZTRhZDI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcsMscGgFqTQzMjU4NjMzOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f11b236b00549f6d2b332995473cdbeea8ae4ad2", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/f11b236b00549f6d2b332995473cdbeea8ae4ad2", "committedDate": "2020-06-03T13:54:05Z", "message": "#18576 spring cleanup of starter import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ddb2f7c2eeb6cab337407747bd43eae2b0f798d0", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/ddb2f7c2eeb6cab337407747bd43eae2b0f798d0", "committedDate": "2020-06-03T15:44:38Z", "message": "#18576 fixing relationshipfields"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7894896ba48209d9a46bebf2ae9af60c0ea1391", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/f7894896ba48209d9a46bebf2ae9af60c0ea1391", "committedDate": "2020-06-03T16:29:52Z", "message": "#18576 testing round trip generation/import with customer data"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56c6fc4083e2914c9f30b2b5933110651efc7d10", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/56c6fc4083e2914c9f30b2b5933110651efc7d10", "committedDate": "2020-06-03T18:37:35Z", "message": "#18576 merging master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzODI5OTQz", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-423829943", "createdAt": "2020-06-03T18:41:13Z", "commit": {"oid": "56c6fc4083e2914c9f30b2b5933110651efc7d10"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo0MToxNFrOGeotkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo0MToxNFrOGeotkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3NzQ5MA==", "bodyText": "Nice I didn't know this one", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r434777490", "createdAt": "2020-06-03T18:41:14Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/db/DotCMSInitDb.java", "diffHunk": "@@ -1,126 +1,113 @@\n package com.dotmarketing.db;\n \n import java.io.File;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.util.List;\n-\n+import org.apache.felix.framework.OSGIUtil;\n import com.dotcms.business.CloseDBIfOpened;\n-import com.dotmarketing.beans.Host;\n+import com.dotcms.business.WrapInTransaction;\n import com.dotmarketing.business.APILocator;\n-import com.dotmarketing.cms.factories.PublicCompanyFactory;\n import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.common.reindex.ReindexThread;\n import com.dotmarketing.exception.DotDataException;\n import com.dotmarketing.exception.DotRuntimeException;\n-import com.dotmarketing.exception.DotSecurityException;\n-import com.dotmarketing.portlets.contentlet.business.HostAPI;\n-import com.dotmarketing.portlets.structure.factories.StructureFactory;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n import com.dotmarketing.util.Config;\n-import com.dotmarketing.util.ImportExportUtil;\n+import com.dotmarketing.util.ImportStarterUtil;\n import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.MaintenanceUtil;\n import com.dotmarketing.util.UtilMethods;\n-import com.liferay.portal.model.User;\n import com.liferay.util.FileUtil;\n-import com.rainerhahnekamp.sneakythrow.Sneaky;\n import io.vavr.control.Try;\n \n public class DotCMSInitDb {\n \n \t@CloseDBIfOpened\n \tprivate static boolean isConfigured () {\n \n-\t\tDotConnect db = new DotConnect();\n-\t\tdb.setSQL(\"select count(*) as test from inode\");\n+\t\treturn new DotConnect()\n+                .setSQL(\"select count(*) as test from inode\")\n+                .getInt(\"test\")>0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56c6fc4083e2914c9f30b2b5933110651efc7d10"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzODMwNzMz", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-423830733", "createdAt": "2020-06-03T18:42:20Z", "commit": {"oid": "56c6fc4083e2914c9f30b2b5933110651efc7d10"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo0MjoyMFrOGeovxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo0MjoyMFrOGeovxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc3ODA1NA==", "bodyText": "you can replace this (e->new DotRuntimeException(e));\nby this\n(DotRuntimeException::new);\nKinda fancy", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r434778054", "createdAt": "2020-06-03T18:42:20Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/db/DotCMSInitDb.java", "diffHunk": "@@ -1,126 +1,113 @@\n package com.dotmarketing.db;\n \n import java.io.File;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.util.List;\n-\n+import org.apache.felix.framework.OSGIUtil;\n import com.dotcms.business.CloseDBIfOpened;\n-import com.dotmarketing.beans.Host;\n+import com.dotcms.business.WrapInTransaction;\n import com.dotmarketing.business.APILocator;\n-import com.dotmarketing.cms.factories.PublicCompanyFactory;\n import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.common.reindex.ReindexThread;\n import com.dotmarketing.exception.DotDataException;\n import com.dotmarketing.exception.DotRuntimeException;\n-import com.dotmarketing.exception.DotSecurityException;\n-import com.dotmarketing.portlets.contentlet.business.HostAPI;\n-import com.dotmarketing.portlets.structure.factories.StructureFactory;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n import com.dotmarketing.util.Config;\n-import com.dotmarketing.util.ImportExportUtil;\n+import com.dotmarketing.util.ImportStarterUtil;\n import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.MaintenanceUtil;\n import com.dotmarketing.util.UtilMethods;\n-import com.liferay.portal.model.User;\n import com.liferay.util.FileUtil;\n-import com.rainerhahnekamp.sneakythrow.Sneaky;\n import io.vavr.control.Try;\n \n public class DotCMSInitDb {\n \n \t@CloseDBIfOpened\n \tprivate static boolean isConfigured () {\n \n-\t\tDotConnect db = new DotConnect();\n-\t\tdb.setSQL(\"select count(*) as test from inode\");\n+\t\treturn new DotConnect()\n+                .setSQL(\"select count(*) as test from inode\")\n+                .getInt(\"test\")>0;\n \n-\t\tint test = db.getInt(\"test\");\n-\t\treturn (test > 0);\n \t}\n \n-\t@CloseDBIfOpened\n-\tpublic static void InitializeDb() throws DotDataException {\n-\n-\t\tfinal boolean configured = isConfigured();\n-\n-\t\tif (!configured) {\n-\t\t\tif(Config.getBooleanProperty(\"STARTERSITE_BUILD\", true)){\n-\t\t\t\tLogger.info(DotCMSInitDb.class,\"There are no inodes - initializing db with starter site\");\n-\t\t\t\ttry {\n-\t\t\t\t\tPrintWriter pw = new PrintWriter(new StringWriter());\n-\t\t\t\t\tloadStarterSite(pw);\n-\t\t\t\t\tLogger.info(DotCMSInitDb.class, pw.toString());\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\tLogger.error(DotCMSInitDb.class, \"Unable to load starter site\", e);\n-\t\t\t\t}\n-\t\t\t}else{\n-\t\t\t\tLogger.info(DotCMSInitDb.class,\"There are no inodes - initializing db for first time use\");\n-\t\t\t\tbuildDefaultData();\n-\t\t\t}\n-\t\t}else {\n-\t\t\tLogger.info(DotCMSInitDb.class,\"inodes exist, skipping initialization of db\");\n-\t\t}\n-\t}\n+    @CloseDBIfOpened\n+    public static void InitializeDb() {\n \n-\tprivate static void buildDefaultData() throws DotDataException {\n-\t\ttry {\n-\t\t\tHostAPI hostAPI = APILocator.getHostAPI();\n-\t\t\tLocalTransaction.wrap(() -> PublicCompanyFactory.createDefaultCompany());\n-\t\t\t// Ensures that default groups are set up\n-\t//\t\tGroupFactory.createDefaultGroups();\n-\t//\t\ttry {\n-\t//\t\t\tLayoutFactory.createDefaultLayouts();\n-\t//\t\t} catch (Exception e) {\n-\t//\t\t\tthrow new DotDataException(e.getMessage(), e);\n-\t//\t\t}\n-\t\t\t// Creating the default host\n-\t\t\tUser systemUser = APILocator.getUserAPI().getSystemUser();\n-\t\t\tList<Host> hosts = hostAPI.findAll(systemUser, false);\n-\t\t\tif (hosts.size() == 0) {\n-\t\t\t\tLogger.debug(DotCMSInitDb.class, \"Creating Default Host\");\n-\t\t\t\thostAPI.findDefaultHost(systemUser, false);\n-\t\t\t}\n-\t        //Create Default Language\n-\t        APILocator.getLanguageAPI().createDefaultLanguage();\n-\t\t\t// Creating the default content structures if it not exists.\n-\t\t\tStructureFactory.createDefaultStructure();\n-\t\t} catch (DotSecurityException e) {\n-\t\t\tLogger.fatal(DotCMSInitDb.class, \"Unable to initialize default data\", e);\n-\t\t\tthrow new DotRuntimeException(e.getMessage(), e);\n-\t\t} catch (Exception e) {\n-\t\t\tLogger.fatal(DotCMSInitDb.class, \"Unable to initialize default data\", e);\n-\t\t\tnew DotDataException(e.getMessage(), e);\n-\t\t}\n-\t}\n+        if (!isConfigured()) {\n \n-\tprivate static void loadStarterSite(PrintWriter pw) throws IOException{\n-\t\t\n-\t\tString starter = Config.getStringProperty(\"STARTER_DATA_LOAD\");\n-\t\tFile starterZip = null;\n-\t\t\n-\t\tif(UtilMethods.isSet(starter)){\n+            Logger.info(DotCMSInitDb.class, \"There are no inodes - initializing db with starter site\");\n+\n+    \n+            \n+            Try.run(() -> loadStarterSite()).getOrElseThrow(e->new DotRuntimeException(e));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56c6fc4083e2914c9f30b2b5933110651efc7d10"}, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzODM0NTg2", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-423834586", "createdAt": "2020-06-03T18:47:50Z", "commit": {"oid": "56c6fc4083e2914c9f30b2b5933110651efc7d10"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo0Nzo1MFrOGeo7bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxODo0Nzo1MFrOGeo7bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc4MTAzNg==", "bodyText": "great", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r434781036", "createdAt": "2020-06-03T18:47:50Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/portlets/cmsmaintenance/action/ViewCMSMaintenanceAction.java", "diffHunk": "@@ -274,60 +278,32 @@ else if(cmd.equals(\"dropoldassets\")){\n \t\t}\r\n \t\t//Manage all the import/ export Task\r\n \t\telse {\r\n-\t\t\tMaintenanceUtil.fixImagesTable();\r\n-\t\t\tFile f = new File(backupFilePath);\r\n-\t\t\tf.mkdirs();\r\n-\t\t\tf = new File(backupTempFilePath);\r\n-\t\t\tf.mkdirs();\r\n-\t\t\tdeleteTempFiles();\r\n-\t\t\tboolean dataOnly = Parameter.getBooleanFromString(req.getParameter(\"dataOnly\"), true);\r\n-\r\n-\t\t\tif(cmd.equals(\"createZip\")) {\r\n-\t\t\t\tif(!dataOnly){\r\n-\t\t\t\t\tmoveAssetsToBackupDir();\r\n-\t\t\t\t}\r\n-\t\t\t\tmessage = \"Creating XML Files. \";\r\n-\t\t\t\tcreateXMLFiles();\r\n-\t\t\t\tString x = UtilMethods.dateToJDBC(new Date()).replace(':', '-').replace(' ', '_');\r\n-\t\t\t\tFile zipFile = new File(backupFilePath + \"/backup_\" + x + \"_.zip\");\r\n-\t\t\t\tmessage +=\"Zipping up to file:\" + zipFile.getAbsolutePath();\r\n-\t\t\t\tfinal BufferedOutputStream bout = new BufferedOutputStream(Files.newOutputStream(zipFile.toPath()));\r\n-\r\n-\t\t\t\tzipTempDirectoryToStream(bout);\r\n-\t\t\t\tmessage +=\". Done.\";\r\n-\t\t\t} else if(cmd.equals(\"downloadZip\")) {\r\n-\r\n-\t\t\t\tmessage =\"File Downloaded\";\r\n-\t\t\t\tString x = UtilMethods.dateToJDBC(new Date()).replace(':', '-').replace(' ', '_');\r\n-\t\t\t\tFile zipFile = new File(backupFilePath + \"/backup_\" + x + \"_.zip\");\r\n-\r\n-\t\t\t\tActionResponseImpl responseImpl = (ActionResponseImpl) res;\r\n-\t\t\t\tHttpServletResponse httpResponse = responseImpl.getHttpServletResponse();\r\n-\t\t\t\thttpResponse.setHeader(\"Content-type\", \"\");\r\n-\t\t\t\thttpResponse.setHeader(\"Content-Disposition\", \"attachment; filename=\" + zipFile.getName());\r\n-\r\n-\t\t\t\tif(!dataOnly){\r\n-\t\t\t\t\tmoveAssetsToBackupDir();\r\n-\t\t\t\t}\r\n-\r\n-\t\t\t\tcreateXMLFiles();\r\n-\r\n-\t\t\t\tzipTempDirectoryToStream(httpResponse.getOutputStream());\r\n-\r\n-\t\t\t}else if(cmd.equals(\"upload\")) {\r\n-\r\n-\r\n-\t\t\t\tUploadPortletRequest uploadReq = PortalUtil.getUploadPortletRequest(req);\r\n-\t\t\t\tActionResponseImpl responseImpl = (ActionResponseImpl) res;\r\n-\t\t\t\tHttpServletResponse httpResponse = responseImpl.getHttpServletResponse();\r\n-\r\n-\t\t\t\tActionRequestImpl requestImpl = (ActionRequestImpl) req;\r\n-\t\t\t\tHttpServletRequest httpRequest = requestImpl.getHttpServletRequest();\r\n \r\n-\t\t\t\t//message =\"file upload Done.\";\r\n-\r\n-\t\t\t\tdoUpload(httpRequest, httpResponse, uploadReq);\r\n-\t\t\t}\r\n+\t\t\tfinal boolean dataOnly = Parameter.getBooleanFromString(req.getParameter(\"dataOnly\"), true);\r\n+\t\t\tfinal boolean download =\"downloadZip\".equalsIgnoreCase(cmd);\r\n+            final HttpServletResponse httpResponse = ((ActionResponseImpl) res).getHttpServletResponse();\r\n+\r\n+\t\t\t\r\n+            final File outputDir = dataOnly ? new ExportStarterUtil().createStarterData() : new ExportStarterUtil().createStarterWithAssets();\r\n+            final File zipFile = new File(backupFilePath + \"/backup_\" +  UtilMethods.dateToJDBC(new Date()).replace(':', '-').replace(' ', '_') + \".zip\");\r\n+            message +=\"Zipping up to file:\" + zipFile.getAbsolutePath();\r\n+            \r\n+            if(download) {\r\n+                httpResponse.setHeader(\"Content-type\", \"application/zip\");\r\n+                httpResponse.setHeader(\"Content-Disposition\", \"attachment; filename=\" + zipFile.getName());\r\n+            }\r\n+            \r\n+            try(final OutputStream outStream = (download) \r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56c6fc4083e2914c9f30b2b5933110651efc7d10"}, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NTExNzEx", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-424511711", "createdAt": "2020-06-04T14:31:46Z", "commit": {"oid": "56c6fc4083e2914c9f30b2b5933110651efc7d10"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NDk3MzI4", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-425497328", "createdAt": "2020-06-05T17:40:34Z", "commit": {"oid": "56c6fc4083e2914c9f30b2b5933110651efc7d10"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c0a3969a2d16735af2228948c4d307a41f07491", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/3c0a3969a2d16735af2228948c4d307a41f07491", "committedDate": "2020-06-06T16:46:45Z", "message": "Merge remote-tracking branch 'origin/master' into issue-18576-starter-xml"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NDA4Mzcy", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-426408372", "createdAt": "2020-06-08T16:25:04Z", "commit": {"oid": "3c0a3969a2d16735af2228948c4d307a41f07491"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjoyNTowNVrOGgmSGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjoyNTowNVrOGgmSGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgzNDg0MA==", "bodyText": "why was the buildDefaultData  removed? what would be the behavior if the STARTERSITE_BUILD is null?", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r436834840", "createdAt": "2020-06-08T16:25:05Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/main/java/com/dotmarketing/db/DotCMSInitDb.java", "diffHunk": "@@ -1,126 +1,113 @@\n package com.dotmarketing.db;\n \n import java.io.File;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.util.List;\n-\n+import org.apache.felix.framework.OSGIUtil;\n import com.dotcms.business.CloseDBIfOpened;\n-import com.dotmarketing.beans.Host;\n+import com.dotcms.business.WrapInTransaction;\n import com.dotmarketing.business.APILocator;\n-import com.dotmarketing.cms.factories.PublicCompanyFactory;\n import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.common.reindex.ReindexThread;\n import com.dotmarketing.exception.DotDataException;\n import com.dotmarketing.exception.DotRuntimeException;\n-import com.dotmarketing.exception.DotSecurityException;\n-import com.dotmarketing.portlets.contentlet.business.HostAPI;\n-import com.dotmarketing.portlets.structure.factories.StructureFactory;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n import com.dotmarketing.util.Config;\n-import com.dotmarketing.util.ImportExportUtil;\n+import com.dotmarketing.util.ImportStarterUtil;\n import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.MaintenanceUtil;\n import com.dotmarketing.util.UtilMethods;\n-import com.liferay.portal.model.User;\n import com.liferay.util.FileUtil;\n-import com.rainerhahnekamp.sneakythrow.Sneaky;\n import io.vavr.control.Try;\n \n public class DotCMSInitDb {\n \n \t@CloseDBIfOpened\n \tprivate static boolean isConfigured () {\n \n-\t\tDotConnect db = new DotConnect();\n-\t\tdb.setSQL(\"select count(*) as test from inode\");\n+\t\treturn new DotConnect()\n+                .setSQL(\"select count(*) as test from inode\")\n+                .getInt(\"test\")>0;\n \n-\t\tint test = db.getInt(\"test\");\n-\t\treturn (test > 0);\n \t}\n \n-\t@CloseDBIfOpened\n-\tpublic static void InitializeDb() throws DotDataException {\n-\n-\t\tfinal boolean configured = isConfigured();\n-\n-\t\tif (!configured) {\n-\t\t\tif(Config.getBooleanProperty(\"STARTERSITE_BUILD\", true)){\n-\t\t\t\tLogger.info(DotCMSInitDb.class,\"There are no inodes - initializing db with starter site\");\n-\t\t\t\ttry {\n-\t\t\t\t\tPrintWriter pw = new PrintWriter(new StringWriter());\n-\t\t\t\t\tloadStarterSite(pw);\n-\t\t\t\t\tLogger.info(DotCMSInitDb.class, pw.toString());\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\tLogger.error(DotCMSInitDb.class, \"Unable to load starter site\", e);\n-\t\t\t\t}\n-\t\t\t}else{\n-\t\t\t\tLogger.info(DotCMSInitDb.class,\"There are no inodes - initializing db for first time use\");\n-\t\t\t\tbuildDefaultData();\n-\t\t\t}\n-\t\t}else {\n-\t\t\tLogger.info(DotCMSInitDb.class,\"inodes exist, skipping initialization of db\");\n-\t\t}\n-\t}\n+    @CloseDBIfOpened\n+    public static void InitializeDb() {\n \n-\tprivate static void buildDefaultData() throws DotDataException {\n-\t\ttry {\n-\t\t\tHostAPI hostAPI = APILocator.getHostAPI();\n-\t\t\tLocalTransaction.wrap(() -> PublicCompanyFactory.createDefaultCompany());\n-\t\t\t// Ensures that default groups are set up\n-\t//\t\tGroupFactory.createDefaultGroups();\n-\t//\t\ttry {\n-\t//\t\t\tLayoutFactory.createDefaultLayouts();\n-\t//\t\t} catch (Exception e) {\n-\t//\t\t\tthrow new DotDataException(e.getMessage(), e);\n-\t//\t\t}\n-\t\t\t// Creating the default host\n-\t\t\tUser systemUser = APILocator.getUserAPI().getSystemUser();\n-\t\t\tList<Host> hosts = hostAPI.findAll(systemUser, false);\n-\t\t\tif (hosts.size() == 0) {\n-\t\t\t\tLogger.debug(DotCMSInitDb.class, \"Creating Default Host\");\n-\t\t\t\thostAPI.findDefaultHost(systemUser, false);\n-\t\t\t}\n-\t        //Create Default Language\n-\t        APILocator.getLanguageAPI().createDefaultLanguage();\n-\t\t\t// Creating the default content structures if it not exists.\n-\t\t\tStructureFactory.createDefaultStructure();\n-\t\t} catch (DotSecurityException e) {\n-\t\t\tLogger.fatal(DotCMSInitDb.class, \"Unable to initialize default data\", e);\n-\t\t\tthrow new DotRuntimeException(e.getMessage(), e);\n-\t\t} catch (Exception e) {\n-\t\t\tLogger.fatal(DotCMSInitDb.class, \"Unable to initialize default data\", e);\n-\t\t\tnew DotDataException(e.getMessage(), e);\n-\t\t}\n-\t}\n+        if (!isConfigured()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c0a3969a2d16735af2228948c4d307a41f07491"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NDEzNzcx", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-426413771", "createdAt": "2020-06-08T16:31:42Z", "commit": {"oid": "3c0a3969a2d16735af2228948c4d307a41f07491"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjozMTo0MlrOGgmivA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQxNjozMTo0MlrOGgmivA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjgzOTEwMA==", "bodyText": "I think it's redundant because there is a Logger.info just below with the same info", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r436839100", "createdAt": "2020-06-08T16:31:42Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/main/java/com/dotmarketing/startup/StartupTasksExecutor.java", "diffHunk": "@@ -10,346 +13,208 @@\n import com.dotmarketing.util.Logger;\n import com.dotmarketing.util.TaskLocatorUtil;\n \n-import java.sql.Connection;\n-import java.sql.Date;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.sql.Statement;\n-import java.util.Calendar;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-\n public class StartupTasksExecutor {\n \n \t\n \tprivate static StartupTasksExecutor executor;\n \n-\tprivate String pgLock = \"lock table db_version;\";\n-\tprivate String myLock = \"lock table db_version write;\";\n-\tprivate String oraLock = \"LOCK TABLE DB_VERSION IN EXCLUSIVE MODE\";\n-\tprivate String msLock = \"SELECT * FROM db_version WITH (XLOCK)\";\n-\tprivate String h2Lock = \"SELECT * FROM db_version FOR UPDATE\";\n-\n-\tprivate String pgCommit = \"commit;\";\n-\tprivate String myCommit = \"unlock tables\";\n-\tprivate String oraCommit = \"COMMIT\";\n-\tprivate String msCommit = \"COMMIT\";\n-\tprivate String h2Commit = \"COMMIT\";\n-\n-\tprivate String pgCreate = \"CREATE TABLE db_version (db_version integer NOT NULL, date_update timestamp with time zone NOT NULL, CONSTRAINT db_version_pkey PRIMARY KEY (db_version));\";\n-\tprivate String myCreate = \"CREATE TABLE `db_version` (`db_version` INTEGER UNSIGNED NOT NULL,`date_update` DATETIME NOT NULL, PRIMARY KEY (`db_version`))\";\n-\tprivate String oraCreate = \"CREATE TABLE \\\"DB_VERSION\\\" ( \\\"DB_VERSION\\\" INTEGER NOT NULL , \\\"DATE_UPDATE\\\" TIMESTAMP NOT NULL, PRIMARY KEY (\\\"DB_VERSION\\\") )\";\n-\tprivate String msCreate =\"CREATE TABLE db_version (\tdb_version int NOT NULL , date_update datetime NOT NULL, PRIMARY KEY (db_version) )\";\n-\tprivate String h2Create = \"CREATE TABLE db_version (db_version integer NOT NULL, date_update timestamp NOT NULL, CONSTRAINT db_version_pkey PRIMARY KEY (db_version))\";\n-\t\n-\tprivate String pgSelect = \"SELECT max(db_version) AS db_version FROM db_version\";\n-\tprivate String mySelect = \"SELECT max(db_version) AS db_version FROM db_version\";\n-\tprivate String oraSelect = \"SELECT max(db_version) AS db_version FROM db_version\";\n-\tprivate String msSelect = \"SELECT max(db_version) AS db_version FROM db_version\";\n-\tprivate String h2Select = \"SELECT max(db_version) AS db_version FROM db_version\";\n \n-\tprivate String lock;\n-\tprivate String commit;\n-\tprivate String create;\n-\tprivate String select;\n \n \n+\tprivate final String pgCreate  = \"CREATE TABLE db_version (db_version integer NOT NULL, date_update timestamp with time zone NOT NULL, CONSTRAINT db_version_pkey PRIMARY KEY (db_version));\";\n+\tprivate final String myCreate  = \"CREATE TABLE `db_version` (`db_version` INTEGER UNSIGNED NOT NULL,`date_update` DATETIME NOT NULL, PRIMARY KEY (`db_version`))\";\n+\tprivate final String oraCreate = \"CREATE TABLE \\\"DB_VERSION\\\" ( \\\"DB_VERSION\\\" INTEGER NOT NULL , \\\"DATE_UPDATE\\\" TIMESTAMP NOT NULL, PRIMARY KEY (\\\"DB_VERSION\\\") )\";\n+\tprivate final String msCreate  = \"CREATE TABLE db_version (\tdb_version int NOT NULL , date_update datetime NOT NULL, PRIMARY KEY (db_version) )\";\n+\n+\tprivate final String select = \"SELECT count(*) as count_versions, max(db_version) AS db_version FROM db_version\";\n+\n+\n+\n+\tfinal boolean firstTimeStart;\n \t\n \t\n \tprivate StartupTasksExecutor() {\n \n+\t    insureDbVersionTable();\n+\t    Config.DB_VERSION = currentDbVersion();\n+        this.firstTimeStart = (Config.DB_VERSION==0);\n+\t    \n \t}\n \n-\tpublic static StartupTasksExecutor getInstance() {\n+\tpublic static synchronized StartupTasksExecutor getInstance() {\n \t\tif (executor == null)\n \t\t\texecutor = new StartupTasksExecutor();\n \t\treturn executor;\n \t}\n \n-\t/**\n-\t * Check which database we're using, and select the apropiate SQL. In a\n-\t * different method to avoid further clutter\n-\t */\n-\tprivate void setupSQL() {\n-\t\tif (DbConnectionFactory.isPostgres()) {\n-\t\t\tlock = pgLock;\n-\t\t\tcommit = pgCommit;\n-\t\t\tcreate = pgCreate;\n-\t\t\tselect = pgSelect;\n-\t\t}\n-\t\telse if (DbConnectionFactory.isMySql()) {\n-\t\t\tlock = myLock.toLowerCase();\n-\t\t\tcommit = myCommit.toLowerCase();\n-\t\t\tcreate = myCreate.toLowerCase();\n-\t\t\tselect = mySelect.toLowerCase();\n-\t\t}\n-\t\t\n-\t\telse if (DbConnectionFactory.isOracle()) {\n-\t\t\tlock = oraLock;\n-\t\t\tcommit = oraCommit;\n-\t\t\tcreate = oraCreate;\n-\t\t\tselect = oraSelect;\n-\t\t}\n-\t\t\n-\t\telse if (DbConnectionFactory.isMsSql()) {\n-\t\t\tlock = msLock;\n-\t\t\tcommit = msCommit;\n-\t\t\tcreate = msCreate;\n-\t\t\tselect = msSelect;\n-\t\t}\n-\t\t\n-\t\telse if(DbConnectionFactory.isH2()) {\n-\t\t    lock = h2Lock;\n-\t\t    commit = h2Commit;\n-\t\t    create = h2Create;\n-\t\t    select = h2Select;\n-\t\t}\n \n+\tprivate final String createTableSQL() {\n+\t    \n+\t       return (DbConnectionFactory.isPostgres()) \n+\t                        ? pgCreate\n+\t                        : DbConnectionFactory.isMySql() \n+\t                            ? myCreate \n+\t                            : DbConnectionFactory.isOracle()\n+\t                                ? oraCreate\n+\t                                : msCreate;\n \t}\n \n-\tpublic void executeUpgrades(String appLocation) throws DotDataException, DotRuntimeException {\n-\n-\t\tList<Class<?>> runOnce;\n-\t\tList<Class<?>> runAlways;\n-\t\tComparator<Class<?>> comparator = new Comparator<Class<?>>() {\n-\t\t\tpublic int compare(Class<?> o1, Class<?> o2) {\n-\t\t\t\treturn o1.getName().compareTo(o2.getName());\n-\t\t\t}\n-\t\t};\n-\t\ttry {\n-\t\t\trunOnce = TaskLocatorUtil.getStartupRunOnceTaskClasses();\n-\t\t\trunAlways = TaskLocatorUtil.getStartupRunAlwaysTaskClasses();\n-\t\t} catch (Exception e) {\n-\t\t\tthrow new DotRuntimeException(e.getMessage(), e);\n-\t\t}\n-\t\tCollections.sort(runOnce, comparator);\n-\t\tCollections.sort(runAlways, comparator);\n-\t\tLogger.debug(this.getClass(), \"Locking db_version table\");\n-\t\tsetupSQL();\n-\t\t//Integer currentVersion = null;\n-\t\tPreparedStatement update = null;\n-\t\tStatement statement = null;\n-\t\tResultSet resultSet = null;\n-\t\tConnection connection = null;\n-\n-\t\ttry {\n-\n-\t\t\tconnection = DbConnectionFactory.getDataSource().getConnection();\n-\t\t\tconnection.setAutoCommit(false);\n-\t\t\tstatement = connection.createStatement();\n-\n-\t\t\tupdate = connection\n-\t\t\t\t\t.prepareStatement(\"INSERT INTO db_version (db_version,date_update) VALUES (?,?)\");\n-\t\t\tstatement.execute(lock);\n-\t\t\tresultSet = statement\n-\t\t\t\t\t.executeQuery(select);\n-\t\t\tresultSet.next();\n-\t\t\tConfig.DB_VERSION = resultSet.getInt(\"db_version\");\n-\t\t} catch (SQLException e) {\n-\t\t\t// Maybe the table doesn't exist?\n-\t\t\tLogger.debug(this.getClass(), \"Trying to create db_version table\");\n-\t\t\ttry {\n-\t\t\t\tconnection.rollback();\n-\t\t\t\tif(DbConnectionFactory.isMySql()){\n-\t\t\t\t\tstatement.execute(\"SET \" + DbConnectionFactory.getMySQLStorageEngine() + \"=INNODB\");\n-\t\t\t\t}\n-\t\t\t\tstatement.execute(create);\n-\t\t\t\tif(update==null) {\n-\t\t\t\t    // looks like H2 do an early table name check\n-\t\t\t\t    update = connection.prepareStatement(\"INSERT INTO db_version (db_version,date_update) VALUES (?,?)\");\n-\t\t\t\t}\n-\t\t\t\tupdate.setInt(1, 0);\n-\t\t\t\tDate date = new Date(Calendar.getInstance().getTimeInMillis());\n-\t\t\t\tupdate.setDate(2, date);\n-\t\t\t\tupdate.execute();\n-\t\t\t\tconnection.commit();\n-\n-\t\t\t\tLogger\n-\t\t\t\t\t\t.debug(this.getClass(),\n-\t\t\t\t\t\t\t\t\"Table db_version created.  Trying to lock db_table again.\");\n-\t\t\t\tstatement.execute(lock);\n-\t\t\t\tresultSet = statement\n-\t\t\t\t\t\t.executeQuery(select);\n-\n-\t\t\t\tresultSet.next();\n-\t\t\t\tConfig.DB_VERSION = resultSet.getInt(\"db_version\");\n-\n-\t\t\t} catch (SQLException e2) {\n-\t\t\t\tLogger.fatal(this.getClass(),\n-\t\t\t\t\t\t\"Locking of db_version table failed: \"\n-\t\t\t\t\t\t\t\t+ e2.getMessage());\n-\t\t\t\tthrow new DotRuntimeException(\n-\t\t\t\t\t\t\"Locking of db_version table failed: \"\n-\t\t\t\t\t\t\t\t+ e2.getMessage(), e2);\n-\t\t\t}\n-\n-\t\t}\n-\t\tLogger.debug(this.getClass(), \"Locking db_version succeeded\");\n-\n-\t\tboolean firstTimeStart = false;\n-\t\tString name = null;\n-\t\ttry {\n-\t\t\tLogger.info(this, \"Starting startup tasks.\");\n-\t\t\tHibernateUtil.startTransaction();\n-\n-\t\t\tfor (Class<?> c : runAlways) {\n-\t\t\t\tname = c.getCanonicalName();\n-\t\t\t\tname = name.substring(name.lastIndexOf(\".\") + 1);\n-\t\t\t\tif (StartupTask.class.isAssignableFrom(c)) {\n-\t\t\t\t\tStartupTask task;\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\ttask = (StartupTask) c.newInstance();\n-\t\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\t\tthrow new DotRuntimeException(e.getMessage(), e);\n-\t\t\t\t\t}\n-\t\t\t\t\tHibernateUtil.startTransaction();\n-\t\t\t\t\tif (task.forceRun()) {\n-\t\t\t\t\t\tHibernateUtil.closeAndCommitTransaction();\n-\t\t\t\t\t\tHibernateUtil.startTransaction();\n-\t\t\t\t\t\tLogger.info(this, \"Running: \" + name);\n-\t\t\t\t\t\ttask.executeUpgrade();\n-\t\t\t\t\t\tif(name.equals(\"Task00001LoadSchema\")){\n-\t\t\t\t\t\t\tfirstTimeStart = true;\n-\t\t\t\t\t\t}\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tLogger.info(this, \"Not running: \" + name);\n-\t\t\t\t\t}\n-\t\t\t\t\tHibernateUtil.closeAndCommitTransaction();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tLogger.info(this, \"Finishing startup tasks.\");\n-\t\t} catch (Throwable e) {\n-\t\t\tHibernateUtil.rollbackTransaction();\n-\t\t\tLogger.fatal(this, \"Unable to execute the upgrade task : \" + name, e);\n-\t    if(Config.getBooleanProperty(\"SYSTEM_EXIT_ON_STARTUP_FAILURE\", true)){\n-\t      e.printStackTrace();\n-\t      System.exit(1);\n-\t    }\n-\t\t} finally {\n-\t\t\t// This will commit the changes and close the connection\n-\t\t\tHibernateUtil.closeSession();\n-\t\t\ttry {\n-\t\t\t    update.close();\n-//\t\t\t    conn.close();\n-\t\t\t} catch(Exception exx) { /* Ignore this */ }\n-\t\t}\n-\n-\t\tLogger.info(this, \"Starting upgrade tasks.\");\n-\n-\t\tLogger.info(this, \"Database version: \" + Config.DB_VERSION);\n-\n-\t\tname = null;\n-\t\t//HibernateUtil.startTransaction();\n-\t\ttry {\n-\t\t\tif(runOnce.size() > 0)\n-\t\t\t\tReindexThread.pause();\n-\t\t\tfor (Class<?> c : runOnce) {\n-\t\t\t\tname = c.getCanonicalName();\n-\t\t\t\tname = name.substring(name.lastIndexOf(\".\") + 1);\n-\t\t\t\tString id = name.substring(4, 9);\n-\t\t\t\ttry {\n-\t\t\t\t\tint taskId = Integer.parseInt(id);\n-\t\t\t\t\tif (StartupTask.class.isAssignableFrom(c)\n-\t\t\t\t\t\t\t&& taskId > Config.DB_VERSION) {\n-\t\t\t\t\t\tStartupTask task;\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\ttask = (StartupTask) c.newInstance();\n-\t\t\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\t\t\tthrow new DotRuntimeException(e.getMessage(), e);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\t//HibernateUtil.startTransaction();\n-\n-\t\t\t\t\t\tif (!firstTimeStart && task.forceRun()) {\n-\t\t\t\t\t\t\tHibernateUtil.closeAndCommitTransaction();\n-\t\t\t\t\t\t\tHibernateUtil.startTransaction();\n-\t\t\t\t\t\t\tLogger.info(this, \"Running: \" + name);\n-\t\t\t\t\t\t\tif(name.equals(\"Task00250UpdateMysqlTablesToINNODB\")){\n-\t\t\t\t\t\t\t\tstatement = connection.createStatement();\n-\t\t\t\t\t\t\t\tstatement.execute(commit);\n-\t\t\t\t\t\t\t\ttask.executeUpgrade();\n-\t\t\t\t\t\t\t\tstatement = connection.createStatement();\n-\t\t\t\t\t\t\t\tstatement.execute(lock);\n-\t\t\t\t\t\t\t}else{\n-\t\t\t\t\t\t\t  task.executeUpgrade();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} \n-\t\t\t\t\t\t// Nothing to execute, or the task ran ok so bump\n-\t\t\t\t\t\t// the db version.\n-\t\t\t\t\t\ttry {\n-//\t\t\t\t\t\t    conn = DbConnectionFactory.getDataSource().getConnection();\n-\t\t\t\t\t\t\tif (connection != null && connection.isClosed()) {\n-\t\t\t\t\t\t\t\tconnection = DbConnectionFactory.getDataSource().getConnection();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t    connection.setAutoCommit(true);\n-\t\t\t\t\t\t    update = connection.prepareStatement(\"INSERT INTO db_version (db_version,date_update) VALUES (?,?)\");\n-    \t\t\t\t\t\tupdate.setInt(1, taskId);\n-    \t\t\t\t\t\tDate date = new Date(Calendar.getInstance().getTimeInMillis());\n-    \t\t\t\t\t\tupdate.setDate(2, date);\n-    \t\t\t\t\t\tupdate.execute();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tfinally {\n-//\t\t\t\t\t\t\tstatement.execute(commit);\n-\t\t\t\t\t\t    update.close();\n-//\t\t\t\t\t\t    conn.close();\n-\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\tLogger.info(this, \"Database upgraded to version: \"\n-\t\t\t\t\t\t\t\t+ taskId);\n-\t\t\t\t\t\tHibernateUtil.closeAndCommitTransaction();\n-\n-\t\t\t\t\t}\n-\t\t\t\t} catch (NumberFormatException e) {\n-\t\t\t\t\tLogger\n-\t\t\t\t\t\t\t.error(\n-\t\t\t\t\t\t\t\t\tthis,\n-\t\t\t\t\t\t\t\t\t\"Class \"\n-\t\t\t\t\t\t\t\t\t\t\t+ name\n-\t\t\t\t\t\t\t\t\t\t\t+ \" has invalid name or shouldn't be in the tasks package.\");\n-\n-\t\t\t\t}\n-\t\t\t}\n-\t\n-\t\t\tReindexThread.unpause();\n-\t\t\t\n-\t\t} catch (Throwable e) {\n-\t\t\tHibernateUtil.rollbackTransaction();\n-      if(Config.getBooleanProperty(\"SYSTEM_EXIT_ON_STARTUP_FAILURE\", true)){\n-        e.printStackTrace();\n-        System.exit(1);\n-      }\n-\t\t\tthrow new DotDataException(\"Unable to execute startup task : \",e);\n-\t\t} finally {\n-\t\t\t// This will commit the changes and close the connection\n-\t\t\tHibernateUtil.closeSession();\n-\t\t\t\n-\t\t\t// DOTCMS-4352\n-\t\t\ttry {\n-\t\t\t\tif(connection != null && !connection.isClosed()){\n-\t\t\t\t\tStatement s1 = connection.createStatement();\n-\t\t\t\t\tif(DbConnectionFactory.isMySql()){\n-\t\t\t\t\t\ts1.execute(commit);\n-\t\t\t\t\t}\n-\t\t\t\t\tif(!connection.getAutoCommit()){\n-\t\t\t\t\t\tconnection.commit();\n-\t\t\t\t\t}\n-\t\t\t\t\tconnection.close();\n-\t\t\t\t}\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tLogger.debug(StartupTasksExecutor.class, \"Exception: \"\n-\t\t\t\t\t\t+ e.getMessage(), e);\n-\t\t\t\tthrow new DotDataException(\n-\t\t\t\t\t\t\"Exception finishing upgrade tasks: \" + e.getMessage(),\n-\t\t\t\t\t\te);\n-\t\t\t} finally {\n-\n-\t\t\t\tCloseUtils.closeQuietly(connection);\n-\t\t\t}\n-\t\t\tLogger.info(this, \"Finishing upgrade tasks.\");\n-\t\t}\n-\n-\t}\n+    /**\n+     * This will create the db version table if it does not already exist\n+     * @return\n+     */\n+\tprivate boolean insureDbVersionTable() {\n+\n+        try {\n+            currentDbVersion();\n+            return true;\n+\n+        } catch (Exception e) {\n+            return createDbVersionTable();\n+        }\n+\n+    }\n+    \n+    /**\n+     * Runs with a separate DB connection\n+     * @return\n+     */\n+    private int currentDbVersion() {\n+        try (Connection conn = DbConnectionFactory.getDataSource().getConnection()) {\n+            Map<String,Object> results =  new DotConnect().setSQL(select).loadObjectResults().get(0);\n+            return  ((Long) results.get(\"count_versions\"))>0\n+                        ? ((int) results.get(\"db_version\"))\n+                        : 0;\n+\n+        } catch (Exception e) {\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+    \n+    /**\n+     * Runs with a separate DB connection\n+     * @return\n+     */\n+    private boolean createDbVersionTable() {\n+\n+        try (Connection conn = DbConnectionFactory.getDataSource().getConnection()) {\n+            new DotConnect().setSQL(createTableSQL()).loadResult(conn);\n+            return true;\n+\n+        } catch (Exception e) {\n+            Logger.debug(this.getClass(), e.getMessage(),e);\n+            throw new DotRuntimeException(e);\n+        }\n+\n+    }\n+    \n+    \n+    public void executeStartUpTasks() throws DotDataException {\n+        \n+        Logger.debug(this.getClass(), \"Running Startup Tasks\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3c0a3969a2d16735af2228948c4d307a41f07491"}, "originalPosition": 431}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "009455d312188a33f673843db0bc84c4b39368b9", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/009455d312188a33f673843db0bc84c4b39368b9", "committedDate": "2020-06-09T17:41:27Z", "message": "#18576 allow starter indexing to finish"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "730d2887abcda3437f64c23123ce1499725c2f6f", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/730d2887abcda3437f64c23123ce1499725c2f6f", "committedDate": "2020-06-09T23:25:23Z", "message": "#18576 starter imports cleanly"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9347cf6dbdfa5122241d59a7edc1c640f4140760", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/9347cf6dbdfa5122241d59a7edc1c640f4140760", "committedDate": "2020-06-10T02:33:05Z", "message": "#18576 messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "414c617ad2102bd45970701cfc98e7e1ca9fcb0b", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/414c617ad2102bd45970701cfc98e7e1ca9fcb0b", "committedDate": "2020-06-10T14:41:22Z", "message": "#18576 now returning index stats"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0d34f4519e6392832c1df875537b7a6fcddc0bf", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/b0d34f4519e6392832c1df875537b7a6fcddc0bf", "committedDate": "2020-06-10T21:21:17Z", "message": "#18576 updating resource"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6b04c30b96ba304b708ea387e39679e2608f2c5", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/b6b04c30b96ba304b708ea387e39679e2608f2c5", "committedDate": "2020-06-11T19:47:36Z", "message": "#18576 add timeout on delete"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "571b3217069ee8ea3a5035c6b7d62e6a43d9c998", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/571b3217069ee8ea3a5035c6b7d62e6a43d9c998", "committedDate": "2020-06-11T21:00:44Z", "message": "#18576 async javascript refresh"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5054e9cf79e72cf693220dd02a7b8bc50cbf4290", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/5054e9cf79e72cf693220dd02a7b8bc50cbf4290", "committedDate": "2020-06-12T20:29:55Z", "message": "#18576 merging indexresource and esindexresource"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f76a618a6522240dcb47c05fa06f54300dbb71d", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/9f76a618a6522240dcb47c05fa06f54300dbb71d", "committedDate": "2020-06-12T20:42:47Z", "message": "#18576 fixing log error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8e897273b81d909230673a8a16d90a61c00b1ee", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/b8e897273b81d909230673a8a16d90a61c00b1ee", "committedDate": "2020-06-12T20:44:42Z", "message": "Merge remote-tracking branch 'origin/master' into issue-18576-starter-xml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64572f8e017d5a724a68d88fec1967ab58c98cb1", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/64572f8e017d5a724a68d88fec1967ab58c98cb1", "committedDate": "2020-06-12T21:51:00Z", "message": "#18576 fixing bad data"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebe24613525c98a72bffe648d03516ec0abac370", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/ebe24613525c98a72bffe648d03516ec0abac370", "committedDate": "2020-06-15T14:57:18Z", "message": "#18576 large customer reindex completed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6734a119922c9c633302b3aa72c9d06a713f08e9", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/6734a119922c9c633302b3aa72c9d06a713f08e9", "committedDate": "2020-06-15T14:58:06Z", "message": "#18576 display options for building indexes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0810fa826fda333aafc51563c518a807f91e01f3", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/0810fa826fda333aafc51563c518a807f91e01f3", "committedDate": "2020-06-15T15:17:09Z", "message": "#18576 removing unneeded commit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7b5526b98605b19c1d96ab42408e1940d86c0e4", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/b7b5526b98605b19c1d96ab42408e1940d86c0e4", "committedDate": "2020-06-15T18:01:55Z", "message": "#18576 get indexes for tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f67450585871d51258572e43548af859ba260aa", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/1f67450585871d51258572e43548af859ba260aa", "committedDate": "2020-06-16T13:14:02Z", "message": "Merge remote-tracking branch 'origin/master' into issue-18576-starter-xml"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "095d6f5cd8d9c892a16dd42408326bd056004deb", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/095d6f5cd8d9c892a16dd42408326bd056004deb", "committedDate": "2020-06-16T14:04:22Z", "message": "#18576 postman tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2da096eef496acc16ca6cd6aa2c3fcce5c508fc", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/e2da096eef496acc16ca6cd6aa2c3fcce5c508fc", "committedDate": "2020-06-16T16:05:53Z", "message": "#18576 fixes class cast exception when the db returns a long rather than an int - e.g. count(*) as test returns a long sometimes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93edfe8d13ba811d7db04a716cbe4b2a40e1ae14", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/93edfe8d13ba811d7db04a716cbe4b2a40e1ae14", "committedDate": "2020-06-16T16:07:27Z", "message": "#18576 fixes tika to not rebuild/save fileasset metadata unless needed"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be0851d773c097bcad893542b1a626a4869cbedd", "author": {"user": {"login": "fabrizzio-dotCMS", "name": "Fabrizzio Araya"}}, "url": "https://github.com/dotCMS/core/commit/be0851d773c097bcad893542b1a626a4869cbedd", "committedDate": "2020-06-16T21:04:12Z", "message": "#18576 fix on broken delete sql"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0", "author": {"user": {"login": "fabrizzio-dotCMS", "name": "Fabrizzio Araya"}}, "url": "https://github.com/dotCMS/core/commit/47c5aa37695a630085c8d2f3fa49d093322fb3a0", "committedDate": "2020-06-16T23:22:54Z", "message": "#18576  restoring cache and optimize endpoints on the ESIndexResource"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NDcy", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959472", "createdAt": "2020-06-16T23:29:04Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOTowNFrOGkwjIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOTowNFrOGkwjIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzM0NA==", "bodyText": "Issue found: Position literals first in String comparisons for EqualsIgnoreCase", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197344", "createdAt": "2020-06-16T23:29:04Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/ImportStarterUtil.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+package com.dotmarketing.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+import org.apache.commons.beanutils.BeanUtils;\n+import com.dotcms.business.WrapInTransaction;\n+import com.dotcms.contenttype.util.ContentTypeImportExportUtil;\n+import com.dotcms.publishing.BundlerUtil;\n+import com.dotcms.repackage.net.sf.hibernate.HibernateException;\n+import com.dotcms.repackage.net.sf.hibernate.persister.AbstractEntityPersister;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.beans.MultiTree;\n+import com.dotmarketing.beans.Tree;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.Layout;\n+import com.dotmarketing.business.LayoutsRoles;\n+import com.dotmarketing.business.PortletsLayouts;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.UsersRoles;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.logConsole.model.LogMapperRow;\n+import com.dotmarketing.portlets.containers.model.Container;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+import com.dotmarketing.portlets.folders.business.FolderAPI;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.links.model.Link;\n+import com.dotmarketing.portlets.rules.util.RulesImportExportUtil;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.portlets.templates.model.Template;\n+import com.dotmarketing.portlets.workflows.util.WorkflowImportExportUtil;\n+import com.dotmarketing.startup.runalways.Task00004LoadStarter;\n+import com.liferay.portal.SystemException;\n+import com.liferay.portal.ejb.CompanyManagerUtil;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.Image;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.Base64;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.EncryptorException;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+\n+\n+/**\n+ * This utility is part of the {@link Task00004LoadStarter} task, which fills the empty dotCMS\n+ * tables on a fresh install with information regarding the Demo Site that the application ships\n+ * with. This allows users to be able to log into the dotCMS back-end and interact with the system\n+ * before adding their own custom content.\n+ *\n+ * @author Jason Tesser\n+ * @version 1.6\n+ *\n+ */\n+public class ImportStarterUtil {\n+\n+    /**\n+     * The path where tmp files are stored. This gets wiped alot\n+     */\n+    private String backupTempFilePath = ConfigUtils.getBackupPath() + File.separator + \"temp\";\n+    private ArrayList<String> classesWithIdentity = new ArrayList<String>();\n+    private Map<String, String> sequences;\n+    private Map<String, String> tableIDColumns;\n+    private Map<String, String> tableNames;\n+    private final String assetPath;\n+\n+\n+    private final List<File> tempFiles;\n+\n+    private static final String SYSTEM_FOLDER_PATH = FolderAPI.SYSTEM_FOLDER_PARENT_PATH;\n+\n+    private final File starterZip;\n+\n+\n+    public ImportStarterUtil(File starterZipFile) {\n+        this.starterZip = starterZipFile;\n+\n+        this.assetPath = ConfigUtils.getAbsoluteAssetsRootPath();\n+        if (!this.validateZipFile()) {\n+            throw new DotRuntimeException(\"starter data invalid\");\n+        }\n+        final File backTemporalFile = new File(getBackupTempFilePath());\n+        \n+        tempFiles = Arrays.asList(backTemporalFile.listFiles()).stream().sorted().collect(Collectors.toList());\n+        tempFiles.removeIf(f -> f.getName().endsWith(\"Counter.xml\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Dashboard\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".FixAudit_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".UserProxy_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".PluginProperty_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Plugin_\"));\n+\n+\n+\n+        classesWithIdentity.add(\"Permission\");\n+        classesWithIdentity.add(\"UsersToDelete\");\n+        tableNames = new HashMap<String, String>();\n+        tableNames.put(\"Permission\", \"permission\");\n+        tableNames.put(\"UsersToDelete\", \"users_to_delete\");\n+\n+        if (DbConnectionFactory.isPostgres() || DbConnectionFactory.isOracle()) {\n+            sequences = new HashMap<String, String>();\n+            sequences.put(\"permission\", \"permission_seq\");\n+            sequences.put(\"users_to_delete\", \"user_to_delete_seq\");\n+            tableIDColumns = new HashMap<String, String>();\n+            tableIDColumns.put(\"permission\", \"id\");\n+            tableIDColumns.put(\"users_to_delete\", \"id\");\n+\n+        }\n+    }\n+\n+    /**\n+     * Takes a ZIP file from the /temp directory to restore dotCMS data. Currently, it will blow away\n+     * all current data. This method cannot currently be run in a transaction. For performance reasons\n+     * with DB drivers and connections it closes the session every so often.\n+     *\n+     * @param out - A print writer for output.\n+     * @throws IOException\n+     * @throws Exception\n+     */\n+    @WrapInTransaction\n+    public void doImport() throws Exception {\n+\n+\n+\n+        Logger.info(this, \"Found \" + tempFiles.size() + \" files to import\");\n+\n+\n+        deleteDotCMS();\n+        \n+\n+        for (File file : endsWith(\"Company.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        List<Role> roles = new ArrayList<Role>();\n+\n+        for (File file : startsWith(\"com.dotmarketing.business.Role_\")) {\n+            roles.addAll((List<Role>) BundlerUtil.xmlToObject(file));\n+        }\n+\n+        Collections.sort(roles);\n+\n+\n+        for (Role role : roles) {\n+            HibernateUtil _dh = new HibernateUtil(Role.class);\n+            String id = HibernateUtil.getSession().getSessionFactory().getClassMetadata(Role.class).getIdentifierPropertyName();\n+\n+            if(UtilMethods.isSet(role.getRoleKey())) {\n+               List<Map<String,Object>>  matches= new DotConnect().setSQL(\"select * from cms_role where role_key =?\").addParam(role.getRoleKey()).loadObjectResults();\n+               Logger.info(this.getClass(), \"roleKey:\" +role.getRoleKey() + \" = \" + matches.size() );\n+            }\n+\n+            _dh.saveWithPrimaryKey(role, role.getId());\n+            HibernateUtil.getSession().flush();\n+        }\n+\n+        for (File file : endsWith(User.class.getCanonicalName() + \".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(UsersRoles.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(Layout.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        \n+        for (File file : contains(PortletsLayouts.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        for (File file : endsWith(\"LogsMappers.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(LayoutsRoles.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        \n+        \n+        for (File file : contains(Language.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        /*\n+         * Because of the parent check we do at db we need to import folder identifiers first but for the\n+         * same reason we need to sort them first by parent_path\n+         */\n+        final List<Identifier> folderIdents = new ArrayList<Identifier>();\n+        final List<Identifier> otherIdents = new ArrayList<Identifier>();\n+\n+        List<File> identifiers = contains(Identifier.class.getCanonicalName());\n+        // collecting all folder identifiers\n+        for (File ff : identifiers) {\n+            List<Identifier> idents = (List<Identifier>) BundlerUtil.xmlToObject(ff);\n+            for (Identifier ident : idents) {\n+                if (ident.getAssetType().equals(\"folder\")) {\n+                    folderIdents.add(ident);\n+                }else {\n+                    otherIdents.add(ident);\n+                }\n+            }\n+        }\n+\n+        // sorting folder identifiers by parent path in order to pass parent check\n+        Collections.sort(folderIdents, new Comparator<Identifier>() {\n+            public int compare(Identifier o1, Identifier o2) {\n+                return o1.getParentPath().compareTo(o2.getParentPath());\n+            }\n+        });\n+\n+        // saving folder identifiers\n+        for (Identifier ident : folderIdents) {\n+            if (!SYSTEM_FOLDER_PATH.equals(ident.getParentPath())) {\n+                ident.setParentPath(ident.getParentPath());\n+                ident.setAssetName(ident.getAssetName());\n+            }\n+            Logger.info(this, \"Importing folder path \" + ident.getParentPath() + ident.getAssetName());\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+        // now we need to save all remaining identifiers (folders already added)\n+        for (final Identifier ident : otherIdents) {\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+\n+\n+        // we store here defaultFileType for every folder\n+        // because of mutual folder <--> structure dependency\n+        final Map<String, String> fileTypesInodes = new HashMap<String, String>();\n+\n+        // now we can import folders\n+        for (File ff : contains(Folder.class.getCanonicalName())) {\n+            try {\n+                doXMLFileImport(ff, new ObjectFilter() {\n+                    public boolean includeIt(Object obj) {\n+                        Folder f = (Folder) obj;\n+                        fileTypesInodes.put(f.getInode(), f.getDefaultFileType());\n+                        f.setDefaultFileType(null);\n+                        return true;\n+                    }\n+                });\n+            } catch (Exception e) {\n+                Logger.error(this, \"Unable to load \" + ff.getName() + \" : \" + e.getMessage(), e);\n+            }\n+        }\n+\n+\n+        // we need content types before contentlets\n+        // but content types have references to folders and hosts identifiers\n+        // so, here is the place to do it\n+        for (File file : endsWith(ContentTypeImportExportUtil.CONTENT_TYPE_FILE_EXTENSION)) {\n+            new ContentTypeImportExportUtil().importContentTypes(file);\n+        }\n+\n+        // updating file_type on folder now that structures were added\n+        DotConnect dc = new DotConnect();\n+        for (Entry<String, String> entry : fileTypesInodes.entrySet()) {\n+            dc.setSQL(\"update folder set default_file_type=? where inode=?\");\n+            dc.addParam(entry.getValue());\n+            dc.addParam(entry.getKey());\n+            dc.loadResult();\n+        }\n+\n+\n+        for (File file : contains(Relationship.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // We have all identifiers, structures and users. Ready to import contentlets!\n+        for (File file : contains(Contentlet.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        for (File file : contains(Template.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.TemplateContainers_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Link.class.getCanonicalName() + \"_\")) {\n+\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Container.class.getCanonicalName()+ \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.ContainerStructure_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.Tree_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // workflow schemas need to come before permissions\n+        for (File file : contains(\"WorkflowSchemeImportExportObject.json\")) {\n+            WorkflowImportExportUtil.getInstance().importWorkflowExport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.Permission_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // finally as all assets are loaded we can import versionInfo files\n+        for (File file : contains(\"VersionInfo_\")) {\n+\n+            doXMLFileImport(file);\n+\n+        }\n+        // We install rules after Version info.\n+        for (File file : contains(\"RuleImportExportObject.json\")) {\n+            RulesImportExportUtil.getInstance().importRules(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowTask_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowHistory_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowComment_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkFlowTaskFiles_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.tag.model.Tag_\")) {\n+            doXMLFileImport(file);\n+        }\n+        // Image, Portlet, Multitree, category\n+        for (File file : endsWith(\".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        cleanUpDBFromImport();\n+        Optional<File> assetDir = tempFiles.stream().filter(f -> (\"asset\".equals(f.getName())||\"assets\".equals(f.getName())) && f.isDirectory()).findAny();\n+        if (assetDir.isPresent()) {\n+            copyAssetDir(assetDir.get());\n+        }\n+        Logger.info(ImportStarterUtil.class, \"Done Importing\");\n+        deleteTempFiles();\n+\n+\n+\n+    }\n+\n+    /**\n+     *\n+     * @param fromAssetDir\n+     * @throws IOException\n+     */\n+    private void copyAssetDir(File fromAssetDir) throws IOException {\n+        File ad = new File(assetPath);\n+\n+        ad.mkdirs();\n+        String[] fileNames = fromAssetDir.list();\n+        for (int i = 0; i < fileNames.length; i++) {\n+            File f = new File(fromAssetDir.getPath() + File.separator + fileNames[i]);\n+            if (f.getName().equals(\".svn\")) {\n+                continue;\n+            }\n+            if (f.getName().equals(\"license.dat\")) {\n+                continue;\n+            }\n+            if (f.isDirectory()) {\n+                FileUtil.copyDirectory(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            } else {\n+                FileUtil.copyFile(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deletes all files from the backupTempFilePath\n+     */\n+    private void deleteTempFiles() {\n+        File f = new File(backupTempFilePath);\n+\n+        FileUtil.deltree(f, true);\n+    }\n+\n+\n+\n+    private void deleteTable(final String table) {\n+\n+        final DotConnect dotConnect = new DotConnect();\n+        dotConnect.setSQL(\"delete from \" + table);\n+        dotConnect.getResult();\n+    }\n+\n+    interface ObjectFilter {\n+        boolean includeIt(Object obj);\n+    }\n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     */\n+    private void doXMLFileImport(File f) throws Exception {\n+        doXMLFileImport(f, null);\n+    }\n+    \n+    \n+    \n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     * @param filter\n+     * @throws DotDataException\n+     * @throws HibernateException\n+     * @throws EncryptorException\n+     * @throws SQLException \n+     * @throws DotSecurityException \n+     * @throws DuplicateUserException \n+     * @throws NoSuchMethodException \n+     * @throws InvocationTargetException \n+     * @throws IllegalAccessException \n+     */\n+    private void doXMLFileImport(File f, ObjectFilter filter) throws Exception {\n+        if (f == null) {\n+            return;\n+        }\n+\n+\n+\n+            Class _importClass = null;\n+            HibernateUtil _dh = null;\n+\n+            boolean counter = false;\n+            boolean image = false;\n+            boolean portlet = false;\n+            boolean logsMappers = false;\n+\n+\n+            Pattern classNamePattern = Pattern.compile(\"_[0-9]{8}\");\n+            Logger.info(this, \"**** Importing the file: \" + f + \" *****\");\n+\n+            /* if we have a multipart import file */\n+            \n+            final String _className = classNamePattern.matcher(f.getName()).find() \n+                   ?  f.getName().substring(0, f.getName().lastIndexOf(\"_\"))\n+                   :   f.getName().substring(0, f.getName().lastIndexOf(\".\"));\n+\n+\n+            if (_className.equals(\"Counter\")) {\n+                counter = true;\n+            } else if (_className.equals(\"Image\")) {\n+                image = true;\n+            } else if (_className.equals(\"Portlet\")) {\n+                portlet = true;\n+            } else if (_className.equals(\"LogsMappers\")) {\n+                logsMappers = true;\n+            } else {\n+                try {\n+                    _importClass = Class.forName(_className);\n+                } catch (Exception e) {\n+                    Logger.error(this, \"Class not found \" + _className);\n+                    return;\n+                }\n+            }\n+\n+            Logger.info(this, \"Importing:\\t\" + _className);\n+\n+\n+            List l = new ArrayList();\n+\n+            List all = (List) BundlerUtil.xmlToObject(f);\n+            if (filter != null) {\n+                for (Object obj : all)\n+                    if (filter.includeIt(obj))\n+                        l.add(obj);\n+            } else {\n+                l = all;\n+            }\n+\n+\n+            Logger.info(this, \"Found :\\t\" + l.size() + \" \" + _className + \"(s)\");\n+            if (counter) {\n+                for (int j = 0; j < l.size(); j++) {\n+                    final HashMap<String, String> dcResults = (HashMap<String, String>) l.get(j);\n+\n+                    DotConnect dc = new DotConnect();\n+                    dc.setSQL(\"insert into counter values (?,?)\");\n+                    dc.addParam(dcResults.get(\"name\"));\n+                    dc.addParam(Integer.valueOf(dcResults.get(\"currentid\")));\n+                    dc.loadResults();\n+\n+                }\n+            } else if (image) {\n+                /*\n+                 * The changes in this part were made for Oracle databases. Oracle has problems when getString()\n+                 * method is called on a LONG field on an Oracle database. Because of this, the object is loaded\n+                 * from liferay and DotConnect is not used\n+                 */\n+                for (int j = 0; j < l.size(); j++) {\n+                    final Image im = (Image) l.get(j);\n+\n+                    DotConnect dc = new DotConnect();\n+                    dc.setSQL(\"insert into image values (?,?)\");\n+                    if (!UtilMethods.isSet(im.getImageId()) && DbConnectionFactory.isOracle()) {\n+                        return;\n+                    }\n+                    dc.addParam(im.getImageId());\n+                    dc.addParam(im.getText());\n+                    dc.loadResults();\n+\n+                }\n+            } else if (portlet) {\n+                for (int j = 0; j < l.size(); j++) {\n+                    final HashMap<String, String> dcResults = (HashMap<String, String>) l.get(j);\n+\n+                    DotConnect dc = new DotConnect();\n+                    StringBuffer sb = new StringBuffer(\"insert into portlet values (?,?,?,?,\");\n+                    if (dcResults.get(\"narrow\").equalsIgnoreCase(\"f\") || dcResults.get(\"narrow\").equalsIgnoreCase(\"false\")\n+                                    || dcResults.get(\"narrow\").equalsIgnoreCase(\"0\")\n+                                    || dcResults.get(\"narrow\").equals(DbConnectionFactory.getDBFalse()))\n+                        sb.append(DbConnectionFactory.getDBFalse() + \",?,\");\n+                    else\n+                        sb.append(DbConnectionFactory.getDBTrue() + \",?,\");\n+                    if (dcResults.get(\"active_\").equalsIgnoreCase(\"f\") || dcResults.get(\"active_\").equalsIgnoreCase(\"false\")\n+                                    || dcResults.get(\"active_\").equalsIgnoreCase(\"0\")\n+                                    || dcResults.get(\"active_\").equals(DbConnectionFactory.getDBFalse()))\n+                        sb.append(DbConnectionFactory.getDBFalse() + \")\");\n+                    else\n+                        sb.append(DbConnectionFactory.getDBTrue() + \")\");\n+                    dc.setSQL(sb.toString());\n+                    dc.addParam(dcResults.get(\"portletid\"));\n+                    dc.addParam(dcResults.get(\"groupid\"));\n+                    dc.addParam(dcResults.get(\"companyid\"));\n+                    dc.addParam(dcResults.get(\"defaultpreferences\"));\n+                    dc.addParam(dcResults.get(\"roles\"));\n+                    dc.loadResults();\n+\n+                }\n+            } else if (logsMappers) {\n+                for (int j = 0; j < l.size(); j++) {\n+                    final LogMapperRow logMapperRow = (LogMapperRow) l.get(j);\n+\n+                    DotConnect dc = new DotConnect();\n+                    dc.setSQL(\"insert into log_mapper values (?,?,?)\");\n+                    dc.addParam(logMapperRow.getEnabled() ? 1 : 0);\n+                    dc.addParam(logMapperRow.getLog_name());\n+                    dc.addParam(logMapperRow.getDescription());\n+                    dc.loadResults();\n+\n+                }\n+            } else if (_importClass.equals(User.class)) {\n+                for (int j = 0; j < l.size(); j++) {\n+                    User u = (User) l.get(j);\n+                    u.setModified(true);\n+                    if (!u.isDefaultUser() && !u.getUserId().equals(\"system\")) {\n+                        try {\n+                            User u1 = APILocator.getUserAPI().createUser(u.getUserId(), u.getEmailAddress());\n+                            u.setUserId(u1.getUserId());\n+                            u.setEmailAddress(u.getEmailAddress());\n+                        } catch (DuplicateUserException e) {\n+                            Logger.info(this, \"user already exists going to update\");\n+                            u = loadUserFromIdOrEmail(u);\n+                        }\n+\n+                        APILocator.getUserAPI().save(u, APILocator.getUserAPI().getSystemUser(), false);\n+                    } else {\n+                        Logger.info(this, \"\");\n+                    }\n+                }\n+            } else if (_importClass.equals(Company.class)) {\n+                for (int j = 0; j < l.size(); j++) {\n+                    Company c = (Company) l.get(j);\n+                    // github #16470 with support for custom starter.zips that have updated keys\n+                    if (\"liferay.com\".equals(c.getCompanyId())) {\n+                        continue;\n+                    }\n+                    c.setKey(Base64.objectToString(Encryptor.generateKey()));\n+\n+                    try {\n+                        c.setModified(true);\n+                        CompanyManagerUtil.updateCompany(c);\n+                    } catch (SystemException e) {\n+                        throw new DotDataException(\"Unable to load company\", e);\n+                    }\n+                }\n+            } else if (_importClass.equals(Language.class)) {\n+                for (Object aL : l) {\n+                    final Language lang = (Language) aL;\n+\n+\n+                    DotConnect dc = new DotConnect();\n+                    dc.setSQL(\"insert into language (id,language_code,country_code,language,country) values (?,?,?,?,?)\");\n+                    dc.addParam(lang.getId());\n+                    dc.addParam(lang.getLanguageCode());\n+                    dc.addParam(lang.getCountryCode());\n+                    dc.addParam(lang.getLanguage());\n+                    dc.addParam(lang.getCountry());\n+                    dc.loadResults();\n+\n+\n+                }\n+\n+            } else if (_importClass.equals(UsersRoles.class)) {\n+                for (Object role : l) {\n+                    final UsersRoles userRole = (UsersRoles) role;\n+\n+                    // upsert pattern for the user role\n+                    new DotConnect().setSQL(\"delete from users_cms_roles where user_id=? and role_id=?\")\n+                                    .addParam(userRole.getUserId())\n+                                    .addParam(userRole.getRoleId())\n+                                    .loadResult();\n+                    new DotConnect().setSQL(\"insert into users_cms_roles (id,user_id,role_id) values (?,?,?)\")\n+                                    .addParam(userRole.getId())\n+                                    .addParam(userRole.getUserId())\n+                                    .addParam(userRole.getRoleId())\n+                                    .loadResult();\n+\n+\n+\n+                }\n+\n+            }\n+\n+\n+\n+            else {\n+                String id;\n+                if (_importClass.equals(Relationship.class)) {\n+                    id = \"inode\";\n+                } else {\n+                    _dh = new HibernateUtil(_importClass);\n+                    id = HibernateUtil.getSession().getSessionFactory().getClassMetadata(_importClass)\n+                                    .getIdentifierPropertyName();\n+                    HibernateUtil.getSession().flush();\n+                }\n+\n+                boolean identityOn = false;\n+                String cName = _className.substring(_className.lastIndexOf(\".\") + 1);\n+                String tableName = \"\";\n+                if (classesWithIdentity.contains(cName) && DbConnectionFactory.isMsSql() && !cName.equalsIgnoreCase(\"inode\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 682}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NDgx", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959481", "createdAt": "2020-06-16T23:29:05Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOTowNlrOGkwjJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOTowNlrOGkwjJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzM1MQ==", "bodyText": "Issue found: Avoid variables with short names like f", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197351", "createdAt": "2020-06-16T23:29:06Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/ImportStarterUtil.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+package com.dotmarketing.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+import org.apache.commons.beanutils.BeanUtils;\n+import com.dotcms.business.WrapInTransaction;\n+import com.dotcms.contenttype.util.ContentTypeImportExportUtil;\n+import com.dotcms.publishing.BundlerUtil;\n+import com.dotcms.repackage.net.sf.hibernate.HibernateException;\n+import com.dotcms.repackage.net.sf.hibernate.persister.AbstractEntityPersister;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.beans.MultiTree;\n+import com.dotmarketing.beans.Tree;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.Layout;\n+import com.dotmarketing.business.LayoutsRoles;\n+import com.dotmarketing.business.PortletsLayouts;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.UsersRoles;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.logConsole.model.LogMapperRow;\n+import com.dotmarketing.portlets.containers.model.Container;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+import com.dotmarketing.portlets.folders.business.FolderAPI;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.links.model.Link;\n+import com.dotmarketing.portlets.rules.util.RulesImportExportUtil;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.portlets.templates.model.Template;\n+import com.dotmarketing.portlets.workflows.util.WorkflowImportExportUtil;\n+import com.dotmarketing.startup.runalways.Task00004LoadStarter;\n+import com.liferay.portal.SystemException;\n+import com.liferay.portal.ejb.CompanyManagerUtil;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.Image;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.Base64;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.EncryptorException;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+\n+\n+/**\n+ * This utility is part of the {@link Task00004LoadStarter} task, which fills the empty dotCMS\n+ * tables on a fresh install with information regarding the Demo Site that the application ships\n+ * with. This allows users to be able to log into the dotCMS back-end and interact with the system\n+ * before adding their own custom content.\n+ *\n+ * @author Jason Tesser\n+ * @version 1.6\n+ *\n+ */\n+public class ImportStarterUtil {\n+\n+    /**\n+     * The path where tmp files are stored. This gets wiped alot\n+     */\n+    private String backupTempFilePath = ConfigUtils.getBackupPath() + File.separator + \"temp\";\n+    private ArrayList<String> classesWithIdentity = new ArrayList<String>();\n+    private Map<String, String> sequences;\n+    private Map<String, String> tableIDColumns;\n+    private Map<String, String> tableNames;\n+    private final String assetPath;\n+\n+\n+    private final List<File> tempFiles;\n+\n+    private static final String SYSTEM_FOLDER_PATH = FolderAPI.SYSTEM_FOLDER_PARENT_PATH;\n+\n+    private final File starterZip;\n+\n+\n+    public ImportStarterUtil(File starterZipFile) {\n+        this.starterZip = starterZipFile;\n+\n+        this.assetPath = ConfigUtils.getAbsoluteAssetsRootPath();\n+        if (!this.validateZipFile()) {\n+            throw new DotRuntimeException(\"starter data invalid\");\n+        }\n+        final File backTemporalFile = new File(getBackupTempFilePath());\n+        \n+        tempFiles = Arrays.asList(backTemporalFile.listFiles()).stream().sorted().collect(Collectors.toList());\n+        tempFiles.removeIf(f -> f.getName().endsWith(\"Counter.xml\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Dashboard\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".FixAudit_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".UserProxy_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".PluginProperty_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Plugin_\"));\n+\n+\n+\n+        classesWithIdentity.add(\"Permission\");\n+        classesWithIdentity.add(\"UsersToDelete\");\n+        tableNames = new HashMap<String, String>();\n+        tableNames.put(\"Permission\", \"permission\");\n+        tableNames.put(\"UsersToDelete\", \"users_to_delete\");\n+\n+        if (DbConnectionFactory.isPostgres() || DbConnectionFactory.isOracle()) {\n+            sequences = new HashMap<String, String>();\n+            sequences.put(\"permission\", \"permission_seq\");\n+            sequences.put(\"users_to_delete\", \"user_to_delete_seq\");\n+            tableIDColumns = new HashMap<String, String>();\n+            tableIDColumns.put(\"permission\", \"id\");\n+            tableIDColumns.put(\"users_to_delete\", \"id\");\n+\n+        }\n+    }\n+\n+    /**\n+     * Takes a ZIP file from the /temp directory to restore dotCMS data. Currently, it will blow away\n+     * all current data. This method cannot currently be run in a transaction. For performance reasons\n+     * with DB drivers and connections it closes the session every so often.\n+     *\n+     * @param out - A print writer for output.\n+     * @throws IOException\n+     * @throws Exception\n+     */\n+    @WrapInTransaction\n+    public void doImport() throws Exception {\n+\n+\n+\n+        Logger.info(this, \"Found \" + tempFiles.size() + \" files to import\");\n+\n+\n+        deleteDotCMS();\n+        \n+\n+        for (File file : endsWith(\"Company.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        List<Role> roles = new ArrayList<Role>();\n+\n+        for (File file : startsWith(\"com.dotmarketing.business.Role_\")) {\n+            roles.addAll((List<Role>) BundlerUtil.xmlToObject(file));\n+        }\n+\n+        Collections.sort(roles);\n+\n+\n+        for (Role role : roles) {\n+            HibernateUtil _dh = new HibernateUtil(Role.class);\n+            String id = HibernateUtil.getSession().getSessionFactory().getClassMetadata(Role.class).getIdentifierPropertyName();\n+\n+            if(UtilMethods.isSet(role.getRoleKey())) {\n+               List<Map<String,Object>>  matches= new DotConnect().setSQL(\"select * from cms_role where role_key =?\").addParam(role.getRoleKey()).loadObjectResults();\n+               Logger.info(this.getClass(), \"roleKey:\" +role.getRoleKey() + \" = \" + matches.size() );\n+            }\n+\n+            _dh.saveWithPrimaryKey(role, role.getId());\n+            HibernateUtil.getSession().flush();\n+        }\n+\n+        for (File file : endsWith(User.class.getCanonicalName() + \".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(UsersRoles.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(Layout.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        \n+        for (File file : contains(PortletsLayouts.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        for (File file : endsWith(\"LogsMappers.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(LayoutsRoles.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        \n+        \n+        for (File file : contains(Language.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        /*\n+         * Because of the parent check we do at db we need to import folder identifiers first but for the\n+         * same reason we need to sort them first by parent_path\n+         */\n+        final List<Identifier> folderIdents = new ArrayList<Identifier>();\n+        final List<Identifier> otherIdents = new ArrayList<Identifier>();\n+\n+        List<File> identifiers = contains(Identifier.class.getCanonicalName());\n+        // collecting all folder identifiers\n+        for (File ff : identifiers) {\n+            List<Identifier> idents = (List<Identifier>) BundlerUtil.xmlToObject(ff);\n+            for (Identifier ident : idents) {\n+                if (ident.getAssetType().equals(\"folder\")) {\n+                    folderIdents.add(ident);\n+                }else {\n+                    otherIdents.add(ident);\n+                }\n+            }\n+        }\n+\n+        // sorting folder identifiers by parent path in order to pass parent check\n+        Collections.sort(folderIdents, new Comparator<Identifier>() {\n+            public int compare(Identifier o1, Identifier o2) {\n+                return o1.getParentPath().compareTo(o2.getParentPath());\n+            }\n+        });\n+\n+        // saving folder identifiers\n+        for (Identifier ident : folderIdents) {\n+            if (!SYSTEM_FOLDER_PATH.equals(ident.getParentPath())) {\n+                ident.setParentPath(ident.getParentPath());\n+                ident.setAssetName(ident.getAssetName());\n+            }\n+            Logger.info(this, \"Importing folder path \" + ident.getParentPath() + ident.getAssetName());\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+        // now we need to save all remaining identifiers (folders already added)\n+        for (final Identifier ident : otherIdents) {\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+\n+\n+        // we store here defaultFileType for every folder\n+        // because of mutual folder <--> structure dependency\n+        final Map<String, String> fileTypesInodes = new HashMap<String, String>();\n+\n+        // now we can import folders\n+        for (File ff : contains(Folder.class.getCanonicalName())) {\n+            try {\n+                doXMLFileImport(ff, new ObjectFilter() {\n+                    public boolean includeIt(Object obj) {\n+                        Folder f = (Folder) obj;\n+                        fileTypesInodes.put(f.getInode(), f.getDefaultFileType());\n+                        f.setDefaultFileType(null);\n+                        return true;\n+                    }\n+                });\n+            } catch (Exception e) {\n+                Logger.error(this, \"Unable to load \" + ff.getName() + \" : \" + e.getMessage(), e);\n+            }\n+        }\n+\n+\n+        // we need content types before contentlets\n+        // but content types have references to folders and hosts identifiers\n+        // so, here is the place to do it\n+        for (File file : endsWith(ContentTypeImportExportUtil.CONTENT_TYPE_FILE_EXTENSION)) {\n+            new ContentTypeImportExportUtil().importContentTypes(file);\n+        }\n+\n+        // updating file_type on folder now that structures were added\n+        DotConnect dc = new DotConnect();\n+        for (Entry<String, String> entry : fileTypesInodes.entrySet()) {\n+            dc.setSQL(\"update folder set default_file_type=? where inode=?\");\n+            dc.addParam(entry.getValue());\n+            dc.addParam(entry.getKey());\n+            dc.loadResult();\n+        }\n+\n+\n+        for (File file : contains(Relationship.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // We have all identifiers, structures and users. Ready to import contentlets!\n+        for (File file : contains(Contentlet.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        for (File file : contains(Template.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.TemplateContainers_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Link.class.getCanonicalName() + \"_\")) {\n+\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Container.class.getCanonicalName()+ \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.ContainerStructure_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.Tree_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // workflow schemas need to come before permissions\n+        for (File file : contains(\"WorkflowSchemeImportExportObject.json\")) {\n+            WorkflowImportExportUtil.getInstance().importWorkflowExport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.Permission_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // finally as all assets are loaded we can import versionInfo files\n+        for (File file : contains(\"VersionInfo_\")) {\n+\n+            doXMLFileImport(file);\n+\n+        }\n+        // We install rules after Version info.\n+        for (File file : contains(\"RuleImportExportObject.json\")) {\n+            RulesImportExportUtil.getInstance().importRules(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowTask_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowHistory_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowComment_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkFlowTaskFiles_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.tag.model.Tag_\")) {\n+            doXMLFileImport(file);\n+        }\n+        // Image, Portlet, Multitree, category\n+        for (File file : endsWith(\".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        cleanUpDBFromImport();\n+        Optional<File> assetDir = tempFiles.stream().filter(f -> (\"asset\".equals(f.getName())||\"assets\".equals(f.getName())) && f.isDirectory()).findAny();\n+        if (assetDir.isPresent()) {\n+            copyAssetDir(assetDir.get());\n+        }\n+        Logger.info(ImportStarterUtil.class, \"Done Importing\");\n+        deleteTempFiles();\n+\n+\n+\n+    }\n+\n+    /**\n+     *\n+     * @param fromAssetDir\n+     * @throws IOException\n+     */\n+    private void copyAssetDir(File fromAssetDir) throws IOException {\n+        File ad = new File(assetPath);\n+\n+        ad.mkdirs();\n+        String[] fileNames = fromAssetDir.list();\n+        for (int i = 0; i < fileNames.length; i++) {\n+            File f = new File(fromAssetDir.getPath() + File.separator + fileNames[i]);\n+            if (f.getName().equals(\".svn\")) {\n+                continue;\n+            }\n+            if (f.getName().equals(\"license.dat\")) {\n+                continue;\n+            }\n+            if (f.isDirectory()) {\n+                FileUtil.copyDirectory(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            } else {\n+                FileUtil.copyFile(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deletes all files from the backupTempFilePath\n+     */\n+    private void deleteTempFiles() {\n+        File f = new File(backupTempFilePath);\n+\n+        FileUtil.deltree(f, true);\n+    }\n+\n+\n+\n+    private void deleteTable(final String table) {\n+\n+        final DotConnect dotConnect = new DotConnect();\n+        dotConnect.setSQL(\"delete from \" + table);\n+        dotConnect.getResult();\n+    }\n+\n+    interface ObjectFilter {\n+        boolean includeIt(Object obj);\n+    }\n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     */\n+    private void doXMLFileImport(File f) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 441}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NDg4", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959488", "createdAt": "2020-06-16T23:29:07Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOTowN1rOGkwjLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOTowN1rOGkwjLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzM1Nw==", "bodyText": "Issue found: Avoid unused local variables such as 'init'.", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197357", "createdAt": "2020-06-16T23:29:07Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/api/v1/index/ESIndexResource.java", "diffHunk": "@@ -480,44 +474,106 @@ public Response getActive(@Context HttpServletRequest httpServletRequest, @Conte\n         }\n     }\n \n-    @GET\n-    @Path(\"/docscount/{params:.*}\")\n-    @Produces(\"text/plain\")\n-    public Response getDocumentCount(@Context HttpServletRequest httpServletRequest,\n-            @Context final HttpServletResponse httpServletResponse,\n-            final @PathParam(\"params\") String params)\n-            throws DotSecurityException {\n-\n-        InitDataObject init= null;\n-        try {\n-            init = auth(params,httpServletRequest, httpServletResponse);\n-\n-            //Creating an utility response object\n-            ResourceResponse responseResource = new ResourceResponse( init.getParamsMap() );\n-\n-            String indexName = this.indexHelper.getIndexNameOrAlias(init.getParamsMap(),\"index\",\"alias\",this.indexAPI);\n-            return responseResource.response( Long.toString( indexDocumentCount( indexName ) ) );\n \n-        } catch (DotDataException e) {\n-            Logger.error(this.getClass(),\"Exception trying to get document count: \" + e.getMessage(), e);\n-            return ResponseUtil.mapExceptionResponse(e);\n-        }\n-    }\n \n     @GET\n     @Path(\"/indexlist/{params:.*}\")\n     @Produces(MediaType.APPLICATION_JSON)\n     public Response indexList(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam(\"params\") String params) {\n         try {\n-            InitDataObject init = auth(params,httpServletRequest, httpServletResponse);\n+            InitDataObject init = auth(httpServletRequest, httpServletResponse);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 849}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NTAw", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959500", "createdAt": "2020-06-16T23:29:08Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOTowOFrOGkwjMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOTowOFrOGkwjMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzM2Mw==", "bodyText": "Issue found: Avoid variables with short names like u", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197363", "createdAt": "2020-06-16T23:29:08Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/ImportStarterUtil.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+package com.dotmarketing.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+import org.apache.commons.beanutils.BeanUtils;\n+import com.dotcms.business.WrapInTransaction;\n+import com.dotcms.contenttype.util.ContentTypeImportExportUtil;\n+import com.dotcms.publishing.BundlerUtil;\n+import com.dotcms.repackage.net.sf.hibernate.HibernateException;\n+import com.dotcms.repackage.net.sf.hibernate.persister.AbstractEntityPersister;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.beans.MultiTree;\n+import com.dotmarketing.beans.Tree;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.Layout;\n+import com.dotmarketing.business.LayoutsRoles;\n+import com.dotmarketing.business.PortletsLayouts;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.UsersRoles;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.logConsole.model.LogMapperRow;\n+import com.dotmarketing.portlets.containers.model.Container;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+import com.dotmarketing.portlets.folders.business.FolderAPI;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.links.model.Link;\n+import com.dotmarketing.portlets.rules.util.RulesImportExportUtil;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.portlets.templates.model.Template;\n+import com.dotmarketing.portlets.workflows.util.WorkflowImportExportUtil;\n+import com.dotmarketing.startup.runalways.Task00004LoadStarter;\n+import com.liferay.portal.SystemException;\n+import com.liferay.portal.ejb.CompanyManagerUtil;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.Image;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.Base64;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.EncryptorException;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+\n+\n+/**\n+ * This utility is part of the {@link Task00004LoadStarter} task, which fills the empty dotCMS\n+ * tables on a fresh install with information regarding the Demo Site that the application ships\n+ * with. This allows users to be able to log into the dotCMS back-end and interact with the system\n+ * before adding their own custom content.\n+ *\n+ * @author Jason Tesser\n+ * @version 1.6\n+ *\n+ */\n+public class ImportStarterUtil {\n+\n+    /**\n+     * The path where tmp files are stored. This gets wiped alot\n+     */\n+    private String backupTempFilePath = ConfigUtils.getBackupPath() + File.separator + \"temp\";\n+    private ArrayList<String> classesWithIdentity = new ArrayList<String>();\n+    private Map<String, String> sequences;\n+    private Map<String, String> tableIDColumns;\n+    private Map<String, String> tableNames;\n+    private final String assetPath;\n+\n+\n+    private final List<File> tempFiles;\n+\n+    private static final String SYSTEM_FOLDER_PATH = FolderAPI.SYSTEM_FOLDER_PARENT_PATH;\n+\n+    private final File starterZip;\n+\n+\n+    public ImportStarterUtil(File starterZipFile) {\n+        this.starterZip = starterZipFile;\n+\n+        this.assetPath = ConfigUtils.getAbsoluteAssetsRootPath();\n+        if (!this.validateZipFile()) {\n+            throw new DotRuntimeException(\"starter data invalid\");\n+        }\n+        final File backTemporalFile = new File(getBackupTempFilePath());\n+        \n+        tempFiles = Arrays.asList(backTemporalFile.listFiles()).stream().sorted().collect(Collectors.toList());\n+        tempFiles.removeIf(f -> f.getName().endsWith(\"Counter.xml\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Dashboard\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".FixAudit_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".UserProxy_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".PluginProperty_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Plugin_\"));\n+\n+\n+\n+        classesWithIdentity.add(\"Permission\");\n+        classesWithIdentity.add(\"UsersToDelete\");\n+        tableNames = new HashMap<String, String>();\n+        tableNames.put(\"Permission\", \"permission\");\n+        tableNames.put(\"UsersToDelete\", \"users_to_delete\");\n+\n+        if (DbConnectionFactory.isPostgres() || DbConnectionFactory.isOracle()) {\n+            sequences = new HashMap<String, String>();\n+            sequences.put(\"permission\", \"permission_seq\");\n+            sequences.put(\"users_to_delete\", \"user_to_delete_seq\");\n+            tableIDColumns = new HashMap<String, String>();\n+            tableIDColumns.put(\"permission\", \"id\");\n+            tableIDColumns.put(\"users_to_delete\", \"id\");\n+\n+        }\n+    }\n+\n+    /**\n+     * Takes a ZIP file from the /temp directory to restore dotCMS data. Currently, it will blow away\n+     * all current data. This method cannot currently be run in a transaction. For performance reasons\n+     * with DB drivers and connections it closes the session every so often.\n+     *\n+     * @param out - A print writer for output.\n+     * @throws IOException\n+     * @throws Exception\n+     */\n+    @WrapInTransaction\n+    public void doImport() throws Exception {\n+\n+\n+\n+        Logger.info(this, \"Found \" + tempFiles.size() + \" files to import\");\n+\n+\n+        deleteDotCMS();\n+        \n+\n+        for (File file : endsWith(\"Company.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        List<Role> roles = new ArrayList<Role>();\n+\n+        for (File file : startsWith(\"com.dotmarketing.business.Role_\")) {\n+            roles.addAll((List<Role>) BundlerUtil.xmlToObject(file));\n+        }\n+\n+        Collections.sort(roles);\n+\n+\n+        for (Role role : roles) {\n+            HibernateUtil _dh = new HibernateUtil(Role.class);\n+            String id = HibernateUtil.getSession().getSessionFactory().getClassMetadata(Role.class).getIdentifierPropertyName();\n+\n+            if(UtilMethods.isSet(role.getRoleKey())) {\n+               List<Map<String,Object>>  matches= new DotConnect().setSQL(\"select * from cms_role where role_key =?\").addParam(role.getRoleKey()).loadObjectResults();\n+               Logger.info(this.getClass(), \"roleKey:\" +role.getRoleKey() + \" = \" + matches.size() );\n+            }\n+\n+            _dh.saveWithPrimaryKey(role, role.getId());\n+            HibernateUtil.getSession().flush();\n+        }\n+\n+        for (File file : endsWith(User.class.getCanonicalName() + \".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(UsersRoles.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(Layout.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        \n+        for (File file : contains(PortletsLayouts.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        for (File file : endsWith(\"LogsMappers.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(LayoutsRoles.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        \n+        \n+        for (File file : contains(Language.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        /*\n+         * Because of the parent check we do at db we need to import folder identifiers first but for the\n+         * same reason we need to sort them first by parent_path\n+         */\n+        final List<Identifier> folderIdents = new ArrayList<Identifier>();\n+        final List<Identifier> otherIdents = new ArrayList<Identifier>();\n+\n+        List<File> identifiers = contains(Identifier.class.getCanonicalName());\n+        // collecting all folder identifiers\n+        for (File ff : identifiers) {\n+            List<Identifier> idents = (List<Identifier>) BundlerUtil.xmlToObject(ff);\n+            for (Identifier ident : idents) {\n+                if (ident.getAssetType().equals(\"folder\")) {\n+                    folderIdents.add(ident);\n+                }else {\n+                    otherIdents.add(ident);\n+                }\n+            }\n+        }\n+\n+        // sorting folder identifiers by parent path in order to pass parent check\n+        Collections.sort(folderIdents, new Comparator<Identifier>() {\n+            public int compare(Identifier o1, Identifier o2) {\n+                return o1.getParentPath().compareTo(o2.getParentPath());\n+            }\n+        });\n+\n+        // saving folder identifiers\n+        for (Identifier ident : folderIdents) {\n+            if (!SYSTEM_FOLDER_PATH.equals(ident.getParentPath())) {\n+                ident.setParentPath(ident.getParentPath());\n+                ident.setAssetName(ident.getAssetName());\n+            }\n+            Logger.info(this, \"Importing folder path \" + ident.getParentPath() + ident.getAssetName());\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+        // now we need to save all remaining identifiers (folders already added)\n+        for (final Identifier ident : otherIdents) {\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+\n+\n+        // we store here defaultFileType for every folder\n+        // because of mutual folder <--> structure dependency\n+        final Map<String, String> fileTypesInodes = new HashMap<String, String>();\n+\n+        // now we can import folders\n+        for (File ff : contains(Folder.class.getCanonicalName())) {\n+            try {\n+                doXMLFileImport(ff, new ObjectFilter() {\n+                    public boolean includeIt(Object obj) {\n+                        Folder f = (Folder) obj;\n+                        fileTypesInodes.put(f.getInode(), f.getDefaultFileType());\n+                        f.setDefaultFileType(null);\n+                        return true;\n+                    }\n+                });\n+            } catch (Exception e) {\n+                Logger.error(this, \"Unable to load \" + ff.getName() + \" : \" + e.getMessage(), e);\n+            }\n+        }\n+\n+\n+        // we need content types before contentlets\n+        // but content types have references to folders and hosts identifiers\n+        // so, here is the place to do it\n+        for (File file : endsWith(ContentTypeImportExportUtil.CONTENT_TYPE_FILE_EXTENSION)) {\n+            new ContentTypeImportExportUtil().importContentTypes(file);\n+        }\n+\n+        // updating file_type on folder now that structures were added\n+        DotConnect dc = new DotConnect();\n+        for (Entry<String, String> entry : fileTypesInodes.entrySet()) {\n+            dc.setSQL(\"update folder set default_file_type=? where inode=?\");\n+            dc.addParam(entry.getValue());\n+            dc.addParam(entry.getKey());\n+            dc.loadResult();\n+        }\n+\n+\n+        for (File file : contains(Relationship.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // We have all identifiers, structures and users. Ready to import contentlets!\n+        for (File file : contains(Contentlet.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        for (File file : contains(Template.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.TemplateContainers_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Link.class.getCanonicalName() + \"_\")) {\n+\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Container.class.getCanonicalName()+ \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.ContainerStructure_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.Tree_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // workflow schemas need to come before permissions\n+        for (File file : contains(\"WorkflowSchemeImportExportObject.json\")) {\n+            WorkflowImportExportUtil.getInstance().importWorkflowExport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.Permission_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // finally as all assets are loaded we can import versionInfo files\n+        for (File file : contains(\"VersionInfo_\")) {\n+\n+            doXMLFileImport(file);\n+\n+        }\n+        // We install rules after Version info.\n+        for (File file : contains(\"RuleImportExportObject.json\")) {\n+            RulesImportExportUtil.getInstance().importRules(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowTask_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowHistory_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowComment_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkFlowTaskFiles_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.tag.model.Tag_\")) {\n+            doXMLFileImport(file);\n+        }\n+        // Image, Portlet, Multitree, category\n+        for (File file : endsWith(\".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        cleanUpDBFromImport();\n+        Optional<File> assetDir = tempFiles.stream().filter(f -> (\"asset\".equals(f.getName())||\"assets\".equals(f.getName())) && f.isDirectory()).findAny();\n+        if (assetDir.isPresent()) {\n+            copyAssetDir(assetDir.get());\n+        }\n+        Logger.info(ImportStarterUtil.class, \"Done Importing\");\n+        deleteTempFiles();\n+\n+\n+\n+    }\n+\n+    /**\n+     *\n+     * @param fromAssetDir\n+     * @throws IOException\n+     */\n+    private void copyAssetDir(File fromAssetDir) throws IOException {\n+        File ad = new File(assetPath);\n+\n+        ad.mkdirs();\n+        String[] fileNames = fromAssetDir.list();\n+        for (int i = 0; i < fileNames.length; i++) {\n+            File f = new File(fromAssetDir.getPath() + File.separator + fileNames[i]);\n+            if (f.getName().equals(\".svn\")) {\n+                continue;\n+            }\n+            if (f.getName().equals(\"license.dat\")) {\n+                continue;\n+            }\n+            if (f.isDirectory()) {\n+                FileUtil.copyDirectory(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            } else {\n+                FileUtil.copyFile(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deletes all files from the backupTempFilePath\n+     */\n+    private void deleteTempFiles() {\n+        File f = new File(backupTempFilePath);\n+\n+        FileUtil.deltree(f, true);\n+    }\n+\n+\n+\n+    private void deleteTable(final String table) {\n+\n+        final DotConnect dotConnect = new DotConnect();\n+        dotConnect.setSQL(\"delete from \" + table);\n+        dotConnect.getResult();\n+    }\n+\n+    interface ObjectFilter {\n+        boolean includeIt(Object obj);\n+    }\n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     */\n+    private void doXMLFileImport(File f) throws Exception {\n+        doXMLFileImport(f, null);\n+    }\n+    \n+    \n+    \n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     * @param filter\n+     * @throws DotDataException\n+     * @throws HibernateException\n+     * @throws EncryptorException\n+     * @throws SQLException \n+     * @throws DotSecurityException \n+     * @throws DuplicateUserException \n+     * @throws NoSuchMethodException \n+     * @throws InvocationTargetException \n+     * @throws IllegalAccessException \n+     */\n+    private void doXMLFileImport(File f, ObjectFilter filter) throws Exception {\n+        if (f == null) {\n+            return;\n+        }\n+\n+\n+\n+            Class _importClass = null;\n+            HibernateUtil _dh = null;\n+\n+            boolean counter = false;\n+            boolean image = false;\n+            boolean portlet = false;\n+            boolean logsMappers = false;\n+\n+\n+            Pattern classNamePattern = Pattern.compile(\"_[0-9]{8}\");\n+            Logger.info(this, \"**** Importing the file: \" + f + \" *****\");\n+\n+            /* if we have a multipart import file */\n+            \n+            final String _className = classNamePattern.matcher(f.getName()).find() \n+                   ?  f.getName().substring(0, f.getName().lastIndexOf(\"_\"))\n+                   :   f.getName().substring(0, f.getName().lastIndexOf(\".\"));\n+\n+\n+            if (_className.equals(\"Counter\")) {\n+                counter = true;\n+            } else if (_className.equals(\"Image\")) {\n+                image = true;\n+            } else if (_className.equals(\"Portlet\")) {\n+                portlet = true;\n+            } else if (_className.equals(\"LogsMappers\")) {\n+                logsMappers = true;\n+            } else {\n+                try {\n+                    _importClass = Class.forName(_className);\n+                } catch (Exception e) {\n+                    Logger.error(this, \"Class not found \" + _className);\n+                    return;\n+                }\n+            }\n+\n+            Logger.info(this, \"Importing:\\t\" + _className);\n+\n+\n+            List l = new ArrayList();\n+\n+            List all = (List) BundlerUtil.xmlToObject(f);\n+            if (filter != null) {\n+                for (Object obj : all)\n+                    if (filter.includeIt(obj))\n+                        l.add(obj);\n+            } else {\n+                l = all;\n+            }\n+\n+\n+            Logger.info(this, \"Found :\\t\" + l.size() + \" \" + _className + \"(s)\");\n+            if (counter) {\n+                for (int j = 0; j < l.size(); j++) {\n+                    final HashMap<String, String> dcResults = (HashMap<String, String>) l.get(j);\n+\n+                    DotConnect dc = new DotConnect();\n+                    dc.setSQL(\"insert into counter values (?,?)\");\n+                    dc.addParam(dcResults.get(\"name\"));\n+                    dc.addParam(Integer.valueOf(dcResults.get(\"currentid\")));\n+                    dc.loadResults();\n+\n+                }\n+            } else if (image) {\n+                /*\n+                 * The changes in this part were made for Oracle databases. Oracle has problems when getString()\n+                 * method is called on a LONG field on an Oracle database. Because of this, the object is loaded\n+                 * from liferay and DotConnect is not used\n+                 */\n+                for (int j = 0; j < l.size(); j++) {\n+                    final Image im = (Image) l.get(j);\n+\n+                    DotConnect dc = new DotConnect();\n+                    dc.setSQL(\"insert into image values (?,?)\");\n+                    if (!UtilMethods.isSet(im.getImageId()) && DbConnectionFactory.isOracle()) {\n+                        return;\n+                    }\n+                    dc.addParam(im.getImageId());\n+                    dc.addParam(im.getText());\n+                    dc.loadResults();\n+\n+                }\n+            } else if (portlet) {\n+                for (int j = 0; j < l.size(); j++) {\n+                    final HashMap<String, String> dcResults = (HashMap<String, String>) l.get(j);\n+\n+                    DotConnect dc = new DotConnect();\n+                    StringBuffer sb = new StringBuffer(\"insert into portlet values (?,?,?,?,\");\n+                    if (dcResults.get(\"narrow\").equalsIgnoreCase(\"f\") || dcResults.get(\"narrow\").equalsIgnoreCase(\"false\")\n+                                    || dcResults.get(\"narrow\").equalsIgnoreCase(\"0\")\n+                                    || dcResults.get(\"narrow\").equals(DbConnectionFactory.getDBFalse()))\n+                        sb.append(DbConnectionFactory.getDBFalse() + \",?,\");\n+                    else\n+                        sb.append(DbConnectionFactory.getDBTrue() + \",?,\");\n+                    if (dcResults.get(\"active_\").equalsIgnoreCase(\"f\") || dcResults.get(\"active_\").equalsIgnoreCase(\"false\")\n+                                    || dcResults.get(\"active_\").equalsIgnoreCase(\"0\")\n+                                    || dcResults.get(\"active_\").equals(DbConnectionFactory.getDBFalse()))\n+                        sb.append(DbConnectionFactory.getDBFalse() + \")\");\n+                    else\n+                        sb.append(DbConnectionFactory.getDBTrue() + \")\");\n+                    dc.setSQL(sb.toString());\n+                    dc.addParam(dcResults.get(\"portletid\"));\n+                    dc.addParam(dcResults.get(\"groupid\"));\n+                    dc.addParam(dcResults.get(\"companyid\"));\n+                    dc.addParam(dcResults.get(\"defaultpreferences\"));\n+                    dc.addParam(dcResults.get(\"roles\"));\n+                    dc.loadResults();\n+\n+                }\n+            } else if (logsMappers) {\n+                for (int j = 0; j < l.size(); j++) {\n+                    final LogMapperRow logMapperRow = (LogMapperRow) l.get(j);\n+\n+                    DotConnect dc = new DotConnect();\n+                    dc.setSQL(\"insert into log_mapper values (?,?,?)\");\n+                    dc.addParam(logMapperRow.getEnabled() ? 1 : 0);\n+                    dc.addParam(logMapperRow.getLog_name());\n+                    dc.addParam(logMapperRow.getDescription());\n+                    dc.loadResults();\n+\n+                }\n+            } else if (_importClass.equals(User.class)) {\n+                for (int j = 0; j < l.size(); j++) {\n+                    User u = (User) l.get(j);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 595}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NTA3", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959507", "createdAt": "2020-06-16T23:29:09Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOTowOVrOGkwjOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOTowOVrOGkwjOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzM2OA==", "bodyText": "Issue found: Position literals first in String comparisons", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197368", "createdAt": "2020-06-16T23:29:09Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/ImportStarterUtil.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+package com.dotmarketing.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+import org.apache.commons.beanutils.BeanUtils;\n+import com.dotcms.business.WrapInTransaction;\n+import com.dotcms.contenttype.util.ContentTypeImportExportUtil;\n+import com.dotcms.publishing.BundlerUtil;\n+import com.dotcms.repackage.net.sf.hibernate.HibernateException;\n+import com.dotcms.repackage.net.sf.hibernate.persister.AbstractEntityPersister;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.beans.MultiTree;\n+import com.dotmarketing.beans.Tree;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.Layout;\n+import com.dotmarketing.business.LayoutsRoles;\n+import com.dotmarketing.business.PortletsLayouts;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.UsersRoles;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.logConsole.model.LogMapperRow;\n+import com.dotmarketing.portlets.containers.model.Container;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+import com.dotmarketing.portlets.folders.business.FolderAPI;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.links.model.Link;\n+import com.dotmarketing.portlets.rules.util.RulesImportExportUtil;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.portlets.templates.model.Template;\n+import com.dotmarketing.portlets.workflows.util.WorkflowImportExportUtil;\n+import com.dotmarketing.startup.runalways.Task00004LoadStarter;\n+import com.liferay.portal.SystemException;\n+import com.liferay.portal.ejb.CompanyManagerUtil;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.Image;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.Base64;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.EncryptorException;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+\n+\n+/**\n+ * This utility is part of the {@link Task00004LoadStarter} task, which fills the empty dotCMS\n+ * tables on a fresh install with information regarding the Demo Site that the application ships\n+ * with. This allows users to be able to log into the dotCMS back-end and interact with the system\n+ * before adding their own custom content.\n+ *\n+ * @author Jason Tesser\n+ * @version 1.6\n+ *\n+ */\n+public class ImportStarterUtil {\n+\n+    /**\n+     * The path where tmp files are stored. This gets wiped alot\n+     */\n+    private String backupTempFilePath = ConfigUtils.getBackupPath() + File.separator + \"temp\";\n+    private ArrayList<String> classesWithIdentity = new ArrayList<String>();\n+    private Map<String, String> sequences;\n+    private Map<String, String> tableIDColumns;\n+    private Map<String, String> tableNames;\n+    private final String assetPath;\n+\n+\n+    private final List<File> tempFiles;\n+\n+    private static final String SYSTEM_FOLDER_PATH = FolderAPI.SYSTEM_FOLDER_PARENT_PATH;\n+\n+    private final File starterZip;\n+\n+\n+    public ImportStarterUtil(File starterZipFile) {\n+        this.starterZip = starterZipFile;\n+\n+        this.assetPath = ConfigUtils.getAbsoluteAssetsRootPath();\n+        if (!this.validateZipFile()) {\n+            throw new DotRuntimeException(\"starter data invalid\");\n+        }\n+        final File backTemporalFile = new File(getBackupTempFilePath());\n+        \n+        tempFiles = Arrays.asList(backTemporalFile.listFiles()).stream().sorted().collect(Collectors.toList());\n+        tempFiles.removeIf(f -> f.getName().endsWith(\"Counter.xml\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Dashboard\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".FixAudit_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".UserProxy_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".PluginProperty_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Plugin_\"));\n+\n+\n+\n+        classesWithIdentity.add(\"Permission\");\n+        classesWithIdentity.add(\"UsersToDelete\");\n+        tableNames = new HashMap<String, String>();\n+        tableNames.put(\"Permission\", \"permission\");\n+        tableNames.put(\"UsersToDelete\", \"users_to_delete\");\n+\n+        if (DbConnectionFactory.isPostgres() || DbConnectionFactory.isOracle()) {\n+            sequences = new HashMap<String, String>();\n+            sequences.put(\"permission\", \"permission_seq\");\n+            sequences.put(\"users_to_delete\", \"user_to_delete_seq\");\n+            tableIDColumns = new HashMap<String, String>();\n+            tableIDColumns.put(\"permission\", \"id\");\n+            tableIDColumns.put(\"users_to_delete\", \"id\");\n+\n+        }\n+    }\n+\n+    /**\n+     * Takes a ZIP file from the /temp directory to restore dotCMS data. Currently, it will blow away\n+     * all current data. This method cannot currently be run in a transaction. For performance reasons\n+     * with DB drivers and connections it closes the session every so often.\n+     *\n+     * @param out - A print writer for output.\n+     * @throws IOException\n+     * @throws Exception\n+     */\n+    @WrapInTransaction\n+    public void doImport() throws Exception {\n+\n+\n+\n+        Logger.info(this, \"Found \" + tempFiles.size() + \" files to import\");\n+\n+\n+        deleteDotCMS();\n+        \n+\n+        for (File file : endsWith(\"Company.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        List<Role> roles = new ArrayList<Role>();\n+\n+        for (File file : startsWith(\"com.dotmarketing.business.Role_\")) {\n+            roles.addAll((List<Role>) BundlerUtil.xmlToObject(file));\n+        }\n+\n+        Collections.sort(roles);\n+\n+\n+        for (Role role : roles) {\n+            HibernateUtil _dh = new HibernateUtil(Role.class);\n+            String id = HibernateUtil.getSession().getSessionFactory().getClassMetadata(Role.class).getIdentifierPropertyName();\n+\n+            if(UtilMethods.isSet(role.getRoleKey())) {\n+               List<Map<String,Object>>  matches= new DotConnect().setSQL(\"select * from cms_role where role_key =?\").addParam(role.getRoleKey()).loadObjectResults();\n+               Logger.info(this.getClass(), \"roleKey:\" +role.getRoleKey() + \" = \" + matches.size() );\n+            }\n+\n+            _dh.saveWithPrimaryKey(role, role.getId());\n+            HibernateUtil.getSession().flush();\n+        }\n+\n+        for (File file : endsWith(User.class.getCanonicalName() + \".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(UsersRoles.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(Layout.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        \n+        for (File file : contains(PortletsLayouts.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        for (File file : endsWith(\"LogsMappers.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(LayoutsRoles.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        \n+        \n+        for (File file : contains(Language.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        /*\n+         * Because of the parent check we do at db we need to import folder identifiers first but for the\n+         * same reason we need to sort them first by parent_path\n+         */\n+        final List<Identifier> folderIdents = new ArrayList<Identifier>();\n+        final List<Identifier> otherIdents = new ArrayList<Identifier>();\n+\n+        List<File> identifiers = contains(Identifier.class.getCanonicalName());\n+        // collecting all folder identifiers\n+        for (File ff : identifiers) {\n+            List<Identifier> idents = (List<Identifier>) BundlerUtil.xmlToObject(ff);\n+            for (Identifier ident : idents) {\n+                if (ident.getAssetType().equals(\"folder\")) {\n+                    folderIdents.add(ident);\n+                }else {\n+                    otherIdents.add(ident);\n+                }\n+            }\n+        }\n+\n+        // sorting folder identifiers by parent path in order to pass parent check\n+        Collections.sort(folderIdents, new Comparator<Identifier>() {\n+            public int compare(Identifier o1, Identifier o2) {\n+                return o1.getParentPath().compareTo(o2.getParentPath());\n+            }\n+        });\n+\n+        // saving folder identifiers\n+        for (Identifier ident : folderIdents) {\n+            if (!SYSTEM_FOLDER_PATH.equals(ident.getParentPath())) {\n+                ident.setParentPath(ident.getParentPath());\n+                ident.setAssetName(ident.getAssetName());\n+            }\n+            Logger.info(this, \"Importing folder path \" + ident.getParentPath() + ident.getAssetName());\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+        // now we need to save all remaining identifiers (folders already added)\n+        for (final Identifier ident : otherIdents) {\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+\n+\n+        // we store here defaultFileType for every folder\n+        // because of mutual folder <--> structure dependency\n+        final Map<String, String> fileTypesInodes = new HashMap<String, String>();\n+\n+        // now we can import folders\n+        for (File ff : contains(Folder.class.getCanonicalName())) {\n+            try {\n+                doXMLFileImport(ff, new ObjectFilter() {\n+                    public boolean includeIt(Object obj) {\n+                        Folder f = (Folder) obj;\n+                        fileTypesInodes.put(f.getInode(), f.getDefaultFileType());\n+                        f.setDefaultFileType(null);\n+                        return true;\n+                    }\n+                });\n+            } catch (Exception e) {\n+                Logger.error(this, \"Unable to load \" + ff.getName() + \" : \" + e.getMessage(), e);\n+            }\n+        }\n+\n+\n+        // we need content types before contentlets\n+        // but content types have references to folders and hosts identifiers\n+        // so, here is the place to do it\n+        for (File file : endsWith(ContentTypeImportExportUtil.CONTENT_TYPE_FILE_EXTENSION)) {\n+            new ContentTypeImportExportUtil().importContentTypes(file);\n+        }\n+\n+        // updating file_type on folder now that structures were added\n+        DotConnect dc = new DotConnect();\n+        for (Entry<String, String> entry : fileTypesInodes.entrySet()) {\n+            dc.setSQL(\"update folder set default_file_type=? where inode=?\");\n+            dc.addParam(entry.getValue());\n+            dc.addParam(entry.getKey());\n+            dc.loadResult();\n+        }\n+\n+\n+        for (File file : contains(Relationship.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // We have all identifiers, structures and users. Ready to import contentlets!\n+        for (File file : contains(Contentlet.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        for (File file : contains(Template.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.TemplateContainers_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Link.class.getCanonicalName() + \"_\")) {\n+\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Container.class.getCanonicalName()+ \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.ContainerStructure_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.Tree_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // workflow schemas need to come before permissions\n+        for (File file : contains(\"WorkflowSchemeImportExportObject.json\")) {\n+            WorkflowImportExportUtil.getInstance().importWorkflowExport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.Permission_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // finally as all assets are loaded we can import versionInfo files\n+        for (File file : contains(\"VersionInfo_\")) {\n+\n+            doXMLFileImport(file);\n+\n+        }\n+        // We install rules after Version info.\n+        for (File file : contains(\"RuleImportExportObject.json\")) {\n+            RulesImportExportUtil.getInstance().importRules(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowTask_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowHistory_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowComment_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkFlowTaskFiles_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.tag.model.Tag_\")) {\n+            doXMLFileImport(file);\n+        }\n+        // Image, Portlet, Multitree, category\n+        for (File file : endsWith(\".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        cleanUpDBFromImport();\n+        Optional<File> assetDir = tempFiles.stream().filter(f -> (\"asset\".equals(f.getName())||\"assets\".equals(f.getName())) && f.isDirectory()).findAny();\n+        if (assetDir.isPresent()) {\n+            copyAssetDir(assetDir.get());\n+        }\n+        Logger.info(ImportStarterUtil.class, \"Done Importing\");\n+        deleteTempFiles();\n+\n+\n+\n+    }\n+\n+    /**\n+     *\n+     * @param fromAssetDir\n+     * @throws IOException\n+     */\n+    private void copyAssetDir(File fromAssetDir) throws IOException {\n+        File ad = new File(assetPath);\n+\n+        ad.mkdirs();\n+        String[] fileNames = fromAssetDir.list();\n+        for (int i = 0; i < fileNames.length; i++) {\n+            File f = new File(fromAssetDir.getPath() + File.separator + fileNames[i]);\n+            if (f.getName().equals(\".svn\")) {\n+                continue;\n+            }\n+            if (f.getName().equals(\"license.dat\")) {\n+                continue;\n+            }\n+            if (f.isDirectory()) {\n+                FileUtil.copyDirectory(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            } else {\n+                FileUtil.copyFile(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deletes all files from the backupTempFilePath\n+     */\n+    private void deleteTempFiles() {\n+        File f = new File(backupTempFilePath);\n+\n+        FileUtil.deltree(f, true);\n+    }\n+\n+\n+\n+    private void deleteTable(final String table) {\n+\n+        final DotConnect dotConnect = new DotConnect();\n+        dotConnect.setSQL(\"delete from \" + table);\n+        dotConnect.getResult();\n+    }\n+\n+    interface ObjectFilter {\n+        boolean includeIt(Object obj);\n+    }\n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     */\n+    private void doXMLFileImport(File f) throws Exception {\n+        doXMLFileImport(f, null);\n+    }\n+    \n+    \n+    \n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     * @param filter\n+     * @throws DotDataException\n+     * @throws HibernateException\n+     * @throws EncryptorException\n+     * @throws SQLException \n+     * @throws DotSecurityException \n+     * @throws DuplicateUserException \n+     * @throws NoSuchMethodException \n+     * @throws InvocationTargetException \n+     * @throws IllegalAccessException \n+     */\n+    private void doXMLFileImport(File f, ObjectFilter filter) throws Exception {\n+        if (f == null) {\n+            return;\n+        }\n+\n+\n+\n+            Class _importClass = null;\n+            HibernateUtil _dh = null;\n+\n+            boolean counter = false;\n+            boolean image = false;\n+            boolean portlet = false;\n+            boolean logsMappers = false;\n+\n+\n+            Pattern classNamePattern = Pattern.compile(\"_[0-9]{8}\");\n+            Logger.info(this, \"**** Importing the file: \" + f + \" *****\");\n+\n+            /* if we have a multipart import file */\n+            \n+            final String _className = classNamePattern.matcher(f.getName()).find() \n+                   ?  f.getName().substring(0, f.getName().lastIndexOf(\"_\"))\n+                   :   f.getName().substring(0, f.getName().lastIndexOf(\".\"));\n+\n+\n+            if (_className.equals(\"Counter\")) {\n+                counter = true;\n+            } else if (_className.equals(\"Image\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 493}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NTE3", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959517", "createdAt": "2020-06-16T23:29:10Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxMFrOGkwjQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxMFrOGkwjQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzM3OA==", "bodyText": "Issue found: Avoid variables with short names like dc", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197378", "createdAt": "2020-06-16T23:29:10Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/ImportStarterUtil.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+package com.dotmarketing.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+import org.apache.commons.beanutils.BeanUtils;\n+import com.dotcms.business.WrapInTransaction;\n+import com.dotcms.contenttype.util.ContentTypeImportExportUtil;\n+import com.dotcms.publishing.BundlerUtil;\n+import com.dotcms.repackage.net.sf.hibernate.HibernateException;\n+import com.dotcms.repackage.net.sf.hibernate.persister.AbstractEntityPersister;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.beans.MultiTree;\n+import com.dotmarketing.beans.Tree;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.Layout;\n+import com.dotmarketing.business.LayoutsRoles;\n+import com.dotmarketing.business.PortletsLayouts;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.UsersRoles;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.logConsole.model.LogMapperRow;\n+import com.dotmarketing.portlets.containers.model.Container;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+import com.dotmarketing.portlets.folders.business.FolderAPI;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.links.model.Link;\n+import com.dotmarketing.portlets.rules.util.RulesImportExportUtil;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.portlets.templates.model.Template;\n+import com.dotmarketing.portlets.workflows.util.WorkflowImportExportUtil;\n+import com.dotmarketing.startup.runalways.Task00004LoadStarter;\n+import com.liferay.portal.SystemException;\n+import com.liferay.portal.ejb.CompanyManagerUtil;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.Image;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.Base64;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.EncryptorException;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+\n+\n+/**\n+ * This utility is part of the {@link Task00004LoadStarter} task, which fills the empty dotCMS\n+ * tables on a fresh install with information regarding the Demo Site that the application ships\n+ * with. This allows users to be able to log into the dotCMS back-end and interact with the system\n+ * before adding their own custom content.\n+ *\n+ * @author Jason Tesser\n+ * @version 1.6\n+ *\n+ */\n+public class ImportStarterUtil {\n+\n+    /**\n+     * The path where tmp files are stored. This gets wiped alot\n+     */\n+    private String backupTempFilePath = ConfigUtils.getBackupPath() + File.separator + \"temp\";\n+    private ArrayList<String> classesWithIdentity = new ArrayList<String>();\n+    private Map<String, String> sequences;\n+    private Map<String, String> tableIDColumns;\n+    private Map<String, String> tableNames;\n+    private final String assetPath;\n+\n+\n+    private final List<File> tempFiles;\n+\n+    private static final String SYSTEM_FOLDER_PATH = FolderAPI.SYSTEM_FOLDER_PARENT_PATH;\n+\n+    private final File starterZip;\n+\n+\n+    public ImportStarterUtil(File starterZipFile) {\n+        this.starterZip = starterZipFile;\n+\n+        this.assetPath = ConfigUtils.getAbsoluteAssetsRootPath();\n+        if (!this.validateZipFile()) {\n+            throw new DotRuntimeException(\"starter data invalid\");\n+        }\n+        final File backTemporalFile = new File(getBackupTempFilePath());\n+        \n+        tempFiles = Arrays.asList(backTemporalFile.listFiles()).stream().sorted().collect(Collectors.toList());\n+        tempFiles.removeIf(f -> f.getName().endsWith(\"Counter.xml\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Dashboard\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".FixAudit_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".UserProxy_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".PluginProperty_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Plugin_\"));\n+\n+\n+\n+        classesWithIdentity.add(\"Permission\");\n+        classesWithIdentity.add(\"UsersToDelete\");\n+        tableNames = new HashMap<String, String>();\n+        tableNames.put(\"Permission\", \"permission\");\n+        tableNames.put(\"UsersToDelete\", \"users_to_delete\");\n+\n+        if (DbConnectionFactory.isPostgres() || DbConnectionFactory.isOracle()) {\n+            sequences = new HashMap<String, String>();\n+            sequences.put(\"permission\", \"permission_seq\");\n+            sequences.put(\"users_to_delete\", \"user_to_delete_seq\");\n+            tableIDColumns = new HashMap<String, String>();\n+            tableIDColumns.put(\"permission\", \"id\");\n+            tableIDColumns.put(\"users_to_delete\", \"id\");\n+\n+        }\n+    }\n+\n+    /**\n+     * Takes a ZIP file from the /temp directory to restore dotCMS data. Currently, it will blow away\n+     * all current data. This method cannot currently be run in a transaction. For performance reasons\n+     * with DB drivers and connections it closes the session every so often.\n+     *\n+     * @param out - A print writer for output.\n+     * @throws IOException\n+     * @throws Exception\n+     */\n+    @WrapInTransaction\n+    public void doImport() throws Exception {\n+\n+\n+\n+        Logger.info(this, \"Found \" + tempFiles.size() + \" files to import\");\n+\n+\n+        deleteDotCMS();\n+        \n+\n+        for (File file : endsWith(\"Company.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        List<Role> roles = new ArrayList<Role>();\n+\n+        for (File file : startsWith(\"com.dotmarketing.business.Role_\")) {\n+            roles.addAll((List<Role>) BundlerUtil.xmlToObject(file));\n+        }\n+\n+        Collections.sort(roles);\n+\n+\n+        for (Role role : roles) {\n+            HibernateUtil _dh = new HibernateUtil(Role.class);\n+            String id = HibernateUtil.getSession().getSessionFactory().getClassMetadata(Role.class).getIdentifierPropertyName();\n+\n+            if(UtilMethods.isSet(role.getRoleKey())) {\n+               List<Map<String,Object>>  matches= new DotConnect().setSQL(\"select * from cms_role where role_key =?\").addParam(role.getRoleKey()).loadObjectResults();\n+               Logger.info(this.getClass(), \"roleKey:\" +role.getRoleKey() + \" = \" + matches.size() );\n+            }\n+\n+            _dh.saveWithPrimaryKey(role, role.getId());\n+            HibernateUtil.getSession().flush();\n+        }\n+\n+        for (File file : endsWith(User.class.getCanonicalName() + \".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(UsersRoles.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(Layout.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        \n+        for (File file : contains(PortletsLayouts.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        for (File file : endsWith(\"LogsMappers.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(LayoutsRoles.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        \n+        \n+        for (File file : contains(Language.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        /*\n+         * Because of the parent check we do at db we need to import folder identifiers first but for the\n+         * same reason we need to sort them first by parent_path\n+         */\n+        final List<Identifier> folderIdents = new ArrayList<Identifier>();\n+        final List<Identifier> otherIdents = new ArrayList<Identifier>();\n+\n+        List<File> identifiers = contains(Identifier.class.getCanonicalName());\n+        // collecting all folder identifiers\n+        for (File ff : identifiers) {\n+            List<Identifier> idents = (List<Identifier>) BundlerUtil.xmlToObject(ff);\n+            for (Identifier ident : idents) {\n+                if (ident.getAssetType().equals(\"folder\")) {\n+                    folderIdents.add(ident);\n+                }else {\n+                    otherIdents.add(ident);\n+                }\n+            }\n+        }\n+\n+        // sorting folder identifiers by parent path in order to pass parent check\n+        Collections.sort(folderIdents, new Comparator<Identifier>() {\n+            public int compare(Identifier o1, Identifier o2) {\n+                return o1.getParentPath().compareTo(o2.getParentPath());\n+            }\n+        });\n+\n+        // saving folder identifiers\n+        for (Identifier ident : folderIdents) {\n+            if (!SYSTEM_FOLDER_PATH.equals(ident.getParentPath())) {\n+                ident.setParentPath(ident.getParentPath());\n+                ident.setAssetName(ident.getAssetName());\n+            }\n+            Logger.info(this, \"Importing folder path \" + ident.getParentPath() + ident.getAssetName());\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+        // now we need to save all remaining identifiers (folders already added)\n+        for (final Identifier ident : otherIdents) {\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+\n+\n+        // we store here defaultFileType for every folder\n+        // because of mutual folder <--> structure dependency\n+        final Map<String, String> fileTypesInodes = new HashMap<String, String>();\n+\n+        // now we can import folders\n+        for (File ff : contains(Folder.class.getCanonicalName())) {\n+            try {\n+                doXMLFileImport(ff, new ObjectFilter() {\n+                    public boolean includeIt(Object obj) {\n+                        Folder f = (Folder) obj;\n+                        fileTypesInodes.put(f.getInode(), f.getDefaultFileType());\n+                        f.setDefaultFileType(null);\n+                        return true;\n+                    }\n+                });\n+            } catch (Exception e) {\n+                Logger.error(this, \"Unable to load \" + ff.getName() + \" : \" + e.getMessage(), e);\n+            }\n+        }\n+\n+\n+        // we need content types before contentlets\n+        // but content types have references to folders and hosts identifiers\n+        // so, here is the place to do it\n+        for (File file : endsWith(ContentTypeImportExportUtil.CONTENT_TYPE_FILE_EXTENSION)) {\n+            new ContentTypeImportExportUtil().importContentTypes(file);\n+        }\n+\n+        // updating file_type on folder now that structures were added\n+        DotConnect dc = new DotConnect();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 290}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NTI2", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959526", "createdAt": "2020-06-16T23:29:11Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxMVrOGkwjSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxMVrOGkwjSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzM4NA==", "bodyText": "Issue found: This final field could be made static", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197384", "createdAt": "2020-06-16T23:29:11Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/startup/StartupTasksExecutor.java", "diffHunk": "@@ -10,346 +13,207 @@\n import com.dotmarketing.util.Logger;\n import com.dotmarketing.util.TaskLocatorUtil;\n \n-import java.sql.Connection;\n-import java.sql.Date;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.sql.Statement;\n-import java.util.Calendar;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-\n public class StartupTasksExecutor {\n \n \t\n \tprivate static StartupTasksExecutor executor;\n \n-\tprivate String pgLock = \"lock table db_version;\";\n-\tprivate String myLock = \"lock table db_version write;\";\n-\tprivate String oraLock = \"LOCK TABLE DB_VERSION IN EXCLUSIVE MODE\";\n-\tprivate String msLock = \"SELECT * FROM db_version WITH (XLOCK)\";\n-\tprivate String h2Lock = \"SELECT * FROM db_version FOR UPDATE\";\n-\n-\tprivate String pgCommit = \"commit;\";\n-\tprivate String myCommit = \"unlock tables\";\n-\tprivate String oraCommit = \"COMMIT\";\n-\tprivate String msCommit = \"COMMIT\";\n-\tprivate String h2Commit = \"COMMIT\";\n-\n-\tprivate String pgCreate = \"CREATE TABLE db_version (db_version integer NOT NULL, date_update timestamp with time zone NOT NULL, CONSTRAINT db_version_pkey PRIMARY KEY (db_version));\";\n-\tprivate String myCreate = \"CREATE TABLE `db_version` (`db_version` INTEGER UNSIGNED NOT NULL,`date_update` DATETIME NOT NULL, PRIMARY KEY (`db_version`))\";\n-\tprivate String oraCreate = \"CREATE TABLE \\\"DB_VERSION\\\" ( \\\"DB_VERSION\\\" INTEGER NOT NULL , \\\"DATE_UPDATE\\\" TIMESTAMP NOT NULL, PRIMARY KEY (\\\"DB_VERSION\\\") )\";\n-\tprivate String msCreate =\"CREATE TABLE db_version (\tdb_version int NOT NULL , date_update datetime NOT NULL, PRIMARY KEY (db_version) )\";\n-\tprivate String h2Create = \"CREATE TABLE db_version (db_version integer NOT NULL, date_update timestamp NOT NULL, CONSTRAINT db_version_pkey PRIMARY KEY (db_version))\";\n-\t\n-\tprivate String pgSelect = \"SELECT max(db_version) AS db_version FROM db_version\";\n-\tprivate String mySelect = \"SELECT max(db_version) AS db_version FROM db_version\";\n-\tprivate String oraSelect = \"SELECT max(db_version) AS db_version FROM db_version\";\n-\tprivate String msSelect = \"SELECT max(db_version) AS db_version FROM db_version\";\n-\tprivate String h2Select = \"SELECT max(db_version) AS db_version FROM db_version\";\n \n-\tprivate String lock;\n-\tprivate String commit;\n-\tprivate String create;\n-\tprivate String select;\n \n \n+\tprivate final String pgCreate  = \"CREATE TABLE db_version (db_version integer NOT NULL, date_update timestamp with time zone NOT NULL, CONSTRAINT db_version_pkey PRIMARY KEY (db_version));\";\n+\tprivate final String myCreate  = \"CREATE TABLE `db_version` (`db_version` INTEGER UNSIGNED NOT NULL,`date_update` DATETIME NOT NULL, PRIMARY KEY (`db_version`))\";\n+\tprivate final String oraCreate = \"CREATE TABLE \\\"DB_VERSION\\\" ( \\\"DB_VERSION\\\" INTEGER NOT NULL , \\\"DATE_UPDATE\\\" TIMESTAMP NOT NULL, PRIMARY KEY (\\\"DB_VERSION\\\") )\";\n+\tprivate final String msCreate  = \"CREATE TABLE db_version (\tdb_version int NOT NULL , date_update datetime NOT NULL, PRIMARY KEY (db_version) )\";\n+\n+\tprivate final String SELECT = \"SELECT max(db_version) AS test FROM db_version\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 66}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NTMx", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959531", "createdAt": "2020-06-16T23:29:12Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxMlrOGkwjTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxMlrOGkwjTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzM4OA==", "bodyText": "Issue found: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197388", "createdAt": "2020-06-16T23:29:12Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/ImportStarterUtil.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+package com.dotmarketing.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+import org.apache.commons.beanutils.BeanUtils;\n+import com.dotcms.business.WrapInTransaction;\n+import com.dotcms.contenttype.util.ContentTypeImportExportUtil;\n+import com.dotcms.publishing.BundlerUtil;\n+import com.dotcms.repackage.net.sf.hibernate.HibernateException;\n+import com.dotcms.repackage.net.sf.hibernate.persister.AbstractEntityPersister;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.beans.MultiTree;\n+import com.dotmarketing.beans.Tree;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.Layout;\n+import com.dotmarketing.business.LayoutsRoles;\n+import com.dotmarketing.business.PortletsLayouts;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.UsersRoles;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.logConsole.model.LogMapperRow;\n+import com.dotmarketing.portlets.containers.model.Container;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+import com.dotmarketing.portlets.folders.business.FolderAPI;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.links.model.Link;\n+import com.dotmarketing.portlets.rules.util.RulesImportExportUtil;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.portlets.templates.model.Template;\n+import com.dotmarketing.portlets.workflows.util.WorkflowImportExportUtil;\n+import com.dotmarketing.startup.runalways.Task00004LoadStarter;\n+import com.liferay.portal.SystemException;\n+import com.liferay.portal.ejb.CompanyManagerUtil;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.Image;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.Base64;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.EncryptorException;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+\n+\n+/**\n+ * This utility is part of the {@link Task00004LoadStarter} task, which fills the empty dotCMS\n+ * tables on a fresh install with information regarding the Demo Site that the application ships\n+ * with. This allows users to be able to log into the dotCMS back-end and interact with the system\n+ * before adding their own custom content.\n+ *\n+ * @author Jason Tesser\n+ * @version 1.6\n+ *\n+ */\n+public class ImportStarterUtil {\n+\n+    /**\n+     * The path where tmp files are stored. This gets wiped alot\n+     */\n+    private String backupTempFilePath = ConfigUtils.getBackupPath() + File.separator + \"temp\";\n+    private ArrayList<String> classesWithIdentity = new ArrayList<String>();\n+    private Map<String, String> sequences;\n+    private Map<String, String> tableIDColumns;\n+    private Map<String, String> tableNames;\n+    private final String assetPath;\n+\n+\n+    private final List<File> tempFiles;\n+\n+    private static final String SYSTEM_FOLDER_PATH = FolderAPI.SYSTEM_FOLDER_PARENT_PATH;\n+\n+    private final File starterZip;\n+\n+\n+    public ImportStarterUtil(File starterZipFile) {\n+        this.starterZip = starterZipFile;\n+\n+        this.assetPath = ConfigUtils.getAbsoluteAssetsRootPath();\n+        if (!this.validateZipFile()) {\n+            throw new DotRuntimeException(\"starter data invalid\");\n+        }\n+        final File backTemporalFile = new File(getBackupTempFilePath());\n+        \n+        tempFiles = Arrays.asList(backTemporalFile.listFiles()).stream().sorted().collect(Collectors.toList());\n+        tempFiles.removeIf(f -> f.getName().endsWith(\"Counter.xml\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Dashboard\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".FixAudit_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".UserProxy_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".PluginProperty_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Plugin_\"));\n+\n+\n+\n+        classesWithIdentity.add(\"Permission\");\n+        classesWithIdentity.add(\"UsersToDelete\");\n+        tableNames = new HashMap<String, String>();\n+        tableNames.put(\"Permission\", \"permission\");\n+        tableNames.put(\"UsersToDelete\", \"users_to_delete\");\n+\n+        if (DbConnectionFactory.isPostgres() || DbConnectionFactory.isOracle()) {\n+            sequences = new HashMap<String, String>();\n+            sequences.put(\"permission\", \"permission_seq\");\n+            sequences.put(\"users_to_delete\", \"user_to_delete_seq\");\n+            tableIDColumns = new HashMap<String, String>();\n+            tableIDColumns.put(\"permission\", \"id\");\n+            tableIDColumns.put(\"users_to_delete\", \"id\");\n+\n+        }\n+    }\n+\n+    /**\n+     * Takes a ZIP file from the /temp directory to restore dotCMS data. Currently, it will blow away\n+     * all current data. This method cannot currently be run in a transaction. For performance reasons\n+     * with DB drivers and connections it closes the session every so often.\n+     *\n+     * @param out - A print writer for output.\n+     * @throws IOException\n+     * @throws Exception\n+     */\n+    @WrapInTransaction\n+    public void doImport() throws Exception {\n+\n+\n+\n+        Logger.info(this, \"Found \" + tempFiles.size() + \" files to import\");\n+\n+\n+        deleteDotCMS();\n+        \n+\n+        for (File file : endsWith(\"Company.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        List<Role> roles = new ArrayList<Role>();\n+\n+        for (File file : startsWith(\"com.dotmarketing.business.Role_\")) {\n+            roles.addAll((List<Role>) BundlerUtil.xmlToObject(file));\n+        }\n+\n+        Collections.sort(roles);\n+\n+\n+        for (Role role : roles) {\n+            HibernateUtil _dh = new HibernateUtil(Role.class);\n+            String id = HibernateUtil.getSession().getSessionFactory().getClassMetadata(Role.class).getIdentifierPropertyName();\n+\n+            if(UtilMethods.isSet(role.getRoleKey())) {\n+               List<Map<String,Object>>  matches= new DotConnect().setSQL(\"select * from cms_role where role_key =?\").addParam(role.getRoleKey()).loadObjectResults();\n+               Logger.info(this.getClass(), \"roleKey:\" +role.getRoleKey() + \" = \" + matches.size() );\n+            }\n+\n+            _dh.saveWithPrimaryKey(role, role.getId());\n+            HibernateUtil.getSession().flush();\n+        }\n+\n+        for (File file : endsWith(User.class.getCanonicalName() + \".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(UsersRoles.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(Layout.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        \n+        for (File file : contains(PortletsLayouts.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        for (File file : endsWith(\"LogsMappers.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(LayoutsRoles.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        \n+        \n+        for (File file : contains(Language.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        /*\n+         * Because of the parent check we do at db we need to import folder identifiers first but for the\n+         * same reason we need to sort them first by parent_path\n+         */\n+        final List<Identifier> folderIdents = new ArrayList<Identifier>();\n+        final List<Identifier> otherIdents = new ArrayList<Identifier>();\n+\n+        List<File> identifiers = contains(Identifier.class.getCanonicalName());\n+        // collecting all folder identifiers\n+        for (File ff : identifiers) {\n+            List<Identifier> idents = (List<Identifier>) BundlerUtil.xmlToObject(ff);\n+            for (Identifier ident : idents) {\n+                if (ident.getAssetType().equals(\"folder\")) {\n+                    folderIdents.add(ident);\n+                }else {\n+                    otherIdents.add(ident);\n+                }\n+            }\n+        }\n+\n+        // sorting folder identifiers by parent path in order to pass parent check\n+        Collections.sort(folderIdents, new Comparator<Identifier>() {\n+            public int compare(Identifier o1, Identifier o2) {\n+                return o1.getParentPath().compareTo(o2.getParentPath());\n+            }\n+        });\n+\n+        // saving folder identifiers\n+        for (Identifier ident : folderIdents) {\n+            if (!SYSTEM_FOLDER_PATH.equals(ident.getParentPath())) {\n+                ident.setParentPath(ident.getParentPath());\n+                ident.setAssetName(ident.getAssetName());\n+            }\n+            Logger.info(this, \"Importing folder path \" + ident.getParentPath() + ident.getAssetName());\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+        // now we need to save all remaining identifiers (folders already added)\n+        for (final Identifier ident : otherIdents) {\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+\n+\n+        // we store here defaultFileType for every folder\n+        // because of mutual folder <--> structure dependency\n+        final Map<String, String> fileTypesInodes = new HashMap<String, String>();\n+\n+        // now we can import folders\n+        for (File ff : contains(Folder.class.getCanonicalName())) {\n+            try {\n+                doXMLFileImport(ff, new ObjectFilter() {\n+                    public boolean includeIt(Object obj) {\n+                        Folder f = (Folder) obj;\n+                        fileTypesInodes.put(f.getInode(), f.getDefaultFileType());\n+                        f.setDefaultFileType(null);\n+                        return true;\n+                    }\n+                });\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 276}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NTM3", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959537", "createdAt": "2020-06-16T23:29:13Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxM1rOGkwjUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxM1rOGkwjUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzM5Mg==", "bodyText": "Issue found: Avoid variables with short names like sb", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197392", "createdAt": "2020-06-16T23:29:13Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/ImportStarterUtil.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+package com.dotmarketing.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+import org.apache.commons.beanutils.BeanUtils;\n+import com.dotcms.business.WrapInTransaction;\n+import com.dotcms.contenttype.util.ContentTypeImportExportUtil;\n+import com.dotcms.publishing.BundlerUtil;\n+import com.dotcms.repackage.net.sf.hibernate.HibernateException;\n+import com.dotcms.repackage.net.sf.hibernate.persister.AbstractEntityPersister;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.beans.MultiTree;\n+import com.dotmarketing.beans.Tree;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.Layout;\n+import com.dotmarketing.business.LayoutsRoles;\n+import com.dotmarketing.business.PortletsLayouts;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.UsersRoles;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.logConsole.model.LogMapperRow;\n+import com.dotmarketing.portlets.containers.model.Container;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+import com.dotmarketing.portlets.folders.business.FolderAPI;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.links.model.Link;\n+import com.dotmarketing.portlets.rules.util.RulesImportExportUtil;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.portlets.templates.model.Template;\n+import com.dotmarketing.portlets.workflows.util.WorkflowImportExportUtil;\n+import com.dotmarketing.startup.runalways.Task00004LoadStarter;\n+import com.liferay.portal.SystemException;\n+import com.liferay.portal.ejb.CompanyManagerUtil;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.Image;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.Base64;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.EncryptorException;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+\n+\n+/**\n+ * This utility is part of the {@link Task00004LoadStarter} task, which fills the empty dotCMS\n+ * tables on a fresh install with information regarding the Demo Site that the application ships\n+ * with. This allows users to be able to log into the dotCMS back-end and interact with the system\n+ * before adding their own custom content.\n+ *\n+ * @author Jason Tesser\n+ * @version 1.6\n+ *\n+ */\n+public class ImportStarterUtil {\n+\n+    /**\n+     * The path where tmp files are stored. This gets wiped alot\n+     */\n+    private String backupTempFilePath = ConfigUtils.getBackupPath() + File.separator + \"temp\";\n+    private ArrayList<String> classesWithIdentity = new ArrayList<String>();\n+    private Map<String, String> sequences;\n+    private Map<String, String> tableIDColumns;\n+    private Map<String, String> tableNames;\n+    private final String assetPath;\n+\n+\n+    private final List<File> tempFiles;\n+\n+    private static final String SYSTEM_FOLDER_PATH = FolderAPI.SYSTEM_FOLDER_PARENT_PATH;\n+\n+    private final File starterZip;\n+\n+\n+    public ImportStarterUtil(File starterZipFile) {\n+        this.starterZip = starterZipFile;\n+\n+        this.assetPath = ConfigUtils.getAbsoluteAssetsRootPath();\n+        if (!this.validateZipFile()) {\n+            throw new DotRuntimeException(\"starter data invalid\");\n+        }\n+        final File backTemporalFile = new File(getBackupTempFilePath());\n+        \n+        tempFiles = Arrays.asList(backTemporalFile.listFiles()).stream().sorted().collect(Collectors.toList());\n+        tempFiles.removeIf(f -> f.getName().endsWith(\"Counter.xml\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Dashboard\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".FixAudit_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".UserProxy_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".PluginProperty_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Plugin_\"));\n+\n+\n+\n+        classesWithIdentity.add(\"Permission\");\n+        classesWithIdentity.add(\"UsersToDelete\");\n+        tableNames = new HashMap<String, String>();\n+        tableNames.put(\"Permission\", \"permission\");\n+        tableNames.put(\"UsersToDelete\", \"users_to_delete\");\n+\n+        if (DbConnectionFactory.isPostgres() || DbConnectionFactory.isOracle()) {\n+            sequences = new HashMap<String, String>();\n+            sequences.put(\"permission\", \"permission_seq\");\n+            sequences.put(\"users_to_delete\", \"user_to_delete_seq\");\n+            tableIDColumns = new HashMap<String, String>();\n+            tableIDColumns.put(\"permission\", \"id\");\n+            tableIDColumns.put(\"users_to_delete\", \"id\");\n+\n+        }\n+    }\n+\n+    /**\n+     * Takes a ZIP file from the /temp directory to restore dotCMS data. Currently, it will blow away\n+     * all current data. This method cannot currently be run in a transaction. For performance reasons\n+     * with DB drivers and connections it closes the session every so often.\n+     *\n+     * @param out - A print writer for output.\n+     * @throws IOException\n+     * @throws Exception\n+     */\n+    @WrapInTransaction\n+    public void doImport() throws Exception {\n+\n+\n+\n+        Logger.info(this, \"Found \" + tempFiles.size() + \" files to import\");\n+\n+\n+        deleteDotCMS();\n+        \n+\n+        for (File file : endsWith(\"Company.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        List<Role> roles = new ArrayList<Role>();\n+\n+        for (File file : startsWith(\"com.dotmarketing.business.Role_\")) {\n+            roles.addAll((List<Role>) BundlerUtil.xmlToObject(file));\n+        }\n+\n+        Collections.sort(roles);\n+\n+\n+        for (Role role : roles) {\n+            HibernateUtil _dh = new HibernateUtil(Role.class);\n+            String id = HibernateUtil.getSession().getSessionFactory().getClassMetadata(Role.class).getIdentifierPropertyName();\n+\n+            if(UtilMethods.isSet(role.getRoleKey())) {\n+               List<Map<String,Object>>  matches= new DotConnect().setSQL(\"select * from cms_role where role_key =?\").addParam(role.getRoleKey()).loadObjectResults();\n+               Logger.info(this.getClass(), \"roleKey:\" +role.getRoleKey() + \" = \" + matches.size() );\n+            }\n+\n+            _dh.saveWithPrimaryKey(role, role.getId());\n+            HibernateUtil.getSession().flush();\n+        }\n+\n+        for (File file : endsWith(User.class.getCanonicalName() + \".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(UsersRoles.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(Layout.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        \n+        for (File file : contains(PortletsLayouts.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        for (File file : endsWith(\"LogsMappers.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(LayoutsRoles.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        \n+        \n+        for (File file : contains(Language.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        /*\n+         * Because of the parent check we do at db we need to import folder identifiers first but for the\n+         * same reason we need to sort them first by parent_path\n+         */\n+        final List<Identifier> folderIdents = new ArrayList<Identifier>();\n+        final List<Identifier> otherIdents = new ArrayList<Identifier>();\n+\n+        List<File> identifiers = contains(Identifier.class.getCanonicalName());\n+        // collecting all folder identifiers\n+        for (File ff : identifiers) {\n+            List<Identifier> idents = (List<Identifier>) BundlerUtil.xmlToObject(ff);\n+            for (Identifier ident : idents) {\n+                if (ident.getAssetType().equals(\"folder\")) {\n+                    folderIdents.add(ident);\n+                }else {\n+                    otherIdents.add(ident);\n+                }\n+            }\n+        }\n+\n+        // sorting folder identifiers by parent path in order to pass parent check\n+        Collections.sort(folderIdents, new Comparator<Identifier>() {\n+            public int compare(Identifier o1, Identifier o2) {\n+                return o1.getParentPath().compareTo(o2.getParentPath());\n+            }\n+        });\n+\n+        // saving folder identifiers\n+        for (Identifier ident : folderIdents) {\n+            if (!SYSTEM_FOLDER_PATH.equals(ident.getParentPath())) {\n+                ident.setParentPath(ident.getParentPath());\n+                ident.setAssetName(ident.getAssetName());\n+            }\n+            Logger.info(this, \"Importing folder path \" + ident.getParentPath() + ident.getAssetName());\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+        // now we need to save all remaining identifiers (folders already added)\n+        for (final Identifier ident : otherIdents) {\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+\n+\n+        // we store here defaultFileType for every folder\n+        // because of mutual folder <--> structure dependency\n+        final Map<String, String> fileTypesInodes = new HashMap<String, String>();\n+\n+        // now we can import folders\n+        for (File ff : contains(Folder.class.getCanonicalName())) {\n+            try {\n+                doXMLFileImport(ff, new ObjectFilter() {\n+                    public boolean includeIt(Object obj) {\n+                        Folder f = (Folder) obj;\n+                        fileTypesInodes.put(f.getInode(), f.getDefaultFileType());\n+                        f.setDefaultFileType(null);\n+                        return true;\n+                    }\n+                });\n+            } catch (Exception e) {\n+                Logger.error(this, \"Unable to load \" + ff.getName() + \" : \" + e.getMessage(), e);\n+            }\n+        }\n+\n+\n+        // we need content types before contentlets\n+        // but content types have references to folders and hosts identifiers\n+        // so, here is the place to do it\n+        for (File file : endsWith(ContentTypeImportExportUtil.CONTENT_TYPE_FILE_EXTENSION)) {\n+            new ContentTypeImportExportUtil().importContentTypes(file);\n+        }\n+\n+        // updating file_type on folder now that structures were added\n+        DotConnect dc = new DotConnect();\n+        for (Entry<String, String> entry : fileTypesInodes.entrySet()) {\n+            dc.setSQL(\"update folder set default_file_type=? where inode=?\");\n+            dc.addParam(entry.getValue());\n+            dc.addParam(entry.getKey());\n+            dc.loadResult();\n+        }\n+\n+\n+        for (File file : contains(Relationship.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // We have all identifiers, structures and users. Ready to import contentlets!\n+        for (File file : contains(Contentlet.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        for (File file : contains(Template.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.TemplateContainers_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Link.class.getCanonicalName() + \"_\")) {\n+\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Container.class.getCanonicalName()+ \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.ContainerStructure_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.Tree_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // workflow schemas need to come before permissions\n+        for (File file : contains(\"WorkflowSchemeImportExportObject.json\")) {\n+            WorkflowImportExportUtil.getInstance().importWorkflowExport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.Permission_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // finally as all assets are loaded we can import versionInfo files\n+        for (File file : contains(\"VersionInfo_\")) {\n+\n+            doXMLFileImport(file);\n+\n+        }\n+        // We install rules after Version info.\n+        for (File file : contains(\"RuleImportExportObject.json\")) {\n+            RulesImportExportUtil.getInstance().importRules(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowTask_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowHistory_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowComment_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkFlowTaskFiles_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.tag.model.Tag_\")) {\n+            doXMLFileImport(file);\n+        }\n+        // Image, Portlet, Multitree, category\n+        for (File file : endsWith(\".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        cleanUpDBFromImport();\n+        Optional<File> assetDir = tempFiles.stream().filter(f -> (\"asset\".equals(f.getName())||\"assets\".equals(f.getName())) && f.isDirectory()).findAny();\n+        if (assetDir.isPresent()) {\n+            copyAssetDir(assetDir.get());\n+        }\n+        Logger.info(ImportStarterUtil.class, \"Done Importing\");\n+        deleteTempFiles();\n+\n+\n+\n+    }\n+\n+    /**\n+     *\n+     * @param fromAssetDir\n+     * @throws IOException\n+     */\n+    private void copyAssetDir(File fromAssetDir) throws IOException {\n+        File ad = new File(assetPath);\n+\n+        ad.mkdirs();\n+        String[] fileNames = fromAssetDir.list();\n+        for (int i = 0; i < fileNames.length; i++) {\n+            File f = new File(fromAssetDir.getPath() + File.separator + fileNames[i]);\n+            if (f.getName().equals(\".svn\")) {\n+                continue;\n+            }\n+            if (f.getName().equals(\"license.dat\")) {\n+                continue;\n+            }\n+            if (f.isDirectory()) {\n+                FileUtil.copyDirectory(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            } else {\n+                FileUtil.copyFile(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deletes all files from the backupTempFilePath\n+     */\n+    private void deleteTempFiles() {\n+        File f = new File(backupTempFilePath);\n+\n+        FileUtil.deltree(f, true);\n+    }\n+\n+\n+\n+    private void deleteTable(final String table) {\n+\n+        final DotConnect dotConnect = new DotConnect();\n+        dotConnect.setSQL(\"delete from \" + table);\n+        dotConnect.getResult();\n+    }\n+\n+    interface ObjectFilter {\n+        boolean includeIt(Object obj);\n+    }\n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     */\n+    private void doXMLFileImport(File f) throws Exception {\n+        doXMLFileImport(f, null);\n+    }\n+    \n+    \n+    \n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     * @param filter\n+     * @throws DotDataException\n+     * @throws HibernateException\n+     * @throws EncryptorException\n+     * @throws SQLException \n+     * @throws DotSecurityException \n+     * @throws DuplicateUserException \n+     * @throws NoSuchMethodException \n+     * @throws InvocationTargetException \n+     * @throws IllegalAccessException \n+     */\n+    private void doXMLFileImport(File f, ObjectFilter filter) throws Exception {\n+        if (f == null) {\n+            return;\n+        }\n+\n+\n+\n+            Class _importClass = null;\n+            HibernateUtil _dh = null;\n+\n+            boolean counter = false;\n+            boolean image = false;\n+            boolean portlet = false;\n+            boolean logsMappers = false;\n+\n+\n+            Pattern classNamePattern = Pattern.compile(\"_[0-9]{8}\");\n+            Logger.info(this, \"**** Importing the file: \" + f + \" *****\");\n+\n+            /* if we have a multipart import file */\n+            \n+            final String _className = classNamePattern.matcher(f.getName()).find() \n+                   ?  f.getName().substring(0, f.getName().lastIndexOf(\"_\"))\n+                   :   f.getName().substring(0, f.getName().lastIndexOf(\".\"));\n+\n+\n+            if (_className.equals(\"Counter\")) {\n+                counter = true;\n+            } else if (_className.equals(\"Image\")) {\n+                image = true;\n+            } else if (_className.equals(\"Portlet\")) {\n+                portlet = true;\n+            } else if (_className.equals(\"LogsMappers\")) {\n+                logsMappers = true;\n+            } else {\n+                try {\n+                    _importClass = Class.forName(_className);\n+                } catch (Exception e) {\n+                    Logger.error(this, \"Class not found \" + _className);\n+                    return;\n+                }\n+            }\n+\n+            Logger.info(this, \"Importing:\\t\" + _className);\n+\n+\n+            List l = new ArrayList();\n+\n+            List all = (List) BundlerUtil.xmlToObject(f);\n+            if (filter != null) {\n+                for (Object obj : all)\n+                    if (filter.includeIt(obj))\n+                        l.add(obj);\n+            } else {\n+                l = all;\n+            }\n+\n+\n+            Logger.info(this, \"Found :\\t\" + l.size() + \" \" + _className + \"(s)\");\n+            if (counter) {\n+                for (int j = 0; j < l.size(); j++) {\n+                    final HashMap<String, String> dcResults = (HashMap<String, String>) l.get(j);\n+\n+                    DotConnect dc = new DotConnect();\n+                    dc.setSQL(\"insert into counter values (?,?)\");\n+                    dc.addParam(dcResults.get(\"name\"));\n+                    dc.addParam(Integer.valueOf(dcResults.get(\"currentid\")));\n+                    dc.loadResults();\n+\n+                }\n+            } else if (image) {\n+                /*\n+                 * The changes in this part were made for Oracle databases. Oracle has problems when getString()\n+                 * method is called on a LONG field on an Oracle database. Because of this, the object is loaded\n+                 * from liferay and DotConnect is not used\n+                 */\n+                for (int j = 0; j < l.size(); j++) {\n+                    final Image im = (Image) l.get(j);\n+\n+                    DotConnect dc = new DotConnect();\n+                    dc.setSQL(\"insert into image values (?,?)\");\n+                    if (!UtilMethods.isSet(im.getImageId()) && DbConnectionFactory.isOracle()) {\n+                        return;\n+                    }\n+                    dc.addParam(im.getImageId());\n+                    dc.addParam(im.getText());\n+                    dc.loadResults();\n+\n+                }\n+            } else if (portlet) {\n+                for (int j = 0; j < l.size(); j++) {\n+                    final HashMap<String, String> dcResults = (HashMap<String, String>) l.get(j);\n+\n+                    DotConnect dc = new DotConnect();\n+                    StringBuffer sb = new StringBuffer(\"insert into portlet values (?,?,?,?,\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 559}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NTQ0", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959544", "createdAt": "2020-06-16T23:29:14Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxNVrOGkwjVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxNVrOGkwjVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzM5Ng==", "bodyText": "Issue found: Avoid reassigning parameters such as 'shards'", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197396", "createdAt": "2020-06-16T23:29:15Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/api/v1/index/ESIndexResource.java", "diffHunk": "@@ -67,392 +68,384 @@\n @Path(\"/v1/esindex\")\n public class ESIndexResource {\n \n+    private enum IndexAction{\n+        ACTIVATE,\n+        DEACTIVATE,\n+        CLEAR,\n+        OPEN,\n+        CLOSE;\n+        \n+        public static IndexAction fromString(String actionStr) {\n+            for(IndexAction action: IndexAction.values()) {\n+                if(action.name().equalsIgnoreCase(actionStr)) {\n+                    return action;\n+                }\n+                \n+            }\n+            return ACTIVATE;\n+        }\n+    }\n+    \n+    \n+    \n+    \n+    \n+    \n+    \n \tprivate final ESIndexAPI indexAPI;\n \tprivate final ESIndexHelper indexHelper;\n-\tprivate final ResponseUtil responseUtil;\n-\tprivate final WebResource webResource;\n-\tprivate final LayoutAPI layoutAPI;\n-\tprivate final IndiciesAPI indiciesAPI;\n+    private final ContentletIndexAPI idxApi;\n+\n \n \tpublic ESIndexResource(){\n \t\tthis.indexAPI = APILocator.getESIndexAPI();\n \t\tthis.indexHelper = ESIndexHelper.getInstance();\n-\t\tthis.responseUtil = ResponseUtil.INSTANCE;\n-\t\tthis.webResource = new WebResource();\n-\t\tthis.layoutAPI = APILocator.getLayoutAPI();\n-\t\tthis.indiciesAPI = APILocator.getIndiciesAPI();\n+\t    this.idxApi = APILocator.getContentletIndexAPI();\n+\n+\n \t}\n \n \t@VisibleForTesting\n-\tESIndexResource(ESIndexAPI indexAPI, ESIndexHelper indexHelper, ResponseUtil responseUtil,\n+\tESIndexResource(ESIndexAPI indexAPI, ESIndexHelper indexHelper,\n \t\t\tWebResource webResource, LayoutAPI layoutAPI, IndiciesAPI indiciesAPI) {\n \t\tthis.indexAPI = indexAPI;\n \t\tthis.indexHelper = indexHelper;\n-\t\tthis.responseUtil = responseUtil;\n-\t\tthis.webResource = webResource;\n-\t\tthis.layoutAPI = layoutAPI;\n-\t\tthis.indiciesAPI = indiciesAPI;\n-\t}\n-\n-    protected InitDataObject auth(final String params,\n-                                  final HttpServletRequest httpServletRequest,\n-                                  final HttpServletResponse httpServletResponse) throws DotSecurityException, DotDataException {\n-\n-        final InitDataObject init = new WebResource.InitBuilder(webResource)\n-                .requiredBackendUser(true)\n-                .requiredFrontendUser(false)\n-                .params(params)\n-                .requestAndResponse(httpServletRequest, httpServletResponse)\n-                .rejectWhenNoUser(true).init();\n-\n-        if(!this.layoutAPI.doesUserHaveAccessToPortlet(\"maintenance\", init.getUser())) {\n-            throw new DotSecurityException(\"unauthorized\");\n-        }\n-        return init;\n-    }\n-\n-    public static void restoreIndex(final File file, final String alias, String index, final boolean clear) throws DotDataException {\n-        if(LicenseUtil.getLevel() >= LicenseLevel.STANDARD.level) {\n-            if(UtilMethods.isSet(alias)) {\n-                String indexName=APILocator.getESIndexAPI()\n-                         .getAliasToIndexMap(APILocator.getSiteSearchAPI().listIndices())\n-                         .get(alias);\n-                if(UtilMethods.isSet(indexName))\n-                    index=indexName;\n-            }\n-            else if(!UtilMethods.isSet(index)) {\n-                index=APILocator.getIndiciesAPI().loadIndicies().getSiteSearch();\n-            }\n-        }\n-\n-        if(UtilMethods.isSet(index)) {\n-            final String indexToRestore=index;\n-            new Thread() {\n-                @CloseDBIfOpened\n-                public void run() {\n-                    try {\n-                        if(clear)\n-                            APILocator.getESIndexAPI().clearIndex(indexToRestore);\n-                        APILocator.getESIndexAPI().restoreIndex(file, indexToRestore);\n-                        Logger.info(this, \"finished restoring index \"+indexToRestore);\n-                    }\n-                    catch(Exception ex) {\n-                        Logger.error(ESIndexResource.class, \"Error restoring \"+indexToRestore,ex);\n-                    }\n-                }\n-            }.start();\n-        }\n-    }\n+        this.idxApi = APILocator.getContentletIndexAPI();\n \n-    /**\n-     * @deprecated Generating a manual index backup is not recommended. Snapshot and restore operations\n-     * via Elastic Search High Level Rest API should be used instead.\n-     * For further details: https://www.elastic.co/guide/en/elasticsearch/reference/7.x/modules-snapshots.html\n-     * @param indexName\n-     * @return\n-     * @throws DotDataException\n-     * @throws IOException\n-     */\n-    @Deprecated\n-    public static File downloadIndex(String indexName) throws DotDataException, IOException {\n-\n-        if(indexName.equalsIgnoreCase(\"live\") || indexName.equalsIgnoreCase(\"working\")){\n-            IndiciesInfo info=APILocator.getIndiciesAPI().loadIndicies();\n-            if(indexName.equalsIgnoreCase(\"live\")){\n-                indexName = info.getLive();\n-            }\n-            if(indexName.equalsIgnoreCase(\"working\")){\n-                indexName = info.getWorking();\n-            }\n-        }\n-\n-        return APILocator.getESIndexAPI().backupIndex(indexName);\n-\n-    }\n-\n-    public static String create(String indexName, int shards, boolean live) throws DotIndexException, IOException {\n-        if(indexName == null)\n-            indexName=ContentletIndexAPIImpl.timestampFormatter.format(new Date());\n-        indexName = (live) ? \"live_\" + indexName : \"working_\" + indexName;\n+\t}\n \n-        APILocator.getContentletIndexAPI().createContentIndex(indexName, shards);\n+    protected InitDataObject auth(\n+                                  final HttpServletRequest request,\n+                                  final HttpServletResponse response) {\n \n-        return indexName;\n+        return new WebResource\n+                        .InitBuilder(request, response)\n+                        .requiredRoles(Role.CMS_ADMINISTRATOR_ROLE)\n+                        .requiredPortlet(\"maintenance\")\n+                        .init();\n     }\n+    \n+    \n+    @CloseDBIfOpened\n+    @GET\n+    @JSONP\n+    @NoCache\n+    @Path(\"/cluster\")\n+    @Produces({MediaType.APPLICATION_JSON})\n+    public Response getClusterStats(@Context final HttpServletRequest request, @Context final HttpServletResponse response)\n+                    throws DotDataException {\n \n-    public static void activateIndex(String indexName) throws DotDataException {\n-    \tAdminLogger.log(ESIndexResource.class, \"activateIndex\", \"Trying to activate index: \" + indexName);\n+        auth(request, response);\n \n-        if(indexName.startsWith(SiteSearchAPI.ES_SITE_SEARCH_NAME)){\n-            APILocator.getSiteSearchAPI().activateIndex(indexName);\n-        }\n-        else{\n-            APILocator.getContentletIndexAPI().activateIndex(indexName);\n-        }\n \n-        AdminLogger.log(ESIndexResource.class, \"activateIndex\", \"Index activated: \" + indexName);\n-    }\n+        final ESIndexAPI esIndexAPI = new ESIndexAPI();\n+        final ClusterStats clusterStats = esIndexAPI.getClusterStats();\n \n-    public static void deactivateIndex(String indexName) throws DotDataException, IOException {\n-    \tAdminLogger.log(ESIndexResource.class, \"deactivateIndex\", \"Trying to deactivate index: \" + indexName);\n+        Builder<String, Object> builder =\n+                        ImmutableMap.<String, Object>builder().put(\"clusterName\", clusterStats.getClusterName());\n \n-        if(indexName.startsWith(SiteSearchAPI.ES_SITE_SEARCH_NAME)){\n-            APILocator.getSiteSearchAPI().deactivateIndex(indexName);\n-        }\n-        else{\n-            APILocator.getContentletIndexAPI().deactivateIndex(indexName);\n+        for (NodeStats stats : clusterStats.getNodeStats()) {\n+            builder.put(\"name\", stats.getName())\n+                .put(\"master\", stats.isMaster())\n+                .put(\"host\", stats.getHost())\n+                .put(\"address\", stats.getTransportAddress())\n+                .put(\"size\", stats.getSize())\n+                .put(\"count\", stats.getDocCount());\n         }\n-\n-        AdminLogger.log(ESIndexResource.class, \"deactivateIndex\", \"Index deactivated: \" + indexName);\n-    }\n-\n-    public static long indexDocumentCount(final String indexName) {\n-        return APILocator.getContentletIndexAPI().getIndexDocumentCount(indexName);\n+        return Response.ok(new ResponseEntityView(builder.build())).build();\n     }\n-\n-    /**\n-     * Creates a compressed (zip) index snapshot file.\n-     *\n-     * @param httpServletRequest request\n-     * @param params optional parameters, such as \"alias\"\n-     * @return\n-     * @deprecated Use ES Snapshot via ES REST API instead {@see <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/6.7/modules-snapshots.html\">}.\n-     */\n+    \n+    @CloseDBIfOpened\n     @GET\n-    @Path(\"/snapshot/{params:.*}\")\n-    @Produces({\"application/zip\", MediaType.APPLICATION_JSON})\n-    @Deprecated\n-    public Response snapshotIndex(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam(\"params\") String params) {\n-\n-    \ttry {\n-        \tcheckArgument(params != null);\n-            InitDataObject initDataObject = auth(params,httpServletRequest, httpServletResponse);\n-            final User user = initDataObject.getUser();\n-            String indexName = this.indexHelper.getIndexNameOrAlias(initDataObject.getParamsMap(),this.indexAPI);\n-\n-            if(!UtilMethods.isSet(indexName)){\n-            \treturn this.responseUtil.getErrorResponse(httpServletRequest, Response.Status.BAD_REQUEST, user.getLocale(), null, \"snapshot.wrong.arguments\");\n-            }\n-\n-            if(\"live\".equalsIgnoreCase(indexName) || \"working\".equalsIgnoreCase(indexName)){\n-                IndiciesInfo info = this.indiciesAPI.loadIndicies();\n-                if(\"live\".equalsIgnoreCase(indexName)){\n-                    indexName = info.getLive();\n+    @JSONP\n+    @NoCache\n+    @Path(\"/failed\")\n+    @Produces({MediaType.APPLICATION_JSON})\n+    public Response downloadRemainingRecordsAsCsv(@Context final HttpServletRequest request,\n+                    @Context final HttpServletResponse response) throws DotDataException {\n+        auth(request, response);\n+        List<Map<String, Object>> results = new ArrayList<>();\n+        \n+        \n+        \n+        APILocator.getReindexQueueAPI().getFailedReindexRecords().stream().forEach(row->{\n+            Map<String, Object> failure = new HashMap<>();\n+            \n+            final Contentlet contentlet = Try.of(()->APILocator.getContentletAPI().findContentletByIdentifierAnyLanguage(row.getIdentToIndex()))\n+                            .onFailure(e->Logger.warn(ESIndexResource.class, e.getMessage(), e))\n+                            .getOrElse(Contentlet::new);\n+            Map<String, Object> conMap = Try.of(() -> new ContentletToMapTransformer(contentlet).toMaps().get(0))\n+                            .onFailure(e->Logger.warn(ESIndexResource.class, e.getMessage(), e))\n+                            .getOrElse(HashMap::new);\n+\n+            failure.put(\"identifier\", row.getIdentToIndex());\n+            failure.put(\"serverId\", row.getServerId());\n+            failure.put(\"failureReason\", row.getLastResult());\n+            failure.put(\"priority\", row.getPriority());\n+            if(contentlet!=null) {\n+                try {\n+                    failure.put(\"title\", contentlet.getTitle());\n+                    failure.put(\"inode\", contentlet.getInode());\n+                    failure.put(\"contentlet\", conMap);\n                 }\n-                if(\"working\".equalsIgnoreCase(indexName)){\n-                    indexName = info.getWorking();\n+                catch(Exception e) {\n+                    Logger.warn(this.getClass(), \"unable to map content:\" + e, e);\n                 }\n             }\n+            \n+            results.add(failure);\n+        });\n \n-            final File snapshotFile = this.indexAPI.createSnapshot(ESIndexAPI.BACKUP_REPOSITORY, \"backup\", indexName);\n-\t\t\tfinal InputStream in = Files.newInputStream(snapshotFile.toPath());\n-\t\t\tfinal StreamingOutput stream = os -> {\n-                try {\n-                    ByteStreams.copy(in, os);\n-                } finally {\n-                    // clean up\n-                    indexAPI.deleteRepository(ESIndexAPI.BACKUP_REPOSITORY, false);\n-                    snapshotFile.delete();\n-                }\n-            };\n-\t\t\treturn Response.ok(stream)\n-\t\t\t\t\t.header(\"Content-Disposition\", \"attachment; filename=\\\"\" + indexName + \".zip\\\"\")\n-\t\t\t\t\t.header(\"Content-Type\", \"application/zip\").build();\n-    \t} catch (Exception e) {\n-            Logger.error(this.getClass(),\"Exception trying to download index snapshot: \" + e.getMessage(), e);\n-            return ResponseUtil.mapExceptionResponse(e);\n-        }\n+        return Response.ok(results).build();\n     }\n \n-    /**\n-     * Upload snapshot backup using a zip file\n-     * @param inputFile file to be uploaded\n-     * @param inputFileDetail file stream details\n-     * @param params optional parameters\n-     * @return request status\n-     * @deprecated Use ES Snapshot via ES REST API instead {@see <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/6.7/modules-snapshots.html\">}.\n-     */\n-    @POST\n-    @Path(\"/restoresnapshot/{params:.*}\")\n-    @Consumes(MediaType.MULTIPART_FORM_DATA)\n-    @Produces({MediaType.APPLICATION_JSON, \"application/javascript\"})\n-    @Deprecated\n-    public void restoreSnapshotIndex(@Context final HttpServletRequest httpServletRequest,\n-                                         @Context final HttpServletResponse httpServletResponse,\n-                                         @Suspended final AsyncResponse asyncResponse,\n-                                         @FormDataParam(\"file\") final InputStream inputFile,\n-                                         @FormDataParam(\"file\") final FormDataContentDisposition inputFileDetail,\n-                                         @PathParam(\"params\") final String params) {\n-\n-        try {\n-        \tcheckArgument(inputFile != null);\n-        \tInitDataObject initDataObject = auth(params,httpServletRequest, httpServletResponse);\n-        \tfinal User user = initDataObject.getUser();\n-\n-        \tResponseUtil.handleAsyncResponse(\n-        \t        () -> {\n-\n-                        try {\n-\n-                            if(this.indexAPI.uploadSnapshot(inputFile)){\n-                                return new MessageEntity(LanguageUtil.get(user.getLocale(),\n-                                        \"snapshot.upload.success\"));\n-                            }\n-\n-                            throw new ServiceUnavailableException(\"snapshot.upload.failed\");\n-                        } catch (InterruptedException | LanguageException | ExecutionException | IOException e) {\n+    @CloseDBIfOpened\n+    @DELETE\n+    @JSONP\n+    @NoCache\n+    @Path(\"/failed\")\n+    @Produces({MediaType.APPLICATION_JSON})\n+    public Response deleteFailedRecords(@Context final HttpServletRequest request, @Context final HttpServletResponse response)\n+                    throws DotDataException {\n+        final InitDataObject init = auth(request, response);\n+        APILocator.getReindexQueueAPI().deleteFailedRecords();\n+        return Response.ok(new ResponseEntityView(true)).build();\n+    }\n \n-                            Logger.error(ESIndexResource.class, e.getMessage(), e);\n-                            throw new DotRuntimeException(\"snapshot.upload.failed\", e);\n-                        }\n-                    },\n-                    (Throwable e) -> {\n+    @CloseDBIfOpened\n+    @POST\n+    @JSONP\n+    @NoCache\n+    @Path(\"/optimize\")\n+    @Produces({MediaType.APPLICATION_JSON})\n+    public Response optimizeIndices(@Context final HttpServletRequest request, @Context final HttpServletResponse response) {\n+        final InitDataObject init = auth(request, response);\n+        final ContentletIndexAPI api = APILocator.getContentletIndexAPI();\n+        final List<String> indices = api.listDotCMSIndices();\n+        api.optimize(indices);\n+        final String message = Try.of(()-> LanguageUtil.get(APILocator.getCompanyAPI().getDefaultCompany(),\"message.cmsmaintenance.cache.indexoptimized\")).get();\n+        sendAdminMessage(message, MessageSeverity.INFO,init.getUser(), 0);\n+        return Response.ok().build();\n+    }\n \n-                        Logger.error(this, \"Exception trying to restore index snapshot:\" + e.getMessage(), e);\n-                        return ResponseUtil.mapExceptionResponse(e);\n-                    },\n-                    asyncResponse);\n+    @CloseDBIfOpened\n+    @DELETE\n+    @JSONP\n+    @NoCache\n+    @Path(\"/cache\")\n+    @Produces({MediaType.APPLICATION_JSON})\n+    public Response flushIndiciesCache(@Context final HttpServletRequest request, @Context final HttpServletResponse response) {\n+        final InitDataObject init = auth(request, response);\n+        final ContentletIndexAPI api = APILocator.getContentletIndexAPI();\n+        final List<String> indices = api.listDotCMSIndices();\n+        final Map<String, Integer> data = APILocator.getESIndexAPI().flushCaches(indices);\n+        String message = Try.of(()->LanguageUtil.get(APILocator.getCompanyAPI().getDefaultCompany(),\"maintenance.index.cache.flush.message\")).get();\n+        message=message.replace(\"{0}\", String.valueOf(data.get(\"successfulShards\")));\n+        message=message.replace(\"{1}\", String.valueOf(data.get(\"failedShards\")));\n+        sendAdminMessage(message, MessageSeverity.INFO, init.getUser(),5000);\n+        return Response.ok(new ResponseEntityView(data)).build();\n \n-        } catch (Exception e) {\n-            Logger.error(this.getClass(),\"Exception trying to restore index snapshot: \" + e.getMessage(), e);\n-            asyncResponse.resume(ResponseUtil.mapExceptionResponse(e));\n-        }\n     }\n \n \n-    /**\n-     * @deprecated  As of 2016-10-12, replaced by {@link #snapshotIndex(HttpServletRequest,HttpServletResponse ,String)}\n-     */\n+    @Deprecated\n     @PUT\n     @Path(\"/create/{params:.*}\")\n     @Produces(\"text/plain\")\n     public Response createIndex(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam(\"params\") String params) {\n         try {\n-            InitDataObject init=auth(params,httpServletRequest, httpServletResponse);\n+            InitDataObject init=auth(httpServletRequest, httpServletResponse);\n \n             int shards=Integer.parseInt(init.getParamsMap().get(\"shards\"));\n             boolean live = init.getParamsMap().containsKey(\"live\") ? Boolean.parseBoolean(init.getParamsMap().get(\"live\")) : false;\n             String indexName = init.getParamsMap().get(\"index\");\n \n-            indexName = create(indexName, shards, live);\n+            if(indexName == null)\n+                indexName=ContentletIndexAPIImpl.timestampFormatter.format(new Date());\n+            indexName = (live) ? \"live_\" + indexName : \"working_\" + indexName;\n+\n+            APILocator.getContentletIndexAPI().createContentIndex(indexName, shards);\n \n             return Response.ok(indexName).build();\n-        } catch (DotSecurityException sec) {\n-            SecurityLogger.logInfo(this.getClass(), \"Access denied on createIndex from \"+httpServletRequest.getRemoteAddr());\n-            return Response.status(Status.UNAUTHORIZED).build();\n         } catch (Exception de) {\n             Logger.error(this, \"Error on createIndex. URI: \"+httpServletRequest.getRequestURI(),de);\n             return Response.serverError().build();\n         }\n     }\n-\n+    \n+    /**\n+     * use modIndex instead, e.g. PUT /api/v1/esindex/{indexName}?action=clear\n+     * @param httpServletRequest\n+     * @param httpServletResponse\n+     * @param params\n+     * @return\n+     */\n+    @Deprecated\n     @PUT\n     @Path(\"/clear/{params:.*}\")\n-    public Response clearIndex(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam(\"params\") String params) {\n-        try {\n-            InitDataObject init=auth(params,httpServletRequest,httpServletResponse);\n-            String indexName = this.indexHelper.getIndexNameOrAlias(init.getParamsMap(),\"index\",\"alias\",this.indexAPI);\n-            if(UtilMethods.isSet(indexName)) {\n-                APILocator.getESIndexAPI().clearIndex(indexName);\n-            }\n-            return Response.ok().build();\n-        } catch (Exception e) {\n-            Logger.error(this.getClass(),\"Exception trying to clear index: \" + e.getMessage(), e);\n-            return ResponseUtil.mapExceptionResponse(e);\n-        }\n-    }\n+    public Response clearIndex(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam(\"params\") String params) throws DotDataException, IOException {\n \n-    @DELETE\n-    @Path(\"/{params:.*}\")\n-    public Response deleteIndex(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam(\"params\") String params) {\n-        try {\n-            InitDataObject init=auth(params,httpServletRequest, httpServletResponse);\n-            String indexName = this.indexHelper.getIndexNameOrAlias(init.getParamsMap(),\"index\",\"alias\",this.indexAPI);\n-            if(UtilMethods.isSet(indexName)) {\n-                APILocator.getESIndexAPI().delete(indexName);\n-            }\n-            return Response.ok().build();\n-        } catch (Exception e) {\n-            Logger.error(this.getClass(),\"Exception trying to delete index: \" + e.getMessage(), e);\n-            return ResponseUtil.mapExceptionResponse(e);\n-        }\n+        InitDataObject init=auth(httpServletRequest,httpServletResponse);\n+        String indexName = this.indexHelper.getIndexNameOrAlias(init.getParamsMap(),\"index\",\"alias\",this.indexAPI);\n+        return modIndex(httpServletRequest, httpServletResponse, indexName, IndexAction.CLEAR.name());\n     }\n \n-    @PUT\n-    @Path(\"/activate/{params:.*}\")\n-    public Response activateIndex(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam(\"params\") String params) {\n-        try {\n-            InitDataObject init=auth(params,httpServletRequest, httpServletResponse);\n-            String indexName = this.indexHelper.getIndexNameOrAlias(init.getParamsMap(),\"index\",\"alias\",this.indexAPI);\n+    @CloseDBIfOpened\n+    @GET\n+    @JSONP\n+    @NoCache\n+    @Path(\"/reindex\")\n+    @Produces({MediaType.APPLICATION_JSON})\n+    public Response getReindexationProgress(@Context final HttpServletRequest request,\n+                    @Context final HttpServletResponse response) throws DotDataException {\n \n-            activateIndex(indexName);\n+        final InitDataObject init = auth(request, response);\n+\n+        return Response.ok(new ResponseEntityView(ESReindexationProcessStatus.getProcessIndexationMap())).build();\n \n-            return Response.ok().build();\n-        } catch (Exception e) {\n-            Logger.error(this.getClass(),\"Exception trying to activate index: \" + e.getMessage(), e);\n-            return ResponseUtil.mapExceptionResponse(e);\n-        }\n     }\n+    private static final String DOTALL=\"DOTALL\";\n+    \n+    \n+    @CloseDBIfOpened\n+    @POST\n+    @JSONP\n+    @NoCache\n+    @Path(\"/reindex\")\n+    @Produces({MediaType.APPLICATION_JSON})\n+    public Response startReindex(@Context final HttpServletRequest request, @Context final HttpServletResponse response,\n+                    @QueryParam(\"shards\") int shards, @DefaultValue(DOTALL) @QueryParam(\"contentType\") String contentType) throws DotDataException, DotSecurityException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 624}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NTUx", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959551", "createdAt": "2020-06-16T23:29:16Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxNlrOGkwjWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxNlrOGkwjWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzQwMw==", "bodyText": "Issue found: Useless parentheses.", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197403", "createdAt": "2020-06-16T23:29:16Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/startup/StartupTasksExecutor.java", "diffHunk": "@@ -10,346 +13,207 @@\n import com.dotmarketing.util.Logger;\n import com.dotmarketing.util.TaskLocatorUtil;\n \n-import java.sql.Connection;\n-import java.sql.Date;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.sql.Statement;\n-import java.util.Calendar;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-\n public class StartupTasksExecutor {\n \n \t\n \tprivate static StartupTasksExecutor executor;\n \n-\tprivate String pgLock = \"lock table db_version;\";\n-\tprivate String myLock = \"lock table db_version write;\";\n-\tprivate String oraLock = \"LOCK TABLE DB_VERSION IN EXCLUSIVE MODE\";\n-\tprivate String msLock = \"SELECT * FROM db_version WITH (XLOCK)\";\n-\tprivate String h2Lock = \"SELECT * FROM db_version FOR UPDATE\";\n-\n-\tprivate String pgCommit = \"commit;\";\n-\tprivate String myCommit = \"unlock tables\";\n-\tprivate String oraCommit = \"COMMIT\";\n-\tprivate String msCommit = \"COMMIT\";\n-\tprivate String h2Commit = \"COMMIT\";\n-\n-\tprivate String pgCreate = \"CREATE TABLE db_version (db_version integer NOT NULL, date_update timestamp with time zone NOT NULL, CONSTRAINT db_version_pkey PRIMARY KEY (db_version));\";\n-\tprivate String myCreate = \"CREATE TABLE `db_version` (`db_version` INTEGER UNSIGNED NOT NULL,`date_update` DATETIME NOT NULL, PRIMARY KEY (`db_version`))\";\n-\tprivate String oraCreate = \"CREATE TABLE \\\"DB_VERSION\\\" ( \\\"DB_VERSION\\\" INTEGER NOT NULL , \\\"DATE_UPDATE\\\" TIMESTAMP NOT NULL, PRIMARY KEY (\\\"DB_VERSION\\\") )\";\n-\tprivate String msCreate =\"CREATE TABLE db_version (\tdb_version int NOT NULL , date_update datetime NOT NULL, PRIMARY KEY (db_version) )\";\n-\tprivate String h2Create = \"CREATE TABLE db_version (db_version integer NOT NULL, date_update timestamp NOT NULL, CONSTRAINT db_version_pkey PRIMARY KEY (db_version))\";\n-\t\n-\tprivate String pgSelect = \"SELECT max(db_version) AS db_version FROM db_version\";\n-\tprivate String mySelect = \"SELECT max(db_version) AS db_version FROM db_version\";\n-\tprivate String oraSelect = \"SELECT max(db_version) AS db_version FROM db_version\";\n-\tprivate String msSelect = \"SELECT max(db_version) AS db_version FROM db_version\";\n-\tprivate String h2Select = \"SELECT max(db_version) AS db_version FROM db_version\";\n \n-\tprivate String lock;\n-\tprivate String commit;\n-\tprivate String create;\n-\tprivate String select;\n \n \n+\tprivate final String pgCreate  = \"CREATE TABLE db_version (db_version integer NOT NULL, date_update timestamp with time zone NOT NULL, CONSTRAINT db_version_pkey PRIMARY KEY (db_version));\";\n+\tprivate final String myCreate  = \"CREATE TABLE `db_version` (`db_version` INTEGER UNSIGNED NOT NULL,`date_update` DATETIME NOT NULL, PRIMARY KEY (`db_version`))\";\n+\tprivate final String oraCreate = \"CREATE TABLE \\\"DB_VERSION\\\" ( \\\"DB_VERSION\\\" INTEGER NOT NULL , \\\"DATE_UPDATE\\\" TIMESTAMP NOT NULL, PRIMARY KEY (\\\"DB_VERSION\\\") )\";\n+\tprivate final String msCreate  = \"CREATE TABLE db_version (\tdb_version int NOT NULL , date_update datetime NOT NULL, PRIMARY KEY (db_version) )\";\n+\n+\tprivate final String SELECT = \"SELECT max(db_version) AS test FROM db_version\";\n+\tprivate final String INSERT = \"INSERT INTO db_version (db_version,date_update) VALUES (?,?)\";\n+\n+\n+\tfinal boolean firstTimeStart;\n \t\n \t\n \tprivate StartupTasksExecutor() {\n \n+\t    insureDbVersionTable();\n+\t    Config.DB_VERSION = currentDbVersion();\n+        this.firstTimeStart = (Config.DB_VERSION==0);\n+\t    \n \t}\n \n-\tpublic static StartupTasksExecutor getInstance() {\n+\tpublic static synchronized StartupTasksExecutor getInstance() {\n \t\tif (executor == null)\n \t\t\texecutor = new StartupTasksExecutor();\n \t\treturn executor;\n \t}\n \n-\t/**\n-\t * Check which database we're using, and select the apropiate SQL. In a\n-\t * different method to avoid further clutter\n-\t */\n-\tprivate void setupSQL() {\n-\t\tif (DbConnectionFactory.isPostgres()) {\n-\t\t\tlock = pgLock;\n-\t\t\tcommit = pgCommit;\n-\t\t\tcreate = pgCreate;\n-\t\t\tselect = pgSelect;\n-\t\t}\n-\t\telse if (DbConnectionFactory.isMySql()) {\n-\t\t\tlock = myLock.toLowerCase();\n-\t\t\tcommit = myCommit.toLowerCase();\n-\t\t\tcreate = myCreate.toLowerCase();\n-\t\t\tselect = mySelect.toLowerCase();\n-\t\t}\n-\t\t\n-\t\telse if (DbConnectionFactory.isOracle()) {\n-\t\t\tlock = oraLock;\n-\t\t\tcommit = oraCommit;\n-\t\t\tcreate = oraCreate;\n-\t\t\tselect = oraSelect;\n-\t\t}\n-\t\t\n-\t\telse if (DbConnectionFactory.isMsSql()) {\n-\t\t\tlock = msLock;\n-\t\t\tcommit = msCommit;\n-\t\t\tcreate = msCreate;\n-\t\t\tselect = msSelect;\n-\t\t}\n-\t\t\n-\t\telse if(DbConnectionFactory.isH2()) {\n-\t\t    lock = h2Lock;\n-\t\t    commit = h2Commit;\n-\t\t    create = h2Create;\n-\t\t    select = h2Select;\n-\t\t}\n \n+\tprivate final String createTableSQL() {\n+\t    \n+\t       return (DbConnectionFactory.isPostgres()) ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NTU4", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959558", "createdAt": "2020-06-16T23:29:17Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxN1rOGkwjYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxN1rOGkwjYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzQwOA==", "bodyText": "Issue found: Prefer StringBuilder (non-synchronized) or StringBuffer (synchronized) over += for concatenating strings", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197408", "createdAt": "2020-06-16T23:29:17Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/api/v1/index/ESIndexResource.java", "diffHunk": "@@ -67,392 +68,384 @@\n @Path(\"/v1/esindex\")\n public class ESIndexResource {\n \n+    private enum IndexAction{\n+        ACTIVATE,\n+        DEACTIVATE,\n+        CLEAR,\n+        OPEN,\n+        CLOSE;\n+        \n+        public static IndexAction fromString(String actionStr) {\n+            for(IndexAction action: IndexAction.values()) {\n+                if(action.name().equalsIgnoreCase(actionStr)) {\n+                    return action;\n+                }\n+                \n+            }\n+            return ACTIVATE;\n+        }\n+    }\n+    \n+    \n+    \n+    \n+    \n+    \n+    \n \tprivate final ESIndexAPI indexAPI;\n \tprivate final ESIndexHelper indexHelper;\n-\tprivate final ResponseUtil responseUtil;\n-\tprivate final WebResource webResource;\n-\tprivate final LayoutAPI layoutAPI;\n-\tprivate final IndiciesAPI indiciesAPI;\n+    private final ContentletIndexAPI idxApi;\n+\n \n \tpublic ESIndexResource(){\n \t\tthis.indexAPI = APILocator.getESIndexAPI();\n \t\tthis.indexHelper = ESIndexHelper.getInstance();\n-\t\tthis.responseUtil = ResponseUtil.INSTANCE;\n-\t\tthis.webResource = new WebResource();\n-\t\tthis.layoutAPI = APILocator.getLayoutAPI();\n-\t\tthis.indiciesAPI = APILocator.getIndiciesAPI();\n+\t    this.idxApi = APILocator.getContentletIndexAPI();\n+\n+\n \t}\n \n \t@VisibleForTesting\n-\tESIndexResource(ESIndexAPI indexAPI, ESIndexHelper indexHelper, ResponseUtil responseUtil,\n+\tESIndexResource(ESIndexAPI indexAPI, ESIndexHelper indexHelper,\n \t\t\tWebResource webResource, LayoutAPI layoutAPI, IndiciesAPI indiciesAPI) {\n \t\tthis.indexAPI = indexAPI;\n \t\tthis.indexHelper = indexHelper;\n-\t\tthis.responseUtil = responseUtil;\n-\t\tthis.webResource = webResource;\n-\t\tthis.layoutAPI = layoutAPI;\n-\t\tthis.indiciesAPI = indiciesAPI;\n-\t}\n-\n-    protected InitDataObject auth(final String params,\n-                                  final HttpServletRequest httpServletRequest,\n-                                  final HttpServletResponse httpServletResponse) throws DotSecurityException, DotDataException {\n-\n-        final InitDataObject init = new WebResource.InitBuilder(webResource)\n-                .requiredBackendUser(true)\n-                .requiredFrontendUser(false)\n-                .params(params)\n-                .requestAndResponse(httpServletRequest, httpServletResponse)\n-                .rejectWhenNoUser(true).init();\n-\n-        if(!this.layoutAPI.doesUserHaveAccessToPortlet(\"maintenance\", init.getUser())) {\n-            throw new DotSecurityException(\"unauthorized\");\n-        }\n-        return init;\n-    }\n-\n-    public static void restoreIndex(final File file, final String alias, String index, final boolean clear) throws DotDataException {\n-        if(LicenseUtil.getLevel() >= LicenseLevel.STANDARD.level) {\n-            if(UtilMethods.isSet(alias)) {\n-                String indexName=APILocator.getESIndexAPI()\n-                         .getAliasToIndexMap(APILocator.getSiteSearchAPI().listIndices())\n-                         .get(alias);\n-                if(UtilMethods.isSet(indexName))\n-                    index=indexName;\n-            }\n-            else if(!UtilMethods.isSet(index)) {\n-                index=APILocator.getIndiciesAPI().loadIndicies().getSiteSearch();\n-            }\n-        }\n-\n-        if(UtilMethods.isSet(index)) {\n-            final String indexToRestore=index;\n-            new Thread() {\n-                @CloseDBIfOpened\n-                public void run() {\n-                    try {\n-                        if(clear)\n-                            APILocator.getESIndexAPI().clearIndex(indexToRestore);\n-                        APILocator.getESIndexAPI().restoreIndex(file, indexToRestore);\n-                        Logger.info(this, \"finished restoring index \"+indexToRestore);\n-                    }\n-                    catch(Exception ex) {\n-                        Logger.error(ESIndexResource.class, \"Error restoring \"+indexToRestore,ex);\n-                    }\n-                }\n-            }.start();\n-        }\n-    }\n+        this.idxApi = APILocator.getContentletIndexAPI();\n \n-    /**\n-     * @deprecated Generating a manual index backup is not recommended. Snapshot and restore operations\n-     * via Elastic Search High Level Rest API should be used instead.\n-     * For further details: https://www.elastic.co/guide/en/elasticsearch/reference/7.x/modules-snapshots.html\n-     * @param indexName\n-     * @return\n-     * @throws DotDataException\n-     * @throws IOException\n-     */\n-    @Deprecated\n-    public static File downloadIndex(String indexName) throws DotDataException, IOException {\n-\n-        if(indexName.equalsIgnoreCase(\"live\") || indexName.equalsIgnoreCase(\"working\")){\n-            IndiciesInfo info=APILocator.getIndiciesAPI().loadIndicies();\n-            if(indexName.equalsIgnoreCase(\"live\")){\n-                indexName = info.getLive();\n-            }\n-            if(indexName.equalsIgnoreCase(\"working\")){\n-                indexName = info.getWorking();\n-            }\n-        }\n-\n-        return APILocator.getESIndexAPI().backupIndex(indexName);\n-\n-    }\n-\n-    public static String create(String indexName, int shards, boolean live) throws DotIndexException, IOException {\n-        if(indexName == null)\n-            indexName=ContentletIndexAPIImpl.timestampFormatter.format(new Date());\n-        indexName = (live) ? \"live_\" + indexName : \"working_\" + indexName;\n+\t}\n \n-        APILocator.getContentletIndexAPI().createContentIndex(indexName, shards);\n+    protected InitDataObject auth(\n+                                  final HttpServletRequest request,\n+                                  final HttpServletResponse response) {\n \n-        return indexName;\n+        return new WebResource\n+                        .InitBuilder(request, response)\n+                        .requiredRoles(Role.CMS_ADMINISTRATOR_ROLE)\n+                        .requiredPortlet(\"maintenance\")\n+                        .init();\n     }\n+    \n+    \n+    @CloseDBIfOpened\n+    @GET\n+    @JSONP\n+    @NoCache\n+    @Path(\"/cluster\")\n+    @Produces({MediaType.APPLICATION_JSON})\n+    public Response getClusterStats(@Context final HttpServletRequest request, @Context final HttpServletResponse response)\n+                    throws DotDataException {\n \n-    public static void activateIndex(String indexName) throws DotDataException {\n-    \tAdminLogger.log(ESIndexResource.class, \"activateIndex\", \"Trying to activate index: \" + indexName);\n+        auth(request, response);\n \n-        if(indexName.startsWith(SiteSearchAPI.ES_SITE_SEARCH_NAME)){\n-            APILocator.getSiteSearchAPI().activateIndex(indexName);\n-        }\n-        else{\n-            APILocator.getContentletIndexAPI().activateIndex(indexName);\n-        }\n \n-        AdminLogger.log(ESIndexResource.class, \"activateIndex\", \"Index activated: \" + indexName);\n-    }\n+        final ESIndexAPI esIndexAPI = new ESIndexAPI();\n+        final ClusterStats clusterStats = esIndexAPI.getClusterStats();\n \n-    public static void deactivateIndex(String indexName) throws DotDataException, IOException {\n-    \tAdminLogger.log(ESIndexResource.class, \"deactivateIndex\", \"Trying to deactivate index: \" + indexName);\n+        Builder<String, Object> builder =\n+                        ImmutableMap.<String, Object>builder().put(\"clusterName\", clusterStats.getClusterName());\n \n-        if(indexName.startsWith(SiteSearchAPI.ES_SITE_SEARCH_NAME)){\n-            APILocator.getSiteSearchAPI().deactivateIndex(indexName);\n-        }\n-        else{\n-            APILocator.getContentletIndexAPI().deactivateIndex(indexName);\n+        for (NodeStats stats : clusterStats.getNodeStats()) {\n+            builder.put(\"name\", stats.getName())\n+                .put(\"master\", stats.isMaster())\n+                .put(\"host\", stats.getHost())\n+                .put(\"address\", stats.getTransportAddress())\n+                .put(\"size\", stats.getSize())\n+                .put(\"count\", stats.getDocCount());\n         }\n-\n-        AdminLogger.log(ESIndexResource.class, \"deactivateIndex\", \"Index deactivated: \" + indexName);\n-    }\n-\n-    public static long indexDocumentCount(final String indexName) {\n-        return APILocator.getContentletIndexAPI().getIndexDocumentCount(indexName);\n+        return Response.ok(new ResponseEntityView(builder.build())).build();\n     }\n-\n-    /**\n-     * Creates a compressed (zip) index snapshot file.\n-     *\n-     * @param httpServletRequest request\n-     * @param params optional parameters, such as \"alias\"\n-     * @return\n-     * @deprecated Use ES Snapshot via ES REST API instead {@see <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/6.7/modules-snapshots.html\">}.\n-     */\n+    \n+    @CloseDBIfOpened\n     @GET\n-    @Path(\"/snapshot/{params:.*}\")\n-    @Produces({\"application/zip\", MediaType.APPLICATION_JSON})\n-    @Deprecated\n-    public Response snapshotIndex(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam(\"params\") String params) {\n-\n-    \ttry {\n-        \tcheckArgument(params != null);\n-            InitDataObject initDataObject = auth(params,httpServletRequest, httpServletResponse);\n-            final User user = initDataObject.getUser();\n-            String indexName = this.indexHelper.getIndexNameOrAlias(initDataObject.getParamsMap(),this.indexAPI);\n-\n-            if(!UtilMethods.isSet(indexName)){\n-            \treturn this.responseUtil.getErrorResponse(httpServletRequest, Response.Status.BAD_REQUEST, user.getLocale(), null, \"snapshot.wrong.arguments\");\n-            }\n-\n-            if(\"live\".equalsIgnoreCase(indexName) || \"working\".equalsIgnoreCase(indexName)){\n-                IndiciesInfo info = this.indiciesAPI.loadIndicies();\n-                if(\"live\".equalsIgnoreCase(indexName)){\n-                    indexName = info.getLive();\n+    @JSONP\n+    @NoCache\n+    @Path(\"/failed\")\n+    @Produces({MediaType.APPLICATION_JSON})\n+    public Response downloadRemainingRecordsAsCsv(@Context final HttpServletRequest request,\n+                    @Context final HttpServletResponse response) throws DotDataException {\n+        auth(request, response);\n+        List<Map<String, Object>> results = new ArrayList<>();\n+        \n+        \n+        \n+        APILocator.getReindexQueueAPI().getFailedReindexRecords().stream().forEach(row->{\n+            Map<String, Object> failure = new HashMap<>();\n+            \n+            final Contentlet contentlet = Try.of(()->APILocator.getContentletAPI().findContentletByIdentifierAnyLanguage(row.getIdentToIndex()))\n+                            .onFailure(e->Logger.warn(ESIndexResource.class, e.getMessage(), e))\n+                            .getOrElse(Contentlet::new);\n+            Map<String, Object> conMap = Try.of(() -> new ContentletToMapTransformer(contentlet).toMaps().get(0))\n+                            .onFailure(e->Logger.warn(ESIndexResource.class, e.getMessage(), e))\n+                            .getOrElse(HashMap::new);\n+\n+            failure.put(\"identifier\", row.getIdentToIndex());\n+            failure.put(\"serverId\", row.getServerId());\n+            failure.put(\"failureReason\", row.getLastResult());\n+            failure.put(\"priority\", row.getPriority());\n+            if(contentlet!=null) {\n+                try {\n+                    failure.put(\"title\", contentlet.getTitle());\n+                    failure.put(\"inode\", contentlet.getInode());\n+                    failure.put(\"contentlet\", conMap);\n                 }\n-                if(\"working\".equalsIgnoreCase(indexName)){\n-                    indexName = info.getWorking();\n+                catch(Exception e) {\n+                    Logger.warn(this.getClass(), \"unable to map content:\" + e, e);\n                 }\n             }\n+            \n+            results.add(failure);\n+        });\n \n-            final File snapshotFile = this.indexAPI.createSnapshot(ESIndexAPI.BACKUP_REPOSITORY, \"backup\", indexName);\n-\t\t\tfinal InputStream in = Files.newInputStream(snapshotFile.toPath());\n-\t\t\tfinal StreamingOutput stream = os -> {\n-                try {\n-                    ByteStreams.copy(in, os);\n-                } finally {\n-                    // clean up\n-                    indexAPI.deleteRepository(ESIndexAPI.BACKUP_REPOSITORY, false);\n-                    snapshotFile.delete();\n-                }\n-            };\n-\t\t\treturn Response.ok(stream)\n-\t\t\t\t\t.header(\"Content-Disposition\", \"attachment; filename=\\\"\" + indexName + \".zip\\\"\")\n-\t\t\t\t\t.header(\"Content-Type\", \"application/zip\").build();\n-    \t} catch (Exception e) {\n-            Logger.error(this.getClass(),\"Exception trying to download index snapshot: \" + e.getMessage(), e);\n-            return ResponseUtil.mapExceptionResponse(e);\n-        }\n+        return Response.ok(results).build();\n     }\n \n-    /**\n-     * Upload snapshot backup using a zip file\n-     * @param inputFile file to be uploaded\n-     * @param inputFileDetail file stream details\n-     * @param params optional parameters\n-     * @return request status\n-     * @deprecated Use ES Snapshot via ES REST API instead {@see <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/6.7/modules-snapshots.html\">}.\n-     */\n-    @POST\n-    @Path(\"/restoresnapshot/{params:.*}\")\n-    @Consumes(MediaType.MULTIPART_FORM_DATA)\n-    @Produces({MediaType.APPLICATION_JSON, \"application/javascript\"})\n-    @Deprecated\n-    public void restoreSnapshotIndex(@Context final HttpServletRequest httpServletRequest,\n-                                         @Context final HttpServletResponse httpServletResponse,\n-                                         @Suspended final AsyncResponse asyncResponse,\n-                                         @FormDataParam(\"file\") final InputStream inputFile,\n-                                         @FormDataParam(\"file\") final FormDataContentDisposition inputFileDetail,\n-                                         @PathParam(\"params\") final String params) {\n-\n-        try {\n-        \tcheckArgument(inputFile != null);\n-        \tInitDataObject initDataObject = auth(params,httpServletRequest, httpServletResponse);\n-        \tfinal User user = initDataObject.getUser();\n-\n-        \tResponseUtil.handleAsyncResponse(\n-        \t        () -> {\n-\n-                        try {\n-\n-                            if(this.indexAPI.uploadSnapshot(inputFile)){\n-                                return new MessageEntity(LanguageUtil.get(user.getLocale(),\n-                                        \"snapshot.upload.success\"));\n-                            }\n-\n-                            throw new ServiceUnavailableException(\"snapshot.upload.failed\");\n-                        } catch (InterruptedException | LanguageException | ExecutionException | IOException e) {\n+    @CloseDBIfOpened\n+    @DELETE\n+    @JSONP\n+    @NoCache\n+    @Path(\"/failed\")\n+    @Produces({MediaType.APPLICATION_JSON})\n+    public Response deleteFailedRecords(@Context final HttpServletRequest request, @Context final HttpServletResponse response)\n+                    throws DotDataException {\n+        final InitDataObject init = auth(request, response);\n+        APILocator.getReindexQueueAPI().deleteFailedRecords();\n+        return Response.ok(new ResponseEntityView(true)).build();\n+    }\n \n-                            Logger.error(ESIndexResource.class, e.getMessage(), e);\n-                            throw new DotRuntimeException(\"snapshot.upload.failed\", e);\n-                        }\n-                    },\n-                    (Throwable e) -> {\n+    @CloseDBIfOpened\n+    @POST\n+    @JSONP\n+    @NoCache\n+    @Path(\"/optimize\")\n+    @Produces({MediaType.APPLICATION_JSON})\n+    public Response optimizeIndices(@Context final HttpServletRequest request, @Context final HttpServletResponse response) {\n+        final InitDataObject init = auth(request, response);\n+        final ContentletIndexAPI api = APILocator.getContentletIndexAPI();\n+        final List<String> indices = api.listDotCMSIndices();\n+        api.optimize(indices);\n+        final String message = Try.of(()-> LanguageUtil.get(APILocator.getCompanyAPI().getDefaultCompany(),\"message.cmsmaintenance.cache.indexoptimized\")).get();\n+        sendAdminMessage(message, MessageSeverity.INFO,init.getUser(), 0);\n+        return Response.ok().build();\n+    }\n \n-                        Logger.error(this, \"Exception trying to restore index snapshot:\" + e.getMessage(), e);\n-                        return ResponseUtil.mapExceptionResponse(e);\n-                    },\n-                    asyncResponse);\n+    @CloseDBIfOpened\n+    @DELETE\n+    @JSONP\n+    @NoCache\n+    @Path(\"/cache\")\n+    @Produces({MediaType.APPLICATION_JSON})\n+    public Response flushIndiciesCache(@Context final HttpServletRequest request, @Context final HttpServletResponse response) {\n+        final InitDataObject init = auth(request, response);\n+        final ContentletIndexAPI api = APILocator.getContentletIndexAPI();\n+        final List<String> indices = api.listDotCMSIndices();\n+        final Map<String, Integer> data = APILocator.getESIndexAPI().flushCaches(indices);\n+        String message = Try.of(()->LanguageUtil.get(APILocator.getCompanyAPI().getDefaultCompany(),\"maintenance.index.cache.flush.message\")).get();\n+        message=message.replace(\"{0}\", String.valueOf(data.get(\"successfulShards\")));\n+        message=message.replace(\"{1}\", String.valueOf(data.get(\"failedShards\")));\n+        sendAdminMessage(message, MessageSeverity.INFO, init.getUser(),5000);\n+        return Response.ok(new ResponseEntityView(data)).build();\n \n-        } catch (Exception e) {\n-            Logger.error(this.getClass(),\"Exception trying to restore index snapshot: \" + e.getMessage(), e);\n-            asyncResponse.resume(ResponseUtil.mapExceptionResponse(e));\n-        }\n     }\n \n \n-    /**\n-     * @deprecated  As of 2016-10-12, replaced by {@link #snapshotIndex(HttpServletRequest,HttpServletResponse ,String)}\n-     */\n+    @Deprecated\n     @PUT\n     @Path(\"/create/{params:.*}\")\n     @Produces(\"text/plain\")\n     public Response createIndex(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam(\"params\") String params) {\n         try {\n-            InitDataObject init=auth(params,httpServletRequest, httpServletResponse);\n+            InitDataObject init=auth(httpServletRequest, httpServletResponse);\n \n             int shards=Integer.parseInt(init.getParamsMap().get(\"shards\"));\n             boolean live = init.getParamsMap().containsKey(\"live\") ? Boolean.parseBoolean(init.getParamsMap().get(\"live\")) : false;\n             String indexName = init.getParamsMap().get(\"index\");\n \n-            indexName = create(indexName, shards, live);\n+            if(indexName == null)\n+                indexName=ContentletIndexAPIImpl.timestampFormatter.format(new Date());\n+            indexName = (live) ? \"live_\" + indexName : \"working_\" + indexName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 529}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NTcx", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959571", "createdAt": "2020-06-16T23:29:18Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxOFrOGkwjaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxOFrOGkwjaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzQxNg==", "bodyText": "Issue found: Avoid assignments in operands", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197416", "createdAt": "2020-06-16T23:29:18Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/db/DotCMSInitDb.java", "diffHunk": "@@ -1,126 +1,113 @@\n package com.dotmarketing.db;\n \n import java.io.File;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.util.List;\n-\n+import org.apache.felix.framework.OSGIUtil;\n import com.dotcms.business.CloseDBIfOpened;\n-import com.dotmarketing.beans.Host;\n+import com.dotcms.business.WrapInTransaction;\n import com.dotmarketing.business.APILocator;\n-import com.dotmarketing.cms.factories.PublicCompanyFactory;\n import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.common.reindex.ReindexThread;\n import com.dotmarketing.exception.DotDataException;\n import com.dotmarketing.exception.DotRuntimeException;\n-import com.dotmarketing.exception.DotSecurityException;\n-import com.dotmarketing.portlets.contentlet.business.HostAPI;\n-import com.dotmarketing.portlets.structure.factories.StructureFactory;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n import com.dotmarketing.util.Config;\n-import com.dotmarketing.util.ImportExportUtil;\n+import com.dotmarketing.util.ImportStarterUtil;\n import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.MaintenanceUtil;\n import com.dotmarketing.util.UtilMethods;\n-import com.liferay.portal.model.User;\n import com.liferay.util.FileUtil;\n-import com.rainerhahnekamp.sneakythrow.Sneaky;\n import io.vavr.control.Try;\n \n public class DotCMSInitDb {\n \n \t@CloseDBIfOpened\n \tprivate static boolean isConfigured () {\n \n-\t\tDotConnect db = new DotConnect();\n-\t\tdb.setSQL(\"select count(*) as test from inode\");\n+\t\treturn new DotConnect()\n+                .setSQL(\"select count(*) as test from inode\")\n+                .getInt(\"test\")>0;\n \n-\t\tint test = db.getInt(\"test\");\n-\t\treturn (test > 0);\n \t}\n \n-\t@CloseDBIfOpened\n-\tpublic static void InitializeDb() throws DotDataException {\n-\n-\t\tfinal boolean configured = isConfigured();\n-\n-\t\tif (!configured) {\n-\t\t\tif(Config.getBooleanProperty(\"STARTERSITE_BUILD\", true)){\n-\t\t\t\tLogger.info(DotCMSInitDb.class,\"There are no inodes - initializing db with starter site\");\n-\t\t\t\ttry {\n-\t\t\t\t\tPrintWriter pw = new PrintWriter(new StringWriter());\n-\t\t\t\t\tloadStarterSite(pw);\n-\t\t\t\t\tLogger.info(DotCMSInitDb.class, pw.toString());\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\tLogger.error(DotCMSInitDb.class, \"Unable to load starter site\", e);\n-\t\t\t\t}\n-\t\t\t}else{\n-\t\t\t\tLogger.info(DotCMSInitDb.class,\"There are no inodes - initializing db for first time use\");\n-\t\t\t\tbuildDefaultData();\n-\t\t\t}\n-\t\t}else {\n-\t\t\tLogger.info(DotCMSInitDb.class,\"inodes exist, skipping initialization of db\");\n-\t\t}\n-\t}\n+    @CloseDBIfOpened\n+    public static void InitializeDb() {\n \n-\tprivate static void buildDefaultData() throws DotDataException {\n-\t\ttry {\n-\t\t\tHostAPI hostAPI = APILocator.getHostAPI();\n-\t\t\tLocalTransaction.wrap(() -> PublicCompanyFactory.createDefaultCompany());\n-\t\t\t// Ensures that default groups are set up\n-\t//\t\tGroupFactory.createDefaultGroups();\n-\t//\t\ttry {\n-\t//\t\t\tLayoutFactory.createDefaultLayouts();\n-\t//\t\t} catch (Exception e) {\n-\t//\t\t\tthrow new DotDataException(e.getMessage(), e);\n-\t//\t\t}\n-\t\t\t// Creating the default host\n-\t\t\tUser systemUser = APILocator.getUserAPI().getSystemUser();\n-\t\t\tList<Host> hosts = hostAPI.findAll(systemUser, false);\n-\t\t\tif (hosts.size() == 0) {\n-\t\t\t\tLogger.debug(DotCMSInitDb.class, \"Creating Default Host\");\n-\t\t\t\thostAPI.findDefaultHost(systemUser, false);\n-\t\t\t}\n-\t        //Create Default Language\n-\t        APILocator.getLanguageAPI().createDefaultLanguage();\n-\t\t\t// Creating the default content structures if it not exists.\n-\t\t\tStructureFactory.createDefaultStructure();\n-\t\t} catch (DotSecurityException e) {\n-\t\t\tLogger.fatal(DotCMSInitDb.class, \"Unable to initialize default data\", e);\n-\t\t\tthrow new DotRuntimeException(e.getMessage(), e);\n-\t\t} catch (Exception e) {\n-\t\t\tLogger.fatal(DotCMSInitDb.class, \"Unable to initialize default data\", e);\n-\t\t\tnew DotDataException(e.getMessage(), e);\n-\t\t}\n-\t}\n+        if (!isConfigured()) {\n \n-\tprivate static void loadStarterSite(PrintWriter pw) throws IOException{\n-\t\t\n-\t\tString starter = Config.getStringProperty(\"STARTER_DATA_LOAD\");\n-\t\tFile starterZip = null;\n-\t\t\n-\t\tif(UtilMethods.isSet(starter)){\n+            Logger.info(DotCMSInitDb.class, \"There are no inodes - initializing db with starter site\");\n+\n+    \n+            \n+            Try.run(() -> loadStarterSite()).getOrElseThrow(e->new DotRuntimeException(e));\n+\n+\n+        } else {\n+            Logger.info(DotCMSInitDb.class, \"inodes exist, skipping initialization of db\");\n+        }\n+    }\n+\n+    \n+    @WrapInTransaction\n+    private static void loadStarterSiteData() throws Exception{\n+        String starter = Config.getStringProperty(\"STARTER_DATA_LOAD\", null);\n+        File starterZip = null;\n+        \n+        if(UtilMethods.isSet(starter)){\n \n-\t\t\t// First we try using the real path\n+            // First we try using the real path\n             starterZip = new File(FileUtil.getRealPath(starter));\n \n             // Then we try to see if there is an absolute path (or relative in case of integration tests)\n             if (!starterZip.exists()) {\n-\t\t\t\tstarterZip = new File(starter);\n-\t\t\t}\n-\t\t}\n+                starterZip = new File(starter);\n+            }\n+        }\n+        \n+        if(starterZip==null || (starterZip!=null && !starterZip.exists())){\n+            String starterSitePath = \"/starter.zip\";\n+            String zipPath = FileUtil.getRealPath(starterSitePath);\n+            starterZip = new File(zipPath); \n+         }\n+        \n+        ImportStarterUtil ieu = new ImportStarterUtil(starterZip);\n+\n+        ieu.doImport();\n+\n+    }\n+    @CloseDBIfOpened\n+\tprivate static void loadStarterSite() throws Exception{\n+\t\t\n+\t    loadStarterSiteData() ;\n+\t    \n+\t\tDbConnectionFactory.closeAndCommit();\n \t\t\n-\t\tif(starterZip==null || (starterZip!=null && !starterZip.exists())){\n-\t\t\tString starterSitePath = \"/starter.zip\";\n-\t\t\tString zipPath = FileUtil.getRealPath(starterSitePath);\n-\t\t\tstarterZip = new File(zipPath); \n-\t\t }\n+\n+        MaintenanceUtil.flushCache();\n+        ReindexThread.startThread();\n+\n+        ContentletAPI conAPI = APILocator.getContentletAPI();\n+        Logger.info(DotCMSInitDb.class, \"Building Initial Index\");\n+\n+\n+        // Initializing felix\n+        OSGIUtil.getInstance().initializeFramework();\n+\n+        // Reindexing the recently added content\n+        conAPI.refreshAllContent();\n+        long recordsToIndex = APILocator.getReindexQueueAPI().recordsInQueue();\n+        Logger.info(DotCMSInitDb.class, \"Records left to index : \" + recordsToIndex);\n+\n+        int counter = 0;\n+\n+        while (recordsToIndex > 0) {\n+            Thread.sleep(2000);\n+            recordsToIndex = APILocator.getReindexQueueAPI().recordsInQueue();\n+            Logger.info(DotCMSInitDb.class, \"Records left to index : \" + recordsToIndex);\n+            // ten minutes\n+            if(++counter>30000) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 192}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NTc1", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959575", "createdAt": "2020-06-16T23:29:19Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxOVrOGkwjaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToxOVrOGkwjaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzQxOQ==", "bodyText": "Issue found: Avoid variables with short names like o1", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197419", "createdAt": "2020-06-16T23:29:19Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/ImportStarterUtil.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+package com.dotmarketing.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+import org.apache.commons.beanutils.BeanUtils;\n+import com.dotcms.business.WrapInTransaction;\n+import com.dotcms.contenttype.util.ContentTypeImportExportUtil;\n+import com.dotcms.publishing.BundlerUtil;\n+import com.dotcms.repackage.net.sf.hibernate.HibernateException;\n+import com.dotcms.repackage.net.sf.hibernate.persister.AbstractEntityPersister;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.beans.MultiTree;\n+import com.dotmarketing.beans.Tree;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.Layout;\n+import com.dotmarketing.business.LayoutsRoles;\n+import com.dotmarketing.business.PortletsLayouts;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.UsersRoles;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.logConsole.model.LogMapperRow;\n+import com.dotmarketing.portlets.containers.model.Container;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+import com.dotmarketing.portlets.folders.business.FolderAPI;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.links.model.Link;\n+import com.dotmarketing.portlets.rules.util.RulesImportExportUtil;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.portlets.templates.model.Template;\n+import com.dotmarketing.portlets.workflows.util.WorkflowImportExportUtil;\n+import com.dotmarketing.startup.runalways.Task00004LoadStarter;\n+import com.liferay.portal.SystemException;\n+import com.liferay.portal.ejb.CompanyManagerUtil;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.Image;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.Base64;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.EncryptorException;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+\n+\n+/**\n+ * This utility is part of the {@link Task00004LoadStarter} task, which fills the empty dotCMS\n+ * tables on a fresh install with information regarding the Demo Site that the application ships\n+ * with. This allows users to be able to log into the dotCMS back-end and interact with the system\n+ * before adding their own custom content.\n+ *\n+ * @author Jason Tesser\n+ * @version 1.6\n+ *\n+ */\n+public class ImportStarterUtil {\n+\n+    /**\n+     * The path where tmp files are stored. This gets wiped alot\n+     */\n+    private String backupTempFilePath = ConfigUtils.getBackupPath() + File.separator + \"temp\";\n+    private ArrayList<String> classesWithIdentity = new ArrayList<String>();\n+    private Map<String, String> sequences;\n+    private Map<String, String> tableIDColumns;\n+    private Map<String, String> tableNames;\n+    private final String assetPath;\n+\n+\n+    private final List<File> tempFiles;\n+\n+    private static final String SYSTEM_FOLDER_PATH = FolderAPI.SYSTEM_FOLDER_PARENT_PATH;\n+\n+    private final File starterZip;\n+\n+\n+    public ImportStarterUtil(File starterZipFile) {\n+        this.starterZip = starterZipFile;\n+\n+        this.assetPath = ConfigUtils.getAbsoluteAssetsRootPath();\n+        if (!this.validateZipFile()) {\n+            throw new DotRuntimeException(\"starter data invalid\");\n+        }\n+        final File backTemporalFile = new File(getBackupTempFilePath());\n+        \n+        tempFiles = Arrays.asList(backTemporalFile.listFiles()).stream().sorted().collect(Collectors.toList());\n+        tempFiles.removeIf(f -> f.getName().endsWith(\"Counter.xml\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Dashboard\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".FixAudit_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".UserProxy_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".PluginProperty_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Plugin_\"));\n+\n+\n+\n+        classesWithIdentity.add(\"Permission\");\n+        classesWithIdentity.add(\"UsersToDelete\");\n+        tableNames = new HashMap<String, String>();\n+        tableNames.put(\"Permission\", \"permission\");\n+        tableNames.put(\"UsersToDelete\", \"users_to_delete\");\n+\n+        if (DbConnectionFactory.isPostgres() || DbConnectionFactory.isOracle()) {\n+            sequences = new HashMap<String, String>();\n+            sequences.put(\"permission\", \"permission_seq\");\n+            sequences.put(\"users_to_delete\", \"user_to_delete_seq\");\n+            tableIDColumns = new HashMap<String, String>();\n+            tableIDColumns.put(\"permission\", \"id\");\n+            tableIDColumns.put(\"users_to_delete\", \"id\");\n+\n+        }\n+    }\n+\n+    /**\n+     * Takes a ZIP file from the /temp directory to restore dotCMS data. Currently, it will blow away\n+     * all current data. This method cannot currently be run in a transaction. For performance reasons\n+     * with DB drivers and connections it closes the session every so often.\n+     *\n+     * @param out - A print writer for output.\n+     * @throws IOException\n+     * @throws Exception\n+     */\n+    @WrapInTransaction\n+    public void doImport() throws Exception {\n+\n+\n+\n+        Logger.info(this, \"Found \" + tempFiles.size() + \" files to import\");\n+\n+\n+        deleteDotCMS();\n+        \n+\n+        for (File file : endsWith(\"Company.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        List<Role> roles = new ArrayList<Role>();\n+\n+        for (File file : startsWith(\"com.dotmarketing.business.Role_\")) {\n+            roles.addAll((List<Role>) BundlerUtil.xmlToObject(file));\n+        }\n+\n+        Collections.sort(roles);\n+\n+\n+        for (Role role : roles) {\n+            HibernateUtil _dh = new HibernateUtil(Role.class);\n+            String id = HibernateUtil.getSession().getSessionFactory().getClassMetadata(Role.class).getIdentifierPropertyName();\n+\n+            if(UtilMethods.isSet(role.getRoleKey())) {\n+               List<Map<String,Object>>  matches= new DotConnect().setSQL(\"select * from cms_role where role_key =?\").addParam(role.getRoleKey()).loadObjectResults();\n+               Logger.info(this.getClass(), \"roleKey:\" +role.getRoleKey() + \" = \" + matches.size() );\n+            }\n+\n+            _dh.saveWithPrimaryKey(role, role.getId());\n+            HibernateUtil.getSession().flush();\n+        }\n+\n+        for (File file : endsWith(User.class.getCanonicalName() + \".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(UsersRoles.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(Layout.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        \n+        for (File file : contains(PortletsLayouts.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        for (File file : endsWith(\"LogsMappers.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(LayoutsRoles.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        \n+        \n+        for (File file : contains(Language.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        /*\n+         * Because of the parent check we do at db we need to import folder identifiers first but for the\n+         * same reason we need to sort them first by parent_path\n+         */\n+        final List<Identifier> folderIdents = new ArrayList<Identifier>();\n+        final List<Identifier> otherIdents = new ArrayList<Identifier>();\n+\n+        List<File> identifiers = contains(Identifier.class.getCanonicalName());\n+        // collecting all folder identifiers\n+        for (File ff : identifiers) {\n+            List<Identifier> idents = (List<Identifier>) BundlerUtil.xmlToObject(ff);\n+            for (Identifier ident : idents) {\n+                if (ident.getAssetType().equals(\"folder\")) {\n+                    folderIdents.add(ident);\n+                }else {\n+                    otherIdents.add(ident);\n+                }\n+            }\n+        }\n+\n+        // sorting folder identifiers by parent path in order to pass parent check\n+        Collections.sort(folderIdents, new Comparator<Identifier>() {\n+            public int compare(Identifier o1, Identifier o2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 239}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NTc5", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959579", "createdAt": "2020-06-16T23:29:20Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyMFrOGkwjcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyMFrOGkwjcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzQyNA==", "bodyText": "Issue found: The String literal \"narrow\" appears 4 times in this file; the first occurrence is on line 560", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197424", "createdAt": "2020-06-16T23:29:20Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/ImportStarterUtil.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+package com.dotmarketing.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+import org.apache.commons.beanutils.BeanUtils;\n+import com.dotcms.business.WrapInTransaction;\n+import com.dotcms.contenttype.util.ContentTypeImportExportUtil;\n+import com.dotcms.publishing.BundlerUtil;\n+import com.dotcms.repackage.net.sf.hibernate.HibernateException;\n+import com.dotcms.repackage.net.sf.hibernate.persister.AbstractEntityPersister;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.beans.MultiTree;\n+import com.dotmarketing.beans.Tree;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.Layout;\n+import com.dotmarketing.business.LayoutsRoles;\n+import com.dotmarketing.business.PortletsLayouts;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.UsersRoles;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.logConsole.model.LogMapperRow;\n+import com.dotmarketing.portlets.containers.model.Container;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+import com.dotmarketing.portlets.folders.business.FolderAPI;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.links.model.Link;\n+import com.dotmarketing.portlets.rules.util.RulesImportExportUtil;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.portlets.templates.model.Template;\n+import com.dotmarketing.portlets.workflows.util.WorkflowImportExportUtil;\n+import com.dotmarketing.startup.runalways.Task00004LoadStarter;\n+import com.liferay.portal.SystemException;\n+import com.liferay.portal.ejb.CompanyManagerUtil;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.Image;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.Base64;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.EncryptorException;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+\n+\n+/**\n+ * This utility is part of the {@link Task00004LoadStarter} task, which fills the empty dotCMS\n+ * tables on a fresh install with information regarding the Demo Site that the application ships\n+ * with. This allows users to be able to log into the dotCMS back-end and interact with the system\n+ * before adding their own custom content.\n+ *\n+ * @author Jason Tesser\n+ * @version 1.6\n+ *\n+ */\n+public class ImportStarterUtil {\n+\n+    /**\n+     * The path where tmp files are stored. This gets wiped alot\n+     */\n+    private String backupTempFilePath = ConfigUtils.getBackupPath() + File.separator + \"temp\";\n+    private ArrayList<String> classesWithIdentity = new ArrayList<String>();\n+    private Map<String, String> sequences;\n+    private Map<String, String> tableIDColumns;\n+    private Map<String, String> tableNames;\n+    private final String assetPath;\n+\n+\n+    private final List<File> tempFiles;\n+\n+    private static final String SYSTEM_FOLDER_PATH = FolderAPI.SYSTEM_FOLDER_PARENT_PATH;\n+\n+    private final File starterZip;\n+\n+\n+    public ImportStarterUtil(File starterZipFile) {\n+        this.starterZip = starterZipFile;\n+\n+        this.assetPath = ConfigUtils.getAbsoluteAssetsRootPath();\n+        if (!this.validateZipFile()) {\n+            throw new DotRuntimeException(\"starter data invalid\");\n+        }\n+        final File backTemporalFile = new File(getBackupTempFilePath());\n+        \n+        tempFiles = Arrays.asList(backTemporalFile.listFiles()).stream().sorted().collect(Collectors.toList());\n+        tempFiles.removeIf(f -> f.getName().endsWith(\"Counter.xml\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Dashboard\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".FixAudit_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".UserProxy_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".PluginProperty_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Plugin_\"));\n+\n+\n+\n+        classesWithIdentity.add(\"Permission\");\n+        classesWithIdentity.add(\"UsersToDelete\");\n+        tableNames = new HashMap<String, String>();\n+        tableNames.put(\"Permission\", \"permission\");\n+        tableNames.put(\"UsersToDelete\", \"users_to_delete\");\n+\n+        if (DbConnectionFactory.isPostgres() || DbConnectionFactory.isOracle()) {\n+            sequences = new HashMap<String, String>();\n+            sequences.put(\"permission\", \"permission_seq\");\n+            sequences.put(\"users_to_delete\", \"user_to_delete_seq\");\n+            tableIDColumns = new HashMap<String, String>();\n+            tableIDColumns.put(\"permission\", \"id\");\n+            tableIDColumns.put(\"users_to_delete\", \"id\");\n+\n+        }\n+    }\n+\n+    /**\n+     * Takes a ZIP file from the /temp directory to restore dotCMS data. Currently, it will blow away\n+     * all current data. This method cannot currently be run in a transaction. For performance reasons\n+     * with DB drivers and connections it closes the session every so often.\n+     *\n+     * @param out - A print writer for output.\n+     * @throws IOException\n+     * @throws Exception\n+     */\n+    @WrapInTransaction\n+    public void doImport() throws Exception {\n+\n+\n+\n+        Logger.info(this, \"Found \" + tempFiles.size() + \" files to import\");\n+\n+\n+        deleteDotCMS();\n+        \n+\n+        for (File file : endsWith(\"Company.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        List<Role> roles = new ArrayList<Role>();\n+\n+        for (File file : startsWith(\"com.dotmarketing.business.Role_\")) {\n+            roles.addAll((List<Role>) BundlerUtil.xmlToObject(file));\n+        }\n+\n+        Collections.sort(roles);\n+\n+\n+        for (Role role : roles) {\n+            HibernateUtil _dh = new HibernateUtil(Role.class);\n+            String id = HibernateUtil.getSession().getSessionFactory().getClassMetadata(Role.class).getIdentifierPropertyName();\n+\n+            if(UtilMethods.isSet(role.getRoleKey())) {\n+               List<Map<String,Object>>  matches= new DotConnect().setSQL(\"select * from cms_role where role_key =?\").addParam(role.getRoleKey()).loadObjectResults();\n+               Logger.info(this.getClass(), \"roleKey:\" +role.getRoleKey() + \" = \" + matches.size() );\n+            }\n+\n+            _dh.saveWithPrimaryKey(role, role.getId());\n+            HibernateUtil.getSession().flush();\n+        }\n+\n+        for (File file : endsWith(User.class.getCanonicalName() + \".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(UsersRoles.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(Layout.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        \n+        for (File file : contains(PortletsLayouts.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        for (File file : endsWith(\"LogsMappers.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(LayoutsRoles.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        \n+        \n+        for (File file : contains(Language.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        /*\n+         * Because of the parent check we do at db we need to import folder identifiers first but for the\n+         * same reason we need to sort them first by parent_path\n+         */\n+        final List<Identifier> folderIdents = new ArrayList<Identifier>();\n+        final List<Identifier> otherIdents = new ArrayList<Identifier>();\n+\n+        List<File> identifiers = contains(Identifier.class.getCanonicalName());\n+        // collecting all folder identifiers\n+        for (File ff : identifiers) {\n+            List<Identifier> idents = (List<Identifier>) BundlerUtil.xmlToObject(ff);\n+            for (Identifier ident : idents) {\n+                if (ident.getAssetType().equals(\"folder\")) {\n+                    folderIdents.add(ident);\n+                }else {\n+                    otherIdents.add(ident);\n+                }\n+            }\n+        }\n+\n+        // sorting folder identifiers by parent path in order to pass parent check\n+        Collections.sort(folderIdents, new Comparator<Identifier>() {\n+            public int compare(Identifier o1, Identifier o2) {\n+                return o1.getParentPath().compareTo(o2.getParentPath());\n+            }\n+        });\n+\n+        // saving folder identifiers\n+        for (Identifier ident : folderIdents) {\n+            if (!SYSTEM_FOLDER_PATH.equals(ident.getParentPath())) {\n+                ident.setParentPath(ident.getParentPath());\n+                ident.setAssetName(ident.getAssetName());\n+            }\n+            Logger.info(this, \"Importing folder path \" + ident.getParentPath() + ident.getAssetName());\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+        // now we need to save all remaining identifiers (folders already added)\n+        for (final Identifier ident : otherIdents) {\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+\n+\n+        // we store here defaultFileType for every folder\n+        // because of mutual folder <--> structure dependency\n+        final Map<String, String> fileTypesInodes = new HashMap<String, String>();\n+\n+        // now we can import folders\n+        for (File ff : contains(Folder.class.getCanonicalName())) {\n+            try {\n+                doXMLFileImport(ff, new ObjectFilter() {\n+                    public boolean includeIt(Object obj) {\n+                        Folder f = (Folder) obj;\n+                        fileTypesInodes.put(f.getInode(), f.getDefaultFileType());\n+                        f.setDefaultFileType(null);\n+                        return true;\n+                    }\n+                });\n+            } catch (Exception e) {\n+                Logger.error(this, \"Unable to load \" + ff.getName() + \" : \" + e.getMessage(), e);\n+            }\n+        }\n+\n+\n+        // we need content types before contentlets\n+        // but content types have references to folders and hosts identifiers\n+        // so, here is the place to do it\n+        for (File file : endsWith(ContentTypeImportExportUtil.CONTENT_TYPE_FILE_EXTENSION)) {\n+            new ContentTypeImportExportUtil().importContentTypes(file);\n+        }\n+\n+        // updating file_type on folder now that structures were added\n+        DotConnect dc = new DotConnect();\n+        for (Entry<String, String> entry : fileTypesInodes.entrySet()) {\n+            dc.setSQL(\"update folder set default_file_type=? where inode=?\");\n+            dc.addParam(entry.getValue());\n+            dc.addParam(entry.getKey());\n+            dc.loadResult();\n+        }\n+\n+\n+        for (File file : contains(Relationship.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // We have all identifiers, structures and users. Ready to import contentlets!\n+        for (File file : contains(Contentlet.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        for (File file : contains(Template.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.TemplateContainers_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Link.class.getCanonicalName() + \"_\")) {\n+\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Container.class.getCanonicalName()+ \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.ContainerStructure_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.Tree_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // workflow schemas need to come before permissions\n+        for (File file : contains(\"WorkflowSchemeImportExportObject.json\")) {\n+            WorkflowImportExportUtil.getInstance().importWorkflowExport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.Permission_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // finally as all assets are loaded we can import versionInfo files\n+        for (File file : contains(\"VersionInfo_\")) {\n+\n+            doXMLFileImport(file);\n+\n+        }\n+        // We install rules after Version info.\n+        for (File file : contains(\"RuleImportExportObject.json\")) {\n+            RulesImportExportUtil.getInstance().importRules(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowTask_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowHistory_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowComment_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkFlowTaskFiles_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.tag.model.Tag_\")) {\n+            doXMLFileImport(file);\n+        }\n+        // Image, Portlet, Multitree, category\n+        for (File file : endsWith(\".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        cleanUpDBFromImport();\n+        Optional<File> assetDir = tempFiles.stream().filter(f -> (\"asset\".equals(f.getName())||\"assets\".equals(f.getName())) && f.isDirectory()).findAny();\n+        if (assetDir.isPresent()) {\n+            copyAssetDir(assetDir.get());\n+        }\n+        Logger.info(ImportStarterUtil.class, \"Done Importing\");\n+        deleteTempFiles();\n+\n+\n+\n+    }\n+\n+    /**\n+     *\n+     * @param fromAssetDir\n+     * @throws IOException\n+     */\n+    private void copyAssetDir(File fromAssetDir) throws IOException {\n+        File ad = new File(assetPath);\n+\n+        ad.mkdirs();\n+        String[] fileNames = fromAssetDir.list();\n+        for (int i = 0; i < fileNames.length; i++) {\n+            File f = new File(fromAssetDir.getPath() + File.separator + fileNames[i]);\n+            if (f.getName().equals(\".svn\")) {\n+                continue;\n+            }\n+            if (f.getName().equals(\"license.dat\")) {\n+                continue;\n+            }\n+            if (f.isDirectory()) {\n+                FileUtil.copyDirectory(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            } else {\n+                FileUtil.copyFile(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deletes all files from the backupTempFilePath\n+     */\n+    private void deleteTempFiles() {\n+        File f = new File(backupTempFilePath);\n+\n+        FileUtil.deltree(f, true);\n+    }\n+\n+\n+\n+    private void deleteTable(final String table) {\n+\n+        final DotConnect dotConnect = new DotConnect();\n+        dotConnect.setSQL(\"delete from \" + table);\n+        dotConnect.getResult();\n+    }\n+\n+    interface ObjectFilter {\n+        boolean includeIt(Object obj);\n+    }\n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     */\n+    private void doXMLFileImport(File f) throws Exception {\n+        doXMLFileImport(f, null);\n+    }\n+    \n+    \n+    \n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     * @param filter\n+     * @throws DotDataException\n+     * @throws HibernateException\n+     * @throws EncryptorException\n+     * @throws SQLException \n+     * @throws DotSecurityException \n+     * @throws DuplicateUserException \n+     * @throws NoSuchMethodException \n+     * @throws InvocationTargetException \n+     * @throws IllegalAccessException \n+     */\n+    private void doXMLFileImport(File f, ObjectFilter filter) throws Exception {\n+        if (f == null) {\n+            return;\n+        }\n+\n+\n+\n+            Class _importClass = null;\n+            HibernateUtil _dh = null;\n+\n+            boolean counter = false;\n+            boolean image = false;\n+            boolean portlet = false;\n+            boolean logsMappers = false;\n+\n+\n+            Pattern classNamePattern = Pattern.compile(\"_[0-9]{8}\");\n+            Logger.info(this, \"**** Importing the file: \" + f + \" *****\");\n+\n+            /* if we have a multipart import file */\n+            \n+            final String _className = classNamePattern.matcher(f.getName()).find() \n+                   ?  f.getName().substring(0, f.getName().lastIndexOf(\"_\"))\n+                   :   f.getName().substring(0, f.getName().lastIndexOf(\".\"));\n+\n+\n+            if (_className.equals(\"Counter\")) {\n+                counter = true;\n+            } else if (_className.equals(\"Image\")) {\n+                image = true;\n+            } else if (_className.equals(\"Portlet\")) {\n+                portlet = true;\n+            } else if (_className.equals(\"LogsMappers\")) {\n+                logsMappers = true;\n+            } else {\n+                try {\n+                    _importClass = Class.forName(_className);\n+                } catch (Exception e) {\n+                    Logger.error(this, \"Class not found \" + _className);\n+                    return;\n+                }\n+            }\n+\n+            Logger.info(this, \"Importing:\\t\" + _className);\n+\n+\n+            List l = new ArrayList();\n+\n+            List all = (List) BundlerUtil.xmlToObject(f);\n+            if (filter != null) {\n+                for (Object obj : all)\n+                    if (filter.includeIt(obj))\n+                        l.add(obj);\n+            } else {\n+                l = all;\n+            }\n+\n+\n+            Logger.info(this, \"Found :\\t\" + l.size() + \" \" + _className + \"(s)\");\n+            if (counter) {\n+                for (int j = 0; j < l.size(); j++) {\n+                    final HashMap<String, String> dcResults = (HashMap<String, String>) l.get(j);\n+\n+                    DotConnect dc = new DotConnect();\n+                    dc.setSQL(\"insert into counter values (?,?)\");\n+                    dc.addParam(dcResults.get(\"name\"));\n+                    dc.addParam(Integer.valueOf(dcResults.get(\"currentid\")));\n+                    dc.loadResults();\n+\n+                }\n+            } else if (image) {\n+                /*\n+                 * The changes in this part were made for Oracle databases. Oracle has problems when getString()\n+                 * method is called on a LONG field on an Oracle database. Because of this, the object is loaded\n+                 * from liferay and DotConnect is not used\n+                 */\n+                for (int j = 0; j < l.size(); j++) {\n+                    final Image im = (Image) l.get(j);\n+\n+                    DotConnect dc = new DotConnect();\n+                    dc.setSQL(\"insert into image values (?,?)\");\n+                    if (!UtilMethods.isSet(im.getImageId()) && DbConnectionFactory.isOracle()) {\n+                        return;\n+                    }\n+                    dc.addParam(im.getImageId());\n+                    dc.addParam(im.getText());\n+                    dc.loadResults();\n+\n+                }\n+            } else if (portlet) {\n+                for (int j = 0; j < l.size(); j++) {\n+                    final HashMap<String, String> dcResults = (HashMap<String, String>) l.get(j);\n+\n+                    DotConnect dc = new DotConnect();\n+                    StringBuffer sb = new StringBuffer(\"insert into portlet values (?,?,?,?,\");\n+                    if (dcResults.get(\"narrow\").equalsIgnoreCase(\"f\") || dcResults.get(\"narrow\").equalsIgnoreCase(\"false\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 560}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NTky", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959592", "createdAt": "2020-06-16T23:29:21Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyMVrOGkwjew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyMVrOGkwjew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzQzNQ==", "bodyText": "Issue found: Position literals first in String comparisons", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197435", "createdAt": "2020-06-16T23:29:21Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/ImportStarterUtil.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+package com.dotmarketing.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+import org.apache.commons.beanutils.BeanUtils;\n+import com.dotcms.business.WrapInTransaction;\n+import com.dotcms.contenttype.util.ContentTypeImportExportUtil;\n+import com.dotcms.publishing.BundlerUtil;\n+import com.dotcms.repackage.net.sf.hibernate.HibernateException;\n+import com.dotcms.repackage.net.sf.hibernate.persister.AbstractEntityPersister;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.beans.MultiTree;\n+import com.dotmarketing.beans.Tree;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.Layout;\n+import com.dotmarketing.business.LayoutsRoles;\n+import com.dotmarketing.business.PortletsLayouts;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.UsersRoles;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.logConsole.model.LogMapperRow;\n+import com.dotmarketing.portlets.containers.model.Container;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+import com.dotmarketing.portlets.folders.business.FolderAPI;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.links.model.Link;\n+import com.dotmarketing.portlets.rules.util.RulesImportExportUtil;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.portlets.templates.model.Template;\n+import com.dotmarketing.portlets.workflows.util.WorkflowImportExportUtil;\n+import com.dotmarketing.startup.runalways.Task00004LoadStarter;\n+import com.liferay.portal.SystemException;\n+import com.liferay.portal.ejb.CompanyManagerUtil;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.Image;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.Base64;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.EncryptorException;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+\n+\n+/**\n+ * This utility is part of the {@link Task00004LoadStarter} task, which fills the empty dotCMS\n+ * tables on a fresh install with information regarding the Demo Site that the application ships\n+ * with. This allows users to be able to log into the dotCMS back-end and interact with the system\n+ * before adding their own custom content.\n+ *\n+ * @author Jason Tesser\n+ * @version 1.6\n+ *\n+ */\n+public class ImportStarterUtil {\n+\n+    /**\n+     * The path where tmp files are stored. This gets wiped alot\n+     */\n+    private String backupTempFilePath = ConfigUtils.getBackupPath() + File.separator + \"temp\";\n+    private ArrayList<String> classesWithIdentity = new ArrayList<String>();\n+    private Map<String, String> sequences;\n+    private Map<String, String> tableIDColumns;\n+    private Map<String, String> tableNames;\n+    private final String assetPath;\n+\n+\n+    private final List<File> tempFiles;\n+\n+    private static final String SYSTEM_FOLDER_PATH = FolderAPI.SYSTEM_FOLDER_PARENT_PATH;\n+\n+    private final File starterZip;\n+\n+\n+    public ImportStarterUtil(File starterZipFile) {\n+        this.starterZip = starterZipFile;\n+\n+        this.assetPath = ConfigUtils.getAbsoluteAssetsRootPath();\n+        if (!this.validateZipFile()) {\n+            throw new DotRuntimeException(\"starter data invalid\");\n+        }\n+        final File backTemporalFile = new File(getBackupTempFilePath());\n+        \n+        tempFiles = Arrays.asList(backTemporalFile.listFiles()).stream().sorted().collect(Collectors.toList());\n+        tempFiles.removeIf(f -> f.getName().endsWith(\"Counter.xml\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Dashboard\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".FixAudit_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".UserProxy_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".PluginProperty_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Plugin_\"));\n+\n+\n+\n+        classesWithIdentity.add(\"Permission\");\n+        classesWithIdentity.add(\"UsersToDelete\");\n+        tableNames = new HashMap<String, String>();\n+        tableNames.put(\"Permission\", \"permission\");\n+        tableNames.put(\"UsersToDelete\", \"users_to_delete\");\n+\n+        if (DbConnectionFactory.isPostgres() || DbConnectionFactory.isOracle()) {\n+            sequences = new HashMap<String, String>();\n+            sequences.put(\"permission\", \"permission_seq\");\n+            sequences.put(\"users_to_delete\", \"user_to_delete_seq\");\n+            tableIDColumns = new HashMap<String, String>();\n+            tableIDColumns.put(\"permission\", \"id\");\n+            tableIDColumns.put(\"users_to_delete\", \"id\");\n+\n+        }\n+    }\n+\n+    /**\n+     * Takes a ZIP file from the /temp directory to restore dotCMS data. Currently, it will blow away\n+     * all current data. This method cannot currently be run in a transaction. For performance reasons\n+     * with DB drivers and connections it closes the session every so often.\n+     *\n+     * @param out - A print writer for output.\n+     * @throws IOException\n+     * @throws Exception\n+     */\n+    @WrapInTransaction\n+    public void doImport() throws Exception {\n+\n+\n+\n+        Logger.info(this, \"Found \" + tempFiles.size() + \" files to import\");\n+\n+\n+        deleteDotCMS();\n+        \n+\n+        for (File file : endsWith(\"Company.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        List<Role> roles = new ArrayList<Role>();\n+\n+        for (File file : startsWith(\"com.dotmarketing.business.Role_\")) {\n+            roles.addAll((List<Role>) BundlerUtil.xmlToObject(file));\n+        }\n+\n+        Collections.sort(roles);\n+\n+\n+        for (Role role : roles) {\n+            HibernateUtil _dh = new HibernateUtil(Role.class);\n+            String id = HibernateUtil.getSession().getSessionFactory().getClassMetadata(Role.class).getIdentifierPropertyName();\n+\n+            if(UtilMethods.isSet(role.getRoleKey())) {\n+               List<Map<String,Object>>  matches= new DotConnect().setSQL(\"select * from cms_role where role_key =?\").addParam(role.getRoleKey()).loadObjectResults();\n+               Logger.info(this.getClass(), \"roleKey:\" +role.getRoleKey() + \" = \" + matches.size() );\n+            }\n+\n+            _dh.saveWithPrimaryKey(role, role.getId());\n+            HibernateUtil.getSession().flush();\n+        }\n+\n+        for (File file : endsWith(User.class.getCanonicalName() + \".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(UsersRoles.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(Layout.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        \n+        for (File file : contains(PortletsLayouts.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        for (File file : endsWith(\"LogsMappers.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(LayoutsRoles.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        \n+        \n+        for (File file : contains(Language.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        /*\n+         * Because of the parent check we do at db we need to import folder identifiers first but for the\n+         * same reason we need to sort them first by parent_path\n+         */\n+        final List<Identifier> folderIdents = new ArrayList<Identifier>();\n+        final List<Identifier> otherIdents = new ArrayList<Identifier>();\n+\n+        List<File> identifiers = contains(Identifier.class.getCanonicalName());\n+        // collecting all folder identifiers\n+        for (File ff : identifiers) {\n+            List<Identifier> idents = (List<Identifier>) BundlerUtil.xmlToObject(ff);\n+            for (Identifier ident : idents) {\n+                if (ident.getAssetType().equals(\"folder\")) {\n+                    folderIdents.add(ident);\n+                }else {\n+                    otherIdents.add(ident);\n+                }\n+            }\n+        }\n+\n+        // sorting folder identifiers by parent path in order to pass parent check\n+        Collections.sort(folderIdents, new Comparator<Identifier>() {\n+            public int compare(Identifier o1, Identifier o2) {\n+                return o1.getParentPath().compareTo(o2.getParentPath());\n+            }\n+        });\n+\n+        // saving folder identifiers\n+        for (Identifier ident : folderIdents) {\n+            if (!SYSTEM_FOLDER_PATH.equals(ident.getParentPath())) {\n+                ident.setParentPath(ident.getParentPath());\n+                ident.setAssetName(ident.getAssetName());\n+            }\n+            Logger.info(this, \"Importing folder path \" + ident.getParentPath() + ident.getAssetName());\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+        // now we need to save all remaining identifiers (folders already added)\n+        for (final Identifier ident : otherIdents) {\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+\n+\n+        // we store here defaultFileType for every folder\n+        // because of mutual folder <--> structure dependency\n+        final Map<String, String> fileTypesInodes = new HashMap<String, String>();\n+\n+        // now we can import folders\n+        for (File ff : contains(Folder.class.getCanonicalName())) {\n+            try {\n+                doXMLFileImport(ff, new ObjectFilter() {\n+                    public boolean includeIt(Object obj) {\n+                        Folder f = (Folder) obj;\n+                        fileTypesInodes.put(f.getInode(), f.getDefaultFileType());\n+                        f.setDefaultFileType(null);\n+                        return true;\n+                    }\n+                });\n+            } catch (Exception e) {\n+                Logger.error(this, \"Unable to load \" + ff.getName() + \" : \" + e.getMessage(), e);\n+            }\n+        }\n+\n+\n+        // we need content types before contentlets\n+        // but content types have references to folders and hosts identifiers\n+        // so, here is the place to do it\n+        for (File file : endsWith(ContentTypeImportExportUtil.CONTENT_TYPE_FILE_EXTENSION)) {\n+            new ContentTypeImportExportUtil().importContentTypes(file);\n+        }\n+\n+        // updating file_type on folder now that structures were added\n+        DotConnect dc = new DotConnect();\n+        for (Entry<String, String> entry : fileTypesInodes.entrySet()) {\n+            dc.setSQL(\"update folder set default_file_type=? where inode=?\");\n+            dc.addParam(entry.getValue());\n+            dc.addParam(entry.getKey());\n+            dc.loadResult();\n+        }\n+\n+\n+        for (File file : contains(Relationship.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // We have all identifiers, structures and users. Ready to import contentlets!\n+        for (File file : contains(Contentlet.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        for (File file : contains(Template.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.TemplateContainers_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Link.class.getCanonicalName() + \"_\")) {\n+\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Container.class.getCanonicalName()+ \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.ContainerStructure_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.Tree_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // workflow schemas need to come before permissions\n+        for (File file : contains(\"WorkflowSchemeImportExportObject.json\")) {\n+            WorkflowImportExportUtil.getInstance().importWorkflowExport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.Permission_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // finally as all assets are loaded we can import versionInfo files\n+        for (File file : contains(\"VersionInfo_\")) {\n+\n+            doXMLFileImport(file);\n+\n+        }\n+        // We install rules after Version info.\n+        for (File file : contains(\"RuleImportExportObject.json\")) {\n+            RulesImportExportUtil.getInstance().importRules(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowTask_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowHistory_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowComment_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkFlowTaskFiles_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.tag.model.Tag_\")) {\n+            doXMLFileImport(file);\n+        }\n+        // Image, Portlet, Multitree, category\n+        for (File file : endsWith(\".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        cleanUpDBFromImport();\n+        Optional<File> assetDir = tempFiles.stream().filter(f -> (\"asset\".equals(f.getName())||\"assets\".equals(f.getName())) && f.isDirectory()).findAny();\n+        if (assetDir.isPresent()) {\n+            copyAssetDir(assetDir.get());\n+        }\n+        Logger.info(ImportStarterUtil.class, \"Done Importing\");\n+        deleteTempFiles();\n+\n+\n+\n+    }\n+\n+    /**\n+     *\n+     * @param fromAssetDir\n+     * @throws IOException\n+     */\n+    private void copyAssetDir(File fromAssetDir) throws IOException {\n+        File ad = new File(assetPath);\n+\n+        ad.mkdirs();\n+        String[] fileNames = fromAssetDir.list();\n+        for (int i = 0; i < fileNames.length; i++) {\n+            File f = new File(fromAssetDir.getPath() + File.separator + fileNames[i]);\n+            if (f.getName().equals(\".svn\")) {\n+                continue;\n+            }\n+            if (f.getName().equals(\"license.dat\")) {\n+                continue;\n+            }\n+            if (f.isDirectory()) {\n+                FileUtil.copyDirectory(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            } else {\n+                FileUtil.copyFile(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deletes all files from the backupTempFilePath\n+     */\n+    private void deleteTempFiles() {\n+        File f = new File(backupTempFilePath);\n+\n+        FileUtil.deltree(f, true);\n+    }\n+\n+\n+\n+    private void deleteTable(final String table) {\n+\n+        final DotConnect dotConnect = new DotConnect();\n+        dotConnect.setSQL(\"delete from \" + table);\n+        dotConnect.getResult();\n+    }\n+\n+    interface ObjectFilter {\n+        boolean includeIt(Object obj);\n+    }\n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     */\n+    private void doXMLFileImport(File f) throws Exception {\n+        doXMLFileImport(f, null);\n+    }\n+    \n+    \n+    \n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     * @param filter\n+     * @throws DotDataException\n+     * @throws HibernateException\n+     * @throws EncryptorException\n+     * @throws SQLException \n+     * @throws DotSecurityException \n+     * @throws DuplicateUserException \n+     * @throws NoSuchMethodException \n+     * @throws InvocationTargetException \n+     * @throws IllegalAccessException \n+     */\n+    private void doXMLFileImport(File f, ObjectFilter filter) throws Exception {\n+        if (f == null) {\n+            return;\n+        }\n+\n+\n+\n+            Class _importClass = null;\n+            HibernateUtil _dh = null;\n+\n+            boolean counter = false;\n+            boolean image = false;\n+            boolean portlet = false;\n+            boolean logsMappers = false;\n+\n+\n+            Pattern classNamePattern = Pattern.compile(\"_[0-9]{8}\");\n+            Logger.info(this, \"**** Importing the file: \" + f + \" *****\");\n+\n+            /* if we have a multipart import file */\n+            \n+            final String _className = classNamePattern.matcher(f.getName()).find() \n+                   ?  f.getName().substring(0, f.getName().lastIndexOf(\"_\"))\n+                   :   f.getName().substring(0, f.getName().lastIndexOf(\".\"));\n+\n+\n+            if (_className.equals(\"Counter\")) {\n+                counter = true;\n+            } else if (_className.equals(\"Image\")) {\n+                image = true;\n+            } else if (_className.equals(\"Portlet\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 495}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NTk1", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959595", "createdAt": "2020-06-16T23:29:22Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyMlrOGkwjfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyMlrOGkwjfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzQzOA==", "bodyText": "Issue found: Overridable method 'getBackupTempFilePath' called during object construction", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197438", "createdAt": "2020-06-16T23:29:22Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/ImportStarterUtil.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+package com.dotmarketing.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+import org.apache.commons.beanutils.BeanUtils;\n+import com.dotcms.business.WrapInTransaction;\n+import com.dotcms.contenttype.util.ContentTypeImportExportUtil;\n+import com.dotcms.publishing.BundlerUtil;\n+import com.dotcms.repackage.net.sf.hibernate.HibernateException;\n+import com.dotcms.repackage.net.sf.hibernate.persister.AbstractEntityPersister;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.beans.MultiTree;\n+import com.dotmarketing.beans.Tree;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.Layout;\n+import com.dotmarketing.business.LayoutsRoles;\n+import com.dotmarketing.business.PortletsLayouts;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.UsersRoles;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.logConsole.model.LogMapperRow;\n+import com.dotmarketing.portlets.containers.model.Container;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+import com.dotmarketing.portlets.folders.business.FolderAPI;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.links.model.Link;\n+import com.dotmarketing.portlets.rules.util.RulesImportExportUtil;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.portlets.templates.model.Template;\n+import com.dotmarketing.portlets.workflows.util.WorkflowImportExportUtil;\n+import com.dotmarketing.startup.runalways.Task00004LoadStarter;\n+import com.liferay.portal.SystemException;\n+import com.liferay.portal.ejb.CompanyManagerUtil;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.Image;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.Base64;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.EncryptorException;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+\n+\n+/**\n+ * This utility is part of the {@link Task00004LoadStarter} task, which fills the empty dotCMS\n+ * tables on a fresh install with information regarding the Demo Site that the application ships\n+ * with. This allows users to be able to log into the dotCMS back-end and interact with the system\n+ * before adding their own custom content.\n+ *\n+ * @author Jason Tesser\n+ * @version 1.6\n+ *\n+ */\n+public class ImportStarterUtil {\n+\n+    /**\n+     * The path where tmp files are stored. This gets wiped alot\n+     */\n+    private String backupTempFilePath = ConfigUtils.getBackupPath() + File.separator + \"temp\";\n+    private ArrayList<String> classesWithIdentity = new ArrayList<String>();\n+    private Map<String, String> sequences;\n+    private Map<String, String> tableIDColumns;\n+    private Map<String, String> tableNames;\n+    private final String assetPath;\n+\n+\n+    private final List<File> tempFiles;\n+\n+    private static final String SYSTEM_FOLDER_PATH = FolderAPI.SYSTEM_FOLDER_PARENT_PATH;\n+\n+    private final File starterZip;\n+\n+\n+    public ImportStarterUtil(File starterZipFile) {\n+        this.starterZip = starterZipFile;\n+\n+        this.assetPath = ConfigUtils.getAbsoluteAssetsRootPath();\n+        if (!this.validateZipFile()) {\n+            throw new DotRuntimeException(\"starter data invalid\");\n+        }\n+        final File backTemporalFile = new File(getBackupTempFilePath());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NjA1", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959605", "createdAt": "2020-06-16T23:29:23Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyM1rOGkwjhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyM1rOGkwjhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzQ0Nw==", "bodyText": "Issue found: Useless parentheses.", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197447", "createdAt": "2020-06-16T23:29:23Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/common/reindex/ReindexQueueFactory.java", "diffHunk": "@@ -129,6 +126,35 @@ protected void deleteReindexAndFailedRecords() throws DotDataException {\n         dc.addParam(Priority.REINDEX.dbValue());\n         dc.loadResult();\n     }\n+    \n+\n+    /**\n+     * deletes reindex records (when a full reindex has been fired) - and excludes stucture or host index records.\n+     * @throws DotDataException\n+     */\n+    protected void deleteReindexRecords() throws DotDataException {\n+        DotConnect dc = new DotConnect();\n+        dc.setSQL(\"DELETE From dist_reindex_journal where priority >= ? and  priority < ? \");\n+        dc.addParam(Priority.REINDEX.dbValue());\n+        dc.addParam(Priority.ERROR.dbValue());\n+        dc.loadResult();\n+    }\n+    \n+    /**\n+     * returns if there are any reindex records in the queue\n+     * @throws DotDataException\n+     */\n+    protected boolean hasReindexRecords() throws DotDataException {\n+        DotConnect dc = new DotConnect();\n+        String sql = (DbConnectionFactory.isMsSql()) ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NjEy", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959612", "createdAt": "2020-06-16T23:29:24Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyNFrOGkwjjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyNFrOGkwjjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzQ1NQ==", "bodyText": "Issue found: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197455", "createdAt": "2020-06-16T23:29:24Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/db/DotCMSInitDb.java", "diffHunk": "@@ -1,126 +1,113 @@\n package com.dotmarketing.db;\n \n import java.io.File;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.util.List;\n-\n+import org.apache.felix.framework.OSGIUtil;\n import com.dotcms.business.CloseDBIfOpened;\n-import com.dotmarketing.beans.Host;\n+import com.dotcms.business.WrapInTransaction;\n import com.dotmarketing.business.APILocator;\n-import com.dotmarketing.cms.factories.PublicCompanyFactory;\n import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.common.reindex.ReindexThread;\n import com.dotmarketing.exception.DotDataException;\n import com.dotmarketing.exception.DotRuntimeException;\n-import com.dotmarketing.exception.DotSecurityException;\n-import com.dotmarketing.portlets.contentlet.business.HostAPI;\n-import com.dotmarketing.portlets.structure.factories.StructureFactory;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n import com.dotmarketing.util.Config;\n-import com.dotmarketing.util.ImportExportUtil;\n+import com.dotmarketing.util.ImportStarterUtil;\n import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.MaintenanceUtil;\n import com.dotmarketing.util.UtilMethods;\n-import com.liferay.portal.model.User;\n import com.liferay.util.FileUtil;\n-import com.rainerhahnekamp.sneakythrow.Sneaky;\n import io.vavr.control.Try;\n \n public class DotCMSInitDb {\n \n \t@CloseDBIfOpened\n \tprivate static boolean isConfigured () {\n \n-\t\tDotConnect db = new DotConnect();\n-\t\tdb.setSQL(\"select count(*) as test from inode\");\n+\t\treturn new DotConnect()\n+                .setSQL(\"select count(*) as test from inode\")\n+                .getInt(\"test\")>0;\n \n-\t\tint test = db.getInt(\"test\");\n-\t\treturn (test > 0);\n \t}\n \n-\t@CloseDBIfOpened\n-\tpublic static void InitializeDb() throws DotDataException {\n-\n-\t\tfinal boolean configured = isConfigured();\n-\n-\t\tif (!configured) {\n-\t\t\tif(Config.getBooleanProperty(\"STARTERSITE_BUILD\", true)){\n-\t\t\t\tLogger.info(DotCMSInitDb.class,\"There are no inodes - initializing db with starter site\");\n-\t\t\t\ttry {\n-\t\t\t\t\tPrintWriter pw = new PrintWriter(new StringWriter());\n-\t\t\t\t\tloadStarterSite(pw);\n-\t\t\t\t\tLogger.info(DotCMSInitDb.class, pw.toString());\n-\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\tLogger.error(DotCMSInitDb.class, \"Unable to load starter site\", e);\n-\t\t\t\t}\n-\t\t\t}else{\n-\t\t\t\tLogger.info(DotCMSInitDb.class,\"There are no inodes - initializing db for first time use\");\n-\t\t\t\tbuildDefaultData();\n-\t\t\t}\n-\t\t}else {\n-\t\t\tLogger.info(DotCMSInitDb.class,\"inodes exist, skipping initialization of db\");\n-\t\t}\n-\t}\n+    @CloseDBIfOpened\n+    public static void InitializeDb() {\n \n-\tprivate static void buildDefaultData() throws DotDataException {\n-\t\ttry {\n-\t\t\tHostAPI hostAPI = APILocator.getHostAPI();\n-\t\t\tLocalTransaction.wrap(() -> PublicCompanyFactory.createDefaultCompany());\n-\t\t\t// Ensures that default groups are set up\n-\t//\t\tGroupFactory.createDefaultGroups();\n-\t//\t\ttry {\n-\t//\t\t\tLayoutFactory.createDefaultLayouts();\n-\t//\t\t} catch (Exception e) {\n-\t//\t\t\tthrow new DotDataException(e.getMessage(), e);\n-\t//\t\t}\n-\t\t\t// Creating the default host\n-\t\t\tUser systemUser = APILocator.getUserAPI().getSystemUser();\n-\t\t\tList<Host> hosts = hostAPI.findAll(systemUser, false);\n-\t\t\tif (hosts.size() == 0) {\n-\t\t\t\tLogger.debug(DotCMSInitDb.class, \"Creating Default Host\");\n-\t\t\t\thostAPI.findDefaultHost(systemUser, false);\n-\t\t\t}\n-\t        //Create Default Language\n-\t        APILocator.getLanguageAPI().createDefaultLanguage();\n-\t\t\t// Creating the default content structures if it not exists.\n-\t\t\tStructureFactory.createDefaultStructure();\n-\t\t} catch (DotSecurityException e) {\n-\t\t\tLogger.fatal(DotCMSInitDb.class, \"Unable to initialize default data\", e);\n-\t\t\tthrow new DotRuntimeException(e.getMessage(), e);\n-\t\t} catch (Exception e) {\n-\t\t\tLogger.fatal(DotCMSInitDb.class, \"Unable to initialize default data\", e);\n-\t\t\tnew DotDataException(e.getMessage(), e);\n-\t\t}\n-\t}\n+        if (!isConfigured()) {\n \n-\tprivate static void loadStarterSite(PrintWriter pw) throws IOException{\n-\t\t\n-\t\tString starter = Config.getStringProperty(\"STARTER_DATA_LOAD\");\n-\t\tFile starterZip = null;\n-\t\t\n-\t\tif(UtilMethods.isSet(starter)){\n+            Logger.info(DotCMSInitDb.class, \"There are no inodes - initializing db with starter site\");\n+\n+    \n+            \n+            Try.run(() -> loadStarterSite()).getOrElseThrow(e->new DotRuntimeException(e));\n+\n+\n+        } else {\n+            Logger.info(DotCMSInitDb.class, \"inodes exist, skipping initialization of db\");\n+        }\n+    }\n+\n+    \n+    @WrapInTransaction\n+    private static void loadStarterSiteData() throws Exception{\n+        String starter = Config.getStringProperty(\"STARTER_DATA_LOAD\", null);\n+        File starterZip = null;\n+        \n+        if(UtilMethods.isSet(starter)){\n \n-\t\t\t// First we try using the real path\n+            // First we try using the real path\n             starterZip = new File(FileUtil.getRealPath(starter));\n \n             // Then we try to see if there is an absolute path (or relative in case of integration tests)\n             if (!starterZip.exists()) {\n-\t\t\t\tstarterZip = new File(starter);\n-\t\t\t}\n-\t\t}\n+                starterZip = new File(starter);\n+            }\n+        }\n+        \n+        if(starterZip==null || (starterZip!=null && !starterZip.exists())){\n+            String starterSitePath = \"/starter.zip\";\n+            String zipPath = FileUtil.getRealPath(starterSitePath);\n+            starterZip = new File(zipPath); \n+         }\n+        \n+        ImportStarterUtil ieu = new ImportStarterUtil(starterZip);\n+\n+        ieu.doImport();\n+\n+    }\n+    @CloseDBIfOpened\n+\tprivate static void loadStarterSite() throws Exception{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 158}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NjIw", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959620", "createdAt": "2020-06-16T23:29:25Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyNVrOGkwjlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyNVrOGkwjlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzQ2Mw==", "bodyText": "Issue found: This statement should have braces", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197463", "createdAt": "2020-06-16T23:29:25Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/ImportStarterUtil.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+package com.dotmarketing.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+import org.apache.commons.beanutils.BeanUtils;\n+import com.dotcms.business.WrapInTransaction;\n+import com.dotcms.contenttype.util.ContentTypeImportExportUtil;\n+import com.dotcms.publishing.BundlerUtil;\n+import com.dotcms.repackage.net.sf.hibernate.HibernateException;\n+import com.dotcms.repackage.net.sf.hibernate.persister.AbstractEntityPersister;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.beans.MultiTree;\n+import com.dotmarketing.beans.Tree;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.Layout;\n+import com.dotmarketing.business.LayoutsRoles;\n+import com.dotmarketing.business.PortletsLayouts;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.UsersRoles;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.logConsole.model.LogMapperRow;\n+import com.dotmarketing.portlets.containers.model.Container;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+import com.dotmarketing.portlets.folders.business.FolderAPI;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.links.model.Link;\n+import com.dotmarketing.portlets.rules.util.RulesImportExportUtil;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.portlets.templates.model.Template;\n+import com.dotmarketing.portlets.workflows.util.WorkflowImportExportUtil;\n+import com.dotmarketing.startup.runalways.Task00004LoadStarter;\n+import com.liferay.portal.SystemException;\n+import com.liferay.portal.ejb.CompanyManagerUtil;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.Image;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.Base64;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.EncryptorException;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+\n+\n+/**\n+ * This utility is part of the {@link Task00004LoadStarter} task, which fills the empty dotCMS\n+ * tables on a fresh install with information regarding the Demo Site that the application ships\n+ * with. This allows users to be able to log into the dotCMS back-end and interact with the system\n+ * before adding their own custom content.\n+ *\n+ * @author Jason Tesser\n+ * @version 1.6\n+ *\n+ */\n+public class ImportStarterUtil {\n+\n+    /**\n+     * The path where tmp files are stored. This gets wiped alot\n+     */\n+    private String backupTempFilePath = ConfigUtils.getBackupPath() + File.separator + \"temp\";\n+    private ArrayList<String> classesWithIdentity = new ArrayList<String>();\n+    private Map<String, String> sequences;\n+    private Map<String, String> tableIDColumns;\n+    private Map<String, String> tableNames;\n+    private final String assetPath;\n+\n+\n+    private final List<File> tempFiles;\n+\n+    private static final String SYSTEM_FOLDER_PATH = FolderAPI.SYSTEM_FOLDER_PARENT_PATH;\n+\n+    private final File starterZip;\n+\n+\n+    public ImportStarterUtil(File starterZipFile) {\n+        this.starterZip = starterZipFile;\n+\n+        this.assetPath = ConfigUtils.getAbsoluteAssetsRootPath();\n+        if (!this.validateZipFile()) {\n+            throw new DotRuntimeException(\"starter data invalid\");\n+        }\n+        final File backTemporalFile = new File(getBackupTempFilePath());\n+        \n+        tempFiles = Arrays.asList(backTemporalFile.listFiles()).stream().sorted().collect(Collectors.toList());\n+        tempFiles.removeIf(f -> f.getName().endsWith(\"Counter.xml\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Dashboard\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".FixAudit_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".UserProxy_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".PluginProperty_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Plugin_\"));\n+\n+\n+\n+        classesWithIdentity.add(\"Permission\");\n+        classesWithIdentity.add(\"UsersToDelete\");\n+        tableNames = new HashMap<String, String>();\n+        tableNames.put(\"Permission\", \"permission\");\n+        tableNames.put(\"UsersToDelete\", \"users_to_delete\");\n+\n+        if (DbConnectionFactory.isPostgres() || DbConnectionFactory.isOracle()) {\n+            sequences = new HashMap<String, String>();\n+            sequences.put(\"permission\", \"permission_seq\");\n+            sequences.put(\"users_to_delete\", \"user_to_delete_seq\");\n+            tableIDColumns = new HashMap<String, String>();\n+            tableIDColumns.put(\"permission\", \"id\");\n+            tableIDColumns.put(\"users_to_delete\", \"id\");\n+\n+        }\n+    }\n+\n+    /**\n+     * Takes a ZIP file from the /temp directory to restore dotCMS data. Currently, it will blow away\n+     * all current data. This method cannot currently be run in a transaction. For performance reasons\n+     * with DB drivers and connections it closes the session every so often.\n+     *\n+     * @param out - A print writer for output.\n+     * @throws IOException\n+     * @throws Exception\n+     */\n+    @WrapInTransaction\n+    public void doImport() throws Exception {\n+\n+\n+\n+        Logger.info(this, \"Found \" + tempFiles.size() + \" files to import\");\n+\n+\n+        deleteDotCMS();\n+        \n+\n+        for (File file : endsWith(\"Company.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        List<Role> roles = new ArrayList<Role>();\n+\n+        for (File file : startsWith(\"com.dotmarketing.business.Role_\")) {\n+            roles.addAll((List<Role>) BundlerUtil.xmlToObject(file));\n+        }\n+\n+        Collections.sort(roles);\n+\n+\n+        for (Role role : roles) {\n+            HibernateUtil _dh = new HibernateUtil(Role.class);\n+            String id = HibernateUtil.getSession().getSessionFactory().getClassMetadata(Role.class).getIdentifierPropertyName();\n+\n+            if(UtilMethods.isSet(role.getRoleKey())) {\n+               List<Map<String,Object>>  matches= new DotConnect().setSQL(\"select * from cms_role where role_key =?\").addParam(role.getRoleKey()).loadObjectResults();\n+               Logger.info(this.getClass(), \"roleKey:\" +role.getRoleKey() + \" = \" + matches.size() );\n+            }\n+\n+            _dh.saveWithPrimaryKey(role, role.getId());\n+            HibernateUtil.getSession().flush();\n+        }\n+\n+        for (File file : endsWith(User.class.getCanonicalName() + \".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(UsersRoles.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(Layout.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        \n+        for (File file : contains(PortletsLayouts.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        for (File file : endsWith(\"LogsMappers.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(LayoutsRoles.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        \n+        \n+        for (File file : contains(Language.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        /*\n+         * Because of the parent check we do at db we need to import folder identifiers first but for the\n+         * same reason we need to sort them first by parent_path\n+         */\n+        final List<Identifier> folderIdents = new ArrayList<Identifier>();\n+        final List<Identifier> otherIdents = new ArrayList<Identifier>();\n+\n+        List<File> identifiers = contains(Identifier.class.getCanonicalName());\n+        // collecting all folder identifiers\n+        for (File ff : identifiers) {\n+            List<Identifier> idents = (List<Identifier>) BundlerUtil.xmlToObject(ff);\n+            for (Identifier ident : idents) {\n+                if (ident.getAssetType().equals(\"folder\")) {\n+                    folderIdents.add(ident);\n+                }else {\n+                    otherIdents.add(ident);\n+                }\n+            }\n+        }\n+\n+        // sorting folder identifiers by parent path in order to pass parent check\n+        Collections.sort(folderIdents, new Comparator<Identifier>() {\n+            public int compare(Identifier o1, Identifier o2) {\n+                return o1.getParentPath().compareTo(o2.getParentPath());\n+            }\n+        });\n+\n+        // saving folder identifiers\n+        for (Identifier ident : folderIdents) {\n+            if (!SYSTEM_FOLDER_PATH.equals(ident.getParentPath())) {\n+                ident.setParentPath(ident.getParentPath());\n+                ident.setAssetName(ident.getAssetName());\n+            }\n+            Logger.info(this, \"Importing folder path \" + ident.getParentPath() + ident.getAssetName());\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+        // now we need to save all remaining identifiers (folders already added)\n+        for (final Identifier ident : otherIdents) {\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+\n+\n+        // we store here defaultFileType for every folder\n+        // because of mutual folder <--> structure dependency\n+        final Map<String, String> fileTypesInodes = new HashMap<String, String>();\n+\n+        // now we can import folders\n+        for (File ff : contains(Folder.class.getCanonicalName())) {\n+            try {\n+                doXMLFileImport(ff, new ObjectFilter() {\n+                    public boolean includeIt(Object obj) {\n+                        Folder f = (Folder) obj;\n+                        fileTypesInodes.put(f.getInode(), f.getDefaultFileType());\n+                        f.setDefaultFileType(null);\n+                        return true;\n+                    }\n+                });\n+            } catch (Exception e) {\n+                Logger.error(this, \"Unable to load \" + ff.getName() + \" : \" + e.getMessage(), e);\n+            }\n+        }\n+\n+\n+        // we need content types before contentlets\n+        // but content types have references to folders and hosts identifiers\n+        // so, here is the place to do it\n+        for (File file : endsWith(ContentTypeImportExportUtil.CONTENT_TYPE_FILE_EXTENSION)) {\n+            new ContentTypeImportExportUtil().importContentTypes(file);\n+        }\n+\n+        // updating file_type on folder now that structures were added\n+        DotConnect dc = new DotConnect();\n+        for (Entry<String, String> entry : fileTypesInodes.entrySet()) {\n+            dc.setSQL(\"update folder set default_file_type=? where inode=?\");\n+            dc.addParam(entry.getValue());\n+            dc.addParam(entry.getKey());\n+            dc.loadResult();\n+        }\n+\n+\n+        for (File file : contains(Relationship.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // We have all identifiers, structures and users. Ready to import contentlets!\n+        for (File file : contains(Contentlet.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        for (File file : contains(Template.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.TemplateContainers_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Link.class.getCanonicalName() + \"_\")) {\n+\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Container.class.getCanonicalName()+ \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.ContainerStructure_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.Tree_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // workflow schemas need to come before permissions\n+        for (File file : contains(\"WorkflowSchemeImportExportObject.json\")) {\n+            WorkflowImportExportUtil.getInstance().importWorkflowExport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.Permission_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // finally as all assets are loaded we can import versionInfo files\n+        for (File file : contains(\"VersionInfo_\")) {\n+\n+            doXMLFileImport(file);\n+\n+        }\n+        // We install rules after Version info.\n+        for (File file : contains(\"RuleImportExportObject.json\")) {\n+            RulesImportExportUtil.getInstance().importRules(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowTask_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowHistory_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowComment_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkFlowTaskFiles_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.tag.model.Tag_\")) {\n+            doXMLFileImport(file);\n+        }\n+        // Image, Portlet, Multitree, category\n+        for (File file : endsWith(\".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        cleanUpDBFromImport();\n+        Optional<File> assetDir = tempFiles.stream().filter(f -> (\"asset\".equals(f.getName())||\"assets\".equals(f.getName())) && f.isDirectory()).findAny();\n+        if (assetDir.isPresent()) {\n+            copyAssetDir(assetDir.get());\n+        }\n+        Logger.info(ImportStarterUtil.class, \"Done Importing\");\n+        deleteTempFiles();\n+\n+\n+\n+    }\n+\n+    /**\n+     *\n+     * @param fromAssetDir\n+     * @throws IOException\n+     */\n+    private void copyAssetDir(File fromAssetDir) throws IOException {\n+        File ad = new File(assetPath);\n+\n+        ad.mkdirs();\n+        String[] fileNames = fromAssetDir.list();\n+        for (int i = 0; i < fileNames.length; i++) {\n+            File f = new File(fromAssetDir.getPath() + File.separator + fileNames[i]);\n+            if (f.getName().equals(\".svn\")) {\n+                continue;\n+            }\n+            if (f.getName().equals(\"license.dat\")) {\n+                continue;\n+            }\n+            if (f.isDirectory()) {\n+                FileUtil.copyDirectory(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            } else {\n+                FileUtil.copyFile(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deletes all files from the backupTempFilePath\n+     */\n+    private void deleteTempFiles() {\n+        File f = new File(backupTempFilePath);\n+\n+        FileUtil.deltree(f, true);\n+    }\n+\n+\n+\n+    private void deleteTable(final String table) {\n+\n+        final DotConnect dotConnect = new DotConnect();\n+        dotConnect.setSQL(\"delete from \" + table);\n+        dotConnect.getResult();\n+    }\n+\n+    interface ObjectFilter {\n+        boolean includeIt(Object obj);\n+    }\n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     */\n+    private void doXMLFileImport(File f) throws Exception {\n+        doXMLFileImport(f, null);\n+    }\n+    \n+    \n+    \n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     * @param filter\n+     * @throws DotDataException\n+     * @throws HibernateException\n+     * @throws EncryptorException\n+     * @throws SQLException \n+     * @throws DotSecurityException \n+     * @throws DuplicateUserException \n+     * @throws NoSuchMethodException \n+     * @throws InvocationTargetException \n+     * @throws IllegalAccessException \n+     */\n+    private void doXMLFileImport(File f, ObjectFilter filter) throws Exception {\n+        if (f == null) {\n+            return;\n+        }\n+\n+\n+\n+            Class _importClass = null;\n+            HibernateUtil _dh = null;\n+\n+            boolean counter = false;\n+            boolean image = false;\n+            boolean portlet = false;\n+            boolean logsMappers = false;\n+\n+\n+            Pattern classNamePattern = Pattern.compile(\"_[0-9]{8}\");\n+            Logger.info(this, \"**** Importing the file: \" + f + \" *****\");\n+\n+            /* if we have a multipart import file */\n+            \n+            final String _className = classNamePattern.matcher(f.getName()).find() \n+                   ?  f.getName().substring(0, f.getName().lastIndexOf(\"_\"))\n+                   :   f.getName().substring(0, f.getName().lastIndexOf(\".\"));\n+\n+\n+            if (_className.equals(\"Counter\")) {\n+                counter = true;\n+            } else if (_className.equals(\"Image\")) {\n+                image = true;\n+            } else if (_className.equals(\"Portlet\")) {\n+                portlet = true;\n+            } else if (_className.equals(\"LogsMappers\")) {\n+                logsMappers = true;\n+            } else {\n+                try {\n+                    _importClass = Class.forName(_className);\n+                } catch (Exception e) {\n+                    Logger.error(this, \"Class not found \" + _className);\n+                    return;\n+                }\n+            }\n+\n+            Logger.info(this, \"Importing:\\t\" + _className);\n+\n+\n+            List l = new ArrayList();\n+\n+            List all = (List) BundlerUtil.xmlToObject(f);\n+            if (filter != null) {\n+                for (Object obj : all)\n+                    if (filter.includeIt(obj))\n+                        l.add(obj);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 517}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NjI4", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959628", "createdAt": "2020-06-16T23:29:26Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyNlrOGkwjpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyNlrOGkwjpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzQ3OQ==", "bodyText": "Issue found: This final field could be made static", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197479", "createdAt": "2020-06-16T23:29:26Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/startup/StartupTasksExecutor.java", "diffHunk": "@@ -10,346 +13,207 @@\n import com.dotmarketing.util.Logger;\n import com.dotmarketing.util.TaskLocatorUtil;\n \n-import java.sql.Connection;\n-import java.sql.Date;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.sql.Statement;\n-import java.util.Calendar;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.List;\n-\n public class StartupTasksExecutor {\n \n \t\n \tprivate static StartupTasksExecutor executor;\n \n-\tprivate String pgLock = \"lock table db_version;\";\n-\tprivate String myLock = \"lock table db_version write;\";\n-\tprivate String oraLock = \"LOCK TABLE DB_VERSION IN EXCLUSIVE MODE\";\n-\tprivate String msLock = \"SELECT * FROM db_version WITH (XLOCK)\";\n-\tprivate String h2Lock = \"SELECT * FROM db_version FOR UPDATE\";\n-\n-\tprivate String pgCommit = \"commit;\";\n-\tprivate String myCommit = \"unlock tables\";\n-\tprivate String oraCommit = \"COMMIT\";\n-\tprivate String msCommit = \"COMMIT\";\n-\tprivate String h2Commit = \"COMMIT\";\n-\n-\tprivate String pgCreate = \"CREATE TABLE db_version (db_version integer NOT NULL, date_update timestamp with time zone NOT NULL, CONSTRAINT db_version_pkey PRIMARY KEY (db_version));\";\n-\tprivate String myCreate = \"CREATE TABLE `db_version` (`db_version` INTEGER UNSIGNED NOT NULL,`date_update` DATETIME NOT NULL, PRIMARY KEY (`db_version`))\";\n-\tprivate String oraCreate = \"CREATE TABLE \\\"DB_VERSION\\\" ( \\\"DB_VERSION\\\" INTEGER NOT NULL , \\\"DATE_UPDATE\\\" TIMESTAMP NOT NULL, PRIMARY KEY (\\\"DB_VERSION\\\") )\";\n-\tprivate String msCreate =\"CREATE TABLE db_version (\tdb_version int NOT NULL , date_update datetime NOT NULL, PRIMARY KEY (db_version) )\";\n-\tprivate String h2Create = \"CREATE TABLE db_version (db_version integer NOT NULL, date_update timestamp NOT NULL, CONSTRAINT db_version_pkey PRIMARY KEY (db_version))\";\n-\t\n-\tprivate String pgSelect = \"SELECT max(db_version) AS db_version FROM db_version\";\n-\tprivate String mySelect = \"SELECT max(db_version) AS db_version FROM db_version\";\n-\tprivate String oraSelect = \"SELECT max(db_version) AS db_version FROM db_version\";\n-\tprivate String msSelect = \"SELECT max(db_version) AS db_version FROM db_version\";\n-\tprivate String h2Select = \"SELECT max(db_version) AS db_version FROM db_version\";\n \n-\tprivate String lock;\n-\tprivate String commit;\n-\tprivate String create;\n-\tprivate String select;\n \n \n+\tprivate final String pgCreate  = \"CREATE TABLE db_version (db_version integer NOT NULL, date_update timestamp with time zone NOT NULL, CONSTRAINT db_version_pkey PRIMARY KEY (db_version));\";\n+\tprivate final String myCreate  = \"CREATE TABLE `db_version` (`db_version` INTEGER UNSIGNED NOT NULL,`date_update` DATETIME NOT NULL, PRIMARY KEY (`db_version`))\";\n+\tprivate final String oraCreate = \"CREATE TABLE \\\"DB_VERSION\\\" ( \\\"DB_VERSION\\\" INTEGER NOT NULL , \\\"DATE_UPDATE\\\" TIMESTAMP NOT NULL, PRIMARY KEY (\\\"DB_VERSION\\\") )\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NjM4", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959638", "createdAt": "2020-06-16T23:29:27Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyN1rOGkwjsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyN1rOGkwjsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzQ4OQ==", "bodyText": "Issue found: Avoid variables with short names like l", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197489", "createdAt": "2020-06-16T23:29:27Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/ImportStarterUtil.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+package com.dotmarketing.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+import org.apache.commons.beanutils.BeanUtils;\n+import com.dotcms.business.WrapInTransaction;\n+import com.dotcms.contenttype.util.ContentTypeImportExportUtil;\n+import com.dotcms.publishing.BundlerUtil;\n+import com.dotcms.repackage.net.sf.hibernate.HibernateException;\n+import com.dotcms.repackage.net.sf.hibernate.persister.AbstractEntityPersister;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.beans.MultiTree;\n+import com.dotmarketing.beans.Tree;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.Layout;\n+import com.dotmarketing.business.LayoutsRoles;\n+import com.dotmarketing.business.PortletsLayouts;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.UsersRoles;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.logConsole.model.LogMapperRow;\n+import com.dotmarketing.portlets.containers.model.Container;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+import com.dotmarketing.portlets.folders.business.FolderAPI;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.links.model.Link;\n+import com.dotmarketing.portlets.rules.util.RulesImportExportUtil;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.portlets.templates.model.Template;\n+import com.dotmarketing.portlets.workflows.util.WorkflowImportExportUtil;\n+import com.dotmarketing.startup.runalways.Task00004LoadStarter;\n+import com.liferay.portal.SystemException;\n+import com.liferay.portal.ejb.CompanyManagerUtil;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.Image;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.Base64;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.EncryptorException;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+\n+\n+/**\n+ * This utility is part of the {@link Task00004LoadStarter} task, which fills the empty dotCMS\n+ * tables on a fresh install with information regarding the Demo Site that the application ships\n+ * with. This allows users to be able to log into the dotCMS back-end and interact with the system\n+ * before adding their own custom content.\n+ *\n+ * @author Jason Tesser\n+ * @version 1.6\n+ *\n+ */\n+public class ImportStarterUtil {\n+\n+    /**\n+     * The path where tmp files are stored. This gets wiped alot\n+     */\n+    private String backupTempFilePath = ConfigUtils.getBackupPath() + File.separator + \"temp\";\n+    private ArrayList<String> classesWithIdentity = new ArrayList<String>();\n+    private Map<String, String> sequences;\n+    private Map<String, String> tableIDColumns;\n+    private Map<String, String> tableNames;\n+    private final String assetPath;\n+\n+\n+    private final List<File> tempFiles;\n+\n+    private static final String SYSTEM_FOLDER_PATH = FolderAPI.SYSTEM_FOLDER_PARENT_PATH;\n+\n+    private final File starterZip;\n+\n+\n+    public ImportStarterUtil(File starterZipFile) {\n+        this.starterZip = starterZipFile;\n+\n+        this.assetPath = ConfigUtils.getAbsoluteAssetsRootPath();\n+        if (!this.validateZipFile()) {\n+            throw new DotRuntimeException(\"starter data invalid\");\n+        }\n+        final File backTemporalFile = new File(getBackupTempFilePath());\n+        \n+        tempFiles = Arrays.asList(backTemporalFile.listFiles()).stream().sorted().collect(Collectors.toList());\n+        tempFiles.removeIf(f -> f.getName().endsWith(\"Counter.xml\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Dashboard\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".FixAudit_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".UserProxy_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".PluginProperty_\"));\n+        tempFiles.removeIf(f -> f.getName().contains(\".Plugin_\"));\n+\n+\n+\n+        classesWithIdentity.add(\"Permission\");\n+        classesWithIdentity.add(\"UsersToDelete\");\n+        tableNames = new HashMap<String, String>();\n+        tableNames.put(\"Permission\", \"permission\");\n+        tableNames.put(\"UsersToDelete\", \"users_to_delete\");\n+\n+        if (DbConnectionFactory.isPostgres() || DbConnectionFactory.isOracle()) {\n+            sequences = new HashMap<String, String>();\n+            sequences.put(\"permission\", \"permission_seq\");\n+            sequences.put(\"users_to_delete\", \"user_to_delete_seq\");\n+            tableIDColumns = new HashMap<String, String>();\n+            tableIDColumns.put(\"permission\", \"id\");\n+            tableIDColumns.put(\"users_to_delete\", \"id\");\n+\n+        }\n+    }\n+\n+    /**\n+     * Takes a ZIP file from the /temp directory to restore dotCMS data. Currently, it will blow away\n+     * all current data. This method cannot currently be run in a transaction. For performance reasons\n+     * with DB drivers and connections it closes the session every so often.\n+     *\n+     * @param out - A print writer for output.\n+     * @throws IOException\n+     * @throws Exception\n+     */\n+    @WrapInTransaction\n+    public void doImport() throws Exception {\n+\n+\n+\n+        Logger.info(this, \"Found \" + tempFiles.size() + \" files to import\");\n+\n+\n+        deleteDotCMS();\n+        \n+\n+        for (File file : endsWith(\"Company.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        List<Role> roles = new ArrayList<Role>();\n+\n+        for (File file : startsWith(\"com.dotmarketing.business.Role_\")) {\n+            roles.addAll((List<Role>) BundlerUtil.xmlToObject(file));\n+        }\n+\n+        Collections.sort(roles);\n+\n+\n+        for (Role role : roles) {\n+            HibernateUtil _dh = new HibernateUtil(Role.class);\n+            String id = HibernateUtil.getSession().getSessionFactory().getClassMetadata(Role.class).getIdentifierPropertyName();\n+\n+            if(UtilMethods.isSet(role.getRoleKey())) {\n+               List<Map<String,Object>>  matches= new DotConnect().setSQL(\"select * from cms_role where role_key =?\").addParam(role.getRoleKey()).loadObjectResults();\n+               Logger.info(this.getClass(), \"roleKey:\" +role.getRoleKey() + \" = \" + matches.size() );\n+            }\n+\n+            _dh.saveWithPrimaryKey(role, role.getId());\n+            HibernateUtil.getSession().flush();\n+        }\n+\n+        for (File file : endsWith(User.class.getCanonicalName() + \".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(UsersRoles.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(Layout.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        \n+        for (File file : contains(PortletsLayouts.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+\n+        \n+        for (File file : endsWith(\"LogsMappers.xml\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(LayoutsRoles.class.getCanonicalName())) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        \n+        \n+        for (File file : contains(Language.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        /*\n+         * Because of the parent check we do at db we need to import folder identifiers first but for the\n+         * same reason we need to sort them first by parent_path\n+         */\n+        final List<Identifier> folderIdents = new ArrayList<Identifier>();\n+        final List<Identifier> otherIdents = new ArrayList<Identifier>();\n+\n+        List<File> identifiers = contains(Identifier.class.getCanonicalName());\n+        // collecting all folder identifiers\n+        for (File ff : identifiers) {\n+            List<Identifier> idents = (List<Identifier>) BundlerUtil.xmlToObject(ff);\n+            for (Identifier ident : idents) {\n+                if (ident.getAssetType().equals(\"folder\")) {\n+                    folderIdents.add(ident);\n+                }else {\n+                    otherIdents.add(ident);\n+                }\n+            }\n+        }\n+\n+        // sorting folder identifiers by parent path in order to pass parent check\n+        Collections.sort(folderIdents, new Comparator<Identifier>() {\n+            public int compare(Identifier o1, Identifier o2) {\n+                return o1.getParentPath().compareTo(o2.getParentPath());\n+            }\n+        });\n+\n+        // saving folder identifiers\n+        for (Identifier ident : folderIdents) {\n+            if (!SYSTEM_FOLDER_PATH.equals(ident.getParentPath())) {\n+                ident.setParentPath(ident.getParentPath());\n+                ident.setAssetName(ident.getAssetName());\n+            }\n+            Logger.info(this, \"Importing folder path \" + ident.getParentPath() + ident.getAssetName());\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+        // now we need to save all remaining identifiers (folders already added)\n+        for (final Identifier ident : otherIdents) {\n+            APILocator.getIdentifierAPI().save(ident);\n+        }\n+\n+\n+\n+        // we store here defaultFileType for every folder\n+        // because of mutual folder <--> structure dependency\n+        final Map<String, String> fileTypesInodes = new HashMap<String, String>();\n+\n+        // now we can import folders\n+        for (File ff : contains(Folder.class.getCanonicalName())) {\n+            try {\n+                doXMLFileImport(ff, new ObjectFilter() {\n+                    public boolean includeIt(Object obj) {\n+                        Folder f = (Folder) obj;\n+                        fileTypesInodes.put(f.getInode(), f.getDefaultFileType());\n+                        f.setDefaultFileType(null);\n+                        return true;\n+                    }\n+                });\n+            } catch (Exception e) {\n+                Logger.error(this, \"Unable to load \" + ff.getName() + \" : \" + e.getMessage(), e);\n+            }\n+        }\n+\n+\n+        // we need content types before contentlets\n+        // but content types have references to folders and hosts identifiers\n+        // so, here is the place to do it\n+        for (File file : endsWith(ContentTypeImportExportUtil.CONTENT_TYPE_FILE_EXTENSION)) {\n+            new ContentTypeImportExportUtil().importContentTypes(file);\n+        }\n+\n+        // updating file_type on folder now that structures were added\n+        DotConnect dc = new DotConnect();\n+        for (Entry<String, String> entry : fileTypesInodes.entrySet()) {\n+            dc.setSQL(\"update folder set default_file_type=? where inode=?\");\n+            dc.addParam(entry.getValue());\n+            dc.addParam(entry.getKey());\n+            dc.loadResult();\n+        }\n+\n+\n+        for (File file : contains(Relationship.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // We have all identifiers, structures and users. Ready to import contentlets!\n+        for (File file : contains(Contentlet.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        for (File file : contains(Template.class.getCanonicalName() + \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.TemplateContainers_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Link.class.getCanonicalName() + \"_\")) {\n+\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(Container.class.getCanonicalName()+ \"_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.ContainerStructure_\")) {\n+            doXMLFileImport(file);\n+        }\n+        \n+        for (File file : contains(\"com.dotmarketing.beans.Tree_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // workflow schemas need to come before permissions\n+        for (File file : contains(\"WorkflowSchemeImportExportObject.json\")) {\n+            WorkflowImportExportUtil.getInstance().importWorkflowExport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.beans.Permission_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        // finally as all assets are loaded we can import versionInfo files\n+        for (File file : contains(\"VersionInfo_\")) {\n+\n+            doXMLFileImport(file);\n+\n+        }\n+        // We install rules after Version info.\n+        for (File file : contains(\"RuleImportExportObject.json\")) {\n+            RulesImportExportUtil.getInstance().importRules(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowTask_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowHistory_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkflowComment_\")) {\n+            doXMLFileImport(file);\n+        }\n+        for (File file : contains(\"com.dotmarketing.portlets.workflows.model.WorkFlowTaskFiles_\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+        for (File file : contains(\"com.dotmarketing.tag.model.Tag_\")) {\n+            doXMLFileImport(file);\n+        }\n+        // Image, Portlet, Multitree, category\n+        for (File file : endsWith(\".xml\")) {\n+            doXMLFileImport(file);\n+        }\n+\n+\n+        cleanUpDBFromImport();\n+        Optional<File> assetDir = tempFiles.stream().filter(f -> (\"asset\".equals(f.getName())||\"assets\".equals(f.getName())) && f.isDirectory()).findAny();\n+        if (assetDir.isPresent()) {\n+            copyAssetDir(assetDir.get());\n+        }\n+        Logger.info(ImportStarterUtil.class, \"Done Importing\");\n+        deleteTempFiles();\n+\n+\n+\n+    }\n+\n+    /**\n+     *\n+     * @param fromAssetDir\n+     * @throws IOException\n+     */\n+    private void copyAssetDir(File fromAssetDir) throws IOException {\n+        File ad = new File(assetPath);\n+\n+        ad.mkdirs();\n+        String[] fileNames = fromAssetDir.list();\n+        for (int i = 0; i < fileNames.length; i++) {\n+            File f = new File(fromAssetDir.getPath() + File.separator + fileNames[i]);\n+            if (f.getName().equals(\".svn\")) {\n+                continue;\n+            }\n+            if (f.getName().equals(\"license.dat\")) {\n+                continue;\n+            }\n+            if (f.isDirectory()) {\n+                FileUtil.copyDirectory(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            } else {\n+                FileUtil.copyFile(f.getPath(), ad.getPath() + File.separator + f.getName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Deletes all files from the backupTempFilePath\n+     */\n+    private void deleteTempFiles() {\n+        File f = new File(backupTempFilePath);\n+\n+        FileUtil.deltree(f, true);\n+    }\n+\n+\n+\n+    private void deleteTable(final String table) {\n+\n+        final DotConnect dotConnect = new DotConnect();\n+        dotConnect.setSQL(\"delete from \" + table);\n+        dotConnect.getResult();\n+    }\n+\n+    interface ObjectFilter {\n+        boolean includeIt(Object obj);\n+    }\n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     */\n+    private void doXMLFileImport(File f) throws Exception {\n+        doXMLFileImport(f, null);\n+    }\n+    \n+    \n+    \n+\n+    /**\n+     * This method takes an XML file and will try to import it via XStream and Hibernate.\n+     *\n+     * @param f - File to be parsed and imported.\n+     * @param out - Printwriter to write responses to Reponse Printwriter so this method can write to\n+     *        screen.\n+     * @param filter\n+     * @throws DotDataException\n+     * @throws HibernateException\n+     * @throws EncryptorException\n+     * @throws SQLException \n+     * @throws DotSecurityException \n+     * @throws DuplicateUserException \n+     * @throws NoSuchMethodException \n+     * @throws InvocationTargetException \n+     * @throws IllegalAccessException \n+     */\n+    private void doXMLFileImport(File f, ObjectFilter filter) throws Exception {\n+        if (f == null) {\n+            return;\n+        }\n+\n+\n+\n+            Class _importClass = null;\n+            HibernateUtil _dh = null;\n+\n+            boolean counter = false;\n+            boolean image = false;\n+            boolean portlet = false;\n+            boolean logsMappers = false;\n+\n+\n+            Pattern classNamePattern = Pattern.compile(\"_[0-9]{8}\");\n+            Logger.info(this, \"**** Importing the file: \" + f + \" *****\");\n+\n+            /* if we have a multipart import file */\n+            \n+            final String _className = classNamePattern.matcher(f.getName()).find() \n+                   ?  f.getName().substring(0, f.getName().lastIndexOf(\"_\"))\n+                   :   f.getName().substring(0, f.getName().lastIndexOf(\".\"));\n+\n+\n+            if (_className.equals(\"Counter\")) {\n+                counter = true;\n+            } else if (_className.equals(\"Image\")) {\n+                image = true;\n+            } else if (_className.equals(\"Portlet\")) {\n+                portlet = true;\n+            } else if (_className.equals(\"LogsMappers\")) {\n+                logsMappers = true;\n+            } else {\n+                try {\n+                    _importClass = Class.forName(_className);\n+                } catch (Exception e) {\n+                    Logger.error(this, \"Class not found \" + _className);\n+                    return;\n+                }\n+            }\n+\n+            Logger.info(this, \"Importing:\\t\" + _className);\n+\n+\n+            List l = new ArrayList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 511}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NjQ0", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959644", "createdAt": "2020-06-16T23:29:28Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyOFrOGkwjtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyOFrOGkwjtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzQ5Mg==", "bodyText": "Issue found: Private field 'classesWithIdentity' could be made final; it is only initialized in the declaration or constructor.", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197492", "createdAt": "2020-06-16T23:29:28Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/ImportStarterUtil.java", "diffHunk": "@@ -0,0 +1,1148 @@\n+package com.dotmarketing.util;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.file.Files;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipFile;\n+import org.apache.commons.beanutils.BeanUtils;\n+import com.dotcms.business.WrapInTransaction;\n+import com.dotcms.contenttype.util.ContentTypeImportExportUtil;\n+import com.dotcms.publishing.BundlerUtil;\n+import com.dotcms.repackage.net.sf.hibernate.HibernateException;\n+import com.dotcms.repackage.net.sf.hibernate.persister.AbstractEntityPersister;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.beans.MultiTree;\n+import com.dotmarketing.beans.Tree;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.Layout;\n+import com.dotmarketing.business.LayoutsRoles;\n+import com.dotmarketing.business.PortletsLayouts;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.UsersRoles;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.logConsole.model.LogMapperRow;\n+import com.dotmarketing.portlets.containers.model.Container;\n+import com.dotmarketing.portlets.contentlet.business.Contentlet;\n+import com.dotmarketing.portlets.folders.business.FolderAPI;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.links.model.Link;\n+import com.dotmarketing.portlets.rules.util.RulesImportExportUtil;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.portlets.templates.model.Template;\n+import com.dotmarketing.portlets.workflows.util.WorkflowImportExportUtil;\n+import com.dotmarketing.startup.runalways.Task00004LoadStarter;\n+import com.liferay.portal.SystemException;\n+import com.liferay.portal.ejb.CompanyManagerUtil;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.Image;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.Base64;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.EncryptorException;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+\n+\n+/**\n+ * This utility is part of the {@link Task00004LoadStarter} task, which fills the empty dotCMS\n+ * tables on a fresh install with information regarding the Demo Site that the application ships\n+ * with. This allows users to be able to log into the dotCMS back-end and interact with the system\n+ * before adding their own custom content.\n+ *\n+ * @author Jason Tesser\n+ * @version 1.6\n+ *\n+ */\n+public class ImportStarterUtil {\n+\n+    /**\n+     * The path where tmp files are stored. This gets wiped alot\n+     */\n+    private String backupTempFilePath = ConfigUtils.getBackupPath() + File.separator + \"temp\";\n+    private ArrayList<String> classesWithIdentity = new ArrayList<String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 88}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NjQ3", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959647", "createdAt": "2020-06-16T23:29:29Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyOVrOGkwjuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOToyOVrOGkwjuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzQ5Nw==", "bodyText": "Issue found: The String literal \"from \" appears 6 times in this file; the first occurrence is on line 144", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197497", "createdAt": "2020-06-16T23:29:29Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/ExportStarterUtil.java", "diffHunk": "@@ -0,0 +1,300 @@\n+package com.dotmarketing.util;\n+\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import javax.servlet.ServletException;\n+import com.dotcms.business.CloseDBIfOpened;\n+import com.dotcms.contenttype.util.ContentTypeImportExportUtil;\n+import com.dotcms.publishing.BundlerUtil;\n+import com.dotcms.util.transform.TransformerLocator;\n+import com.dotmarketing.beans.Clickstream;\n+import com.dotmarketing.beans.Clickstream404;\n+import com.dotmarketing.beans.ClickstreamRequest;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.beans.Inode;\n+import com.dotmarketing.beans.MultiTree;\n+import com.dotmarketing.beans.PermissionReference;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.portlets.calendar.model.CalendarReminder;\n+import com.dotmarketing.portlets.cmsmaintenance.util.AssetFileNameFilter;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.portlets.rules.util.RulesImportExportUtil;\n+import com.dotmarketing.portlets.structure.model.Field;\n+import com.dotmarketing.portlets.structure.model.Relationship;\n+import com.dotmarketing.portlets.structure.model.Structure;\n+import com.dotmarketing.portlets.workflows.model.WorkflowHistory;\n+import com.dotmarketing.portlets.workflows.util.WorkflowImportExportUtil;\n+import com.dotmarketing.tag.model.Tag;\n+import com.dotmarketing.tag.model.TagInode;\n+import com.google.common.collect.ImmutableList;\n+import com.liferay.portal.ejb.ImageLocalManagerUtil;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.FileUtil;\n+\n+public class ExportStarterUtil {\n+\n+    \n+\n+    final File outputDirectory;\n+    \n+    public ExportStarterUtil() {\n+        \n+        outputDirectory = new File(ConfigUtils.getBackupPath() + File.separator + \"backup_\" + System.currentTimeMillis());\n+        outputDirectory.mkdirs();\n+       \n+        \n+    }\n+    \n+    public File createStarterWithAssets() throws FileNotFoundException, IOException {\n+        \n+        moveAssetsToBackupDir();\n+        return createStarterData() ;\n+        \n+    }\n+    \n+    public File createStarterData() {\n+        createXMLFiles() ;\n+        \n+        return outputDirectory;\n+        \n+        \n+    }\n+    \n+    \n+    /**\n+     * This method will pull a list of all tables /classed being managed by\n+     * hibernate and export them, one class per file to the backupTempFilePath\n+     * as valid XML. It uses XStream to write the xml out to the files.\n+     *\n+     * @throws ServletException\n+     * @throws IOException\n+     * @author Will\n+     * @throws DotDataException\n+     */\n+    @CloseDBIfOpened\n+    private void createXMLFiles()  {\n+\n+        Logger.info(this, \"Starting createXMLFiles into \" + outputDirectory);\n+\n+        final Set<Class> _tablesToDump = new HashSet<Class>();\n+        try {\n+\n+            /* get a list of all our tables */\n+            //Including Identifier.class and Language.class because it is not mapped with Hibernate anymore\n+            _tablesToDump.add(Identifier.class);\n+            _tablesToDump.add(Language.class);\n+            _tablesToDump.add(Relationship.class);\n+            _tablesToDump.addAll(HibernateUtil.getSession().getSessionFactory().getAllClassMetadata().keySet());\n+\n+            _tablesToDump.removeIf(c->c.equals(Inode.class));\n+            _tablesToDump.removeIf(c->c.equals(Clickstream.class));\n+            _tablesToDump.removeIf(c->c.equals(ClickstreamRequest.class));\n+            _tablesToDump.removeIf(c->c.equals(Clickstream404.class));\n+            _tablesToDump.removeIf(c->c.equals(Structure.class));\n+            _tablesToDump.removeIf(c->c.equals(Field.class));\n+            _tablesToDump.removeIf(c->c.equals(WorkflowHistory.class));\n+            _tablesToDump.removeIf(c->c.equals(PermissionReference.class));\n+            \n+            _tablesToDump.removeIf(t->t.getName().startsWith(\"Dashboard\"));\n+            _tablesToDump.removeIf(t->t.getName().contains(\"HBM\"));\n+\n+\n+            HibernateUtil _dh = null;\n+            DotConnect dc = null;\n+            List _list = null;\n+            File _writing = null;\n+            java.text.NumberFormat formatter = new java.text.DecimalFormat(\"0000000000\");\n+\n+            for (Class clazz : _tablesToDump) {\n+\n+\n+                /*\n+                 * String _shortClassName =\n+                 * clazz.getName().substring(clazz.getName().lastIndexOf(\".\"),clazz.getName().length());\n+                 * xstream.alias(_shortClassName, clazz);\n+                 */\n+                int i= 0;\n+                int step = 1000;\n+                int total =0;\n+                \n+                /* we will only export 10,000,000 items of any given type */\n+                for(i=0;i < 10000000;i=i+step){\n+\n+                    _dh = new HibernateUtil(clazz);\n+                    _dh.setFirstResult(i);\n+                    _dh.setMaxResults(step);\n+\n+                    //This line was previously like;\n+                    //_dh.setQuery(\"from \" + clazz.getName() + \" order by 1,2\");\n+                    //This caused a problem when the database is Oracle because Oracle causes problems when the results are ordered\n+                    //by an NCLOB field. In the case of dot_containers table, the second field, CODE, is an NCLOB field. Because of this,\n+                    //ordering is done only on the first field for the tables, which is INODE\n+                    if(com.dotmarketing.beans.Tree.class.equals(clazz)){\n+                        _dh.setQuery(\"from \" + clazz.getName() + \" order by parent, child, relation_type\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 142}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTU5NjU3", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-431959657", "createdAt": "2020-06-16T23:29:30Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOTozMFrOGkwjwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzoyOTozMFrOGkwjwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzUwNg==", "bodyText": "Issue found: Classes implementing Serializable should set a serialVersionUID", "url": "https://github.com/dotCMS/core/pull/18584#discussion_r441197506", "createdAt": "2020-06-16T23:29:30Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/common/reindex/ReIndexerStatus.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package com.dotmarketing.common.reindex;\n+\n+import com.dotcms.content.elasticsearch.business.ESIndexAPI;\n+import java.io.Serializable;\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import com.dotcms.business.CloseDBIfOpened;\n+import com.dotcms.content.elasticsearch.business.ContentletIndexAPIImpl;\n+import com.dotcms.content.elasticsearch.business.IndiciesInfo;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNTg2MzM5", "url": "https://github.com/dotCMS/core/pull/18584#pullrequestreview-432586339", "createdAt": "2020-06-17T16:46:09Z", "commit": {"oid": "47c5aa37695a630085c8d2f3fa49d093322fb3a0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 885, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}