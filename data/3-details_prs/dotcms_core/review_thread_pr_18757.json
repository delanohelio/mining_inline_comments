{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4NzM3Njg4", "number": 18757, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMToxMjo1M1rOEIh-zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMToxMjo1M1rOEIh-zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzgwODE1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppsAPIImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMToxMjo1M1rOGojU3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMToxMjo1M1rOGojU3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3NTAwNg==", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "url": "https://github.com/dotCMS/core/pull/18757#discussion_r445175006", "createdAt": "2020-06-24T21:12:53Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppsAPIImpl.java", "diffHunk": "@@ -389,51 +388,78 @@ private void deleteSecrets(final String key, final String siteIdentifier, final\n         }\n \n         final String appKeyLC = key.toLowerCase();\n-        final AppDescriptorMeta appDescriptorMeta = getAppDescriptorMap()\n+        final AppDescriptor appDescriptorMeta = getAppDescriptorMap()\n                 .get(appKeyLC);\n         return null == appDescriptorMeta ? Optional.empty()\n-                : Optional.of(appDescriptorMeta.getAppDescriptor());\n+                : Optional.of(appDescriptorMeta);\n     }\n \n     @Override\n-    public AppDescriptor createAppDescriptor(final InputStream inputStream,\n-            final User user) throws IOException, DotDataException, AlreadyExistException, DotSecurityException {\n+    public AppDescriptor createAppDescriptor(final File file,\n+            final User user) throws DotDataException, AlreadyExistException, DotSecurityException {\n         if (userDoesNotHaveAccess(user)) {\n             throw new DotSecurityException(String.format(\n-                    \"Invalid attempt to create an App descriptor performed by user with id `%s`.\",\n+                    \"Invalid attempt to create an app descriptor performed by user with id `%s`.\",\n                     user.getUserId()));\n         }\n-\n         final String ymlFilesPath = getServiceDescriptorDirectory();\n         final File basePath = new File(ymlFilesPath);\n         if (!basePath.exists()) {\n-            basePath.mkdir();\n-        }\n-        Logger.debug(AppsAPIImpl.class,\n-                () -> \" ymlFiles are set under:  \" + ymlFilesPath);\n-\n-        // Now validate the incoming file.. see if we're rewriting an existing file or attempting to re-use an already in use service-key.\n-        final AppDescriptor serviceDescriptor = ymlMapper\n-                .readValue(inputStream, AppDescriptor.class);\n+            basePath.mkdirs();\n+        }\n+        Logger.debug(AppsAPIImpl.class, () -> \" ymlFiles are set under:  \" + ymlFilesPath);\n+\n+            final AppSchema appSchema = readAppFile(file);\n+            // Now validate the incoming file.. see if we're rewriting an existing file or attempting to re-use an already in use service-key.\n+            if (validateServiceDescriptor(appSchema)) {\n+                final File incomingFile = new File(basePath, file.getName());\n+                if (incomingFile.exists()) {\n+                    throw new AlreadyExistException(\n+                            String.format(\n+                                    \"Invalid attempt to override an existing file named '%s'.\",\n+                                    incomingFile.getName()));\n+                }\n \n-        if (validateServiceDescriptor(serviceDescriptor)\n-                && validateAppDescriptorUniqueName(serviceDescriptor)) {\n+                writeAppFile(incomingFile, appSchema);\n \n-            final String serviceKey = serviceDescriptor.getKey();\n-            final File incomingFile = new File(basePath, String.format(\"%s.yml\", serviceKey));\n-            if (incomingFile.exists()) {\n-                throw new AlreadyExistException(\n-                        String.format(\"Invalid attempt to override an existing file named '%s'.\",\n-                                incomingFile.getName()));\n+                invalidateCache();\n             }\n+            return new AppDescriptorImpl(file.getName(), appSchema);\n \n-            ymlMapper.writeValue(incomingFile, serviceDescriptor);\n+    }\n \n-            invalidateCache();\n+    /**\n+     * There's a version of the method readValue on the ymlMapper which takes a file and internally creates directly a FileInputStream\n+     * According to https://dzone.com/articles/fileinputstream-fileoutputstream-considered-harmful\n+     * that's very harmful\n+     * @param file\n+     * @return\n+     * @throws DotDataException\n+     */\n+    private AppSchema readAppFile(final File file) throws DotDataException {\n+        try (InputStream inputStream = Files.newInputStream(Paths.get(file.getPath()))) {\n+            return ymlMapper.readValue(inputStream, AppSchema.class);\n+        }catch (Exception e){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "471cd14d4cc246f6e4b0e47b522d3c86fbedd567"}, "originalPosition": 127}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2014, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}