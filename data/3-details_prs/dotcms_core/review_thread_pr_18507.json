{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE4ODEwOTU5", "number": 18507, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDozMzoxM1rOD9a9RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNToyMDoyMVrOECnIfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzMxMzk3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDozMzoxM1rOGW58IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo0NzoyMlrOGXt-8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3MTEzNg==", "bodyText": "here you can do\nfinal List inodeList = result.stream().map(row -> row.get(\"inode\")).collect(Collectors.toList());", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r426671136", "createdAt": "2020-05-18T14:33:13Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "diffHunk": "@@ -679,64 +681,87 @@ private void deleteTreesForInodes(List<String> inodes) throws DotDataException {\n     }\n \n \t@Override\n-\tprotected int deleteOldContent(Date deleteFrom) throws DotDataException {\n-\t    ContentletCache cc = CacheLocator.getContentletCache();\n-        Calendar calendar = Calendar.getInstance();\n+    protected int deleteOldContent(final Date deleteFrom) throws DotDataException {\n+        final Calendar calendar = Calendar.getInstance();\n         calendar.setTime(deleteFrom);\n         calendar.set(Calendar.HOUR_OF_DAY, 0);\n         calendar.set(Calendar.MINUTE, 0);\n         calendar.set(Calendar.SECOND, 0);\n         calendar.set(Calendar.MILLISECOND, 0);\n-        Date date = calendar.getTime();\n-        //Because of the way Oracle databases handle dates,\n-        //this string is converted to Uppercase.This does\n-        //not cause a problem with the other databases\n-        DotConnect dc = new DotConnect();\n+        final Date date = calendar.getTime();\n \n-        String countSQL = (\"select count(*) as count from contentlet\");\n+        DotConnect dc = new DotConnect();\n+        final String countSQL = \"select count(*) as count from contentlet\";\n         dc.setSQL(countSQL);\n         List<Map<String, String>> result = dc.loadResults();\n-        int before = Integer.parseInt(result.get(0).get(\"count\"));\n-\n-        String deleteContentletSQL = \"delete from contentlet where identifier<>'SYSTEM_HOST' and mod_date < ? \" +\n-        \"and not exists (select * from contentlet_version_info where working_inode=contentlet.inode or live_inode=contentlet.inode)\";\n-        dc.setSQL(deleteContentletSQL);\n-        dc.addParam(date);\n-        dc.loadResult();\n-\n-        String deleteOrphanInodes=\"delete from inode where type='contentlet' and idate < ? and inode not in (select inode from contentlet)\";\n-        dc.setSQL(deleteOrphanInodes);\n+        final int before = Integer.parseInt(result.get(0).get(\"count\"));\n+        dc = new DotConnect();\n+        dc.setSQL(\"SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < ? AND NOT EXISTS \" +\n+                \"(SELECT working_inode, live_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode OR \" +\n+                \"live_inode = contentlet.inode)\");\n         dc.addParam(date);\n-        dc.loadResult();\n-\n+        result = dc.loadResults();\n+        int oldInodesCount = result.size();\n+        if (oldInodesCount > 0) {\n+            final List<String> inodeList = new ArrayList<>();\n+            for (final Map<String, String> row : result) {\n+                inodeList.add(row.get(\"inode\").toString());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "886a8bfa5eca55deffeaf98234a5c2e73d758f4e"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMzgyNQ==", "bodyText": "Fixed.", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r427523825", "createdAt": "2020-05-19T18:47:22Z", "author": {"login": "jcastro-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "diffHunk": "@@ -679,64 +681,87 @@ private void deleteTreesForInodes(List<String> inodes) throws DotDataException {\n     }\n \n \t@Override\n-\tprotected int deleteOldContent(Date deleteFrom) throws DotDataException {\n-\t    ContentletCache cc = CacheLocator.getContentletCache();\n-        Calendar calendar = Calendar.getInstance();\n+    protected int deleteOldContent(final Date deleteFrom) throws DotDataException {\n+        final Calendar calendar = Calendar.getInstance();\n         calendar.setTime(deleteFrom);\n         calendar.set(Calendar.HOUR_OF_DAY, 0);\n         calendar.set(Calendar.MINUTE, 0);\n         calendar.set(Calendar.SECOND, 0);\n         calendar.set(Calendar.MILLISECOND, 0);\n-        Date date = calendar.getTime();\n-        //Because of the way Oracle databases handle dates,\n-        //this string is converted to Uppercase.This does\n-        //not cause a problem with the other databases\n-        DotConnect dc = new DotConnect();\n+        final Date date = calendar.getTime();\n \n-        String countSQL = (\"select count(*) as count from contentlet\");\n+        DotConnect dc = new DotConnect();\n+        final String countSQL = \"select count(*) as count from contentlet\";\n         dc.setSQL(countSQL);\n         List<Map<String, String>> result = dc.loadResults();\n-        int before = Integer.parseInt(result.get(0).get(\"count\"));\n-\n-        String deleteContentletSQL = \"delete from contentlet where identifier<>'SYSTEM_HOST' and mod_date < ? \" +\n-        \"and not exists (select * from contentlet_version_info where working_inode=contentlet.inode or live_inode=contentlet.inode)\";\n-        dc.setSQL(deleteContentletSQL);\n-        dc.addParam(date);\n-        dc.loadResult();\n-\n-        String deleteOrphanInodes=\"delete from inode where type='contentlet' and idate < ? and inode not in (select inode from contentlet)\";\n-        dc.setSQL(deleteOrphanInodes);\n+        final int before = Integer.parseInt(result.get(0).get(\"count\"));\n+        dc = new DotConnect();\n+        dc.setSQL(\"SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < ? AND NOT EXISTS \" +\n+                \"(SELECT working_inode, live_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode OR \" +\n+                \"live_inode = contentlet.inode)\");\n         dc.addParam(date);\n-        dc.loadResult();\n-\n+        result = dc.loadResults();\n+        int oldInodesCount = result.size();\n+        if (oldInodesCount > 0) {\n+            final List<String> inodeList = new ArrayList<>();\n+            for (final Map<String, String> row : result) {\n+                inodeList.add(row.get(\"inode\").toString());\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3MTEzNg=="}, "originalCommit": {"oid": "886a8bfa5eca55deffeaf98234a5c2e73d758f4e"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzMyNjY3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDozNjoxMFrOGW6ECA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo0NzoyN1rOGXt_IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3MzE2MA==", "bodyText": "I think all this logic should go into a private method\nhttps://github.com/dotCMS/core/pull/18507/files#diff-0d54bf61089532e67d512211809b7a69R710-R727", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r426673160", "createdAt": "2020-05-18T14:36:10Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "diffHunk": "@@ -679,64 +681,87 @@ private void deleteTreesForInodes(List<String> inodes) throws DotDataException {\n     }\n \n \t@Override\n-\tprotected int deleteOldContent(Date deleteFrom) throws DotDataException {\n-\t    ContentletCache cc = CacheLocator.getContentletCache();\n-        Calendar calendar = Calendar.getInstance();\n+    protected int deleteOldContent(final Date deleteFrom) throws DotDataException {\n+        final Calendar calendar = Calendar.getInstance();\n         calendar.setTime(deleteFrom);\n         calendar.set(Calendar.HOUR_OF_DAY, 0);\n         calendar.set(Calendar.MINUTE, 0);\n         calendar.set(Calendar.SECOND, 0);\n         calendar.set(Calendar.MILLISECOND, 0);\n-        Date date = calendar.getTime();\n-        //Because of the way Oracle databases handle dates,\n-        //this string is converted to Uppercase.This does\n-        //not cause a problem with the other databases\n-        DotConnect dc = new DotConnect();\n+        final Date date = calendar.getTime();\n \n-        String countSQL = (\"select count(*) as count from contentlet\");\n+        DotConnect dc = new DotConnect();\n+        final String countSQL = \"select count(*) as count from contentlet\";\n         dc.setSQL(countSQL);\n         List<Map<String, String>> result = dc.loadResults();\n-        int before = Integer.parseInt(result.get(0).get(\"count\"));\n-\n-        String deleteContentletSQL = \"delete from contentlet where identifier<>'SYSTEM_HOST' and mod_date < ? \" +\n-        \"and not exists (select * from contentlet_version_info where working_inode=contentlet.inode or live_inode=contentlet.inode)\";\n-        dc.setSQL(deleteContentletSQL);\n-        dc.addParam(date);\n-        dc.loadResult();\n-\n-        String deleteOrphanInodes=\"delete from inode where type='contentlet' and idate < ? and inode not in (select inode from contentlet)\";\n-        dc.setSQL(deleteOrphanInodes);\n+        final int before = Integer.parseInt(result.get(0).get(\"count\"));\n+        dc = new DotConnect();\n+        dc.setSQL(\"SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < ? AND NOT EXISTS \" +\n+                \"(SELECT working_inode, live_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode OR \" +\n+                \"live_inode = contentlet.inode)\");\n         dc.addParam(date);\n-        dc.loadResult();\n-\n+        result = dc.loadResults();\n+        int oldInodesCount = result.size();\n+        if (oldInodesCount > 0) {\n+            final List<String> inodeList = new ArrayList<>();\n+            for (final Map<String, String> row : result) {\n+                inodeList.add(row.get(\"inode\").toString());\n+            }\n+            final int splitAt = 100;\n+            // Split all records into lists of size 'truncateAt'\n+            final List<List<String>> inodesToDelete = Lists.partition(inodeList, splitAt);\n+            final List<String> queries = Lists.newArrayList(\"DELETE FROM contentlet WHERE inode IN (?)\",\n+                    \"DELETE FROM inode WHERE inode IN (?)\");\n+            for (final String query : queries) {\n+                for (final List<String> inodes : inodesToDelete) {\n+                    dc = new DotConnect();\n+                    // Generate the \"(?,?,?...)\" string depending of the number of inodes\n+                    final String parameterPlaceholders = DotConnect.createParametersPlaceholder(inodes.size());\n+                    dc.setSQL(query.replace(\"?\", parameterPlaceholders));\n+                    for (final String inode : inodes) {\n+                        dc.addParam(inode);\n+                    }\n+                    dc.loadResult();\n+                }\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "886a8bfa5eca55deffeaf98234a5c2e73d758f4e"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMzg3Mw==", "bodyText": "Fixed.", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r427523873", "createdAt": "2020-05-19T18:47:27Z", "author": {"login": "jcastro-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "diffHunk": "@@ -679,64 +681,87 @@ private void deleteTreesForInodes(List<String> inodes) throws DotDataException {\n     }\n \n \t@Override\n-\tprotected int deleteOldContent(Date deleteFrom) throws DotDataException {\n-\t    ContentletCache cc = CacheLocator.getContentletCache();\n-        Calendar calendar = Calendar.getInstance();\n+    protected int deleteOldContent(final Date deleteFrom) throws DotDataException {\n+        final Calendar calendar = Calendar.getInstance();\n         calendar.setTime(deleteFrom);\n         calendar.set(Calendar.HOUR_OF_DAY, 0);\n         calendar.set(Calendar.MINUTE, 0);\n         calendar.set(Calendar.SECOND, 0);\n         calendar.set(Calendar.MILLISECOND, 0);\n-        Date date = calendar.getTime();\n-        //Because of the way Oracle databases handle dates,\n-        //this string is converted to Uppercase.This does\n-        //not cause a problem with the other databases\n-        DotConnect dc = new DotConnect();\n+        final Date date = calendar.getTime();\n \n-        String countSQL = (\"select count(*) as count from contentlet\");\n+        DotConnect dc = new DotConnect();\n+        final String countSQL = \"select count(*) as count from contentlet\";\n         dc.setSQL(countSQL);\n         List<Map<String, String>> result = dc.loadResults();\n-        int before = Integer.parseInt(result.get(0).get(\"count\"));\n-\n-        String deleteContentletSQL = \"delete from contentlet where identifier<>'SYSTEM_HOST' and mod_date < ? \" +\n-        \"and not exists (select * from contentlet_version_info where working_inode=contentlet.inode or live_inode=contentlet.inode)\";\n-        dc.setSQL(deleteContentletSQL);\n-        dc.addParam(date);\n-        dc.loadResult();\n-\n-        String deleteOrphanInodes=\"delete from inode where type='contentlet' and idate < ? and inode not in (select inode from contentlet)\";\n-        dc.setSQL(deleteOrphanInodes);\n+        final int before = Integer.parseInt(result.get(0).get(\"count\"));\n+        dc = new DotConnect();\n+        dc.setSQL(\"SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < ? AND NOT EXISTS \" +\n+                \"(SELECT working_inode, live_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode OR \" +\n+                \"live_inode = contentlet.inode)\");\n         dc.addParam(date);\n-        dc.loadResult();\n-\n+        result = dc.loadResults();\n+        int oldInodesCount = result.size();\n+        if (oldInodesCount > 0) {\n+            final List<String> inodeList = new ArrayList<>();\n+            for (final Map<String, String> row : result) {\n+                inodeList.add(row.get(\"inode\").toString());\n+            }\n+            final int splitAt = 100;\n+            // Split all records into lists of size 'truncateAt'\n+            final List<List<String>> inodesToDelete = Lists.partition(inodeList, splitAt);\n+            final List<String> queries = Lists.newArrayList(\"DELETE FROM contentlet WHERE inode IN (?)\",\n+                    \"DELETE FROM inode WHERE inode IN (?)\");\n+            for (final String query : queries) {\n+                for (final List<String> inodes : inodesToDelete) {\n+                    dc = new DotConnect();\n+                    // Generate the \"(?,?,?...)\" string depending of the number of inodes\n+                    final String parameterPlaceholders = DotConnect.createParametersPlaceholder(inodes.size());\n+                    dc.setSQL(query.replace(\"?\", parameterPlaceholders));\n+                    for (final String inode : inodes) {\n+                        dc.addParam(inode);\n+                    }\n+                    dc.loadResult();\n+                }\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3MzE2MA=="}, "originalCommit": {"oid": "886a8bfa5eca55deffeaf98234a5c2e73d758f4e"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1NzMzODA3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOFQxNDozODozM1rOGW6Kvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo0NzozMlrOGXt_SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3NDg3OA==", "bodyText": "All this logic should go into a method too\nhttps://github.com/dotCMS/core/pull/18507/files#diff-0d54bf61089532e67d512211809b7a69R731-R755", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r426674878", "createdAt": "2020-05-18T14:38:33Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "diffHunk": "@@ -679,64 +681,87 @@ private void deleteTreesForInodes(List<String> inodes) throws DotDataException {\n     }\n \n \t@Override\n-\tprotected int deleteOldContent(Date deleteFrom) throws DotDataException {\n-\t    ContentletCache cc = CacheLocator.getContentletCache();\n-        Calendar calendar = Calendar.getInstance();\n+    protected int deleteOldContent(final Date deleteFrom) throws DotDataException {\n+        final Calendar calendar = Calendar.getInstance();\n         calendar.setTime(deleteFrom);\n         calendar.set(Calendar.HOUR_OF_DAY, 0);\n         calendar.set(Calendar.MINUTE, 0);\n         calendar.set(Calendar.SECOND, 0);\n         calendar.set(Calendar.MILLISECOND, 0);\n-        Date date = calendar.getTime();\n-        //Because of the way Oracle databases handle dates,\n-        //this string is converted to Uppercase.This does\n-        //not cause a problem with the other databases\n-        DotConnect dc = new DotConnect();\n+        final Date date = calendar.getTime();\n \n-        String countSQL = (\"select count(*) as count from contentlet\");\n+        DotConnect dc = new DotConnect();\n+        final String countSQL = \"select count(*) as count from contentlet\";\n         dc.setSQL(countSQL);\n         List<Map<String, String>> result = dc.loadResults();\n-        int before = Integer.parseInt(result.get(0).get(\"count\"));\n-\n-        String deleteContentletSQL = \"delete from contentlet where identifier<>'SYSTEM_HOST' and mod_date < ? \" +\n-        \"and not exists (select * from contentlet_version_info where working_inode=contentlet.inode or live_inode=contentlet.inode)\";\n-        dc.setSQL(deleteContentletSQL);\n-        dc.addParam(date);\n-        dc.loadResult();\n-\n-        String deleteOrphanInodes=\"delete from inode where type='contentlet' and idate < ? and inode not in (select inode from contentlet)\";\n-        dc.setSQL(deleteOrphanInodes);\n+        final int before = Integer.parseInt(result.get(0).get(\"count\"));\n+        dc = new DotConnect();\n+        dc.setSQL(\"SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < ? AND NOT EXISTS \" +\n+                \"(SELECT working_inode, live_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode OR \" +\n+                \"live_inode = contentlet.inode)\");\n         dc.addParam(date);\n-        dc.loadResult();\n-\n+        result = dc.loadResults();\n+        int oldInodesCount = result.size();\n+        if (oldInodesCount > 0) {\n+            final List<String> inodeList = new ArrayList<>();\n+            for (final Map<String, String> row : result) {\n+                inodeList.add(row.get(\"inode\").toString());\n+            }\n+            final int splitAt = 100;\n+            // Split all records into lists of size 'truncateAt'\n+            final List<List<String>> inodesToDelete = Lists.partition(inodeList, splitAt);\n+            final List<String> queries = Lists.newArrayList(\"DELETE FROM contentlet WHERE inode IN (?)\",\n+                    \"DELETE FROM inode WHERE inode IN (?)\");\n+            for (final String query : queries) {\n+                for (final List<String> inodes : inodesToDelete) {\n+                    dc = new DotConnect();\n+                    // Generate the \"(?,?,?...)\" string depending of the number of inodes\n+                    final String parameterPlaceholders = DotConnect.createParametersPlaceholder(inodes.size());\n+                    dc.setSQL(query.replace(\"?\", parameterPlaceholders));\n+                    for (final String inode : inodes) {\n+                        dc.addParam(inode);\n+                    }\n+                    dc.loadResult();\n+                }\n+            }\n+        }\n+        dc = new DotConnect();\n         dc.setSQL(countSQL);\n         result = dc.loadResults();\n-        int after = Integer.parseInt(result.get(0).get(\"count\"));\n-\n-        int deleted=before - after;\n-\n-        // deleting orphan binary files\n-        java.io.File assets=new java.io.File(APILocator.getFileAssetAPI().getRealAssetsRootPath());\n-        for(java.io.File ff1 : assets.listFiles())\n-            if(ff1.isDirectory() && ff1.getName().length()==1 && ff1.getName().matches(\"^[a-f0-9]$\"))\n-                for(java.io.File ff2 : ff1.listFiles())\n-                    if(ff2.isDirectory() && ff2.getName().length()==1 && ff2.getName().matches(\"^[a-f0-9]$\"))\n-                        for(java.io.File ff3 : ff2.listFiles())\n-                            try {\n-                                if(ff3.isDirectory()) {\n-                                    Contentlet con=find(ff3.getName());\n-                                    if(con==null || !UtilMethods.isSet(con.getIdentifier()))\n-                                        if(!FileUtils.deleteQuietly(ff3))\n-                                            Logger.warn(this, \"can't delete \"+ff3.getAbsolutePath());\n+        final int after = Integer.parseInt(result.get(0).get(\"count\"));\n+        final int deleted = before - after;\n+        if (deleted > 0) {\n+            // Deleting orphaned binary files\n+            final java.io.File assets = new java.io.File(APILocator.getFileAssetAPI().getRealAssetsRootPath());\n+            for (final java.io.File firstLevelFolder : assets.listFiles()) {\n+                if (firstLevelFolder.isDirectory() && firstLevelFolder.getName().length() == 1 && firstLevelFolder\n+                        .getName().matches(\"^[a-f0-9]$\")) {\n+                    for (final java.io.File secondLevelFolder : firstLevelFolder.listFiles()) {\n+                        if (secondLevelFolder.isDirectory() && secondLevelFolder.getName().length() == 1 &&\n+                                secondLevelFolder.getName().matches(\"^[a-f0-9]$\")) {\n+                            for (final java.io.File asset : secondLevelFolder.listFiles()) {\n+                                try {\n+                                    if (asset.isDirectory()) {\n+                                        final Contentlet contentlet = find(asset.getName());\n+                                        if (null == contentlet || !UtilMethods.isSet(contentlet.getIdentifier())) {\n+                                            if (!FileUtils.deleteQuietly(asset)) {\n+                                                Logger.warn(this, \"Asset '\" + asset.getAbsolutePath() + \"' could \" +\n+                                                        \"not be deleted.\");\n+                                            }\n+                                        }\n+                                    }\n+                                } catch (final Exception ex) {\n+                                    Logger.warn(this, String.format(\"An error occurred when deleting asset '%s': %s\",\n+                                            asset.getAbsolutePath(), ex.getMessage()));\n                                 }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "886a8bfa5eca55deffeaf98234a5c2e73d758f4e"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMzkxMw==", "bodyText": "Fixed.", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r427523913", "createdAt": "2020-05-19T18:47:32Z", "author": {"login": "jcastro-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "diffHunk": "@@ -679,64 +681,87 @@ private void deleteTreesForInodes(List<String> inodes) throws DotDataException {\n     }\n \n \t@Override\n-\tprotected int deleteOldContent(Date deleteFrom) throws DotDataException {\n-\t    ContentletCache cc = CacheLocator.getContentletCache();\n-        Calendar calendar = Calendar.getInstance();\n+    protected int deleteOldContent(final Date deleteFrom) throws DotDataException {\n+        final Calendar calendar = Calendar.getInstance();\n         calendar.setTime(deleteFrom);\n         calendar.set(Calendar.HOUR_OF_DAY, 0);\n         calendar.set(Calendar.MINUTE, 0);\n         calendar.set(Calendar.SECOND, 0);\n         calendar.set(Calendar.MILLISECOND, 0);\n-        Date date = calendar.getTime();\n-        //Because of the way Oracle databases handle dates,\n-        //this string is converted to Uppercase.This does\n-        //not cause a problem with the other databases\n-        DotConnect dc = new DotConnect();\n+        final Date date = calendar.getTime();\n \n-        String countSQL = (\"select count(*) as count from contentlet\");\n+        DotConnect dc = new DotConnect();\n+        final String countSQL = \"select count(*) as count from contentlet\";\n         dc.setSQL(countSQL);\n         List<Map<String, String>> result = dc.loadResults();\n-        int before = Integer.parseInt(result.get(0).get(\"count\"));\n-\n-        String deleteContentletSQL = \"delete from contentlet where identifier<>'SYSTEM_HOST' and mod_date < ? \" +\n-        \"and not exists (select * from contentlet_version_info where working_inode=contentlet.inode or live_inode=contentlet.inode)\";\n-        dc.setSQL(deleteContentletSQL);\n-        dc.addParam(date);\n-        dc.loadResult();\n-\n-        String deleteOrphanInodes=\"delete from inode where type='contentlet' and idate < ? and inode not in (select inode from contentlet)\";\n-        dc.setSQL(deleteOrphanInodes);\n+        final int before = Integer.parseInt(result.get(0).get(\"count\"));\n+        dc = new DotConnect();\n+        dc.setSQL(\"SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < ? AND NOT EXISTS \" +\n+                \"(SELECT working_inode, live_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode OR \" +\n+                \"live_inode = contentlet.inode)\");\n         dc.addParam(date);\n-        dc.loadResult();\n-\n+        result = dc.loadResults();\n+        int oldInodesCount = result.size();\n+        if (oldInodesCount > 0) {\n+            final List<String> inodeList = new ArrayList<>();\n+            for (final Map<String, String> row : result) {\n+                inodeList.add(row.get(\"inode\").toString());\n+            }\n+            final int splitAt = 100;\n+            // Split all records into lists of size 'truncateAt'\n+            final List<List<String>> inodesToDelete = Lists.partition(inodeList, splitAt);\n+            final List<String> queries = Lists.newArrayList(\"DELETE FROM contentlet WHERE inode IN (?)\",\n+                    \"DELETE FROM inode WHERE inode IN (?)\");\n+            for (final String query : queries) {\n+                for (final List<String> inodes : inodesToDelete) {\n+                    dc = new DotConnect();\n+                    // Generate the \"(?,?,?...)\" string depending of the number of inodes\n+                    final String parameterPlaceholders = DotConnect.createParametersPlaceholder(inodes.size());\n+                    dc.setSQL(query.replace(\"?\", parameterPlaceholders));\n+                    for (final String inode : inodes) {\n+                        dc.addParam(inode);\n+                    }\n+                    dc.loadResult();\n+                }\n+            }\n+        }\n+        dc = new DotConnect();\n         dc.setSQL(countSQL);\n         result = dc.loadResults();\n-        int after = Integer.parseInt(result.get(0).get(\"count\"));\n-\n-        int deleted=before - after;\n-\n-        // deleting orphan binary files\n-        java.io.File assets=new java.io.File(APILocator.getFileAssetAPI().getRealAssetsRootPath());\n-        for(java.io.File ff1 : assets.listFiles())\n-            if(ff1.isDirectory() && ff1.getName().length()==1 && ff1.getName().matches(\"^[a-f0-9]$\"))\n-                for(java.io.File ff2 : ff1.listFiles())\n-                    if(ff2.isDirectory() && ff2.getName().length()==1 && ff2.getName().matches(\"^[a-f0-9]$\"))\n-                        for(java.io.File ff3 : ff2.listFiles())\n-                            try {\n-                                if(ff3.isDirectory()) {\n-                                    Contentlet con=find(ff3.getName());\n-                                    if(con==null || !UtilMethods.isSet(con.getIdentifier()))\n-                                        if(!FileUtils.deleteQuietly(ff3))\n-                                            Logger.warn(this, \"can't delete \"+ff3.getAbsolutePath());\n+        final int after = Integer.parseInt(result.get(0).get(\"count\"));\n+        final int deleted = before - after;\n+        if (deleted > 0) {\n+            // Deleting orphaned binary files\n+            final java.io.File assets = new java.io.File(APILocator.getFileAssetAPI().getRealAssetsRootPath());\n+            for (final java.io.File firstLevelFolder : assets.listFiles()) {\n+                if (firstLevelFolder.isDirectory() && firstLevelFolder.getName().length() == 1 && firstLevelFolder\n+                        .getName().matches(\"^[a-f0-9]$\")) {\n+                    for (final java.io.File secondLevelFolder : firstLevelFolder.listFiles()) {\n+                        if (secondLevelFolder.isDirectory() && secondLevelFolder.getName().length() == 1 &&\n+                                secondLevelFolder.getName().matches(\"^[a-f0-9]$\")) {\n+                            for (final java.io.File asset : secondLevelFolder.listFiles()) {\n+                                try {\n+                                    if (asset.isDirectory()) {\n+                                        final Contentlet contentlet = find(asset.getName());\n+                                        if (null == contentlet || !UtilMethods.isSet(contentlet.getIdentifier())) {\n+                                            if (!FileUtils.deleteQuietly(asset)) {\n+                                                Logger.warn(this, \"Asset '\" + asset.getAbsolutePath() + \"' could \" +\n+                                                        \"not be deleted.\");\n+                                            }\n+                                        }\n+                                    }\n+                                } catch (final Exception ex) {\n+                                    Logger.warn(this, String.format(\"An error occurred when deleting asset '%s': %s\",\n+                                            asset.getAbsolutePath(), ex.getMessage()));\n                                 }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY3NDg3OA=="}, "originalCommit": {"oid": "886a8bfa5eca55deffeaf98234a5c2e73d758f4e"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjY0MTAzOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo1MToxNFrOGXuIUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo1MToxNFrOGXuIUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyNjIyNw==", "bodyText": "Just by separating this into two queries and using UNION on them you will probably get a high performance gain:\nOriginal query\nEXPLAIN ANALYSE SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < now() AND NOT EXISTS\n(SELECT working_inode, live_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode OR\n                live_inode = contentlet.inode)\n\nProposed query - One query for live, one for working and INTERSECT. That way you don't have an OR.\nEXPLAIN ANALYSE SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < now() AND NOT EXISTS\n    (SELECT working_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode)\nINTERSECT\n        SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < now() AND NOT EXISTS\n    (SELECT live_inode FROM contentlet_version_info WHERE live_inode = contentlet.inode)```", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r427526227", "createdAt": "2020-05-19T18:51:14Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "diffHunk": "@@ -679,64 +681,87 @@ private void deleteTreesForInodes(List<String> inodes) throws DotDataException {\n     }\n \n \t@Override\n-\tprotected int deleteOldContent(Date deleteFrom) throws DotDataException {\n-\t    ContentletCache cc = CacheLocator.getContentletCache();\n-        Calendar calendar = Calendar.getInstance();\n+    protected int deleteOldContent(final Date deleteFrom) throws DotDataException {\n+        final Calendar calendar = Calendar.getInstance();\n         calendar.setTime(deleteFrom);\n         calendar.set(Calendar.HOUR_OF_DAY, 0);\n         calendar.set(Calendar.MINUTE, 0);\n         calendar.set(Calendar.SECOND, 0);\n         calendar.set(Calendar.MILLISECOND, 0);\n-        Date date = calendar.getTime();\n-        //Because of the way Oracle databases handle dates,\n-        //this string is converted to Uppercase.This does\n-        //not cause a problem with the other databases\n-        DotConnect dc = new DotConnect();\n+        final Date date = calendar.getTime();\n \n-        String countSQL = (\"select count(*) as count from contentlet\");\n+        DotConnect dc = new DotConnect();\n+        final String countSQL = \"select count(*) as count from contentlet\";\n         dc.setSQL(countSQL);\n         List<Map<String, String>> result = dc.loadResults();\n-        int before = Integer.parseInt(result.get(0).get(\"count\"));\n-\n-        String deleteContentletSQL = \"delete from contentlet where identifier<>'SYSTEM_HOST' and mod_date < ? \" +\n-        \"and not exists (select * from contentlet_version_info where working_inode=contentlet.inode or live_inode=contentlet.inode)\";\n-        dc.setSQL(deleteContentletSQL);\n-        dc.addParam(date);\n-        dc.loadResult();\n-\n-        String deleteOrphanInodes=\"delete from inode where type='contentlet' and idate < ? and inode not in (select inode from contentlet)\";\n-        dc.setSQL(deleteOrphanInodes);\n+        final int before = Integer.parseInt(result.get(0).get(\"count\"));\n+        dc = new DotConnect();\n+        dc.setSQL(\"SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < ? AND NOT EXISTS \" +\n+                \"(SELECT working_inode, live_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode OR \" +\n+                \"live_inode = contentlet.inode)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "886a8bfa5eca55deffeaf98234a5c2e73d758f4e"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjcwMTQ0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxOTowODoyMlrOGXuucg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxOTowODoyMlrOGXuucg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzNTk4Ng==", "bodyText": "You can use a temp table instead and do a DELETE JOIN instead of having to use an IN.\nBasically insert results of the previous suggested query (INTERSECT) into a temp table, and join against that temp table for doing the two DELETEs", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r427535986", "createdAt": "2020-05-19T19:08:22Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "diffHunk": "@@ -678,65 +680,113 @@ private void deleteTreesForInodes(List<String> inodes) throws DotDataException {\n         }\n     }\n \n-\t@Override\n-\tprotected int deleteOldContent(Date deleteFrom) throws DotDataException {\n-\t    ContentletCache cc = CacheLocator.getContentletCache();\n-        Calendar calendar = Calendar.getInstance();\n+    /**\n+     * Deletes all the Contentlet versions that are older than the specified date.\n+     *\n+     * @param deleteFrom The date as of which all contents older than that will be deleted.\n+     *\n+     * @return The number of records deleted by this operation.\n+     *\n+     * @throws DotDataException An error occurred when interacting with the data source.\n+     */\n+    @Override\n+    protected int deleteOldContent(final Date deleteFrom) throws DotDataException {\n+        final Calendar calendar = Calendar.getInstance();\n         calendar.setTime(deleteFrom);\n         calendar.set(Calendar.HOUR_OF_DAY, 0);\n         calendar.set(Calendar.MINUTE, 0);\n         calendar.set(Calendar.SECOND, 0);\n         calendar.set(Calendar.MILLISECOND, 0);\n-        Date date = calendar.getTime();\n-        //Because of the way Oracle databases handle dates,\n-        //this string is converted to Uppercase.This does\n-        //not cause a problem with the other databases\n+        final Date date = calendar.getTime();\n         DotConnect dc = new DotConnect();\n-\n-        String countSQL = (\"select count(*) as count from contentlet\");\n+        final String countSQL = \"select count(*) as count from contentlet\";\n         dc.setSQL(countSQL);\n         List<Map<String, String>> result = dc.loadResults();\n-        int before = Integer.parseInt(result.get(0).get(\"count\"));\n-\n-        String deleteContentletSQL = \"delete from contentlet where identifier<>'SYSTEM_HOST' and mod_date < ? \" +\n-        \"and not exists (select * from contentlet_version_info where working_inode=contentlet.inode or live_inode=contentlet.inode)\";\n-        dc.setSQL(deleteContentletSQL);\n+        final int before = Integer.parseInt(result.get(0).get(\"count\"));\n+        dc = new DotConnect();\n+        dc.setSQL(\"SELECT inode FROM contentlet WHERE identifier <> 'SYSTEM_HOST' AND mod_date < ? AND NOT EXISTS \" +\n+                \"(SELECT working_inode, live_inode FROM contentlet_version_info WHERE working_inode = contentlet.inode OR \" +\n+                \"live_inode = contentlet.inode)\");\n         dc.addParam(date);\n-        dc.loadResult();\n-\n-        String deleteOrphanInodes=\"delete from inode where type='contentlet' and idate < ? and inode not in (select inode from contentlet)\";\n-        dc.setSQL(deleteOrphanInodes);\n-        dc.addParam(date);\n-        dc.loadResult();\n-\n+        result = dc.loadResults();\n+        int oldInodesCount = result.size();\n+        if (oldInodesCount > 0) {\n+            final List<String> inodeList = result.stream().map(row -> row.get(\"inode\")).collect(Collectors.toList());\n+            deleteContentData(inodeList);\n+        }\n+        dc = new DotConnect();\n         dc.setSQL(countSQL);\n         result = dc.loadResults();\n-        int after = Integer.parseInt(result.get(0).get(\"count\"));\n+        final int after = Integer.parseInt(result.get(0).get(\"count\"));\n+        final int deleted = before - after;\n+        if (deleted > 0) {\n+            deleteOrphanedBinaryFiles();\n+        }\n+        return deleted;\n+    }\n \n-        int deleted=before - after;\n+    /**\n+     * Deletes the content data associated to the specified list of Inodes. Based on such a list, the {@code contentlet}\n+     * will be cleaned up as well.\n+     *\n+     * @param inodeList The list of Inodes that will be deleted.\n+     *\n+     * @throws DotDataException An error occurred when interacting with the data source.\n+     */\n+    private void deleteContentData(final List<String> inodeList) throws DotDataException {\n+        final int splitAt = 100;\n+        // Split all records into lists of size 'truncateAt'\n+        final List<List<String>> inodesToDelete = Lists.partition(inodeList, splitAt);\n+        final List<String> queries = Lists.newArrayList(\"DELETE FROM contentlet WHERE inode IN (?)\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baab02a866740a2b99cc3aecd5cca4e0f233779d"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTczNzMyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotmarketing/portlets/cmsmaintenance/factories/CMSMaintenanceFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNToyMDoxOVrOGfLJSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNToyMDoxOVrOGfLJSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM0MTY0MQ==", "bodyText": "Issue found: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r435341641", "createdAt": "2020-06-04T15:20:19Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/portlets/cmsmaintenance/factories/CMSMaintenanceFactory.java", "diffHunk": "@@ -17,138 +18,176 @@\n import java.util.Map;\r\n \r\n /**\r\n- * This class is use to fix identifiers inconsistencies in db,\r\n- * solving the problem of identifiers without a working or live asset\r\n- * @author Oswaldo\r\n+ * This tool allows CMS users to delete entries of versionable dotCMS objects\r\n+ * that are older than a specified date. These versions can be accessed through\r\n+ * the <b>History</b> tab of such objects. The list of elements that are\r\n+ * versionable in the system are:\r\n+ * <ul>\r\n+ * <li>Contentlets - including HTML Pages as Content, Files as Content, Sites,\r\n+ * etc.</li>\r\n+ * <li>Containers.</li>\r\n+ * <li>Templates.</li>\r\n+ * <li>Links.</li>\r\n+ * <li>Workflow History.</li>\r\n+ * </ul>\r\n  *\r\n+ * @author root\r\n+ * @since Mar 22, 2012\r\n  */\r\n public class CMSMaintenanceFactory {\r\n \r\n-\tpublic static int deleteOldAssetVersions (Date assetsOlderThan) {\r\n-\t\tint counter = 0;\r\n-\t\tint auxCount = 0;\r\n-\r\n+    /**\r\n+     * Deletes dotCMS object versions that are older than the specified date. Such a\r\n+     * date is compared to the date in which a version of an object was created. The\r\n+     * list of objects may include:\r\n+     * <ul>\r\n+     * <li>Contentlets - including HTML Pages as Content, Files as Content, Sites,\r\n+     * etc.</li>\r\n+     * <li>Containers.</li>\r\n+     * <li>Templates.</li>\r\n+     * <li>Links.</li>\r\n+     * <li>Workflow History.</li>\r\n+     * </ul>\r\n+     *\r\n+     * @param assetsOlderThan\r\n+     *            The user-specified date up to which object versions will be\r\n+     *            deleted.\r\n+     * @return The total number of versions that were deleted.\r\n+     */\r\n+    public static int deleteOldAssetVersions(final Date assetsOlderThan) {\r\n+        Logger.info(CMSMaintenanceFactory.class, \"------------------------------------------------------------\");\r\n+        Logger.info(CMSMaintenanceFactory.class, \" Executing the Drop Old Assets Versions tool\");\r\n+        Calendar startDate = Calendar.getInstance();\r\n+        startDate.setTime(assetsOlderThan);\r\n+        startDate.add(Calendar.YEAR, -2);\r\n+        startDate.set(Calendar.HOUR_OF_DAY, 0);\r\n+        startDate.set(Calendar.MINUTE, 0);\r\n+        startDate.set(Calendar.SECOND, 0);\r\n+        startDate.set(Calendar.MILLISECOND, 0);\r\n+        final Calendar oldestInodeDate = getOldestInodeDate();\r\n+        startDate = null != oldestInodeDate ? oldestInodeDate : startDate;\r\n+        Logger.info(CMSMaintenanceFactory.class, String.format(\"- Deleting versions older than '%s'\",\r\n+                UtilMethods.dateToHTMLDate(assetsOlderThan, \"yyyy-MM-dd\")));\r\n+        Logger.info(CMSMaintenanceFactory.class, \" \");\r\n+        int totalRecords = 0;\r\n+        while (startDate.getTime().before(assetsOlderThan) || startDate.getTime().equals(assetsOlderThan)) {\r\n+            try {\r\n+                HibernateUtil.startTransaction();\r\n+                final int deletedRecords = removeOldVersions(startDate);\r\n+                // Run the drop tasks iteratively, moving forward in time\r\n+                // DROP_OLD_ASSET_ITERATE_BY_SECONDS controls how many seconds to move forward\r\n+                // in time for each iteration - default is to iterate by 30 days\r\n+                startDate.add(Calendar.SECOND,\r\n+                        Config.getIntProperty(\"DROP_OLD_ASSET_ITERATE_BY_SECONDS\", 60 * 60 * 24 * 30));\r\n+                // We should never go past the date the user entered\r\n+                if (startDate.getTime().after(assetsOlderThan)) {\r\n+                    break;\r\n+                }\r\n+                totalRecords += deletedRecords;\r\n+                HibernateUtil.commitTransaction();\r\n+            } catch (final Exception ex) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ec8a0a27abd08522669d22b7f6dcac60dd8e707"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTczNzQ2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotmarketing/portlets/cmsmaintenance/factories/CMSMaintenanceFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNToyMDoyMFrOGfLJXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNToyMDoyMFrOGfLJXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM0MTY2MQ==", "bodyText": "Issue found: Avoid variables with short names like dc", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r435341661", "createdAt": "2020-06-04T15:20:20Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/portlets/cmsmaintenance/factories/CMSMaintenanceFactory.java", "diffHunk": "@@ -17,138 +18,176 @@\n import java.util.Map;\r\n \r\n /**\r\n- * This class is use to fix identifiers inconsistencies in db,\r\n- * solving the problem of identifiers without a working or live asset\r\n- * @author Oswaldo\r\n+ * This tool allows CMS users to delete entries of versionable dotCMS objects\r\n+ * that are older than a specified date. These versions can be accessed through\r\n+ * the <b>History</b> tab of such objects. The list of elements that are\r\n+ * versionable in the system are:\r\n+ * <ul>\r\n+ * <li>Contentlets - including HTML Pages as Content, Files as Content, Sites,\r\n+ * etc.</li>\r\n+ * <li>Containers.</li>\r\n+ * <li>Templates.</li>\r\n+ * <li>Links.</li>\r\n+ * <li>Workflow History.</li>\r\n+ * </ul>\r\n  *\r\n+ * @author root\r\n+ * @since Mar 22, 2012\r\n  */\r\n public class CMSMaintenanceFactory {\r\n \r\n-\tpublic static int deleteOldAssetVersions (Date assetsOlderThan) {\r\n-\t\tint counter = 0;\r\n-\t\tint auxCount = 0;\r\n-\r\n+    /**\r\n+     * Deletes dotCMS object versions that are older than the specified date. Such a\r\n+     * date is compared to the date in which a version of an object was created. The\r\n+     * list of objects may include:\r\n+     * <ul>\r\n+     * <li>Contentlets - including HTML Pages as Content, Files as Content, Sites,\r\n+     * etc.</li>\r\n+     * <li>Containers.</li>\r\n+     * <li>Templates.</li>\r\n+     * <li>Links.</li>\r\n+     * <li>Workflow History.</li>\r\n+     * </ul>\r\n+     *\r\n+     * @param assetsOlderThan\r\n+     *            The user-specified date up to which object versions will be\r\n+     *            deleted.\r\n+     * @return The total number of versions that were deleted.\r\n+     */\r\n+    public static int deleteOldAssetVersions(final Date assetsOlderThan) {\r\n+        Logger.info(CMSMaintenanceFactory.class, \"------------------------------------------------------------\");\r\n+        Logger.info(CMSMaintenanceFactory.class, \" Executing the Drop Old Assets Versions tool\");\r\n+        Calendar startDate = Calendar.getInstance();\r\n+        startDate.setTime(assetsOlderThan);\r\n+        startDate.add(Calendar.YEAR, -2);\r\n+        startDate.set(Calendar.HOUR_OF_DAY, 0);\r\n+        startDate.set(Calendar.MINUTE, 0);\r\n+        startDate.set(Calendar.SECOND, 0);\r\n+        startDate.set(Calendar.MILLISECOND, 0);\r\n+        final Calendar oldestInodeDate = getOldestInodeDate();\r\n+        startDate = null != oldestInodeDate ? oldestInodeDate : startDate;\r\n+        Logger.info(CMSMaintenanceFactory.class, String.format(\"- Deleting versions older than '%s'\",\r\n+                UtilMethods.dateToHTMLDate(assetsOlderThan, \"yyyy-MM-dd\")));\r\n+        Logger.info(CMSMaintenanceFactory.class, \" \");\r\n+        int totalRecords = 0;\r\n+        while (startDate.getTime().before(assetsOlderThan) || startDate.getTime().equals(assetsOlderThan)) {\r\n+            try {\r\n+                HibernateUtil.startTransaction();\r\n+                final int deletedRecords = removeOldVersions(startDate);\r\n+                // Run the drop tasks iteratively, moving forward in time\r\n+                // DROP_OLD_ASSET_ITERATE_BY_SECONDS controls how many seconds to move forward\r\n+                // in time for each iteration - default is to iterate by 30 days\r\n+                startDate.add(Calendar.SECOND,\r\n+                        Config.getIntProperty(\"DROP_OLD_ASSET_ITERATE_BY_SECONDS\", 60 * 60 * 24 * 30));\r\n+                // We should never go past the date the user entered\r\n+                if (startDate.getTime().after(assetsOlderThan)) {\r\n+                    break;\r\n+                }\r\n+                totalRecords += deletedRecords;\r\n+                HibernateUtil.commitTransaction();\r\n+            } catch (final Exception ex) {\r\n+                Logger.error(CMSMaintenanceFactory.class,\r\n+                        String.format(\"An error occurred when deleting old asset versions: %s\", ex.getMessage()), ex);\r\n+                try {\r\n+                    HibernateUtil.rollbackTransaction();\r\n+                } catch (final DotHibernateException e) {\r\n+                    Logger.error(CMSMaintenanceFactory.class,\r\n+                            String.format(\"An error occurred when rolling the transaction back: %s\", e.getMessage()),\r\n+                            e);\r\n+                }\r\n+                return -1;\r\n+            }\r\n+        }\r\n+        if (totalRecords > 0) {\r\n+            CacheLocator.getCacheAdministrator().flushAll();\r\n+        }\r\n+        Logger.info(CMSMaintenanceFactory.class, String.format(\r\n+                \" The Drop Old Assets Versions tool has run. A total of %d records were deleted!\", totalRecords));\r\n+        return totalRecords;\r\n+    }\r\n \r\n+    /**\r\n+     * Looks for the oldest last modified date of versionable objects in the system.\r\n+     * Such a date will allow the tool to start deleting from the oldest to the\r\n+     * newest version. If no date is found, the current date will be returned.\r\n+     *\r\n+     * @return The oldest modification date from a versionable object.\r\n+     */\r\n+    private static Calendar getOldestInodeDate() {\r\n+        Calendar startDate = null;\r\n+        final DotConnect dc = new DotConnect();\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ec8a0a27abd08522669d22b7f6dcac60dd8e707"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTczNzU2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotmarketing/portlets/cmsmaintenance/factories/CMSMaintenanceFactoryTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNToyMDoyMVrOGfLJbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNToyMDoyMVrOGfLJbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM0MTY3OA==", "bodyText": "Issue found: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/18507#discussion_r435341678", "createdAt": "2020-06-04T15:20:21Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/portlets/cmsmaintenance/factories/CMSMaintenanceFactoryTest.java", "diffHunk": "@@ -0,0 +1,77 @@\n+package com.dotmarketing.portlets.cmsmaintenance.factories;\n+\n+import com.dotcms.datagen.SiteDataGen;\n+import com.dotcms.datagen.TestDataUtils;\n+import com.dotcms.datagen.TestUserUtils;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.beans.Identifier;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.UUIDGenerator;\n+import com.liferay.portal.model.User;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.List;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+public class CMSMaintenanceFactoryTest {\n+\n+    private static User adminUser;\n+    private static ContentletAPI contentletAPI;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ec8a0a27abd08522669d22b7f6dcac60dd8e707"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2320, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}