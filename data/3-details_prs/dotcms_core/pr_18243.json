{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3MTg0MDkz", "number": 18243, "title": "Issue 17917 query cache", "bodyText": "Take a look.\nThis pull request implements a ESQueryCache that will take a given SearchRequest and return a cached list of hits for the query.\nThe cache key takes into account the SearchRequest.source, e.g. the json es query, and the index(s) which are specified.  It will also not take into account any requests being made from the backend (though this is not true for  jobs and what not).\nAll the different ES searches being done in the ESContentletFactoryImpl roll up to use the new internal cachedIndexSearch(searchRequest) method, including the counts.\nFinally, there was an old/final findContentletByIdentifier that was still trying to use ES to find the id, which has probably caused us some unsolvable issues.  It now uses cache/db like all the non-query methods should.", "createdAt": "2020-04-01T19:19:20Z", "url": "https://github.com/dotCMS/core/pull/18243", "merged": true, "mergeCommit": {"oid": "f84b130e2bad5a163b27f6c5032d0dbdf10e928f"}, "closed": true, "closedAt": "2020-04-13T22:20:25Z", "author": {"login": "wezell"}, "timelineItems": {"totalCount": 62, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcRfaB6gH2gAyMzk3MTg0MDkzOjZhM2Q1MTQ1NzlhZmFhZGM4ZTdmMmRkODJlMTQ3YzAzY2I5MjQ2Y2Y=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcXUVjZgFqTM5MjM4OTIzNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6a3d514579afaadc8e7f2dd82e147c03cb9246cf", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/6a3d514579afaadc8e7f2dd82e147c03cb9246cf", "committedDate": "2020-03-26T17:18:17Z", "message": "#17917 testing query cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d12a6137061b9f22e9b4fcf5a1dcce754ceb6c7b", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/d12a6137061b9f22e9b4fcf5a1dcce754ceb6c7b", "committedDate": "2020-04-01T13:02:38Z", "message": "Merge remote-tracking branch 'origin/master' into issue-17917-query-cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1329ceacf1d793b33c76297bd2364155fb06ebd", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/c1329ceacf1d793b33c76297bd2364155fb06ebd", "committedDate": "2020-04-01T19:09:22Z", "message": "#17917 add es query cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39401909d25b8c7dd64fbff512feb429f8dc4d2e", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/39401909d25b8c7dd64fbff512feb429f8dc4d2e", "committedDate": "2020-04-01T19:16:30Z", "message": "#17917 removed from abstract factory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c383813eb76500a32f5779c29ea22bd3ad1aafe", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/7c383813eb76500a32f5779c29ea22bd3ad1aafe", "committedDate": "2020-04-01T19:31:08Z", "message": "#17917 removed just the string cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa15b258966784446924fe9fc3d7c7b7289d94d2", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/fa15b258966784446924fe9fc3d7c7b7289d94d2", "committedDate": "2020-04-01T19:43:13Z", "message": "#17917 cleanup and less diff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ccee818c4659291005b1ea6555bd52fae9f313e", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/4ccee818c4659291005b1ea6555bd52fae9f313e", "committedDate": "2020-04-01T20:21:24Z", "message": "#17917 calling searchRequest.source invokes a lot of json parsing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MDAyNDkx", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-386002491", "createdAt": "2020-04-01T22:49:45Z", "commit": {"oid": "4ccee818c4659291005b1ea6555bd52fae9f313e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMjo0OTo0NlrOF_VZKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMjo0OTo0NlrOF_VZKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1NTExMw==", "bodyText": "An IT should be implemented for this change in case a test for the old logic didn't exist", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r401955113", "createdAt": "2020-04-01T22:49:46Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "diffHunk": "@@ -960,33 +959,12 @@ protected Contentlet find(final String inode) throws ElasticsearchException, Dot\n \n \t@Override\n \tprotected Contentlet findContentletByIdentifier(String identifier, Boolean live, Long languageId) throws DotDataException {\n-\t\ttry {\n-\t\t\tStringWriter query= new StringWriter();\n-\t\t\tquery.append(\" +identifier:\" + identifier);\n-\t\t\tquery.append(\" +languageid:\" + languageId);\n-\t\t\tquery.append(\" +deleted:false\");\n-\n-            final SearchSourceBuilder searchSourceBuilder = createSearchSourceBuilder(query.toString());\n-\t\t\tIndiciesInfo info=APILocator.getIndiciesAPI().loadIndicies();\n-\n-\t\t\tfinal  SearchRequest searchRequest = new SearchRequest();\n-\t\t\tsearchRequest.source(searchSourceBuilder);\n-\t\t\tsearchRequest.indices((live ? info.getLive() : info.getWorking()));\n-\n-            final SearchResponse response = Sneaky.sneak(()->\n-                    RestHighLevelClientProvider.getInstance().getClient().search(searchRequest, RequestOptions.DEFAULT));\n-            SearchHits hits = response.getHits();\n-\n-\t\t\treturn find(hits.getAt(0).getSourceAsMap().get(\"inode\").toString());\n-\t\t}\n-\t\t// if we don't have the con in this language\n-\t\tcatch(ArrayIndexOutOfBoundsException aibex){\n-\t\t\treturn null;\n-\t\t}\n-\t\tcatch (Exception e) {\n-\t\t\tthrow new ElasticsearchException(e.getMessage(), e);\n-\n-\t\t}\n+        final ContentletVersionInfo cvi = APILocator.getVersionableAPI().getContentletVersionInfo(identifier, languageId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ccee818c4659291005b1ea6555bd52fae9f313e"}, "originalPosition": 163}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68614ab1ad423bce26b570fc351728ee3470e4af", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/68614ab1ad423bce26b570fc351728ee3470e4af", "committedDate": "2020-04-02T00:30:17Z", "message": "#17917 invalidate cache for tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e4ebfe3a2735c52fee4ddd87d62ba81a352eccb", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/4e4ebfe3a2735c52fee4ddd87d62ba81a352eccb", "committedDate": "2020-04-02T00:47:16Z", "message": "#17917 fixing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "746ff8814294ce4a95bd0814ca002066d91b7903", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/746ff8814294ce4a95bd0814ca002066d91b7903", "committedDate": "2020-04-02T00:51:09Z", "message": "Merge remote-tracking branch 'origin/master' into issue-17917-query-cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2MTAzNzI3", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-386103727", "createdAt": "2020-04-02T04:43:13Z", "commit": {"oid": "4e4ebfe3a2735c52fee4ddd87d62ba81a352eccb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NDgzODI1", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-386483825", "createdAt": "2020-04-02T14:29:48Z", "commit": {"oid": "4e4ebfe3a2735c52fee4ddd87d62ba81a352eccb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2NDg2NjI3", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-386486627", "createdAt": "2020-04-02T14:32:34Z", "commit": {"oid": "4e4ebfe3a2735c52fee4ddd87d62ba81a352eccb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDozMjozNFrOF_uIAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNDo1MzozNFrOF_vJ9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM2MDMyMA==", "bodyText": "doc?", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r402360320", "createdAt": "2020-04-02T14:32:34Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/ESQueryCache.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import java.util.Arrays;\n+import java.util.Optional;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.search.SearchHits;\n+import com.dotcms.enterprise.license.LicenseManager;\n+import com.dotmarketing.business.Cachable;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.PageMode;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.hash.Hashing;\n+\n+public class ESQueryCache implements Cachable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e4ebfe3a2735c52fee4ddd87d62ba81a352eccb"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM2NzY2NA==", "bodyText": "I think is not need to do this test, it is test with the others test", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r402367664", "createdAt": "2020-04-02T14:41:52Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin, true);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e4ebfe3a2735c52fee4ddd87d62ba81a352eccb"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3MDM5Mg==", "bodyText": "where are these be using?", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r402370392", "createdAt": "2020-04-02T14:45:10Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/resources/dotmarketing-config.properties", "diffHunk": "@@ -500,12 +502,23 @@ cache.contentletcache.chain =com.dotmarketing.business.cache.provider.caffine.Ca\n ## the velocity macros to disk, otherwise, they might not reload on restarts. \n cache.velocitycache.chain   =com.dotmarketing.business.cache.provider.caffine.CaffineCache,com.dotmarketing.business.cache.provider.h22.H22Cache\n cache.velocitymacrocache.chain   =com.dotmarketing.business.cache.provider.caffine.CaffineCache,com.dotmarketing.business.cache.provider.h22.H22Cache\n+\n+## Cache API Token lookups for a hour (invalidations still apply)\n cache.apitokencache.chain=com.dotmarketing.business.cache.provider.timedcache.TimedCacheProvider\n+cache.apitokencache.seconds=3600\n+\n+## Cache Elasticsearch Queries for 10 seconds - only applies to live queries\n+cache.esquerycache.chain=com.dotmarketing.business.cache.provider.timedcache.TimedCacheProvider\n+cache.esquerycache.seconds=10\n+cache.esquerycache.size=10000", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e4ebfe3a2735c52fee4ddd87d62ba81a352eccb"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3MjQwOA==", "bodyText": "maybe we can do a test where sleep the main thread for:\nhttps://github.com/dotCMS/core/pull/18243/files#diff-9eef290d7e7caa46fa38e7f59dfe65cdR512\nand test that the value was clean", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r402372408", "createdAt": "2020-04-02T14:47:36Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin, true);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();\n+        assertTrue(!cache.get(request2).isPresent());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_get_hits_by_request() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        assert(cache.get(req1).isPresent());\n+        \n+        assert(cache.get(req2).isPresent());\n+        \n+        assertEquals(cache.get(req1).get(), cache.get(req2).get());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_clear_cache() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        \n+        assert(cache.get(req1).isPresent());\n+        assert(cache.get(req2).isPresent());\n+        \n+        cache.clearCache();\n+        \n+        assert(!cache.get(req1).isPresent());\n+        assert(!cache.get(req2).isPresent());\n+\n+\n+    }\n+    \n+    \n+    \n+    \n+    SearchHits hits() {\n+        Random rand = new Random(); \n+        List<SearchHit> hitList = new ArrayList<>();\n+        for(int i=0;i< rand.nextInt(10);i++) {\n+            Text text = new Text(RandomStringUtils.randomAscii(36));\n+            SearchHit hit = new SearchHit(i,RandomStringUtils.randomAscii(36),text,new HashMap<>());\n+            hitList.add(hit);\n+        }\n+        \n+        return new SearchHits(hitList.toArray(new SearchHit[0]), new TotalHits(2, Relation.EQUAL_TO), .7f);\n+        \n+        \n+    }\n+    \n+    \n+    \n+    private SearchRequest getSearchRequest() {\n+\n+        return getSearchRquest(RandomStringUtils.randomAscii(200), true) ;\n+        \n+    }\n+    \n+    @NotNull\n+    private SearchRequest getSearchRquest(String query, boolean live) {\n+        SearchRequest searchRequest = new SearchRequest();\n+        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n+        searchSourceBuilder.query(QueryBuilders.queryStringQuery(query));\n+        searchSourceBuilder.size(0);\n+        searchSourceBuilder.timeout(TimeValue.timeValueMillis(INDEX_OPERATIONS_TIMEOUT_IN_MS));\n+        searchRequest.source(searchSourceBuilder);\n+        searchRequest.indices((live ? \"live\" : \"working\"));\n+        return searchRequest;\n+    }\n+\n+    static DotCacheAdministrator admin = new DotCacheAdministrator() {\n+\n+        private Map<String, SearchHits> hitMap = new HashMap<>();\n+\n+        @Override\n+        public void shutdown() {\n+\n+\n+        }\n+\n+        @Override\n+        public void setTransport(CacheTransport transport) {\n+\n+\n+        }\n+\n+        @Override\n+        public void removeLocalOnly(String key, String group, boolean ignoreDistributed) {\n+            hitMap.remove(key + group);\n+\n+        }\n+\n+        @Override\n+        public void remove(String key, String group) {\n+            hitMap.remove(key + group);\n+\n+        }\n+\n+        @Override\n+        public void put(String key, Object content, String group) {\n+            hitMap.put(key + group, (SearchHits) content);\n+\n+        }\n+\n+        @Override\n+        public void invalidateCacheMesageFromCluster(String message) {\n+\n+\n+        }\n+\n+        @Override\n+        public void initProviders() {\n+\n+\n+        }\n+\n+        @Override\n+        public CacheTransport getTransport() {\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public DotCacheAdministrator getImplementationObject() {\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public Class getImplementationClass() {\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public Set<String> getGroups() {\n+\n+            return ImmutableSet.of(cache.getPrimaryGroup());\n+        }\n+\n+        @Override\n+        public List<CacheProviderStats> getCacheStatsList() {\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public Object get(String key, String group) throws DotCacheException {\n+\n+            return hitMap.get(key + group);\n+        }\n+\n+        @Override\n+        public void flushGroupLocalOnly(String group, boolean ignoreDistributed) {\n+            hitMap.clear();\n+\n+        }\n+\n+        @Override\n+        public void flushGroup(String group) {\n+\n+            hitMap.clear();\n+        }\n+\n+        @Override\n+        public void flushAll() {\n+            hitMap.clear();\n+\n+        }\n+\n+        @Override\n+        public void flushAlLocalOnly(boolean ignoreDistributed) {\n+            hitMap.clear();\n+\n+        }\n+    };\n+\n+\n+\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e4ebfe3a2735c52fee4ddd87d62ba81a352eccb"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3MjczOQ==", "bodyText": "maybe we can do a test to this: https://github.com/dotCMS/core/pull/18243/files#diff-9eef290d7e7caa46fa38e7f59dfe65cdR512", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r402372739", "createdAt": "2020-04-02T14:48:00Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin, true);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();\n+        assertTrue(!cache.get(request2).isPresent());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_get_hits_by_request() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        assert(cache.get(req1).isPresent());\n+        \n+        assert(cache.get(req2).isPresent());\n+        \n+        assertEquals(cache.get(req1).get(), cache.get(req2).get());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_clear_cache() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        \n+        assert(cache.get(req1).isPresent());\n+        assert(cache.get(req2).isPresent());\n+        \n+        cache.clearCache();\n+        \n+        assert(!cache.get(req1).isPresent());\n+        assert(!cache.get(req2).isPresent());\n+\n+\n+    }\n+    \n+    \n+    \n+    \n+    SearchHits hits() {\n+        Random rand = new Random(); \n+        List<SearchHit> hitList = new ArrayList<>();\n+        for(int i=0;i< rand.nextInt(10);i++) {\n+            Text text = new Text(RandomStringUtils.randomAscii(36));\n+            SearchHit hit = new SearchHit(i,RandomStringUtils.randomAscii(36),text,new HashMap<>());\n+            hitList.add(hit);\n+        }\n+        \n+        return new SearchHits(hitList.toArray(new SearchHit[0]), new TotalHits(2, Relation.EQUAL_TO), .7f);\n+        \n+        \n+    }\n+    \n+    \n+    \n+    private SearchRequest getSearchRequest() {\n+\n+        return getSearchRquest(RandomStringUtils.randomAscii(200), true) ;\n+        \n+    }\n+    \n+    @NotNull\n+    private SearchRequest getSearchRquest(String query, boolean live) {\n+        SearchRequest searchRequest = new SearchRequest();\n+        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n+        searchSourceBuilder.query(QueryBuilders.queryStringQuery(query));\n+        searchSourceBuilder.size(0);\n+        searchSourceBuilder.timeout(TimeValue.timeValueMillis(INDEX_OPERATIONS_TIMEOUT_IN_MS));\n+        searchRequest.source(searchSourceBuilder);\n+        searchRequest.indices((live ? \"live\" : \"working\"));\n+        return searchRequest;\n+    }\n+\n+    static DotCacheAdministrator admin = new DotCacheAdministrator() {\n+\n+        private Map<String, SearchHits> hitMap = new HashMap<>();\n+\n+        @Override\n+        public void shutdown() {\n+\n+\n+        }\n+\n+        @Override\n+        public void setTransport(CacheTransport transport) {\n+\n+\n+        }\n+\n+        @Override\n+        public void removeLocalOnly(String key, String group, boolean ignoreDistributed) {\n+            hitMap.remove(key + group);\n+\n+        }\n+\n+        @Override\n+        public void remove(String key, String group) {\n+            hitMap.remove(key + group);\n+\n+        }\n+\n+        @Override\n+        public void put(String key, Object content, String group) {\n+            hitMap.put(key + group, (SearchHits) content);\n+\n+        }\n+\n+        @Override\n+        public void invalidateCacheMesageFromCluster(String message) {\n+\n+\n+        }\n+\n+        @Override\n+        public void initProviders() {\n+\n+\n+        }\n+\n+        @Override\n+        public CacheTransport getTransport() {\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public DotCacheAdministrator getImplementationObject() {\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public Class getImplementationClass() {\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public Set<String> getGroups() {\n+\n+            return ImmutableSet.of(cache.getPrimaryGroup());\n+        }\n+\n+        @Override\n+        public List<CacheProviderStats> getCacheStatsList() {\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public Object get(String key, String group) throws DotCacheException {\n+\n+            return hitMap.get(key + group);\n+        }\n+\n+        @Override\n+        public void flushGroupLocalOnly(String group, boolean ignoreDistributed) {\n+            hitMap.clear();\n+\n+        }\n+\n+        @Override\n+        public void flushGroup(String group) {\n+\n+            hitMap.clear();\n+        }\n+\n+        @Override\n+        public void flushAll() {\n+            hitMap.clear();\n+\n+        }\n+\n+        @Override\n+        public void flushAlLocalOnly(boolean ignoreDistributed) {\n+            hitMap.clear();\n+\n+        }\n+    };\n+\n+\n+\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e4ebfe3a2735c52fee4ddd87d62ba81a352eccb"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3NzIwNQ==", "bodyText": "I think we don't have test to prove the cache is used here, maybe we can do a unit test mocking the RestHighLevelClientProvider  instance and verify that the search method is not call", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r402377205", "createdAt": "2020-04-02T14:53:34Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImpl.java", "diffHunk": "@@ -1520,23 +1495,62 @@ private SearchSourceBuilder createSearchSourceBuilder(final String query, final\n         return searchSourceBuilder;\n     }\n \n-\t@Override\n-\tprotected SearchHits indexSearch(final String query, final int limit, final int offset, String sortBy) {\n+    \n+\n+\n+    \n+\n+    SearchHits cachedIndexSearch(final SearchRequest searchRequest) {\n+        \n \n-\t    final String formattedQuery = LuceneQueryDateTimeFormatter\n+        final Optional<SearchHits> optionalHits = queryCache.get(searchRequest);\n+        if(optionalHits.isPresent()) {\n+            return optionalHits.get();\n+        }\n+        try {\n+            SearchResponse response = RestHighLevelClientProvider.getInstance().getClient().search(searchRequest, RequestOptions.DEFAULT);\n+            SearchHits hits  = response.getHits();\n+            queryCache.put(searchRequest, hits);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e4ebfe3a2735c52fee4ddd87d62ba81a352eccb"}, "originalPosition": 231}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a1eba614724497395cfda413126b19fb3a169cb", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/3a1eba614724497395cfda413126b19fb3a169cb", "committedDate": "2020-04-02T15:56:09Z", "message": "#17917 invalidating on reindex"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "586311174ec3dc5e94d4e8bbf0502a0c78766fed", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/586311174ec3dc5e94d4e8bbf0502a0c78766fed", "committedDate": "2020-04-02T15:58:44Z", "message": "#17917 removing unneeded code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab5b39b40c3020c2fe1d6a59df26d2ebb07b2ab0", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/ab5b39b40c3020c2fe1d6a59df26d2ebb07b2ab0", "committedDate": "2020-04-02T15:59:50Z", "message": "17917 prevent unneded puts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "342668f12b9fe35ce0558e0b091ab409aeea8989", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/342668f12b9fe35ce0558e0b091ab409aeea8989", "committedDate": "2020-04-02T16:04:10Z", "message": "#17917 cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "732114168ce255d471c2a65e9f9de769aa853a91", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/732114168ce255d471c2a65e9f9de769aa853a91", "committedDate": "2020-04-02T16:05:45Z", "message": "#17917 cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90dbaf58940338c1ec13ffaa8820725e3c452608", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/90dbaf58940338c1ec13ffaa8820725e3c452608", "committedDate": "2020-04-02T16:18:30Z", "message": "#17917 clear index on delete"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "493b65312a53bd3aa42a0925800c51452963a689", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/493b65312a53bd3aa42a0925800c51452963a689", "committedDate": "2020-04-02T19:14:07Z", "message": "#17917 flush on a reindex switchover"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a77ea62a20230fe3d19962e7cf947ce6d342bd5", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/0a77ea62a20230fe3d19962e7cf947ce6d342bd5", "committedDate": "2020-04-03T15:03:30Z", "message": "#17917 making sure isInodeInIndex works"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c69dd13fb53345cca5c0180468b932ac02f9bf7a", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/c69dd13fb53345cca5c0180468b932ac02f9bf7a", "committedDate": "2020-04-03T16:28:15Z", "message": "#17917 added some javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "264f841157fe4a8d54e9862d92ebc7dd8312da53", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/264f841157fe4a8d54e9862d92ebc7dd8312da53", "committedDate": "2020-04-03T17:09:11Z", "message": "#17917 adding it test for findByIdentifier"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd534d8a9a05f68f8b310c2cf6594b4e7e3a8a01", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/bd534d8a9a05f68f8b310c2cf6594b4e7e3a8a01", "committedDate": "2020-04-03T17:37:42Z", "message": "#17917 test cached search hits"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f592844181128898bd4460df255a09b0c3ad6107", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/f592844181128898bd4460df255a09b0c3ad6107", "committedDate": "2020-04-03T17:44:39Z", "message": "#17917 test cached search hits"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "940fc285b9a06d34b5691bfa776a21e02ae72617", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/940fc285b9a06d34b5691bfa776a21e02ae72617", "committedDate": "2020-04-03T17:53:43Z", "message": "#17917 more javadocs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NTg3NTgw", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-389587580", "createdAt": "2020-04-08T00:59:31Z", "commit": {"oid": "940fc285b9a06d34b5691bfa776a21e02ae72617"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMDo1OTozMlrOGCbYmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMDo1OTozMlrOGCbYmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTE5OTAwMg==", "bodyText": "@wezell is the uuid stuff required yet?", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r405199002", "createdAt": "2020-04-08T00:59:32Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ContentletIndexAPIImplTest.java", "diffHunk": "@@ -506,10 +506,10 @@ public void addRemoveContentToIndex () throws Exception {\n             indexAPI.removeContentFromIndex( testContentlet );\n \n             //We are just making time in order to let it apply the index\n-            wasContentRemoved( query );\n+            wasContentRemoved( query + \" \" + UUIDGenerator.generateUuid() );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "940fc285b9a06d34b5691bfa776a21e02ae72617"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NTkwMjY4", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-389590268", "createdAt": "2020-04-08T01:09:01Z", "commit": {"oid": "940fc285b9a06d34b5691bfa776a21e02ae72617"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTowOTowMVrOGCbh_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwMTowOTowMVrOGCbh_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTIwMTQwNg==", "bodyText": "why do you need to clear cache here?", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r405201406", "createdAt": "2020-04-08T01:09:01Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/integration-test/java/com/dotcms/util/ImportUtilTest.java", "diffHunk": "@@ -1442,7 +1443,7 @@ public void importFile_updateRelatedContentWithEmptyColumn_shouldWipeOutRelatedC\n                     TITLE_FIELD_NAME + \", \" + BODY_FIELD_NAME + \", \" + field.variable()\n                             + \"\\r\\n\" +\n                             \"parent contentlet, parent contentlet body, \");\n-\n+            CacheLocator.getESQueryCache().clearCache();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "940fc285b9a06d34b5691bfa776a21e02ae72617"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54684379d2a7f1df1cec0ffd595aad412701e595", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/54684379d2a7f1df1cec0ffd595aad412701e595", "committedDate": "2020-04-09T15:20:12Z", "message": "#17917 fixing test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bc57868fe35bf9986a7bb2ced64d3f78b18d9c2", "author": {"user": {"login": "wezell", "name": "Will Ezell"}}, "url": "https://github.com/dotCMS/core/commit/3bc57868fe35bf9986a7bb2ced64d3f78b18d9c2", "committedDate": "2020-04-09T16:25:46Z", "message": "#17917 removing unneeded changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54a73c1624ae0036faeb1ea2985ef159276986ee", "author": {"user": {"login": "dsilvam", "name": "Daniel Silva"}}, "url": "https://github.com/dotCMS/core/commit/54a73c1624ae0036faeb1ea2985ef159276986ee", "committedDate": "2020-04-09T21:13:36Z", "message": "#17917 merge with master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7c3e21a973ad8188289feb4e77a4bf70852e3ae", "author": {"user": {"login": "dsilvam", "name": "Daniel Silva"}}, "url": "https://github.com/dotCMS/core/commit/e7c3e21a973ad8188289feb4e77a4bf70852e3ae", "committedDate": "2020-04-09T21:13:55Z", "message": "Merge branch 'issue-17917-query-cache' of github.com:dotCMS/core into issue-17917-query-cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdba266e69d73710ae7ba1f59b52d70e8111bcce", "author": {"user": {"login": "dsilvam", "name": "Daniel Silva"}}, "url": "https://github.com/dotCMS/core/commit/fdba266e69d73710ae7ba1f59b52d70e8111bcce", "committedDate": "2020-04-09T21:15:57Z", "message": "#17917 merge with master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTcyMjAx", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391172201", "createdAt": "2020-04-09T22:26:32Z", "commit": {"oid": "fdba266e69d73710ae7ba1f59b52d70e8111bcce"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6", "author": {"user": {"login": "dsilvam", "name": "Daniel Silva"}}, "url": "https://github.com/dotCMS/core/commit/3438952c02eb9a535aadb19d85393d75caed31a6", "committedDate": "2020-04-09T23:03:05Z", "message": "#17917 additional asserts for tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3MzI2", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187326", "createdAt": "2020-04-09T23:09:50Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1MVrOGDsUpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1MVrOGDsUpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTA5Mw==", "bodyText": "Issue found: Local variable 'request2' could be declared final", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525093", "createdAt": "2020-04-09T23:09:51Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3MzM0", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187334", "createdAt": "2020-04-09T23:09:52Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1MlrOGDsUrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1MlrOGDsUrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTEwMA==", "bodyText": "Issue found: The String literal \"myBody\" appears 4 times in this file; the first occurrence is on line 500", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525100", "createdAt": "2020-04-09T23:09:52Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImplTest.java", "diffHunk": "@@ -537,4 +542,163 @@ private void runLuceneQueryAndValidateResults(final String query, final Contentl\n         assertEquals(contentlet.getInode(), hits[0].getSourceAsMap().get(\"inode\"));\n     }\n \n+    @Test\n+    public void test_findContentletByIdentifier() throws Exception {\n+    \n+        final Language language1 = new LanguageDataGen().nextPersisted();\n+        final Language language2 = new LanguageDataGen().nextPersisted();\n+        final ContentType blogType = TestDataUtils.getBlogLikeContentType(site);\n+        \n+\n+        // create URL-Mapped content\n+        final Contentlet workingOneLanguage = new ContentletDataGen(blogType.id())\n+                .languageId(language1.getId())\n+                .setProperty(\"body\", \"myBody\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3MzQx", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187341", "createdAt": "2020-04-09T23:09:53Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1M1rOGDsUsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1M1rOGDsUsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTEwNw==", "bodyText": "Issue found: Local variable 'req2' could be declared final", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525107", "createdAt": "2020-04-09T23:09:53Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();\n+        assertTrue(!cache.get(request2).isPresent());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_get_hits_by_request() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        assert(cache.get(req1).isPresent());\n+        \n+        assert(cache.get(req2).isPresent());\n+        \n+        assertEquals(cache.get(req1).get(), cache.get(req2).get());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_clear_cache() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 110}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3MzUw", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187350", "createdAt": "2020-04-09T23:09:54Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1NFrOGDsUuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1NFrOGDsUuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTExNQ==", "bodyText": "Issue found: Parameter 'message' is not assigned and could be declared final", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525115", "createdAt": "2020-04-09T23:09:54Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();\n+        assertTrue(!cache.get(request2).isPresent());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_get_hits_by_request() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        assert(cache.get(req1).isPresent());\n+        \n+        assert(cache.get(req2).isPresent());\n+        \n+        assertEquals(cache.get(req1).get(), cache.get(req2).get());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_clear_cache() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        \n+        assert(cache.get(req1).isPresent());\n+        assert(cache.get(req2).isPresent());\n+        \n+        cache.clearCache();\n+        \n+        assert(!cache.get(req1).isPresent());\n+        assert(!cache.get(req2).isPresent());\n+\n+\n+    }\n+    \n+    \n+    \n+    \n+    SearchHits hits() {\n+        Random rand = new Random(); \n+        List<SearchHit> hitList = new ArrayList<>();\n+        for(int i=0;i< rand.nextInt(10);i++) {\n+            Text text = new Text(RandomStringUtils.randomAscii(36));\n+            SearchHit hit = new SearchHit(i,RandomStringUtils.randomAscii(36),text,new HashMap<>());\n+            hitList.add(hit);\n+        }\n+        \n+        return new SearchHits(hitList.toArray(new SearchHit[0]), new TotalHits(2, Relation.EQUAL_TO), .7f);\n+        \n+        \n+    }\n+    \n+    \n+    \n+    private SearchRequest getSearchRequest() {\n+\n+        return getSearchRquest(RandomStringUtils.randomAscii(200), true) ;\n+        \n+    }\n+    \n+    @NotNull\n+    private SearchRequest getSearchRquest(String query, boolean live) {\n+        SearchRequest searchRequest = new SearchRequest();\n+        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n+        searchSourceBuilder.query(QueryBuilders.queryStringQuery(query));\n+        searchSourceBuilder.size(0);\n+        searchSourceBuilder.timeout(TimeValue.timeValueMillis(INDEX_OPERATIONS_TIMEOUT_IN_MS));\n+        searchRequest.source(searchSourceBuilder);\n+        searchRequest.indices((live ? \"live\" : \"working\"));\n+        return searchRequest;\n+    }\n+\n+    static DotCacheAdministrator admin = new DotCacheAdministrator() {\n+\n+        private Map<String, SearchHits> hitMap = new HashMap<>();\n+\n+        @Override\n+        public void shutdown() {\n+\n+\n+        }\n+\n+        @Override\n+        public void setTransport(CacheTransport transport) {\n+\n+\n+        }\n+\n+        @Override\n+        public void removeLocalOnly(String key, String group, boolean ignoreDistributed) {\n+            hitMap.remove(key + group);\n+\n+        }\n+\n+        @Override\n+        public void remove(String key, String group) {\n+            hitMap.remove(key + group);\n+\n+        }\n+\n+        @Override\n+        public void put(String key, Object content, String group) {\n+            hitMap.put(key + group, (SearchHits) content);\n+\n+        }\n+\n+        @Override\n+        public void invalidateCacheMesageFromCluster(String message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 198}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3MzU1", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187355", "createdAt": "2020-04-09T23:09:55Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1NVrOGDsUwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1NVrOGDsUwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTEyMQ==", "bodyText": "Issue found: Parameter 'transport' is not assigned and could be declared final", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525121", "createdAt": "2020-04-09T23:09:55Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();\n+        assertTrue(!cache.get(request2).isPresent());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_get_hits_by_request() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        assert(cache.get(req1).isPresent());\n+        \n+        assert(cache.get(req2).isPresent());\n+        \n+        assertEquals(cache.get(req1).get(), cache.get(req2).get());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_clear_cache() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        \n+        assert(cache.get(req1).isPresent());\n+        assert(cache.get(req2).isPresent());\n+        \n+        cache.clearCache();\n+        \n+        assert(!cache.get(req1).isPresent());\n+        assert(!cache.get(req2).isPresent());\n+\n+\n+    }\n+    \n+    \n+    \n+    \n+    SearchHits hits() {\n+        Random rand = new Random(); \n+        List<SearchHit> hitList = new ArrayList<>();\n+        for(int i=0;i< rand.nextInt(10);i++) {\n+            Text text = new Text(RandomStringUtils.randomAscii(36));\n+            SearchHit hit = new SearchHit(i,RandomStringUtils.randomAscii(36),text,new HashMap<>());\n+            hitList.add(hit);\n+        }\n+        \n+        return new SearchHits(hitList.toArray(new SearchHit[0]), new TotalHits(2, Relation.EQUAL_TO), .7f);\n+        \n+        \n+    }\n+    \n+    \n+    \n+    private SearchRequest getSearchRequest() {\n+\n+        return getSearchRquest(RandomStringUtils.randomAscii(200), true) ;\n+        \n+    }\n+    \n+    @NotNull\n+    private SearchRequest getSearchRquest(String query, boolean live) {\n+        SearchRequest searchRequest = new SearchRequest();\n+        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n+        searchSourceBuilder.query(QueryBuilders.queryStringQuery(query));\n+        searchSourceBuilder.size(0);\n+        searchSourceBuilder.timeout(TimeValue.timeValueMillis(INDEX_OPERATIONS_TIMEOUT_IN_MS));\n+        searchRequest.source(searchSourceBuilder);\n+        searchRequest.indices((live ? \"live\" : \"working\"));\n+        return searchRequest;\n+    }\n+\n+    static DotCacheAdministrator admin = new DotCacheAdministrator() {\n+\n+        private Map<String, SearchHits> hitMap = new HashMap<>();\n+\n+        @Override\n+        public void shutdown() {\n+\n+\n+        }\n+\n+        @Override\n+        public void setTransport(CacheTransport transport) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 174}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3Mzcw", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187370", "createdAt": "2020-04-09T23:09:56Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1NlrOGDsUxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1NlrOGDsUxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTEyNw==", "bodyText": "Issue found: Local variable 'searchRequest' could be declared final", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525127", "createdAt": "2020-04-09T23:09:56Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();\n+        assertTrue(!cache.get(request2).isPresent());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_get_hits_by_request() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        assert(cache.get(req1).isPresent());\n+        \n+        assert(cache.get(req2).isPresent());\n+        \n+        assertEquals(cache.get(req1).get(), cache.get(req2).get());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_clear_cache() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        \n+        assert(cache.get(req1).isPresent());\n+        assert(cache.get(req2).isPresent());\n+        \n+        cache.clearCache();\n+        \n+        assert(!cache.get(req1).isPresent());\n+        assert(!cache.get(req2).isPresent());\n+\n+\n+    }\n+    \n+    \n+    \n+    \n+    SearchHits hits() {\n+        Random rand = new Random(); \n+        List<SearchHit> hitList = new ArrayList<>();\n+        for(int i=0;i< rand.nextInt(10);i++) {\n+            Text text = new Text(RandomStringUtils.randomAscii(36));\n+            SearchHit hit = new SearchHit(i,RandomStringUtils.randomAscii(36),text,new HashMap<>());\n+            hitList.add(hit);\n+        }\n+        \n+        return new SearchHits(hitList.toArray(new SearchHit[0]), new TotalHits(2, Relation.EQUAL_TO), .7f);\n+        \n+        \n+    }\n+    \n+    \n+    \n+    private SearchRequest getSearchRequest() {\n+\n+        return getSearchRquest(RandomStringUtils.randomAscii(200), true) ;\n+        \n+    }\n+    \n+    @NotNull\n+    private SearchRequest getSearchRquest(String query, boolean live) {\n+        SearchRequest searchRequest = new SearchRequest();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 153}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3Mzc3", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187377", "createdAt": "2020-04-09T23:09:57Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1N1rOGDsUzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1N1rOGDsUzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTEzMw==", "bodyText": "Issue found: Local variable 'rand' could be declared final", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525133", "createdAt": "2020-04-09T23:09:57Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();\n+        assertTrue(!cache.get(request2).isPresent());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_get_hits_by_request() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        assert(cache.get(req1).isPresent());\n+        \n+        assert(cache.get(req2).isPresent());\n+        \n+        assertEquals(cache.get(req1).get(), cache.get(req2).get());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_clear_cache() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        \n+        assert(cache.get(req1).isPresent());\n+        assert(cache.get(req2).isPresent());\n+        \n+        cache.clearCache();\n+        \n+        assert(!cache.get(req1).isPresent());\n+        assert(!cache.get(req2).isPresent());\n+\n+\n+    }\n+    \n+    \n+    \n+    \n+    SearchHits hits() {\n+        Random rand = new Random(); ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 130}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3Mzg2", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187386", "createdAt": "2020-04-09T23:09:58Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1OFrOGDsU0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1OFrOGDsU0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTEzOQ==", "bodyText": "Issue found: Parameter 'ignoreDistributed' is not assigned and could be declared final", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525139", "createdAt": "2020-04-09T23:09:58Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();\n+        assertTrue(!cache.get(request2).isPresent());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_get_hits_by_request() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        assert(cache.get(req1).isPresent());\n+        \n+        assert(cache.get(req2).isPresent());\n+        \n+        assertEquals(cache.get(req1).get(), cache.get(req2).get());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_clear_cache() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        \n+        assert(cache.get(req1).isPresent());\n+        assert(cache.get(req2).isPresent());\n+        \n+        cache.clearCache();\n+        \n+        assert(!cache.get(req1).isPresent());\n+        assert(!cache.get(req2).isPresent());\n+\n+\n+    }\n+    \n+    \n+    \n+    \n+    SearchHits hits() {\n+        Random rand = new Random(); \n+        List<SearchHit> hitList = new ArrayList<>();\n+        for(int i=0;i< rand.nextInt(10);i++) {\n+            Text text = new Text(RandomStringUtils.randomAscii(36));\n+            SearchHit hit = new SearchHit(i,RandomStringUtils.randomAscii(36),text,new HashMap<>());\n+            hitList.add(hit);\n+        }\n+        \n+        return new SearchHits(hitList.toArray(new SearchHit[0]), new TotalHits(2, Relation.EQUAL_TO), .7f);\n+        \n+        \n+    }\n+    \n+    \n+    \n+    private SearchRequest getSearchRequest() {\n+\n+        return getSearchRquest(RandomStringUtils.randomAscii(200), true) ;\n+        \n+    }\n+    \n+    @NotNull\n+    private SearchRequest getSearchRquest(String query, boolean live) {\n+        SearchRequest searchRequest = new SearchRequest();\n+        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n+        searchSourceBuilder.query(QueryBuilders.queryStringQuery(query));\n+        searchSourceBuilder.size(0);\n+        searchSourceBuilder.timeout(TimeValue.timeValueMillis(INDEX_OPERATIONS_TIMEOUT_IN_MS));\n+        searchRequest.source(searchSourceBuilder);\n+        searchRequest.indices((live ? \"live\" : \"working\"));\n+        return searchRequest;\n+    }\n+\n+    static DotCacheAdministrator admin = new DotCacheAdministrator() {\n+\n+        private Map<String, SearchHits> hitMap = new HashMap<>();\n+\n+        @Override\n+        public void shutdown() {\n+\n+\n+        }\n+\n+        @Override\n+        public void setTransport(CacheTransport transport) {\n+\n+\n+        }\n+\n+        @Override\n+        public void removeLocalOnly(String key, String group, boolean ignoreDistributed) {\n+            hitMap.remove(key + group);\n+\n+        }\n+\n+        @Override\n+        public void remove(String key, String group) {\n+            hitMap.remove(key + group);\n+\n+        }\n+\n+        @Override\n+        public void put(String key, Object content, String group) {\n+            hitMap.put(key + group, (SearchHits) content);\n+\n+        }\n+\n+        @Override\n+        public void invalidateCacheMesageFromCluster(String message) {\n+\n+\n+        }\n+\n+        @Override\n+        public void initProviders() {\n+\n+\n+        }\n+\n+        @Override\n+        public CacheTransport getTransport() {\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public DotCacheAdministrator getImplementationObject() {\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public Class getImplementationClass() {\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public Set<String> getGroups() {\n+\n+            return ImmutableSet.of(cache.getPrimaryGroup());\n+        }\n+\n+        @Override\n+        public List<CacheProviderStats> getCacheStatsList() {\n+\n+            return null;\n+        }\n+\n+        @Override\n+        public Object get(String key, String group) throws DotCacheException {\n+\n+            return hitMap.get(key + group);\n+        }\n+\n+        @Override\n+        public void flushGroupLocalOnly(String group, boolean ignoreDistributed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 246}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3Mzkx", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187391", "createdAt": "2020-04-09T23:09:59Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1OVrOGDsU2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzowOTo1OVrOGDsU2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTE0NA==", "bodyText": "Issue found: Use assertSame(x, y) instead of assertTrue(x==y), or assertNotSame(x,y) vs assertFalse(x==y)", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525144", "createdAt": "2020-04-09T23:09:59Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImplTest.java", "diffHunk": "@@ -537,4 +542,163 @@ private void runLuceneQueryAndValidateResults(final String query, final Contentl\n         assertEquals(contentlet.getInode(), hits[0].getSourceAsMap().get(\"inode\"));\n     }\n \n+    @Test\n+    public void test_findContentletByIdentifier() throws Exception {\n+    \n+        final Language language1 = new LanguageDataGen().nextPersisted();\n+        final Language language2 = new LanguageDataGen().nextPersisted();\n+        final ContentType blogType = TestDataUtils.getBlogLikeContentType(site);\n+        \n+\n+        // create URL-Mapped content\n+        final Contentlet workingOneLanguage = new ContentletDataGen(blogType.id())\n+                .languageId(language1.getId())\n+                .setProperty(\"body\", \"myBody\")\n+                .nextPersisted();\n+        \n+        // create URL-Mapped content\n+        final Contentlet workingTwoLanguage = new ContentletDataGen(blogType.id())\n+                .languageId(language1.getId())\n+                .setProperty(\"body\", \"myBody\")\n+                .nextPersisted();\n+        \n+        // create URL-Mapped content\n+        final Contentlet publishedTwoLanguage2 = new ContentletDataGen(blogType.id())\n+                .languageId(language2.getId())\n+                .setProperty(\"body\", \"myBody\")\n+                .setProperty(\"identifier\", workingTwoLanguage.getIdentifier())\n+                .nextPersisted();\n+        \n+        \n+        APILocator.getContentletAPI().publish(publishedTwoLanguage2, APILocator.systemUser(), false);\n+        \n+        \n+        \n+        assertEquals(\"workingOneLanguage exists and is working\", workingOneLanguage, instance.findContentletByIdentifier(workingOneLanguage.getIdentifier(), false, language1.getId()));\n+        assertNull(\"workingOneLanguage does not exist in 2nd language\", instance.findContentletByIdentifier(workingOneLanguage.getIdentifier(), false, language2.getId()));\n+        assertNull(\"workingOneLanguage does not exist in live\", instance.findContentletByIdentifier(workingOneLanguage.getIdentifier(), true, language1.getId()));\n+\n+        assertNull(\"workingTwoLanguage in language1 is not live\", instance.findContentletByIdentifier(workingTwoLanguage.getIdentifier(), true, language1.getId()));\n+        assertEquals(\"workingTwoLanguage exists in langauge1 and is working\", workingTwoLanguage, instance.findContentletByIdentifier(workingTwoLanguage.getIdentifier(), false, language1.getId()));\n+        assertEquals(\"workingTwoLanguage exists in langauge2 and is working\", publishedTwoLanguage2, instance.findContentletByIdentifier(workingTwoLanguage.getIdentifier(), false, language2.getId()));\n+        assertEquals(\"workingTwoLanguage exists in langauge2 and is live\", publishedTwoLanguage2, instance.findContentletByIdentifier(workingTwoLanguage.getIdentifier(), true, language2.getId()));\n+\n+    }\n+    \n+    /**\n+     * This tests whether we are getting cached results from queries to elasticsearch and that these\n+     * results are invalidated when a new piece of content is checked in\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void test_cached_es_query_response() throws Exception {\n+        \n+        final Language language1 = new LanguageDataGen().nextPersisted();\n+\n+        final ContentType blogType = TestDataUtils.getBlogLikeContentType(site);\n+        \n+\n+        assert(CacheLocator.getESQueryCache() !=null);\n+        final String liveQuery = \"+baseType:1 +live:true\" ;\n+        final String workingQuery = \"+baseType:1 +live:false\" ;\n+        \n+\n+        SearchHits hits = instance.indexSearch(liveQuery, 10, 0, null);\n+        \n+        //assert we have results\n+        assertTrue(hits.getTotalHits().value > 0);\n+        \n+        SearchHits hits2 = instance.indexSearch(liveQuery, 10, 0, null);\n+        \n+        // hits and hits2 are the same object in memory (meaning, it came from cache)\n+        assertTrue(hits == hits2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 151}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3Mzk1", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187395", "createdAt": "2020-04-09T23:10:00Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowMFrOGDsU2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowMFrOGDsU2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTE0Nw==", "bodyText": "Issue found: Useless parentheses.", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525147", "createdAt": "2020-04-09T23:10:00Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();\n+        assertTrue(!cache.get(request2).isPresent());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_get_hits_by_request() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        assert(cache.get(req1).isPresent());\n+        \n+        assert(cache.get(req2).isPresent());\n+        \n+        assertEquals(cache.get(req1).get(), cache.get(req2).get());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_clear_cache() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        \n+        assert(cache.get(req1).isPresent());\n+        assert(cache.get(req2).isPresent());\n+        \n+        cache.clearCache();\n+        \n+        assert(!cache.get(req1).isPresent());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 120}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3NDAw", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187400", "createdAt": "2020-04-09T23:10:01Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowMVrOGDsU4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowMVrOGDsU4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTE1Mg==", "bodyText": "Issue found: Document empty method body", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525152", "createdAt": "2020-04-09T23:10:01Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();\n+        assertTrue(!cache.get(request2).isPresent());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_get_hits_by_request() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        assert(cache.get(req1).isPresent());\n+        \n+        assert(cache.get(req2).isPresent());\n+        \n+        assertEquals(cache.get(req1).get(), cache.get(req2).get());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_clear_cache() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        \n+        assert(cache.get(req1).isPresent());\n+        assert(cache.get(req2).isPresent());\n+        \n+        cache.clearCache();\n+        \n+        assert(!cache.get(req1).isPresent());\n+        assert(!cache.get(req2).isPresent());\n+\n+\n+    }\n+    \n+    \n+    \n+    \n+    SearchHits hits() {\n+        Random rand = new Random(); \n+        List<SearchHit> hitList = new ArrayList<>();\n+        for(int i=0;i< rand.nextInt(10);i++) {\n+            Text text = new Text(RandomStringUtils.randomAscii(36));\n+            SearchHit hit = new SearchHit(i,RandomStringUtils.randomAscii(36),text,new HashMap<>());\n+            hitList.add(hit);\n+        }\n+        \n+        return new SearchHits(hitList.toArray(new SearchHit[0]), new TotalHits(2, Relation.EQUAL_TO), .7f);\n+        \n+        \n+    }\n+    \n+    \n+    \n+    private SearchRequest getSearchRequest() {\n+\n+        return getSearchRquest(RandomStringUtils.randomAscii(200), true) ;\n+        \n+    }\n+    \n+    @NotNull\n+    private SearchRequest getSearchRquest(String query, boolean live) {\n+        SearchRequest searchRequest = new SearchRequest();\n+        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n+        searchSourceBuilder.query(QueryBuilders.queryStringQuery(query));\n+        searchSourceBuilder.size(0);\n+        searchSourceBuilder.timeout(TimeValue.timeValueMillis(INDEX_OPERATIONS_TIMEOUT_IN_MS));\n+        searchRequest.source(searchSourceBuilder);\n+        searchRequest.indices((live ? \"live\" : \"working\"));\n+        return searchRequest;\n+    }\n+\n+    static DotCacheAdministrator admin = new DotCacheAdministrator() {\n+\n+        private Map<String, SearchHits> hitMap = new HashMap<>();\n+\n+        @Override\n+        public void shutdown() {\n+\n+\n+        }\n+\n+        @Override\n+        public void setTransport(CacheTransport transport) {\n+\n+\n+        }\n+\n+        @Override\n+        public void removeLocalOnly(String key, String group, boolean ignoreDistributed) {\n+            hitMap.remove(key + group);\n+\n+        }\n+\n+        @Override\n+        public void remove(String key, String group) {\n+            hitMap.remove(key + group);\n+\n+        }\n+\n+        @Override\n+        public void put(String key, Object content, String group) {\n+            hitMap.put(key + group, (SearchHits) content);\n+\n+        }\n+\n+        @Override\n+        public void invalidateCacheMesageFromCluster(String message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 198}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3NDA4", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187408", "createdAt": "2020-04-09T23:10:02Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowMlrOGDsU6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowMlrOGDsU6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTE2MQ==", "bodyText": "Issue found: Useless parentheses.", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525161", "createdAt": "2020-04-09T23:10:02Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();\n+        assertTrue(!cache.get(request2).isPresent());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_get_hits_by_request() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        assert(cache.get(req1).isPresent());\n+        \n+        assert(cache.get(req2).isPresent());\n+        \n+        assertEquals(cache.get(req1).get(), cache.get(req2).get());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_clear_cache() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        \n+        assert(cache.get(req1).isPresent());\n+        assert(cache.get(req2).isPresent());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3NDE4", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187418", "createdAt": "2020-04-09T23:10:03Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowM1rOGDsU8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowM1rOGDsU8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTE2OQ==", "bodyText": "Issue found: Unnecessary use of fully qualified name 'com.dotcms.content.elasticsearch.ESQueryCache' due to existing import 'com.dotcms.content.elasticsearch.ESQueryCache'", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525169", "createdAt": "2020-04-09T23:10:03Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/business/CacheLocator.java", "diffHunk": "@@ -436,6 +443,7 @@ Cachable create() {\n \t      \tcase MultiTreeCache : return new MultiTreeCache();\n \t      \tcase ApiTokenCache : return new ApiTokenCache();\n \t      \tcase PortletCache : return new PortletCache();\n+\t      \tcase ESQueryCache : return new com.dotcms.content.elasticsearch.ESQueryCache();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3NDI3", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187427", "createdAt": "2020-04-09T23:10:04Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowNFrOGDsVAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowNFrOGDsVAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTE4Ng==", "bodyText": "Issue found: Avoid unused imports such as 'io.vavr.API'", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525186", "createdAt": "2020-04-09T23:10:04Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImplTest.java", "diffHunk": "@@ -31,32 +52,16 @@\n import com.dotmarketing.portlets.contentlet.business.ContentletFactory;\n import com.dotmarketing.portlets.contentlet.model.Contentlet;\n import com.dotmarketing.portlets.contentlet.model.IndexPolicy;\n+import com.dotmarketing.portlets.languagesmanager.business.LanguageDataGen;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n import com.dotmarketing.util.Logger;\n import com.dotmarketing.util.UUIDGenerator;\n import com.dotmarketing.util.UtilMethods;\n import com.liferay.portal.model.User;\n import com.tngtech.java.junit.dataprovider.DataProvider;\n import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n import com.tngtech.java.junit.dataprovider.UseDataProvider;\n-import java.time.LocalDateTime;\n-import java.time.ZoneId;\n-import java.time.format.DateTimeFormatter;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import org.elasticsearch.search.SearchHit;\n-import org.elasticsearch.search.SearchHits;\n-import org.junit.Assert;\n-import org.junit.BeforeClass;\n-import org.junit.Test;\n-import org.junit.runner.RunWith;\n+import io.vavr.API;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3NDMz", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187433", "createdAt": "2020-04-09T23:10:05Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowNVrOGDsVEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowNVrOGDsVEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTIwMA==", "bodyText": "Issue found: Document empty method body", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525200", "createdAt": "2020-04-09T23:10:05Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();\n+        assertTrue(!cache.get(request2).isPresent());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_get_hits_by_request() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        assert(cache.get(req1).isPresent());\n+        \n+        assert(cache.get(req2).isPresent());\n+        \n+        assertEquals(cache.get(req1).get(), cache.get(req2).get());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_clear_cache() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        \n+        assert(cache.get(req1).isPresent());\n+        assert(cache.get(req2).isPresent());\n+        \n+        cache.clearCache();\n+        \n+        assert(!cache.get(req1).isPresent());\n+        assert(!cache.get(req2).isPresent());\n+\n+\n+    }\n+    \n+    \n+    \n+    \n+    SearchHits hits() {\n+        Random rand = new Random(); \n+        List<SearchHit> hitList = new ArrayList<>();\n+        for(int i=0;i< rand.nextInt(10);i++) {\n+            Text text = new Text(RandomStringUtils.randomAscii(36));\n+            SearchHit hit = new SearchHit(i,RandomStringUtils.randomAscii(36),text,new HashMap<>());\n+            hitList.add(hit);\n+        }\n+        \n+        return new SearchHits(hitList.toArray(new SearchHit[0]), new TotalHits(2, Relation.EQUAL_TO), .7f);\n+        \n+        \n+    }\n+    \n+    \n+    \n+    private SearchRequest getSearchRequest() {\n+\n+        return getSearchRquest(RandomStringUtils.randomAscii(200), true) ;\n+        \n+    }\n+    \n+    @NotNull\n+    private SearchRequest getSearchRquest(String query, boolean live) {\n+        SearchRequest searchRequest = new SearchRequest();\n+        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n+        searchSourceBuilder.query(QueryBuilders.queryStringQuery(query));\n+        searchSourceBuilder.size(0);\n+        searchSourceBuilder.timeout(TimeValue.timeValueMillis(INDEX_OPERATIONS_TIMEOUT_IN_MS));\n+        searchRequest.source(searchSourceBuilder);\n+        searchRequest.indices((live ? \"live\" : \"working\"));\n+        return searchRequest;\n+    }\n+\n+    static DotCacheAdministrator admin = new DotCacheAdministrator() {\n+\n+        private Map<String, SearchHits> hitMap = new HashMap<>();\n+\n+        @Override\n+        public void shutdown() {\n+\n+\n+        }\n+\n+        @Override\n+        public void setTransport(CacheTransport transport) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 174}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3NDQ1", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187445", "createdAt": "2020-04-09T23:10:06Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowNlrOGDsVGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowNlrOGDsVGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTIxMA==", "bodyText": "Issue found: Parameter 'query' is not assigned and could be declared final", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525210", "createdAt": "2020-04-09T23:10:06Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();\n+        assertTrue(!cache.get(request2).isPresent());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_get_hits_by_request() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        assert(cache.get(req1).isPresent());\n+        \n+        assert(cache.get(req2).isPresent());\n+        \n+        assertEquals(cache.get(req1).get(), cache.get(req2).get());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_clear_cache() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        \n+        assert(cache.get(req1).isPresent());\n+        assert(cache.get(req2).isPresent());\n+        \n+        cache.clearCache();\n+        \n+        assert(!cache.get(req1).isPresent());\n+        assert(!cache.get(req2).isPresent());\n+\n+\n+    }\n+    \n+    \n+    \n+    \n+    SearchHits hits() {\n+        Random rand = new Random(); \n+        List<SearchHit> hitList = new ArrayList<>();\n+        for(int i=0;i< rand.nextInt(10);i++) {\n+            Text text = new Text(RandomStringUtils.randomAscii(36));\n+            SearchHit hit = new SearchHit(i,RandomStringUtils.randomAscii(36),text,new HashMap<>());\n+            hitList.add(hit);\n+        }\n+        \n+        return new SearchHits(hitList.toArray(new SearchHit[0]), new TotalHits(2, Relation.EQUAL_TO), .7f);\n+        \n+        \n+    }\n+    \n+    \n+    \n+    private SearchRequest getSearchRequest() {\n+\n+        return getSearchRquest(RandomStringUtils.randomAscii(200), true) ;\n+        \n+    }\n+    \n+    @NotNull\n+    private SearchRequest getSearchRquest(String query, boolean live) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 152}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3NDUx", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187451", "createdAt": "2020-04-09T23:10:07Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowN1rOGDsVIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowN1rOGDsVIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTIxNg==", "bodyText": "Issue found: Local variable 'request1' could be declared final", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525216", "createdAt": "2020-04-09T23:10:07Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3NDU5", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187459", "createdAt": "2020-04-09T23:10:08Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowOFrOGDsVJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowOFrOGDsVJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTIyMw==", "bodyText": "Issue found: Local variable 'request2' could be declared final", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525223", "createdAt": "2020-04-09T23:10:08Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3NDY3", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187467", "createdAt": "2020-04-09T23:10:09Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowOVrOGDsVMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDowOVrOGDsVMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTIzMg==", "bodyText": "Issue found: Parameter 'key' is not assigned and could be declared final", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525232", "createdAt": "2020-04-09T23:10:09Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();\n+        assertTrue(!cache.get(request2).isPresent());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_get_hits_by_request() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        assert(cache.get(req1).isPresent());\n+        \n+        assert(cache.get(req2).isPresent());\n+        \n+        assertEquals(cache.get(req1).get(), cache.get(req2).get());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_clear_cache() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        \n+        assert(cache.get(req1).isPresent());\n+        assert(cache.get(req2).isPresent());\n+        \n+        cache.clearCache();\n+        \n+        assert(!cache.get(req1).isPresent());\n+        assert(!cache.get(req2).isPresent());\n+\n+\n+    }\n+    \n+    \n+    \n+    \n+    SearchHits hits() {\n+        Random rand = new Random(); \n+        List<SearchHit> hitList = new ArrayList<>();\n+        for(int i=0;i< rand.nextInt(10);i++) {\n+            Text text = new Text(RandomStringUtils.randomAscii(36));\n+            SearchHit hit = new SearchHit(i,RandomStringUtils.randomAscii(36),text,new HashMap<>());\n+            hitList.add(hit);\n+        }\n+        \n+        return new SearchHits(hitList.toArray(new SearchHit[0]), new TotalHits(2, Relation.EQUAL_TO), .7f);\n+        \n+        \n+    }\n+    \n+    \n+    \n+    private SearchRequest getSearchRequest() {\n+\n+        return getSearchRquest(RandomStringUtils.randomAscii(200), true) ;\n+        \n+    }\n+    \n+    @NotNull\n+    private SearchRequest getSearchRquest(String query, boolean live) {\n+        SearchRequest searchRequest = new SearchRequest();\n+        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();\n+        searchSourceBuilder.query(QueryBuilders.queryStringQuery(query));\n+        searchSourceBuilder.size(0);\n+        searchSourceBuilder.timeout(TimeValue.timeValueMillis(INDEX_OPERATIONS_TIMEOUT_IN_MS));\n+        searchRequest.source(searchSourceBuilder);\n+        searchRequest.indices((live ? \"live\" : \"working\"));\n+        return searchRequest;\n+    }\n+\n+    static DotCacheAdministrator admin = new DotCacheAdministrator() {\n+\n+        private Map<String, SearchHits> hitMap = new HashMap<>();\n+\n+        @Override\n+        public void shutdown() {\n+\n+\n+        }\n+\n+        @Override\n+        public void setTransport(CacheTransport transport) {\n+\n+\n+        }\n+\n+        @Override\n+        public void removeLocalOnly(String key, String group, boolean ignoreDistributed) {\n+            hitMap.remove(key + group);\n+\n+        }\n+\n+        @Override\n+        public void remove(String key, String group) {\n+            hitMap.remove(key + group);\n+\n+        }\n+\n+        @Override\n+        public void put(String key, Object content, String group) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 192}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3NDgw", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187480", "createdAt": "2020-04-09T23:10:10Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDoxMFrOGDsVPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDoxMFrOGDsVPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTI0NQ==", "bodyText": "Issue found: Local variable 'user' could be declared final", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525245", "createdAt": "2020-04-09T23:10:10Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/datagen/TestUserUtils.java", "diffHunk": "@@ -173,8 +173,10 @@ public static User getUser(final Role role, final String email,\n             final String lastName, final String password)\n             throws DotDataException {\n         final List<User> users = APILocator.getUserAPI().getUsersByNameOrEmail(email, 0, 1);\n-        if (UtilMethods.isSet(users)) {\n-            return users.get(0);\n+        if (UtilMethods.isSet(users) && !users.isEmpty()) {\n+            User user = users.get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3NDg0", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187484", "createdAt": "2020-04-09T23:10:11Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDoxMVrOGDsVPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDoxMVrOGDsVPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTI0Nw==", "bodyText": "Issue found: Avoid unused local variables such as 'workingQuery'.", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525247", "createdAt": "2020-04-09T23:10:11Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImplTest.java", "diffHunk": "@@ -537,4 +542,163 @@ private void runLuceneQueryAndValidateResults(final String query, final Contentl\n         assertEquals(contentlet.getInode(), hits[0].getSourceAsMap().get(\"inode\"));\n     }\n \n+    @Test\n+    public void test_findContentletByIdentifier() throws Exception {\n+    \n+        final Language language1 = new LanguageDataGen().nextPersisted();\n+        final Language language2 = new LanguageDataGen().nextPersisted();\n+        final ContentType blogType = TestDataUtils.getBlogLikeContentType(site);\n+        \n+\n+        // create URL-Mapped content\n+        final Contentlet workingOneLanguage = new ContentletDataGen(blogType.id())\n+                .languageId(language1.getId())\n+                .setProperty(\"body\", \"myBody\")\n+                .nextPersisted();\n+        \n+        // create URL-Mapped content\n+        final Contentlet workingTwoLanguage = new ContentletDataGen(blogType.id())\n+                .languageId(language1.getId())\n+                .setProperty(\"body\", \"myBody\")\n+                .nextPersisted();\n+        \n+        // create URL-Mapped content\n+        final Contentlet publishedTwoLanguage2 = new ContentletDataGen(blogType.id())\n+                .languageId(language2.getId())\n+                .setProperty(\"body\", \"myBody\")\n+                .setProperty(\"identifier\", workingTwoLanguage.getIdentifier())\n+                .nextPersisted();\n+        \n+        \n+        APILocator.getContentletAPI().publish(publishedTwoLanguage2, APILocator.systemUser(), false);\n+        \n+        \n+        \n+        assertEquals(\"workingOneLanguage exists and is working\", workingOneLanguage, instance.findContentletByIdentifier(workingOneLanguage.getIdentifier(), false, language1.getId()));\n+        assertNull(\"workingOneLanguage does not exist in 2nd language\", instance.findContentletByIdentifier(workingOneLanguage.getIdentifier(), false, language2.getId()));\n+        assertNull(\"workingOneLanguage does not exist in live\", instance.findContentletByIdentifier(workingOneLanguage.getIdentifier(), true, language1.getId()));\n+\n+        assertNull(\"workingTwoLanguage in language1 is not live\", instance.findContentletByIdentifier(workingTwoLanguage.getIdentifier(), true, language1.getId()));\n+        assertEquals(\"workingTwoLanguage exists in langauge1 and is working\", workingTwoLanguage, instance.findContentletByIdentifier(workingTwoLanguage.getIdentifier(), false, language1.getId()));\n+        assertEquals(\"workingTwoLanguage exists in langauge2 and is working\", publishedTwoLanguage2, instance.findContentletByIdentifier(workingTwoLanguage.getIdentifier(), false, language2.getId()));\n+        assertEquals(\"workingTwoLanguage exists in langauge2 and is live\", publishedTwoLanguage2, instance.findContentletByIdentifier(workingTwoLanguage.getIdentifier(), true, language2.getId()));\n+\n+    }\n+    \n+    /**\n+     * This tests whether we are getting cached results from queries to elasticsearch and that these\n+     * results are invalidated when a new piece of content is checked in\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void test_cached_es_query_response() throws Exception {\n+        \n+        final Language language1 = new LanguageDataGen().nextPersisted();\n+\n+        final ContentType blogType = TestDataUtils.getBlogLikeContentType(site);\n+        \n+\n+        assert(CacheLocator.getESQueryCache() !=null);\n+        final String liveQuery = \"+baseType:1 +live:true\" ;\n+        final String workingQuery = \"+baseType:1 +live:false\" ;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 140}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3NDky", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187492", "createdAt": "2020-04-09T23:10:12Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDoxMlrOGDsVRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDoxMlrOGDsVRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTI1Mw==", "bodyText": "Issue found: Use equals() to compare object references.", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525253", "createdAt": "2020-04-09T23:10:12Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESContentFactoryImplTest.java", "diffHunk": "@@ -537,4 +542,163 @@ private void runLuceneQueryAndValidateResults(final String query, final Contentl\n         assertEquals(contentlet.getInode(), hits[0].getSourceAsMap().get(\"inode\"));\n     }\n \n+    @Test\n+    public void test_findContentletByIdentifier() throws Exception {\n+    \n+        final Language language1 = new LanguageDataGen().nextPersisted();\n+        final Language language2 = new LanguageDataGen().nextPersisted();\n+        final ContentType blogType = TestDataUtils.getBlogLikeContentType(site);\n+        \n+\n+        // create URL-Mapped content\n+        final Contentlet workingOneLanguage = new ContentletDataGen(blogType.id())\n+                .languageId(language1.getId())\n+                .setProperty(\"body\", \"myBody\")\n+                .nextPersisted();\n+        \n+        // create URL-Mapped content\n+        final Contentlet workingTwoLanguage = new ContentletDataGen(blogType.id())\n+                .languageId(language1.getId())\n+                .setProperty(\"body\", \"myBody\")\n+                .nextPersisted();\n+        \n+        // create URL-Mapped content\n+        final Contentlet publishedTwoLanguage2 = new ContentletDataGen(blogType.id())\n+                .languageId(language2.getId())\n+                .setProperty(\"body\", \"myBody\")\n+                .setProperty(\"identifier\", workingTwoLanguage.getIdentifier())\n+                .nextPersisted();\n+        \n+        \n+        APILocator.getContentletAPI().publish(publishedTwoLanguage2, APILocator.systemUser(), false);\n+        \n+        \n+        \n+        assertEquals(\"workingOneLanguage exists and is working\", workingOneLanguage, instance.findContentletByIdentifier(workingOneLanguage.getIdentifier(), false, language1.getId()));\n+        assertNull(\"workingOneLanguage does not exist in 2nd language\", instance.findContentletByIdentifier(workingOneLanguage.getIdentifier(), false, language2.getId()));\n+        assertNull(\"workingOneLanguage does not exist in live\", instance.findContentletByIdentifier(workingOneLanguage.getIdentifier(), true, language1.getId()));\n+\n+        assertNull(\"workingTwoLanguage in language1 is not live\", instance.findContentletByIdentifier(workingTwoLanguage.getIdentifier(), true, language1.getId()));\n+        assertEquals(\"workingTwoLanguage exists in langauge1 and is working\", workingTwoLanguage, instance.findContentletByIdentifier(workingTwoLanguage.getIdentifier(), false, language1.getId()));\n+        assertEquals(\"workingTwoLanguage exists in langauge2 and is working\", publishedTwoLanguage2, instance.findContentletByIdentifier(workingTwoLanguage.getIdentifier(), false, language2.getId()));\n+        assertEquals(\"workingTwoLanguage exists in langauge2 and is live\", publishedTwoLanguage2, instance.findContentletByIdentifier(workingTwoLanguage.getIdentifier(), true, language2.getId()));\n+\n+    }\n+    \n+    /**\n+     * This tests whether we are getting cached results from queries to elasticsearch and that these\n+     * results are invalidated when a new piece of content is checked in\n+     * \n+     * @throws Exception\n+     */\n+    @Test\n+    public void test_cached_es_query_response() throws Exception {\n+        \n+        final Language language1 = new LanguageDataGen().nextPersisted();\n+\n+        final ContentType blogType = TestDataUtils.getBlogLikeContentType(site);\n+        \n+\n+        assert(CacheLocator.getESQueryCache() !=null);\n+        final String liveQuery = \"+baseType:1 +live:true\" ;\n+        final String workingQuery = \"+baseType:1 +live:false\" ;\n+        \n+\n+        SearchHits hits = instance.indexSearch(liveQuery, 10, 0, null);\n+        \n+        //assert we have results\n+        assertTrue(hits.getTotalHits().value > 0);\n+        \n+        SearchHits hits2 = instance.indexSearch(liveQuery, 10, 0, null);\n+        \n+        // hits and hits2 are the same object in memory (meaning, it came from cache)\n+        assertTrue(hits == hits2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 151}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3NTAx", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187501", "createdAt": "2020-04-09T23:10:14Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDoxNFrOGDsVSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDoxNFrOGDsVSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTI1OQ==", "bodyText": "Issue found: Local variable 'testQuery' could be declared final", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525259", "createdAt": "2020-04-09T23:10:14Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3NTA1", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187505", "createdAt": "2020-04-09T23:10:14Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDoxNVrOGDsVTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDoxNVrOGDsVTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTI2Mw==", "bodyText": "Issue found: JUnit tests should include assert() or fail()", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525263", "createdAt": "2020-04-09T23:10:15Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();\n+        assertTrue(!cache.get(request2).isPresent());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_get_hits_by_request() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        assert(cache.get(req1).isPresent());\n+        \n+        assert(cache.get(req2).isPresent());\n+        \n+        assertEquals(cache.get(req1).get(), cache.get(req2).get());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_clear_cache() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 104}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTg3NTE2", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-391187516", "createdAt": "2020-04-09T23:10:15Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDoxNlrOGDsVVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMzoxMDoxNlrOGDsVVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjUyNTI2OQ==", "bodyText": "Issue found: Local variable 'searchSourceBuilder' could be declared final", "url": "https://github.com/dotCMS/core/pull/18243#discussion_r406525269", "createdAt": "2020-04-09T23:10:16Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/content/elasticsearch/ESQueryCacheTest.java", "diffHunk": "@@ -0,0 +1,272 @@\n+package com.dotcms.content.elasticsearch;\n+\n+import static com.dotcms.content.elasticsearch.business.ESIndexAPI.INDEX_OPERATIONS_TIMEOUT_IN_MS;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertTrue;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.apache.lucene.search.TotalHits;\n+import org.apache.lucene.search.TotalHits.Relation;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.common.text.Text;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.search.SearchHits;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.business.DotCacheException;\n+import com.dotmarketing.business.cache.provider.CacheProviderStats;\n+import com.dotmarketing.business.cache.transport.CacheTransport;\n+import com.google.common.collect.ImmutableSet;\n+\n+public class ESQueryCacheTest {\n+\n+\n+    static ESQueryCache cache;\n+\n+\n+    @BeforeClass\n+    public static void setup() {\n+\n+        cache = new  ESQueryCache(admin);\n+        \n+        \n+        \n+    }\n+\n+    @Test\n+    public void test_hash() {\n+\n+        String testQuery =RandomStringUtils.randomAscii(200);\n+\n+        SearchRequest request1 = getSearchRquest(testQuery, true) ;\n+        SearchRequest request2 = getSearchRquest(testQuery, true) ;\n+        \n+\n+        assertEquals(cache.hash(request1), cache.hash(request2));\n+        \n+        \n+        SearchRequest request3 = getSearchRquest(testQuery, false) ;\n+        \n+\n+        assertNotEquals(cache.hash(request1), cache.hash(request3));\n+    }\n+\n+    \n+    @Test\n+    public void test_get_hits_by_query() {\n+\n+        SearchRequest request = getSearchRequest();\n+        SearchHits hits= hits();\n+        cache.put(request, hits);\n+        \n+        assertTrue(cache.get(request).isPresent());\n+        \n+        assertEquals(hits, cache.get(request).get());\n+        \n+        SearchRequest request2 = getSearchRequest();\n+        assertTrue(!cache.get(request2).isPresent());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_get_hits_by_request() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        assert(cache.get(req1).isPresent());\n+        \n+        assert(cache.get(req2).isPresent());\n+        \n+        assertEquals(cache.get(req1).get(), cache.get(req2).get());\n+\n+    }\n+    \n+    \n+    @Test\n+    public void test_clear_cache() {\n+\n+        final String testQuery =RandomStringUtils.randomAscii(200);\n+        SearchHits hits= hits();\n+        \n+        SearchRequest req1 = getSearchRquest(testQuery, true);\n+        SearchRequest req2 = getSearchRquest(testQuery, true);\n+        cache.put(req1, hits);\n+        \n+\n+        \n+        assert(cache.get(req1).isPresent());\n+        assert(cache.get(req2).isPresent());\n+        \n+        cache.clearCache();\n+        \n+        assert(!cache.get(req1).isPresent());\n+        assert(!cache.get(req2).isPresent());\n+\n+\n+    }\n+    \n+    \n+    \n+    \n+    SearchHits hits() {\n+        Random rand = new Random(); \n+        List<SearchHit> hitList = new ArrayList<>();\n+        for(int i=0;i< rand.nextInt(10);i++) {\n+            Text text = new Text(RandomStringUtils.randomAscii(36));\n+            SearchHit hit = new SearchHit(i,RandomStringUtils.randomAscii(36),text,new HashMap<>());\n+            hitList.add(hit);\n+        }\n+        \n+        return new SearchHits(hitList.toArray(new SearchHit[0]), new TotalHits(2, Relation.EQUAL_TO), .7f);\n+        \n+        \n+    }\n+    \n+    \n+    \n+    private SearchRequest getSearchRequest() {\n+\n+        return getSearchRquest(RandomStringUtils.randomAscii(200), true) ;\n+        \n+    }\n+    \n+    @NotNull\n+    private SearchRequest getSearchRquest(String query, boolean live) {\n+        SearchRequest searchRequest = new SearchRequest();\n+        SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMzg5MjM0", "url": "https://github.com/dotCMS/core/pull/18243#pullrequestreview-392389234", "createdAt": "2020-04-13T19:47:59Z", "commit": {"oid": "3438952c02eb9a535aadb19d85393d75caed31a6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1240, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}