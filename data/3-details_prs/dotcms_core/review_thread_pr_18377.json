{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwMTE4OTQ0", "number": 18377, "reviewThreads": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyMTowNlrOEGDo6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxOVrOEGkDIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzg2NTM4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/datagen/VanityUrlDataGen.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyMTowNlrOGknxmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyMTowNlrOGknxmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1MzU5Mw==", "bodyText": "Fix javadoc", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441053593", "createdAt": "2020-06-16T18:21:06Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotcms/datagen/VanityUrlDataGen.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package com.dotcms.datagen;\n+\n+import com.dotcms.vanityurl.business.VanityUrlAPI;\n+import com.dotcms.vanityurl.model.DefaultVanityUrl;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.contentlet.model.IndexPolicy;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+\n+import io.vavr.control.Try;\n+\n+/**\n+ * Class used to create {@link Contentlet} objects of type Persona for test purposes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3078ad44c742c6f044bcf1de7881a43057321e5"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzg4NTI4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/util/FiltersUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyNTozOFrOGkn-SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyNTozOFrOGkn-SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1Njg0MQ==", "bodyText": "this could be change to DotContentletTransformer when it gets done", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441056841", "createdAt": "2020-06-16T18:25:38Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/util/FiltersUtil.java", "diffHunk": "@@ -85,7 +86,7 @@ public Contentlet createVanityUrl(String title, String site, String uri,\n         contentlet.setIndexPolicyDependencies(IndexPolicy.FORCE);\n         contentlet.setBoolProperty(Contentlet.IS_TEST_MODE, true);\n \n-        return contentlet;\n+        return (DefaultVanityUrl) APILocator.getVanityUrlAPI().fromContentlet(contentlet);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3078ad44c742c6f044bcf1de7881a43057321e5"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzg5MDk5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentletAPIImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyNzowOVrOGkoBwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyNzowOVrOGkoBwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1NzczMA==", "bodyText": "this shouldn't be there", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441057730", "createdAt": "2020-06-16T18:27:09Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentletAPIImpl.java", "diffHunk": "@@ -4141,6 +4149,7 @@ private Contentlet checkin(final Contentlet contentletIn, final ContentletRelati\n                                 )\n                         ); // end synchronized block\n             } catch (final Throwable t) {\n+              t.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3078ad44c742c6f044bcf1de7881a43057321e5"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0Nzg5ODEyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPI.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyOToxOVrOGkoGbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODoyOToxOVrOGkoGbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1ODkyNQ==", "bodyText": "Add doc to all methods", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441058925", "createdAt": "2020-06-16T18:29:19Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPI.java", "diffHunk": "@@ -1,73 +1,42 @@\n package com.dotcms.vanityurl.business;\n \n+import java.util.List;\n+import java.util.Optional;\n+\n import com.dotcms.vanityurl.model.CachedVanityUrl;\n import com.dotcms.vanityurl.model.VanityUrl;\n import com.dotmarketing.beans.Host;\n+import com.dotmarketing.exception.DotDataException;\n import com.dotmarketing.portlets.contentlet.model.Contentlet;\n-import com.liferay.portal.model.User;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n \n /**\n- * This API provides access to the information related to Vanity URLs\n- * in dotCMS. Vanity URLs are alternate reference paths to\n- * internal or external URL's. Vanity URLs are most commonly used to give\n- * visitors to the website a more user-friendly or memorable way of reaching an\n- * HTML page or File, that might actually live \u201cburied\u201d in a much deeper path.\n+ * This API provides access to the information related to Vanity URLs in dotCMS. Vanity URLs are\n+ * alternate reference paths to internal or external URL's. Vanity URLs are most commonly used to\n+ * give visitors to the website a more user-friendly or memorable way of reaching an HTML page or\n+ * File, that might actually live \u201cburied\u201d in a much deeper path.\n  *\n  * @author oswaldogallango\n  * @version 4.2.0\n  * @since June 12, 2017\n  */\n public interface VanityUrlAPI {\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_INODE = \"8e850645-bb92-4fda-a765-e67063a59be0\";\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_VARNAME = \"Vanityurl\";\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_NAME = \"Vanity URL\";\n+\n+    void validateVanityUrl(Contentlet contentlet);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3078ad44c742c6f044bcf1de7881a43057321e5"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NzkwMjg4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPIImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODozMDo0NVrOGkoJtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODozMDo0NVrOGkoJtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA1OTc2NA==", "bodyText": "rename to language and set to final", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441059764", "createdAt": "2020-06-16T18:30:45Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPIImpl.java", "diffHunk": "@@ -54,679 +44,240 @@\n  * @since June 12, 2017\n  */\n public class VanityUrlAPIImpl implements VanityUrlAPI {\n-    \n-    private final Set<Integer> allowedActions = new ImmutableSet.Builder<Integer>().add(200).add(301).add(302).build();\n-\n-    public static final String URL_SUFFIX = \"/\";\n-    public static final String LEGACY_CMS_HOME_PAGE = \"/cmsHomePage\";\n-    private final ContentletAPI     contentletAPI;\n-    private final VanityUrlServices vanityUrlServices;\n-    private final LanguageAPI       languageAPI;\n-    private final UserAPI           userAPI;\n-    private final long              defaultLanguageId;\n-    private final User              systemUser;\n-\n-    private static final int CODE_404_VALUE = 404;\n-    private static final VanityMatches VANITY_MATCHES_FALSE =\n-            new VanityMatches(Boolean.FALSE, null);\n-    private static final VanityMatches VANITY_MATCHES_TRUE =\n-            new VanityMatches(Boolean.TRUE, null);\n-\n-\n-    public VanityUrlAPIImpl() throws DotDataException {\n-        this(APILocator.getContentletAPI(),\n-                VanityUrlServices.getInstance(),\n-                APILocator.getLanguageAPI(),\n-                APILocator.getUserAPI());\n-    }\n-\n-    @VisibleForTesting\n-    public VanityUrlAPIImpl(final ContentletAPI contentletAPI,\n-            final VanityUrlServices vanityUrlServices,\n-            final LanguageAPI       languageAPI,\n-            final UserAPI           userAPI) throws DotDataException {\n-\n-        this.contentletAPI     = contentletAPI;\n-        this.vanityUrlServices = vanityUrlServices;\n-        this.languageAPI       = languageAPI;\n-        this.userAPI           = userAPI;\n-        this.defaultLanguageId = languageAPI.getDefaultLanguage()\n-                .getId();\n-        this.systemUser        = userAPI.getSystemUser();\n \n+  private final Set<Integer> allowedActions = new ImmutableSet.Builder<Integer>().add(200).add(301).add(302).build();\n+\n+  private static final String SELECT_LIVE_VANITY_URL_INODES =\n+      \"SELECT cvi.live_inode FROM contentlet c, identifier i, contentlet_version_info cvi, structure s \"\n+          + \" where s.structuretype= 7 and c.structure_inode=s.inode \"\n+          + \" and cvi.live_inode=c.inode and cvi.identifier = i.id  and i.host_inode = ? and cvi.lang =? \";\n+\n+  public static final String URL_SUFFIX = \"/\";\n+  public static final String LEGACY_CMS_HOME_PAGE = \"/cmsHomePage\";\n+  private final ContentletAPI contentletAPI;\n+  private final VanityUrlCache cache;\n+  private final LanguageAPI languageAPI;\n+  private final boolean languageFallback = Config.getBooleanProperty(\"DEFAULT_VANITY_URL_TO_DEFAULT_LANGUAGE\", false) ;\n+\n+  public VanityUrlAPIImpl()  {\n+    this(APILocator.getContentletAPI(),\n+        APILocator.getLanguageAPI(), \n+        APILocator.getUserAPI(),\n+        CacheLocator.getVanityURLCache());\n+  }\n+\n+  @VisibleForTesting\n+  public VanityUrlAPIImpl(final ContentletAPI contentletAPI, \n+      final LanguageAPI languageAPI, \n+      final UserAPI userAPI,\n+      final VanityUrlCache cache) {\n+    this.contentletAPI = contentletAPI;\n+    this.languageAPI = languageAPI;\n+    this.cache = cache;\n+   \n+\n+  }\n+\n+  /**\n+   * Searches for all Vanity URLs for a given Site in the system. It goes directly to the database in\n+   * order to avoid retrieving data that has not been updated in the ES index yet. This initialization\n+   * routine will also add Vanity URLs located under System Host.\n+   *\n+   * @param siteId String site id\n+   * @param languageId Long language id\n+   * @return A list of VanityURLs\n+   */\n+  private void populateVanityURLsCacheBySite(final Host host) {\n+    if(host==null || host.getIdentifier()==null) {\n+        throw new DotStateException(\"Host cannot be null. Got:\" + host);\n     }\n-\n-    @CloseDBIfOpened\n-    @Override\n-    public void initializeVanityURLsCache(final User user) {\n-        initializeActiveVanityURLsCacheBySiteAndLanguage(null, null);\n+    Logger.info(this.getClass(), \"Populating Vanity URLS for :\" + host.getHostname()); \n+    for (Language lang : languageAPI.getLanguages()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3078ad44c742c6f044bcf1de7881a43057321e5"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NzkyODc3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/util/FiltersUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxODozNzo1N1rOGkoaEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMjo1MjoyNFrOGkv12w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2Mzk1Mg==", "bodyText": "Why changing the return type? You should leave Contentlet", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441063952", "createdAt": "2020-06-16T18:37:57Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotcms/util/FiltersUtil.java", "diffHunk": "@@ -85,7 +86,7 @@ public Contentlet createVanityUrl(String title, String site, String uri,\n         contentlet.setIndexPolicyDependencies(IndexPolicy.FORCE);\n         contentlet.setBoolProperty(Contentlet.IS_TEST_MODE, true);\n \n-        return contentlet;\n+        return (DefaultVanityUrl) APILocator.getVanityUrlAPI().fromContentlet(contentlet);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3078ad44c742c6f044bcf1de7881a43057321e5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NTc1NQ==", "bodyText": "This is to avoid transforming it when this is called, so we can use the VanityUrl specific methods.", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441185755", "createdAt": "2020-06-16T22:52:24Z", "author": {"login": "erickgonzalez"}, "path": "dotCMS/src/integration-test/java/com/dotcms/util/FiltersUtil.java", "diffHunk": "@@ -85,7 +86,7 @@ public Contentlet createVanityUrl(String title, String site, String uri,\n         contentlet.setIndexPolicyDependencies(IndexPolicy.FORCE);\n         contentlet.setBoolProperty(Contentlet.IS_TEST_MODE, true);\n \n-        return contentlet;\n+        return (DefaultVanityUrl) APILocator.getVanityUrlAPI().fromContentlet(contentlet);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA2Mzk1Mg=="}, "originalCommit": {"oid": "a3078ad44c742c6f044bcf1de7881a43057321e5"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODAyMzIyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentletAPIImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTowNjozMlrOGkpXXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTowNjozMlrOGkpXXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3OTY0NQ==", "bodyText": "remove this or replace with Logger", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441079645", "createdAt": "2020-06-16T19:06:32Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESContentletAPIImpl.java", "diffHunk": "@@ -4141,6 +4149,7 @@ private Contentlet checkin(final Contentlet contentletIn, final ContentletRelati\n                                 )\n                         ); // end synchronized block\n             } catch (final Throwable t) {\n+              t.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3078ad44c742c6f044bcf1de7881a43057321e5"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODA0MDEzOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPI.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxMTo0N1rOGkpigw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxMTo0N1rOGkpigw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4MjQ5OQ==", "bodyText": "javadoc", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441082499", "createdAt": "2020-06-16T19:11:47Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPI.java", "diffHunk": "@@ -1,73 +1,42 @@\n package com.dotcms.vanityurl.business;\n \n+import java.util.List;\n+import java.util.Optional;\n+\n import com.dotcms.vanityurl.model.CachedVanityUrl;\n import com.dotcms.vanityurl.model.VanityUrl;\n import com.dotmarketing.beans.Host;\n+import com.dotmarketing.exception.DotDataException;\n import com.dotmarketing.portlets.contentlet.model.Contentlet;\n-import com.liferay.portal.model.User;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n \n /**\n- * This API provides access to the information related to Vanity URLs\n- * in dotCMS. Vanity URLs are alternate reference paths to\n- * internal or external URL's. Vanity URLs are most commonly used to give\n- * visitors to the website a more user-friendly or memorable way of reaching an\n- * HTML page or File, that might actually live \u201cburied\u201d in a much deeper path.\n+ * This API provides access to the information related to Vanity URLs in dotCMS. Vanity URLs are\n+ * alternate reference paths to internal or external URL's. Vanity URLs are most commonly used to\n+ * give visitors to the website a more user-friendly or memorable way of reaching an HTML page or\n+ * File, that might actually live \u201cburied\u201d in a much deeper path.\n  *\n  * @author oswaldogallango\n  * @version 4.2.0\n  * @since June 12, 2017\n  */\n public interface VanityUrlAPI {\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_INODE = \"8e850645-bb92-4fda-a765-e67063a59be0\";\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_VARNAME = \"Vanityurl\";\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_NAME = \"Vanity URL\";\n+\n+    void validateVanityUrl(Contentlet contentlet);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3078ad44c742c6f044bcf1de7881a43057321e5"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODA0MDUxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPI.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxMTo1NlrOGkpiyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxMTo1NlrOGkpiyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4MjU2OA==", "bodyText": "javadoc", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441082568", "createdAt": "2020-06-16T19:11:56Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPI.java", "diffHunk": "@@ -1,73 +1,42 @@\n package com.dotcms.vanityurl.business;\n \n+import java.util.List;\n+import java.util.Optional;\n+\n import com.dotcms.vanityurl.model.CachedVanityUrl;\n import com.dotcms.vanityurl.model.VanityUrl;\n import com.dotmarketing.beans.Host;\n+import com.dotmarketing.exception.DotDataException;\n import com.dotmarketing.portlets.contentlet.model.Contentlet;\n-import com.liferay.portal.model.User;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n \n /**\n- * This API provides access to the information related to Vanity URLs\n- * in dotCMS. Vanity URLs are alternate reference paths to\n- * internal or external URL's. Vanity URLs are most commonly used to give\n- * visitors to the website a more user-friendly or memorable way of reaching an\n- * HTML page or File, that might actually live \u201cburied\u201d in a much deeper path.\n+ * This API provides access to the information related to Vanity URLs in dotCMS. Vanity URLs are\n+ * alternate reference paths to internal or external URL's. Vanity URLs are most commonly used to\n+ * give visitors to the website a more user-friendly or memorable way of reaching an HTML page or\n+ * File, that might actually live \u201cburied\u201d in a much deeper path.\n  *\n  * @author oswaldogallango\n  * @version 4.2.0\n  * @since June 12, 2017\n  */\n public interface VanityUrlAPI {\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_INODE = \"8e850645-bb92-4fda-a765-e67063a59be0\";\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_VARNAME = \"Vanityurl\";\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_NAME = \"Vanity URL\";\n+\n+    void validateVanityUrl(Contentlet contentlet);\n \n-    public static final String CACHE_404_VANITY_URL = \"CACHE_404_VANITY_URL\";\n+    Optional<CachedVanityUrl> resolveVanityUrl(String url, Host host, Language language);\n \n-    /**\n-     * Searches and populates the cache for live VanityURLs, each VanityURL found is added into the cache.\n-     * <br>\n-     * Note this method does not uses cache, always does the ES search, the intention of this method\n-     * is mainly to populate the cache with the found data.\n-     *\n-     * @param user The current user\n-     * @return a List of all Cached Vanity URLs contentlets live\n-     */\n-    void initializeVanityURLsCache(final User user);\n+    VanityUrl fromContentlet(Contentlet contentlet);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3078ad44c742c6f044bcf1de7881a43057321e5"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODA0MTA1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPI.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxMjowN1rOGkpjGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxMjowN1rOGkpjGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4MjY1MA==", "bodyText": "javadoc", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441082650", "createdAt": "2020-06-16T19:12:07Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPI.java", "diffHunk": "@@ -1,73 +1,42 @@\n package com.dotcms.vanityurl.business;\n \n+import java.util.List;\n+import java.util.Optional;\n+\n import com.dotcms.vanityurl.model.CachedVanityUrl;\n import com.dotcms.vanityurl.model.VanityUrl;\n import com.dotmarketing.beans.Host;\n+import com.dotmarketing.exception.DotDataException;\n import com.dotmarketing.portlets.contentlet.model.Contentlet;\n-import com.liferay.portal.model.User;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n \n /**\n- * This API provides access to the information related to Vanity URLs\n- * in dotCMS. Vanity URLs are alternate reference paths to\n- * internal or external URL's. Vanity URLs are most commonly used to give\n- * visitors to the website a more user-friendly or memorable way of reaching an\n- * HTML page or File, that might actually live \u201cburied\u201d in a much deeper path.\n+ * This API provides access to the information related to Vanity URLs in dotCMS. Vanity URLs are\n+ * alternate reference paths to internal or external URL's. Vanity URLs are most commonly used to\n+ * give visitors to the website a more user-friendly or memorable way of reaching an HTML page or\n+ * File, that might actually live \u201cburied\u201d in a much deeper path.\n  *\n  * @author oswaldogallango\n  * @version 4.2.0\n  * @since June 12, 2017\n  */\n public interface VanityUrlAPI {\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_INODE = \"8e850645-bb92-4fda-a765-e67063a59be0\";\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_VARNAME = \"Vanityurl\";\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_NAME = \"Vanity URL\";\n+\n+    void validateVanityUrl(Contentlet contentlet);\n \n-    public static final String CACHE_404_VANITY_URL = \"CACHE_404_VANITY_URL\";\n+    Optional<CachedVanityUrl> resolveVanityUrl(String url, Host host, Language language);\n \n-    /**\n-     * Searches and populates the cache for live VanityURLs, each VanityURL found is added into the cache.\n-     * <br>\n-     * Note this method does not uses cache, always does the ES search, the intention of this method\n-     * is mainly to populate the cache with the found data.\n-     *\n-     * @param user The current user\n-     * @return a List of all Cached Vanity URLs contentlets live\n-     */\n-    void initializeVanityURLsCache(final User user);\n+    VanityUrl fromContentlet(Contentlet contentlet);\n \n-    /**\n-     * Return the live version of the Cached vanityurl URL contentlet with the specified URI\n-     *\n-     * @param uri The URI of the vanityurl URL\n-     * @param host The current host\n-     * @param languageId The current language Id\n-     * @param user The current user\n-     * @return the live version of the vanityurl URL contentlet\n-     */\n-    CachedVanityUrl getLiveCachedVanityUrl(final String uri, final Host site, final long languageId,\n-                                           final User user);\n+    void populateAllVanityURLsCache() throws DotDataException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3078ad44c742c6f044bcf1de7881a43057321e5"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODA0MjY3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPI.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxMjozOVrOGkpkHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxMjozOVrOGkpkHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4MjkwOA==", "bodyText": "javadoc", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441082908", "createdAt": "2020-06-16T19:12:39Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPI.java", "diffHunk": "@@ -1,73 +1,42 @@\n package com.dotcms.vanityurl.business;\n \n+import java.util.List;\n+import java.util.Optional;\n+\n import com.dotcms.vanityurl.model.CachedVanityUrl;\n import com.dotcms.vanityurl.model.VanityUrl;\n import com.dotmarketing.beans.Host;\n+import com.dotmarketing.exception.DotDataException;\n import com.dotmarketing.portlets.contentlet.model.Contentlet;\n-import com.liferay.portal.model.User;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n \n /**\n- * This API provides access to the information related to Vanity URLs\n- * in dotCMS. Vanity URLs are alternate reference paths to\n- * internal or external URL's. Vanity URLs are most commonly used to give\n- * visitors to the website a more user-friendly or memorable way of reaching an\n- * HTML page or File, that might actually live \u201cburied\u201d in a much deeper path.\n+ * This API provides access to the information related to Vanity URLs in dotCMS. Vanity URLs are\n+ * alternate reference paths to internal or external URL's. Vanity URLs are most commonly used to\n+ * give visitors to the website a more user-friendly or memorable way of reaching an HTML page or\n+ * File, that might actually live \u201cburied\u201d in a much deeper path.\n  *\n  * @author oswaldogallango\n  * @version 4.2.0\n  * @since June 12, 2017\n  */\n public interface VanityUrlAPI {\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_INODE = \"8e850645-bb92-4fda-a765-e67063a59be0\";\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_VARNAME = \"Vanityurl\";\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_NAME = \"Vanity URL\";\n+\n+    void validateVanityUrl(Contentlet contentlet);\n \n-    public static final String CACHE_404_VANITY_URL = \"CACHE_404_VANITY_URL\";\n+    Optional<CachedVanityUrl> resolveVanityUrl(String url, Host host, Language language);\n \n-    /**\n-     * Searches and populates the cache for live VanityURLs, each VanityURL found is added into the cache.\n-     * <br>\n-     * Note this method does not uses cache, always does the ES search, the intention of this method\n-     * is mainly to populate the cache with the found data.\n-     *\n-     * @param user The current user\n-     * @return a List of all Cached Vanity URLs contentlets live\n-     */\n-    void initializeVanityURLsCache(final User user);\n+    VanityUrl fromContentlet(Contentlet contentlet);\n \n-    /**\n-     * Return the live version of the Cached vanityurl URL contentlet with the specified URI\n-     *\n-     * @param uri The URI of the vanityurl URL\n-     * @param host The current host\n-     * @param languageId The current language Id\n-     * @param user The current user\n-     * @return the live version of the vanityurl URL contentlet\n-     */\n-    CachedVanityUrl getLiveCachedVanityUrl(final String uri, final Host site, final long languageId,\n-                                           final User user);\n+    void populateAllVanityURLsCache() throws DotDataException;\n \n-    /**\n-     * Convert the contentlet into a Vanity URL object\n-     *\n-     * @param con the contentlet\n-     * @return Vanity URL\n-     */\n-    VanityUrl getVanityUrlFromContentlet(final Contentlet con);\n+    void invalidateVanityUrl(Contentlet contentlet);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3078ad44c742c6f044bcf1de7881a43057321e5"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODA0MzE5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPI.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxMjo0N1rOGkpkag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToxMjo0N1rOGkpkag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA4Mjk4Ng==", "bodyText": "javadoc", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441082986", "createdAt": "2020-06-16T19:12:47Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPI.java", "diffHunk": "@@ -1,73 +1,42 @@\n package com.dotcms.vanityurl.business;\n \n+import java.util.List;\n+import java.util.Optional;\n+\n import com.dotcms.vanityurl.model.CachedVanityUrl;\n import com.dotcms.vanityurl.model.VanityUrl;\n import com.dotmarketing.beans.Host;\n+import com.dotmarketing.exception.DotDataException;\n import com.dotmarketing.portlets.contentlet.model.Contentlet;\n-import com.liferay.portal.model.User;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n \n /**\n- * This API provides access to the information related to Vanity URLs\n- * in dotCMS. Vanity URLs are alternate reference paths to\n- * internal or external URL's. Vanity URLs are most commonly used to give\n- * visitors to the website a more user-friendly or memorable way of reaching an\n- * HTML page or File, that might actually live \u201cburied\u201d in a much deeper path.\n+ * This API provides access to the information related to Vanity URLs in dotCMS. Vanity URLs are\n+ * alternate reference paths to internal or external URL's. Vanity URLs are most commonly used to\n+ * give visitors to the website a more user-friendly or memorable way of reaching an HTML page or\n+ * File, that might actually live \u201cburied\u201d in a much deeper path.\n  *\n  * @author oswaldogallango\n  * @version 4.2.0\n  * @since June 12, 2017\n  */\n public interface VanityUrlAPI {\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_INODE = \"8e850645-bb92-4fda-a765-e67063a59be0\";\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_VARNAME = \"Vanityurl\";\n+    public static final String DEFAULT_VANITY_URL_STRUCTURE_NAME = \"Vanity URL\";\n+\n+    void validateVanityUrl(Contentlet contentlet);\n \n-    public static final String CACHE_404_VANITY_URL = \"CACHE_404_VANITY_URL\";\n+    Optional<CachedVanityUrl> resolveVanityUrl(String url, Host host, Language language);\n \n-    /**\n-     * Searches and populates the cache for live VanityURLs, each VanityURL found is added into the cache.\n-     * <br>\n-     * Note this method does not uses cache, always does the ES search, the intention of this method\n-     * is mainly to populate the cache with the found data.\n-     *\n-     * @param user The current user\n-     * @return a List of all Cached Vanity URLs contentlets live\n-     */\n-    void initializeVanityURLsCache(final User user);\n+    VanityUrl fromContentlet(Contentlet contentlet);\n \n-    /**\n-     * Return the live version of the Cached vanityurl URL contentlet with the specified URI\n-     *\n-     * @param uri The URI of the vanityurl URL\n-     * @param host The current host\n-     * @param languageId The current language Id\n-     * @param user The current user\n-     * @return the live version of the vanityurl URL contentlet\n-     */\n-    CachedVanityUrl getLiveCachedVanityUrl(final String uri, final Host site, final long languageId,\n-                                           final User user);\n+    void populateAllVanityURLsCache() throws DotDataException;\n \n-    /**\n-     * Convert the contentlet into a Vanity URL object\n-     *\n-     * @param con the contentlet\n-     * @return Vanity URL\n-     */\n-    VanityUrl getVanityUrlFromContentlet(final Contentlet con);\n+    void invalidateVanityUrl(Contentlet contentlet);\n \n-    /**\n-     * This method checks that the Vanity Url URI is using a valid regular expression.\n-     *\n-     * @param contentlet The Vanity Url Contentlet\n-     */\n-    void validateVanityUrl(Contentlet contentlet);\n+    List<CachedVanityUrl> findInDb(Host host, Language lang);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3078ad44c742c6f044bcf1de7881a43057321e5"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODYxODkwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest2.txt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMjoyMjowMlrOGkvMnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMjoyMjowMlrOGkvMnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3NTE5Ng==", "bodyText": "Why do you need this txt file?", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441175196", "createdAt": "2020-06-16T22:22:02Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest2.txt", "diffHunk": "@@ -0,0 +1,1488 @@\n+package com.dotcms.vanityurl.business;\n+\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+\n+import java.util.Optional;\n+\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import com.dotcms.business.WrapInTransaction;\n+\n+import com.dotcms.contenttype.model.type.VanityUrlContentType;\n+import com.dotcms.datagen.TestDataUtils;\n+import com.dotcms.datagen.VanityUrlDataGen;\n+import com.dotcms.util.FiltersUtil;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotcms.vanityurl.cache.VanityUrlCache;\n+import com.dotcms.vanityurl.model.CachedVanityUrl;\n+import com.dotcms.vanityurl.model.VanityUrl;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.filters.CMSFilter;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.business.HostAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.contentlet.model.IndexPolicy;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+\n+/**\n+ * This class test the {@link VanityUrlAPI} methods\n+ *\n+ * @author oswaldogallango\n+ * @version 4.2.0\n+ * @since June 22, 2017\n+ */\n+public class VanityUrlAPITest2 {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3078ad44c742c6f044bcf1de7881a43057321e5"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODY0MDU4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/test/java/com/dotcms/util/VanityUrlUtilTest.txt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMjozMToxN1rOGkvZpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMjozMToxN1rOGkvZpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE3ODUzMw==", "bodyText": "why did you rename it to a txt file? do you need it as a a backup?", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441178533", "createdAt": "2020-06-16T22:31:17Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/test/java/com/dotcms/util/VanityUrlUtilTest.txt", "diffHunk": "@@ -115,7 +115,7 @@ public void processExpressions3Test()  {\n         final CachedVanityUrl cachedVanityUrl = new CachedVanityUrl(vanityUrl);\n         final String [] matches = new String[] { \"hello\", \"world\", \"dot\"};\n \n-        final CachedVanityUrl newCachedVanityUrl =\n+        final CachedVanityUrl newCachedVanityUrl = ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3078ad44c742c6f044bcf1de7881a43057321e5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODcwMzM1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPI.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzowMDoxNVrOGkv_yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzowMDoxNVrOGkv_yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4ODI5Ng==", "bodyText": "typo here?", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441188296", "createdAt": "2020-06-16T23:00:15Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPI.java", "diffHunk": "@@ -21,21 +22,57 @@\n  * @since June 12, 2017\n  */\n public interface VanityUrlAPI {\n-    public static final String DEFAULT_VANITY_URL_STRUCTURE_INODE = \"8e850645-bb92-4fda-a765-e67063a59be0\";\n     public static final String DEFAULT_VANITY_URL_STRUCTURE_VARNAME = \"Vanityurl\";\n-    public static final String DEFAULT_VANITY_URL_STRUCTURE_NAME = \"Vanity URL\";\n \n     void validateVanityUrl(Contentlet contentlet);\n \n+    /**\n+     * Resolves a the url based on the url, host and language passed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f530cfe8022796d97a264d1ed78a32ee6192bc"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODcwNDAwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPI.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzowMDozNFrOGkwAMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMzowMDozNFrOGkwAMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4ODQwMw==", "bodyText": "\"If it\" or \"It\" ?", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441188403", "createdAt": "2020-06-16T23:00:34Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPI.java", "diffHunk": "@@ -21,21 +22,57 @@\n  * @since June 12, 2017\n  */\n public interface VanityUrlAPI {\n-    public static final String DEFAULT_VANITY_URL_STRUCTURE_INODE = \"8e850645-bb92-4fda-a765-e67063a59be0\";\n     public static final String DEFAULT_VANITY_URL_STRUCTURE_VARNAME = \"Vanityurl\";\n-    public static final String DEFAULT_VANITY_URL_STRUCTURE_NAME = \"Vanity URL\";\n \n     void validateVanityUrl(Contentlet contentlet);\n \n+    /**\n+     * Resolves a the url based on the url, host and language passed.\n+     * If it has several fallbacks:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58f530cfe8022796d97a264d1ed78a32ee6192bc"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MjY2MTQ5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPIImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDo1NToxM1rOGlXFkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QyMDo1OToyNlrOGlXNyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyODc1NA==", "bodyText": "@erickgonzalez, I think this should use the passed in language, not the default language.", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441828754", "createdAt": "2020-06-17T20:55:13Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPIImpl.java", "diffHunk": "@@ -54,679 +44,248 @@\n  * @since June 12, 2017\n  */\n public class VanityUrlAPIImpl implements VanityUrlAPI {\n-    \n-    private final Set<Integer> allowedActions = new ImmutableSet.Builder<Integer>().add(200).add(301).add(302).build();\n-\n-    public static final String URL_SUFFIX = \"/\";\n-    public static final String LEGACY_CMS_HOME_PAGE = \"/cmsHomePage\";\n-    private final ContentletAPI     contentletAPI;\n-    private final VanityUrlServices vanityUrlServices;\n-    private final LanguageAPI       languageAPI;\n-    private final UserAPI           userAPI;\n-    private final long              defaultLanguageId;\n-    private final User              systemUser;\n-\n-    private static final int CODE_404_VALUE = 404;\n-    private static final VanityMatches VANITY_MATCHES_FALSE =\n-            new VanityMatches(Boolean.FALSE, null);\n-    private static final VanityMatches VANITY_MATCHES_TRUE =\n-            new VanityMatches(Boolean.TRUE, null);\n-\n-\n-    public VanityUrlAPIImpl() throws DotDataException {\n-        this(APILocator.getContentletAPI(),\n-                VanityUrlServices.getInstance(),\n-                APILocator.getLanguageAPI(),\n-                APILocator.getUserAPI());\n-    }\n-\n-    @VisibleForTesting\n-    public VanityUrlAPIImpl(final ContentletAPI contentletAPI,\n-            final VanityUrlServices vanityUrlServices,\n-            final LanguageAPI       languageAPI,\n-            final UserAPI           userAPI) throws DotDataException {\n-\n-        this.contentletAPI     = contentletAPI;\n-        this.vanityUrlServices = vanityUrlServices;\n-        this.languageAPI       = languageAPI;\n-        this.userAPI           = userAPI;\n-        this.defaultLanguageId = languageAPI.getDefaultLanguage()\n-                .getId();\n-        this.systemUser        = userAPI.getSystemUser();\n \n+  private final Set<Integer> allowedActions = new ImmutableSet.Builder<Integer>().add(200).add(301).add(302).build();\n+\n+  private static final String SELECT_LIVE_VANITY_URL_INODES =\n+      \"SELECT cvi.live_inode FROM contentlet c, identifier i, contentlet_version_info cvi, structure s \"\n+          + \" where s.structuretype= 7 and c.structure_inode=s.inode \"\n+          + \" and cvi.live_inode=c.inode and cvi.identifier = i.id  and i.host_inode = ? and cvi.lang =? \";\n+\n+  public static final String   URL_SUFFIX = \"/\";\n+  public static final String   LEGACY_CMS_HOME_PAGE = \"/cmsHomePage\";\n+  private final ContentletAPI  contentletAPI;\n+  private final VanityUrlCache cache;\n+  private final LanguageAPI    languageAPI;\n+  private final boolean        languageFallback = Config.getBooleanProperty(\"DEFAULT_VANITY_URL_TO_DEFAULT_LANGUAGE\", false) ;\n+\n+  public VanityUrlAPIImpl()  {\n+    this(APILocator.getContentletAPI(),\n+        APILocator.getLanguageAPI(), \n+        APILocator.getUserAPI(),\n+        CacheLocator.getVanityURLCache());\n+  }\n+\n+  @VisibleForTesting\n+  public VanityUrlAPIImpl(final ContentletAPI contentletAPI, \n+      final LanguageAPI languageAPI,\n+      final UserAPI userAPI,\n+      final VanityUrlCache cache) {\n+    this.contentletAPI = contentletAPI;\n+    this.languageAPI = languageAPI;\n+    this.cache = cache;\n+   \n+\n+  }\n+\n+  /**\n+   * Searches for all Vanity URLs for a given Site in the system. It goes directly to the database in\n+   * order to avoid retrieving data that has not been updated in the ES index yet. This initialization\n+   * routine will also add Vanity URLs located under System Host.\n+   *\n+   * @param host Site to populate vanity urls\n+   */\n+  private void populateVanityURLsCacheBySite(final Host host) {\n+    if(host==null || host.getIdentifier()==null) {\n+        throw new DotStateException(\"Host cannot be null. Got:\" + host);\n     }\n-\n-    @CloseDBIfOpened\n-    @Override\n-    public void initializeVanityURLsCache(final User user) {\n-        initializeActiveVanityURLsCacheBySiteAndLanguage(null, null);\n+    Logger.info(this.getClass(), \"Populating Vanity URLS for :\" + host.getHostname()); \n+    for (final Language language : languageAPI.getLanguages()) {\n+      cache.putSiteMappings(host, language, findInDb(host, language));\n     }\n+  }\n \n-    /**\n-     * Searches for all Vanity URLs for a given Site in the system. It goes directly to the database in order to\n-     * avoid retrieving data that has not been updated in the ES index yet. This initialization routine will also\n-     * add Vanity URLs located under System Host.\n-     *\n-     * @param siteId     The ID of the Site whose Vanity URLs will be retrieved.\n-     * @param languageId The ID of the language for the Vanity URLs.\n-     * @return A list of VanityURLs\n-     */\n-    private void initializeActiveVanityURLsCacheBySiteAndLanguage(final String siteId, final Long languageId) {\n-        final boolean includeSystemHost = Boolean.TRUE;\n-        try {\n-            final List<Contentlet> contentResults = searchAndPopulate(siteId, languageId, includeSystemHost);\n-            if (null == contentResults || contentResults.isEmpty()) {\n-                // Empty is a valid cache value\n-                this.setEmptyCaches(siteId, languageId, includeSystemHost);\n-                return;\n-            }\n-            final List<VanityUrl> vanityUrls = contentResults.stream()\n-                    .map(this::getVanityUrlFromContentlet)\n-                    .sorted(Comparator.comparing(VanityUrl::getOrder))\n-                    .collect(toImmutableList());\n-            // Add them to caches\n-            this.addSecondaryVanityURLCacheCollection (vanityUrls);\n-            vanityUrls.forEach(this::addToSingleVanityURLCache);\n-             // If a site was sent we need to make sure it was initialized in the cache\n-            if (null != siteId && null != languageId) {\n-                this.checkSiteLanguageVanities\n-                        (siteId, languageId, includeSystemHost);\n-            }\n-        } catch (final Exception e) {\n-            throw new DotRuntimeException(String.format(\"Error searching and populating the Vanity URL from DB for \" +\n-                    \"Site ID '%s', language ID = '%s': %s\", siteId, languageId, e.getMessage()), e);\n-        }\n-    } // initializeActiveVanityURLsCacheBySiteAndLanguage.\n-\n-    /**\n-     * Searches for all Vanity URLs for a given Site in the system <b>without loading data into any of the Vanity URL\n-     * Cache Regions</b>. This initialization routine will also add Vanity URLs located under System Host.\n-     *\n-     * @param siteId     The ID of the Site whose Vanity URLs will be retrieved.\n-     * @param languageId The ID of the language for the Vanity URLs.\n-     *\n-     * @return A list of Vanity URLs read from the data source.\n-     */\n-    private List<CachedVanityUrl> getActiveVanityURLsNoCacheBySiteAndLanguage(final String siteId, final Long languageId) {\n-        final boolean includeSystemHost = Boolean.TRUE;\n-        try {\n-            final List<Contentlet> contentResults = searchAndPopulate(siteId, languageId, includeSystemHost);\n-            final List<VanityUrl> vanityUrls = contentResults.stream()\n-                    .map(this::getVanityUrlFromContentlet)\n-                    .sorted(Comparator.comparing(VanityUrl::getOrder))\n-                    .collect(toImmutableList());\n-            final List<CachedVanityUrl> cachedVanityUrls = new ArrayList<>();\n-            if (UtilMethods.isSet(vanityUrls)) {\n-                // Simulate Vanity URLs coming from cache\n-                for (final VanityUrl vanityUrl : vanityUrls) {\n-                    cachedVanityUrls.add(new CachedVanityUrl(vanityUrl));\n-                }\n-            }\n-            return cachedVanityUrls;\n-        } catch (final Exception e) {\n-            throw new DotRuntimeException(String.format(\"Error searching and populating the Vanity URL from DB for \" +\n-                    \"Site ID '%s', language ID = '%s': %s\", siteId, languageId, e.getMessage()), e);\n-        }\n-    }\n \n-    /**\n-     * Executes a SQL query that will return all the Vanity URLs that belong to a specific Site. This method moved from\n-     * using the ES index to using a SQL query in order to avoid situations where the index was not fully updated when\n-     * reading new data.\n-     *\n-     * @param siteId            The Identifier of the Site whose Vanity URLs will be retrieved.\n-     * @param languageId        The language ID used to created the Vanity URLs.\n-     * @param includeSystemHost If set to {@code true}, the results will include Vanity URLs that were created under\n-     *                          System Host. Otherwise, set to {@code false}.\n-     *\n-     * @return The list of Vanity URLs.\n-     */\n-    @CloseDBIfOpened\n-    private List<Contentlet> searchAndPopulate(final String siteId, final Long languageId, final boolean\n-            includeSystemHost) {\n-        List<Contentlet> contentlets = new ArrayList<>();\n-        final StringBuilder query = new StringBuilder();\n-        query.append(\"SELECT cvi.live_inode FROM contentlet c \");\n-        //c.text2 is the Site Field for Vanity URL Content Type\n-        query.append(\"INNER JOIN identifier i ON c.identifier = i.id AND c.text2 \");\n-        if (includeSystemHost) {\n-            query.append(\"IN ('\" + Host.SYSTEM_HOST + \"', ?) \");\n-        } else {\n-            query.append(\"= ? \");\n-        }\n-        query.append(\"INNER JOIN contentlet_version_info cvi ON c.identifier = cvi.identifier AND c.inode = cvi\" +\n-                \".live_inode \");\n-        query.append(\"WHERE c.language_id = ? AND c.structure_inode IN (SELECT s.inode FROM structure s WHERE s\" +\n-                \".structuretype = ?)\");\n-        try {\n-            final List<Map<String, Object>> vanityUrls = new DotConnect().setSQL(query.toString())\n-                    .addParam(siteId)\n-                    .addParam(languageId)\n-                    .addParam(BaseContentType.VANITY_URL.getType())\n-                    .loadObjectResults();\n-            final List<String> vanityUrlInodes = vanityUrls.stream().map(vanity -> vanity.get(\"live_inode\").toString\n-                    ()).collect(Collectors.toList());\n-            contentlets = this.contentletAPI.findContentlets(vanityUrlInodes);\n-        } catch (final DotDataException e) {\n-            Logger.error(this, String.format(\"An error occurred when retrieving Vanity URLs: siteId=[%s], \" +\n-                    \"languageId=[%s], includeSystemHost=[%s]\", siteId, languageId, includeSystemHost), e);\n-        } catch (final DotSecurityException e) {\n-            Logger.error(this, String.format(\"An error occurred when retrieving Vanity URLs: siteId=[%s], \" +\n-                    \"languageId=[%s], includeSystemHost=[%s]\", siteId, languageId, includeSystemHost), e);\n-        }\n-        return contentlets;\n+  @Override\n+  public void populateAllVanityURLsCache() throws DotDataException {\n+    for (final Host host : Try.of(() -> APILocator.getHostAPI().findAllFromDB(APILocator.systemUser(), false)).getOrElse(ImmutableList.of())) {\n+      populateVanityURLsCacheBySite(host);\n     }\n-\n-    private boolean is404 (final CachedVanityUrl cachedVanityUrl) {\n-\n-        return UtilMethods.isSet(cachedVanityUrl) && VanityUrlAPI.CACHE_404_VANITY_URL\n-                .equals(cachedVanityUrl.getVanityUrlId());\n+    populateVanityURLsCacheBySite(APILocator.getHostAPI().findSystemHost());\n+  }\n+\n+  /**\n+   * Executes a SQL query that will return all the Vanity URLs that belong to a specific Site. This\n+   * method moved from using the ES index to using a SQL query in order to avoid situations where the\n+   * index was not fully updated when reading new data.\n+   *\n+   * @param host The Site whose Vanity URLs will be retrieved.\n+   * @param language The language used to created the Vanity URLs.\n+   *\n+   * @return The list of Vanity URLs.\n+   */\n+  @Override\n+  @CloseDBIfOpened\n+  public List<CachedVanityUrl> findInDb(final Host host, final Language language) {\n+\n+    try {\n+      final List<Map<String, Object>> vanityUrls =\n+          new DotConnect().setSQL(SELECT_LIVE_VANITY_URL_INODES).addParam(host.getIdentifier()).addParam(language.getId()).loadObjectResults();\n+      final List<String> vanityUrlInodes =\n+          vanityUrls.stream().map(vanity -> vanity.get(\"live_inode\").toString()).collect(Collectors.toList());\n+      final List<Contentlet> contentlets = this.contentletAPI.findContentlets(vanityUrlInodes);\n+\n+      return contentlets.stream().map(contentlet -> new CachedVanityUrl(this.fromContentlet(contentlet))).collect(Collectors.toList());\n+\n+    } catch (final Exception e) {\n+      Logger.error(this,\n+          String.format(\"An error occurred when retrieving Vanity URLs: siteId=[%s], \" + \"languageId=[%s], includeSystemHost=[%s]\",\n+              host.getIdentifier(), language.getId()),\n+          e);\n+      throw new DotStateException(e);\n     }\n \n-    @CloseDBIfOpened\n-    @Override\n-    public boolean isVanityUrl(final String url, final Host host, final long languageId) {\n-\n-        final String uri    = url; // not process now for it.\n-        final String siteId = this.getSiteId(host);\n-\n-        // tries first cache.\n-        final CachedVanityUrl cachedVanityUrl =\n-                this.vanityUrlServices\n-                        .getCachedVanityUrlByUri(uri, siteId, languageId);\n-        boolean isVanityURL = !is404(cachedVanityUrl)\n-                && this.patternMatches(cachedVanityUrl, uri).isPatternMatches();\n-\n-        if (!isVanityURL) {\n-\n-            CachedVanityUrl liveCachedVanityUrl =\n-                    this.searchLiveCachedVanityUrlBySiteAndLanguage\n-                            (uri, siteId, languageId);\n-\n-            if (null == liveCachedVanityUrl) {\n-\n-                liveCachedVanityUrl =\n-                        this.getFallback(uri, siteId, languageId, this.systemUser);\n-            }\n+  }\n \n-            isVanityURL =\n-                    !is404(liveCachedVanityUrl);\n \n-            // Still support legacy cmsHomePage\n-            if (URL_SUFFIX.equals(uri) && !isVanityURL) {\n+  \n+  \n+  \n+  private List<CachedVanityUrl> load(final Host host, final Language language) {\n \n-                liveCachedVanityUrl =\n-                        this.getLiveCachedVanityUrl\n-                                (LEGACY_CMS_HOME_PAGE, host, languageId, this.systemUser);\n-                isVanityURL = UtilMethods.isSet(liveCachedVanityUrl)\n-                        && !VanityUrlAPI.CACHE_404_VANITY_URL\n-                            .equals(liveCachedVanityUrl.getVanityUrlId());\n-            }\n+    List<CachedVanityUrl> cachedVanities = cache.getSiteMappings(host, language);\n+    if(cachedVanities == null) {\n+      synchronized (VanityUrlAPI.class) {\n+        cachedVanities = cache.getSiteMappings(host, language);\n+        if(cachedVanities==null) {\n+          cachedVanities = findInDb(host, language);\n+          cache.putSiteMappings(host, language, cachedVanities);\n         }\n-\n-        return isVanityURL;\n-    } // isVanityUrl\n-\n-    @CloseDBIfOpened\n-    @Override\n-    public VanityUrl getVanityUrlFromContentlet(final Contentlet contentlet) {\n-\n-        if (contentlet != null) {\n-            try {\n-                if (!contentlet.isVanityUrl()) {\n-                    throw new DotStateException(\n-                            \"Contentlet : \" + contentlet.getInode() + \" is not a Vanity Url\");\n-                }\n-            } catch (DotDataException | DotSecurityException e) {\n-                throw new DotStateException(\n-                        \"Contentlet : \" + contentlet.getInode() + \" is not a Vanity Url\", e);\n-            }\n-        } else {\n-            throw new DotStateException(\"Contentlet is null\");\n-        }\n-\n-        final DefaultVanityUrl vanityUrl = new DefaultVanityUrl();\n-        vanityUrl.setContentTypeId(contentlet.getContentTypeId());\n-        try {\n-            this.contentletAPI.copyProperties(vanityUrl, contentlet.getMap());\n-        } catch (Exception e) {\n-            throw new DotStateException(\"Vanity Url Copy Failed\", e);\n-        }\n-        vanityUrl.setHost(contentlet.getHost());\n-        vanityUrl.setFolder(contentlet.getFolder());\n-\n-        return vanityUrl;\n-    } // getVanityUrlFromContentlet.\n-\n-    /**\n-     * Add the Vanity URL to the vanityURLCache, without affecting any secondary cache.\n-     *\n-     * @param vanityUrl The vanityurl URL object\n-     */\n-    private void addToSingleVanityURLCache(final VanityUrl vanityUrl) {\n-        try {\n-            if (vanityUrl.isLive()) {\n-                vanityUrlServices.addSingleCache(vanityUrl);\n-            } else {\n-                vanityUrlServices.invalidateVanityUrl(vanityUrl);\n-            }\n-        } catch (DotDataException | DotRuntimeException | DotSecurityException e) {\n-            Logger.error(this,\n-                    \"Error trying to add Vanity URL identifier:\" + vanityUrl.getIdentifier()\n-                            + \" to VanityURLCache\", e);\n-        }\n-    } // addToSingleVanityURLCache.\n-\n-    /**\n-     * Add a 404 Vanity URL to the vanityURLCache\n-     *\n-     * @param siteId The current site Id\n-     * @param uri The current URI\n-     * @param languageId The current language Id\n-     */\n-    private void add404URIToCache(final String siteId,\n-                                  final String uri,\n-                                  final long languageId) {\n-\n-        final VanityUrl cache404VanityUrl = new DefaultVanityUrl();\n-        cache404VanityUrl.setInode(VanityUrlAPI.CACHE_404_VANITY_URL);\n-        cache404VanityUrl.setIdentifier(VanityUrlAPI.CACHE_404_VANITY_URL);\n-        cache404VanityUrl.setAction(CODE_404_VALUE);\n-        cache404VanityUrl.setLanguageId(languageId);\n-        cache404VanityUrl.setURI(uri);\n-        cache404VanityUrl.setSite(siteId);\n-        cache404VanityUrl.setOrder(0);\n-\n-        this.vanityUrlServices.updateCache(cache404VanityUrl);\n+      }\n     }\n \n-    private String getSiteId (final Host site) {\n-\n-        return\n-            (null != site && !site.isSystemHost())?\n-                        site.getIdentifier():Host.SYSTEM_HOST;\n-\n-    } // getSiteId.\n-\n-    @CloseDBIfOpened\n-    @Override\n-    public CachedVanityUrl getLiveCachedVanityUrl(final String uri, final Host site,\n-            final long languageId, final User user) {\n-\n-        final String siteId = this.getSiteId(site);\n-\n-        //First lets try with the cache\n-        CachedVanityUrl result = vanityUrlServices\n-                .getCachedVanityUrlByUri(uri, siteId, languageId);\n-\n-        final VanityMatches matches =\n-                this.patternMatches(result, uri);\n-        if (matches.isPatternMatches()) {\n-\n-            return processExpressions(result, matches.getGroups());\n-        } else {\n-            //Search for the URI in the vanityURL cached by site and language Ids\n-            result =\n-                    this.searchLiveCachedVanityUrlBySiteAndLanguage\n-                            (uri, siteId, languageId);\n-        }\n-\n-        return (null == result)?\n-                this.getFallback(uri, siteId, languageId, this.systemUser):result;\n-    } // getLiveCachedVanityUrl.\n-\n-    private CachedVanityUrl getFallback (final String uri, final String siteId,\n-                                         final long languageId, final User user) {\n-\n-        CachedVanityUrl result = null;\n-\n-        try {\n-\n-            //Search for the list of ContentTypes of type VanityURL\n-            final List<ContentType> vanityUrlContentTypes = APILocator.getContentTypeAPI(user)\n-                    .findByType(BaseContentType.VANITY_URL);\n-\n-            //Verify if this Content Type has a Multilinguable fallback\n-            if (!vanityUrlContentTypes.isEmpty()\n-                    && (this.defaultLanguageId != languageId)\n-                    && ((VanityUrlContentType) vanityUrlContentTypes.get(0)).fallback()) {\n-\n-                //if the fallback is set then is going to try to get it by the default language\n-                result = this.vanityUrlServices\n-                        .getCachedVanityUrlByUri(uri, siteId, this.defaultLanguageId);\n-\n-                final VanityMatches matches = this.patternMatches(result, uri);\n-                if (matches.isPatternMatches()) {\n-\n-                    return processExpressions(result, matches.getGroups());\n-                } else {\n-                    //Search for the URI in the vanityURL cached by site and default language Ids\n-                    result = searchLiveCachedVanityUrlBySiteAndLanguage(uri, siteId,\n-                            this.defaultLanguageId);\n-                }\n-            }\n-\n-        } catch (DotDataException | DotSecurityException e) {\n-            Logger.error(this, \"Error searching for Vanity URL by URI\", e);\n-        }\n-\n-        if (result == null) {\n-            //Add 404 to cache\n-            this.add404URIToCache(siteId, uri, languageId);\n-            result = this.vanityUrlServices\n-                    .getCachedVanityUrlByUri(uri, siteId, languageId);\n-        }\n-\n-        return result;\n-    } // getFallback.\n-\n-    /**\n-     * Validate if the CachedVanityUrl pattern matches the uri\n-     *\n-     * @param cachedVanityUrl The CachedVanityUrl\n-     * @param uri The current uri\n-     * @return true if the CachedVanityUrl match, false if not\n-     */\n-    private VanityMatches patternMatches(final CachedVanityUrl cachedVanityUrl,\n-                                         final String uri) {\n-        if (cachedVanityUrl != null) {\n-\n-            final Matcher matcher = cachedVanityUrl.getPattern().matcher(uri);\n-            if (matcher.matches()) {\n-                if (matcher.groupCount() > 0) {\n-\n-                    final String[] matches = new String[matcher.groupCount()];\n-                    rangeClosed(1, matcher.groupCount())\n-                            .forEach(i -> matches[i - 1] = matcher.group(i));\n-                    return new VanityMatches(Boolean.TRUE, matches);\n-                }\n-\n-                return VANITY_MATCHES_TRUE;\n-            }\n-        }\n-\n-        return VANITY_MATCHES_FALSE;\n-    } // patternMatches.\n-\n-    /**\n-     * Search CachedVanity Url checking if the Uri is in the Site Id and language Id cache\n-     *\n-     * @param uri The current uri\n-     * @param siteId the current site Id\n-     * @param languageId the current language Id\n-     * @return a CachedVanityUrl object\n-     */\n-    private CachedVanityUrl searchLiveCachedVanityUrlBySiteAndLanguage(final String uri,\n-            final String siteId, final long languageId) {\n-\n-        CachedVanityUrl result = null;\n-\n-        //Get the list of site cached Vanities URLs\n-        List<CachedVanityUrl> cachedVanityUrls =\n-                this.getVanityUrlBySiteAndLanguageFromCache\n-                        (siteId, languageId,true);\n-\n-        if (null == cachedVanityUrls) {\n-\n-            synchronized (VanityUrlAPIImpl.class) {\n-\n-                cachedVanityUrls =\n-                        this.getVanityUrlBySiteAndLanguageFromCache\n-                            (siteId, languageId, true);\n-\n-                if (null == cachedVanityUrls) {\n-\n-                    //Initialize the Cached Vanity URL cache if is null\n-                    this.initializeActiveVanityURLsCacheBySiteAndLanguage\n-                            (siteId, languageId);\n-\n-                    //Get the list of site cached Vanities URLs\n-                    cachedVanityUrls =\n-                            this.getVanityUrlBySiteAndLanguageFromCache\n-                                    (siteId, languageId,true);\n-                    if (!UtilMethods.isSet(cachedVanityUrls)) {\n-                        // If this point is reached, there's probably an issue with the Vanity URL Caches. So, just read\n-                        // directly from the data source WITHOUT reading or loading from any cache\n-                        cachedVanityUrls = this.getActiveVanityURLsNoCacheBySiteAndLanguage(siteId, languageId);\n-                    }\n-                }\n-            }\n-        }\n-\n-        VanityMatches matches = null;\n-        if (null != cachedVanityUrls) {\n-            //Validates if onw of the site cachedVanityUrls matches the uri\n-            for (CachedVanityUrl vanity : cachedVanityUrls) {\n-\n-                matches = this.patternMatches(vanity, uri);\n-                if (matches.isPatternMatches()) {\n-\n-                    result = processExpressions(vanity, matches.getGroups());\n-                    break;\n-                }\n-            }\n-        }\n-\n-        /*\n-        At this point we already found and saved in cache the VanityURL that matches with the given\n-        URL but adding a new VanityURL to the cache for the completed requested URL\n-        and not just the regex used can save us time.\n-         */\n-        if (null != result && !result.getUrl().equals(uri)) {\n-            this.vanityUrlServices.updateCache(new CachedVanityUrl(result, uri));\n-        }\n-\n-        return result;\n-    } // searchLiveCachedVanityUrlBySiteAndLanguage.\n-\n-    private void checkSiteLanguageVanities(final String siteId,\n-                                           final Long languageId,\n-                                           final Boolean includedSystemHostOnLuceneQuery) {\n-\n-        if (null == this.vanityUrlServices.getCachedVanityUrlList(siteId, languageId)) {\n-\n-            this.vanityUrlServices.setCachedVanityUrlList(siteId, languageId, Collections.EMPTY_LIST);\n-        }\n-\n-        if (includedSystemHostOnLuceneQuery && !Host.SYSTEM_HOST.equals(siteId) &&\n-                null == this.vanityUrlServices.getCachedVanityUrlList(Host.SYSTEM_HOST, languageId)) {\n-\n-            this.vanityUrlServices.setCachedVanityUrlList(Host.SYSTEM_HOST, languageId, Collections.EMPTY_LIST);\n-        }\n-    } // checkSiteLanguageVanities.\n-\n-    private void setEmptyCaches(final String siteId,\n-                                final Long languageId,\n-                                final Boolean includedSystemHostOnLuceneQuery) {\n-\n-        if (null != siteId && null != languageId) {\n-            this.vanityUrlServices.setCachedVanityUrlList(\n-                    siteId, languageId,\n-                    Collections.EMPTY_LIST);\n-\n-            if (includedSystemHostOnLuceneQuery && !Host.SYSTEM_HOST.equals(siteId)) {\n-                this.vanityUrlServices.setCachedVanityUrlList(\n-                        Host.SYSTEM_HOST, languageId,\n-                        Collections.EMPTY_LIST);\n-            }\n-        }\n-    } // setEmptyCaches.\n-\n-    private void addSecondaryVanityURLCacheCollection(final List<VanityUrl> vanityUrls) {\n-\n-        final Map<SiteLanguageKey, ImmutableList.Builder<CachedVanityUrl>> vanityPerSiteLanguageMap\n-                = map();\n-        SiteLanguageKey key;\n-\n-        for (final VanityUrl vanityUrl : vanityUrls) {\n-\n-            key = new SiteLanguageKey(vanityUrl.getSite(), vanityUrl.getLanguageId());\n-            if (!vanityPerSiteLanguageMap.containsKey(key)) {\n-\n-                vanityPerSiteLanguageMap.put(key, new ImmutableList.Builder());\n-            }\n-\n-            vanityPerSiteLanguageMap.get(key).add(new CachedVanityUrl(vanityUrl));\n-        }\n-\n-        // when the site + lang list is gonna be override, the main cache items should be clean too\n-        vanityPerSiteLanguageMap.keySet().forEach(this::cleanCurrentVanityUrlsPerSite);\n-\n-        vanityPerSiteLanguageMap.forEach( (k, vanityUrlBuilder) ->\n-                    this.vanityUrlServices.setCachedVanityUrlList (k.hostId(), k.languageId(), vanityUrlBuilder.build()));\n-    } // addSecondaryVanityURLCacheCollection.\n-\n-    private void cleanCurrentVanityUrlsPerSite(final SiteLanguageKey siteLanguageKey) {\n-\n-        final List<CachedVanityUrl> cachedVanityUrls = this.vanityUrlServices.getCachedVanityUrlList\n-                (siteLanguageKey.hostId(), siteLanguageKey.languageId());\n+    return cachedVanities;\n+  }\n+  \n \n-        if (null != cachedVanityUrls) {\n+  \n+  @CloseDBIfOpened\n+  @Override\n+  public Optional<CachedVanityUrl> resolveVanityUrl(final String url, final Host host, final Language language) {\n \n-            for (final CachedVanityUrl cachedVanityUrl : cachedVanityUrls) {\n \n-                CacheLocator.getVanityURLCache().remove(new CacheVanityKey(\n-                        cachedVanityUrl.getSiteId(),\n-                        cachedVanityUrl.getLanguageId(),\n-                        cachedVanityUrl.getUrl()\n-                ).toString());\n-            }\n-        }\n+    // 404 short circuit\n+    final Optional<CachedVanityUrl> shortCircuit = cache.getDirectMapping(url, host, language);\n+    if(shortCircuit!=null) {\n+        return shortCircuit;\n     }\n \n-    @CloseDBIfOpened\n-    @Override\n-    public void validateVanityUrl(final Contentlet contentlet) {\n+    // tries specific site, language and url\n+    Optional<CachedVanityUrl> matched = load(host, language).parallelStream()\n+            .filter(cachedVanityUrl ->\n+                    cachedVanityUrl.url.equalsIgnoreCase(url)).findAny();\n \n-        final User user = getUser(contentlet);\n-        Language language =\n-                APILocator.getLanguageAPI().getLanguage(user.getLanguageId());\n+    // tries specific site, language and pattern\n+    if(!matched.isPresent()) {\n+      matched = load(host, language).parallelStream()\n+              .filter(cachedVanityUrl ->\n+                      cachedVanityUrl.pattern.matcher(url).matches()).findAny();\n+    }\n \n-        language = (null == language ? APILocator.getLanguageAPI().getDefaultLanguage() : language);\n+    \n+    // try language fallback\n+    if (!matched.isPresent()  && !languageAPI.getDefaultLanguage().equals(language) && languageFallback) {\n \n-        // check fields\n-        checkMissingField(contentlet, language, VanityUrlContentType.ACTION_FIELD_VAR);\n-        checkMissingField(contentlet, language, VanityUrlContentType.URI_FIELD_VAR);\n+      matched = resolveVanityUrl(url, host, languageAPI.getDefaultLanguage());\n+    }\n+    \n+    // tries SYSTEM_HOST\n+    if (!matched.isPresent() && !APILocator.systemHost().equals(host)) {\n \n-        final Integer action     =\n-                (int)contentlet.getLongProperty(VanityUrlContentType.ACTION_FIELD_VAR);\n-        final String uri         =\n-                contentlet.getStringProperty(VanityUrlContentType.URI_FIELD_VAR);\n+        matched = resolveVanityUrl(url, APILocator.systemHost(), languageAPI.getDefaultLanguage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f525cc08b29ea13f9c097c818e918937e62741ad"}, "originalPosition": 751}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgzMDg1Ng==", "bodyText": "done", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441830856", "createdAt": "2020-06-17T20:59:26Z", "author": {"login": "erickgonzalez"}, "path": "dotCMS/src/main/java/com/dotcms/vanityurl/business/VanityUrlAPIImpl.java", "diffHunk": "@@ -54,679 +44,248 @@\n  * @since June 12, 2017\n  */\n public class VanityUrlAPIImpl implements VanityUrlAPI {\n-    \n-    private final Set<Integer> allowedActions = new ImmutableSet.Builder<Integer>().add(200).add(301).add(302).build();\n-\n-    public static final String URL_SUFFIX = \"/\";\n-    public static final String LEGACY_CMS_HOME_PAGE = \"/cmsHomePage\";\n-    private final ContentletAPI     contentletAPI;\n-    private final VanityUrlServices vanityUrlServices;\n-    private final LanguageAPI       languageAPI;\n-    private final UserAPI           userAPI;\n-    private final long              defaultLanguageId;\n-    private final User              systemUser;\n-\n-    private static final int CODE_404_VALUE = 404;\n-    private static final VanityMatches VANITY_MATCHES_FALSE =\n-            new VanityMatches(Boolean.FALSE, null);\n-    private static final VanityMatches VANITY_MATCHES_TRUE =\n-            new VanityMatches(Boolean.TRUE, null);\n-\n-\n-    public VanityUrlAPIImpl() throws DotDataException {\n-        this(APILocator.getContentletAPI(),\n-                VanityUrlServices.getInstance(),\n-                APILocator.getLanguageAPI(),\n-                APILocator.getUserAPI());\n-    }\n-\n-    @VisibleForTesting\n-    public VanityUrlAPIImpl(final ContentletAPI contentletAPI,\n-            final VanityUrlServices vanityUrlServices,\n-            final LanguageAPI       languageAPI,\n-            final UserAPI           userAPI) throws DotDataException {\n-\n-        this.contentletAPI     = contentletAPI;\n-        this.vanityUrlServices = vanityUrlServices;\n-        this.languageAPI       = languageAPI;\n-        this.userAPI           = userAPI;\n-        this.defaultLanguageId = languageAPI.getDefaultLanguage()\n-                .getId();\n-        this.systemUser        = userAPI.getSystemUser();\n \n+  private final Set<Integer> allowedActions = new ImmutableSet.Builder<Integer>().add(200).add(301).add(302).build();\n+\n+  private static final String SELECT_LIVE_VANITY_URL_INODES =\n+      \"SELECT cvi.live_inode FROM contentlet c, identifier i, contentlet_version_info cvi, structure s \"\n+          + \" where s.structuretype= 7 and c.structure_inode=s.inode \"\n+          + \" and cvi.live_inode=c.inode and cvi.identifier = i.id  and i.host_inode = ? and cvi.lang =? \";\n+\n+  public static final String   URL_SUFFIX = \"/\";\n+  public static final String   LEGACY_CMS_HOME_PAGE = \"/cmsHomePage\";\n+  private final ContentletAPI  contentletAPI;\n+  private final VanityUrlCache cache;\n+  private final LanguageAPI    languageAPI;\n+  private final boolean        languageFallback = Config.getBooleanProperty(\"DEFAULT_VANITY_URL_TO_DEFAULT_LANGUAGE\", false) ;\n+\n+  public VanityUrlAPIImpl()  {\n+    this(APILocator.getContentletAPI(),\n+        APILocator.getLanguageAPI(), \n+        APILocator.getUserAPI(),\n+        CacheLocator.getVanityURLCache());\n+  }\n+\n+  @VisibleForTesting\n+  public VanityUrlAPIImpl(final ContentletAPI contentletAPI, \n+      final LanguageAPI languageAPI,\n+      final UserAPI userAPI,\n+      final VanityUrlCache cache) {\n+    this.contentletAPI = contentletAPI;\n+    this.languageAPI = languageAPI;\n+    this.cache = cache;\n+   \n+\n+  }\n+\n+  /**\n+   * Searches for all Vanity URLs for a given Site in the system. It goes directly to the database in\n+   * order to avoid retrieving data that has not been updated in the ES index yet. This initialization\n+   * routine will also add Vanity URLs located under System Host.\n+   *\n+   * @param host Site to populate vanity urls\n+   */\n+  private void populateVanityURLsCacheBySite(final Host host) {\n+    if(host==null || host.getIdentifier()==null) {\n+        throw new DotStateException(\"Host cannot be null. Got:\" + host);\n     }\n-\n-    @CloseDBIfOpened\n-    @Override\n-    public void initializeVanityURLsCache(final User user) {\n-        initializeActiveVanityURLsCacheBySiteAndLanguage(null, null);\n+    Logger.info(this.getClass(), \"Populating Vanity URLS for :\" + host.getHostname()); \n+    for (final Language language : languageAPI.getLanguages()) {\n+      cache.putSiteMappings(host, language, findInDb(host, language));\n     }\n+  }\n \n-    /**\n-     * Searches for all Vanity URLs for a given Site in the system. It goes directly to the database in order to\n-     * avoid retrieving data that has not been updated in the ES index yet. This initialization routine will also\n-     * add Vanity URLs located under System Host.\n-     *\n-     * @param siteId     The ID of the Site whose Vanity URLs will be retrieved.\n-     * @param languageId The ID of the language for the Vanity URLs.\n-     * @return A list of VanityURLs\n-     */\n-    private void initializeActiveVanityURLsCacheBySiteAndLanguage(final String siteId, final Long languageId) {\n-        final boolean includeSystemHost = Boolean.TRUE;\n-        try {\n-            final List<Contentlet> contentResults = searchAndPopulate(siteId, languageId, includeSystemHost);\n-            if (null == contentResults || contentResults.isEmpty()) {\n-                // Empty is a valid cache value\n-                this.setEmptyCaches(siteId, languageId, includeSystemHost);\n-                return;\n-            }\n-            final List<VanityUrl> vanityUrls = contentResults.stream()\n-                    .map(this::getVanityUrlFromContentlet)\n-                    .sorted(Comparator.comparing(VanityUrl::getOrder))\n-                    .collect(toImmutableList());\n-            // Add them to caches\n-            this.addSecondaryVanityURLCacheCollection (vanityUrls);\n-            vanityUrls.forEach(this::addToSingleVanityURLCache);\n-             // If a site was sent we need to make sure it was initialized in the cache\n-            if (null != siteId && null != languageId) {\n-                this.checkSiteLanguageVanities\n-                        (siteId, languageId, includeSystemHost);\n-            }\n-        } catch (final Exception e) {\n-            throw new DotRuntimeException(String.format(\"Error searching and populating the Vanity URL from DB for \" +\n-                    \"Site ID '%s', language ID = '%s': %s\", siteId, languageId, e.getMessage()), e);\n-        }\n-    } // initializeActiveVanityURLsCacheBySiteAndLanguage.\n-\n-    /**\n-     * Searches for all Vanity URLs for a given Site in the system <b>without loading data into any of the Vanity URL\n-     * Cache Regions</b>. This initialization routine will also add Vanity URLs located under System Host.\n-     *\n-     * @param siteId     The ID of the Site whose Vanity URLs will be retrieved.\n-     * @param languageId The ID of the language for the Vanity URLs.\n-     *\n-     * @return A list of Vanity URLs read from the data source.\n-     */\n-    private List<CachedVanityUrl> getActiveVanityURLsNoCacheBySiteAndLanguage(final String siteId, final Long languageId) {\n-        final boolean includeSystemHost = Boolean.TRUE;\n-        try {\n-            final List<Contentlet> contentResults = searchAndPopulate(siteId, languageId, includeSystemHost);\n-            final List<VanityUrl> vanityUrls = contentResults.stream()\n-                    .map(this::getVanityUrlFromContentlet)\n-                    .sorted(Comparator.comparing(VanityUrl::getOrder))\n-                    .collect(toImmutableList());\n-            final List<CachedVanityUrl> cachedVanityUrls = new ArrayList<>();\n-            if (UtilMethods.isSet(vanityUrls)) {\n-                // Simulate Vanity URLs coming from cache\n-                for (final VanityUrl vanityUrl : vanityUrls) {\n-                    cachedVanityUrls.add(new CachedVanityUrl(vanityUrl));\n-                }\n-            }\n-            return cachedVanityUrls;\n-        } catch (final Exception e) {\n-            throw new DotRuntimeException(String.format(\"Error searching and populating the Vanity URL from DB for \" +\n-                    \"Site ID '%s', language ID = '%s': %s\", siteId, languageId, e.getMessage()), e);\n-        }\n-    }\n \n-    /**\n-     * Executes a SQL query that will return all the Vanity URLs that belong to a specific Site. This method moved from\n-     * using the ES index to using a SQL query in order to avoid situations where the index was not fully updated when\n-     * reading new data.\n-     *\n-     * @param siteId            The Identifier of the Site whose Vanity URLs will be retrieved.\n-     * @param languageId        The language ID used to created the Vanity URLs.\n-     * @param includeSystemHost If set to {@code true}, the results will include Vanity URLs that were created under\n-     *                          System Host. Otherwise, set to {@code false}.\n-     *\n-     * @return The list of Vanity URLs.\n-     */\n-    @CloseDBIfOpened\n-    private List<Contentlet> searchAndPopulate(final String siteId, final Long languageId, final boolean\n-            includeSystemHost) {\n-        List<Contentlet> contentlets = new ArrayList<>();\n-        final StringBuilder query = new StringBuilder();\n-        query.append(\"SELECT cvi.live_inode FROM contentlet c \");\n-        //c.text2 is the Site Field for Vanity URL Content Type\n-        query.append(\"INNER JOIN identifier i ON c.identifier = i.id AND c.text2 \");\n-        if (includeSystemHost) {\n-            query.append(\"IN ('\" + Host.SYSTEM_HOST + \"', ?) \");\n-        } else {\n-            query.append(\"= ? \");\n-        }\n-        query.append(\"INNER JOIN contentlet_version_info cvi ON c.identifier = cvi.identifier AND c.inode = cvi\" +\n-                \".live_inode \");\n-        query.append(\"WHERE c.language_id = ? AND c.structure_inode IN (SELECT s.inode FROM structure s WHERE s\" +\n-                \".structuretype = ?)\");\n-        try {\n-            final List<Map<String, Object>> vanityUrls = new DotConnect().setSQL(query.toString())\n-                    .addParam(siteId)\n-                    .addParam(languageId)\n-                    .addParam(BaseContentType.VANITY_URL.getType())\n-                    .loadObjectResults();\n-            final List<String> vanityUrlInodes = vanityUrls.stream().map(vanity -> vanity.get(\"live_inode\").toString\n-                    ()).collect(Collectors.toList());\n-            contentlets = this.contentletAPI.findContentlets(vanityUrlInodes);\n-        } catch (final DotDataException e) {\n-            Logger.error(this, String.format(\"An error occurred when retrieving Vanity URLs: siteId=[%s], \" +\n-                    \"languageId=[%s], includeSystemHost=[%s]\", siteId, languageId, includeSystemHost), e);\n-        } catch (final DotSecurityException e) {\n-            Logger.error(this, String.format(\"An error occurred when retrieving Vanity URLs: siteId=[%s], \" +\n-                    \"languageId=[%s], includeSystemHost=[%s]\", siteId, languageId, includeSystemHost), e);\n-        }\n-        return contentlets;\n+  @Override\n+  public void populateAllVanityURLsCache() throws DotDataException {\n+    for (final Host host : Try.of(() -> APILocator.getHostAPI().findAllFromDB(APILocator.systemUser(), false)).getOrElse(ImmutableList.of())) {\n+      populateVanityURLsCacheBySite(host);\n     }\n-\n-    private boolean is404 (final CachedVanityUrl cachedVanityUrl) {\n-\n-        return UtilMethods.isSet(cachedVanityUrl) && VanityUrlAPI.CACHE_404_VANITY_URL\n-                .equals(cachedVanityUrl.getVanityUrlId());\n+    populateVanityURLsCacheBySite(APILocator.getHostAPI().findSystemHost());\n+  }\n+\n+  /**\n+   * Executes a SQL query that will return all the Vanity URLs that belong to a specific Site. This\n+   * method moved from using the ES index to using a SQL query in order to avoid situations where the\n+   * index was not fully updated when reading new data.\n+   *\n+   * @param host The Site whose Vanity URLs will be retrieved.\n+   * @param language The language used to created the Vanity URLs.\n+   *\n+   * @return The list of Vanity URLs.\n+   */\n+  @Override\n+  @CloseDBIfOpened\n+  public List<CachedVanityUrl> findInDb(final Host host, final Language language) {\n+\n+    try {\n+      final List<Map<String, Object>> vanityUrls =\n+          new DotConnect().setSQL(SELECT_LIVE_VANITY_URL_INODES).addParam(host.getIdentifier()).addParam(language.getId()).loadObjectResults();\n+      final List<String> vanityUrlInodes =\n+          vanityUrls.stream().map(vanity -> vanity.get(\"live_inode\").toString()).collect(Collectors.toList());\n+      final List<Contentlet> contentlets = this.contentletAPI.findContentlets(vanityUrlInodes);\n+\n+      return contentlets.stream().map(contentlet -> new CachedVanityUrl(this.fromContentlet(contentlet))).collect(Collectors.toList());\n+\n+    } catch (final Exception e) {\n+      Logger.error(this,\n+          String.format(\"An error occurred when retrieving Vanity URLs: siteId=[%s], \" + \"languageId=[%s], includeSystemHost=[%s]\",\n+              host.getIdentifier(), language.getId()),\n+          e);\n+      throw new DotStateException(e);\n     }\n \n-    @CloseDBIfOpened\n-    @Override\n-    public boolean isVanityUrl(final String url, final Host host, final long languageId) {\n-\n-        final String uri    = url; // not process now for it.\n-        final String siteId = this.getSiteId(host);\n-\n-        // tries first cache.\n-        final CachedVanityUrl cachedVanityUrl =\n-                this.vanityUrlServices\n-                        .getCachedVanityUrlByUri(uri, siteId, languageId);\n-        boolean isVanityURL = !is404(cachedVanityUrl)\n-                && this.patternMatches(cachedVanityUrl, uri).isPatternMatches();\n-\n-        if (!isVanityURL) {\n-\n-            CachedVanityUrl liveCachedVanityUrl =\n-                    this.searchLiveCachedVanityUrlBySiteAndLanguage\n-                            (uri, siteId, languageId);\n-\n-            if (null == liveCachedVanityUrl) {\n-\n-                liveCachedVanityUrl =\n-                        this.getFallback(uri, siteId, languageId, this.systemUser);\n-            }\n+  }\n \n-            isVanityURL =\n-                    !is404(liveCachedVanityUrl);\n \n-            // Still support legacy cmsHomePage\n-            if (URL_SUFFIX.equals(uri) && !isVanityURL) {\n+  \n+  \n+  \n+  private List<CachedVanityUrl> load(final Host host, final Language language) {\n \n-                liveCachedVanityUrl =\n-                        this.getLiveCachedVanityUrl\n-                                (LEGACY_CMS_HOME_PAGE, host, languageId, this.systemUser);\n-                isVanityURL = UtilMethods.isSet(liveCachedVanityUrl)\n-                        && !VanityUrlAPI.CACHE_404_VANITY_URL\n-                            .equals(liveCachedVanityUrl.getVanityUrlId());\n-            }\n+    List<CachedVanityUrl> cachedVanities = cache.getSiteMappings(host, language);\n+    if(cachedVanities == null) {\n+      synchronized (VanityUrlAPI.class) {\n+        cachedVanities = cache.getSiteMappings(host, language);\n+        if(cachedVanities==null) {\n+          cachedVanities = findInDb(host, language);\n+          cache.putSiteMappings(host, language, cachedVanities);\n         }\n-\n-        return isVanityURL;\n-    } // isVanityUrl\n-\n-    @CloseDBIfOpened\n-    @Override\n-    public VanityUrl getVanityUrlFromContentlet(final Contentlet contentlet) {\n-\n-        if (contentlet != null) {\n-            try {\n-                if (!contentlet.isVanityUrl()) {\n-                    throw new DotStateException(\n-                            \"Contentlet : \" + contentlet.getInode() + \" is not a Vanity Url\");\n-                }\n-            } catch (DotDataException | DotSecurityException e) {\n-                throw new DotStateException(\n-                        \"Contentlet : \" + contentlet.getInode() + \" is not a Vanity Url\", e);\n-            }\n-        } else {\n-            throw new DotStateException(\"Contentlet is null\");\n-        }\n-\n-        final DefaultVanityUrl vanityUrl = new DefaultVanityUrl();\n-        vanityUrl.setContentTypeId(contentlet.getContentTypeId());\n-        try {\n-            this.contentletAPI.copyProperties(vanityUrl, contentlet.getMap());\n-        } catch (Exception e) {\n-            throw new DotStateException(\"Vanity Url Copy Failed\", e);\n-        }\n-        vanityUrl.setHost(contentlet.getHost());\n-        vanityUrl.setFolder(contentlet.getFolder());\n-\n-        return vanityUrl;\n-    } // getVanityUrlFromContentlet.\n-\n-    /**\n-     * Add the Vanity URL to the vanityURLCache, without affecting any secondary cache.\n-     *\n-     * @param vanityUrl The vanityurl URL object\n-     */\n-    private void addToSingleVanityURLCache(final VanityUrl vanityUrl) {\n-        try {\n-            if (vanityUrl.isLive()) {\n-                vanityUrlServices.addSingleCache(vanityUrl);\n-            } else {\n-                vanityUrlServices.invalidateVanityUrl(vanityUrl);\n-            }\n-        } catch (DotDataException | DotRuntimeException | DotSecurityException e) {\n-            Logger.error(this,\n-                    \"Error trying to add Vanity URL identifier:\" + vanityUrl.getIdentifier()\n-                            + \" to VanityURLCache\", e);\n-        }\n-    } // addToSingleVanityURLCache.\n-\n-    /**\n-     * Add a 404 Vanity URL to the vanityURLCache\n-     *\n-     * @param siteId The current site Id\n-     * @param uri The current URI\n-     * @param languageId The current language Id\n-     */\n-    private void add404URIToCache(final String siteId,\n-                                  final String uri,\n-                                  final long languageId) {\n-\n-        final VanityUrl cache404VanityUrl = new DefaultVanityUrl();\n-        cache404VanityUrl.setInode(VanityUrlAPI.CACHE_404_VANITY_URL);\n-        cache404VanityUrl.setIdentifier(VanityUrlAPI.CACHE_404_VANITY_URL);\n-        cache404VanityUrl.setAction(CODE_404_VALUE);\n-        cache404VanityUrl.setLanguageId(languageId);\n-        cache404VanityUrl.setURI(uri);\n-        cache404VanityUrl.setSite(siteId);\n-        cache404VanityUrl.setOrder(0);\n-\n-        this.vanityUrlServices.updateCache(cache404VanityUrl);\n+      }\n     }\n \n-    private String getSiteId (final Host site) {\n-\n-        return\n-            (null != site && !site.isSystemHost())?\n-                        site.getIdentifier():Host.SYSTEM_HOST;\n-\n-    } // getSiteId.\n-\n-    @CloseDBIfOpened\n-    @Override\n-    public CachedVanityUrl getLiveCachedVanityUrl(final String uri, final Host site,\n-            final long languageId, final User user) {\n-\n-        final String siteId = this.getSiteId(site);\n-\n-        //First lets try with the cache\n-        CachedVanityUrl result = vanityUrlServices\n-                .getCachedVanityUrlByUri(uri, siteId, languageId);\n-\n-        final VanityMatches matches =\n-                this.patternMatches(result, uri);\n-        if (matches.isPatternMatches()) {\n-\n-            return processExpressions(result, matches.getGroups());\n-        } else {\n-            //Search for the URI in the vanityURL cached by site and language Ids\n-            result =\n-                    this.searchLiveCachedVanityUrlBySiteAndLanguage\n-                            (uri, siteId, languageId);\n-        }\n-\n-        return (null == result)?\n-                this.getFallback(uri, siteId, languageId, this.systemUser):result;\n-    } // getLiveCachedVanityUrl.\n-\n-    private CachedVanityUrl getFallback (final String uri, final String siteId,\n-                                         final long languageId, final User user) {\n-\n-        CachedVanityUrl result = null;\n-\n-        try {\n-\n-            //Search for the list of ContentTypes of type VanityURL\n-            final List<ContentType> vanityUrlContentTypes = APILocator.getContentTypeAPI(user)\n-                    .findByType(BaseContentType.VANITY_URL);\n-\n-            //Verify if this Content Type has a Multilinguable fallback\n-            if (!vanityUrlContentTypes.isEmpty()\n-                    && (this.defaultLanguageId != languageId)\n-                    && ((VanityUrlContentType) vanityUrlContentTypes.get(0)).fallback()) {\n-\n-                //if the fallback is set then is going to try to get it by the default language\n-                result = this.vanityUrlServices\n-                        .getCachedVanityUrlByUri(uri, siteId, this.defaultLanguageId);\n-\n-                final VanityMatches matches = this.patternMatches(result, uri);\n-                if (matches.isPatternMatches()) {\n-\n-                    return processExpressions(result, matches.getGroups());\n-                } else {\n-                    //Search for the URI in the vanityURL cached by site and default language Ids\n-                    result = searchLiveCachedVanityUrlBySiteAndLanguage(uri, siteId,\n-                            this.defaultLanguageId);\n-                }\n-            }\n-\n-        } catch (DotDataException | DotSecurityException e) {\n-            Logger.error(this, \"Error searching for Vanity URL by URI\", e);\n-        }\n-\n-        if (result == null) {\n-            //Add 404 to cache\n-            this.add404URIToCache(siteId, uri, languageId);\n-            result = this.vanityUrlServices\n-                    .getCachedVanityUrlByUri(uri, siteId, languageId);\n-        }\n-\n-        return result;\n-    } // getFallback.\n-\n-    /**\n-     * Validate if the CachedVanityUrl pattern matches the uri\n-     *\n-     * @param cachedVanityUrl The CachedVanityUrl\n-     * @param uri The current uri\n-     * @return true if the CachedVanityUrl match, false if not\n-     */\n-    private VanityMatches patternMatches(final CachedVanityUrl cachedVanityUrl,\n-                                         final String uri) {\n-        if (cachedVanityUrl != null) {\n-\n-            final Matcher matcher = cachedVanityUrl.getPattern().matcher(uri);\n-            if (matcher.matches()) {\n-                if (matcher.groupCount() > 0) {\n-\n-                    final String[] matches = new String[matcher.groupCount()];\n-                    rangeClosed(1, matcher.groupCount())\n-                            .forEach(i -> matches[i - 1] = matcher.group(i));\n-                    return new VanityMatches(Boolean.TRUE, matches);\n-                }\n-\n-                return VANITY_MATCHES_TRUE;\n-            }\n-        }\n-\n-        return VANITY_MATCHES_FALSE;\n-    } // patternMatches.\n-\n-    /**\n-     * Search CachedVanity Url checking if the Uri is in the Site Id and language Id cache\n-     *\n-     * @param uri The current uri\n-     * @param siteId the current site Id\n-     * @param languageId the current language Id\n-     * @return a CachedVanityUrl object\n-     */\n-    private CachedVanityUrl searchLiveCachedVanityUrlBySiteAndLanguage(final String uri,\n-            final String siteId, final long languageId) {\n-\n-        CachedVanityUrl result = null;\n-\n-        //Get the list of site cached Vanities URLs\n-        List<CachedVanityUrl> cachedVanityUrls =\n-                this.getVanityUrlBySiteAndLanguageFromCache\n-                        (siteId, languageId,true);\n-\n-        if (null == cachedVanityUrls) {\n-\n-            synchronized (VanityUrlAPIImpl.class) {\n-\n-                cachedVanityUrls =\n-                        this.getVanityUrlBySiteAndLanguageFromCache\n-                            (siteId, languageId, true);\n-\n-                if (null == cachedVanityUrls) {\n-\n-                    //Initialize the Cached Vanity URL cache if is null\n-                    this.initializeActiveVanityURLsCacheBySiteAndLanguage\n-                            (siteId, languageId);\n-\n-                    //Get the list of site cached Vanities URLs\n-                    cachedVanityUrls =\n-                            this.getVanityUrlBySiteAndLanguageFromCache\n-                                    (siteId, languageId,true);\n-                    if (!UtilMethods.isSet(cachedVanityUrls)) {\n-                        // If this point is reached, there's probably an issue with the Vanity URL Caches. So, just read\n-                        // directly from the data source WITHOUT reading or loading from any cache\n-                        cachedVanityUrls = this.getActiveVanityURLsNoCacheBySiteAndLanguage(siteId, languageId);\n-                    }\n-                }\n-            }\n-        }\n-\n-        VanityMatches matches = null;\n-        if (null != cachedVanityUrls) {\n-            //Validates if onw of the site cachedVanityUrls matches the uri\n-            for (CachedVanityUrl vanity : cachedVanityUrls) {\n-\n-                matches = this.patternMatches(vanity, uri);\n-                if (matches.isPatternMatches()) {\n-\n-                    result = processExpressions(vanity, matches.getGroups());\n-                    break;\n-                }\n-            }\n-        }\n-\n-        /*\n-        At this point we already found and saved in cache the VanityURL that matches with the given\n-        URL but adding a new VanityURL to the cache for the completed requested URL\n-        and not just the regex used can save us time.\n-         */\n-        if (null != result && !result.getUrl().equals(uri)) {\n-            this.vanityUrlServices.updateCache(new CachedVanityUrl(result, uri));\n-        }\n-\n-        return result;\n-    } // searchLiveCachedVanityUrlBySiteAndLanguage.\n-\n-    private void checkSiteLanguageVanities(final String siteId,\n-                                           final Long languageId,\n-                                           final Boolean includedSystemHostOnLuceneQuery) {\n-\n-        if (null == this.vanityUrlServices.getCachedVanityUrlList(siteId, languageId)) {\n-\n-            this.vanityUrlServices.setCachedVanityUrlList(siteId, languageId, Collections.EMPTY_LIST);\n-        }\n-\n-        if (includedSystemHostOnLuceneQuery && !Host.SYSTEM_HOST.equals(siteId) &&\n-                null == this.vanityUrlServices.getCachedVanityUrlList(Host.SYSTEM_HOST, languageId)) {\n-\n-            this.vanityUrlServices.setCachedVanityUrlList(Host.SYSTEM_HOST, languageId, Collections.EMPTY_LIST);\n-        }\n-    } // checkSiteLanguageVanities.\n-\n-    private void setEmptyCaches(final String siteId,\n-                                final Long languageId,\n-                                final Boolean includedSystemHostOnLuceneQuery) {\n-\n-        if (null != siteId && null != languageId) {\n-            this.vanityUrlServices.setCachedVanityUrlList(\n-                    siteId, languageId,\n-                    Collections.EMPTY_LIST);\n-\n-            if (includedSystemHostOnLuceneQuery && !Host.SYSTEM_HOST.equals(siteId)) {\n-                this.vanityUrlServices.setCachedVanityUrlList(\n-                        Host.SYSTEM_HOST, languageId,\n-                        Collections.EMPTY_LIST);\n-            }\n-        }\n-    } // setEmptyCaches.\n-\n-    private void addSecondaryVanityURLCacheCollection(final List<VanityUrl> vanityUrls) {\n-\n-        final Map<SiteLanguageKey, ImmutableList.Builder<CachedVanityUrl>> vanityPerSiteLanguageMap\n-                = map();\n-        SiteLanguageKey key;\n-\n-        for (final VanityUrl vanityUrl : vanityUrls) {\n-\n-            key = new SiteLanguageKey(vanityUrl.getSite(), vanityUrl.getLanguageId());\n-            if (!vanityPerSiteLanguageMap.containsKey(key)) {\n-\n-                vanityPerSiteLanguageMap.put(key, new ImmutableList.Builder());\n-            }\n-\n-            vanityPerSiteLanguageMap.get(key).add(new CachedVanityUrl(vanityUrl));\n-        }\n-\n-        // when the site + lang list is gonna be override, the main cache items should be clean too\n-        vanityPerSiteLanguageMap.keySet().forEach(this::cleanCurrentVanityUrlsPerSite);\n-\n-        vanityPerSiteLanguageMap.forEach( (k, vanityUrlBuilder) ->\n-                    this.vanityUrlServices.setCachedVanityUrlList (k.hostId(), k.languageId(), vanityUrlBuilder.build()));\n-    } // addSecondaryVanityURLCacheCollection.\n-\n-    private void cleanCurrentVanityUrlsPerSite(final SiteLanguageKey siteLanguageKey) {\n-\n-        final List<CachedVanityUrl> cachedVanityUrls = this.vanityUrlServices.getCachedVanityUrlList\n-                (siteLanguageKey.hostId(), siteLanguageKey.languageId());\n+    return cachedVanities;\n+  }\n+  \n \n-        if (null != cachedVanityUrls) {\n+  \n+  @CloseDBIfOpened\n+  @Override\n+  public Optional<CachedVanityUrl> resolveVanityUrl(final String url, final Host host, final Language language) {\n \n-            for (final CachedVanityUrl cachedVanityUrl : cachedVanityUrls) {\n \n-                CacheLocator.getVanityURLCache().remove(new CacheVanityKey(\n-                        cachedVanityUrl.getSiteId(),\n-                        cachedVanityUrl.getLanguageId(),\n-                        cachedVanityUrl.getUrl()\n-                ).toString());\n-            }\n-        }\n+    // 404 short circuit\n+    final Optional<CachedVanityUrl> shortCircuit = cache.getDirectMapping(url, host, language);\n+    if(shortCircuit!=null) {\n+        return shortCircuit;\n     }\n \n-    @CloseDBIfOpened\n-    @Override\n-    public void validateVanityUrl(final Contentlet contentlet) {\n+    // tries specific site, language and url\n+    Optional<CachedVanityUrl> matched = load(host, language).parallelStream()\n+            .filter(cachedVanityUrl ->\n+                    cachedVanityUrl.url.equalsIgnoreCase(url)).findAny();\n \n-        final User user = getUser(contentlet);\n-        Language language =\n-                APILocator.getLanguageAPI().getLanguage(user.getLanguageId());\n+    // tries specific site, language and pattern\n+    if(!matched.isPresent()) {\n+      matched = load(host, language).parallelStream()\n+              .filter(cachedVanityUrl ->\n+                      cachedVanityUrl.pattern.matcher(url).matches()).findAny();\n+    }\n \n-        language = (null == language ? APILocator.getLanguageAPI().getDefaultLanguage() : language);\n+    \n+    // try language fallback\n+    if (!matched.isPresent()  && !languageAPI.getDefaultLanguage().equals(language) && languageFallback) {\n \n-        // check fields\n-        checkMissingField(contentlet, language, VanityUrlContentType.ACTION_FIELD_VAR);\n-        checkMissingField(contentlet, language, VanityUrlContentType.URI_FIELD_VAR);\n+      matched = resolveVanityUrl(url, host, languageAPI.getDefaultLanguage());\n+    }\n+    \n+    // tries SYSTEM_HOST\n+    if (!matched.isPresent() && !APILocator.systemHost().equals(host)) {\n \n-        final Integer action     =\n-                (int)contentlet.getLongProperty(VanityUrlContentType.ACTION_FIELD_VAR);\n-        final String uri         =\n-                contentlet.getStringProperty(VanityUrlContentType.URI_FIELD_VAR);\n+        matched = resolveVanityUrl(url, APILocator.systemHost(), languageAPI.getDefaultLanguage());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTgyODc1NA=="}, "originalCommit": {"oid": "f525cc08b29ea13f9c097c818e918937e62741ad"}, "originalPosition": 751}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NDUwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NDo1NVrOGlcC-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NDo1NVrOGlcC-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDAwOQ==", "bodyText": "Codacy found an issue: Unnecessary use of fully qualified name 'Assert.assertEquals' due to existing static import 'org.junit.Assert.assertEquals'", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910009", "createdAt": "2020-06-18T00:54:55Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "diffHunk": "@@ -1533,31 +829,23 @@ public void Test_Vanity_URI_Ending_With_Forward_Slash_Handles_Non_forward_Slash_\n         final int order = 1;\n \n         final Contentlet vanityURL = filtersUtil.createVanityUrl(title, hostIdentifier, uri,\n-                forwardTo, action, order, defaultLanguageId);\n+                forwardTo, action, order, defaultLanguage.getId());\n         Assert.assertNotNull(vanityURL);\n         filtersUtil.publishVanityUrl(vanityURL);\n \n         final String testUri1 = \"/test1_\" + timeMillis + \"/\" ;\n         final String testUri2 = \"/test1_\" + timeMillis  ;\n \n-        final CachedVanityUrl v1 = vanityUrlAPI.getLiveCachedVanityUrl(testUri1, host, defaultLanguageId, APILocator.systemUser());\n+        final CachedVanityUrl v1 = vanityUrlAPI.resolveVanityUrl(testUri1, host, defaultLanguage).get();\n         Assert.assertNotNull(v1);\n-        Assert.assertNotNull(v1.getVanityUrlId());\n-        Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,v1.getVanityUrlId());\n-        Assert.assertEquals(v1.getForwardTo(),forwardTo);\n+        Assert.assertNotNull(v1.vanityUrlId);\n+        Assert.assertEquals(v1.forwardTo,forwardTo);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 2064}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NDU0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NDo1NlrOGlcC_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NDo1NlrOGlcC_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDAxNA==", "bodyText": "Codacy found an issue: Useless parentheses.", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910014", "createdAt": "2020-06-18T00:54:56Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "diffHunk": "@@ -457,499 +401,249 @@ public void checkInvalidActionTest()\n      */\n     @Test\n     @WrapInTransaction\n-    public void removeVanityURLDefaultLanguaguefromCacheTest() throws DotDataException, DotSecurityException {\n+    public void resolving_multilingual_vanities_with_default_language_unpublished() throws Exception {\n         long currentTime = System.currentTimeMillis();\n         Contentlet vanityURLContentletEnglish = null;\n         Contentlet vanityURLContentletSpanish = null;\n         final Language spanish = TestDataUtils.getSpanishLanguage();\n-        try{\n-            vanityURLContentletEnglish = filtersUtil\n-                    .createVanityUrl(\"test Vanity Url \" + currentTime, defaultHost.getIdentifier(),\n-                            \"/testing\" + currentTime, \"https://www.google.com\", 200, 1,\n-                            defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityURLContentletEnglish);\n-\n-            CachedVanityUrl vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletEnglish.getLanguageId(),\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n-\n-            vanityUrlAPI.getLiveCachedVanityUrl(\"/testing\"+currentTime, defaultHost, defaultLanguageId, user);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletEnglish.getLanguageId(),\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityURLCached.getVanityUrlId());\n-\n-            vanityURLContentletSpanish = contentletAPI.find(vanityURLContentletEnglish.getInode(), user, false);\n-            vanityURLContentletSpanish.setInode(\"\");\n-            vanityURLContentletSpanish.setLanguageId(spanish.getId());\n-            vanityURLContentletSpanish = contentletAPI.checkin(vanityURLContentletSpanish, user, false);\n-\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityUrlAPI.getLiveCachedVanityUrl(\"/testing\"+currentTime, defaultHost, spanish.getId(), user).getVanityUrlId());\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletSpanish.getLanguageId(),\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityURLCached.getVanityUrlId());\n-\n-            filtersUtil.publishVanityUrl(vanityURLContentletSpanish);\n-\n-            vanityUrlAPI.getLiveCachedVanityUrl(\"/testing\"+currentTime, defaultHost, spanish.getId(), user);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletSpanish.getLanguageId(),\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityURLCached.getVanityUrlId());\n-\n-            filtersUtil.unpublishVanityURL(vanityURLContentletEnglish);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletEnglish.getLanguageId(),\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n-\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletSpanish.getLanguageId(),\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityURLCached.getVanityUrlId());\n-\n-\n-        }finally{\n-\n-            try {\n-                contentletAPI.destroy(vanityURLContentletEnglish, user, false);\n-                contentletAPI.destroy(vanityURLContentletSpanish, user, false);\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Testing how the cache is working when publishing and unpublishing a VanityURL, we are\n-     * simulating URL requests that makes exact match with the URI of the VanityURL\n-     */\n-    @Test\n-    public void publishUnpublishVanityURLExact() throws DotDataException, DotSecurityException {\n-\n-        long currentTime = System.currentTimeMillis();\n-        publishUnpublishVanityURL(\"/testing\" + currentTime, \"/testing\" + currentTime,\n-                defaultHost.getIdentifier());\n-    }\n-\n-    /**\n-     * Testing how the cache is working when publishing and unpublishing a VanityURL, on this test\n-     * we created a VanityURL with a regex\n-     */\n-    @Test\n-    public void publishUnpublishVanityURLRegex() throws DotDataException, DotSecurityException {\n-\n-        long currentTime = System.currentTimeMillis();\n-        publishUnpublishVanityURL(\"/testing\" + currentTime + \"(.*)\",\n-                \"/testing\" + currentTime + \"/testing/index\", defaultHost.getIdentifier());\n-    }\n-\n-    /**\n-     * Testing how the cache is working when publishing and unpublishing a VanityURL, on this test\n-     * we created a VanityURL with a regex\n-     */\n-    @Test\n-    public void publishUnpublishVanityURLRegexSystemHost()\n-            throws DotDataException, DotSecurityException {\n-\n-        long currentTime = System.currentTimeMillis();\n-        publishUnpublishVanityURL(\"/testing\" + currentTime + \"(.*)\",\n-                \"/testing\" + currentTime + \"/testing/index\", Host.SYSTEM_HOST);\n-    }\n \n-    /**\n-     * Testing how the cache is working with multiple vanities using the same URI and the\n-     * combinations of existing vanities in other different Sites\n-     */\n-    @Test\n-    public void sameURLSystemHost()\n-            throws DotDataException, DotSecurityException {\n+        vanityURLContentletEnglish = filtersUtil\n+                .createVanityUrl(\"test Vanity Url \" + currentTime, defaultHost.getIdentifier(),\n+                        \"/testing\" + currentTime, \"https://www.google.com\", 200, 1,\n+                        defaultLanguage.getId());\n+        filtersUtil.publishVanityUrl(vanityURLContentletEnglish);\n \n-        Contentlet vanityURL = null;\n-        Contentlet vanityURL1 = null;\n-        Contentlet vanityURL2 = null;\n+        Optional<CachedVanityUrl> englishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, defaultLanguage);\n \n-        try {\n-            long currentTime = System.currentTimeMillis();\n-            String uri = \"/\" + currentTime + \"_testing\" + \"(.*)\";\n-            String requestedURL = \"/\" + currentTime + \"_testing\";\n-            final String nonExistingURL = \"/nonexisting/should404/index\" + currentTime;\n+        // we have vanity in english\n+        assert(englishVanity.isPresent());\n+        assert(englishVanity.get().response==200);\n \n-            //------------------------------------\n-            //Create a VanityURL for the default host\n-            //------------------------------------\n-            vanityURL = filtersUtil\n-                    .createVanityUrl(\"test Vanity Url \" + System.currentTimeMillis(),\n-                            defaultHost.getIdentifier(),\n-                            uri, \"https://www.google.com\", 200, 1, defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityURL);\n-\n-            //Should not exist in cache\n-            CachedVanityUrl vanityURLCached = vanityUrlCache\n-                    .get(\n-                        new CacheVanityKey(\n-                                vanityURL.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                                vanityURL.getLanguageId(),\n-                                vanityURL.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                        ));\n-            Assert.assertNull(vanityURLCached);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            defaultHost.getIdentifier(),\n-                            defaultLanguageId,\n-                            requestedURL\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n \n-            //Request a vanity with a URL with no matches\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(nonExistingURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //Check the cache, probably the Vanity we created was added in cache by the getLiveCachedVanityUrl\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL.getLanguageId(),\n-                            vanityURL.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //------------------------------------\n-            //Create the first VanityURL for the SYSTEM_HOST\n-            //------------------------------------\n-\n-            currentTime = System.currentTimeMillis();\n-            uri = \"/testing\" + currentTime + \"(.*)\";\n-            requestedURL = \"/testing\" + currentTime;\n-\n-            vanityURL1 = filtersUtil\n-                    .createVanityUrl(\"test Vanity Url \" + System.currentTimeMillis(),\n-                            Host.SYSTEM_HOST,\n-                            uri, \"https://www.google.com\", 200, 1, defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityURL1);\n-\n-            //Should not exist in cache\n-            vanityURLCached = vanityUrlCache\n-                    .get(\n-                            new CacheVanityKey(\n-                                    vanityURL1.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                                    vanityURL1.getLanguageId(),\n-                                    vanityURL1.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                            ));\n-            Assert.assertNull(vanityURLCached);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            defaultHost.getIdentifier(),\n-                            defaultLanguageId,\n-                            requestedURL\n-                    ));\n-\n-            Assert.assertNull(vanityURLCached);\n-\n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //Check the cache, probably the Vanity we created was added in cache by the getLiveCachedVanityUrl\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL1.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL1.getLanguageId(),\n-                            vanityURL1.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+        Optional<CachedVanityUrl> vanityFromCache = cache.getDirectMapping(\"/testing\" + currentTime, defaultHost, defaultLanguage);\n \n-            //------------------------------------\n-            //Create the second VanityURL  for the SYSTEM_HOST and with the same URI\n-            //------------------------------------\n-            vanityURL2 = filtersUtil\n-                    .createVanityUrl(\"test Vanity Url \" + System.currentTimeMillis(),\n-                            Host.SYSTEM_HOST,\n-                            uri, \"https://www.google.com\", 200, 1, defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityURL2);\n-\n-            //Should not exist in cache\n-            vanityURLCached = vanityUrlCache\n-                    .get(\n-                            new CacheVanityKey(\n-                                    vanityURL2.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                                    vanityURL2.getLanguageId(),\n-                                    vanityURL2.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                            ));\n-            Assert.assertNull(vanityURLCached);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            defaultHost.getIdentifier(),\n-                            defaultLanguageId,\n-                            requestedURL\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n+        assertEquals(englishVanity.get(),vanityFromCache.get());\n+        \n+        vanityURLContentletSpanish = contentletAPI.find(vanityURLContentletEnglish.getInode(), user, false);\n+        vanityURLContentletSpanish.setInode(\"\");\n+        vanityURLContentletSpanish.setLanguageId(spanish.getId());\n+        vanityURLContentletSpanish = contentletAPI.checkin(vanityURLContentletSpanish, user, false);\n \n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //Check the cache, probably the Vanity we created was added in cache by the getLiveCachedVanityUrl\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL2.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL2.getLanguageId(),\n-                            vanityURL2.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+        Optional<CachedVanityUrl> spanishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, spanish);\n \n-            //------------------------------------\n-            //Unpublish the VanityURL\n-            //------------------------------------\n-            vanityURL2.setIndexPolicy(IndexPolicy.FORCE);\n-            vanityURL2.setIndexPolicyDependencies(IndexPolicy.FORCE);\n-            filtersUtil.unpublishVanityURL(vanityURL2);\n-\n-            //Should NOT be in cache\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL2.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL2.getLanguageId(),\n-                            vanityURL2.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n+        // we do not have a spanish vanity because it is not published\n+        assert(!spanishVanity.isPresent());\n+        \n+        filtersUtil.publishVanityUrl(vanityURLContentletSpanish);\n \n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+        spanishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, spanish);\n \n-            //------------------------------------\n-            //Unpublish the VanityURL\n-            //------------------------------------\n-            vanityURL1.setIndexPolicy(IndexPolicy.FORCE);\n-            vanityURL1.setIndexPolicyDependencies(IndexPolicy.FORCE);\n-            filtersUtil.unpublishVanityURL(vanityURL1);\n-\n-            //Should NOT be in cache\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL1.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL1.getLanguageId(),\n-                            vanityURL1.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n+        // we have a spanish vanity because it is published\n+        assert(spanishVanity.isPresent());\n+        assertEquals(spanishVanity.get().vanityUrlId, englishVanity.get().vanityUrlId);\n+        assertEquals(spanishVanity.get().languageId,spanish.getId());\n+        \n+        // unpublish the english one\n+        filtersUtil.unpublishVanityURL(vanityURLContentletEnglish);\n+        \n+        \n+        englishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, defaultLanguage);\n+        assert(!englishVanity.isPresent());\n \n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+        \n+        spanishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, spanish);\n+        assert(spanishVanity.isPresent());\n \n-            //------------------------------------\n-            //Unpublish the VanityURL\n-            //------------------------------------\n-            vanityURL2.setIndexPolicy(IndexPolicy.FORCE);\n-            vanityURL2.setIndexPolicyDependencies(IndexPolicy.FORCE);\n-            filtersUtil.publishVanityUrl(vanityURL2);\n-\n-            //Should NOT be in cache\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL2.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL2.getLanguageId(),\n-                            vanityURL2.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n \n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+    }\n \n+    \n \n-        } finally {\n+    /**\n+     * Testing how the cache is working with multiple vanities using the same URI and the\n+     * combinations of existing vanities in other different Sites\n+     */\n+    @Test\n+    public void does_a_site_specific_vanity_override_system_host_vanity()\n+            throws Exception {\n+\n+        DefaultVanityUrl siteVanity = null;\n+        DefaultVanityUrl systemHostVanity = null;\n+\n+\n+\n+        final long currentTime = System.currentTimeMillis();\n+        final String uri = \"/\" + currentTime + \"_testing\" + \"(.*)\";\n+        final String requestedURL = \"/\" + currentTime + \"_testing\" + \"RANDOM_CHARACTERS\";\n+        final String nonExistingURL = \"/nonexisting/should404/index\" + currentTime;\n+\n+        //------------------------------------\n+        //Create a VanityURL for the default host\n+        //------------------------------------\n+        siteVanity = filtersUtil\n+                .createVanityUrl(\"test Vanity Url \" + System.currentTimeMillis(),\n+                        defaultHost.getIdentifier(),\n+                        uri, \"https://www.google.com\", 200, 1, defaultLanguage.getId());\n+        filtersUtil.publishVanityUrl(siteVanity);\n+        \n+        // nothing in cache\n+        List<CachedVanityUrl> siteCache= cache.getSiteMappings(defaultHost, defaultLanguage);\n+        assert( siteCache==null);\n+        \n+        //None of these exist in cache\n+        Optional<CachedVanityUrl> vanityURLCached = cache.getDirectMapping(uri, defaultHost, defaultLanguage);\n+        assert(vanityURLCached ==null );\n+        vanityURLCached = cache.getDirectMapping(requestedURL, defaultHost, defaultLanguage);\n+        assert(vanityURLCached ==null );\n+        vanityURLCached = cache.getDirectMapping(nonExistingURL, defaultHost, defaultLanguage);\n+        assert(vanityURLCached ==null );\n+\n+        \n+        // one hit loads cache\n+        vanityURLCached= vanityUrlAPI.resolveVanityUrl(requestedURL, defaultHost, defaultLanguage);\n+        assert( vanityURLCached.isPresent());\n+        \n+        siteCache= cache.getSiteMappings(defaultHost, defaultLanguage);\n+        \n+        // it lives in the host cache\n+        assert( siteCache!=null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 1155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NDU2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotmarketing/filters/FiltersTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NDo1N1rOGlcDAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NDo1N1rOGlcDAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDAxNg==", "bodyText": "Codacy found an issue: The String literal \"/products/\" appears 4 times in this file; the first occurrence is on line 198", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910016", "createdAt": "2020-06-18T00:54:57Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/filters/FiltersTest.java", "diffHunk": "@@ -163,120 +164,90 @@ public String answer(InvocationOnMock invocation) throws Throwable {\n     }\n \n     @Test\n-    public void shouldWorkVanityUrl() throws IOException, DotDataException {\n+    public void shouldWorkVanityUrl() throws Exception {\n \n         //Init APIs and test values\n         Contentlet vanityUrl1 = null;\n         Contentlet vanityUrl2 = null;\n         Contentlet vanityUrl3 = null;\n         Contentlet vanityUrl4 = null;\n         Contentlet vanityUrl5 = null;\n-\n+        final String uniqueUrl = UUIDGenerator.shorty();\n         // build them up\n-        try {\n-            vanityUrl1 = filtersUtil.createVanityUrl(\"test link1\", Host.SYSTEM_HOST, \"/testLink1\",\n-                    \"/about-us/\" + CMSFilter.CMS_INDEX_PAGE, 200, 1, defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityUrl1);\n-\n-            vanityUrl2 = filtersUtil.createVanityUrl(\"test link2\", site.getIdentifier(),\n-                    \"/testLink2\", \"/about-us/\" + CMSFilter.CMS_INDEX_PAGE, 200, 1,\n-                    defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityUrl2);\n-\n-            vanityUrl3 = filtersUtil.createVanityUrl(\"test link3\", site.getIdentifier(),\n-                    \"/testLink3\", \"http://demo.dotcms.com/about-us/\" + CMSFilter.CMS_INDEX_PAGE,\n-                    301, 1, defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityUrl3);\n-\n-            vanityUrl4 = filtersUtil.createVanityUrl(\"test link4\", site.getIdentifier(),\n-                    \"/testLink4\", \"http://demo.dotcms.com/about-us/\" + CMSFilter.CMS_INDEX_PAGE,\n-                    301, 1, defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityUrl4);\n-\n-            vanityUrl5 = filtersUtil.createVanityUrl(\"test link5\", Host.SYSTEM_HOST,\n-                    \"forbidden\", \"/products/\" + CMSFilter.CMS_INDEX_PAGE, 302, 1, defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityUrl5);\n \n-            VanityURLFilter filter = new VanityURLFilter();\n-            HttpServletResponse res = Mockito.mock(HttpServletResponse.class);\n-            MockResponseWrapper response = new MockResponseWrapper(res);\n-            FilterChain chain = Mockito.mock(FilterChain.class);\n-            Logger.info(this.getClass(),\n-                    \"/testLink1 should forward to /about-us/\" + CMSFilter.CMS_INDEX_PAGE);\n-            HttpServletRequest request = getMockRequest(site.getHostname(), \"/testLink1\");\n-            filter.doFilter(request, response, chain);\n-            Assert.assertEquals(200, response.getStatus());\n-            Assert.assertEquals(\"/about-us/\" + CMSFilter.CMS_INDEX_PAGE,\n-                    request.getAttribute(Constants.CMS_FILTER_URI_OVERRIDE));\n-\n-            Logger.info(this.getClass(),\n-                    \"/testLink2 should forward to /about-us/\" + CMSFilter.CMS_INDEX_PAGE);\n-            request = getMockRequest(site.getHostname(), \"/testLink2\");\n-            response = new MockResponseWrapper(Mockito.mock(HttpServletResponse.class));\n-            filter.doFilter(request, response, chain);\n-            Assert.assertEquals(200, response.getStatus());\n-            Assert.assertEquals(\"/about-us/\" + CMSFilter.CMS_INDEX_PAGE,\n-                    request.getAttribute(Constants.CMS_FILTER_URI_OVERRIDE));\n+        vanityUrl1 = filtersUtil.createVanityUrl(\"test link1\", Host.SYSTEM_HOST, \"/\" + uniqueUrl + \"1\",\n+                \"/about-us/\" + CMSFilter.CMS_INDEX_PAGE, 200, 1, defaultLanguageId);\n+        filtersUtil.publishVanityUrl(vanityUrl1);\n \n-            Logger.info(this.getClass(),\n-                    \"/testLink3 should redirect to http://demo.dotcms.com/about-us/\"\n-                            + CMSFilter.CMS_INDEX_PAGE);\n-            request = getMockRequest(site.getHostname(), \"/testLink3\");\n-            response = new MockResponseWrapper(Mockito.mock(HttpServletResponse.class));\n-            filter.doFilter(request, response, chain);\n-            Assert.assertEquals(301, response.getStatus());\n-            Assert.assertEquals(\"http://demo.dotcms.com/about-us/\" + CMSFilter.CMS_INDEX_PAGE,\n-                    response.getRedirectLocation());\n+        vanityUrl2 = filtersUtil.createVanityUrl(\"test link2\", site.getIdentifier(),\n+                \"/\" + uniqueUrl + \"2\", \"/about-us/\" + CMSFilter.CMS_INDEX_PAGE, 200, 1,\n+                defaultLanguageId);\n+        filtersUtil.publishVanityUrl(vanityUrl2);\n \n-            Logger.info(this.getClass(),\n-                    \"/testLink4 should redirect to http://demo.dotcms.com/about-us/\"\n-                            + CMSFilter.CMS_INDEX_PAGE);\n-            request = getMockRequest(site.getHostname(), \"/testLink4\");\n-            response = new MockResponseWrapper(Mockito.mock(HttpServletResponse.class));\n-            filter.doFilter(request, response, chain);\n-            Assert.assertEquals(301, response.getStatus());\n-            Assert.assertEquals(\"http://demo.dotcms.com/about-us/\" + CMSFilter.CMS_INDEX_PAGE,\n-                    response.getRedirectLocation());\n+        vanityUrl3 = filtersUtil.createVanityUrl(\"test link3\", site.getIdentifier(),\n+                \"/\" + uniqueUrl + \"3\", \"http://demo.dotcms.com/about-us/\" + CMSFilter.CMS_INDEX_PAGE,\n+                301, 1, defaultLanguageId);\n+        filtersUtil.publishVanityUrl(vanityUrl3);\n \n-            Logger.info(this.getClass(),\n-                    \"/forbidden should forward to /products/\" + CMSFilter.CMS_INDEX_PAGE);\n-            request = getMockRequest(site.getHostname(), \"/forbidden\");\n-            response = new MockResponseWrapper(Mockito.mock(HttpServletResponse.class));\n-            filter.doFilter(request, response, chain);\n-            Assert.assertEquals(200, response.getStatus());\n+        vanityUrl4 = filtersUtil.createVanityUrl(\"test link4\", site.getIdentifier(),\n+                \"/\" + uniqueUrl + \"4\", \"http://demo.dotcms.com/about-us/\" + CMSFilter.CMS_INDEX_PAGE,\n+                301, 1, defaultLanguageId);\n+        filtersUtil.publishVanityUrl(vanityUrl4);\n \n-        } catch (Exception e) {\n+        vanityUrl5 = filtersUtil.createVanityUrl(\"test link5\", Host.SYSTEM_HOST,\n+                \"/forbidden\", \"/products/\" + CMSFilter.CMS_INDEX_PAGE, 302, 1, defaultLanguageId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NDU5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NDo1OFrOGlcDBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NDo1OFrOGlcDBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDAyMg==", "bodyText": "Codacy found an issue: Unnecessary use of fully qualified name 'Assert.assertNull' due to existing static import 'org.junit.Assert.assertNull'", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910022", "createdAt": "2020-06-18T00:54:58Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "diffHunk": "@@ -457,499 +401,249 @@ public void checkInvalidActionTest()\n      */\n     @Test\n     @WrapInTransaction\n-    public void removeVanityURLDefaultLanguaguefromCacheTest() throws DotDataException, DotSecurityException {\n+    public void resolving_multilingual_vanities_with_default_language_unpublished() throws Exception {\n         long currentTime = System.currentTimeMillis();\n         Contentlet vanityURLContentletEnglish = null;\n         Contentlet vanityURLContentletSpanish = null;\n         final Language spanish = TestDataUtils.getSpanishLanguage();\n-        try{\n-            vanityURLContentletEnglish = filtersUtil\n-                    .createVanityUrl(\"test Vanity Url \" + currentTime, defaultHost.getIdentifier(),\n-                            \"/testing\" + currentTime, \"https://www.google.com\", 200, 1,\n-                            defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityURLContentletEnglish);\n-\n-            CachedVanityUrl vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletEnglish.getLanguageId(),\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n-\n-            vanityUrlAPI.getLiveCachedVanityUrl(\"/testing\"+currentTime, defaultHost, defaultLanguageId, user);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletEnglish.getLanguageId(),\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityURLCached.getVanityUrlId());\n-\n-            vanityURLContentletSpanish = contentletAPI.find(vanityURLContentletEnglish.getInode(), user, false);\n-            vanityURLContentletSpanish.setInode(\"\");\n-            vanityURLContentletSpanish.setLanguageId(spanish.getId());\n-            vanityURLContentletSpanish = contentletAPI.checkin(vanityURLContentletSpanish, user, false);\n-\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityUrlAPI.getLiveCachedVanityUrl(\"/testing\"+currentTime, defaultHost, spanish.getId(), user).getVanityUrlId());\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletSpanish.getLanguageId(),\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityURLCached.getVanityUrlId());\n-\n-            filtersUtil.publishVanityUrl(vanityURLContentletSpanish);\n-\n-            vanityUrlAPI.getLiveCachedVanityUrl(\"/testing\"+currentTime, defaultHost, spanish.getId(), user);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletSpanish.getLanguageId(),\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityURLCached.getVanityUrlId());\n-\n-            filtersUtil.unpublishVanityURL(vanityURLContentletEnglish);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletEnglish.getLanguageId(),\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n-\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletSpanish.getLanguageId(),\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityURLCached.getVanityUrlId());\n-\n-\n-        }finally{\n-\n-            try {\n-                contentletAPI.destroy(vanityURLContentletEnglish, user, false);\n-                contentletAPI.destroy(vanityURLContentletSpanish, user, false);\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Testing how the cache is working when publishing and unpublishing a VanityURL, we are\n-     * simulating URL requests that makes exact match with the URI of the VanityURL\n-     */\n-    @Test\n-    public void publishUnpublishVanityURLExact() throws DotDataException, DotSecurityException {\n-\n-        long currentTime = System.currentTimeMillis();\n-        publishUnpublishVanityURL(\"/testing\" + currentTime, \"/testing\" + currentTime,\n-                defaultHost.getIdentifier());\n-    }\n-\n-    /**\n-     * Testing how the cache is working when publishing and unpublishing a VanityURL, on this test\n-     * we created a VanityURL with a regex\n-     */\n-    @Test\n-    public void publishUnpublishVanityURLRegex() throws DotDataException, DotSecurityException {\n-\n-        long currentTime = System.currentTimeMillis();\n-        publishUnpublishVanityURL(\"/testing\" + currentTime + \"(.*)\",\n-                \"/testing\" + currentTime + \"/testing/index\", defaultHost.getIdentifier());\n-    }\n-\n-    /**\n-     * Testing how the cache is working when publishing and unpublishing a VanityURL, on this test\n-     * we created a VanityURL with a regex\n-     */\n-    @Test\n-    public void publishUnpublishVanityURLRegexSystemHost()\n-            throws DotDataException, DotSecurityException {\n-\n-        long currentTime = System.currentTimeMillis();\n-        publishUnpublishVanityURL(\"/testing\" + currentTime + \"(.*)\",\n-                \"/testing\" + currentTime + \"/testing/index\", Host.SYSTEM_HOST);\n-    }\n \n-    /**\n-     * Testing how the cache is working with multiple vanities using the same URI and the\n-     * combinations of existing vanities in other different Sites\n-     */\n-    @Test\n-    public void sameURLSystemHost()\n-            throws DotDataException, DotSecurityException {\n+        vanityURLContentletEnglish = filtersUtil\n+                .createVanityUrl(\"test Vanity Url \" + currentTime, defaultHost.getIdentifier(),\n+                        \"/testing\" + currentTime, \"https://www.google.com\", 200, 1,\n+                        defaultLanguage.getId());\n+        filtersUtil.publishVanityUrl(vanityURLContentletEnglish);\n \n-        Contentlet vanityURL = null;\n-        Contentlet vanityURL1 = null;\n-        Contentlet vanityURL2 = null;\n+        Optional<CachedVanityUrl> englishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, defaultLanguage);\n \n-        try {\n-            long currentTime = System.currentTimeMillis();\n-            String uri = \"/\" + currentTime + \"_testing\" + \"(.*)\";\n-            String requestedURL = \"/\" + currentTime + \"_testing\";\n-            final String nonExistingURL = \"/nonexisting/should404/index\" + currentTime;\n+        // we have vanity in english\n+        assert(englishVanity.isPresent());\n+        assert(englishVanity.get().response==200);\n \n-            //------------------------------------\n-            //Create a VanityURL for the default host\n-            //------------------------------------\n-            vanityURL = filtersUtil\n-                    .createVanityUrl(\"test Vanity Url \" + System.currentTimeMillis(),\n-                            defaultHost.getIdentifier(),\n-                            uri, \"https://www.google.com\", 200, 1, defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityURL);\n-\n-            //Should not exist in cache\n-            CachedVanityUrl vanityURLCached = vanityUrlCache\n-                    .get(\n-                        new CacheVanityKey(\n-                                vanityURL.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                                vanityURL.getLanguageId(),\n-                                vanityURL.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                        ));\n-            Assert.assertNull(vanityURLCached);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            defaultHost.getIdentifier(),\n-                            defaultLanguageId,\n-                            requestedURL\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n \n-            //Request a vanity with a URL with no matches\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(nonExistingURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //Check the cache, probably the Vanity we created was added in cache by the getLiveCachedVanityUrl\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL.getLanguageId(),\n-                            vanityURL.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //------------------------------------\n-            //Create the first VanityURL for the SYSTEM_HOST\n-            //------------------------------------\n-\n-            currentTime = System.currentTimeMillis();\n-            uri = \"/testing\" + currentTime + \"(.*)\";\n-            requestedURL = \"/testing\" + currentTime;\n-\n-            vanityURL1 = filtersUtil\n-                    .createVanityUrl(\"test Vanity Url \" + System.currentTimeMillis(),\n-                            Host.SYSTEM_HOST,\n-                            uri, \"https://www.google.com\", 200, 1, defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityURL1);\n-\n-            //Should not exist in cache\n-            vanityURLCached = vanityUrlCache\n-                    .get(\n-                            new CacheVanityKey(\n-                                    vanityURL1.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                                    vanityURL1.getLanguageId(),\n-                                    vanityURL1.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                            ));\n-            Assert.assertNull(vanityURLCached);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            defaultHost.getIdentifier(),\n-                            defaultLanguageId,\n-                            requestedURL\n-                    ));\n-\n-            Assert.assertNull(vanityURLCached);\n-\n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //Check the cache, probably the Vanity we created was added in cache by the getLiveCachedVanityUrl\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL1.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL1.getLanguageId(),\n-                            vanityURL1.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+        Optional<CachedVanityUrl> vanityFromCache = cache.getDirectMapping(\"/testing\" + currentTime, defaultHost, defaultLanguage);\n \n-            //------------------------------------\n-            //Create the second VanityURL  for the SYSTEM_HOST and with the same URI\n-            //------------------------------------\n-            vanityURL2 = filtersUtil\n-                    .createVanityUrl(\"test Vanity Url \" + System.currentTimeMillis(),\n-                            Host.SYSTEM_HOST,\n-                            uri, \"https://www.google.com\", 200, 1, defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityURL2);\n-\n-            //Should not exist in cache\n-            vanityURLCached = vanityUrlCache\n-                    .get(\n-                            new CacheVanityKey(\n-                                    vanityURL2.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                                    vanityURL2.getLanguageId(),\n-                                    vanityURL2.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                            ));\n-            Assert.assertNull(vanityURLCached);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            defaultHost.getIdentifier(),\n-                            defaultLanguageId,\n-                            requestedURL\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n+        assertEquals(englishVanity.get(),vanityFromCache.get());\n+        \n+        vanityURLContentletSpanish = contentletAPI.find(vanityURLContentletEnglish.getInode(), user, false);\n+        vanityURLContentletSpanish.setInode(\"\");\n+        vanityURLContentletSpanish.setLanguageId(spanish.getId());\n+        vanityURLContentletSpanish = contentletAPI.checkin(vanityURLContentletSpanish, user, false);\n \n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //Check the cache, probably the Vanity we created was added in cache by the getLiveCachedVanityUrl\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL2.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL2.getLanguageId(),\n-                            vanityURL2.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+        Optional<CachedVanityUrl> spanishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, spanish);\n \n-            //------------------------------------\n-            //Unpublish the VanityURL\n-            //------------------------------------\n-            vanityURL2.setIndexPolicy(IndexPolicy.FORCE);\n-            vanityURL2.setIndexPolicyDependencies(IndexPolicy.FORCE);\n-            filtersUtil.unpublishVanityURL(vanityURL2);\n-\n-            //Should NOT be in cache\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL2.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL2.getLanguageId(),\n-                            vanityURL2.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n+        // we do not have a spanish vanity because it is not published\n+        assert(!spanishVanity.isPresent());\n+        \n+        filtersUtil.publishVanityUrl(vanityURLContentletSpanish);\n \n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+        spanishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, spanish);\n \n-            //------------------------------------\n-            //Unpublish the VanityURL\n-            //------------------------------------\n-            vanityURL1.setIndexPolicy(IndexPolicy.FORCE);\n-            vanityURL1.setIndexPolicyDependencies(IndexPolicy.FORCE);\n-            filtersUtil.unpublishVanityURL(vanityURL1);\n-\n-            //Should NOT be in cache\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL1.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL1.getLanguageId(),\n-                            vanityURL1.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n+        // we have a spanish vanity because it is published\n+        assert(spanishVanity.isPresent());\n+        assertEquals(spanishVanity.get().vanityUrlId, englishVanity.get().vanityUrlId);\n+        assertEquals(spanishVanity.get().languageId,spanish.getId());\n+        \n+        // unpublish the english one\n+        filtersUtil.unpublishVanityURL(vanityURLContentletEnglish);\n+        \n+        \n+        englishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, defaultLanguage);\n+        assert(!englishVanity.isPresent());\n \n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+        \n+        spanishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, spanish);\n+        assert(spanishVanity.isPresent());\n \n-            //------------------------------------\n-            //Unpublish the VanityURL\n-            //------------------------------------\n-            vanityURL2.setIndexPolicy(IndexPolicy.FORCE);\n-            vanityURL2.setIndexPolicyDependencies(IndexPolicy.FORCE);\n-            filtersUtil.publishVanityUrl(vanityURL2);\n-\n-            //Should NOT be in cache\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL2.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL2.getLanguageId(),\n-                            vanityURL2.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n \n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+    }\n \n+    \n \n-        } finally {\n+    /**\n+     * Testing how the cache is working with multiple vanities using the same URI and the\n+     * combinations of existing vanities in other different Sites\n+     */\n+    @Test\n+    public void does_a_site_specific_vanity_override_system_host_vanity()\n+            throws Exception {\n+\n+        DefaultVanityUrl siteVanity = null;\n+        DefaultVanityUrl systemHostVanity = null;\n+\n+\n+\n+        final long currentTime = System.currentTimeMillis();\n+        final String uri = \"/\" + currentTime + \"_testing\" + \"(.*)\";\n+        final String requestedURL = \"/\" + currentTime + \"_testing\" + \"RANDOM_CHARACTERS\";\n+        final String nonExistingURL = \"/nonexisting/should404/index\" + currentTime;\n+\n+        //------------------------------------\n+        //Create a VanityURL for the default host\n+        //------------------------------------\n+        siteVanity = filtersUtil\n+                .createVanityUrl(\"test Vanity Url \" + System.currentTimeMillis(),\n+                        defaultHost.getIdentifier(),\n+                        uri, \"https://www.google.com\", 200, 1, defaultLanguage.getId());\n+        filtersUtil.publishVanityUrl(siteVanity);\n+        \n+        // nothing in cache\n+        List<CachedVanityUrl> siteCache= cache.getSiteMappings(defaultHost, defaultLanguage);\n+        assert( siteCache==null);\n+        \n+        //None of these exist in cache\n+        Optional<CachedVanityUrl> vanityURLCached = cache.getDirectMapping(uri, defaultHost, defaultLanguage);\n+        assert(vanityURLCached ==null );\n+        vanityURLCached = cache.getDirectMapping(requestedURL, defaultHost, defaultLanguage);\n+        assert(vanityURLCached ==null );\n+        vanityURLCached = cache.getDirectMapping(nonExistingURL, defaultHost, defaultLanguage);\n+        assert(vanityURLCached ==null );\n+\n+        \n+        // one hit loads cache\n+        vanityURLCached= vanityUrlAPI.resolveVanityUrl(requestedURL, defaultHost, defaultLanguage);\n+        assert( vanityURLCached.isPresent());\n+        \n+        siteCache= cache.getSiteMappings(defaultHost, defaultLanguage);\n+        \n+        // it lives in the host cache\n+        assert( siteCache!=null);\n+        assert(siteCache.contains(vanityURLCached.get()));\n+        Optional<CachedVanityUrl> directCached = cache.getDirectMapping(requestedURL, defaultHost, defaultLanguage);\n+        // and the direct cache\n+        assertEquals(vanityURLCached.get(), directCached.get());\n+        \n+        \n+\n+        //------------------------------------\n+        //Create the VanityURL for the SYSTEM_HOST\n+        //------------------------------------\n+\n+        systemHostVanity = filtersUtil.createVanityUrl(\"test Vanity Url \" + System.currentTimeMillis(), Host.SYSTEM_HOST, uri,\n+                        \"https://www.google.com\", 200, 1, defaultLanguage.getId());\n+        filtersUtil.publishVanityUrl(systemHostVanity);\n+\n+        //Should not exist in direct cache (the save/publish wipes cache) or in the host cache\n+        vanityURLCached = cache.getDirectMapping(requestedURL, defaultHost, defaultLanguage);\n+        Assert.assertNull(vanityURLCached);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 1173}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NDY1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/datagen/VanityUrlDataGen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NDo1OVrOGlcDDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NDo1OVrOGlcDDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDAyOQ==", "bodyText": "Codacy found an issue: Field action has the same name as a method", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910029", "createdAt": "2020-06-18T00:54:59Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/datagen/VanityUrlDataGen.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package com.dotcms.datagen;\n+\n+import com.dotcms.vanityurl.business.VanityUrlAPI;\n+import com.dotcms.vanityurl.model.DefaultVanityUrl;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.contentlet.model.IndexPolicy;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+\n+import io.vavr.control.Try;\n+\n+/**\n+ * Class used to create {@link Contentlet} objects of type {@link com.dotcms.vanityurl.model.VanityUrl} for test purposes\n+ *\n+ * @author Nollymar Longa\n+ */\n+public class VanityUrlDataGen extends ContentletDataGen {\n+\n+\n+\n+  private String uri;\n+  private String forwardTo;\n+  private int action;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NDY4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowMFrOGlcDEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowMFrOGlcDEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDAzMg==", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910032", "createdAt": "2020-06-18T00:55:00Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "diffHunk": "@@ -60,271 +61,255 @@ public static void prepare() throws Exception {\n         /* Default user */\n         user = APILocator.systemUser();\n \n-        /* APIs initialization */\n-        hostAPI = APILocator.getHostAPI();\n         contentletAPI = APILocator.getContentletAPI();\n         vanityUrlAPI = APILocator.getVanityUrlAPI();\n         filtersUtil = FiltersUtil.getInstance();\n \n-        /* Load Cache */\n-        vanityUrlCache = CacheLocator.getVanityURLCache();\n+        cache=CacheLocator.getVanityURLCache();\n \n         /* Default variables */\n-        defaultHost = hostAPI.findDefaultHost(user, false);\n-        defaultLanguageId = APILocator.getLanguageAPI().getDefaultLanguage().getId();\n+        defaultHost =  new SiteDataGen().nextPersisted();\n+        defaultLanguage = APILocator.getLanguageAPI().getDefaultLanguage();\n     }\n \n+    \n+    \n     /**\n      * Creates a vanity url but no publish it, gets it and checks there is not in cache.\n      *\n      * @see VanityUrlAPI\n      */\n     @Test\n-    public void getWorkingVanityUrl() {\n+    public void testing_the_from_contentlet_method() throws Exception {\n+\n+\n+        long i = System.currentTimeMillis();\n+        String title = \"VanityURL\" + i;\n+        String site = defaultHost.getIdentifier();\n+        String uri = \"/test1_\" + i;\n+        String forwardTo = \"/about-us/\" + CMSFilter.CMS_INDEX_PAGE;\n+        int action = 200;\n+        int order = 1;\n+\n+        Contentlet contentlet1 = filtersUtil.createVanityUrl(title, site, uri,\n+                forwardTo, action, order, defaultLanguage.getId());\n+\n+        VanityUrl vanity1 = vanityUrlAPI.fromContentlet(contentletAPI.find(contentlet1.getInode(), user, false));\n+\n+        Assert.assertNotNull(vanity1);\n+        Assert.assertEquals(title, vanity1.getTitle());\n+        Assert.assertEquals(site, vanity1.getSite());\n+        Assert.assertEquals(uri, vanity1.getURI());\n+        Assert.assertEquals(forwardTo, vanity1.getForwardTo());\n+        Assert.assertEquals(action, vanity1.getAction());\n+        Assert.assertEquals(order, vanity1.getOrder());\n+\n+    }\n+    \n+    \n+    \n+    \n+    /**\n+     * Creates a vanity url but no publish it, gets it and checks there is not in cache.\n+     *\n+     * @see VanityUrlAPI\n+     */\n+    @Test\n+    public void working_vanities_do_not_resolve() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NDcyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/vanityurl/filters/VanityURLFilter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowMVrOGlcDFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowMVrOGlcDFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDAzNg==", "bodyText": "Codacy found an issue: Document empty method body", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910036", "createdAt": "2020-06-18T00:55:01Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/vanityurl/filters/VanityURLFilter.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.dotcms.vanityurl.filters;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotcms.vanityurl.business.VanityUrlAPI;\n+import com.dotcms.vanityurl.model.CachedVanityUrl;\n+import com.dotcms.vanityurl.model.VanityUrlResult;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.LanguageWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.filters.CMSUrlUtil;\n+import com.dotmarketing.filters.Constants;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+\n+/**\n+ * This Filter handles the vanity url logic\n+ * \n+ * @author Jonathan Gamba 7/27/17\n+ */\n+// todo: change this to an interceptor\n+public class VanityURLFilter implements Filter {\n+\n+\n+  private final CMSUrlUtil urlUtil;\n+  private final HostWebAPI hostWebAPI;\n+  private final LanguageWebAPI languageWebAPI;\n+  private final VanityUrlAPI vanityApi;\n+\n+  public VanityURLFilter() {\n+\n+    this(CMSUrlUtil.getInstance(), WebAPILocator.getHostWebAPI(), WebAPILocator.getLanguageWebAPI(),\n+       APILocator.getVanityUrlAPI());\n+  }\n+\n+  @VisibleForTesting\n+  protected VanityURLFilter( final CMSUrlUtil urlUtil, final HostWebAPI hostWebAPI,\n+      final LanguageWebAPI languageWebAPI, final VanityUrlAPI vanityApi) {\n+    this.vanityApi = vanityApi;\n+\n+    this.urlUtil = urlUtil;\n+    this.hostWebAPI = hostWebAPI;\n+    this.languageWebAPI = languageWebAPI;\n+  }\n+  @Override\n+  public void init(FilterConfig filterConfig) throws ServletException {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NDc2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/filters/VanityUrlFilterTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowM1rOGlcDGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowM1rOGlcDGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDA0MQ==", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910041", "createdAt": "2020-06-18T00:55:03Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/filters/VanityUrlFilterTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package com.dotcms.filters;\n+\n+import java.io.File;\n+import java.util.Collection;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotcms.datagen.SiteDataGen;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.response.MockHeaderResponse;\n+import com.dotcms.mock.response.MockHttpCaptureResponse;\n+import com.dotcms.mock.response.MockHttpResponse;\n+import com.dotcms.mock.response.MockHttpStatusResponse;\n+import com.dotcms.util.FiltersUtil;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotcms.vanityurl.business.VanityUrlAPI;\n+import com.dotcms.vanityurl.cache.VanityUrlCache;\n+import com.dotcms.vanityurl.filters.VanityURLFilter;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.FileUtil;\n+\n+public class VanityUrlFilterTest {\n+\n+\n+    private static ContentletAPI contentletAPI;\n+    private static VanityUrlAPI vanityUrlAPI;\n+    private static Host defaultHost;\n+    private static User user;\n+    private static Language defaultLanguage;\n+    private static VanityUrlCache cache;\n+    private static FiltersUtil filtersUtil;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+\n+        /* Default user */\n+        user = APILocator.systemUser();\n+\n+        contentletAPI = APILocator.getContentletAPI();\n+        vanityUrlAPI = APILocator.getVanityUrlAPI();\n+        filtersUtil = FiltersUtil.getInstance();\n+\n+        cache=CacheLocator.getVanityURLCache();\n+\n+        /* Default variables */\n+        defaultHost =  new SiteDataGen().nextPersisted();\n+        defaultLanguage = APILocator.getLanguageAPI().getDefaultLanguage();\n+    }\n+\n+\n+    /**\n+     * this tests that the vanityURL proxies requests that are made to different hosts.\n+     * In this case, we will request a url from dotcms and check to see that we get the results from dotcms.com\n+     */\n+\n+    @Test\n+    public void test_that_vanity_url_filter_handles_proxy_requests() throws Exception {\n+\n+\n+        String title = \"VanityURL\"  + System.currentTimeMillis();\n+        String site = defaultHost.getIdentifier();\n+        String uri = \"/testing_forward\" + System.currentTimeMillis();\n+        String forwardTo = \"https://dotcms.com\";\n+        int action = 200;\n+        int order = 1;\n+\n+        Contentlet contentlet1 = filtersUtil.createVanityUrl(title, site, uri,\n+                forwardTo, action, order, defaultLanguage.getId());\n+        filtersUtil.publishVanityUrl(contentlet1);\n+\n+        final HttpServletRequest request = new MockHttpRequest(defaultHost.getHostname(), uri).request();\n+  \n+        final File tmp = File.createTempFile(\"testingVanity\", \"test\");\n+        tmp.deleteOnExit();\n+        \n+        final HttpServletResponse response = new MockHttpCaptureResponse(new MockHttpResponse().response(), tmp).response();\n+\n+        final VanityURLFilter filter = new VanityURLFilter();\n+        \n+        filter.doFilter(request, response, null);\n+        \n+        assert(tmp.exists());\n+        String content = FileUtil.read(tmp);\n+        assert(content!=null);\n+        assert(content.contains(\"All rights reserved\"));\n+        assert(content.contains(\"<meta property=\\\"og:url\\\" content=\\\"https://dotcms.com/\\\">\"));\n+        \n+\n+    }\n+\n+    /**\n+     * this tests that vanity url redirects work as expected\n+     * @throws Exception\n+     */\n+    @Test\n+    public void test_that_vanity_url_filter_handles_redirects() throws Exception {\n+\n+\n+        String title = \"VanityURL\"  + System.currentTimeMillis();\n+        String site = defaultHost.getIdentifier();\n+        String uri = \"/testing_301\" + System.currentTimeMillis();\n+        String forwardTo = \"https://dotcms.com\";\n+        int action = 301;\n+        int order = 1;\n+\n+        Contentlet contentlet1 = filtersUtil.createVanityUrl(title, site, uri,\n+                forwardTo, action, order, defaultLanguage.getId());\n+        filtersUtil.publishVanityUrl(contentlet1);\n+\n+\n+        final HttpServletRequest request = new MockHttpRequest(defaultHost.getHostname(), uri).request();\n+        final HttpServletResponse response = new MockHttpStatusResponse(new MockHeaderResponse(new MockHttpResponse().response()).response()).response();\n+\n+        \n+        VanityURLFilter filter = new VanityURLFilter();\n+        \n+        filter.doFilter(request, response, null);\n+\n+        Collection<String> list=  response.getHeaderNames();\n+        assert(response.getHeader(\"Location\").equals(forwardTo));\n+        assert(response.getStatus()==301);\n+\n+    }\n+\n+    /**\n+     * this tests that vanity urls still work after clearing the vanity url cache\n+     * @throws Exception\n+     */\n+    @Test\n+    public void test_cache_flush_does_not_break_vanities() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NDc3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/filters/VanityUrlFilterTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowNFrOGlcDHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowNFrOGlcDHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDA0NQ==", "bodyText": "Codacy found an issue: Avoid unused local variables such as 'list'.", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910045", "createdAt": "2020-06-18T00:55:04Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/filters/VanityUrlFilterTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package com.dotcms.filters;\n+\n+import java.io.File;\n+import java.util.Collection;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotcms.datagen.SiteDataGen;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.response.MockHeaderResponse;\n+import com.dotcms.mock.response.MockHttpCaptureResponse;\n+import com.dotcms.mock.response.MockHttpResponse;\n+import com.dotcms.mock.response.MockHttpStatusResponse;\n+import com.dotcms.util.FiltersUtil;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotcms.vanityurl.business.VanityUrlAPI;\n+import com.dotcms.vanityurl.cache.VanityUrlCache;\n+import com.dotcms.vanityurl.filters.VanityURLFilter;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.FileUtil;\n+\n+public class VanityUrlFilterTest {\n+\n+\n+    private static ContentletAPI contentletAPI;\n+    private static VanityUrlAPI vanityUrlAPI;\n+    private static Host defaultHost;\n+    private static User user;\n+    private static Language defaultLanguage;\n+    private static VanityUrlCache cache;\n+    private static FiltersUtil filtersUtil;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+\n+        /* Default user */\n+        user = APILocator.systemUser();\n+\n+        contentletAPI = APILocator.getContentletAPI();\n+        vanityUrlAPI = APILocator.getVanityUrlAPI();\n+        filtersUtil = FiltersUtil.getInstance();\n+\n+        cache=CacheLocator.getVanityURLCache();\n+\n+        /* Default variables */\n+        defaultHost =  new SiteDataGen().nextPersisted();\n+        defaultLanguage = APILocator.getLanguageAPI().getDefaultLanguage();\n+    }\n+\n+\n+    /**\n+     * this tests that the vanityURL proxies requests that are made to different hosts.\n+     * In this case, we will request a url from dotcms and check to see that we get the results from dotcms.com\n+     */\n+\n+    @Test\n+    public void test_that_vanity_url_filter_handles_proxy_requests() throws Exception {\n+\n+\n+        String title = \"VanityURL\"  + System.currentTimeMillis();\n+        String site = defaultHost.getIdentifier();\n+        String uri = \"/testing_forward\" + System.currentTimeMillis();\n+        String forwardTo = \"https://dotcms.com\";\n+        int action = 200;\n+        int order = 1;\n+\n+        Contentlet contentlet1 = filtersUtil.createVanityUrl(title, site, uri,\n+                forwardTo, action, order, defaultLanguage.getId());\n+        filtersUtil.publishVanityUrl(contentlet1);\n+\n+        final HttpServletRequest request = new MockHttpRequest(defaultHost.getHostname(), uri).request();\n+  \n+        final File tmp = File.createTempFile(\"testingVanity\", \"test\");\n+        tmp.deleteOnExit();\n+        \n+        final HttpServletResponse response = new MockHttpCaptureResponse(new MockHttpResponse().response(), tmp).response();\n+\n+        final VanityURLFilter filter = new VanityURLFilter();\n+        \n+        filter.doFilter(request, response, null);\n+        \n+        assert(tmp.exists());\n+        String content = FileUtil.read(tmp);\n+        assert(content!=null);\n+        assert(content.contains(\"All rights reserved\"));\n+        assert(content.contains(\"<meta property=\\\"og:url\\\" content=\\\"https://dotcms.com/\\\">\"));\n+        \n+\n+    }\n+\n+    /**\n+     * this tests that vanity url redirects work as expected\n+     * @throws Exception\n+     */\n+    @Test\n+    public void test_that_vanity_url_filter_handles_redirects() throws Exception {\n+\n+\n+        String title = \"VanityURL\"  + System.currentTimeMillis();\n+        String site = defaultHost.getIdentifier();\n+        String uri = \"/testing_301\" + System.currentTimeMillis();\n+        String forwardTo = \"https://dotcms.com\";\n+        int action = 301;\n+        int order = 1;\n+\n+        Contentlet contentlet1 = filtersUtil.createVanityUrl(title, site, uri,\n+                forwardTo, action, order, defaultLanguage.getId());\n+        filtersUtil.publishVanityUrl(contentlet1);\n+\n+\n+        final HttpServletRequest request = new MockHttpRequest(defaultHost.getHostname(), uri).request();\n+        final HttpServletResponse response = new MockHttpStatusResponse(new MockHeaderResponse(new MockHttpResponse().response()).response()).response();\n+\n+        \n+        VanityURLFilter filter = new VanityURLFilter();\n+        \n+        filter.doFilter(request, response, null);\n+\n+        Collection<String> list=  response.getHeaderNames();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NDg0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowNVrOGlcDJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowNVrOGlcDJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDA1NQ==", "bodyText": "Codacy found an issue: Useless parentheses.", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910055", "createdAt": "2020-06-18T00:55:05Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "diffHunk": "@@ -457,499 +401,249 @@ public void checkInvalidActionTest()\n      */\n     @Test\n     @WrapInTransaction\n-    public void removeVanityURLDefaultLanguaguefromCacheTest() throws DotDataException, DotSecurityException {\n+    public void resolving_multilingual_vanities_with_default_language_unpublished() throws Exception {\n         long currentTime = System.currentTimeMillis();\n         Contentlet vanityURLContentletEnglish = null;\n         Contentlet vanityURLContentletSpanish = null;\n         final Language spanish = TestDataUtils.getSpanishLanguage();\n-        try{\n-            vanityURLContentletEnglish = filtersUtil\n-                    .createVanityUrl(\"test Vanity Url \" + currentTime, defaultHost.getIdentifier(),\n-                            \"/testing\" + currentTime, \"https://www.google.com\", 200, 1,\n-                            defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityURLContentletEnglish);\n-\n-            CachedVanityUrl vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletEnglish.getLanguageId(),\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n-\n-            vanityUrlAPI.getLiveCachedVanityUrl(\"/testing\"+currentTime, defaultHost, defaultLanguageId, user);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletEnglish.getLanguageId(),\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityURLCached.getVanityUrlId());\n-\n-            vanityURLContentletSpanish = contentletAPI.find(vanityURLContentletEnglish.getInode(), user, false);\n-            vanityURLContentletSpanish.setInode(\"\");\n-            vanityURLContentletSpanish.setLanguageId(spanish.getId());\n-            vanityURLContentletSpanish = contentletAPI.checkin(vanityURLContentletSpanish, user, false);\n-\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityUrlAPI.getLiveCachedVanityUrl(\"/testing\"+currentTime, defaultHost, spanish.getId(), user).getVanityUrlId());\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletSpanish.getLanguageId(),\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityURLCached.getVanityUrlId());\n-\n-            filtersUtil.publishVanityUrl(vanityURLContentletSpanish);\n-\n-            vanityUrlAPI.getLiveCachedVanityUrl(\"/testing\"+currentTime, defaultHost, spanish.getId(), user);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletSpanish.getLanguageId(),\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityURLCached.getVanityUrlId());\n-\n-            filtersUtil.unpublishVanityURL(vanityURLContentletEnglish);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletEnglish.getLanguageId(),\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n-\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletSpanish.getLanguageId(),\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityURLCached.getVanityUrlId());\n-\n-\n-        }finally{\n-\n-            try {\n-                contentletAPI.destroy(vanityURLContentletEnglish, user, false);\n-                contentletAPI.destroy(vanityURLContentletSpanish, user, false);\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Testing how the cache is working when publishing and unpublishing a VanityURL, we are\n-     * simulating URL requests that makes exact match with the URI of the VanityURL\n-     */\n-    @Test\n-    public void publishUnpublishVanityURLExact() throws DotDataException, DotSecurityException {\n-\n-        long currentTime = System.currentTimeMillis();\n-        publishUnpublishVanityURL(\"/testing\" + currentTime, \"/testing\" + currentTime,\n-                defaultHost.getIdentifier());\n-    }\n-\n-    /**\n-     * Testing how the cache is working when publishing and unpublishing a VanityURL, on this test\n-     * we created a VanityURL with a regex\n-     */\n-    @Test\n-    public void publishUnpublishVanityURLRegex() throws DotDataException, DotSecurityException {\n-\n-        long currentTime = System.currentTimeMillis();\n-        publishUnpublishVanityURL(\"/testing\" + currentTime + \"(.*)\",\n-                \"/testing\" + currentTime + \"/testing/index\", defaultHost.getIdentifier());\n-    }\n-\n-    /**\n-     * Testing how the cache is working when publishing and unpublishing a VanityURL, on this test\n-     * we created a VanityURL with a regex\n-     */\n-    @Test\n-    public void publishUnpublishVanityURLRegexSystemHost()\n-            throws DotDataException, DotSecurityException {\n-\n-        long currentTime = System.currentTimeMillis();\n-        publishUnpublishVanityURL(\"/testing\" + currentTime + \"(.*)\",\n-                \"/testing\" + currentTime + \"/testing/index\", Host.SYSTEM_HOST);\n-    }\n \n-    /**\n-     * Testing how the cache is working with multiple vanities using the same URI and the\n-     * combinations of existing vanities in other different Sites\n-     */\n-    @Test\n-    public void sameURLSystemHost()\n-            throws DotDataException, DotSecurityException {\n+        vanityURLContentletEnglish = filtersUtil\n+                .createVanityUrl(\"test Vanity Url \" + currentTime, defaultHost.getIdentifier(),\n+                        \"/testing\" + currentTime, \"https://www.google.com\", 200, 1,\n+                        defaultLanguage.getId());\n+        filtersUtil.publishVanityUrl(vanityURLContentletEnglish);\n \n-        Contentlet vanityURL = null;\n-        Contentlet vanityURL1 = null;\n-        Contentlet vanityURL2 = null;\n+        Optional<CachedVanityUrl> englishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, defaultLanguage);\n \n-        try {\n-            long currentTime = System.currentTimeMillis();\n-            String uri = \"/\" + currentTime + \"_testing\" + \"(.*)\";\n-            String requestedURL = \"/\" + currentTime + \"_testing\";\n-            final String nonExistingURL = \"/nonexisting/should404/index\" + currentTime;\n+        // we have vanity in english\n+        assert(englishVanity.isPresent());\n+        assert(englishVanity.get().response==200);\n \n-            //------------------------------------\n-            //Create a VanityURL for the default host\n-            //------------------------------------\n-            vanityURL = filtersUtil\n-                    .createVanityUrl(\"test Vanity Url \" + System.currentTimeMillis(),\n-                            defaultHost.getIdentifier(),\n-                            uri, \"https://www.google.com\", 200, 1, defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityURL);\n-\n-            //Should not exist in cache\n-            CachedVanityUrl vanityURLCached = vanityUrlCache\n-                    .get(\n-                        new CacheVanityKey(\n-                                vanityURL.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                                vanityURL.getLanguageId(),\n-                                vanityURL.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                        ));\n-            Assert.assertNull(vanityURLCached);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            defaultHost.getIdentifier(),\n-                            defaultLanguageId,\n-                            requestedURL\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n \n-            //Request a vanity with a URL with no matches\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(nonExistingURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //Check the cache, probably the Vanity we created was added in cache by the getLiveCachedVanityUrl\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL.getLanguageId(),\n-                            vanityURL.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //------------------------------------\n-            //Create the first VanityURL for the SYSTEM_HOST\n-            //------------------------------------\n-\n-            currentTime = System.currentTimeMillis();\n-            uri = \"/testing\" + currentTime + \"(.*)\";\n-            requestedURL = \"/testing\" + currentTime;\n-\n-            vanityURL1 = filtersUtil\n-                    .createVanityUrl(\"test Vanity Url \" + System.currentTimeMillis(),\n-                            Host.SYSTEM_HOST,\n-                            uri, \"https://www.google.com\", 200, 1, defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityURL1);\n-\n-            //Should not exist in cache\n-            vanityURLCached = vanityUrlCache\n-                    .get(\n-                            new CacheVanityKey(\n-                                    vanityURL1.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                                    vanityURL1.getLanguageId(),\n-                                    vanityURL1.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                            ));\n-            Assert.assertNull(vanityURLCached);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            defaultHost.getIdentifier(),\n-                            defaultLanguageId,\n-                            requestedURL\n-                    ));\n-\n-            Assert.assertNull(vanityURLCached);\n-\n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //Check the cache, probably the Vanity we created was added in cache by the getLiveCachedVanityUrl\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL1.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL1.getLanguageId(),\n-                            vanityURL1.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+        Optional<CachedVanityUrl> vanityFromCache = cache.getDirectMapping(\"/testing\" + currentTime, defaultHost, defaultLanguage);\n \n-            //------------------------------------\n-            //Create the second VanityURL  for the SYSTEM_HOST and with the same URI\n-            //------------------------------------\n-            vanityURL2 = filtersUtil\n-                    .createVanityUrl(\"test Vanity Url \" + System.currentTimeMillis(),\n-                            Host.SYSTEM_HOST,\n-                            uri, \"https://www.google.com\", 200, 1, defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityURL2);\n-\n-            //Should not exist in cache\n-            vanityURLCached = vanityUrlCache\n-                    .get(\n-                            new CacheVanityKey(\n-                                    vanityURL2.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                                    vanityURL2.getLanguageId(),\n-                                    vanityURL2.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                            ));\n-            Assert.assertNull(vanityURLCached);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            defaultHost.getIdentifier(),\n-                            defaultLanguageId,\n-                            requestedURL\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n+        assertEquals(englishVanity.get(),vanityFromCache.get());\n+        \n+        vanityURLContentletSpanish = contentletAPI.find(vanityURLContentletEnglish.getInode(), user, false);\n+        vanityURLContentletSpanish.setInode(\"\");\n+        vanityURLContentletSpanish.setLanguageId(spanish.getId());\n+        vanityURLContentletSpanish = contentletAPI.checkin(vanityURLContentletSpanish, user, false);\n \n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //Check the cache, probably the Vanity we created was added in cache by the getLiveCachedVanityUrl\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL2.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL2.getLanguageId(),\n-                            vanityURL2.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+        Optional<CachedVanityUrl> spanishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, spanish);\n \n-            //------------------------------------\n-            //Unpublish the VanityURL\n-            //------------------------------------\n-            vanityURL2.setIndexPolicy(IndexPolicy.FORCE);\n-            vanityURL2.setIndexPolicyDependencies(IndexPolicy.FORCE);\n-            filtersUtil.unpublishVanityURL(vanityURL2);\n-\n-            //Should NOT be in cache\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL2.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL2.getLanguageId(),\n-                            vanityURL2.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n+        // we do not have a spanish vanity because it is not published\n+        assert(!spanishVanity.isPresent());\n+        \n+        filtersUtil.publishVanityUrl(vanityURLContentletSpanish);\n \n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+        spanishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, spanish);\n \n-            //------------------------------------\n-            //Unpublish the VanityURL\n-            //------------------------------------\n-            vanityURL1.setIndexPolicy(IndexPolicy.FORCE);\n-            vanityURL1.setIndexPolicyDependencies(IndexPolicy.FORCE);\n-            filtersUtil.unpublishVanityURL(vanityURL1);\n-\n-            //Should NOT be in cache\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL1.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL1.getLanguageId(),\n-                            vanityURL1.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n+        // we have a spanish vanity because it is published\n+        assert(spanishVanity.isPresent());\n+        assertEquals(spanishVanity.get().vanityUrlId, englishVanity.get().vanityUrlId);\n+        assertEquals(spanishVanity.get().languageId,spanish.getId());\n+        \n+        // unpublish the english one\n+        filtersUtil.unpublishVanityURL(vanityURLContentletEnglish);\n+        \n+        \n+        englishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, defaultLanguage);\n+        assert(!englishVanity.isPresent());\n \n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+        \n+        spanishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, spanish);\n+        assert(spanishVanity.isPresent());\n \n-            //------------------------------------\n-            //Unpublish the VanityURL\n-            //------------------------------------\n-            vanityURL2.setIndexPolicy(IndexPolicy.FORCE);\n-            vanityURL2.setIndexPolicyDependencies(IndexPolicy.FORCE);\n-            filtersUtil.publishVanityUrl(vanityURL2);\n-\n-            //Should NOT be in cache\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL2.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL2.getLanguageId(),\n-                            vanityURL2.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n \n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+    }\n \n+    \n \n-        } finally {\n+    /**\n+     * Testing how the cache is working with multiple vanities using the same URI and the\n+     * combinations of existing vanities in other different Sites\n+     */\n+    @Test\n+    public void does_a_site_specific_vanity_override_system_host_vanity()\n+            throws Exception {\n+\n+        DefaultVanityUrl siteVanity = null;\n+        DefaultVanityUrl systemHostVanity = null;\n+\n+\n+\n+        final long currentTime = System.currentTimeMillis();\n+        final String uri = \"/\" + currentTime + \"_testing\" + \"(.*)\";\n+        final String requestedURL = \"/\" + currentTime + \"_testing\" + \"RANDOM_CHARACTERS\";\n+        final String nonExistingURL = \"/nonexisting/should404/index\" + currentTime;\n+\n+        //------------------------------------\n+        //Create a VanityURL for the default host\n+        //------------------------------------\n+        siteVanity = filtersUtil\n+                .createVanityUrl(\"test Vanity Url \" + System.currentTimeMillis(),\n+                        defaultHost.getIdentifier(),\n+                        uri, \"https://www.google.com\", 200, 1, defaultLanguage.getId());\n+        filtersUtil.publishVanityUrl(siteVanity);\n+        \n+        // nothing in cache\n+        List<CachedVanityUrl> siteCache= cache.getSiteMappings(defaultHost, defaultLanguage);\n+        assert( siteCache==null);\n+        \n+        //None of these exist in cache\n+        Optional<CachedVanityUrl> vanityURLCached = cache.getDirectMapping(uri, defaultHost, defaultLanguage);\n+        assert(vanityURLCached ==null );\n+        vanityURLCached = cache.getDirectMapping(requestedURL, defaultHost, defaultLanguage);\n+        assert(vanityURLCached ==null );\n+        vanityURLCached = cache.getDirectMapping(nonExistingURL, defaultHost, defaultLanguage);\n+        assert(vanityURLCached ==null );\n+\n+        \n+        // one hit loads cache\n+        vanityURLCached= vanityUrlAPI.resolveVanityUrl(requestedURL, defaultHost, defaultLanguage);\n+        assert( vanityURLCached.isPresent());\n+        \n+        siteCache= cache.getSiteMappings(defaultHost, defaultLanguage);\n+        \n+        // it lives in the host cache\n+        assert( siteCache!=null);\n+        assert(siteCache.contains(vanityURLCached.get()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 1156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NDg5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowNlrOGlcDLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowNlrOGlcDLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDA2MQ==", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910061", "createdAt": "2020-06-18T00:55:06Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "diffHunk": "@@ -457,499 +401,249 @@ public void checkInvalidActionTest()\n      */\n     @Test\n     @WrapInTransaction\n-    public void removeVanityURLDefaultLanguaguefromCacheTest() throws DotDataException, DotSecurityException {\n+    public void resolving_multilingual_vanities_with_default_language_unpublished() throws Exception {\n         long currentTime = System.currentTimeMillis();\n         Contentlet vanityURLContentletEnglish = null;\n         Contentlet vanityURLContentletSpanish = null;\n         final Language spanish = TestDataUtils.getSpanishLanguage();\n-        try{\n-            vanityURLContentletEnglish = filtersUtil\n-                    .createVanityUrl(\"test Vanity Url \" + currentTime, defaultHost.getIdentifier(),\n-                            \"/testing\" + currentTime, \"https://www.google.com\", 200, 1,\n-                            defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityURLContentletEnglish);\n-\n-            CachedVanityUrl vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletEnglish.getLanguageId(),\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n-\n-            vanityUrlAPI.getLiveCachedVanityUrl(\"/testing\"+currentTime, defaultHost, defaultLanguageId, user);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletEnglish.getLanguageId(),\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityURLCached.getVanityUrlId());\n-\n-            vanityURLContentletSpanish = contentletAPI.find(vanityURLContentletEnglish.getInode(), user, false);\n-            vanityURLContentletSpanish.setInode(\"\");\n-            vanityURLContentletSpanish.setLanguageId(spanish.getId());\n-            vanityURLContentletSpanish = contentletAPI.checkin(vanityURLContentletSpanish, user, false);\n-\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityUrlAPI.getLiveCachedVanityUrl(\"/testing\"+currentTime, defaultHost, spanish.getId(), user).getVanityUrlId());\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletSpanish.getLanguageId(),\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityURLCached.getVanityUrlId());\n-\n-            filtersUtil.publishVanityUrl(vanityURLContentletSpanish);\n-\n-            vanityUrlAPI.getLiveCachedVanityUrl(\"/testing\"+currentTime, defaultHost, spanish.getId(), user);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletSpanish.getLanguageId(),\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityURLCached.getVanityUrlId());\n-\n-            filtersUtil.unpublishVanityURL(vanityURLContentletEnglish);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletEnglish.getLanguageId(),\n-                            vanityURLContentletEnglish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n-\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURLContentletSpanish.getLanguageId(),\n-                            vanityURLContentletSpanish.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL, vanityURLCached.getVanityUrlId());\n-\n-\n-        }finally{\n-\n-            try {\n-                contentletAPI.destroy(vanityURLContentletEnglish, user, false);\n-                contentletAPI.destroy(vanityURLContentletSpanish, user, false);\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * Testing how the cache is working when publishing and unpublishing a VanityURL, we are\n-     * simulating URL requests that makes exact match with the URI of the VanityURL\n-     */\n-    @Test\n-    public void publishUnpublishVanityURLExact() throws DotDataException, DotSecurityException {\n-\n-        long currentTime = System.currentTimeMillis();\n-        publishUnpublishVanityURL(\"/testing\" + currentTime, \"/testing\" + currentTime,\n-                defaultHost.getIdentifier());\n-    }\n-\n-    /**\n-     * Testing how the cache is working when publishing and unpublishing a VanityURL, on this test\n-     * we created a VanityURL with a regex\n-     */\n-    @Test\n-    public void publishUnpublishVanityURLRegex() throws DotDataException, DotSecurityException {\n-\n-        long currentTime = System.currentTimeMillis();\n-        publishUnpublishVanityURL(\"/testing\" + currentTime + \"(.*)\",\n-                \"/testing\" + currentTime + \"/testing/index\", defaultHost.getIdentifier());\n-    }\n-\n-    /**\n-     * Testing how the cache is working when publishing and unpublishing a VanityURL, on this test\n-     * we created a VanityURL with a regex\n-     */\n-    @Test\n-    public void publishUnpublishVanityURLRegexSystemHost()\n-            throws DotDataException, DotSecurityException {\n-\n-        long currentTime = System.currentTimeMillis();\n-        publishUnpublishVanityURL(\"/testing\" + currentTime + \"(.*)\",\n-                \"/testing\" + currentTime + \"/testing/index\", Host.SYSTEM_HOST);\n-    }\n \n-    /**\n-     * Testing how the cache is working with multiple vanities using the same URI and the\n-     * combinations of existing vanities in other different Sites\n-     */\n-    @Test\n-    public void sameURLSystemHost()\n-            throws DotDataException, DotSecurityException {\n+        vanityURLContentletEnglish = filtersUtil\n+                .createVanityUrl(\"test Vanity Url \" + currentTime, defaultHost.getIdentifier(),\n+                        \"/testing\" + currentTime, \"https://www.google.com\", 200, 1,\n+                        defaultLanguage.getId());\n+        filtersUtil.publishVanityUrl(vanityURLContentletEnglish);\n \n-        Contentlet vanityURL = null;\n-        Contentlet vanityURL1 = null;\n-        Contentlet vanityURL2 = null;\n+        Optional<CachedVanityUrl> englishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, defaultLanguage);\n \n-        try {\n-            long currentTime = System.currentTimeMillis();\n-            String uri = \"/\" + currentTime + \"_testing\" + \"(.*)\";\n-            String requestedURL = \"/\" + currentTime + \"_testing\";\n-            final String nonExistingURL = \"/nonexisting/should404/index\" + currentTime;\n+        // we have vanity in english\n+        assert(englishVanity.isPresent());\n+        assert(englishVanity.get().response==200);\n \n-            //------------------------------------\n-            //Create a VanityURL for the default host\n-            //------------------------------------\n-            vanityURL = filtersUtil\n-                    .createVanityUrl(\"test Vanity Url \" + System.currentTimeMillis(),\n-                            defaultHost.getIdentifier(),\n-                            uri, \"https://www.google.com\", 200, 1, defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityURL);\n-\n-            //Should not exist in cache\n-            CachedVanityUrl vanityURLCached = vanityUrlCache\n-                    .get(\n-                        new CacheVanityKey(\n-                                vanityURL.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                                vanityURL.getLanguageId(),\n-                                vanityURL.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                        ));\n-            Assert.assertNull(vanityURLCached);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            defaultHost.getIdentifier(),\n-                            defaultLanguageId,\n-                            requestedURL\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n \n-            //Request a vanity with a URL with no matches\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(nonExistingURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //Check the cache, probably the Vanity we created was added in cache by the getLiveCachedVanityUrl\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL.getLanguageId(),\n-                            vanityURL.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //------------------------------------\n-            //Create the first VanityURL for the SYSTEM_HOST\n-            //------------------------------------\n-\n-            currentTime = System.currentTimeMillis();\n-            uri = \"/testing\" + currentTime + \"(.*)\";\n-            requestedURL = \"/testing\" + currentTime;\n-\n-            vanityURL1 = filtersUtil\n-                    .createVanityUrl(\"test Vanity Url \" + System.currentTimeMillis(),\n-                            Host.SYSTEM_HOST,\n-                            uri, \"https://www.google.com\", 200, 1, defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityURL1);\n-\n-            //Should not exist in cache\n-            vanityURLCached = vanityUrlCache\n-                    .get(\n-                            new CacheVanityKey(\n-                                    vanityURL1.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                                    vanityURL1.getLanguageId(),\n-                                    vanityURL1.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                            ));\n-            Assert.assertNull(vanityURLCached);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            defaultHost.getIdentifier(),\n-                            defaultLanguageId,\n-                            requestedURL\n-                    ));\n-\n-            Assert.assertNull(vanityURLCached);\n-\n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //Check the cache, probably the Vanity we created was added in cache by the getLiveCachedVanityUrl\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL1.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL1.getLanguageId(),\n-                            vanityURL1.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+        Optional<CachedVanityUrl> vanityFromCache = cache.getDirectMapping(\"/testing\" + currentTime, defaultHost, defaultLanguage);\n \n-            //------------------------------------\n-            //Create the second VanityURL  for the SYSTEM_HOST and with the same URI\n-            //------------------------------------\n-            vanityURL2 = filtersUtil\n-                    .createVanityUrl(\"test Vanity Url \" + System.currentTimeMillis(),\n-                            Host.SYSTEM_HOST,\n-                            uri, \"https://www.google.com\", 200, 1, defaultLanguageId);\n-            filtersUtil.publishVanityUrl(vanityURL2);\n-\n-            //Should not exist in cache\n-            vanityURLCached = vanityUrlCache\n-                    .get(\n-                            new CacheVanityKey(\n-                                    vanityURL2.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                                    vanityURL2.getLanguageId(),\n-                                    vanityURL2.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                            ));\n-            Assert.assertNull(vanityURLCached);\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            defaultHost.getIdentifier(),\n-                            defaultLanguageId,\n-                            requestedURL\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n+        assertEquals(englishVanity.get(),vanityFromCache.get());\n+        \n+        vanityURLContentletSpanish = contentletAPI.find(vanityURLContentletEnglish.getInode(), user, false);\n+        vanityURLContentletSpanish.setInode(\"\");\n+        vanityURLContentletSpanish.setLanguageId(spanish.getId());\n+        vanityURLContentletSpanish = contentletAPI.checkin(vanityURLContentletSpanish, user, false);\n \n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n-\n-            //Check the cache, probably the Vanity we created was added in cache by the getLiveCachedVanityUrl\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL2.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL2.getLanguageId(),\n-                            vanityURL2.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+        Optional<CachedVanityUrl> spanishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, spanish);\n \n-            //------------------------------------\n-            //Unpublish the VanityURL\n-            //------------------------------------\n-            vanityURL2.setIndexPolicy(IndexPolicy.FORCE);\n-            vanityURL2.setIndexPolicyDependencies(IndexPolicy.FORCE);\n-            filtersUtil.unpublishVanityURL(vanityURL2);\n-\n-            //Should NOT be in cache\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL2.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL2.getLanguageId(),\n-                            vanityURL2.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n+        // we do not have a spanish vanity because it is not published\n+        assert(!spanishVanity.isPresent());\n+        \n+        filtersUtil.publishVanityUrl(vanityURLContentletSpanish);\n \n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+        spanishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, spanish);\n \n-            //------------------------------------\n-            //Unpublish the VanityURL\n-            //------------------------------------\n-            vanityURL1.setIndexPolicy(IndexPolicy.FORCE);\n-            vanityURL1.setIndexPolicyDependencies(IndexPolicy.FORCE);\n-            filtersUtil.unpublishVanityURL(vanityURL1);\n-\n-            //Should NOT be in cache\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL1.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL1.getLanguageId(),\n-                            vanityURL1.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n+        // we have a spanish vanity because it is published\n+        assert(spanishVanity.isPresent());\n+        assertEquals(spanishVanity.get().vanityUrlId, englishVanity.get().vanityUrlId);\n+        assertEquals(spanishVanity.get().languageId,spanish.getId());\n+        \n+        // unpublish the english one\n+        filtersUtil.unpublishVanityURL(vanityURLContentletEnglish);\n+        \n+        \n+        englishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, defaultLanguage);\n+        assert(!englishVanity.isPresent());\n \n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+        \n+        spanishVanity = vanityUrlAPI.resolveVanityUrl(\"/testing\" + currentTime, defaultHost, spanish);\n+        assert(spanishVanity.isPresent());\n \n-            //------------------------------------\n-            //Unpublish the VanityURL\n-            //------------------------------------\n-            vanityURL2.setIndexPolicy(IndexPolicy.FORCE);\n-            vanityURL2.setIndexPolicyDependencies(IndexPolicy.FORCE);\n-            filtersUtil.publishVanityUrl(vanityURL2);\n-\n-            //Should NOT be in cache\n-            vanityURLCached = vanityUrlCache.get(\n-                    new CacheVanityKey(\n-                            vanityURL2.getStringProperty(VanityUrlContentType.SITE_FIELD_VAR),\n-                            vanityURL2.getLanguageId(),\n-                            vanityURL2.getStringProperty(VanityUrlContentType.URI_FIELD_VAR)\n-                    ));\n-            Assert.assertNull(vanityURLCached);\n \n-            //Request a vanity with a URL with a match\n-            vanityURLCached = vanityUrlAPI\n-                    .getLiveCachedVanityUrl(requestedURL, defaultHost, defaultLanguageId, user);\n-            Assert.assertNotNull(vanityURLCached);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,\n-                    vanityURLCached.getVanityUrlId());\n+    }\n \n+    \n \n-        } finally {\n+    /**\n+     * Testing how the cache is working with multiple vanities using the same URI and the\n+     * combinations of existing vanities in other different Sites\n+     */\n+    @Test\n+    public void does_a_site_specific_vanity_override_system_host_vanity()\n+            throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 1114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NDkxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/datagen/VanityUrlDataGen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowN1rOGlcDLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowN1rOGlcDLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDA2Mw==", "bodyText": "Codacy found an issue: Field folder has the same name as a method", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910063", "createdAt": "2020-06-18T00:55:07Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/datagen/VanityUrlDataGen.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package com.dotcms.datagen;\n+\n+import com.dotcms.vanityurl.business.VanityUrlAPI;\n+import com.dotcms.vanityurl.model.DefaultVanityUrl;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.contentlet.model.IndexPolicy;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+\n+import io.vavr.control.Try;\n+\n+/**\n+ * Class used to create {@link Contentlet} objects of type {@link com.dotcms.vanityurl.model.VanityUrl} for test purposes\n+ *\n+ * @author Nollymar Longa\n+ */\n+public class VanityUrlDataGen extends ContentletDataGen {\n+\n+\n+\n+  private String uri;\n+  private String forwardTo;\n+  private int action;\n+  private int order;\n+  private long language;\n+  private String title;\n+  private Folder folder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NDkyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowOFrOGlcDMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowOFrOGlcDMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDA2NQ==", "bodyText": "Codacy found an issue: Useless parentheses.", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910065", "createdAt": "2020-06-18T00:55:08Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "diffHunk": "@@ -60,271 +61,255 @@ public static void prepare() throws Exception {\n         /* Default user */\n         user = APILocator.systemUser();\n \n-        /* APIs initialization */\n-        hostAPI = APILocator.getHostAPI();\n         contentletAPI = APILocator.getContentletAPI();\n         vanityUrlAPI = APILocator.getVanityUrlAPI();\n         filtersUtil = FiltersUtil.getInstance();\n \n-        /* Load Cache */\n-        vanityUrlCache = CacheLocator.getVanityURLCache();\n+        cache=CacheLocator.getVanityURLCache();\n \n         /* Default variables */\n-        defaultHost = hostAPI.findDefaultHost(user, false);\n-        defaultLanguageId = APILocator.getLanguageAPI().getDefaultLanguage().getId();\n+        defaultHost =  new SiteDataGen().nextPersisted();\n+        defaultLanguage = APILocator.getLanguageAPI().getDefaultLanguage();\n     }\n \n+    \n+    \n     /**\n      * Creates a vanity url but no publish it, gets it and checks there is not in cache.\n      *\n      * @see VanityUrlAPI\n      */\n     @Test\n-    public void getWorkingVanityUrl() {\n+    public void testing_the_from_contentlet_method() throws Exception {\n+\n+\n+        long i = System.currentTimeMillis();\n+        String title = \"VanityURL\" + i;\n+        String site = defaultHost.getIdentifier();\n+        String uri = \"/test1_\" + i;\n+        String forwardTo = \"/about-us/\" + CMSFilter.CMS_INDEX_PAGE;\n+        int action = 200;\n+        int order = 1;\n+\n+        Contentlet contentlet1 = filtersUtil.createVanityUrl(title, site, uri,\n+                forwardTo, action, order, defaultLanguage.getId());\n+\n+        VanityUrl vanity1 = vanityUrlAPI.fromContentlet(contentletAPI.find(contentlet1.getInode(), user, false));\n+\n+        Assert.assertNotNull(vanity1);\n+        Assert.assertEquals(title, vanity1.getTitle());\n+        Assert.assertEquals(site, vanity1.getSite());\n+        Assert.assertEquals(uri, vanity1.getURI());\n+        Assert.assertEquals(forwardTo, vanity1.getForwardTo());\n+        Assert.assertEquals(action, vanity1.getAction());\n+        Assert.assertEquals(order, vanity1.getOrder());\n+\n+    }\n+    \n+    \n+    \n+    \n+    /**\n+     * Creates a vanity url but no publish it, gets it and checks there is not in cache.\n+     *\n+     * @see VanityUrlAPI\n+     */\n+    @Test\n+    public void working_vanities_do_not_resolve() throws Exception {\n \n         Contentlet contentlet1 = null;\n \n-        try {\n-            long i = System.currentTimeMillis();\n-            String title = \"VanityURL\" + i;\n-            String site = defaultHost.getIdentifier();\n-            String uri = \"/test1_\" + i;\n-            String forwardTo = \"/about-us/\" + CMSFilter.CMS_INDEX_PAGE;\n-            int action = 200;\n-            int order = 1;\n-\n-            contentlet1 = filtersUtil.createVanityUrl(title, site, uri,\n-                    forwardTo, action, order, defaultLanguageId);\n-\n-            VanityUrl vanity1 = vanityUrlAPI.getVanityUrlFromContentlet(contentletAPI.find(contentlet1.getInode(), user, false));\n-\n-            Assert.assertNotNull(vanity1);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,vanity1.getInode());\n-            Assert.assertEquals(title, vanity1.getTitle());\n-            Assert.assertEquals(site, vanity1.getSite());\n-            Assert.assertEquals(uri, vanity1.getURI());\n-            Assert.assertEquals(forwardTo, vanity1.getForwardTo());\n-            Assert.assertEquals(action, vanity1.getAction());\n-\n-            CachedVanityUrl vanityCached = vanityUrlAPI.getLiveCachedVanityUrl(uri, defaultHost, defaultLanguageId, user);\n-\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL,vanityCached.getVanityUrlId());\n-\n-        } catch (DotDataException | DotSecurityException e) {\n-            e.printStackTrace();\n-            fail();\n-        } finally {\n-            try {\n-                if (contentlet1 != null) {\n-                    contentletAPI.destroy(contentlet1, user, false );\n-                }\n-            } catch (Exception e) {\n-                Logger.error(this.getClass(), \"Error cleaning up Vanity Url Links\");\n-            }\n-        }\n+\n+        long i = System.currentTimeMillis();\n+        String title = \"VanityURL\" + i;\n+        String site = defaultHost.getIdentifier();\n+        String uri = \"/test1_\" + i;\n+        String forwardTo = \"/about-us/\" + CMSFilter.CMS_INDEX_PAGE;\n+        int action = 200;\n+        int order = 1;\n+\n+        contentlet1 = filtersUtil.createVanityUrl(title, site, uri,\n+                forwardTo, action, order, defaultLanguage.getId());\n+\n+        \n+        \n+        Optional<CachedVanityUrl> optionalCache = cache.getDirectMapping(uri, defaultHost, defaultLanguage);\n+        assert(optionalCache==null );\n+        \n+\n+        Optional<CachedVanityUrl> vanityCached = vanityUrlAPI.resolveVanityUrl(uri, defaultHost, defaultLanguage);\n+\n+        // it is not here because it is not published\n+        assert(!vanityCached.isPresent());\n+\n+            \n+        // it is stored in the cache as an Optional.empty();\n+        optionalCache = cache.getDirectMapping(uri, defaultHost, defaultLanguage);\n+        \n+        assert(optionalCache!=null && !optionalCache.isPresent());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NDk1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotmarketing/filters/FiltersTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowOVrOGlcDNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NTowOVrOGlcDNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDA2OA==", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910068", "createdAt": "2020-06-18T00:55:09Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/filters/FiltersTest.java", "diffHunk": "@@ -694,7 +657,7 @@ public void shouldRedirect401() throws IOException {\n      * /products/\n      */\n     @Test\n-    public void shouldRedirectToFolderIndex() throws IOException {\n+    public void shouldRedirectToFolderIndex() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 352}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NDk4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/filters/VanityUrlFilterTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxMFrOGlcDOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxMFrOGlcDOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDA3Mg==", "bodyText": "Codacy found an issue: Avoid unused private fields such as 'contentletAPI'.", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910072", "createdAt": "2020-06-18T00:55:10Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/filters/VanityUrlFilterTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package com.dotcms.filters;\n+\n+import java.io.File;\n+import java.util.Collection;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotcms.datagen.SiteDataGen;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.response.MockHeaderResponse;\n+import com.dotcms.mock.response.MockHttpCaptureResponse;\n+import com.dotcms.mock.response.MockHttpResponse;\n+import com.dotcms.mock.response.MockHttpStatusResponse;\n+import com.dotcms.util.FiltersUtil;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotcms.vanityurl.business.VanityUrlAPI;\n+import com.dotcms.vanityurl.cache.VanityUrlCache;\n+import com.dotcms.vanityurl.filters.VanityURLFilter;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.FileUtil;\n+\n+public class VanityUrlFilterTest {\n+\n+\n+    private static ContentletAPI contentletAPI;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NTAxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxMVrOGlcDOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxMVrOGlcDOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDA3NQ==", "bodyText": "Codacy found an issue: Avoid unused imports such as 'org.junit.Assert.assertNull'", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910075", "createdAt": "2020-06-18T00:55:11Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "diffHunk": "@@ -2,17 +2,22 @@\n \n \n import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NTA0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/filters/VanityUrlFilterTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxMlrOGlcDPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxMlrOGlcDPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDA3OA==", "bodyText": "Codacy found an issue: Useless parentheses.", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910078", "createdAt": "2020-06-18T00:55:12Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/filters/VanityUrlFilterTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package com.dotcms.filters;\n+\n+import java.io.File;\n+import java.util.Collection;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotcms.datagen.SiteDataGen;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.response.MockHeaderResponse;\n+import com.dotcms.mock.response.MockHttpCaptureResponse;\n+import com.dotcms.mock.response.MockHttpResponse;\n+import com.dotcms.mock.response.MockHttpStatusResponse;\n+import com.dotcms.util.FiltersUtil;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotcms.vanityurl.business.VanityUrlAPI;\n+import com.dotcms.vanityurl.cache.VanityUrlCache;\n+import com.dotcms.vanityurl.filters.VanityURLFilter;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.FileUtil;\n+\n+public class VanityUrlFilterTest {\n+\n+\n+    private static ContentletAPI contentletAPI;\n+    private static VanityUrlAPI vanityUrlAPI;\n+    private static Host defaultHost;\n+    private static User user;\n+    private static Language defaultLanguage;\n+    private static VanityUrlCache cache;\n+    private static FiltersUtil filtersUtil;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+\n+        /* Default user */\n+        user = APILocator.systemUser();\n+\n+        contentletAPI = APILocator.getContentletAPI();\n+        vanityUrlAPI = APILocator.getVanityUrlAPI();\n+        filtersUtil = FiltersUtil.getInstance();\n+\n+        cache=CacheLocator.getVanityURLCache();\n+\n+        /* Default variables */\n+        defaultHost =  new SiteDataGen().nextPersisted();\n+        defaultLanguage = APILocator.getLanguageAPI().getDefaultLanguage();\n+    }\n+\n+\n+    /**\n+     * this tests that the vanityURL proxies requests that are made to different hosts.\n+     * In this case, we will request a url from dotcms and check to see that we get the results from dotcms.com\n+     */\n+\n+    @Test\n+    public void test_that_vanity_url_filter_handles_proxy_requests() throws Exception {\n+\n+\n+        String title = \"VanityURL\"  + System.currentTimeMillis();\n+        String site = defaultHost.getIdentifier();\n+        String uri = \"/testing_forward\" + System.currentTimeMillis();\n+        String forwardTo = \"https://dotcms.com\";\n+        int action = 200;\n+        int order = 1;\n+\n+        Contentlet contentlet1 = filtersUtil.createVanityUrl(title, site, uri,\n+                forwardTo, action, order, defaultLanguage.getId());\n+        filtersUtil.publishVanityUrl(contentlet1);\n+\n+        final HttpServletRequest request = new MockHttpRequest(defaultHost.getHostname(), uri).request();\n+  \n+        final File tmp = File.createTempFile(\"testingVanity\", \"test\");\n+        tmp.deleteOnExit();\n+        \n+        final HttpServletResponse response = new MockHttpCaptureResponse(new MockHttpResponse().response(), tmp).response();\n+\n+        final VanityURLFilter filter = new VanityURLFilter();\n+        \n+        filter.doFilter(request, response, null);\n+        \n+        assert(tmp.exists());\n+        String content = FileUtil.read(tmp);\n+        assert(content!=null);\n+        assert(content.contains(\"All rights reserved\"));\n+        assert(content.contains(\"<meta property=\\\"og:url\\\" content=\\\"https://dotcms.com/\\\">\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NTA4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/filters/VanityUrlFilterTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxM1rOGlcDRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxM1rOGlcDRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDA4Ng==", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910086", "createdAt": "2020-06-18T00:55:13Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/filters/VanityUrlFilterTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package com.dotcms.filters;\n+\n+import java.io.File;\n+import java.util.Collection;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotcms.datagen.SiteDataGen;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.response.MockHeaderResponse;\n+import com.dotcms.mock.response.MockHttpCaptureResponse;\n+import com.dotcms.mock.response.MockHttpResponse;\n+import com.dotcms.mock.response.MockHttpStatusResponse;\n+import com.dotcms.util.FiltersUtil;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotcms.vanityurl.business.VanityUrlAPI;\n+import com.dotcms.vanityurl.cache.VanityUrlCache;\n+import com.dotcms.vanityurl.filters.VanityURLFilter;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.FileUtil;\n+\n+public class VanityUrlFilterTest {\n+\n+\n+    private static ContentletAPI contentletAPI;\n+    private static VanityUrlAPI vanityUrlAPI;\n+    private static Host defaultHost;\n+    private static User user;\n+    private static Language defaultLanguage;\n+    private static VanityUrlCache cache;\n+    private static FiltersUtil filtersUtil;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+\n+        /* Default user */\n+        user = APILocator.systemUser();\n+\n+        contentletAPI = APILocator.getContentletAPI();\n+        vanityUrlAPI = APILocator.getVanityUrlAPI();\n+        filtersUtil = FiltersUtil.getInstance();\n+\n+        cache=CacheLocator.getVanityURLCache();\n+\n+        /* Default variables */\n+        defaultHost =  new SiteDataGen().nextPersisted();\n+        defaultLanguage = APILocator.getLanguageAPI().getDefaultLanguage();\n+    }\n+\n+\n+    /**\n+     * this tests that the vanityURL proxies requests that are made to different hosts.\n+     * In this case, we will request a url from dotcms and check to see that we get the results from dotcms.com\n+     */\n+\n+    @Test\n+    public void test_that_vanity_url_filter_handles_proxy_requests() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NTEzOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxNFrOGlcDTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxNFrOGlcDTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDA5Mg==", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910092", "createdAt": "2020-06-18T00:55:14Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "diffHunk": "@@ -60,271 +61,255 @@ public static void prepare() throws Exception {\n         /* Default user */\n         user = APILocator.systemUser();\n \n-        /* APIs initialization */\n-        hostAPI = APILocator.getHostAPI();\n         contentletAPI = APILocator.getContentletAPI();\n         vanityUrlAPI = APILocator.getVanityUrlAPI();\n         filtersUtil = FiltersUtil.getInstance();\n \n-        /* Load Cache */\n-        vanityUrlCache = CacheLocator.getVanityURLCache();\n+        cache=CacheLocator.getVanityURLCache();\n \n         /* Default variables */\n-        defaultHost = hostAPI.findDefaultHost(user, false);\n-        defaultLanguageId = APILocator.getLanguageAPI().getDefaultLanguage().getId();\n+        defaultHost =  new SiteDataGen().nextPersisted();\n+        defaultLanguage = APILocator.getLanguageAPI().getDefaultLanguage();\n     }\n \n+    \n+    \n     /**\n      * Creates a vanity url but no publish it, gets it and checks there is not in cache.\n      *\n      * @see VanityUrlAPI\n      */\n     @Test\n-    public void getWorkingVanityUrl() {\n+    public void testing_the_from_contentlet_method() throws Exception {\n+\n+\n+        long i = System.currentTimeMillis();\n+        String title = \"VanityURL\" + i;\n+        String site = defaultHost.getIdentifier();\n+        String uri = \"/test1_\" + i;\n+        String forwardTo = \"/about-us/\" + CMSFilter.CMS_INDEX_PAGE;\n+        int action = 200;\n+        int order = 1;\n+\n+        Contentlet contentlet1 = filtersUtil.createVanityUrl(title, site, uri,\n+                forwardTo, action, order, defaultLanguage.getId());\n+\n+        VanityUrl vanity1 = vanityUrlAPI.fromContentlet(contentletAPI.find(contentlet1.getInode(), user, false));\n+\n+        Assert.assertNotNull(vanity1);\n+        Assert.assertEquals(title, vanity1.getTitle());\n+        Assert.assertEquals(site, vanity1.getSite());\n+        Assert.assertEquals(uri, vanity1.getURI());\n+        Assert.assertEquals(forwardTo, vanity1.getForwardTo());\n+        Assert.assertEquals(action, vanity1.getAction());\n+        Assert.assertEquals(order, vanity1.getOrder());\n+\n+    }\n+    \n+    \n+    \n+    \n+    /**\n+     * Creates a vanity url but no publish it, gets it and checks there is not in cache.\n+     *\n+     * @see VanityUrlAPI\n+     */\n+    @Test\n+    public void working_vanities_do_not_resolve() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NTE0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/filters/VanityUrlFilterTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxNVrOGlcDTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxNVrOGlcDTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDA5NA==", "bodyText": "Codacy found an issue: JUnit tests should include assert() or fail()", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910094", "createdAt": "2020-06-18T00:55:15Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/filters/VanityUrlFilterTest.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package com.dotcms.filters;\n+\n+import java.io.File;\n+import java.util.Collection;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import com.dotcms.datagen.SiteDataGen;\n+import com.dotcms.mock.request.MockHttpRequest;\n+import com.dotcms.mock.response.MockHeaderResponse;\n+import com.dotcms.mock.response.MockHttpCaptureResponse;\n+import com.dotcms.mock.response.MockHttpResponse;\n+import com.dotcms.mock.response.MockHttpStatusResponse;\n+import com.dotcms.util.FiltersUtil;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotcms.vanityurl.business.VanityUrlAPI;\n+import com.dotcms.vanityurl.cache.VanityUrlCache;\n+import com.dotcms.vanityurl.filters.VanityURLFilter;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.portlets.contentlet.business.ContentletAPI;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.FileUtil;\n+\n+public class VanityUrlFilterTest {\n+\n+\n+    private static ContentletAPI contentletAPI;\n+    private static VanityUrlAPI vanityUrlAPI;\n+    private static Host defaultHost;\n+    private static User user;\n+    private static Language defaultLanguage;\n+    private static VanityUrlCache cache;\n+    private static FiltersUtil filtersUtil;\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+\n+        /* Default user */\n+        user = APILocator.systemUser();\n+\n+        contentletAPI = APILocator.getContentletAPI();\n+        vanityUrlAPI = APILocator.getVanityUrlAPI();\n+        filtersUtil = FiltersUtil.getInstance();\n+\n+        cache=CacheLocator.getVanityURLCache();\n+\n+        /* Default variables */\n+        defaultHost =  new SiteDataGen().nextPersisted();\n+        defaultLanguage = APILocator.getLanguageAPI().getDefaultLanguage();\n+    }\n+\n+\n+    /**\n+     * this tests that the vanityURL proxies requests that are made to different hosts.\n+     * In this case, we will request a url from dotcms and check to see that we get the results from dotcms.com\n+     */\n+\n+    @Test\n+    public void test_that_vanity_url_filter_handles_proxy_requests() throws Exception {\n+\n+\n+        String title = \"VanityURL\"  + System.currentTimeMillis();\n+        String site = defaultHost.getIdentifier();\n+        String uri = \"/testing_forward\" + System.currentTimeMillis();\n+        String forwardTo = \"https://dotcms.com\";\n+        int action = 200;\n+        int order = 1;\n+\n+        Contentlet contentlet1 = filtersUtil.createVanityUrl(title, site, uri,\n+                forwardTo, action, order, defaultLanguage.getId());\n+        filtersUtil.publishVanityUrl(contentlet1);\n+\n+        final HttpServletRequest request = new MockHttpRequest(defaultHost.getHostname(), uri).request();\n+  \n+        final File tmp = File.createTempFile(\"testingVanity\", \"test\");\n+        tmp.deleteOnExit();\n+        \n+        final HttpServletResponse response = new MockHttpCaptureResponse(new MockHttpResponse().response(), tmp).response();\n+\n+        final VanityURLFilter filter = new VanityURLFilter();\n+        \n+        filter.doFilter(request, response, null);\n+        \n+        assert(tmp.exists());\n+        String content = FileUtil.read(tmp);\n+        assert(content!=null);\n+        assert(content.contains(\"All rights reserved\"));\n+        assert(content.contains(\"<meta property=\\\"og:url\\\" content=\\\"https://dotcms.com/\\\">\"));\n+        \n+\n+    }\n+\n+    /**\n+     * this tests that vanity url redirects work as expected\n+     * @throws Exception\n+     */\n+    @Test\n+    public void test_that_vanity_url_filter_handles_redirects() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NTE2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/datagen/VanityUrlDataGen.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxNlrOGlcDUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxNlrOGlcDUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDA5OQ==", "bodyText": "Codacy found an issue: Field uri has the same name as a method", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910099", "createdAt": "2020-06-18T00:55:16Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/datagen/VanityUrlDataGen.java", "diffHunk": "@@ -0,0 +1,108 @@\n+package com.dotcms.datagen;\n+\n+import com.dotcms.vanityurl.business.VanityUrlAPI;\n+import com.dotcms.vanityurl.model.DefaultVanityUrl;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.contentlet.model.IndexPolicy;\n+import com.dotmarketing.portlets.folders.model.Folder;\n+\n+import io.vavr.control.Try;\n+\n+/**\n+ * Class used to create {@link Contentlet} objects of type {@link com.dotcms.vanityurl.model.VanityUrl} for test purposes\n+ *\n+ * @author Nollymar Longa\n+ */\n+public class VanityUrlDataGen extends ContentletDataGen {\n+\n+\n+\n+  private String uri;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NTIyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/vanityurl/cache/VanityUrlCacheImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxN1rOGlcDWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxN1rOGlcDWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDEwNQ==", "bodyText": "Codacy found an issue: Consider simply returning the value vs storing it in local variable 'key'", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910105", "createdAt": "2020-06-18T00:55:17Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/vanityurl/cache/VanityUrlCacheImpl.java", "diffHunk": "@@ -0,0 +1,156 @@\n+package com.dotcms.vanityurl.cache;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import com.dotcms.vanityurl.model.CachedVanityUrl;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.portlets.languagesmanager.model.Language;\n+import com.liferay.util.StringPool;\n+import io.vavr.control.Try;\n+\n+/**\n+ * This class implements {@link VanityUrlCache} the cache for Vanity URLs. Is used to map the Vanity\n+ * URLs path to the Vanity URL content\n+ *\n+ * @author oswaldogallango\n+ * @version 4.2.0\n+ * @since June 24, 2017\n+ */\n+public class VanityUrlCacheImpl extends VanityUrlCache {\n+\n+    private DotCacheAdministrator cache;\n+\n+    private static final String VANITY_URL_SITE_GROUP = \"VanityURLSiteCache\";\n+    private static final String VANITY_URL_DIRECT_GROUP = \"VanityURLDirectCache\";\n+\n+\n+\n+    public VanityUrlCacheImpl() {\n+        cache = CacheLocator.getCacheAdministrator();\n+    }\n+\n+    @Override\n+    public String getPrimaryGroup() {\n+\n+        return VANITY_URL_SITE_GROUP;\n+    }\n+\n+    @Override\n+    public String[] getGroups() {\n+\n+        return new String[] {VANITY_URL_SITE_GROUP, VANITY_URL_DIRECT_GROUP};\n+    }\n+\n+    @Override\n+    public void clearCache() {\n+        cache.flushGroup(VANITY_URL_SITE_GROUP);\n+        cache.flushGroup(VANITY_URL_DIRECT_GROUP);\n+\n+    }\n+\n+    @Override\n+    public void remove(final Contentlet vanityURL) {\n+        if (vanityURL == null || !vanityURL.isVanityUrl()) {\n+            return;\n+        }\n+        Host host = Try.of(() -> APILocator.getHostAPI().find(vanityURL.getHost(), APILocator.systemUser(), false)).getOrNull();\n+        Language lang = Try.of(() -> APILocator.getLanguageAPI().getLanguage(vanityURL.getLanguageId())).getOrNull();\n+        if (host == null || lang == null) {\n+            return;\n+        }\n+        remove(host, lang);\n+\n+\n+    }\n+\n+\n+    @Override\n+    public void remove(final Host vanityHost) {\n+        if (vanityHost == null) {\n+            return;\n+        }\n+\n+        final List<Language> langs = APILocator.getLanguageAPI().getLanguages();\n+\n+        for (Language lang : langs) {\n+            remove(vanityHost, lang);\n+        }\n+\n+    }\n+\n+\n+    @Override\n+    public void remove(final Host vanityHost, final Language lang) {\n+        if (vanityHost == null || lang == null) {\n+            return;\n+        }\n+\n+        cache.remove(key(vanityHost, lang), VANITY_URL_SITE_GROUP);\n+        cache.flushGroup(VANITY_URL_DIRECT_GROUP);\n+\n+    }\n+\n+\n+    @Override\n+    public void putSiteMappings(final Host host, final Language lang, final List<CachedVanityUrl> vanityURLs) {\n+        if (host == null || host.getIdentifier() == null || lang == null || vanityURLs == null) {\n+            return;\n+        }\n+        cache.put(key(host, lang), vanityURLs, VANITY_URL_SITE_GROUP);\n+    }\n+\n+    @Override\n+    public List<CachedVanityUrl> getSiteMappings(final Host host, final Language lang) {\n+        if (host == null || lang == null || host.getIdentifier() == null) {\n+            return null;\n+        }\n+        final String key = key(host, lang);\n+\n+        return (List<CachedVanityUrl>) cache.getNoThrow(key, VANITY_URL_SITE_GROUP);\n+\n+    }\n+\n+    @Override\n+    public Optional<CachedVanityUrl> getDirectMapping(final String url, final Host host, final Language lang) {\n+\n+        return (Optional<CachedVanityUrl>) cache.getNoThrow(key(host, lang, url), VANITY_URL_DIRECT_GROUP);\n+\n+    }\n+    \n+\n+\n+\n+    @Override\n+    public void putDirectMapping(final Host host, final Language lang, final String url, final Optional<CachedVanityUrl> vanityUrl) {\n+        if(vanityUrl==null) {\n+            throw new DotRuntimeException(\"Unable to put null value in cache:\" + key(host, lang, url));\n+        }\n+        cache.put(key(host, lang, url), vanityUrl, VANITY_URL_DIRECT_GROUP);\n+\n+    }\n+\n+\n+    String key(final Host host, final Language lang) {\n+        return key(host, lang, null);\n+    }\n+\n+\n+\n+    String key(final Host host, final Language lang, final String url) {\n+        if(host==null || lang==null) {\n+            throw new DotRuntimeException(\"Host or language are null - host:\" + host  + \" lang:\" + lang);\n+        }\n+        String key = host.getIdentifier() + StringPool.UNDERLINE\n+                        +  String.valueOf(lang.getId()) + StringPool.UNDERLINE\n+                        + (url != null ? url : \"\");\n+        return key;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NTI2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotmarketing/filters/FiltersTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxOFrOGlcDYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxOFrOGlcDYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDExMg==", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910112", "createdAt": "2020-06-18T00:55:18Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/filters/FiltersTest.java", "diffHunk": "@@ -601,7 +564,7 @@ public void forward(ServletRequest arg0, ServletResponse arg1)\n     }\n \n \n-    public void runTests() throws IOException, DotDataException {\n+    public void runTests() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 343}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NTMxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/vanityurl/model/CachedVanityUrl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxOFrOGlcDZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxOFrOGlcDZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDExOA==", "bodyText": "Codacy found an issue: This statement should have braces", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910118", "createdAt": "2020-06-18T00:55:18Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/vanityurl/model/CachedVanityUrl.java", "diffHunk": "@@ -172,13 +104,91 @@ private String addOptionalForwardSlashSupport(final String uri){\n     /**\n      * This takes the uir that was originally stored in the contentlet adds validates it.\n      * @param uri the uri stored in the contentlet.\n-     * @param cache404VanityUrl whether or not this is a 404 cache entry\n      * @return normalized uri.\n      */\n-    private String normalize(final String uri, final boolean cache404VanityUrl){\n-        final String uriRegEx = cache404VanityUrl ? uri : addOptionalForwardSlashSupport(uri);\n+    private String normalize(final String uri){\n+        final String uriRegEx = addOptionalForwardSlashSupport(uri);\n         return VanityUrlUtil.isValidRegex(uriRegEx) ? uriRegEx : StringPool.BLANK;\n     }\n+    \n+    \n+    public VanityUrlResult handle(final String uriIn,\n+                    final HttpServletResponse response) {\n+        \n+        final Tuple2<String,String> rewritten = processForward(uriIn);\n+        final String rewrite = rewritten._1;\n+        final String queryString = rewritten._2;\n+\n+\n+        // if the vanity is a redirect\n+        if (this.response==301 || this.response==302 ) {\n+            response.setStatus(this.response);\n+            response.setHeader(\"Location\", rewrite);\n+            return new VanityUrlResult(rewrite, queryString, true);\n+        }\n+        \n+        // if the vanity is a proxy request\n+        if (this.response==200 && UtilMethods.isSet(rewrite) && rewrite.contains(\"//\")) {\n+            \n+            final String proxyUrl  = rewrite + (queryString!=null ? \"?\" + queryString : \"\");\n+            \n+            Try.run(()-> new CircuitBreakerUrl(proxyUrl).doOut(response)).onFailure(DotRuntimeException::new);\n+            return new VanityUrlResult(rewrite, queryString, true);\n+        }\n+\n+        return new VanityUrlResult(rewrite, queryString, false);\n+        \n+        \n+    }\n+    \n+    \n+\n+\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + ((forwardTo == null) ? 0 : forwardTo.hashCode());\n+        result = prime * result + (int) (languageId ^ (languageId >>> 32));\n+        result = prime * result + response;\n+        result = prime * result + ((siteId == null) ? 0 : siteId.hashCode());\n+        result = prime * result + ((url == null) ? 0 : url.hashCode());\n+        return result;\n+    }\n+\n+\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 276}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MzE3NTM5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxOVrOGlcDcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDo1NToxOVrOGlcDcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkxMDEyOA==", "bodyText": "Codacy found an issue: Useless parentheses.", "url": "https://github.com/dotCMS/core/pull/18377#discussion_r441910128", "createdAt": "2020-06-18T00:55:19Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/vanityurl/business/VanityUrlAPITest.java", "diffHunk": "@@ -60,271 +61,255 @@ public static void prepare() throws Exception {\n         /* Default user */\n         user = APILocator.systemUser();\n \n-        /* APIs initialization */\n-        hostAPI = APILocator.getHostAPI();\n         contentletAPI = APILocator.getContentletAPI();\n         vanityUrlAPI = APILocator.getVanityUrlAPI();\n         filtersUtil = FiltersUtil.getInstance();\n \n-        /* Load Cache */\n-        vanityUrlCache = CacheLocator.getVanityURLCache();\n+        cache=CacheLocator.getVanityURLCache();\n \n         /* Default variables */\n-        defaultHost = hostAPI.findDefaultHost(user, false);\n-        defaultLanguageId = APILocator.getLanguageAPI().getDefaultLanguage().getId();\n+        defaultHost =  new SiteDataGen().nextPersisted();\n+        defaultLanguage = APILocator.getLanguageAPI().getDefaultLanguage();\n     }\n \n+    \n+    \n     /**\n      * Creates a vanity url but no publish it, gets it and checks there is not in cache.\n      *\n      * @see VanityUrlAPI\n      */\n     @Test\n-    public void getWorkingVanityUrl() {\n+    public void testing_the_from_contentlet_method() throws Exception {\n+\n+\n+        long i = System.currentTimeMillis();\n+        String title = \"VanityURL\" + i;\n+        String site = defaultHost.getIdentifier();\n+        String uri = \"/test1_\" + i;\n+        String forwardTo = \"/about-us/\" + CMSFilter.CMS_INDEX_PAGE;\n+        int action = 200;\n+        int order = 1;\n+\n+        Contentlet contentlet1 = filtersUtil.createVanityUrl(title, site, uri,\n+                forwardTo, action, order, defaultLanguage.getId());\n+\n+        VanityUrl vanity1 = vanityUrlAPI.fromContentlet(contentletAPI.find(contentlet1.getInode(), user, false));\n+\n+        Assert.assertNotNull(vanity1);\n+        Assert.assertEquals(title, vanity1.getTitle());\n+        Assert.assertEquals(site, vanity1.getSite());\n+        Assert.assertEquals(uri, vanity1.getURI());\n+        Assert.assertEquals(forwardTo, vanity1.getForwardTo());\n+        Assert.assertEquals(action, vanity1.getAction());\n+        Assert.assertEquals(order, vanity1.getOrder());\n+\n+    }\n+    \n+    \n+    \n+    \n+    /**\n+     * Creates a vanity url but no publish it, gets it and checks there is not in cache.\n+     *\n+     * @see VanityUrlAPI\n+     */\n+    @Test\n+    public void working_vanities_do_not_resolve() throws Exception {\n \n         Contentlet contentlet1 = null;\n \n-        try {\n-            long i = System.currentTimeMillis();\n-            String title = \"VanityURL\" + i;\n-            String site = defaultHost.getIdentifier();\n-            String uri = \"/test1_\" + i;\n-            String forwardTo = \"/about-us/\" + CMSFilter.CMS_INDEX_PAGE;\n-            int action = 200;\n-            int order = 1;\n-\n-            contentlet1 = filtersUtil.createVanityUrl(title, site, uri,\n-                    forwardTo, action, order, defaultLanguageId);\n-\n-            VanityUrl vanity1 = vanityUrlAPI.getVanityUrlFromContentlet(contentletAPI.find(contentlet1.getInode(), user, false));\n-\n-            Assert.assertNotNull(vanity1);\n-            Assert.assertNotEquals(VanityUrlAPI.CACHE_404_VANITY_URL,vanity1.getInode());\n-            Assert.assertEquals(title, vanity1.getTitle());\n-            Assert.assertEquals(site, vanity1.getSite());\n-            Assert.assertEquals(uri, vanity1.getURI());\n-            Assert.assertEquals(forwardTo, vanity1.getForwardTo());\n-            Assert.assertEquals(action, vanity1.getAction());\n-\n-            CachedVanityUrl vanityCached = vanityUrlAPI.getLiveCachedVanityUrl(uri, defaultHost, defaultLanguageId, user);\n-\n-            Assert.assertEquals(VanityUrlAPI.CACHE_404_VANITY_URL,vanityCached.getVanityUrlId());\n-\n-        } catch (DotDataException | DotSecurityException e) {\n-            e.printStackTrace();\n-            fail();\n-        } finally {\n-            try {\n-                if (contentlet1 != null) {\n-                    contentletAPI.destroy(contentlet1, user, false );\n-                }\n-            } catch (Exception e) {\n-                Logger.error(this.getClass(), \"Error cleaning up Vanity Url Links\");\n-            }\n-        }\n+\n+        long i = System.currentTimeMillis();\n+        String title = \"VanityURL\" + i;\n+        String site = defaultHost.getIdentifier();\n+        String uri = \"/test1_\" + i;\n+        String forwardTo = \"/about-us/\" + CMSFilter.CMS_INDEX_PAGE;\n+        int action = 200;\n+        int order = 1;\n+\n+        contentlet1 = filtersUtil.createVanityUrl(title, site, uri,\n+                forwardTo, action, order, defaultLanguage.getId());\n+\n+        \n+        \n+        Optional<CachedVanityUrl> optionalCache = cache.getDirectMapping(uri, defaultHost, defaultLanguage);\n+        assert(optionalCache==null );\n+        \n+\n+        Optional<CachedVanityUrl> vanityCached = vanityUrlAPI.resolveVanityUrl(uri, defaultHost, defaultLanguage);\n+\n+        // it is not here because it is not published\n+        assert(!vanityCached.isPresent());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5be94801aa30843f9fc663091d0aa81d050f15b3"}, "originalPosition": 183}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2252, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}