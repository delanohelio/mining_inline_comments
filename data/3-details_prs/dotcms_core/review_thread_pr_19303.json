{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkxMTc5NTU5", "number": 19303, "reviewThreads": {"totalCount": 64, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjoxMzo0MlrOEoKSWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoyMFrOEuu1_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTQ3MDM0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadataAPIImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNjoxMzo0MlrOHZFyWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxODowMjo1NFrOHiTv5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MTI1Ng==", "bodyText": "remove this", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r496071256", "createdAt": "2020-09-28T16:13:42Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadataAPIImpl.java", "diffHunk": "@@ -0,0 +1,384 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.contenttype.model.field.BinaryField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.portlets.contentlet.business.ContentletCache;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.StringUtils;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Default implementation\n+ * @author jsanca\n+ */\n+public class ContentletMetadataAPIImpl implements ContentletMetadataAPI {\n+\n+    private static final String METADATA_GROUP_NAME = \"METADATA_GROUP_NAME\";\n+    private static final String DEFAULT_STORAGE_TYPE = \"DEFAULT_STORAGE_TYPE\";\n+    private static final String DOT_METADATA = \"dotmetadata\";\n+    private static final String DEFAULT_METADATA_GROUP_NAME = DOT_METADATA;\n+    private final FileStorageAPI fileStorageAPI;\n+\n+    public ContentletMetadataAPIImpl() {\n+        this(APILocator.getFileStorageAPI());\n+    }\n+\n+    @VisibleForTesting\n+    public ContentletMetadataAPIImpl(final FileStorageAPI fileStorageAPI) {\n+        this.fileStorageAPI = fileStorageAPI;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet Contentlet\n+     * @param basicBinaryFieldNameSet {@link Set} fields to generate basic metadata\n+     * @param fullBinaryFieldNameSet  {@link Set} fields to generate full metadata\n+     * @return\n+     * @throws IOException\n+     */\n+    @Override\n+    public ContentletMetadata generateContentletMetadata(final Contentlet contentlet,\n+                                                         final Set<String> basicBinaryFieldNameSet,\n+                                                         final Set<String> fullBinaryFieldNameSet) throws IOException {\n+\n+        final ImmutableMap.Builder<String, Map<String, Object>> fullMetadataMap  = new ImmutableMap.Builder<>();\n+        final ImmutableMap.Builder<String, Map<String, Object>> basicMetadataMap = new ImmutableMap.Builder<>();\n+        final  Map<String, Field>  fieldMap   = contentlet.getContentType().fieldMap();\n+        /*\n+\t\tVerify if it is enabled the option to always regenerate metadata files on reindex,\n+\t\tenabling this could affect greatly the performance of a reindex process.\n+\t\t */\n+        final boolean alwaysRegenerateMetadata = Config\n+                .getBooleanProperty(\"always.regenerate.metadata.on.reindex\", false);\n+\n+        Logger.debug(this, ()-> \"Generating the metadata for contentlet, id = \" + contentlet.getIdentifier());\n+\n+        // Full MD is stored in disc (FS or DB)\n+        this.generateFullMetadata (contentlet, fullBinaryFieldNameSet, fullMetadataMap, fieldMap, alwaysRegenerateMetadata);\n+        //Basic MD lives only in cache\n+        this.generateBasicMetadata(contentlet, basicBinaryFieldNameSet, fullBinaryFieldNameSet, basicMetadataMap, fieldMap, alwaysRegenerateMetadata);\n+\n+        return new ContentletMetadata(fullMetadataMap.build(), basicMetadataMap.build());\n+    }\n+\n+    /**\n+     * Basic metadata generation entry point.\n+     * @param contentlet\n+     * @param basicBinaryFieldNameSet\n+     * @param fullBinaryFieldNameSet\n+     * @param basicMetadataMap\n+     * @param fieldMap\n+     * @param alwaysRegenerateMetadata\n+     * @throws IOException\n+     */\n+    private void generateBasicMetadata(final Contentlet contentlet,\n+                                       final Set<String> basicBinaryFieldNameSet,\n+                                       final Set<String> fullBinaryFieldNameSet,\n+                                       final ImmutableMap.Builder<String, Map<String, Object>> basicMetadataMap,\n+                                       final Map<String, Field> fieldMap,\n+                                       final boolean alwaysRegenerateMetadata) throws IOException {\n+\n+        final StorageType storageType = StoragePersistenceProvider.getStorageType();\n+        Map<String, Object> metadataMap;\n+        final String metadataBucketName = Config.getStringProperty(METADATA_GROUP_NAME, DEFAULT_METADATA_GROUP_NAME);\n+        for (final String basicBinaryFieldName : basicBinaryFieldNameSet) {\n+\n+            final File file           = contentlet.getBinary(basicBinaryFieldName);\n+            final String metadataPath = this.getFileName(contentlet, basicBinaryFieldName);\n+\n+            if (null != file && file.exists() && file.canRead()) {\n+\n+                // if already included on the full, the file was already generated, just need to add the basic to the cache.\n+                final Set<String> metadataFields = this.getMetadataFields(fieldMap.get(basicBinaryFieldName).id());\n+\n+                if (fullBinaryFieldNameSet.contains(basicBinaryFieldName)) {\n+\n+                    // if it is included on the full keys, we only have to store the meta in the cache.\n+                    metadataMap = this.fileStorageAPI.generateBasicMetaData(file,\n+                            metadataKey -> metadataFields.isEmpty() || metadataFields\n+                                    .contains(metadataKey));\n+                    CacheLocator.getContentletCache()\n+                            .addMetadataMap(contentlet.getInode() + basicBinaryFieldName, metadataMap);\n+                } else {\n+\n+\n+                    metadataMap = this.fileStorageAPI.generateMetaData(file,\n+                            new GenerateMetadataConfig.Builder()\n+                                    .full(false)\n+                                    .override(alwaysRegenerateMetadata)\n+                                    .store(true)\n+                                    .cache(()-> ContentletCache.META_DATA_MAP_KEY + contentlet.getInode() + basicBinaryFieldName)\n+                                    .metaDataKeyFilter(metadataKey -> metadataFields.isEmpty()\n+                                            || metadataFields.contains(metadataKey))\n+                                    .storageKey(new StorageKey.Builder().group(metadataBucketName).path(metadataPath).storage(storageType).build())\n+                                    .build()\n+                    );\n+                }\n+\n+                basicMetadataMap.put(basicBinaryFieldName, metadataMap);\n+            } else {\n+               //We're dealing with a  non required neither set binary field. No need to throw an exception. Just continue processing.\n+               Logger.warn(ContentletMetadataAPIImpl.class, String.format(\"The binary field : `%s`, is null, does not exists or can not be accessed\",basicBinaryFieldName));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Metadata file generator.\n+     * @param contentlet\n+     * @param fieldVariableName\n+     * @return\n+     */\n+    private String getFileName (final Contentlet contentlet, final String fieldVariableName) {\n+\n+        final String inode        = contentlet.getInode();\n+        final String fileName     = fieldVariableName + \"-metadata.json\";\n+        return StringUtils.builder(File.separator,\n+                inode.charAt(0), File.separator, inode.charAt(1), File.separator, inode, File.separator,\n+                fileName).toString();\n+    }\n+\n+    private void generateFullMetadata(final Contentlet contentlet,\n+                                      final Set<String> fullBinaryFieldNameSet,\n+                                      final ImmutableMap.Builder<String, Map<String, Object>> fullMetadataMap,\n+                                      final Map<String, Field> fieldMap,\n+                                      final boolean alwaysRegenerateMetadata) throws IOException {\n+\n+\n+        final StorageType storageType = StoragePersistenceProvider.getStorageType();\n+        final String metadataBucketName = Config.getStringProperty(METADATA_GROUP_NAME,\n+                DOT_METADATA);\n+        for (final String fullBinaryFieldName : fullBinaryFieldNameSet) {\n+            Logger.info(ContentletMetadataAPIImpl.class,\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff9e73122ca0ad6b7d5eade7859cad4780d4d90a"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczNzE4OQ==", "bodyText": "done", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505737189", "createdAt": "2020-10-15T18:02:54Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadataAPIImpl.java", "diffHunk": "@@ -0,0 +1,384 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.contenttype.model.field.BinaryField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.portlets.contentlet.business.ContentletCache;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.StringUtils;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Default implementation\n+ * @author jsanca\n+ */\n+public class ContentletMetadataAPIImpl implements ContentletMetadataAPI {\n+\n+    private static final String METADATA_GROUP_NAME = \"METADATA_GROUP_NAME\";\n+    private static final String DEFAULT_STORAGE_TYPE = \"DEFAULT_STORAGE_TYPE\";\n+    private static final String DOT_METADATA = \"dotmetadata\";\n+    private static final String DEFAULT_METADATA_GROUP_NAME = DOT_METADATA;\n+    private final FileStorageAPI fileStorageAPI;\n+\n+    public ContentletMetadataAPIImpl() {\n+        this(APILocator.getFileStorageAPI());\n+    }\n+\n+    @VisibleForTesting\n+    public ContentletMetadataAPIImpl(final FileStorageAPI fileStorageAPI) {\n+        this.fileStorageAPI = fileStorageAPI;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet Contentlet\n+     * @param basicBinaryFieldNameSet {@link Set} fields to generate basic metadata\n+     * @param fullBinaryFieldNameSet  {@link Set} fields to generate full metadata\n+     * @return\n+     * @throws IOException\n+     */\n+    @Override\n+    public ContentletMetadata generateContentletMetadata(final Contentlet contentlet,\n+                                                         final Set<String> basicBinaryFieldNameSet,\n+                                                         final Set<String> fullBinaryFieldNameSet) throws IOException {\n+\n+        final ImmutableMap.Builder<String, Map<String, Object>> fullMetadataMap  = new ImmutableMap.Builder<>();\n+        final ImmutableMap.Builder<String, Map<String, Object>> basicMetadataMap = new ImmutableMap.Builder<>();\n+        final  Map<String, Field>  fieldMap   = contentlet.getContentType().fieldMap();\n+        /*\n+\t\tVerify if it is enabled the option to always regenerate metadata files on reindex,\n+\t\tenabling this could affect greatly the performance of a reindex process.\n+\t\t */\n+        final boolean alwaysRegenerateMetadata = Config\n+                .getBooleanProperty(\"always.regenerate.metadata.on.reindex\", false);\n+\n+        Logger.debug(this, ()-> \"Generating the metadata for contentlet, id = \" + contentlet.getIdentifier());\n+\n+        // Full MD is stored in disc (FS or DB)\n+        this.generateFullMetadata (contentlet, fullBinaryFieldNameSet, fullMetadataMap, fieldMap, alwaysRegenerateMetadata);\n+        //Basic MD lives only in cache\n+        this.generateBasicMetadata(contentlet, basicBinaryFieldNameSet, fullBinaryFieldNameSet, basicMetadataMap, fieldMap, alwaysRegenerateMetadata);\n+\n+        return new ContentletMetadata(fullMetadataMap.build(), basicMetadataMap.build());\n+    }\n+\n+    /**\n+     * Basic metadata generation entry point.\n+     * @param contentlet\n+     * @param basicBinaryFieldNameSet\n+     * @param fullBinaryFieldNameSet\n+     * @param basicMetadataMap\n+     * @param fieldMap\n+     * @param alwaysRegenerateMetadata\n+     * @throws IOException\n+     */\n+    private void generateBasicMetadata(final Contentlet contentlet,\n+                                       final Set<String> basicBinaryFieldNameSet,\n+                                       final Set<String> fullBinaryFieldNameSet,\n+                                       final ImmutableMap.Builder<String, Map<String, Object>> basicMetadataMap,\n+                                       final Map<String, Field> fieldMap,\n+                                       final boolean alwaysRegenerateMetadata) throws IOException {\n+\n+        final StorageType storageType = StoragePersistenceProvider.getStorageType();\n+        Map<String, Object> metadataMap;\n+        final String metadataBucketName = Config.getStringProperty(METADATA_GROUP_NAME, DEFAULT_METADATA_GROUP_NAME);\n+        for (final String basicBinaryFieldName : basicBinaryFieldNameSet) {\n+\n+            final File file           = contentlet.getBinary(basicBinaryFieldName);\n+            final String metadataPath = this.getFileName(contentlet, basicBinaryFieldName);\n+\n+            if (null != file && file.exists() && file.canRead()) {\n+\n+                // if already included on the full, the file was already generated, just need to add the basic to the cache.\n+                final Set<String> metadataFields = this.getMetadataFields(fieldMap.get(basicBinaryFieldName).id());\n+\n+                if (fullBinaryFieldNameSet.contains(basicBinaryFieldName)) {\n+\n+                    // if it is included on the full keys, we only have to store the meta in the cache.\n+                    metadataMap = this.fileStorageAPI.generateBasicMetaData(file,\n+                            metadataKey -> metadataFields.isEmpty() || metadataFields\n+                                    .contains(metadataKey));\n+                    CacheLocator.getContentletCache()\n+                            .addMetadataMap(contentlet.getInode() + basicBinaryFieldName, metadataMap);\n+                } else {\n+\n+\n+                    metadataMap = this.fileStorageAPI.generateMetaData(file,\n+                            new GenerateMetadataConfig.Builder()\n+                                    .full(false)\n+                                    .override(alwaysRegenerateMetadata)\n+                                    .store(true)\n+                                    .cache(()-> ContentletCache.META_DATA_MAP_KEY + contentlet.getInode() + basicBinaryFieldName)\n+                                    .metaDataKeyFilter(metadataKey -> metadataFields.isEmpty()\n+                                            || metadataFields.contains(metadataKey))\n+                                    .storageKey(new StorageKey.Builder().group(metadataBucketName).path(metadataPath).storage(storageType).build())\n+                                    .build()\n+                    );\n+                }\n+\n+                basicMetadataMap.put(basicBinaryFieldName, metadataMap);\n+            } else {\n+               //We're dealing with a  non required neither set binary field. No need to throw an exception. Just continue processing.\n+               Logger.warn(ContentletMetadataAPIImpl.class, String.format(\"The binary field : `%s`, is null, does not exists or can not be accessed\",basicBinaryFieldName));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Metadata file generator.\n+     * @param contentlet\n+     * @param fieldVariableName\n+     * @return\n+     */\n+    private String getFileName (final Contentlet contentlet, final String fieldVariableName) {\n+\n+        final String inode        = contentlet.getInode();\n+        final String fileName     = fieldVariableName + \"-metadata.json\";\n+        return StringUtils.builder(File.separator,\n+                inode.charAt(0), File.separator, inode.charAt(1), File.separator, inode, File.separator,\n+                fileName).toString();\n+    }\n+\n+    private void generateFullMetadata(final Contentlet contentlet,\n+                                      final Set<String> fullBinaryFieldNameSet,\n+                                      final ImmutableMap.Builder<String, Map<String, Object>> fullMetadataMap,\n+                                      final Map<String, Field> fieldMap,\n+                                      final boolean alwaysRegenerateMetadata) throws IOException {\n+\n+\n+        final StorageType storageType = StoragePersistenceProvider.getStorageType();\n+        final String metadataBucketName = Config.getStringProperty(METADATA_GROUP_NAME,\n+                DOT_METADATA);\n+        for (final String fullBinaryFieldName : fullBinaryFieldNameSet) {\n+            Logger.info(ContentletMetadataAPIImpl.class,\"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MTI1Ng=="}, "originalCommit": {"oid": "ff9e73122ca0ad6b7d5eade7859cad4780d4d90a"}, "originalPosition": 175}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDIyOTYxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/StorageKey.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzoyNFrOHZzvdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzoyNFrOHZzvdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyNDE4Mw==", "bodyText": "Codacy found an issue: Field storage has the same name as a method", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r496824183", "createdAt": "2020-09-29T15:37:24Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/StorageKey.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package com.dotcms.storage;\n+\n+/**\n+ * Encapsulates a storage key, it has the key (for instance the path)\n+ * the group (for instance the bucket, folder, space, etc)\n+ * Storage {@link StorageType}\n+ * @author jsanca\n+ */\n+public class StorageKey {\n+\n+    //Key components\n+    private final String path;\n+    private final String group;\n+    private final StorageType storage;\n+\n+    /**\n+     * Builder based constructor\n+     * @param builder\n+     */\n+    private StorageKey(final Builder builder) {\n+\n+        this.path = builder.path;\n+        this.group = builder.group;\n+        this.storage    = builder.storage;\n+    }\n+\n+    /**\n+     * read only path\n+     * @return\n+     */\n+    public String getPath() {\n+        return path;\n+    }\n+\n+    /**\n+     * read only group\n+     * @return\n+     */\n+    public String getGroup() {\n+        return group;\n+    }\n+\n+    /**\n+     * read-only storage\n+     * @return\n+     */\n+    public StorageType getStorage() {\n+        return storage;\n+    }\n+\n+    /**\n+     * Convenience builder\n+     */\n+    public static final class Builder {\n+\n+        private String path;\n+        private String group;\n+        private StorageType storage;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDIyOTczOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/FileSystemStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzoyNVrOHZzvhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzoyNVrOHZzvhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyNDE5OQ==", "bodyText": "Codacy found an issue: The String literal \"StoragePool\" appears 4 times in this file; the first occurrence is on line 210", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r496824199", "createdAt": "2020-09-29T15:37:25Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/FileSystemStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,463 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.liferay.util.FileUtil;\n+import java.nio.file.Paths;\n+import org.apache.commons.io.FileUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import org.apache.commons.lang3.mutable.MutableInt;\n+\n+/**\n+ * Represents a Storage on the file system The groups here are folder previously registered, you can\n+ * subscribe more by using {@link #addGroupMapping(String, File)}\n+ * By default the API loads up and maps a root folder. Which can be override by a property.\n+ * Any new group created will result in a new folder under that root folder.\n+ * @author jsanca\n+ */\n+public class FileSystemStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private static final String DEFAULT_ROOT = \"root\";\n+    private static final String THE_BUCKET_NAME_S_DOES_NOT_HAVE_ANY_FILE_MAPPED = \"The bucketName: `%s`, does not have any files mapped\";\n+\n+    private final Map<String, File> groups = new ConcurrentHashMap<>();\n+\n+    /**\n+     * default constructor\n+     */\n+    FileSystemStoragePersistenceAPIImpl() {\n+        final String rootGroupKey = getRootGroupKey();\n+        final File rootFolder = getRootFolder();\n+        groups.put(rootGroupKey, rootFolder);\n+        Logger.info(FileSystemStoragePersistenceAPIImpl.class, () -> String\n+                .format(\"Default group key is `%s` currently mapped to folder `%s` \", rootGroupKey,\n+                        rootFolder));\n+    }\n+\n+\n+\n+    /**\n+     * Adds a mapping between a bucket name and a file\n+     *\n+     * @param groupName {@link String} bucket name\n+     * @param folder {@link File}\n+     */\n+    void addGroupMapping(final String groupName, final File folder) {\n+        if (!folder.isDirectory() || !folder.exists() || !folder.canWrite()) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Invalid attempt of mapping an non existing or writable folder. Argument`%s` must be a valid. \",\n+                    folder));\n+        }\n+        this.groups.put(groupName.toLowerCase(), folder);\n+        Logger.info(FileSystemStoragePersistenceAPIImpl.class, () -> String.format(\"Registering New Group with key is `%s` mapped to folder `%s` \",groupName, folder));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.groups.containsKey(groupNameLC) && this.groups.get(groupNameLC).exists();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String}\n+     * @param objectPath {@link String}\n+     * @return\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.existsGroup(groupNameLC) && new File(this.groups.get(groupNameLC), objectPath)\n+                .exists();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) {\n+        return this.createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName    {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options or not.\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final File rootGroup = this.groups.get(getRootGroupKey());\n+        final File destBucketFile = new File(rootGroup, groupNameLC);\n+        final boolean mkdirs = destBucketFile.mkdirs();\n+        if(mkdirs) {\n+           this.groups.put(groupNameLC, destBucketFile);\n+        }\n+        return mkdirs;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) {\n+        final File rootGroup = this.groups.get(getRootGroupKey());\n+        final File destBucketFile = new File(rootGroup, groupName.toLowerCase());\n+        if (!rootGroup.equals(destBucketFile)) {\n+            final int count = countFiles(destBucketFile);\n+            FileUtil.deltree(destBucketFile, true);\n+            return count;\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @param path   {   @link String} object path\n+     * @return\n+     */\n+    public boolean deleteObject(final String groupName, final String path) {\n+        return new File(this.groups.get(groupName.toLowerCase()), path.toLowerCase()).delete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return\n+     */\n+    @Override\n+    public List<String> listGroups() {\n+\n+        return new ImmutableList.Builder<String>().addAll(this.groups.keySet()).build();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String} the group to upload\n+     * @param path       {@link String} path to upload the file\n+     * @param file       {@link File}   the actual file\n+     * @param extraMeta  {@link Map} optional metadata, this could be null but depending on the implementation it would need some meta info.\n+     * @return\n+     */\n+    @Override\n+    public Object pushFile(final String groupName,\n+            final String path,\n+            final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        if (!this.existsGroup(groupName)) {\n+\n+            throw new IllegalArgumentException(String.format(\n+                    THE_BUCKET_NAME_S_DOES_NOT_HAVE_ANY_FILE_MAPPED,groupName));\n+        }\n+\n+        final File groupFile = this.groups.get(groupName.toLowerCase());\n+\n+        if (null != file && file.exists() && file.canRead() && groupFile.canWrite()) {\n+\n+            try {\n+\n+                final File destBucketFile = new File(groupFile, path.toLowerCase());\n+                FileUtils.copyFile(file, destBucketFile);\n+            } catch (IOException e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        } else {\n+\n+            throw new IllegalArgumentException(\"The file: \" + file +\n+                    \", is null, does not exist can not be read or bucket: \" + groupName +\n+                    \" could not be written\");\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} the group to upload\n+     * @param path       {@link String} path to upload the file\n+     * @param writerDelegate     {@link ObjectWriterDelegate} stream to upload\n+     * @param object     {@link Serializable} object to write into the storage\n+     * @param extraMeta  {@link Map} optional metadata, this could be null but depending on the implementation it would need some meta info.\n+     * @return\n+     */\n+    @Override\n+    public Object pushObject(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        if (!this.existsGroup(groupName)) {\n+\n+            throw new IllegalArgumentException(String.format(\n+                    THE_BUCKET_NAME_S_DOES_NOT_HAVE_ANY_FILE_MAPPED,groupName));\n+        }\n+\n+        final File groupFile = this.groups.get(groupName.toLowerCase());\n+\n+        if (groupFile.canWrite()) {\n+\n+            try {\n+\n+                final File destBucketFile = new File(groupFile, path.toLowerCase());\n+                final String compressor = Config\n+                        .getStringProperty(\"CONTENT_METADATA_COMPRESSOR\", \"none\");\n+                this.prepareParent(destBucketFile);\n+\n+                try (OutputStream outputStream = FileUtil\n+                        .createOutputStream(destBucketFile.toPath(), compressor)) {\n+\n+                    writerDelegate.write(outputStream, object);\n+                    outputStream.flush();\n+                }\n+            } catch (IOException e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        } else {\n+\n+            throw new IllegalArgumentException(\"The bucket: \" + groupName + \" could not write\");\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * makes parent dir if doesnt exist\n+     * @param file\n+     */\n+    private void prepareParent(final File file) {\n+\n+        if (!file.getParentFile().exists()) {\n+\n+            file.getParentFile().mkdirs();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} the bucket to push\n+     * @param path       {@link String} path to push the file\n+     * @param file       {@link File}   the actual file\n+     * @param extraMeta  {@link Map} optional metadata, this could be null but depending on the implementation it would need some meta info.\n+     * @return\n+     */\n+    @Override\n+    public Future<Object> pushFileAsync(final String groupName, final String path,\n+            final File file, final Map<String, Object> extraMeta) {\n+        return DotConcurrentFactory.getInstance().getSubmitter(\"StoragePool\").submit(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 273}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDIyOTk2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadataAPIImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzoyNlrOHZzvsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzoyNlrOHZzvsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyNDI0MA==", "bodyText": "Codacy found an issue: Unnecessary use of fully qualified name 'java.lang.String' due to existing implicit import 'java.lang.*'", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r496824240", "createdAt": "2020-09-29T15:37:26Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadataAPIImpl.java", "diffHunk": "@@ -0,0 +1,384 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.contenttype.model.field.BinaryField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.portlets.contentlet.business.ContentletCache;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.StringUtils;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Default implementation\n+ * @author jsanca\n+ */\n+public class ContentletMetadataAPIImpl implements ContentletMetadataAPI {\n+\n+    private static final String METADATA_GROUP_NAME = \"METADATA_GROUP_NAME\";\n+    private static final String DEFAULT_STORAGE_TYPE = \"DEFAULT_STORAGE_TYPE\";\n+    private static final String DOT_METADATA = \"dotmetadata\";\n+    private static final String DEFAULT_METADATA_GROUP_NAME = DOT_METADATA;\n+    private final FileStorageAPI fileStorageAPI;\n+\n+    public ContentletMetadataAPIImpl() {\n+        this(APILocator.getFileStorageAPI());\n+    }\n+\n+    @VisibleForTesting\n+    public ContentletMetadataAPIImpl(final FileStorageAPI fileStorageAPI) {\n+        this.fileStorageAPI = fileStorageAPI;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet Contentlet\n+     * @param basicBinaryFieldNameSet {@link Set} fields to generate basic metadata\n+     * @param fullBinaryFieldNameSet  {@link Set} fields to generate full metadata\n+     * @return\n+     * @throws IOException\n+     */\n+    @Override\n+    public ContentletMetadata generateContentletMetadata(final Contentlet contentlet,\n+                                                         final Set<String> basicBinaryFieldNameSet,\n+                                                         final Set<String> fullBinaryFieldNameSet) throws IOException {\n+\n+        final ImmutableMap.Builder<String, Map<String, Object>> fullMetadataMap  = new ImmutableMap.Builder<>();\n+        final ImmutableMap.Builder<String, Map<String, Object>> basicMetadataMap = new ImmutableMap.Builder<>();\n+        final  Map<String, Field>  fieldMap   = contentlet.getContentType().fieldMap();\n+        /*\n+\t\tVerify if it is enabled the option to always regenerate metadata files on reindex,\n+\t\tenabling this could affect greatly the performance of a reindex process.\n+\t\t */\n+        final boolean alwaysRegenerateMetadata = Config\n+                .getBooleanProperty(\"always.regenerate.metadata.on.reindex\", false);\n+\n+        Logger.debug(this, ()-> \"Generating the metadata for contentlet, id = \" + contentlet.getIdentifier());\n+\n+        // Full MD is stored in disc (FS or DB)\n+        this.generateFullMetadata (contentlet, fullBinaryFieldNameSet, fullMetadataMap, fieldMap, alwaysRegenerateMetadata);\n+        //Basic MD lives only in cache\n+        this.generateBasicMetadata(contentlet, basicBinaryFieldNameSet, fullBinaryFieldNameSet, basicMetadataMap, fieldMap, alwaysRegenerateMetadata);\n+\n+        return new ContentletMetadata(fullMetadataMap.build(), basicMetadataMap.build());\n+    }\n+\n+    /**\n+     * Basic metadata generation entry point.\n+     * @param contentlet\n+     * @param basicBinaryFieldNameSet\n+     * @param fullBinaryFieldNameSet\n+     * @param basicMetadataMap\n+     * @param fieldMap\n+     * @param alwaysRegenerateMetadata\n+     * @throws IOException\n+     */\n+    private void generateBasicMetadata(final Contentlet contentlet,\n+                                       final Set<String> basicBinaryFieldNameSet,\n+                                       final Set<String> fullBinaryFieldNameSet,\n+                                       final ImmutableMap.Builder<String, Map<String, Object>> basicMetadataMap,\n+                                       final Map<String, Field> fieldMap,\n+                                       final boolean alwaysRegenerateMetadata) throws IOException {\n+\n+        final StorageType storageType = StoragePersistenceProvider.getStorageType();\n+        Map<String, Object> metadataMap;\n+        final String metadataBucketName = Config.getStringProperty(METADATA_GROUP_NAME, DEFAULT_METADATA_GROUP_NAME);\n+        for (final String basicBinaryFieldName : basicBinaryFieldNameSet) {\n+\n+            final File file           = contentlet.getBinary(basicBinaryFieldName);\n+            final String metadataPath = this.getFileName(contentlet, basicBinaryFieldName);\n+\n+            if (null != file && file.exists() && file.canRead()) {\n+\n+                // if already included on the full, the file was already generated, just need to add the basic to the cache.\n+                final Set<String> metadataFields = this.getMetadataFields(fieldMap.get(basicBinaryFieldName).id());\n+\n+                if (fullBinaryFieldNameSet.contains(basicBinaryFieldName)) {\n+\n+                    // if it is included on the full keys, we only have to store the meta in the cache.\n+                    metadataMap = this.fileStorageAPI.generateBasicMetaData(file,\n+                            metadataKey -> metadataFields.isEmpty() || metadataFields\n+                                    .contains(metadataKey));\n+                    CacheLocator.getContentletCache()\n+                            .addMetadataMap(contentlet.getInode() + basicBinaryFieldName, metadataMap);\n+                } else {\n+\n+\n+                    metadataMap = this.fileStorageAPI.generateMetaData(file,\n+                            new GenerateMetadataConfig.Builder()\n+                                    .full(false)\n+                                    .override(alwaysRegenerateMetadata)\n+                                    .store(true)\n+                                    .cache(()-> ContentletCache.META_DATA_MAP_KEY + contentlet.getInode() + basicBinaryFieldName)\n+                                    .metaDataKeyFilter(metadataKey -> metadataFields.isEmpty()\n+                                            || metadataFields.contains(metadataKey))\n+                                    .storageKey(new StorageKey.Builder().group(metadataBucketName).path(metadataPath).storage(storageType).build())\n+                                    .build()\n+                    );\n+                }\n+\n+                basicMetadataMap.put(basicBinaryFieldName, metadataMap);\n+            } else {\n+               //We're dealing with a  non required neither set binary field. No need to throw an exception. Just continue processing.\n+               Logger.warn(ContentletMetadataAPIImpl.class, String.format(\"The binary field : `%s`, is null, does not exists or can not be accessed\",basicBinaryFieldName));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Metadata file generator.\n+     * @param contentlet\n+     * @param fieldVariableName\n+     * @return\n+     */\n+    private String getFileName (final Contentlet contentlet, final String fieldVariableName) {\n+\n+        final String inode        = contentlet.getInode();\n+        final String fileName     = fieldVariableName + \"-metadata.json\";\n+        return StringUtils.builder(File.separator,\n+                inode.charAt(0), File.separator, inode.charAt(1), File.separator, inode, File.separator,\n+                fileName).toString();\n+    }\n+\n+    private void generateFullMetadata(final Contentlet contentlet,\n+                                      final Set<String> fullBinaryFieldNameSet,\n+                                      final ImmutableMap.Builder<String, Map<String, Object>> fullMetadataMap,\n+                                      final Map<String, Field> fieldMap,\n+                                      final boolean alwaysRegenerateMetadata) throws IOException {\n+\n+\n+        final StorageType storageType = StoragePersistenceProvider.getStorageType();\n+        final String metadataBucketName = Config.getStringProperty(METADATA_GROUP_NAME,\n+                DOT_METADATA);\n+        for (final String fullBinaryFieldName : fullBinaryFieldNameSet) {\n+            Logger.info(ContentletMetadataAPIImpl.class,\"\");\n+            final File file           = contentlet.getBinary(fullBinaryFieldName);\n+            final String metadataPath = this.getFileName(contentlet, fullBinaryFieldName);\n+            if (null != file && file.exists() && file.canRead()) {\n+                final Set<String> metadataFields = this.getMetadataFields(fieldMap.get(fullBinaryFieldName).id());\n+                final Map<String, Object> metadataMap = this.fileStorageAPI.generateMetaData(file,\n+                        new GenerateMetadataConfig.Builder()\n+                            .full(true)\n+                            .override(alwaysRegenerateMetadata)\n+                            .cache(false)  // do not want cache on full meta\n+                            .store(true)\n+                            .metaDataKeyFilter(metadataKey -> metadataFields.isEmpty()\n+                                    || metadataFields.contains(metadataKey))\n+                            .storageKey(new StorageKey.Builder().group(metadataBucketName).path(metadataPath).storage(storageType).build())\n+                            .build()\n+                        );\n+\n+                fullMetadataMap.put(fullBinaryFieldName, metadataMap);\n+            } else {\n+\n+                throw new IOException(\"The file: \" + file + \", is null, does not exists or can not access\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * based on the identifier this will give you a set of fields for the metadata generation\n+     * fields are specific to the CT or preconfigured\n+     * @param fieldIdentifier\n+     * @return\n+     */\n+    @VisibleForTesting\n+    Set<String> getMetadataFields (final String fieldIdentifier) {\n+\n+        final Optional<FieldVariable> customIndexMetaDataFieldsOpt =\n+                Try.of(()->FactoryLocator.getFieldFactory().byFieldVariableKey(fieldIdentifier, BinaryField.INDEX_METADATA_FIELDS)).getOrElse(Optional.empty());\n+\n+        final Set<String> metadataFields = customIndexMetaDataFieldsOpt.isPresent()?\n+                new HashSet<>(Arrays.asList(customIndexMetaDataFieldsOpt.get().value().split(StringPool.COMMA))):\n+                this.getConfiguredMetadataFields();\n+\n+        Logger.info(ContentletMetadataAPIImpl.class,\n+                () -> String.format(\" `%s` has these fields: `%s` \", fieldIdentifier, String\n+                        .join(\",\", metadataFields)));\n+        return metadataFields;\n+    }\n+\n+    /**\n+     * Reads INDEX_METADATA_FIELDS for  pre-configured metadata fields\n+     * @return\n+     */\n+    private Set<String> getConfiguredMetadataFields(){\n+\n+        final java.lang.String configFields = Config.getStringProperty(\"INDEX_METADATA_FIELDS\", null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 228}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDIzMDA1OnYy", "diffSide": "LEFT", "path": "dotCMS/src/main/java/com/liferay/util/Encryptor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzoyN1rOHZzvvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzoyN1rOHZzvvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyNDI1NA==", "bodyText": "Codacy found an issue: All methods are static.  Consider using a utility class instead. Alternatively, you could add a private constructor or make the class abstract to silence this warning.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r496824254", "createdAt": "2020-09-29T15:37:27Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/liferay/util/Encryptor.java", "diffHunk": "@@ -158,4 +162,60 @@ public static String encrypt(Key key, String plainText)\n \r\n \tprivate static final Log _log = LogFactory.getLog(Encryptor.class);\r\n \r\n-}\n\\ No newline at end of file", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDIzMDE3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/util/FileJoiner.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzoyOFrOHZzv0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzoyOFrOHZzv0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyNDI3NA==", "bodyText": "Codacy found an issue: Avoid assignments in operands", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r496824274", "createdAt": "2020-09-29T15:37:28Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/util/FileJoiner.java", "diffHunk": "@@ -0,0 +1,100 @@\n+package com.dotcms.util;\n+\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Config;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.Flushable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.function.Function;\n+\n+/**\n+ * A File Joiner is a class take chucks of a file (they could be an actual file [previously splitted]) or a collection of byte chucks.\n+ * or both.\n+ * In case you are gonna use the file instead of the raw bytes, you should need to define a buffer previous by passing the chuck file of the\n+ * diff pieces (by default is 2mb) witch is the same default of the {@link FileSplitter} and {@link FileByteSplitter}\n+ * @author jsanca\n+ */\n+public class FileJoiner implements AutoCloseable, Flushable, Closeable {\n+\n+    private final OutputStream outputStream;\n+    private final byte []      buffer;\n+    private final Function<File, InputStream> inputStreamCreatorFunction;\n+\n+    /**\n+     * Defaut size for the chucks, 2mb\n+     */\n+    private static final int CHUNK_SIZE = Config.getIntProperty(\"FILE_SPLITTER_CHUNK_SIZE\", 2097152); // 2mb\n+\n+\n+    private static InputStream createCompressorOutputStream (final File file) {\n+\n+        final String compressor   = Config.getStringProperty(\"FILE_SPLITTER_COMPRESSOR\", \"gzip\");\n+        return Try.of(()->FileUtil.createInputStream(file.toPath(), compressor)).getOrElseThrow(DotRuntimeException::new);\n+    }\n+\n+    public FileJoiner(final File file) throws IOException {\n+        this (FileUtil.createOutputStream(file), FileJoiner::createCompressorOutputStream, CHUNK_SIZE);\n+    }\n+\n+    public FileJoiner(final OutputStream outputStream) {\n+        this (outputStream, FileJoiner::createCompressorOutputStream, CHUNK_SIZE);\n+    }\n+\n+    public FileJoiner(final OutputStream outputStream, final int bufferSize) {\n+        this (outputStream, FileJoiner::createCompressorOutputStream, bufferSize);\n+    }\n+\n+    public FileJoiner(final OutputStream outputStream,\n+                      final Function<File, InputStream> inputStreamCreatorFunction,\n+                      final int bufferSize) {\n+\n+        this.outputStream               = outputStream;\n+        this.inputStreamCreatorFunction = inputStreamCreatorFunction;\n+        this.buffer                     = bufferSize>0?new byte[bufferSize]:\n+                                            new byte[1]; // probably won't need any buffer to join.\n+    }\n+\n+    public void join (final File file) {\n+\n+        try (InputStream inputStream = this.inputStreamCreatorFunction.apply(file)) {\n+\n+            int bytesRead = 0;\n+            while ((bytesRead = inputStream.read(this.buffer)) > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDIzMDM0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/GenerateMetadataConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzoyOVrOHZzv6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzoyOVrOHZzv6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyNDI5Nw==", "bodyText": "Codacy found an issue: Field store has the same name as a method", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r496824297", "createdAt": "2020-09-29T15:37:29Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/GenerateMetadataConfig.java", "diffHunk": "@@ -0,0 +1,202 @@\n+package com.dotcms.storage;\n+\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Configuration to generate the meta data.\n+ *\n+ * @author jsanca\n+ */\n+public class GenerateMetadataConfig {\n+\n+    /**\n+     * Provides the key for the storage\n+     */\n+    private final StorageKey storageKey;\n+\n+    /**\n+     * If true, means the metadata output will be stores in the metaDataFileSupplier file\n+     */\n+    private final boolean store;\n+\n+    /**\n+     * if store is true, and you want to force always the file generation set this to true (keep in\n+     * mind it could be expensive)\n+     */\n+    private final boolean override;\n+\n+    /**\n+     * On huge file, we probably do not want to parse all the content, so this max will limited how\n+     * much do we want to read\n+     */\n+    private final long maxLength;\n+\n+    /**\n+     * {@link Predicate} filter the meta data key for the map result generation\n+     */\n+    private final Predicate<String> metaDataKeyFilter;\n+\n+    /**\n+     * If true, means the medatada output will be stores in the memory cache.\n+     */\n+    private final boolean cache;\n+\n+    /**\n+     * Cache key supplier, if cache is true\n+     */\n+    private final Supplier<String> cacheKeySupplier;\n+\n+    /**\n+     * If true, means the metadata generated will be full except if there is any metaDataKeyFilter,\n+     * only these fields will be accepted.\n+     */\n+    private final boolean full;\n+\n+    private GenerateMetadataConfig(final Builder builder) {\n+\n+        this.cache = builder.cache;\n+        this.cacheKeySupplier = builder.cacheKeySupplier;\n+        this.maxLength = builder.maxLength;\n+        this.storageKey = builder.storageKey;\n+        this.metaDataKeyFilter = builder.metaDataKeyFilter;\n+        this.override = builder.override;\n+        this.store = builder.store;\n+        this.full = builder.full;\n+    }\n+\n+    public StorageKey getStorageKey() {\n+        return storageKey;\n+    }\n+\n+    public boolean isStore() {\n+        return store;\n+    }\n+\n+    public boolean isOverride() {\n+        return override;\n+    }\n+\n+    public long getMaxLength() {\n+        return maxLength;\n+    }\n+\n+    public Predicate<String> getMetaDataKeyFilter() {\n+        return metaDataKeyFilter;\n+    }\n+\n+    public boolean isCache() {\n+        return cache;\n+    }\n+\n+    public Supplier<String> getCacheKeySupplier() {\n+        return cacheKeySupplier;\n+    }\n+\n+    public boolean isFull() {\n+        return full;\n+    }\n+\n+    public static final class Builder {\n+\n+        /**\n+         * If true, means the metadata generated will be full except if there is any\n+         * metaDataKeyFilter, only these fields will be accepted.\n+         */\n+        private boolean full;\n+\n+        /**\n+         * Provides the supplier to stores the metadata generated, if store is true\n+         */\n+        private StorageKey storageKey;\n+\n+        /**\n+         * If true, means the metadata output will be storage\n+         */\n+        private boolean store;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDIzMDQ1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzozMFrOHZzv-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzozMFrOHZzv-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyNDMxMw==", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r496824313", "createdAt": "2020-09-29T15:37:30Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDIzMDYyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/storage/ContentletMetadataAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzozMVrOHZzwEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzozMVrOHZzwEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyNDMzNg==", "bodyText": "Codacy found an issue: Avoid unused imports such as 'com.dotcms.datagen.TestDataUtils'", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r496824336", "createdAt": "2020-09-29T15:37:31Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/storage/ContentletMetadataAPITest.java", "diffHunk": "@@ -0,0 +1,365 @@\n+package com.dotcms.storage;\n+\n+import static com.dotcms.datagen.TestDataUtils.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDIzMDc4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/GenerateMetadataConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzozMlrOHZzwJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzozMlrOHZzwJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyNDM1Nw==", "bodyText": "Codacy found an issue: Field maxLength has the same name as a method", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r496824357", "createdAt": "2020-09-29T15:37:32Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/GenerateMetadataConfig.java", "diffHunk": "@@ -0,0 +1,202 @@\n+package com.dotcms.storage;\n+\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Configuration to generate the meta data.\n+ *\n+ * @author jsanca\n+ */\n+public class GenerateMetadataConfig {\n+\n+    /**\n+     * Provides the key for the storage\n+     */\n+    private final StorageKey storageKey;\n+\n+    /**\n+     * If true, means the metadata output will be stores in the metaDataFileSupplier file\n+     */\n+    private final boolean store;\n+\n+    /**\n+     * if store is true, and you want to force always the file generation set this to true (keep in\n+     * mind it could be expensive)\n+     */\n+    private final boolean override;\n+\n+    /**\n+     * On huge file, we probably do not want to parse all the content, so this max will limited how\n+     * much do we want to read\n+     */\n+    private final long maxLength;\n+\n+    /**\n+     * {@link Predicate} filter the meta data key for the map result generation\n+     */\n+    private final Predicate<String> metaDataKeyFilter;\n+\n+    /**\n+     * If true, means the medatada output will be stores in the memory cache.\n+     */\n+    private final boolean cache;\n+\n+    /**\n+     * Cache key supplier, if cache is true\n+     */\n+    private final Supplier<String> cacheKeySupplier;\n+\n+    /**\n+     * If true, means the metadata generated will be full except if there is any metaDataKeyFilter,\n+     * only these fields will be accepted.\n+     */\n+    private final boolean full;\n+\n+    private GenerateMetadataConfig(final Builder builder) {\n+\n+        this.cache = builder.cache;\n+        this.cacheKeySupplier = builder.cacheKeySupplier;\n+        this.maxLength = builder.maxLength;\n+        this.storageKey = builder.storageKey;\n+        this.metaDataKeyFilter = builder.metaDataKeyFilter;\n+        this.override = builder.override;\n+        this.store = builder.store;\n+        this.full = builder.full;\n+    }\n+\n+    public StorageKey getStorageKey() {\n+        return storageKey;\n+    }\n+\n+    public boolean isStore() {\n+        return store;\n+    }\n+\n+    public boolean isOverride() {\n+        return override;\n+    }\n+\n+    public long getMaxLength() {\n+        return maxLength;\n+    }\n+\n+    public Predicate<String> getMetaDataKeyFilter() {\n+        return metaDataKeyFilter;\n+    }\n+\n+    public boolean isCache() {\n+        return cache;\n+    }\n+\n+    public Supplier<String> getCacheKeySupplier() {\n+        return cacheKeySupplier;\n+    }\n+\n+    public boolean isFull() {\n+        return full;\n+    }\n+\n+    public static final class Builder {\n+\n+        /**\n+         * If true, means the metadata generated will be full except if there is any\n+         * metaDataKeyFilter, only these fields will be accepted.\n+         */\n+        private boolean full;\n+\n+        /**\n+         * Provides the supplier to stores the metadata generated, if store is true\n+         */\n+        private StorageKey storageKey;\n+\n+        /**\n+         * If true, means the metadata output will be storage\n+         */\n+        private boolean store;\n+\n+        /**\n+         * if store is true, and you want to force always the file generation set this to true (keep\n+         * in mind it could be expensive)\n+         */\n+        private boolean override;\n+\n+        /**\n+         * On huge file, we probably do not want to parse all the content, so this max will limited\n+         * how much do we want to read\n+         */\n+        private long maxLength = FileStorageAPI.configuredMaxLength();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDIzMDg0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/storage/ContentletMetadataAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzozM1rOHZzwMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNTozNzozM1rOHZzwMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyNDM3MA==", "bodyText": "Codacy found an issue: Avoid unused imports such as 'com.dotcms.datagen.TestDataUtils'", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r496824370", "createdAt": "2020-09-29T15:37:33Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/storage/ContentletMetadataAPITest.java", "diffHunk": "@@ -0,0 +1,365 @@\n+package com.dotcms.storage;\n+\n+import static com.dotcms.datagen.TestDataUtils.*;\n+import static com.dotcms.storage.StoragePersistenceProvider.DEFAULT_STORAGE_TYPE;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.datagen.TestDataUtils;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMTI5MjQ0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadata.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxOToyODozMVrOHZ932w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxODoyMjowNVrOHiUm4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk5MDE3MQ==", "bodyText": "Is this what is going to be stored in cache/memory?  Does this class need to implement serializable?\nDo we need to store both fullMetadataMap and basicMetadataMap ?  I would say we only need a metaDataMap that we filter for basicProperties if they are asked for,", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r496990171", "createdAt": "2020-09-29T19:28:31Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadata.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.dotcms.storage;\n+\n+import java.util.Map;\n+\n+/**\n+ * Encapsulates a collection with field with full metadata generation and\n+ * all fields with basic metadata\n+ */\n+public class ContentletMetadata {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU0OTA3OA==", "bodyText": "This is just a class that presents them both as (as an aggregation I suppose) since Full metadata isn't meant to live in cache.\nThe metadata maps are already filtered/cached (in the specific case of the basic md).", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503549078", "createdAt": "2020-10-12T21:41:30Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadata.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.dotcms.storage;\n+\n+import java.util.Map;\n+\n+/**\n+ * Encapsulates a collection with field with full metadata generation and\n+ * all fields with basic metadata\n+ */\n+public class ContentletMetadata {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk5MDE3MQ=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU2NjEzMA==", "bodyText": "Only basic md lives in cache", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503566130", "createdAt": "2020-10-12T22:31:08Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadata.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.dotcms.storage;\n+\n+import java.util.Map;\n+\n+/**\n+ * Encapsulates a collection with field with full metadata generation and\n+ * all fields with basic metadata\n+ */\n+public class ContentletMetadata {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk5MDE3MQ=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc1MTI2NQ==", "bodyText": "Modified the type of the maps to be Map<String, Serialiable> to ensure they'll make it safe into cache", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505751265", "createdAt": "2020-10-15T18:22:05Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadata.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.dotcms.storage;\n+\n+import java.util.Map;\n+\n+/**\n+ * Encapsulates a collection with field with full metadata generation and\n+ * all fields with basic metadata\n+ */\n+public class ContentletMetadata {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk5MDE3MQ=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMzU1MTYyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadataAPIImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNzowNjowNVrOHdRmDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNzowNjowNVrOHdRmDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ1OTAyMg==", "bodyText": "I think it's cleaner to have a collection with all keys and then just:\nif (myCollection.contains(key)){\n    reduceMap.put(key, originalMap.get(key));\n}", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r500459022", "createdAt": "2020-10-06T17:06:05Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadataAPIImpl.java", "diffHunk": "@@ -0,0 +1,384 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.contenttype.model.field.BinaryField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.portlets.contentlet.business.ContentletCache;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.StringUtils;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Default implementation\n+ * @author jsanca\n+ */\n+public class ContentletMetadataAPIImpl implements ContentletMetadataAPI {\n+\n+    private static final String METADATA_GROUP_NAME = \"METADATA_GROUP_NAME\";\n+    private static final String DEFAULT_STORAGE_TYPE = \"DEFAULT_STORAGE_TYPE\";\n+    private static final String DOT_METADATA = \"dotmetadata\";\n+    private static final String DEFAULT_METADATA_GROUP_NAME = DOT_METADATA;\n+    private final FileStorageAPI fileStorageAPI;\n+\n+    public ContentletMetadataAPIImpl() {\n+        this(APILocator.getFileStorageAPI());\n+    }\n+\n+    @VisibleForTesting\n+    public ContentletMetadataAPIImpl(final FileStorageAPI fileStorageAPI) {\n+        this.fileStorageAPI = fileStorageAPI;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet Contentlet\n+     * @param basicBinaryFieldNameSet {@link Set} fields to generate basic metadata\n+     * @param fullBinaryFieldNameSet  {@link Set} fields to generate full metadata\n+     * @return\n+     * @throws IOException\n+     */\n+    @Override\n+    public ContentletMetadata generateContentletMetadata(final Contentlet contentlet,\n+                                                         final Set<String> basicBinaryFieldNameSet,\n+                                                         final Set<String> fullBinaryFieldNameSet) throws IOException {\n+\n+        final ImmutableMap.Builder<String, Map<String, Object>> fullMetadataMap  = new ImmutableMap.Builder<>();\n+        final ImmutableMap.Builder<String, Map<String, Object>> basicMetadataMap = new ImmutableMap.Builder<>();\n+        final  Map<String, Field>  fieldMap   = contentlet.getContentType().fieldMap();\n+        /*\n+\t\tVerify if it is enabled the option to always regenerate metadata files on reindex,\n+\t\tenabling this could affect greatly the performance of a reindex process.\n+\t\t */\n+        final boolean alwaysRegenerateMetadata = Config\n+                .getBooleanProperty(\"always.regenerate.metadata.on.reindex\", false);\n+\n+        Logger.debug(this, ()-> \"Generating the metadata for contentlet, id = \" + contentlet.getIdentifier());\n+\n+        // Full MD is stored in disc (FS or DB)\n+        this.generateFullMetadata (contentlet, fullBinaryFieldNameSet, fullMetadataMap, fieldMap, alwaysRegenerateMetadata);\n+        //Basic MD lives only in cache\n+        this.generateBasicMetadata(contentlet, basicBinaryFieldNameSet, fullBinaryFieldNameSet, basicMetadataMap, fieldMap, alwaysRegenerateMetadata);\n+\n+        return new ContentletMetadata(fullMetadataMap.build(), basicMetadataMap.build());\n+    }\n+\n+    /**\n+     * Basic metadata generation entry point.\n+     * @param contentlet\n+     * @param basicBinaryFieldNameSet\n+     * @param fullBinaryFieldNameSet\n+     * @param basicMetadataMap\n+     * @param fieldMap\n+     * @param alwaysRegenerateMetadata\n+     * @throws IOException\n+     */\n+    private void generateBasicMetadata(final Contentlet contentlet,\n+                                       final Set<String> basicBinaryFieldNameSet,\n+                                       final Set<String> fullBinaryFieldNameSet,\n+                                       final ImmutableMap.Builder<String, Map<String, Object>> basicMetadataMap,\n+                                       final Map<String, Field> fieldMap,\n+                                       final boolean alwaysRegenerateMetadata) throws IOException {\n+\n+        final StorageType storageType = StoragePersistenceProvider.getStorageType();\n+        Map<String, Object> metadataMap;\n+        final String metadataBucketName = Config.getStringProperty(METADATA_GROUP_NAME, DEFAULT_METADATA_GROUP_NAME);\n+        for (final String basicBinaryFieldName : basicBinaryFieldNameSet) {\n+\n+            final File file           = contentlet.getBinary(basicBinaryFieldName);\n+            final String metadataPath = this.getFileName(contentlet, basicBinaryFieldName);\n+\n+            if (null != file && file.exists() && file.canRead()) {\n+\n+                // if already included on the full, the file was already generated, just need to add the basic to the cache.\n+                final Set<String> metadataFields = this.getMetadataFields(fieldMap.get(basicBinaryFieldName).id());\n+\n+                if (fullBinaryFieldNameSet.contains(basicBinaryFieldName)) {\n+\n+                    // if it is included on the full keys, we only have to store the meta in the cache.\n+                    metadataMap = this.fileStorageAPI.generateBasicMetaData(file,\n+                            metadataKey -> metadataFields.isEmpty() || metadataFields\n+                                    .contains(metadataKey));\n+                    CacheLocator.getContentletCache()\n+                            .addMetadataMap(contentlet.getInode() + basicBinaryFieldName, metadataMap);\n+                } else {\n+\n+\n+                    metadataMap = this.fileStorageAPI.generateMetaData(file,\n+                            new GenerateMetadataConfig.Builder()\n+                                    .full(false)\n+                                    .override(alwaysRegenerateMetadata)\n+                                    .store(true)\n+                                    .cache(()-> ContentletCache.META_DATA_MAP_KEY + contentlet.getInode() + basicBinaryFieldName)\n+                                    .metaDataKeyFilter(metadataKey -> metadataFields.isEmpty()\n+                                            || metadataFields.contains(metadataKey))\n+                                    .storageKey(new StorageKey.Builder().group(metadataBucketName).path(metadataPath).storage(storageType).build())\n+                                    .build()\n+                    );\n+                }\n+\n+                basicMetadataMap.put(basicBinaryFieldName, metadataMap);\n+            } else {\n+               //We're dealing with a  non required neither set binary field. No need to throw an exception. Just continue processing.\n+               Logger.warn(ContentletMetadataAPIImpl.class, String.format(\"The binary field : `%s`, is null, does not exists or can not be accessed\",basicBinaryFieldName));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Metadata file generator.\n+     * @param contentlet\n+     * @param fieldVariableName\n+     * @return\n+     */\n+    private String getFileName (final Contentlet contentlet, final String fieldVariableName) {\n+\n+        final String inode        = contentlet.getInode();\n+        final String fileName     = fieldVariableName + \"-metadata.json\";\n+        return StringUtils.builder(File.separator,\n+                inode.charAt(0), File.separator, inode.charAt(1), File.separator, inode, File.separator,\n+                fileName).toString();\n+    }\n+\n+    private void generateFullMetadata(final Contentlet contentlet,\n+                                      final Set<String> fullBinaryFieldNameSet,\n+                                      final ImmutableMap.Builder<String, Map<String, Object>> fullMetadataMap,\n+                                      final Map<String, Field> fieldMap,\n+                                      final boolean alwaysRegenerateMetadata) throws IOException {\n+\n+\n+        final StorageType storageType = StoragePersistenceProvider.getStorageType();\n+        final String metadataBucketName = Config.getStringProperty(METADATA_GROUP_NAME,\n+                DOT_METADATA);\n+        for (final String fullBinaryFieldName : fullBinaryFieldNameSet) {\n+            Logger.info(ContentletMetadataAPIImpl.class,\"\");\n+            final File file           = contentlet.getBinary(fullBinaryFieldName);\n+            final String metadataPath = this.getFileName(contentlet, fullBinaryFieldName);\n+            if (null != file && file.exists() && file.canRead()) {\n+                final Set<String> metadataFields = this.getMetadataFields(fieldMap.get(fullBinaryFieldName).id());\n+                final Map<String, Object> metadataMap = this.fileStorageAPI.generateMetaData(file,\n+                        new GenerateMetadataConfig.Builder()\n+                            .full(true)\n+                            .override(alwaysRegenerateMetadata)\n+                            .cache(false)  // do not want cache on full meta\n+                            .store(true)\n+                            .metaDataKeyFilter(metadataKey -> metadataFields.isEmpty()\n+                                    || metadataFields.contains(metadataKey))\n+                            .storageKey(new StorageKey.Builder().group(metadataBucketName).path(metadataPath).storage(storageType).build())\n+                            .build()\n+                        );\n+\n+                fullMetadataMap.put(fullBinaryFieldName, metadataMap);\n+            } else {\n+\n+                throw new IOException(\"The file: \" + file + \", is null, does not exists or can not access\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * based on the identifier this will give you a set of fields for the metadata generation\n+     * fields are specific to the CT or preconfigured\n+     * @param fieldIdentifier\n+     * @return\n+     */\n+    @VisibleForTesting\n+    Set<String> getMetadataFields (final String fieldIdentifier) {\n+\n+        final Optional<FieldVariable> customIndexMetaDataFieldsOpt =\n+                Try.of(()->FactoryLocator.getFieldFactory().byFieldVariableKey(fieldIdentifier, BinaryField.INDEX_METADATA_FIELDS)).getOrElse(Optional.empty());\n+\n+        final Set<String> metadataFields = customIndexMetaDataFieldsOpt.isPresent()?\n+                new HashSet<>(Arrays.asList(customIndexMetaDataFieldsOpt.get().value().split(StringPool.COMMA))):\n+                this.getConfiguredMetadataFields();\n+\n+        Logger.info(ContentletMetadataAPIImpl.class,\n+                () -> String.format(\" `%s` has these fields: `%s` \", fieldIdentifier, String\n+                        .join(\",\", metadataFields)));\n+        return metadataFields;\n+    }\n+\n+    /**\n+     * Reads INDEX_METADATA_FIELDS for  pre-configured metadata fields\n+     * @return\n+     */\n+    private Set<String> getConfiguredMetadataFields(){\n+\n+        final java.lang.String configFields = Config.getStringProperty(\"INDEX_METADATA_FIELDS\", null);\n+\n+        return UtilMethods.isSet(configFields)?\n+            new HashSet<>(Arrays.asList( configFields.split(StringPool.COMMA))):\n+            Collections.emptySet();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet {@link Contentlet}\n+     * @return\n+     * @throws IOException\n+     */\n+    @Override\n+    public ContentletMetadata generateContentletMetadata(final Contentlet contentlet) throws IOException {\n+\n+        final Tuple2<Set<String>, Set<String>> binaryFields = this.findBinaryFields(contentlet);\n+        return this.generateContentletMetadata(contentlet, binaryFields._1(), binaryFields._2());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet  {@link Contentlet}\n+     * @param field       {@link Field}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> getMetadata(final Contentlet contentlet, final Field field) {\n+\n+        return this.getMetadata(contentlet, field.variable());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet          {@link Contentlet}\n+     * @param fieldVariableName  {@link String}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> getMetadata(final Contentlet contentlet,final  String fieldVariableName) {\n+\n+        final String storageType        = Config.getStringProperty(DEFAULT_STORAGE_TYPE, StorageType.FILE_SYSTEM.name());\n+        final String metadataBucketName = Config.getStringProperty(METADATA_GROUP_NAME,\n+                DOT_METADATA);\n+        final String metadataPath       = this.getFileName(contentlet, fieldVariableName);\n+\n+        return this.fileStorageAPI.retrieveMetaData(\n+                new RequestMetadata.Builder()\n+                        .wrapMetadataMapForCache(this::wrapMetadataMapForCache)\n+                        .cache(()-> ContentletCache.META_DATA_MAP_KEY + contentlet.getInode() + fieldVariableName)\n+                        .storageKey(new StorageKey.Builder().group(metadataBucketName).path(metadataPath).storage(storageType).build())\n+                        .build()\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet          {@link Contentlet}\n+     * @param fieldVariableName  {@link String}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> getMetadataNoCache(final Contentlet contentlet,\n+            final String fieldVariableName) {\n+\n+        final StorageType storageType = StoragePersistenceProvider.getStorageType();\n+        final String metadataBucketName = Config\n+                .getStringProperty(METADATA_GROUP_NAME, DOT_METADATA);\n+        final String metadataPath = this.getFileName(contentlet, fieldVariableName);\n+\n+        return this.fileStorageAPI.retrieveMetaData(\n+                new RequestMetadata.Builder()\n+                        .cache(false)\n+                        .wrapMetadataMapForCache(this::wrapMetadataMapForCache) // why is it needed for the non-cached version??\n+                        .storageKey(\n+                                new StorageKey.Builder().group(metadataBucketName).path(metadataPath)\n+                                        .storage(storageType).build())\n+                        .build()\n+        );\n+    }\n+\n+    /**\n+     * filters exclude non-basic metadata fields\n+     * @param originalMap\n+     * @return\n+     */\n+    private Map<String, Object> wrapMetadataMapForCache (final Map<String, Object> originalMap) {\n+\n+        final ImmutableMap.Builder<String, Object> reduceMap = new ImmutableMap.Builder<>();\n+\n+        for (final String key : originalMap.keySet()) {\n+\n+            if (FileStorageAPI.TITLE_META_KEY.equals(key)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 320}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMzU3OTAyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNzoxMzowOFrOHdR27Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODozNDowNFrOHgJPSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ2MzM0MQ==", "bodyText": "shouldn't all these queries be in a factory class? Many methods have direct access to the database and we don't usually do it in an API method", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r500463341", "createdAt": "2020-10-06T17:13:08Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ2Nzg1MQ==", "bodyText": "I am ok with queries in the API - as our API --> Factory pattern is old and boilerplate heavy and not worth the double interfaces (api and factory) they are written with.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503467851", "createdAt": "2020-10-12T18:34:04Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ2MzM0MQ=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMzYwMDYzOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/S3StoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNzoxODo0MFrOHdSEYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzoyNjo1OVrOHiSa_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ2Njc4NA==", "bodyText": "why is this commented? if not used, it should be removed", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r500466784", "createdAt": "2020-10-06T17:18:40Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/main/java/com/dotcms/storage/S3StoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,221 @@\n+package com.dotcms.storage;\n+\n+public class S3StoragePersistenceAPIImpl {\n+\n+}\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxNTQ1NA==", "bodyText": "Sachez wanted to keep such code at hand but I guess you're right. Removed", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505715454", "createdAt": "2020-10-15T17:26:59Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/S3StoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,221 @@\n+package com.dotcms.storage;\n+\n+public class S3StoragePersistenceAPIImpl {\n+\n+}\n+/*", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ2Njc4NA=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMzYyMDA2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/test/java/com/dotmarketing/util/FileUtilTest.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNzoyMzo0NlrOHdSQkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMjowMDoyNVrOHgOnpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ2OTkwNw==", "bodyText": "why don't you get the real asset path from the config properties?", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r500469907", "createdAt": "2020-10-06T17:23:46Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/test/java/com/dotmarketing/util/FileUtilTest.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.dotmarketing.util;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.dotcms.UnitTestBase;\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import org.junit.Test;\n+\n+public class FileUtilTest extends UnitTestBase {\n+\n+    /**\n+     * Given scenario: I have a file that belongs under my realAssets path (somewhere)\n+     * Expected Result: The method gets me the relative part of the file's absolute path that is under the real asset path.\n+     */\n+    @Test\n+    public void Test_Get_Relative_Path_Expect_Match(){\n+        final String relativePart = \"/4/1/419bacda-1e1d-412e-b73e-db514289b71f/fileAsset/test_image11600880647045.jpg\";\n+        final String realAssetPath = \"/Users/fabrizzio/code/servers/server1/assets/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQxNjY3NA==", "bodyText": "it's a unit test.  I wanted to avoid using api calls such as\nAPILocator.getFileAssetAPI().getRealAssetsRootPath()\nor \nConfig.getStringProperty(\"ASSET_REAL_PATH\")\n\nbesides, it's an example.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503416674", "createdAt": "2020-10-12T16:48:15Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/test/java/com/dotmarketing/util/FileUtilTest.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.dotmarketing.util;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.dotcms.UnitTestBase;\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import org.junit.Test;\n+\n+public class FileUtilTest extends UnitTestBase {\n+\n+    /**\n+     * Given scenario: I have a file that belongs under my realAssets path (somewhere)\n+     * Expected Result: The method gets me the relative part of the file's absolute path that is under the real asset path.\n+     */\n+    @Test\n+    public void Test_Get_Relative_Path_Expect_Match(){\n+        final String relativePart = \"/4/1/419bacda-1e1d-412e-b73e-db514289b71f/fileAsset/test_image11600880647045.jpg\";\n+        final String realAssetPath = \"/Users/fabrizzio/code/servers/server1/assets/\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ2OTkwNw=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUyMDQyNQ==", "bodyText": "Yeah, I am not sure we need the two extra methods in the FileUtils.\nWe also have the ConfigUtils.getAbsoluteAssetsRootPath() which I think has the logic and is where we should read the /asset path from", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503520425", "createdAt": "2020-10-12T20:37:54Z", "author": {"login": "wezell"}, "path": "dotCMS/src/test/java/com/dotmarketing/util/FileUtilTest.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.dotmarketing.util;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.dotcms.UnitTestBase;\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import org.junit.Test;\n+\n+public class FileUtilTest extends UnitTestBase {\n+\n+    /**\n+     * Given scenario: I have a file that belongs under my realAssets path (somewhere)\n+     * Expected Result: The method gets me the relative part of the file's absolute path that is under the real asset path.\n+     */\n+    @Test\n+    public void Test_Get_Relative_Path_Expect_Match(){\n+        final String relativePart = \"/4/1/419bacda-1e1d-412e-b73e-db514289b71f/fileAsset/test_image11600880647045.jpg\";\n+        final String realAssetPath = \"/Users/fabrizzio/code/servers/server1/assets/\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ2OTkwNw=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU1NjAwNA==", "bodyText": "alright I'm moving these methods", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503556004", "createdAt": "2020-10-12T22:00:25Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/test/java/com/dotmarketing/util/FileUtilTest.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.dotmarketing.util;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.dotcms.UnitTestBase;\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import org.junit.Test;\n+\n+public class FileUtilTest extends UnitTestBase {\n+\n+    /**\n+     * Given scenario: I have a file that belongs under my realAssets path (somewhere)\n+     * Expected Result: The method gets me the relative part of the file's absolute path that is under the real asset path.\n+     */\n+    @Test\n+    public void Test_Get_Relative_Path_Expect_Match(){\n+        final String relativePart = \"/4/1/419bacda-1e1d-412e-b73e-db514289b71f/fileAsset/test_image11600880647045.jpg\";\n+        final String realAssetPath = \"/Users/fabrizzio/code/servers/server1/assets/\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ2OTkwNw=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzMzYyMTEzOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/test/java/com/dotmarketing/util/FileUtilTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNzoyNDowNFrOHdSRQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNzoyNDowNFrOHdSRQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQ3MDA4Mw==", "bodyText": "same here", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r500470083", "createdAt": "2020-10-06T17:24:04Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/test/java/com/dotmarketing/util/FileUtilTest.java", "diffHunk": "@@ -0,0 +1,49 @@\n+package com.dotmarketing.util;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import com.dotcms.UnitTestBase;\n+import java.io.File;\n+import java.nio.file.Paths;\n+import java.util.Optional;\n+import org.junit.Test;\n+\n+public class FileUtilTest extends UnitTestBase {\n+\n+    /**\n+     * Given scenario: I have a file that belongs under my realAssets path (somewhere)\n+     * Expected Result: The method gets me the relative part of the file's absolute path that is under the real asset path.\n+     */\n+    @Test\n+    public void Test_Get_Relative_Path_Expect_Match(){\n+        final String relativePart = \"/4/1/419bacda-1e1d-412e-b73e-db514289b71f/fileAsset/test_image11600880647045.jpg\";\n+        final String realAssetPath = \"/Users/fabrizzio/code/servers/server1/assets/\";\n+        final String absolutePath = realAssetPath + relativePart;\n+        final File file = mock(File.class);\n+        when(file.getAbsolutePath()).thenReturn(Paths.get(absolutePath).normalize().toString());\n+        final Optional<String> optional = FileUtil\n+                .getRealAssetsPathRelativePiece(file, () -> realAssetPath);\n+        assertTrue(optional.isPresent());\n+        assertEquals(relativePart,optional.get());\n+    }\n+\n+    /**\n+     * Given scenario: I am passing a file that doesnt belong under real-assets-path\n+     * Expected Result: an empty option since there is no relative part\n+     */\n+    @Test\n+    public void Test_Get_Relative_Path_Expect_Mismatch(){\n+        final String realAssetPath = \"/Users/fabrizzio/code/servers/server1/assets\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzQ2NDk3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadataAPIImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODozMjowOVrOHgJMFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxODowMjozN1rOHiTvRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ2NzAzMA==", "bodyText": "I'd remove the extra sort.  The fields come back in sort order anyway - which also takes into account their velocity_var_name as a secondary sort.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503467030", "createdAt": "2020-10-12T18:32:09Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadataAPIImpl.java", "diffHunk": "@@ -0,0 +1,384 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.contenttype.model.field.BinaryField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.portlets.contentlet.business.ContentletCache;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.StringUtils;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Default implementation\n+ * @author jsanca\n+ */\n+public class ContentletMetadataAPIImpl implements ContentletMetadataAPI {\n+\n+    private static final String METADATA_GROUP_NAME = \"METADATA_GROUP_NAME\";\n+    private static final String DEFAULT_STORAGE_TYPE = \"DEFAULT_STORAGE_TYPE\";\n+    private static final String DOT_METADATA = \"dotmetadata\";\n+    private static final String DEFAULT_METADATA_GROUP_NAME = DOT_METADATA;\n+    private final FileStorageAPI fileStorageAPI;\n+\n+    public ContentletMetadataAPIImpl() {\n+        this(APILocator.getFileStorageAPI());\n+    }\n+\n+    @VisibleForTesting\n+    public ContentletMetadataAPIImpl(final FileStorageAPI fileStorageAPI) {\n+        this.fileStorageAPI = fileStorageAPI;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet Contentlet\n+     * @param basicBinaryFieldNameSet {@link Set} fields to generate basic metadata\n+     * @param fullBinaryFieldNameSet  {@link Set} fields to generate full metadata\n+     * @return\n+     * @throws IOException\n+     */\n+    @Override\n+    public ContentletMetadata generateContentletMetadata(final Contentlet contentlet,\n+                                                         final Set<String> basicBinaryFieldNameSet,\n+                                                         final Set<String> fullBinaryFieldNameSet) throws IOException {\n+\n+        final ImmutableMap.Builder<String, Map<String, Object>> fullMetadataMap  = new ImmutableMap.Builder<>();\n+        final ImmutableMap.Builder<String, Map<String, Object>> basicMetadataMap = new ImmutableMap.Builder<>();\n+        final  Map<String, Field>  fieldMap   = contentlet.getContentType().fieldMap();\n+        /*\n+\t\tVerify if it is enabled the option to always regenerate metadata files on reindex,\n+\t\tenabling this could affect greatly the performance of a reindex process.\n+\t\t */\n+        final boolean alwaysRegenerateMetadata = Config\n+                .getBooleanProperty(\"always.regenerate.metadata.on.reindex\", false);\n+\n+        Logger.debug(this, ()-> \"Generating the metadata for contentlet, id = \" + contentlet.getIdentifier());\n+\n+        // Full MD is stored in disc (FS or DB)\n+        this.generateFullMetadata (contentlet, fullBinaryFieldNameSet, fullMetadataMap, fieldMap, alwaysRegenerateMetadata);\n+        //Basic MD lives only in cache\n+        this.generateBasicMetadata(contentlet, basicBinaryFieldNameSet, fullBinaryFieldNameSet, basicMetadataMap, fieldMap, alwaysRegenerateMetadata);\n+\n+        return new ContentletMetadata(fullMetadataMap.build(), basicMetadataMap.build());\n+    }\n+\n+    /**\n+     * Basic metadata generation entry point.\n+     * @param contentlet\n+     * @param basicBinaryFieldNameSet\n+     * @param fullBinaryFieldNameSet\n+     * @param basicMetadataMap\n+     * @param fieldMap\n+     * @param alwaysRegenerateMetadata\n+     * @throws IOException\n+     */\n+    private void generateBasicMetadata(final Contentlet contentlet,\n+                                       final Set<String> basicBinaryFieldNameSet,\n+                                       final Set<String> fullBinaryFieldNameSet,\n+                                       final ImmutableMap.Builder<String, Map<String, Object>> basicMetadataMap,\n+                                       final Map<String, Field> fieldMap,\n+                                       final boolean alwaysRegenerateMetadata) throws IOException {\n+\n+        final StorageType storageType = StoragePersistenceProvider.getStorageType();\n+        Map<String, Object> metadataMap;\n+        final String metadataBucketName = Config.getStringProperty(METADATA_GROUP_NAME, DEFAULT_METADATA_GROUP_NAME);\n+        for (final String basicBinaryFieldName : basicBinaryFieldNameSet) {\n+\n+            final File file           = contentlet.getBinary(basicBinaryFieldName);\n+            final String metadataPath = this.getFileName(contentlet, basicBinaryFieldName);\n+\n+            if (null != file && file.exists() && file.canRead()) {\n+\n+                // if already included on the full, the file was already generated, just need to add the basic to the cache.\n+                final Set<String> metadataFields = this.getMetadataFields(fieldMap.get(basicBinaryFieldName).id());\n+\n+                if (fullBinaryFieldNameSet.contains(basicBinaryFieldName)) {\n+\n+                    // if it is included on the full keys, we only have to store the meta in the cache.\n+                    metadataMap = this.fileStorageAPI.generateBasicMetaData(file,\n+                            metadataKey -> metadataFields.isEmpty() || metadataFields\n+                                    .contains(metadataKey));\n+                    CacheLocator.getContentletCache()\n+                            .addMetadataMap(contentlet.getInode() + basicBinaryFieldName, metadataMap);\n+                } else {\n+\n+\n+                    metadataMap = this.fileStorageAPI.generateMetaData(file,\n+                            new GenerateMetadataConfig.Builder()\n+                                    .full(false)\n+                                    .override(alwaysRegenerateMetadata)\n+                                    .store(true)\n+                                    .cache(()-> ContentletCache.META_DATA_MAP_KEY + contentlet.getInode() + basicBinaryFieldName)\n+                                    .metaDataKeyFilter(metadataKey -> metadataFields.isEmpty()\n+                                            || metadataFields.contains(metadataKey))\n+                                    .storageKey(new StorageKey.Builder().group(metadataBucketName).path(metadataPath).storage(storageType).build())\n+                                    .build()\n+                    );\n+                }\n+\n+                basicMetadataMap.put(basicBinaryFieldName, metadataMap);\n+            } else {\n+               //We're dealing with a  non required neither set binary field. No need to throw an exception. Just continue processing.\n+               Logger.warn(ContentletMetadataAPIImpl.class, String.format(\"The binary field : `%s`, is null, does not exists or can not be accessed\",basicBinaryFieldName));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Metadata file generator.\n+     * @param contentlet\n+     * @param fieldVariableName\n+     * @return\n+     */\n+    private String getFileName (final Contentlet contentlet, final String fieldVariableName) {\n+\n+        final String inode        = contentlet.getInode();\n+        final String fileName     = fieldVariableName + \"-metadata.json\";\n+        return StringUtils.builder(File.separator,\n+                inode.charAt(0), File.separator, inode.charAt(1), File.separator, inode, File.separator,\n+                fileName).toString();\n+    }\n+\n+    private void generateFullMetadata(final Contentlet contentlet,\n+                                      final Set<String> fullBinaryFieldNameSet,\n+                                      final ImmutableMap.Builder<String, Map<String, Object>> fullMetadataMap,\n+                                      final Map<String, Field> fieldMap,\n+                                      final boolean alwaysRegenerateMetadata) throws IOException {\n+\n+\n+        final StorageType storageType = StoragePersistenceProvider.getStorageType();\n+        final String metadataBucketName = Config.getStringProperty(METADATA_GROUP_NAME,\n+                DOT_METADATA);\n+        for (final String fullBinaryFieldName : fullBinaryFieldNameSet) {\n+            Logger.info(ContentletMetadataAPIImpl.class,\"\");\n+            final File file           = contentlet.getBinary(fullBinaryFieldName);\n+            final String metadataPath = this.getFileName(contentlet, fullBinaryFieldName);\n+            if (null != file && file.exists() && file.canRead()) {\n+                final Set<String> metadataFields = this.getMetadataFields(fieldMap.get(fullBinaryFieldName).id());\n+                final Map<String, Object> metadataMap = this.fileStorageAPI.generateMetaData(file,\n+                        new GenerateMetadataConfig.Builder()\n+                            .full(true)\n+                            .override(alwaysRegenerateMetadata)\n+                            .cache(false)  // do not want cache on full meta\n+                            .store(true)\n+                            .metaDataKeyFilter(metadataKey -> metadataFields.isEmpty()\n+                                    || metadataFields.contains(metadataKey))\n+                            .storageKey(new StorageKey.Builder().group(metadataBucketName).path(metadataPath).storage(storageType).build())\n+                            .build()\n+                        );\n+\n+                fullMetadataMap.put(fullBinaryFieldName, metadataMap);\n+            } else {\n+\n+                throw new IOException(\"The file: \" + file + \", is null, does not exists or can not access\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * based on the identifier this will give you a set of fields for the metadata generation\n+     * fields are specific to the CT or preconfigured\n+     * @param fieldIdentifier\n+     * @return\n+     */\n+    @VisibleForTesting\n+    Set<String> getMetadataFields (final String fieldIdentifier) {\n+\n+        final Optional<FieldVariable> customIndexMetaDataFieldsOpt =\n+                Try.of(()->FactoryLocator.getFieldFactory().byFieldVariableKey(fieldIdentifier, BinaryField.INDEX_METADATA_FIELDS)).getOrElse(Optional.empty());\n+\n+        final Set<String> metadataFields = customIndexMetaDataFieldsOpt.isPresent()?\n+                new HashSet<>(Arrays.asList(customIndexMetaDataFieldsOpt.get().value().split(StringPool.COMMA))):\n+                this.getConfiguredMetadataFields();\n+\n+        Logger.info(ContentletMetadataAPIImpl.class,\n+                () -> String.format(\" `%s` has these fields: `%s` \", fieldIdentifier, String\n+                        .join(\",\", metadataFields)));\n+        return metadataFields;\n+    }\n+\n+    /**\n+     * Reads INDEX_METADATA_FIELDS for  pre-configured metadata fields\n+     * @return\n+     */\n+    private Set<String> getConfiguredMetadataFields(){\n+\n+        final java.lang.String configFields = Config.getStringProperty(\"INDEX_METADATA_FIELDS\", null);\n+\n+        return UtilMethods.isSet(configFields)?\n+            new HashSet<>(Arrays.asList( configFields.split(StringPool.COMMA))):\n+            Collections.emptySet();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet {@link Contentlet}\n+     * @return\n+     * @throws IOException\n+     */\n+    @Override\n+    public ContentletMetadata generateContentletMetadata(final Contentlet contentlet) throws IOException {\n+\n+        final Tuple2<Set<String>, Set<String>> binaryFields = this.findBinaryFields(contentlet);\n+        return this.generateContentletMetadata(contentlet, binaryFields._1(), binaryFields._2());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet  {@link Contentlet}\n+     * @param field       {@link Field}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> getMetadata(final Contentlet contentlet, final Field field) {\n+\n+        return this.getMetadata(contentlet, field.variable());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet          {@link Contentlet}\n+     * @param fieldVariableName  {@link String}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> getMetadata(final Contentlet contentlet,final  String fieldVariableName) {\n+\n+        final String storageType        = Config.getStringProperty(DEFAULT_STORAGE_TYPE, StorageType.FILE_SYSTEM.name());\n+        final String metadataBucketName = Config.getStringProperty(METADATA_GROUP_NAME,\n+                DOT_METADATA);\n+        final String metadataPath       = this.getFileName(contentlet, fieldVariableName);\n+\n+        return this.fileStorageAPI.retrieveMetaData(\n+                new RequestMetadata.Builder()\n+                        .wrapMetadataMapForCache(this::wrapMetadataMapForCache)\n+                        .cache(()-> ContentletCache.META_DATA_MAP_KEY + contentlet.getInode() + fieldVariableName)\n+                        .storageKey(new StorageKey.Builder().group(metadataBucketName).path(metadataPath).storage(storageType).build())\n+                        .build()\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet          {@link Contentlet}\n+     * @param fieldVariableName  {@link String}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> getMetadataNoCache(final Contentlet contentlet,\n+            final String fieldVariableName) {\n+\n+        final StorageType storageType = StoragePersistenceProvider.getStorageType();\n+        final String metadataBucketName = Config\n+                .getStringProperty(METADATA_GROUP_NAME, DOT_METADATA);\n+        final String metadataPath = this.getFileName(contentlet, fieldVariableName);\n+\n+        return this.fileStorageAPI.retrieveMetaData(\n+                new RequestMetadata.Builder()\n+                        .cache(false)\n+                        .wrapMetadataMapForCache(this::wrapMetadataMapForCache) // why is it needed for the non-cached version??\n+                        .storageKey(\n+                                new StorageKey.Builder().group(metadataBucketName).path(metadataPath)\n+                                        .storage(storageType).build())\n+                        .build()\n+        );\n+    }\n+\n+    /**\n+     * filters exclude non-basic metadata fields\n+     * @param originalMap\n+     * @return\n+     */\n+    private Map<String, Object> wrapMetadataMapForCache (final Map<String, Object> originalMap) {\n+\n+        final ImmutableMap.Builder<String, Object> reduceMap = new ImmutableMap.Builder<>();\n+\n+        for (final String key : originalMap.keySet()) {\n+\n+            if (FileStorageAPI.TITLE_META_KEY.equals(key)) {\n+\n+                reduceMap.put(FileStorageAPI.TITLE_META_KEY, originalMap.get(key));\n+            }\n+\n+            if (FileStorageAPI.PATH_META_KEY.equals(key)) {\n+\n+                reduceMap.put(FileStorageAPI.PATH_META_KEY, originalMap.get(key));\n+            }\n+\n+            if (FileStorageAPI.LENGTH_META_KEY.equals(key)) {\n+\n+                reduceMap.put(FileStorageAPI.LENGTH_META_KEY, originalMap.get(key));\n+            }\n+\n+            if (FileStorageAPI.CONTENT_TYPE_META_KEY.equals(key)) {\n+\n+                reduceMap.put(FileStorageAPI.CONTENT_TYPE_META_KEY, originalMap.get(key));\n+            }\n+\n+            if (FileStorageAPI.MOD_DATE_META_KEY.equals(key)) {\n+\n+                reduceMap.put(FileStorageAPI.MOD_DATE_META_KEY, originalMap.get(key));\n+            }\n+\n+            if (FileStorageAPI.SHA226_META_KEY.equals(key)) {\n+\n+                reduceMap.put(FileStorageAPI.SHA226_META_KEY, originalMap.get(key));\n+            }\n+        }\n+\n+        return reduceMap.build();\n+    }\n+\n+    /**\n+     * This separates binaries in two sets candidates for the full meta and regular basic metadata\n+     * @param contentlet\n+     * @return\n+     */\n+    @VisibleForTesting\n+    Tuple2<Set<String>, Set<String>> findBinaryFields(final Contentlet contentlet) {\n+\n+        final List<Field> binaryFields = contentlet.getContentType().fields(BinaryField.class);\n+        binaryFields.sort(Comparator.comparing(Field::sortOrder));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 363}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczNzAyOA==", "bodyText": "done", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505737028", "createdAt": "2020-10-15T18:02:37Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadataAPIImpl.java", "diffHunk": "@@ -0,0 +1,384 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.contenttype.model.field.BinaryField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.portlets.contentlet.business.ContentletCache;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.StringUtils;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Default implementation\n+ * @author jsanca\n+ */\n+public class ContentletMetadataAPIImpl implements ContentletMetadataAPI {\n+\n+    private static final String METADATA_GROUP_NAME = \"METADATA_GROUP_NAME\";\n+    private static final String DEFAULT_STORAGE_TYPE = \"DEFAULT_STORAGE_TYPE\";\n+    private static final String DOT_METADATA = \"dotmetadata\";\n+    private static final String DEFAULT_METADATA_GROUP_NAME = DOT_METADATA;\n+    private final FileStorageAPI fileStorageAPI;\n+\n+    public ContentletMetadataAPIImpl() {\n+        this(APILocator.getFileStorageAPI());\n+    }\n+\n+    @VisibleForTesting\n+    public ContentletMetadataAPIImpl(final FileStorageAPI fileStorageAPI) {\n+        this.fileStorageAPI = fileStorageAPI;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet Contentlet\n+     * @param basicBinaryFieldNameSet {@link Set} fields to generate basic metadata\n+     * @param fullBinaryFieldNameSet  {@link Set} fields to generate full metadata\n+     * @return\n+     * @throws IOException\n+     */\n+    @Override\n+    public ContentletMetadata generateContentletMetadata(final Contentlet contentlet,\n+                                                         final Set<String> basicBinaryFieldNameSet,\n+                                                         final Set<String> fullBinaryFieldNameSet) throws IOException {\n+\n+        final ImmutableMap.Builder<String, Map<String, Object>> fullMetadataMap  = new ImmutableMap.Builder<>();\n+        final ImmutableMap.Builder<String, Map<String, Object>> basicMetadataMap = new ImmutableMap.Builder<>();\n+        final  Map<String, Field>  fieldMap   = contentlet.getContentType().fieldMap();\n+        /*\n+\t\tVerify if it is enabled the option to always regenerate metadata files on reindex,\n+\t\tenabling this could affect greatly the performance of a reindex process.\n+\t\t */\n+        final boolean alwaysRegenerateMetadata = Config\n+                .getBooleanProperty(\"always.regenerate.metadata.on.reindex\", false);\n+\n+        Logger.debug(this, ()-> \"Generating the metadata for contentlet, id = \" + contentlet.getIdentifier());\n+\n+        // Full MD is stored in disc (FS or DB)\n+        this.generateFullMetadata (contentlet, fullBinaryFieldNameSet, fullMetadataMap, fieldMap, alwaysRegenerateMetadata);\n+        //Basic MD lives only in cache\n+        this.generateBasicMetadata(contentlet, basicBinaryFieldNameSet, fullBinaryFieldNameSet, basicMetadataMap, fieldMap, alwaysRegenerateMetadata);\n+\n+        return new ContentletMetadata(fullMetadataMap.build(), basicMetadataMap.build());\n+    }\n+\n+    /**\n+     * Basic metadata generation entry point.\n+     * @param contentlet\n+     * @param basicBinaryFieldNameSet\n+     * @param fullBinaryFieldNameSet\n+     * @param basicMetadataMap\n+     * @param fieldMap\n+     * @param alwaysRegenerateMetadata\n+     * @throws IOException\n+     */\n+    private void generateBasicMetadata(final Contentlet contentlet,\n+                                       final Set<String> basicBinaryFieldNameSet,\n+                                       final Set<String> fullBinaryFieldNameSet,\n+                                       final ImmutableMap.Builder<String, Map<String, Object>> basicMetadataMap,\n+                                       final Map<String, Field> fieldMap,\n+                                       final boolean alwaysRegenerateMetadata) throws IOException {\n+\n+        final StorageType storageType = StoragePersistenceProvider.getStorageType();\n+        Map<String, Object> metadataMap;\n+        final String metadataBucketName = Config.getStringProperty(METADATA_GROUP_NAME, DEFAULT_METADATA_GROUP_NAME);\n+        for (final String basicBinaryFieldName : basicBinaryFieldNameSet) {\n+\n+            final File file           = contentlet.getBinary(basicBinaryFieldName);\n+            final String metadataPath = this.getFileName(contentlet, basicBinaryFieldName);\n+\n+            if (null != file && file.exists() && file.canRead()) {\n+\n+                // if already included on the full, the file was already generated, just need to add the basic to the cache.\n+                final Set<String> metadataFields = this.getMetadataFields(fieldMap.get(basicBinaryFieldName).id());\n+\n+                if (fullBinaryFieldNameSet.contains(basicBinaryFieldName)) {\n+\n+                    // if it is included on the full keys, we only have to store the meta in the cache.\n+                    metadataMap = this.fileStorageAPI.generateBasicMetaData(file,\n+                            metadataKey -> metadataFields.isEmpty() || metadataFields\n+                                    .contains(metadataKey));\n+                    CacheLocator.getContentletCache()\n+                            .addMetadataMap(contentlet.getInode() + basicBinaryFieldName, metadataMap);\n+                } else {\n+\n+\n+                    metadataMap = this.fileStorageAPI.generateMetaData(file,\n+                            new GenerateMetadataConfig.Builder()\n+                                    .full(false)\n+                                    .override(alwaysRegenerateMetadata)\n+                                    .store(true)\n+                                    .cache(()-> ContentletCache.META_DATA_MAP_KEY + contentlet.getInode() + basicBinaryFieldName)\n+                                    .metaDataKeyFilter(metadataKey -> metadataFields.isEmpty()\n+                                            || metadataFields.contains(metadataKey))\n+                                    .storageKey(new StorageKey.Builder().group(metadataBucketName).path(metadataPath).storage(storageType).build())\n+                                    .build()\n+                    );\n+                }\n+\n+                basicMetadataMap.put(basicBinaryFieldName, metadataMap);\n+            } else {\n+               //We're dealing with a  non required neither set binary field. No need to throw an exception. Just continue processing.\n+               Logger.warn(ContentletMetadataAPIImpl.class, String.format(\"The binary field : `%s`, is null, does not exists or can not be accessed\",basicBinaryFieldName));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Metadata file generator.\n+     * @param contentlet\n+     * @param fieldVariableName\n+     * @return\n+     */\n+    private String getFileName (final Contentlet contentlet, final String fieldVariableName) {\n+\n+        final String inode        = contentlet.getInode();\n+        final String fileName     = fieldVariableName + \"-metadata.json\";\n+        return StringUtils.builder(File.separator,\n+                inode.charAt(0), File.separator, inode.charAt(1), File.separator, inode, File.separator,\n+                fileName).toString();\n+    }\n+\n+    private void generateFullMetadata(final Contentlet contentlet,\n+                                      final Set<String> fullBinaryFieldNameSet,\n+                                      final ImmutableMap.Builder<String, Map<String, Object>> fullMetadataMap,\n+                                      final Map<String, Field> fieldMap,\n+                                      final boolean alwaysRegenerateMetadata) throws IOException {\n+\n+\n+        final StorageType storageType = StoragePersistenceProvider.getStorageType();\n+        final String metadataBucketName = Config.getStringProperty(METADATA_GROUP_NAME,\n+                DOT_METADATA);\n+        for (final String fullBinaryFieldName : fullBinaryFieldNameSet) {\n+            Logger.info(ContentletMetadataAPIImpl.class,\"\");\n+            final File file           = contentlet.getBinary(fullBinaryFieldName);\n+            final String metadataPath = this.getFileName(contentlet, fullBinaryFieldName);\n+            if (null != file && file.exists() && file.canRead()) {\n+                final Set<String> metadataFields = this.getMetadataFields(fieldMap.get(fullBinaryFieldName).id());\n+                final Map<String, Object> metadataMap = this.fileStorageAPI.generateMetaData(file,\n+                        new GenerateMetadataConfig.Builder()\n+                            .full(true)\n+                            .override(alwaysRegenerateMetadata)\n+                            .cache(false)  // do not want cache on full meta\n+                            .store(true)\n+                            .metaDataKeyFilter(metadataKey -> metadataFields.isEmpty()\n+                                    || metadataFields.contains(metadataKey))\n+                            .storageKey(new StorageKey.Builder().group(metadataBucketName).path(metadataPath).storage(storageType).build())\n+                            .build()\n+                        );\n+\n+                fullMetadataMap.put(fullBinaryFieldName, metadataMap);\n+            } else {\n+\n+                throw new IOException(\"The file: \" + file + \", is null, does not exists or can not access\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * based on the identifier this will give you a set of fields for the metadata generation\n+     * fields are specific to the CT or preconfigured\n+     * @param fieldIdentifier\n+     * @return\n+     */\n+    @VisibleForTesting\n+    Set<String> getMetadataFields (final String fieldIdentifier) {\n+\n+        final Optional<FieldVariable> customIndexMetaDataFieldsOpt =\n+                Try.of(()->FactoryLocator.getFieldFactory().byFieldVariableKey(fieldIdentifier, BinaryField.INDEX_METADATA_FIELDS)).getOrElse(Optional.empty());\n+\n+        final Set<String> metadataFields = customIndexMetaDataFieldsOpt.isPresent()?\n+                new HashSet<>(Arrays.asList(customIndexMetaDataFieldsOpt.get().value().split(StringPool.COMMA))):\n+                this.getConfiguredMetadataFields();\n+\n+        Logger.info(ContentletMetadataAPIImpl.class,\n+                () -> String.format(\" `%s` has these fields: `%s` \", fieldIdentifier, String\n+                        .join(\",\", metadataFields)));\n+        return metadataFields;\n+    }\n+\n+    /**\n+     * Reads INDEX_METADATA_FIELDS for  pre-configured metadata fields\n+     * @return\n+     */\n+    private Set<String> getConfiguredMetadataFields(){\n+\n+        final java.lang.String configFields = Config.getStringProperty(\"INDEX_METADATA_FIELDS\", null);\n+\n+        return UtilMethods.isSet(configFields)?\n+            new HashSet<>(Arrays.asList( configFields.split(StringPool.COMMA))):\n+            Collections.emptySet();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet {@link Contentlet}\n+     * @return\n+     * @throws IOException\n+     */\n+    @Override\n+    public ContentletMetadata generateContentletMetadata(final Contentlet contentlet) throws IOException {\n+\n+        final Tuple2<Set<String>, Set<String>> binaryFields = this.findBinaryFields(contentlet);\n+        return this.generateContentletMetadata(contentlet, binaryFields._1(), binaryFields._2());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet  {@link Contentlet}\n+     * @param field       {@link Field}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> getMetadata(final Contentlet contentlet, final Field field) {\n+\n+        return this.getMetadata(contentlet, field.variable());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet          {@link Contentlet}\n+     * @param fieldVariableName  {@link String}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> getMetadata(final Contentlet contentlet,final  String fieldVariableName) {\n+\n+        final String storageType        = Config.getStringProperty(DEFAULT_STORAGE_TYPE, StorageType.FILE_SYSTEM.name());\n+        final String metadataBucketName = Config.getStringProperty(METADATA_GROUP_NAME,\n+                DOT_METADATA);\n+        final String metadataPath       = this.getFileName(contentlet, fieldVariableName);\n+\n+        return this.fileStorageAPI.retrieveMetaData(\n+                new RequestMetadata.Builder()\n+                        .wrapMetadataMapForCache(this::wrapMetadataMapForCache)\n+                        .cache(()-> ContentletCache.META_DATA_MAP_KEY + contentlet.getInode() + fieldVariableName)\n+                        .storageKey(new StorageKey.Builder().group(metadataBucketName).path(metadataPath).storage(storageType).build())\n+                        .build()\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param contentlet          {@link Contentlet}\n+     * @param fieldVariableName  {@link String}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> getMetadataNoCache(final Contentlet contentlet,\n+            final String fieldVariableName) {\n+\n+        final StorageType storageType = StoragePersistenceProvider.getStorageType();\n+        final String metadataBucketName = Config\n+                .getStringProperty(METADATA_GROUP_NAME, DOT_METADATA);\n+        final String metadataPath = this.getFileName(contentlet, fieldVariableName);\n+\n+        return this.fileStorageAPI.retrieveMetaData(\n+                new RequestMetadata.Builder()\n+                        .cache(false)\n+                        .wrapMetadataMapForCache(this::wrapMetadataMapForCache) // why is it needed for the non-cached version??\n+                        .storageKey(\n+                                new StorageKey.Builder().group(metadataBucketName).path(metadataPath)\n+                                        .storage(storageType).build())\n+                        .build()\n+        );\n+    }\n+\n+    /**\n+     * filters exclude non-basic metadata fields\n+     * @param originalMap\n+     * @return\n+     */\n+    private Map<String, Object> wrapMetadataMapForCache (final Map<String, Object> originalMap) {\n+\n+        final ImmutableMap.Builder<String, Object> reduceMap = new ImmutableMap.Builder<>();\n+\n+        for (final String key : originalMap.keySet()) {\n+\n+            if (FileStorageAPI.TITLE_META_KEY.equals(key)) {\n+\n+                reduceMap.put(FileStorageAPI.TITLE_META_KEY, originalMap.get(key));\n+            }\n+\n+            if (FileStorageAPI.PATH_META_KEY.equals(key)) {\n+\n+                reduceMap.put(FileStorageAPI.PATH_META_KEY, originalMap.get(key));\n+            }\n+\n+            if (FileStorageAPI.LENGTH_META_KEY.equals(key)) {\n+\n+                reduceMap.put(FileStorageAPI.LENGTH_META_KEY, originalMap.get(key));\n+            }\n+\n+            if (FileStorageAPI.CONTENT_TYPE_META_KEY.equals(key)) {\n+\n+                reduceMap.put(FileStorageAPI.CONTENT_TYPE_META_KEY, originalMap.get(key));\n+            }\n+\n+            if (FileStorageAPI.MOD_DATE_META_KEY.equals(key)) {\n+\n+                reduceMap.put(FileStorageAPI.MOD_DATE_META_KEY, originalMap.get(key));\n+            }\n+\n+            if (FileStorageAPI.SHA226_META_KEY.equals(key)) {\n+\n+                reduceMap.put(FileStorageAPI.SHA226_META_KEY, originalMap.get(key));\n+            }\n+        }\n+\n+        return reduceMap.build();\n+    }\n+\n+    /**\n+     * This separates binaries in two sets candidates for the full meta and regular basic metadata\n+     * @param contentlet\n+     * @return\n+     */\n+    @VisibleForTesting\n+    Tuple2<Set<String>, Set<String>> findBinaryFields(final Contentlet contentlet) {\n+\n+        final List<Field> binaryFields = contentlet.getContentType().fields(BinaryField.class);\n+        binaryFields.sort(Comparator.comparing(Field::sortOrder));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ2NzAzMA=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 363}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzQ3ODQyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODozNjo1NlrOHgJT-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxODowMjowNVrOHiTuEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ2OTA1MQ==", "bodyText": "Redoing the wrap connection logic seems gratuitous to me as we should be in complete control of all the queries.  I would just keep it simple and use try(with resources){} to keep our DB connections closed.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503469051", "createdAt": "2020-10-12T18:36:56Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param jdbcPool\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczNjcyMQ==", "bodyText": "done", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505736721", "createdAt": "2020-10-15T18:02:05Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param jdbcPool\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ2OTA1MQ=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzQ4MjczOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODozODoyNFrOHgJWbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxODowMTozMlrOHiTstA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ2OTY3OA==", "bodyText": "Temporary not Temporal", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503469678", "createdAt": "2020-10-12T18:38:24Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param jdbcPool\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage_group WHERE group_name = ?\")\n+                    .addParam(groupNameLC).loadObjectResults(this.getConnection())).getOrElse(\n+                    Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String}\n+     * @param objectPath {@link String}\n+     * @return\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage WHERE group_name = ? AND path = ?\")\n+                    .addParam(groupNameLC).addParam(objectPathLC)\n+                    .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName    {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options or not.\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults();\n+\n+            int count = deleteObjects(maps.stream().map(map -> map.get(\"hash\").toString())\n+                    .collect(Collectors.toSet()), dotConnect, connection);\n+\n+            final int storageEntriesCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage WHERE group_name = ?\", groupNameLC);\n+\n+            final int groupsCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_group WHERE group_name = ?\", groupNameLC);\n+\n+            Logger.info(this, () -> String\n+                    .format(\"total of `%d` objects allocated in `%d` removed for `%d` group. \",\n+                            storageEntriesCount, count, groupsCount));\n+            return storageEntriesCount;\n+        });\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @param path   {   @link String} object path\n+     * @return\n+     */\n+    @Override\n+    public boolean deleteObject(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final String hash = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ? \")\n+                    .addParam(groupNameLC).addParam(pathLC).getString(\"hash\");\n+            if(null != hash) {\n+                deleteObjects(ImmutableSet.of(hash), dotConnect, connection);\n+            }\n+            final int count = dotConnect\n+                    .executeUpdate(connection,\n+                            \"DELETE FROM storage WHERE group_name = ? AND path = ?\",\n+                            groupNameLC, pathLC);\n+            return count > 0;\n+        });\n+    }\n+\n+    /**\n+     * object reference removal\n+     * @param hashSet object hash id\n+     * @param dotConnect DotConnect\n+     * @param connection external connection\n+     * @return count of all removed objects\n+     * @throws DotDataException\n+     */\n+    private int deleteObjects(final Set<String> hashSet, final DotConnect dotConnect, final Connection connection)\n+            throws DotDataException {\n+      int count = 0;\n+        for (final String hash:hashSet) {\n+            //We could seriously benefit from a batch update here. The only problem is our current impl does not take an external connection\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_x_data WHERE data_hash = ?\", hash);\n+\n+            count +=  dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_data WHERE hash_id = ?\", hash);\n+\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return\n+     */\n+    @Override\n+    public List<String> listGroups() {\n+\n+        final MutableObject<List<String>> result = new MutableObject<>(Collections.emptyList());\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List<Map<String, Object>> results = Try\n+                    .of(() -> new DotConnect().setSQL(\"SELECT group_name FROM storage_group\")\n+                            .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+\n+            result.setValue(results.stream().map(map -> map.get(\"group_name\").toString())\n+                    .collect(CollectionsUtils.toImmutableList()));\n+        });\n+\n+        return result.getValue();\n+    }\n+\n+    @Override\n+    public Object pushFile(final String groupName, final String path,\n+            final File file, final Map<String, Object> extraMeta) {\n+\n+        // 1. generate metadata\n+        // 2. see if the sha-256 exists\n+        // 2.1 if exists only insert on the reference\n+        // 2.2 if does not exists, insert a new one\n+        final Map<String, Object> metaData = processMetadata(file, extraMeta);\n+        final String fileHash = (String) metaData.get(FileStorageAPI.SHA226_META_KEY);\n+\n+        return this.wrapInTransaction(\n+                () -> {\n+                    if (!existsGroup(groupName)) {\n+                        throw new IllegalArgumentException(\"The groupName: \" + groupName +\n+                                \", does not exist.\");\n+                    }\n+                    if (this.existsObject(groupName, path)) {\n+                        Logger.warn(DataBaseStoragePersistenceAPIImpl.class,\n+                                String.format(\"Attempt to override entry `%s/%s` \", groupName,\n+                                        path));\n+                        return false;\n+                    }\n+                    return this.existsHash(fileHash) ?\n+                            this.pushFileReference(groupName, path, metaData, fileHash) :\n+                            this.pushNewFile(groupName, path, file, metaData);\n+                });\n+    }\n+\n+    /**\n+     * Selects directly on storage-data since hash is the primary key there.\n+     * @param fileHash\n+     * @return\n+     */\n+    private boolean existsHash(final String fileHash) {\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        this.wrapCloseConnection(() -> {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_data WHERE hash_id = ?\")\n+                                        .addParam(fileHash)\n+                                        .loadObjectResults(this.getConnection());\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        });\n+\n+        return exists.getValue();\n+    }\n+\n+    private Map<String, Object> processMetadata(final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        if (UtilMethods.isSet(extraMeta) && extraMeta.containsKey(FileStorageAPI.SHA226_META_KEY)) {\n+\n+            return extraMeta;\n+        }\n+\n+        final ImmutableMap.Builder<String, Object> metaData = new ImmutableMap.Builder<>();\n+\n+        if (UtilMethods.isSet(extraMeta)) {\n+\n+            metaData.putAll(extraMeta);\n+        }\n+\n+        metaData.putAll(APILocator.getFileStorageAPI().generateRawBasicMetaData(file));\n+\n+        return metaData.build();\n+    }\n+\n+    private Object pushFileReference(final String groupName, final String path,\n+            final Map<String, Object> extraMeta, final String objectHash) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try {\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+            return true;\n+        } catch (DotDataException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private Object pushNewFile(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try (final FileByteSplitter fileSplitter = new FileByteSplitter(file)) {\n+\n+            final HashBuilder objectHashBuilder = Encryptor.Hashing.sha256();\n+            final List<String> chunkHashes = new ArrayList<>();\n+\n+            for (final Tuple2<byte[], Integer> bytesRead : fileSplitter) {\n+\n+                objectHashBuilder.append(bytesRead._1(), bytesRead._2());\n+                final String chunkHash = Encryptor.Hashing.sha256().append\n+                        (bytesRead._1(), bytesRead._2()).buildUnixHash();\n+                chunkHashes.add(chunkHash);\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_data(hash_id, data) VALUES (?, ?)\",\n+                        chunkHash,\n+                        bytesRead._1().length == bytesRead._2() ?\n+                                bytesRead._1() : this.chunkBytes(bytesRead._2(), bytesRead._1()));\n+            }\n+\n+            final String objectHash = objectHashBuilder.buildUnixHash();\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+\n+            int order = 1;\n+            for (final String chunkHash : chunkHashes) {\n+\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_x_data(storage_hash, data_hash, data_order) VALUES (?, ?, ?)\",\n+                        objectHash, chunkHash, order++);\n+            }\n+\n+            return true;\n+        } catch (DotDataException | NoSuchAlgorithmException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] chunkBytes(final int bytesLength, final byte[] bytes) {\n+\n+        final byte[] chunkedArray = new byte[bytesLength];\n+\n+        System.arraycopy(bytes, 0, chunkedArray, 0, bytesLength);\n+\n+        return chunkedArray;\n+    }\n+\n+    @Override\n+    public Object pushObject(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        try {\n+\n+            final File file = FileUtil.createTemporalFile(\"object-storage\", \".tmp\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 563}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczNjM3Mg==", "bodyText": "changed.. a few other classes got affected by this rename.  Not many though", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505736372", "createdAt": "2020-10-15T18:01:32Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param jdbcPool\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage_group WHERE group_name = ?\")\n+                    .addParam(groupNameLC).loadObjectResults(this.getConnection())).getOrElse(\n+                    Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String}\n+     * @param objectPath {@link String}\n+     * @return\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage WHERE group_name = ? AND path = ?\")\n+                    .addParam(groupNameLC).addParam(objectPathLC)\n+                    .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName    {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options or not.\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults();\n+\n+            int count = deleteObjects(maps.stream().map(map -> map.get(\"hash\").toString())\n+                    .collect(Collectors.toSet()), dotConnect, connection);\n+\n+            final int storageEntriesCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage WHERE group_name = ?\", groupNameLC);\n+\n+            final int groupsCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_group WHERE group_name = ?\", groupNameLC);\n+\n+            Logger.info(this, () -> String\n+                    .format(\"total of `%d` objects allocated in `%d` removed for `%d` group. \",\n+                            storageEntriesCount, count, groupsCount));\n+            return storageEntriesCount;\n+        });\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @param path   {   @link String} object path\n+     * @return\n+     */\n+    @Override\n+    public boolean deleteObject(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final String hash = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ? \")\n+                    .addParam(groupNameLC).addParam(pathLC).getString(\"hash\");\n+            if(null != hash) {\n+                deleteObjects(ImmutableSet.of(hash), dotConnect, connection);\n+            }\n+            final int count = dotConnect\n+                    .executeUpdate(connection,\n+                            \"DELETE FROM storage WHERE group_name = ? AND path = ?\",\n+                            groupNameLC, pathLC);\n+            return count > 0;\n+        });\n+    }\n+\n+    /**\n+     * object reference removal\n+     * @param hashSet object hash id\n+     * @param dotConnect DotConnect\n+     * @param connection external connection\n+     * @return count of all removed objects\n+     * @throws DotDataException\n+     */\n+    private int deleteObjects(final Set<String> hashSet, final DotConnect dotConnect, final Connection connection)\n+            throws DotDataException {\n+      int count = 0;\n+        for (final String hash:hashSet) {\n+            //We could seriously benefit from a batch update here. The only problem is our current impl does not take an external connection\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_x_data WHERE data_hash = ?\", hash);\n+\n+            count +=  dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_data WHERE hash_id = ?\", hash);\n+\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return\n+     */\n+    @Override\n+    public List<String> listGroups() {\n+\n+        final MutableObject<List<String>> result = new MutableObject<>(Collections.emptyList());\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List<Map<String, Object>> results = Try\n+                    .of(() -> new DotConnect().setSQL(\"SELECT group_name FROM storage_group\")\n+                            .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+\n+            result.setValue(results.stream().map(map -> map.get(\"group_name\").toString())\n+                    .collect(CollectionsUtils.toImmutableList()));\n+        });\n+\n+        return result.getValue();\n+    }\n+\n+    @Override\n+    public Object pushFile(final String groupName, final String path,\n+            final File file, final Map<String, Object> extraMeta) {\n+\n+        // 1. generate metadata\n+        // 2. see if the sha-256 exists\n+        // 2.1 if exists only insert on the reference\n+        // 2.2 if does not exists, insert a new one\n+        final Map<String, Object> metaData = processMetadata(file, extraMeta);\n+        final String fileHash = (String) metaData.get(FileStorageAPI.SHA226_META_KEY);\n+\n+        return this.wrapInTransaction(\n+                () -> {\n+                    if (!existsGroup(groupName)) {\n+                        throw new IllegalArgumentException(\"The groupName: \" + groupName +\n+                                \", does not exist.\");\n+                    }\n+                    if (this.existsObject(groupName, path)) {\n+                        Logger.warn(DataBaseStoragePersistenceAPIImpl.class,\n+                                String.format(\"Attempt to override entry `%s/%s` \", groupName,\n+                                        path));\n+                        return false;\n+                    }\n+                    return this.existsHash(fileHash) ?\n+                            this.pushFileReference(groupName, path, metaData, fileHash) :\n+                            this.pushNewFile(groupName, path, file, metaData);\n+                });\n+    }\n+\n+    /**\n+     * Selects directly on storage-data since hash is the primary key there.\n+     * @param fileHash\n+     * @return\n+     */\n+    private boolean existsHash(final String fileHash) {\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        this.wrapCloseConnection(() -> {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_data WHERE hash_id = ?\")\n+                                        .addParam(fileHash)\n+                                        .loadObjectResults(this.getConnection());\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        });\n+\n+        return exists.getValue();\n+    }\n+\n+    private Map<String, Object> processMetadata(final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        if (UtilMethods.isSet(extraMeta) && extraMeta.containsKey(FileStorageAPI.SHA226_META_KEY)) {\n+\n+            return extraMeta;\n+        }\n+\n+        final ImmutableMap.Builder<String, Object> metaData = new ImmutableMap.Builder<>();\n+\n+        if (UtilMethods.isSet(extraMeta)) {\n+\n+            metaData.putAll(extraMeta);\n+        }\n+\n+        metaData.putAll(APILocator.getFileStorageAPI().generateRawBasicMetaData(file));\n+\n+        return metaData.build();\n+    }\n+\n+    private Object pushFileReference(final String groupName, final String path,\n+            final Map<String, Object> extraMeta, final String objectHash) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try {\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+            return true;\n+        } catch (DotDataException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private Object pushNewFile(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try (final FileByteSplitter fileSplitter = new FileByteSplitter(file)) {\n+\n+            final HashBuilder objectHashBuilder = Encryptor.Hashing.sha256();\n+            final List<String> chunkHashes = new ArrayList<>();\n+\n+            for (final Tuple2<byte[], Integer> bytesRead : fileSplitter) {\n+\n+                objectHashBuilder.append(bytesRead._1(), bytesRead._2());\n+                final String chunkHash = Encryptor.Hashing.sha256().append\n+                        (bytesRead._1(), bytesRead._2()).buildUnixHash();\n+                chunkHashes.add(chunkHash);\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_data(hash_id, data) VALUES (?, ?)\",\n+                        chunkHash,\n+                        bytesRead._1().length == bytesRead._2() ?\n+                                bytesRead._1() : this.chunkBytes(bytesRead._2(), bytesRead._1()));\n+            }\n+\n+            final String objectHash = objectHashBuilder.buildUnixHash();\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+\n+            int order = 1;\n+            for (final String chunkHash : chunkHashes) {\n+\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_x_data(storage_hash, data_hash, data_order) VALUES (?, ?, ?)\",\n+                        objectHash, chunkHash, order++);\n+            }\n+\n+            return true;\n+        } catch (DotDataException | NoSuchAlgorithmException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] chunkBytes(final int bytesLength, final byte[] bytes) {\n+\n+        final byte[] chunkedArray = new byte[bytesLength];\n+\n+        System.arraycopy(bytes, 0, chunkedArray, 0, bytesLength);\n+\n+        return chunkedArray;\n+    }\n+\n+    @Override\n+    public Object pushObject(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        try {\n+\n+            final File file = FileUtil.createTemporalFile(\"object-storage\", \".tmp\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ2OTY3OA=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 563}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzQ4Njg1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODozOTozOVrOHgJYyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMToyNjowMFrOHibqyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3MDI4MQ==", "bodyText": "This reads the whole file into memory.  You need to use streams.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503470281", "createdAt": "2020-10-12T18:39:39Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param jdbcPool\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage_group WHERE group_name = ?\")\n+                    .addParam(groupNameLC).loadObjectResults(this.getConnection())).getOrElse(\n+                    Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String}\n+     * @param objectPath {@link String}\n+     * @return\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage WHERE group_name = ? AND path = ?\")\n+                    .addParam(groupNameLC).addParam(objectPathLC)\n+                    .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName    {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options or not.\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults();\n+\n+            int count = deleteObjects(maps.stream().map(map -> map.get(\"hash\").toString())\n+                    .collect(Collectors.toSet()), dotConnect, connection);\n+\n+            final int storageEntriesCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage WHERE group_name = ?\", groupNameLC);\n+\n+            final int groupsCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_group WHERE group_name = ?\", groupNameLC);\n+\n+            Logger.info(this, () -> String\n+                    .format(\"total of `%d` objects allocated in `%d` removed for `%d` group. \",\n+                            storageEntriesCount, count, groupsCount));\n+            return storageEntriesCount;\n+        });\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @param path   {   @link String} object path\n+     * @return\n+     */\n+    @Override\n+    public boolean deleteObject(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final String hash = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ? \")\n+                    .addParam(groupNameLC).addParam(pathLC).getString(\"hash\");\n+            if(null != hash) {\n+                deleteObjects(ImmutableSet.of(hash), dotConnect, connection);\n+            }\n+            final int count = dotConnect\n+                    .executeUpdate(connection,\n+                            \"DELETE FROM storage WHERE group_name = ? AND path = ?\",\n+                            groupNameLC, pathLC);\n+            return count > 0;\n+        });\n+    }\n+\n+    /**\n+     * object reference removal\n+     * @param hashSet object hash id\n+     * @param dotConnect DotConnect\n+     * @param connection external connection\n+     * @return count of all removed objects\n+     * @throws DotDataException\n+     */\n+    private int deleteObjects(final Set<String> hashSet, final DotConnect dotConnect, final Connection connection)\n+            throws DotDataException {\n+      int count = 0;\n+        for (final String hash:hashSet) {\n+            //We could seriously benefit from a batch update here. The only problem is our current impl does not take an external connection\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_x_data WHERE data_hash = ?\", hash);\n+\n+            count +=  dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_data WHERE hash_id = ?\", hash);\n+\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return\n+     */\n+    @Override\n+    public List<String> listGroups() {\n+\n+        final MutableObject<List<String>> result = new MutableObject<>(Collections.emptyList());\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List<Map<String, Object>> results = Try\n+                    .of(() -> new DotConnect().setSQL(\"SELECT group_name FROM storage_group\")\n+                            .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+\n+            result.setValue(results.stream().map(map -> map.get(\"group_name\").toString())\n+                    .collect(CollectionsUtils.toImmutableList()));\n+        });\n+\n+        return result.getValue();\n+    }\n+\n+    @Override\n+    public Object pushFile(final String groupName, final String path,\n+            final File file, final Map<String, Object> extraMeta) {\n+\n+        // 1. generate metadata\n+        // 2. see if the sha-256 exists\n+        // 2.1 if exists only insert on the reference\n+        // 2.2 if does not exists, insert a new one\n+        final Map<String, Object> metaData = processMetadata(file, extraMeta);\n+        final String fileHash = (String) metaData.get(FileStorageAPI.SHA226_META_KEY);\n+\n+        return this.wrapInTransaction(\n+                () -> {\n+                    if (!existsGroup(groupName)) {\n+                        throw new IllegalArgumentException(\"The groupName: \" + groupName +\n+                                \", does not exist.\");\n+                    }\n+                    if (this.existsObject(groupName, path)) {\n+                        Logger.warn(DataBaseStoragePersistenceAPIImpl.class,\n+                                String.format(\"Attempt to override entry `%s/%s` \", groupName,\n+                                        path));\n+                        return false;\n+                    }\n+                    return this.existsHash(fileHash) ?\n+                            this.pushFileReference(groupName, path, metaData, fileHash) :\n+                            this.pushNewFile(groupName, path, file, metaData);\n+                });\n+    }\n+\n+    /**\n+     * Selects directly on storage-data since hash is the primary key there.\n+     * @param fileHash\n+     * @return\n+     */\n+    private boolean existsHash(final String fileHash) {\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        this.wrapCloseConnection(() -> {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_data WHERE hash_id = ?\")\n+                                        .addParam(fileHash)\n+                                        .loadObjectResults(this.getConnection());\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        });\n+\n+        return exists.getValue();\n+    }\n+\n+    private Map<String, Object> processMetadata(final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        if (UtilMethods.isSet(extraMeta) && extraMeta.containsKey(FileStorageAPI.SHA226_META_KEY)) {\n+\n+            return extraMeta;\n+        }\n+\n+        final ImmutableMap.Builder<String, Object> metaData = new ImmutableMap.Builder<>();\n+\n+        if (UtilMethods.isSet(extraMeta)) {\n+\n+            metaData.putAll(extraMeta);\n+        }\n+\n+        metaData.putAll(APILocator.getFileStorageAPI().generateRawBasicMetaData(file));\n+\n+        return metaData.build();\n+    }\n+\n+    private Object pushFileReference(final String groupName, final String path,\n+            final Map<String, Object> extraMeta, final String objectHash) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try {\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+            return true;\n+        } catch (DotDataException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private Object pushNewFile(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try (final FileByteSplitter fileSplitter = new FileByteSplitter(file)) {\n+\n+            final HashBuilder objectHashBuilder = Encryptor.Hashing.sha256();\n+            final List<String> chunkHashes = new ArrayList<>();\n+\n+            for (final Tuple2<byte[], Integer> bytesRead : fileSplitter) {\n+\n+                objectHashBuilder.append(bytesRead._1(), bytesRead._2());\n+                final String chunkHash = Encryptor.Hashing.sha256().append\n+                        (bytesRead._1(), bytesRead._2()).buildUnixHash();\n+                chunkHashes.add(chunkHash);\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_data(hash_id, data) VALUES (?, ?)\",\n+                        chunkHash,\n+                        bytesRead._1().length == bytesRead._2() ?\n+                                bytesRead._1() : this.chunkBytes(bytesRead._2(), bytesRead._1()));\n+            }\n+\n+            final String objectHash = objectHashBuilder.buildUnixHash();\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+\n+            int order = 1;\n+            for (final String chunkHash : chunkHashes) {\n+\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_x_data(storage_hash, data_hash, data_order) VALUES (?, ?, ?)\",\n+                        objectHash, chunkHash, order++);\n+            }\n+\n+            return true;\n+        } catch (DotDataException | NoSuchAlgorithmException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] chunkBytes(final int bytesLength, final byte[] bytes) {\n+\n+        final byte[] chunkedArray = new byte[bytesLength];\n+\n+        System.arraycopy(bytes, 0, chunkedArray, 0, bytesLength);\n+\n+        return chunkedArray;\n+    }\n+\n+    @Override\n+    public Object pushObject(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        try {\n+\n+            final File file = FileUtil.createTemporalFile(\"object-storage\", \".tmp\");\n+            final byte[] objectBytes = this.objectToBytes(writerDelegate, object);\n+            FileUtils.writeByteArrayToFile(file, objectBytes);\n+\n+            return this.pushFile(groupName, path, file, extraMeta);\n+        } catch (IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] objectToBytes(final ObjectWriterDelegate writerDelegate,\n+            final Serializable object) {\n+\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        writerDelegate.write(byteArrayOutputStream, object);\n+        return byteArrayOutputStream.toByteArray();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 580}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2Njk1NQ==", "bodyText": "fixed", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505866955", "createdAt": "2020-10-15T21:26:00Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param jdbcPool\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage_group WHERE group_name = ?\")\n+                    .addParam(groupNameLC).loadObjectResults(this.getConnection())).getOrElse(\n+                    Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String}\n+     * @param objectPath {@link String}\n+     * @return\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage WHERE group_name = ? AND path = ?\")\n+                    .addParam(groupNameLC).addParam(objectPathLC)\n+                    .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName    {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options or not.\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults();\n+\n+            int count = deleteObjects(maps.stream().map(map -> map.get(\"hash\").toString())\n+                    .collect(Collectors.toSet()), dotConnect, connection);\n+\n+            final int storageEntriesCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage WHERE group_name = ?\", groupNameLC);\n+\n+            final int groupsCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_group WHERE group_name = ?\", groupNameLC);\n+\n+            Logger.info(this, () -> String\n+                    .format(\"total of `%d` objects allocated in `%d` removed for `%d` group. \",\n+                            storageEntriesCount, count, groupsCount));\n+            return storageEntriesCount;\n+        });\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @param path   {   @link String} object path\n+     * @return\n+     */\n+    @Override\n+    public boolean deleteObject(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final String hash = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ? \")\n+                    .addParam(groupNameLC).addParam(pathLC).getString(\"hash\");\n+            if(null != hash) {\n+                deleteObjects(ImmutableSet.of(hash), dotConnect, connection);\n+            }\n+            final int count = dotConnect\n+                    .executeUpdate(connection,\n+                            \"DELETE FROM storage WHERE group_name = ? AND path = ?\",\n+                            groupNameLC, pathLC);\n+            return count > 0;\n+        });\n+    }\n+\n+    /**\n+     * object reference removal\n+     * @param hashSet object hash id\n+     * @param dotConnect DotConnect\n+     * @param connection external connection\n+     * @return count of all removed objects\n+     * @throws DotDataException\n+     */\n+    private int deleteObjects(final Set<String> hashSet, final DotConnect dotConnect, final Connection connection)\n+            throws DotDataException {\n+      int count = 0;\n+        for (final String hash:hashSet) {\n+            //We could seriously benefit from a batch update here. The only problem is our current impl does not take an external connection\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_x_data WHERE data_hash = ?\", hash);\n+\n+            count +=  dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_data WHERE hash_id = ?\", hash);\n+\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return\n+     */\n+    @Override\n+    public List<String> listGroups() {\n+\n+        final MutableObject<List<String>> result = new MutableObject<>(Collections.emptyList());\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List<Map<String, Object>> results = Try\n+                    .of(() -> new DotConnect().setSQL(\"SELECT group_name FROM storage_group\")\n+                            .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+\n+            result.setValue(results.stream().map(map -> map.get(\"group_name\").toString())\n+                    .collect(CollectionsUtils.toImmutableList()));\n+        });\n+\n+        return result.getValue();\n+    }\n+\n+    @Override\n+    public Object pushFile(final String groupName, final String path,\n+            final File file, final Map<String, Object> extraMeta) {\n+\n+        // 1. generate metadata\n+        // 2. see if the sha-256 exists\n+        // 2.1 if exists only insert on the reference\n+        // 2.2 if does not exists, insert a new one\n+        final Map<String, Object> metaData = processMetadata(file, extraMeta);\n+        final String fileHash = (String) metaData.get(FileStorageAPI.SHA226_META_KEY);\n+\n+        return this.wrapInTransaction(\n+                () -> {\n+                    if (!existsGroup(groupName)) {\n+                        throw new IllegalArgumentException(\"The groupName: \" + groupName +\n+                                \", does not exist.\");\n+                    }\n+                    if (this.existsObject(groupName, path)) {\n+                        Logger.warn(DataBaseStoragePersistenceAPIImpl.class,\n+                                String.format(\"Attempt to override entry `%s/%s` \", groupName,\n+                                        path));\n+                        return false;\n+                    }\n+                    return this.existsHash(fileHash) ?\n+                            this.pushFileReference(groupName, path, metaData, fileHash) :\n+                            this.pushNewFile(groupName, path, file, metaData);\n+                });\n+    }\n+\n+    /**\n+     * Selects directly on storage-data since hash is the primary key there.\n+     * @param fileHash\n+     * @return\n+     */\n+    private boolean existsHash(final String fileHash) {\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        this.wrapCloseConnection(() -> {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_data WHERE hash_id = ?\")\n+                                        .addParam(fileHash)\n+                                        .loadObjectResults(this.getConnection());\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        });\n+\n+        return exists.getValue();\n+    }\n+\n+    private Map<String, Object> processMetadata(final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        if (UtilMethods.isSet(extraMeta) && extraMeta.containsKey(FileStorageAPI.SHA226_META_KEY)) {\n+\n+            return extraMeta;\n+        }\n+\n+        final ImmutableMap.Builder<String, Object> metaData = new ImmutableMap.Builder<>();\n+\n+        if (UtilMethods.isSet(extraMeta)) {\n+\n+            metaData.putAll(extraMeta);\n+        }\n+\n+        metaData.putAll(APILocator.getFileStorageAPI().generateRawBasicMetaData(file));\n+\n+        return metaData.build();\n+    }\n+\n+    private Object pushFileReference(final String groupName, final String path,\n+            final Map<String, Object> extraMeta, final String objectHash) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try {\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+            return true;\n+        } catch (DotDataException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private Object pushNewFile(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try (final FileByteSplitter fileSplitter = new FileByteSplitter(file)) {\n+\n+            final HashBuilder objectHashBuilder = Encryptor.Hashing.sha256();\n+            final List<String> chunkHashes = new ArrayList<>();\n+\n+            for (final Tuple2<byte[], Integer> bytesRead : fileSplitter) {\n+\n+                objectHashBuilder.append(bytesRead._1(), bytesRead._2());\n+                final String chunkHash = Encryptor.Hashing.sha256().append\n+                        (bytesRead._1(), bytesRead._2()).buildUnixHash();\n+                chunkHashes.add(chunkHash);\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_data(hash_id, data) VALUES (?, ?)\",\n+                        chunkHash,\n+                        bytesRead._1().length == bytesRead._2() ?\n+                                bytesRead._1() : this.chunkBytes(bytesRead._2(), bytesRead._1()));\n+            }\n+\n+            final String objectHash = objectHashBuilder.buildUnixHash();\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+\n+            int order = 1;\n+            for (final String chunkHash : chunkHashes) {\n+\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_x_data(storage_hash, data_hash, data_order) VALUES (?, ?, ?)\",\n+                        objectHash, chunkHash, order++);\n+            }\n+\n+            return true;\n+        } catch (DotDataException | NoSuchAlgorithmException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] chunkBytes(final int bytesLength, final byte[] bytes) {\n+\n+        final byte[] chunkedArray = new byte[bytesLength];\n+\n+        System.arraycopy(bytes, 0, chunkedArray, 0, bytesLength);\n+\n+        return chunkedArray;\n+    }\n+\n+    @Override\n+    public Object pushObject(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        try {\n+\n+            final File file = FileUtil.createTemporalFile(\"object-storage\", \".tmp\");\n+            final byte[] objectBytes = this.objectToBytes(writerDelegate, object);\n+            FileUtils.writeByteArrayToFile(file, objectBytes);\n+\n+            return this.pushFile(groupName, path, file, extraMeta);\n+        } catch (IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] objectToBytes(final ObjectWriterDelegate writerDelegate,\n+            final Serializable object) {\n+\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        writerDelegate.write(byteArrayOutputStream, object);\n+        return byteArrayOutputStream.toByteArray();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3MDI4MQ=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 580}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzQ5MzAzOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODo0MTo1NFrOHgJcTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzo1OToxOFrOHiTnXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3MTE4Mw==", "bodyText": "We should be mindful of where we create the temporary file - on the shared disk or on the local disk.  Where will the file ultimately end up?  If you write it to the wrong disk, moving the file from the temporary file to the local storage will be slow.  We might want to make this configurable.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503471183", "createdAt": "2020-10-12T18:41:54Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param jdbcPool\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage_group WHERE group_name = ?\")\n+                    .addParam(groupNameLC).loadObjectResults(this.getConnection())).getOrElse(\n+                    Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String}\n+     * @param objectPath {@link String}\n+     * @return\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage WHERE group_name = ? AND path = ?\")\n+                    .addParam(groupNameLC).addParam(objectPathLC)\n+                    .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName    {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options or not.\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults();\n+\n+            int count = deleteObjects(maps.stream().map(map -> map.get(\"hash\").toString())\n+                    .collect(Collectors.toSet()), dotConnect, connection);\n+\n+            final int storageEntriesCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage WHERE group_name = ?\", groupNameLC);\n+\n+            final int groupsCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_group WHERE group_name = ?\", groupNameLC);\n+\n+            Logger.info(this, () -> String\n+                    .format(\"total of `%d` objects allocated in `%d` removed for `%d` group. \",\n+                            storageEntriesCount, count, groupsCount));\n+            return storageEntriesCount;\n+        });\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @param path   {   @link String} object path\n+     * @return\n+     */\n+    @Override\n+    public boolean deleteObject(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final String hash = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ? \")\n+                    .addParam(groupNameLC).addParam(pathLC).getString(\"hash\");\n+            if(null != hash) {\n+                deleteObjects(ImmutableSet.of(hash), dotConnect, connection);\n+            }\n+            final int count = dotConnect\n+                    .executeUpdate(connection,\n+                            \"DELETE FROM storage WHERE group_name = ? AND path = ?\",\n+                            groupNameLC, pathLC);\n+            return count > 0;\n+        });\n+    }\n+\n+    /**\n+     * object reference removal\n+     * @param hashSet object hash id\n+     * @param dotConnect DotConnect\n+     * @param connection external connection\n+     * @return count of all removed objects\n+     * @throws DotDataException\n+     */\n+    private int deleteObjects(final Set<String> hashSet, final DotConnect dotConnect, final Connection connection)\n+            throws DotDataException {\n+      int count = 0;\n+        for (final String hash:hashSet) {\n+            //We could seriously benefit from a batch update here. The only problem is our current impl does not take an external connection\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_x_data WHERE data_hash = ?\", hash);\n+\n+            count +=  dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_data WHERE hash_id = ?\", hash);\n+\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return\n+     */\n+    @Override\n+    public List<String> listGroups() {\n+\n+        final MutableObject<List<String>> result = new MutableObject<>(Collections.emptyList());\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List<Map<String, Object>> results = Try\n+                    .of(() -> new DotConnect().setSQL(\"SELECT group_name FROM storage_group\")\n+                            .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+\n+            result.setValue(results.stream().map(map -> map.get(\"group_name\").toString())\n+                    .collect(CollectionsUtils.toImmutableList()));\n+        });\n+\n+        return result.getValue();\n+    }\n+\n+    @Override\n+    public Object pushFile(final String groupName, final String path,\n+            final File file, final Map<String, Object> extraMeta) {\n+\n+        // 1. generate metadata\n+        // 2. see if the sha-256 exists\n+        // 2.1 if exists only insert on the reference\n+        // 2.2 if does not exists, insert a new one\n+        final Map<String, Object> metaData = processMetadata(file, extraMeta);\n+        final String fileHash = (String) metaData.get(FileStorageAPI.SHA226_META_KEY);\n+\n+        return this.wrapInTransaction(\n+                () -> {\n+                    if (!existsGroup(groupName)) {\n+                        throw new IllegalArgumentException(\"The groupName: \" + groupName +\n+                                \", does not exist.\");\n+                    }\n+                    if (this.existsObject(groupName, path)) {\n+                        Logger.warn(DataBaseStoragePersistenceAPIImpl.class,\n+                                String.format(\"Attempt to override entry `%s/%s` \", groupName,\n+                                        path));\n+                        return false;\n+                    }\n+                    return this.existsHash(fileHash) ?\n+                            this.pushFileReference(groupName, path, metaData, fileHash) :\n+                            this.pushNewFile(groupName, path, file, metaData);\n+                });\n+    }\n+\n+    /**\n+     * Selects directly on storage-data since hash is the primary key there.\n+     * @param fileHash\n+     * @return\n+     */\n+    private boolean existsHash(final String fileHash) {\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        this.wrapCloseConnection(() -> {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_data WHERE hash_id = ?\")\n+                                        .addParam(fileHash)\n+                                        .loadObjectResults(this.getConnection());\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        });\n+\n+        return exists.getValue();\n+    }\n+\n+    private Map<String, Object> processMetadata(final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        if (UtilMethods.isSet(extraMeta) && extraMeta.containsKey(FileStorageAPI.SHA226_META_KEY)) {\n+\n+            return extraMeta;\n+        }\n+\n+        final ImmutableMap.Builder<String, Object> metaData = new ImmutableMap.Builder<>();\n+\n+        if (UtilMethods.isSet(extraMeta)) {\n+\n+            metaData.putAll(extraMeta);\n+        }\n+\n+        metaData.putAll(APILocator.getFileStorageAPI().generateRawBasicMetaData(file));\n+\n+        return metaData.build();\n+    }\n+\n+    private Object pushFileReference(final String groupName, final String path,\n+            final Map<String, Object> extraMeta, final String objectHash) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try {\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+            return true;\n+        } catch (DotDataException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private Object pushNewFile(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try (final FileByteSplitter fileSplitter = new FileByteSplitter(file)) {\n+\n+            final HashBuilder objectHashBuilder = Encryptor.Hashing.sha256();\n+            final List<String> chunkHashes = new ArrayList<>();\n+\n+            for (final Tuple2<byte[], Integer> bytesRead : fileSplitter) {\n+\n+                objectHashBuilder.append(bytesRead._1(), bytesRead._2());\n+                final String chunkHash = Encryptor.Hashing.sha256().append\n+                        (bytesRead._1(), bytesRead._2()).buildUnixHash();\n+                chunkHashes.add(chunkHash);\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_data(hash_id, data) VALUES (?, ?)\",\n+                        chunkHash,\n+                        bytesRead._1().length == bytesRead._2() ?\n+                                bytesRead._1() : this.chunkBytes(bytesRead._2(), bytesRead._1()));\n+            }\n+\n+            final String objectHash = objectHashBuilder.buildUnixHash();\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+\n+            int order = 1;\n+            for (final String chunkHash : chunkHashes) {\n+\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_x_data(storage_hash, data_hash, data_order) VALUES (?, ?, ?)\",\n+                        objectHash, chunkHash, order++);\n+            }\n+\n+            return true;\n+        } catch (DotDataException | NoSuchAlgorithmException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] chunkBytes(final int bytesLength, final byte[] bytes) {\n+\n+        final byte[] chunkedArray = new byte[bytesLength];\n+\n+        System.arraycopy(bytes, 0, chunkedArray, 0, bytesLength);\n+\n+        return chunkedArray;\n+    }\n+\n+    @Override\n+    public Object pushObject(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        try {\n+\n+            final File file = FileUtil.createTemporalFile(\"object-storage\", \".tmp\");\n+            final byte[] objectBytes = this.objectToBytes(writerDelegate, object);\n+            FileUtils.writeByteArrayToFile(file, objectBytes);\n+\n+            return this.pushFile(groupName, path, file, extraMeta);\n+        } catch (IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] objectToBytes(final ObjectWriterDelegate writerDelegate,\n+            final Serializable object) {\n+\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        writerDelegate.write(byteArrayOutputStream, object);\n+        return byteArrayOutputStream.toByteArray();\n+    }\n+\n+    @Override\n+    public Future<Object> pushFileAsync(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushFile(groupName, path, file, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public Future<Object> pushObjectAsync(final String bucketName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushObject(bucketName, path, writerDelegate, object, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public File pullFile(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        final MutableObject<File> file = new MutableObject<>(null);\n+\n+        this.wrapCloseConnection(() -> {\n+            try {\n+\n+                final List<Map<String, Object>> storageResult = Try.of(() ->\n+                        new DotConnect()\n+                                .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ?\")\n+                                .addParam(groupNameLC).addParam(pathLC).loadObjectResults()).getOrElse(\n+                        Collections::emptyList);\n+\n+                if (!storageResult.isEmpty()) {\n+\n+                    final Optional<Object> objectOpt = storageResult.stream()\n+                            .map(map -> map.get(\"hash\")).findFirst();\n+                    if (objectOpt.isPresent()) {\n+\n+                        final String objectHash = (String) objectOpt.get();\n+                        if (UtilMethods.isSet(objectHash)) {\n+\n+                            file.setValue(this.createJoinFile(objectHash));\n+                        }\n+                    }\n+                } else {\n+\n+                    throw new DoesNotExistException(\n+                            \"The storage, group: \" + groupName + \", path: \" + path\n+                                    + \" does not exists\");\n+                }\n+            } catch (IOException e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        });\n+\n+        return file.getValue();\n+    }\n+\n+    private File createJoinFile(final String hashId) throws IOException {\n+\n+        final File file = FileUtil.createTemporalFile(\"dotdbstorage-recovery\", \".tmp\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 647}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkxMTI3Nw==", "bodyText": "I was going to add a property that could be used to specify the temp files dir. But then I found that by default The java Files API does use the following param to specify so -Djava.io.tmpdir. We could change that if we so desired. For now, the default points to a tmp folder location under Tomcat's root folder.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r504911277", "createdAt": "2020-10-14T19:12:18Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param jdbcPool\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage_group WHERE group_name = ?\")\n+                    .addParam(groupNameLC).loadObjectResults(this.getConnection())).getOrElse(\n+                    Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String}\n+     * @param objectPath {@link String}\n+     * @return\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage WHERE group_name = ? AND path = ?\")\n+                    .addParam(groupNameLC).addParam(objectPathLC)\n+                    .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName    {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options or not.\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults();\n+\n+            int count = deleteObjects(maps.stream().map(map -> map.get(\"hash\").toString())\n+                    .collect(Collectors.toSet()), dotConnect, connection);\n+\n+            final int storageEntriesCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage WHERE group_name = ?\", groupNameLC);\n+\n+            final int groupsCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_group WHERE group_name = ?\", groupNameLC);\n+\n+            Logger.info(this, () -> String\n+                    .format(\"total of `%d` objects allocated in `%d` removed for `%d` group. \",\n+                            storageEntriesCount, count, groupsCount));\n+            return storageEntriesCount;\n+        });\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @param path   {   @link String} object path\n+     * @return\n+     */\n+    @Override\n+    public boolean deleteObject(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final String hash = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ? \")\n+                    .addParam(groupNameLC).addParam(pathLC).getString(\"hash\");\n+            if(null != hash) {\n+                deleteObjects(ImmutableSet.of(hash), dotConnect, connection);\n+            }\n+            final int count = dotConnect\n+                    .executeUpdate(connection,\n+                            \"DELETE FROM storage WHERE group_name = ? AND path = ?\",\n+                            groupNameLC, pathLC);\n+            return count > 0;\n+        });\n+    }\n+\n+    /**\n+     * object reference removal\n+     * @param hashSet object hash id\n+     * @param dotConnect DotConnect\n+     * @param connection external connection\n+     * @return count of all removed objects\n+     * @throws DotDataException\n+     */\n+    private int deleteObjects(final Set<String> hashSet, final DotConnect dotConnect, final Connection connection)\n+            throws DotDataException {\n+      int count = 0;\n+        for (final String hash:hashSet) {\n+            //We could seriously benefit from a batch update here. The only problem is our current impl does not take an external connection\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_x_data WHERE data_hash = ?\", hash);\n+\n+            count +=  dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_data WHERE hash_id = ?\", hash);\n+\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return\n+     */\n+    @Override\n+    public List<String> listGroups() {\n+\n+        final MutableObject<List<String>> result = new MutableObject<>(Collections.emptyList());\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List<Map<String, Object>> results = Try\n+                    .of(() -> new DotConnect().setSQL(\"SELECT group_name FROM storage_group\")\n+                            .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+\n+            result.setValue(results.stream().map(map -> map.get(\"group_name\").toString())\n+                    .collect(CollectionsUtils.toImmutableList()));\n+        });\n+\n+        return result.getValue();\n+    }\n+\n+    @Override\n+    public Object pushFile(final String groupName, final String path,\n+            final File file, final Map<String, Object> extraMeta) {\n+\n+        // 1. generate metadata\n+        // 2. see if the sha-256 exists\n+        // 2.1 if exists only insert on the reference\n+        // 2.2 if does not exists, insert a new one\n+        final Map<String, Object> metaData = processMetadata(file, extraMeta);\n+        final String fileHash = (String) metaData.get(FileStorageAPI.SHA226_META_KEY);\n+\n+        return this.wrapInTransaction(\n+                () -> {\n+                    if (!existsGroup(groupName)) {\n+                        throw new IllegalArgumentException(\"The groupName: \" + groupName +\n+                                \", does not exist.\");\n+                    }\n+                    if (this.existsObject(groupName, path)) {\n+                        Logger.warn(DataBaseStoragePersistenceAPIImpl.class,\n+                                String.format(\"Attempt to override entry `%s/%s` \", groupName,\n+                                        path));\n+                        return false;\n+                    }\n+                    return this.existsHash(fileHash) ?\n+                            this.pushFileReference(groupName, path, metaData, fileHash) :\n+                            this.pushNewFile(groupName, path, file, metaData);\n+                });\n+    }\n+\n+    /**\n+     * Selects directly on storage-data since hash is the primary key there.\n+     * @param fileHash\n+     * @return\n+     */\n+    private boolean existsHash(final String fileHash) {\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        this.wrapCloseConnection(() -> {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_data WHERE hash_id = ?\")\n+                                        .addParam(fileHash)\n+                                        .loadObjectResults(this.getConnection());\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        });\n+\n+        return exists.getValue();\n+    }\n+\n+    private Map<String, Object> processMetadata(final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        if (UtilMethods.isSet(extraMeta) && extraMeta.containsKey(FileStorageAPI.SHA226_META_KEY)) {\n+\n+            return extraMeta;\n+        }\n+\n+        final ImmutableMap.Builder<String, Object> metaData = new ImmutableMap.Builder<>();\n+\n+        if (UtilMethods.isSet(extraMeta)) {\n+\n+            metaData.putAll(extraMeta);\n+        }\n+\n+        metaData.putAll(APILocator.getFileStorageAPI().generateRawBasicMetaData(file));\n+\n+        return metaData.build();\n+    }\n+\n+    private Object pushFileReference(final String groupName, final String path,\n+            final Map<String, Object> extraMeta, final String objectHash) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try {\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+            return true;\n+        } catch (DotDataException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private Object pushNewFile(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try (final FileByteSplitter fileSplitter = new FileByteSplitter(file)) {\n+\n+            final HashBuilder objectHashBuilder = Encryptor.Hashing.sha256();\n+            final List<String> chunkHashes = new ArrayList<>();\n+\n+            for (final Tuple2<byte[], Integer> bytesRead : fileSplitter) {\n+\n+                objectHashBuilder.append(bytesRead._1(), bytesRead._2());\n+                final String chunkHash = Encryptor.Hashing.sha256().append\n+                        (bytesRead._1(), bytesRead._2()).buildUnixHash();\n+                chunkHashes.add(chunkHash);\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_data(hash_id, data) VALUES (?, ?)\",\n+                        chunkHash,\n+                        bytesRead._1().length == bytesRead._2() ?\n+                                bytesRead._1() : this.chunkBytes(bytesRead._2(), bytesRead._1()));\n+            }\n+\n+            final String objectHash = objectHashBuilder.buildUnixHash();\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+\n+            int order = 1;\n+            for (final String chunkHash : chunkHashes) {\n+\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_x_data(storage_hash, data_hash, data_order) VALUES (?, ?, ?)\",\n+                        objectHash, chunkHash, order++);\n+            }\n+\n+            return true;\n+        } catch (DotDataException | NoSuchAlgorithmException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] chunkBytes(final int bytesLength, final byte[] bytes) {\n+\n+        final byte[] chunkedArray = new byte[bytesLength];\n+\n+        System.arraycopy(bytes, 0, chunkedArray, 0, bytesLength);\n+\n+        return chunkedArray;\n+    }\n+\n+    @Override\n+    public Object pushObject(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        try {\n+\n+            final File file = FileUtil.createTemporalFile(\"object-storage\", \".tmp\");\n+            final byte[] objectBytes = this.objectToBytes(writerDelegate, object);\n+            FileUtils.writeByteArrayToFile(file, objectBytes);\n+\n+            return this.pushFile(groupName, path, file, extraMeta);\n+        } catch (IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] objectToBytes(final ObjectWriterDelegate writerDelegate,\n+            final Serializable object) {\n+\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        writerDelegate.write(byteArrayOutputStream, object);\n+        return byteArrayOutputStream.toByteArray();\n+    }\n+\n+    @Override\n+    public Future<Object> pushFileAsync(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushFile(groupName, path, file, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public Future<Object> pushObjectAsync(final String bucketName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushObject(bucketName, path, writerDelegate, object, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public File pullFile(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        final MutableObject<File> file = new MutableObject<>(null);\n+\n+        this.wrapCloseConnection(() -> {\n+            try {\n+\n+                final List<Map<String, Object>> storageResult = Try.of(() ->\n+                        new DotConnect()\n+                                .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ?\")\n+                                .addParam(groupNameLC).addParam(pathLC).loadObjectResults()).getOrElse(\n+                        Collections::emptyList);\n+\n+                if (!storageResult.isEmpty()) {\n+\n+                    final Optional<Object> objectOpt = storageResult.stream()\n+                            .map(map -> map.get(\"hash\")).findFirst();\n+                    if (objectOpt.isPresent()) {\n+\n+                        final String objectHash = (String) objectOpt.get();\n+                        if (UtilMethods.isSet(objectHash)) {\n+\n+                            file.setValue(this.createJoinFile(objectHash));\n+                        }\n+                    }\n+                } else {\n+\n+                    throw new DoesNotExistException(\n+                            \"The storage, group: \" + groupName + \", path: \" + path\n+                                    + \" does not exists\");\n+                }\n+            } catch (IOException e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        });\n+\n+        return file.getValue();\n+    }\n+\n+    private File createJoinFile(final String hashId) throws IOException {\n+\n+        final File file = FileUtil.createTemporalFile(\"dotdbstorage-recovery\", \".tmp\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3MTE4Mw=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 647}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczNTAwNw==", "bodyText": "There's a new version of that method that takes a bool. if passed true it tells the underlying layers the temp file must be created under dotGeneratedPath", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505735007", "createdAt": "2020-10-15T17:59:18Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param jdbcPool\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage_group WHERE group_name = ?\")\n+                    .addParam(groupNameLC).loadObjectResults(this.getConnection())).getOrElse(\n+                    Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String}\n+     * @param objectPath {@link String}\n+     * @return\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage WHERE group_name = ? AND path = ?\")\n+                    .addParam(groupNameLC).addParam(objectPathLC)\n+                    .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName    {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options or not.\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults();\n+\n+            int count = deleteObjects(maps.stream().map(map -> map.get(\"hash\").toString())\n+                    .collect(Collectors.toSet()), dotConnect, connection);\n+\n+            final int storageEntriesCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage WHERE group_name = ?\", groupNameLC);\n+\n+            final int groupsCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_group WHERE group_name = ?\", groupNameLC);\n+\n+            Logger.info(this, () -> String\n+                    .format(\"total of `%d` objects allocated in `%d` removed for `%d` group. \",\n+                            storageEntriesCount, count, groupsCount));\n+            return storageEntriesCount;\n+        });\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @param path   {   @link String} object path\n+     * @return\n+     */\n+    @Override\n+    public boolean deleteObject(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final String hash = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ? \")\n+                    .addParam(groupNameLC).addParam(pathLC).getString(\"hash\");\n+            if(null != hash) {\n+                deleteObjects(ImmutableSet.of(hash), dotConnect, connection);\n+            }\n+            final int count = dotConnect\n+                    .executeUpdate(connection,\n+                            \"DELETE FROM storage WHERE group_name = ? AND path = ?\",\n+                            groupNameLC, pathLC);\n+            return count > 0;\n+        });\n+    }\n+\n+    /**\n+     * object reference removal\n+     * @param hashSet object hash id\n+     * @param dotConnect DotConnect\n+     * @param connection external connection\n+     * @return count of all removed objects\n+     * @throws DotDataException\n+     */\n+    private int deleteObjects(final Set<String> hashSet, final DotConnect dotConnect, final Connection connection)\n+            throws DotDataException {\n+      int count = 0;\n+        for (final String hash:hashSet) {\n+            //We could seriously benefit from a batch update here. The only problem is our current impl does not take an external connection\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_x_data WHERE data_hash = ?\", hash);\n+\n+            count +=  dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_data WHERE hash_id = ?\", hash);\n+\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return\n+     */\n+    @Override\n+    public List<String> listGroups() {\n+\n+        final MutableObject<List<String>> result = new MutableObject<>(Collections.emptyList());\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List<Map<String, Object>> results = Try\n+                    .of(() -> new DotConnect().setSQL(\"SELECT group_name FROM storage_group\")\n+                            .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+\n+            result.setValue(results.stream().map(map -> map.get(\"group_name\").toString())\n+                    .collect(CollectionsUtils.toImmutableList()));\n+        });\n+\n+        return result.getValue();\n+    }\n+\n+    @Override\n+    public Object pushFile(final String groupName, final String path,\n+            final File file, final Map<String, Object> extraMeta) {\n+\n+        // 1. generate metadata\n+        // 2. see if the sha-256 exists\n+        // 2.1 if exists only insert on the reference\n+        // 2.2 if does not exists, insert a new one\n+        final Map<String, Object> metaData = processMetadata(file, extraMeta);\n+        final String fileHash = (String) metaData.get(FileStorageAPI.SHA226_META_KEY);\n+\n+        return this.wrapInTransaction(\n+                () -> {\n+                    if (!existsGroup(groupName)) {\n+                        throw new IllegalArgumentException(\"The groupName: \" + groupName +\n+                                \", does not exist.\");\n+                    }\n+                    if (this.existsObject(groupName, path)) {\n+                        Logger.warn(DataBaseStoragePersistenceAPIImpl.class,\n+                                String.format(\"Attempt to override entry `%s/%s` \", groupName,\n+                                        path));\n+                        return false;\n+                    }\n+                    return this.existsHash(fileHash) ?\n+                            this.pushFileReference(groupName, path, metaData, fileHash) :\n+                            this.pushNewFile(groupName, path, file, metaData);\n+                });\n+    }\n+\n+    /**\n+     * Selects directly on storage-data since hash is the primary key there.\n+     * @param fileHash\n+     * @return\n+     */\n+    private boolean existsHash(final String fileHash) {\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        this.wrapCloseConnection(() -> {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_data WHERE hash_id = ?\")\n+                                        .addParam(fileHash)\n+                                        .loadObjectResults(this.getConnection());\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        });\n+\n+        return exists.getValue();\n+    }\n+\n+    private Map<String, Object> processMetadata(final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        if (UtilMethods.isSet(extraMeta) && extraMeta.containsKey(FileStorageAPI.SHA226_META_KEY)) {\n+\n+            return extraMeta;\n+        }\n+\n+        final ImmutableMap.Builder<String, Object> metaData = new ImmutableMap.Builder<>();\n+\n+        if (UtilMethods.isSet(extraMeta)) {\n+\n+            metaData.putAll(extraMeta);\n+        }\n+\n+        metaData.putAll(APILocator.getFileStorageAPI().generateRawBasicMetaData(file));\n+\n+        return metaData.build();\n+    }\n+\n+    private Object pushFileReference(final String groupName, final String path,\n+            final Map<String, Object> extraMeta, final String objectHash) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try {\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+            return true;\n+        } catch (DotDataException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private Object pushNewFile(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try (final FileByteSplitter fileSplitter = new FileByteSplitter(file)) {\n+\n+            final HashBuilder objectHashBuilder = Encryptor.Hashing.sha256();\n+            final List<String> chunkHashes = new ArrayList<>();\n+\n+            for (final Tuple2<byte[], Integer> bytesRead : fileSplitter) {\n+\n+                objectHashBuilder.append(bytesRead._1(), bytesRead._2());\n+                final String chunkHash = Encryptor.Hashing.sha256().append\n+                        (bytesRead._1(), bytesRead._2()).buildUnixHash();\n+                chunkHashes.add(chunkHash);\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_data(hash_id, data) VALUES (?, ?)\",\n+                        chunkHash,\n+                        bytesRead._1().length == bytesRead._2() ?\n+                                bytesRead._1() : this.chunkBytes(bytesRead._2(), bytesRead._1()));\n+            }\n+\n+            final String objectHash = objectHashBuilder.buildUnixHash();\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+\n+            int order = 1;\n+            for (final String chunkHash : chunkHashes) {\n+\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_x_data(storage_hash, data_hash, data_order) VALUES (?, ?, ?)\",\n+                        objectHash, chunkHash, order++);\n+            }\n+\n+            return true;\n+        } catch (DotDataException | NoSuchAlgorithmException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] chunkBytes(final int bytesLength, final byte[] bytes) {\n+\n+        final byte[] chunkedArray = new byte[bytesLength];\n+\n+        System.arraycopy(bytes, 0, chunkedArray, 0, bytesLength);\n+\n+        return chunkedArray;\n+    }\n+\n+    @Override\n+    public Object pushObject(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        try {\n+\n+            final File file = FileUtil.createTemporalFile(\"object-storage\", \".tmp\");\n+            final byte[] objectBytes = this.objectToBytes(writerDelegate, object);\n+            FileUtils.writeByteArrayToFile(file, objectBytes);\n+\n+            return this.pushFile(groupName, path, file, extraMeta);\n+        } catch (IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] objectToBytes(final ObjectWriterDelegate writerDelegate,\n+            final Serializable object) {\n+\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        writerDelegate.write(byteArrayOutputStream, object);\n+        return byteArrayOutputStream.toByteArray();\n+    }\n+\n+    @Override\n+    public Future<Object> pushFileAsync(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushFile(groupName, path, file, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public Future<Object> pushObjectAsync(final String bucketName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushObject(bucketName, path, writerDelegate, object, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public File pullFile(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        final MutableObject<File> file = new MutableObject<>(null);\n+\n+        this.wrapCloseConnection(() -> {\n+            try {\n+\n+                final List<Map<String, Object>> storageResult = Try.of(() ->\n+                        new DotConnect()\n+                                .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ?\")\n+                                .addParam(groupNameLC).addParam(pathLC).loadObjectResults()).getOrElse(\n+                        Collections::emptyList);\n+\n+                if (!storageResult.isEmpty()) {\n+\n+                    final Optional<Object> objectOpt = storageResult.stream()\n+                            .map(map -> map.get(\"hash\")).findFirst();\n+                    if (objectOpt.isPresent()) {\n+\n+                        final String objectHash = (String) objectOpt.get();\n+                        if (UtilMethods.isSet(objectHash)) {\n+\n+                            file.setValue(this.createJoinFile(objectHash));\n+                        }\n+                    }\n+                } else {\n+\n+                    throw new DoesNotExistException(\n+                            \"The storage, group: \" + groupName + \", path: \" + path\n+                                    + \" does not exists\");\n+                }\n+            } catch (IOException e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        });\n+\n+        return file.getValue();\n+    }\n+\n+    private File createJoinFile(final String hashId) throws IOException {\n+\n+        final File file = FileUtil.createTemporalFile(\"dotdbstorage-recovery\", \".tmp\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3MTE4Mw=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 647}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzQ5NTg1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODo0MzowM1rOHgJeBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMToyNjo0MVrOHibtIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3MTYyMw==", "bodyText": "Is this a chunk or a whole file?  Again, we should use streams where possible and not read ByteArrays into memory.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503471623", "createdAt": "2020-10-12T18:43:03Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param jdbcPool\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage_group WHERE group_name = ?\")\n+                    .addParam(groupNameLC).loadObjectResults(this.getConnection())).getOrElse(\n+                    Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String}\n+     * @param objectPath {@link String}\n+     * @return\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage WHERE group_name = ? AND path = ?\")\n+                    .addParam(groupNameLC).addParam(objectPathLC)\n+                    .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName    {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options or not.\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults();\n+\n+            int count = deleteObjects(maps.stream().map(map -> map.get(\"hash\").toString())\n+                    .collect(Collectors.toSet()), dotConnect, connection);\n+\n+            final int storageEntriesCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage WHERE group_name = ?\", groupNameLC);\n+\n+            final int groupsCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_group WHERE group_name = ?\", groupNameLC);\n+\n+            Logger.info(this, () -> String\n+                    .format(\"total of `%d` objects allocated in `%d` removed for `%d` group. \",\n+                            storageEntriesCount, count, groupsCount));\n+            return storageEntriesCount;\n+        });\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @param path   {   @link String} object path\n+     * @return\n+     */\n+    @Override\n+    public boolean deleteObject(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final String hash = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ? \")\n+                    .addParam(groupNameLC).addParam(pathLC).getString(\"hash\");\n+            if(null != hash) {\n+                deleteObjects(ImmutableSet.of(hash), dotConnect, connection);\n+            }\n+            final int count = dotConnect\n+                    .executeUpdate(connection,\n+                            \"DELETE FROM storage WHERE group_name = ? AND path = ?\",\n+                            groupNameLC, pathLC);\n+            return count > 0;\n+        });\n+    }\n+\n+    /**\n+     * object reference removal\n+     * @param hashSet object hash id\n+     * @param dotConnect DotConnect\n+     * @param connection external connection\n+     * @return count of all removed objects\n+     * @throws DotDataException\n+     */\n+    private int deleteObjects(final Set<String> hashSet, final DotConnect dotConnect, final Connection connection)\n+            throws DotDataException {\n+      int count = 0;\n+        for (final String hash:hashSet) {\n+            //We could seriously benefit from a batch update here. The only problem is our current impl does not take an external connection\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_x_data WHERE data_hash = ?\", hash);\n+\n+            count +=  dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_data WHERE hash_id = ?\", hash);\n+\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return\n+     */\n+    @Override\n+    public List<String> listGroups() {\n+\n+        final MutableObject<List<String>> result = new MutableObject<>(Collections.emptyList());\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List<Map<String, Object>> results = Try\n+                    .of(() -> new DotConnect().setSQL(\"SELECT group_name FROM storage_group\")\n+                            .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+\n+            result.setValue(results.stream().map(map -> map.get(\"group_name\").toString())\n+                    .collect(CollectionsUtils.toImmutableList()));\n+        });\n+\n+        return result.getValue();\n+    }\n+\n+    @Override\n+    public Object pushFile(final String groupName, final String path,\n+            final File file, final Map<String, Object> extraMeta) {\n+\n+        // 1. generate metadata\n+        // 2. see if the sha-256 exists\n+        // 2.1 if exists only insert on the reference\n+        // 2.2 if does not exists, insert a new one\n+        final Map<String, Object> metaData = processMetadata(file, extraMeta);\n+        final String fileHash = (String) metaData.get(FileStorageAPI.SHA226_META_KEY);\n+\n+        return this.wrapInTransaction(\n+                () -> {\n+                    if (!existsGroup(groupName)) {\n+                        throw new IllegalArgumentException(\"The groupName: \" + groupName +\n+                                \", does not exist.\");\n+                    }\n+                    if (this.existsObject(groupName, path)) {\n+                        Logger.warn(DataBaseStoragePersistenceAPIImpl.class,\n+                                String.format(\"Attempt to override entry `%s/%s` \", groupName,\n+                                        path));\n+                        return false;\n+                    }\n+                    return this.existsHash(fileHash) ?\n+                            this.pushFileReference(groupName, path, metaData, fileHash) :\n+                            this.pushNewFile(groupName, path, file, metaData);\n+                });\n+    }\n+\n+    /**\n+     * Selects directly on storage-data since hash is the primary key there.\n+     * @param fileHash\n+     * @return\n+     */\n+    private boolean existsHash(final String fileHash) {\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        this.wrapCloseConnection(() -> {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_data WHERE hash_id = ?\")\n+                                        .addParam(fileHash)\n+                                        .loadObjectResults(this.getConnection());\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        });\n+\n+        return exists.getValue();\n+    }\n+\n+    private Map<String, Object> processMetadata(final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        if (UtilMethods.isSet(extraMeta) && extraMeta.containsKey(FileStorageAPI.SHA226_META_KEY)) {\n+\n+            return extraMeta;\n+        }\n+\n+        final ImmutableMap.Builder<String, Object> metaData = new ImmutableMap.Builder<>();\n+\n+        if (UtilMethods.isSet(extraMeta)) {\n+\n+            metaData.putAll(extraMeta);\n+        }\n+\n+        metaData.putAll(APILocator.getFileStorageAPI().generateRawBasicMetaData(file));\n+\n+        return metaData.build();\n+    }\n+\n+    private Object pushFileReference(final String groupName, final String path,\n+            final Map<String, Object> extraMeta, final String objectHash) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try {\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+            return true;\n+        } catch (DotDataException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private Object pushNewFile(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try (final FileByteSplitter fileSplitter = new FileByteSplitter(file)) {\n+\n+            final HashBuilder objectHashBuilder = Encryptor.Hashing.sha256();\n+            final List<String> chunkHashes = new ArrayList<>();\n+\n+            for (final Tuple2<byte[], Integer> bytesRead : fileSplitter) {\n+\n+                objectHashBuilder.append(bytesRead._1(), bytesRead._2());\n+                final String chunkHash = Encryptor.Hashing.sha256().append\n+                        (bytesRead._1(), bytesRead._2()).buildUnixHash();\n+                chunkHashes.add(chunkHash);\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_data(hash_id, data) VALUES (?, ?)\",\n+                        chunkHash,\n+                        bytesRead._1().length == bytesRead._2() ?\n+                                bytesRead._1() : this.chunkBytes(bytesRead._2(), bytesRead._1()));\n+            }\n+\n+            final String objectHash = objectHashBuilder.buildUnixHash();\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+\n+            int order = 1;\n+            for (final String chunkHash : chunkHashes) {\n+\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_x_data(storage_hash, data_hash, data_order) VALUES (?, ?, ?)\",\n+                        objectHash, chunkHash, order++);\n+            }\n+\n+            return true;\n+        } catch (DotDataException | NoSuchAlgorithmException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] chunkBytes(final int bytesLength, final byte[] bytes) {\n+\n+        final byte[] chunkedArray = new byte[bytesLength];\n+\n+        System.arraycopy(bytes, 0, chunkedArray, 0, bytesLength);\n+\n+        return chunkedArray;\n+    }\n+\n+    @Override\n+    public Object pushObject(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        try {\n+\n+            final File file = FileUtil.createTemporalFile(\"object-storage\", \".tmp\");\n+            final byte[] objectBytes = this.objectToBytes(writerDelegate, object);\n+            FileUtils.writeByteArrayToFile(file, objectBytes);\n+\n+            return this.pushFile(groupName, path, file, extraMeta);\n+        } catch (IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] objectToBytes(final ObjectWriterDelegate writerDelegate,\n+            final Serializable object) {\n+\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        writerDelegate.write(byteArrayOutputStream, object);\n+        return byteArrayOutputStream.toByteArray();\n+    }\n+\n+    @Override\n+    public Future<Object> pushFileAsync(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushFile(groupName, path, file, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public Future<Object> pushObjectAsync(final String bucketName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushObject(bucketName, path, writerDelegate, object, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public File pullFile(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        final MutableObject<File> file = new MutableObject<>(null);\n+\n+        this.wrapCloseConnection(() -> {\n+            try {\n+\n+                final List<Map<String, Object>> storageResult = Try.of(() ->\n+                        new DotConnect()\n+                                .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ?\")\n+                                .addParam(groupNameLC).addParam(pathLC).loadObjectResults()).getOrElse(\n+                        Collections::emptyList);\n+\n+                if (!storageResult.isEmpty()) {\n+\n+                    final Optional<Object> objectOpt = storageResult.stream()\n+                            .map(map -> map.get(\"hash\")).findFirst();\n+                    if (objectOpt.isPresent()) {\n+\n+                        final String objectHash = (String) objectOpt.get();\n+                        if (UtilMethods.isSet(objectHash)) {\n+\n+                            file.setValue(this.createJoinFile(objectHash));\n+                        }\n+                    }\n+                } else {\n+\n+                    throw new DoesNotExistException(\n+                            \"The storage, group: \" + groupName + \", path: \" + path\n+                                    + \" does not exists\");\n+                }\n+            } catch (IOException e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        });\n+\n+        return file.getValue();\n+    }\n+\n+    private File createJoinFile(final String hashId) throws IOException {\n+\n+        final File file = FileUtil.createTemporalFile(\"dotdbstorage-recovery\", \".tmp\");\n+        try (final FileJoiner fileJoiner = new FileJoiner(file)) {\n+\n+            final HashBuilder fileHashBuilder = Try.of(() -> Encryptor.Hashing.sha256())\n+                    .getOrElseThrow(DotRuntimeException::new);\n+            final List<Map<String, Object>> hashes = Try.of(() -> new DotConnect().setSQL(\n+                    \"SELECT storage_data.hash_id AS hash, storage_data.data AS data FROM storage_data , storage_x_data \"\n+                            +\n+                            \"WHERE storage_x_data.data_hash  =  storage_data.hash_id \" +\n+                            \"AND storage_x_data.storage_hash = ? order by data_order ASC\")\n+                    .setFetchSize(1).addParam(hashId).loadObjectResults(this.getConnection()))\n+                    .getOrElse(() -> Collections.emptyList());\n+\n+            for (final Map<String, Object> hashMap : hashes) {\n+\n+                final String hash = (String) hashMap.get(\"hash\");\n+                final byte[] bytes = (byte[]) hashMap\n+                        .get(\"data\"); // todo: this could be a getInputStream: must\n+                final String recoverHash = Try\n+                        .of(() -> Encryptor.Hashing.sha256().append(bytes).buildUnixHash())\n+                        .getOrElseThrow(DotRuntimeException::new);\n+\n+                if (hash.equals(recoverHash)) {\n+\n+                    fileJoiner.join(bytes, 0, bytes.length);\n+                    fileJoiner.flush();\n+                    fileHashBuilder.append(bytes);\n+                } else {\n+\n+                    throw new DotCorruptedDataException(\"The chunks hash is not valid\");\n+                }\n+            }\n+\n+            if (!hashId.equals(fileHashBuilder.buildUnixHash())) {\n+\n+                throw new DotCorruptedDataException(\"The file hash is not valid\");\n+            }\n+        }\n+\n+        return file;\n+    }\n+\n+    @Override\n+    public Object pullObject(final String groupName, final String path,\n+            final ObjectReaderDelegate readerDelegate) {\n+\n+        Object object = null;\n+        final File file = pullFile(groupName, path);\n+\n+        if (null != file) {\n+\n+            object = Try.of(() -> readerDelegate.read(\n+                    new ByteArrayInputStream(FileUtils.readFileToByteArray(file)))).getOrNull();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 699}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTEzMDQ1Nw==", "bodyText": "I think we need more info regarding the stuff we put into storage... I see the only way we have to gain access to the blob fields is via FileJoining. Meaning we have to dump chunks into a file prior to serving it.  That can be expensive especially if we take into consideration that metadata is formed by very small chubks that could be loaded into a byte array at a very low cost.  That said we don't hold enough information in our DB to decide whether or not we want to serve the content through a file or a small stream buffer. I think I'm gonna add a \"size\" field to track such info.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505130457", "createdAt": "2020-10-15T02:41:28Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param jdbcPool\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage_group WHERE group_name = ?\")\n+                    .addParam(groupNameLC).loadObjectResults(this.getConnection())).getOrElse(\n+                    Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String}\n+     * @param objectPath {@link String}\n+     * @return\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage WHERE group_name = ? AND path = ?\")\n+                    .addParam(groupNameLC).addParam(objectPathLC)\n+                    .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName    {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options or not.\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults();\n+\n+            int count = deleteObjects(maps.stream().map(map -> map.get(\"hash\").toString())\n+                    .collect(Collectors.toSet()), dotConnect, connection);\n+\n+            final int storageEntriesCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage WHERE group_name = ?\", groupNameLC);\n+\n+            final int groupsCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_group WHERE group_name = ?\", groupNameLC);\n+\n+            Logger.info(this, () -> String\n+                    .format(\"total of `%d` objects allocated in `%d` removed for `%d` group. \",\n+                            storageEntriesCount, count, groupsCount));\n+            return storageEntriesCount;\n+        });\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @param path   {   @link String} object path\n+     * @return\n+     */\n+    @Override\n+    public boolean deleteObject(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final String hash = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ? \")\n+                    .addParam(groupNameLC).addParam(pathLC).getString(\"hash\");\n+            if(null != hash) {\n+                deleteObjects(ImmutableSet.of(hash), dotConnect, connection);\n+            }\n+            final int count = dotConnect\n+                    .executeUpdate(connection,\n+                            \"DELETE FROM storage WHERE group_name = ? AND path = ?\",\n+                            groupNameLC, pathLC);\n+            return count > 0;\n+        });\n+    }\n+\n+    /**\n+     * object reference removal\n+     * @param hashSet object hash id\n+     * @param dotConnect DotConnect\n+     * @param connection external connection\n+     * @return count of all removed objects\n+     * @throws DotDataException\n+     */\n+    private int deleteObjects(final Set<String> hashSet, final DotConnect dotConnect, final Connection connection)\n+            throws DotDataException {\n+      int count = 0;\n+        for (final String hash:hashSet) {\n+            //We could seriously benefit from a batch update here. The only problem is our current impl does not take an external connection\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_x_data WHERE data_hash = ?\", hash);\n+\n+            count +=  dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_data WHERE hash_id = ?\", hash);\n+\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return\n+     */\n+    @Override\n+    public List<String> listGroups() {\n+\n+        final MutableObject<List<String>> result = new MutableObject<>(Collections.emptyList());\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List<Map<String, Object>> results = Try\n+                    .of(() -> new DotConnect().setSQL(\"SELECT group_name FROM storage_group\")\n+                            .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+\n+            result.setValue(results.stream().map(map -> map.get(\"group_name\").toString())\n+                    .collect(CollectionsUtils.toImmutableList()));\n+        });\n+\n+        return result.getValue();\n+    }\n+\n+    @Override\n+    public Object pushFile(final String groupName, final String path,\n+            final File file, final Map<String, Object> extraMeta) {\n+\n+        // 1. generate metadata\n+        // 2. see if the sha-256 exists\n+        // 2.1 if exists only insert on the reference\n+        // 2.2 if does not exists, insert a new one\n+        final Map<String, Object> metaData = processMetadata(file, extraMeta);\n+        final String fileHash = (String) metaData.get(FileStorageAPI.SHA226_META_KEY);\n+\n+        return this.wrapInTransaction(\n+                () -> {\n+                    if (!existsGroup(groupName)) {\n+                        throw new IllegalArgumentException(\"The groupName: \" + groupName +\n+                                \", does not exist.\");\n+                    }\n+                    if (this.existsObject(groupName, path)) {\n+                        Logger.warn(DataBaseStoragePersistenceAPIImpl.class,\n+                                String.format(\"Attempt to override entry `%s/%s` \", groupName,\n+                                        path));\n+                        return false;\n+                    }\n+                    return this.existsHash(fileHash) ?\n+                            this.pushFileReference(groupName, path, metaData, fileHash) :\n+                            this.pushNewFile(groupName, path, file, metaData);\n+                });\n+    }\n+\n+    /**\n+     * Selects directly on storage-data since hash is the primary key there.\n+     * @param fileHash\n+     * @return\n+     */\n+    private boolean existsHash(final String fileHash) {\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        this.wrapCloseConnection(() -> {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_data WHERE hash_id = ?\")\n+                                        .addParam(fileHash)\n+                                        .loadObjectResults(this.getConnection());\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        });\n+\n+        return exists.getValue();\n+    }\n+\n+    private Map<String, Object> processMetadata(final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        if (UtilMethods.isSet(extraMeta) && extraMeta.containsKey(FileStorageAPI.SHA226_META_KEY)) {\n+\n+            return extraMeta;\n+        }\n+\n+        final ImmutableMap.Builder<String, Object> metaData = new ImmutableMap.Builder<>();\n+\n+        if (UtilMethods.isSet(extraMeta)) {\n+\n+            metaData.putAll(extraMeta);\n+        }\n+\n+        metaData.putAll(APILocator.getFileStorageAPI().generateRawBasicMetaData(file));\n+\n+        return metaData.build();\n+    }\n+\n+    private Object pushFileReference(final String groupName, final String path,\n+            final Map<String, Object> extraMeta, final String objectHash) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try {\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+            return true;\n+        } catch (DotDataException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private Object pushNewFile(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try (final FileByteSplitter fileSplitter = new FileByteSplitter(file)) {\n+\n+            final HashBuilder objectHashBuilder = Encryptor.Hashing.sha256();\n+            final List<String> chunkHashes = new ArrayList<>();\n+\n+            for (final Tuple2<byte[], Integer> bytesRead : fileSplitter) {\n+\n+                objectHashBuilder.append(bytesRead._1(), bytesRead._2());\n+                final String chunkHash = Encryptor.Hashing.sha256().append\n+                        (bytesRead._1(), bytesRead._2()).buildUnixHash();\n+                chunkHashes.add(chunkHash);\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_data(hash_id, data) VALUES (?, ?)\",\n+                        chunkHash,\n+                        bytesRead._1().length == bytesRead._2() ?\n+                                bytesRead._1() : this.chunkBytes(bytesRead._2(), bytesRead._1()));\n+            }\n+\n+            final String objectHash = objectHashBuilder.buildUnixHash();\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+\n+            int order = 1;\n+            for (final String chunkHash : chunkHashes) {\n+\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_x_data(storage_hash, data_hash, data_order) VALUES (?, ?, ?)\",\n+                        objectHash, chunkHash, order++);\n+            }\n+\n+            return true;\n+        } catch (DotDataException | NoSuchAlgorithmException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] chunkBytes(final int bytesLength, final byte[] bytes) {\n+\n+        final byte[] chunkedArray = new byte[bytesLength];\n+\n+        System.arraycopy(bytes, 0, chunkedArray, 0, bytesLength);\n+\n+        return chunkedArray;\n+    }\n+\n+    @Override\n+    public Object pushObject(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        try {\n+\n+            final File file = FileUtil.createTemporalFile(\"object-storage\", \".tmp\");\n+            final byte[] objectBytes = this.objectToBytes(writerDelegate, object);\n+            FileUtils.writeByteArrayToFile(file, objectBytes);\n+\n+            return this.pushFile(groupName, path, file, extraMeta);\n+        } catch (IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] objectToBytes(final ObjectWriterDelegate writerDelegate,\n+            final Serializable object) {\n+\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        writerDelegate.write(byteArrayOutputStream, object);\n+        return byteArrayOutputStream.toByteArray();\n+    }\n+\n+    @Override\n+    public Future<Object> pushFileAsync(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushFile(groupName, path, file, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public Future<Object> pushObjectAsync(final String bucketName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushObject(bucketName, path, writerDelegate, object, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public File pullFile(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        final MutableObject<File> file = new MutableObject<>(null);\n+\n+        this.wrapCloseConnection(() -> {\n+            try {\n+\n+                final List<Map<String, Object>> storageResult = Try.of(() ->\n+                        new DotConnect()\n+                                .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ?\")\n+                                .addParam(groupNameLC).addParam(pathLC).loadObjectResults()).getOrElse(\n+                        Collections::emptyList);\n+\n+                if (!storageResult.isEmpty()) {\n+\n+                    final Optional<Object> objectOpt = storageResult.stream()\n+                            .map(map -> map.get(\"hash\")).findFirst();\n+                    if (objectOpt.isPresent()) {\n+\n+                        final String objectHash = (String) objectOpt.get();\n+                        if (UtilMethods.isSet(objectHash)) {\n+\n+                            file.setValue(this.createJoinFile(objectHash));\n+                        }\n+                    }\n+                } else {\n+\n+                    throw new DoesNotExistException(\n+                            \"The storage, group: \" + groupName + \", path: \" + path\n+                                    + \" does not exists\");\n+                }\n+            } catch (IOException e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        });\n+\n+        return file.getValue();\n+    }\n+\n+    private File createJoinFile(final String hashId) throws IOException {\n+\n+        final File file = FileUtil.createTemporalFile(\"dotdbstorage-recovery\", \".tmp\");\n+        try (final FileJoiner fileJoiner = new FileJoiner(file)) {\n+\n+            final HashBuilder fileHashBuilder = Try.of(() -> Encryptor.Hashing.sha256())\n+                    .getOrElseThrow(DotRuntimeException::new);\n+            final List<Map<String, Object>> hashes = Try.of(() -> new DotConnect().setSQL(\n+                    \"SELECT storage_data.hash_id AS hash, storage_data.data AS data FROM storage_data , storage_x_data \"\n+                            +\n+                            \"WHERE storage_x_data.data_hash  =  storage_data.hash_id \" +\n+                            \"AND storage_x_data.storage_hash = ? order by data_order ASC\")\n+                    .setFetchSize(1).addParam(hashId).loadObjectResults(this.getConnection()))\n+                    .getOrElse(() -> Collections.emptyList());\n+\n+            for (final Map<String, Object> hashMap : hashes) {\n+\n+                final String hash = (String) hashMap.get(\"hash\");\n+                final byte[] bytes = (byte[]) hashMap\n+                        .get(\"data\"); // todo: this could be a getInputStream: must\n+                final String recoverHash = Try\n+                        .of(() -> Encryptor.Hashing.sha256().append(bytes).buildUnixHash())\n+                        .getOrElseThrow(DotRuntimeException::new);\n+\n+                if (hash.equals(recoverHash)) {\n+\n+                    fileJoiner.join(bytes, 0, bytes.length);\n+                    fileJoiner.flush();\n+                    fileHashBuilder.append(bytes);\n+                } else {\n+\n+                    throw new DotCorruptedDataException(\"The chunks hash is not valid\");\n+                }\n+            }\n+\n+            if (!hashId.equals(fileHashBuilder.buildUnixHash())) {\n+\n+                throw new DotCorruptedDataException(\"The file hash is not valid\");\n+            }\n+        }\n+\n+        return file;\n+    }\n+\n+    @Override\n+    public Object pullObject(final String groupName, final String path,\n+            final ObjectReaderDelegate readerDelegate) {\n+\n+        Object object = null;\n+        final File file = pullFile(groupName, path);\n+\n+        if (null != file) {\n+\n+            object = Try.of(() -> readerDelegate.read(\n+                    new ByteArrayInputStream(FileUtils.readFileToByteArray(file)))).getOrNull();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3MTYyMw=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 699}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2NzU1Mg==", "bodyText": "anyways .. fixed switched to a Stream", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505867552", "createdAt": "2020-10-15T21:26:41Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param jdbcPool\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage_group WHERE group_name = ?\")\n+                    .addParam(groupNameLC).loadObjectResults(this.getConnection())).getOrElse(\n+                    Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String}\n+     * @param objectPath {@link String}\n+     * @return\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage WHERE group_name = ? AND path = ?\")\n+                    .addParam(groupNameLC).addParam(objectPathLC)\n+                    .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName    {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options or not.\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults();\n+\n+            int count = deleteObjects(maps.stream().map(map -> map.get(\"hash\").toString())\n+                    .collect(Collectors.toSet()), dotConnect, connection);\n+\n+            final int storageEntriesCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage WHERE group_name = ?\", groupNameLC);\n+\n+            final int groupsCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_group WHERE group_name = ?\", groupNameLC);\n+\n+            Logger.info(this, () -> String\n+                    .format(\"total of `%d` objects allocated in `%d` removed for `%d` group. \",\n+                            storageEntriesCount, count, groupsCount));\n+            return storageEntriesCount;\n+        });\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @param path   {   @link String} object path\n+     * @return\n+     */\n+    @Override\n+    public boolean deleteObject(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final String hash = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ? \")\n+                    .addParam(groupNameLC).addParam(pathLC).getString(\"hash\");\n+            if(null != hash) {\n+                deleteObjects(ImmutableSet.of(hash), dotConnect, connection);\n+            }\n+            final int count = dotConnect\n+                    .executeUpdate(connection,\n+                            \"DELETE FROM storage WHERE group_name = ? AND path = ?\",\n+                            groupNameLC, pathLC);\n+            return count > 0;\n+        });\n+    }\n+\n+    /**\n+     * object reference removal\n+     * @param hashSet object hash id\n+     * @param dotConnect DotConnect\n+     * @param connection external connection\n+     * @return count of all removed objects\n+     * @throws DotDataException\n+     */\n+    private int deleteObjects(final Set<String> hashSet, final DotConnect dotConnect, final Connection connection)\n+            throws DotDataException {\n+      int count = 0;\n+        for (final String hash:hashSet) {\n+            //We could seriously benefit from a batch update here. The only problem is our current impl does not take an external connection\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_x_data WHERE data_hash = ?\", hash);\n+\n+            count +=  dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_data WHERE hash_id = ?\", hash);\n+\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return\n+     */\n+    @Override\n+    public List<String> listGroups() {\n+\n+        final MutableObject<List<String>> result = new MutableObject<>(Collections.emptyList());\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List<Map<String, Object>> results = Try\n+                    .of(() -> new DotConnect().setSQL(\"SELECT group_name FROM storage_group\")\n+                            .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+\n+            result.setValue(results.stream().map(map -> map.get(\"group_name\").toString())\n+                    .collect(CollectionsUtils.toImmutableList()));\n+        });\n+\n+        return result.getValue();\n+    }\n+\n+    @Override\n+    public Object pushFile(final String groupName, final String path,\n+            final File file, final Map<String, Object> extraMeta) {\n+\n+        // 1. generate metadata\n+        // 2. see if the sha-256 exists\n+        // 2.1 if exists only insert on the reference\n+        // 2.2 if does not exists, insert a new one\n+        final Map<String, Object> metaData = processMetadata(file, extraMeta);\n+        final String fileHash = (String) metaData.get(FileStorageAPI.SHA226_META_KEY);\n+\n+        return this.wrapInTransaction(\n+                () -> {\n+                    if (!existsGroup(groupName)) {\n+                        throw new IllegalArgumentException(\"The groupName: \" + groupName +\n+                                \", does not exist.\");\n+                    }\n+                    if (this.existsObject(groupName, path)) {\n+                        Logger.warn(DataBaseStoragePersistenceAPIImpl.class,\n+                                String.format(\"Attempt to override entry `%s/%s` \", groupName,\n+                                        path));\n+                        return false;\n+                    }\n+                    return this.existsHash(fileHash) ?\n+                            this.pushFileReference(groupName, path, metaData, fileHash) :\n+                            this.pushNewFile(groupName, path, file, metaData);\n+                });\n+    }\n+\n+    /**\n+     * Selects directly on storage-data since hash is the primary key there.\n+     * @param fileHash\n+     * @return\n+     */\n+    private boolean existsHash(final String fileHash) {\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        this.wrapCloseConnection(() -> {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_data WHERE hash_id = ?\")\n+                                        .addParam(fileHash)\n+                                        .loadObjectResults(this.getConnection());\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        });\n+\n+        return exists.getValue();\n+    }\n+\n+    private Map<String, Object> processMetadata(final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        if (UtilMethods.isSet(extraMeta) && extraMeta.containsKey(FileStorageAPI.SHA226_META_KEY)) {\n+\n+            return extraMeta;\n+        }\n+\n+        final ImmutableMap.Builder<String, Object> metaData = new ImmutableMap.Builder<>();\n+\n+        if (UtilMethods.isSet(extraMeta)) {\n+\n+            metaData.putAll(extraMeta);\n+        }\n+\n+        metaData.putAll(APILocator.getFileStorageAPI().generateRawBasicMetaData(file));\n+\n+        return metaData.build();\n+    }\n+\n+    private Object pushFileReference(final String groupName, final String path,\n+            final Map<String, Object> extraMeta, final String objectHash) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try {\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+            return true;\n+        } catch (DotDataException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private Object pushNewFile(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try (final FileByteSplitter fileSplitter = new FileByteSplitter(file)) {\n+\n+            final HashBuilder objectHashBuilder = Encryptor.Hashing.sha256();\n+            final List<String> chunkHashes = new ArrayList<>();\n+\n+            for (final Tuple2<byte[], Integer> bytesRead : fileSplitter) {\n+\n+                objectHashBuilder.append(bytesRead._1(), bytesRead._2());\n+                final String chunkHash = Encryptor.Hashing.sha256().append\n+                        (bytesRead._1(), bytesRead._2()).buildUnixHash();\n+                chunkHashes.add(chunkHash);\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_data(hash_id, data) VALUES (?, ?)\",\n+                        chunkHash,\n+                        bytesRead._1().length == bytesRead._2() ?\n+                                bytesRead._1() : this.chunkBytes(bytesRead._2(), bytesRead._1()));\n+            }\n+\n+            final String objectHash = objectHashBuilder.buildUnixHash();\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+\n+            int order = 1;\n+            for (final String chunkHash : chunkHashes) {\n+\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_x_data(storage_hash, data_hash, data_order) VALUES (?, ?, ?)\",\n+                        objectHash, chunkHash, order++);\n+            }\n+\n+            return true;\n+        } catch (DotDataException | NoSuchAlgorithmException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] chunkBytes(final int bytesLength, final byte[] bytes) {\n+\n+        final byte[] chunkedArray = new byte[bytesLength];\n+\n+        System.arraycopy(bytes, 0, chunkedArray, 0, bytesLength);\n+\n+        return chunkedArray;\n+    }\n+\n+    @Override\n+    public Object pushObject(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        try {\n+\n+            final File file = FileUtil.createTemporalFile(\"object-storage\", \".tmp\");\n+            final byte[] objectBytes = this.objectToBytes(writerDelegate, object);\n+            FileUtils.writeByteArrayToFile(file, objectBytes);\n+\n+            return this.pushFile(groupName, path, file, extraMeta);\n+        } catch (IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] objectToBytes(final ObjectWriterDelegate writerDelegate,\n+            final Serializable object) {\n+\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        writerDelegate.write(byteArrayOutputStream, object);\n+        return byteArrayOutputStream.toByteArray();\n+    }\n+\n+    @Override\n+    public Future<Object> pushFileAsync(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushFile(groupName, path, file, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public Future<Object> pushObjectAsync(final String bucketName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushObject(bucketName, path, writerDelegate, object, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public File pullFile(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        final MutableObject<File> file = new MutableObject<>(null);\n+\n+        this.wrapCloseConnection(() -> {\n+            try {\n+\n+                final List<Map<String, Object>> storageResult = Try.of(() ->\n+                        new DotConnect()\n+                                .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ?\")\n+                                .addParam(groupNameLC).addParam(pathLC).loadObjectResults()).getOrElse(\n+                        Collections::emptyList);\n+\n+                if (!storageResult.isEmpty()) {\n+\n+                    final Optional<Object> objectOpt = storageResult.stream()\n+                            .map(map -> map.get(\"hash\")).findFirst();\n+                    if (objectOpt.isPresent()) {\n+\n+                        final String objectHash = (String) objectOpt.get();\n+                        if (UtilMethods.isSet(objectHash)) {\n+\n+                            file.setValue(this.createJoinFile(objectHash));\n+                        }\n+                    }\n+                } else {\n+\n+                    throw new DoesNotExistException(\n+                            \"The storage, group: \" + groupName + \", path: \" + path\n+                                    + \" does not exists\");\n+                }\n+            } catch (IOException e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        });\n+\n+        return file.getValue();\n+    }\n+\n+    private File createJoinFile(final String hashId) throws IOException {\n+\n+        final File file = FileUtil.createTemporalFile(\"dotdbstorage-recovery\", \".tmp\");\n+        try (final FileJoiner fileJoiner = new FileJoiner(file)) {\n+\n+            final HashBuilder fileHashBuilder = Try.of(() -> Encryptor.Hashing.sha256())\n+                    .getOrElseThrow(DotRuntimeException::new);\n+            final List<Map<String, Object>> hashes = Try.of(() -> new DotConnect().setSQL(\n+                    \"SELECT storage_data.hash_id AS hash, storage_data.data AS data FROM storage_data , storage_x_data \"\n+                            +\n+                            \"WHERE storage_x_data.data_hash  =  storage_data.hash_id \" +\n+                            \"AND storage_x_data.storage_hash = ? order by data_order ASC\")\n+                    .setFetchSize(1).addParam(hashId).loadObjectResults(this.getConnection()))\n+                    .getOrElse(() -> Collections.emptyList());\n+\n+            for (final Map<String, Object> hashMap : hashes) {\n+\n+                final String hash = (String) hashMap.get(\"hash\");\n+                final byte[] bytes = (byte[]) hashMap\n+                        .get(\"data\"); // todo: this could be a getInputStream: must\n+                final String recoverHash = Try\n+                        .of(() -> Encryptor.Hashing.sha256().append(bytes).buildUnixHash())\n+                        .getOrElseThrow(DotRuntimeException::new);\n+\n+                if (hash.equals(recoverHash)) {\n+\n+                    fileJoiner.join(bytes, 0, bytes.length);\n+                    fileJoiner.flush();\n+                    fileHashBuilder.append(bytes);\n+                } else {\n+\n+                    throw new DotCorruptedDataException(\"The chunks hash is not valid\");\n+                }\n+            }\n+\n+            if (!hashId.equals(fileHashBuilder.buildUnixHash())) {\n+\n+                throw new DotCorruptedDataException(\"The file hash is not valid\");\n+            }\n+        }\n+\n+        return file;\n+    }\n+\n+    @Override\n+    public Object pullObject(final String groupName, final String path,\n+            final ObjectReaderDelegate readerDelegate) {\n+\n+        Object object = null;\n+        final File file = pullFile(groupName, path);\n+\n+        if (null != file) {\n+\n+            object = Try.of(() -> readerDelegate.read(\n+                    new ByteArrayInputStream(FileUtils.readFileToByteArray(file)))).getOrNull();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3MTYyMw=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 699}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzQ5OTg2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/FileStorageAPI.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODo0NDozMVrOHgJgbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzo1NzowOFrOHiTiRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3MjIzNg==", "bodyText": "As you mentioned, let's add isImage and  Dimension in the next branch", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503472236", "createdAt": "2020-10-12T18:44:31Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/FileStorageAPI.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package com.dotcms.storage;\n+\n+import com.dotmarketing.util.Config;\n+\n+import java.io.File;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+\n+/**\n+ * This class is in charge of resolve File (on diff storages), metadata, etc.\n+ * @author jsanca\n+ */\n+public interface FileStorageAPI {\n+\n+    int SIZE                       = 1024;\n+    int DEFAULT_META_DATA_MAX_SIZE = 5;\n+\n+    String TITLE_META_KEY         = \"title\";\n+    String PATH_META_KEY          = \"path\";\n+    String LENGTH_META_KEY        = \"length\";\n+    String CONTENT_TYPE_META_KEY  = \"contentType\";\n+    String MOD_DATE_META_KEY      = \"modDate\";\n+    String SHA226_META_KEY        = \"sha256\";\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczMzcwMg==", "bodyText": "I added the constants there and a TODO on the method that generates the Basic metadata", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505733702", "createdAt": "2020-10-15T17:57:08Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/FileStorageAPI.java", "diffHunk": "@@ -0,0 +1,84 @@\n+package com.dotcms.storage;\n+\n+import com.dotmarketing.util.Config;\n+\n+import java.io.File;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+\n+/**\n+ * This class is in charge of resolve File (on diff storages), metadata, etc.\n+ * @author jsanca\n+ */\n+public interface FileStorageAPI {\n+\n+    int SIZE                       = 1024;\n+    int DEFAULT_META_DATA_MAX_SIZE = 5;\n+\n+    String TITLE_META_KEY         = \"title\";\n+    String PATH_META_KEY          = \"path\";\n+    String LENGTH_META_KEY        = \"length\";\n+    String CONTENT_TYPE_META_KEY  = \"contentType\";\n+    String MOD_DATE_META_KEY      = \"modDate\";\n+    String SHA226_META_KEY        = \"sha256\";\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3MjIzNg=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzUwNDg4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/FileStorageAPIImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODo0NjoyMFrOHgJjdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxNzo0Mjo1NlrOHgyWdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3MzAxMw==", "bodyText": "Isn't treemap sorted already?", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503473013", "createdAt": "2020-10-12T18:46:20Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/FileStorageAPIImpl.java", "diffHunk": "@@ -0,0 +1,359 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.util.MimeTypeUtils;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSortedMap;\n+import io.vavr.control.Try;\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Default implementation\n+ *\n+ * @author jsanca\n+ */\n+public class FileStorageAPIImpl implements FileStorageAPI {\n+\n+    private static final String CACHE_GROUP = \"Contentlet\";\n+\n+    private volatile ObjectReaderDelegate objectReaderDelegate;\n+    private volatile ObjectWriterDelegate objectWriterDelegate;\n+    private volatile MetadataGenerator metadataGenerator;\n+    private final StoragePersistenceProvider persistenceProvider;\n+\n+    /**\n+     * Testing constructor\n+     * @param objectReaderDelegate\n+     * @param objectWriterDelegate\n+     * @param metadataGenerator\n+     * @param persistenceProvider\n+     */\n+    @VisibleForTesting\n+    FileStorageAPIImpl(final ObjectReaderDelegate objectReaderDelegate,\n+            final ObjectWriterDelegate objectWriterDelegate,\n+            final MetadataGenerator metadataGenerator,\n+            final StoragePersistenceProvider persistenceProvider) {\n+        this.objectReaderDelegate = objectReaderDelegate;\n+        this.objectWriterDelegate = objectWriterDelegate;\n+        this.metadataGenerator = metadataGenerator;\n+        this.persistenceProvider = persistenceProvider;\n+    }\n+\n+    /**\n+     * Default constructor\n+     */\n+    public FileStorageAPIImpl() {\n+        this(new JsonReaderDelegate<>(Map.class), new JsonWriterDelegate(),\n+                new TikaMetadataGenerator(), StoragePersistenceProvider.INSTANCE.get());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateRawBasicMetaData(final File binary) {\n+\n+        return this.generateBasicMetaData(binary, s -> true); // raw = no filter\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary  {@link File} file to get the information\n+     * @param maxLength {@link Long} max length is used when parse the content, how many bytes do you want to parse.\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateRawFullMetaData(final File binary, long maxLength) {\n+\n+        return this.generateFullMetaData(binary, s -> true, maxLength); // raw = no filter\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @param metaDataKeyFilter  {@link Predicate} filter the meta data key for the map result generation\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateBasicMetaData(final File binary,\n+            final Predicate<String> metaDataKeyFilter) {\n+\n+        final ImmutableSortedMap.Builder<String, Object> mapBuilder =\n+                new ImmutableSortedMap.Builder<>(Comparator.naturalOrder());\n+\n+        if (this.validBinary(binary)) {\n+\n+\n+            mapBuilder.put(TITLE_META_KEY, binary.getName());\n+\n+            final Optional<String> optional = FileUtil.getRealAssetsPathRelativePiece(binary);\n+            if (optional.isPresent()) {\n+                mapBuilder.put(PATH_META_KEY, optional.get());\n+            } else {\n+                Logger.warn(FileStorageAPIImpl.class, String.format(\n+                        \"Unable to determine relative path for asset `%s`. Using absolute path.\",\n+                        binary));\n+                mapBuilder.put(PATH_META_KEY, binary.getAbsolutePath());\n+            }\n+\n+            if (metaDataKeyFilter.test(LENGTH_META_KEY)) {\n+                mapBuilder.put(LENGTH_META_KEY, binary.length());\n+            }\n+\n+            if (metaDataKeyFilter.test(CONTENT_TYPE_META_KEY)) {\n+                mapBuilder.put(CONTENT_TYPE_META_KEY, MimeTypeUtils.getMimeType(binary));\n+            }\n+\n+            mapBuilder.put(MOD_DATE_META_KEY, System.currentTimeMillis());\n+            mapBuilder.put(SHA226_META_KEY,\n+                    Try.of(() -> FileUtil.sha256toUnixHash(binary)).getOrElse(\"unknown\"));\n+        }\n+\n+        return mapBuilder.build();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary  {@link File} file to get the information\n+     * @param metaDataKeyFilter  {@link Predicate} filter for the map result generation\n+     * @param maxLength {@link Long} max length is used when parse the content, how many bytes do you want to parse.\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateFullMetaData(final File binary,\n+            final Predicate<String> metaDataKeyFilter,\n+            final long maxLength) {\n+\n+        final TreeMap<String, Object> metadataMap = new TreeMap<>(Comparator.naturalOrder());\n+\n+        try {\n+            final Map<String, Object> fullMetaDataMap = this.metadataGenerator.generate(binary, maxLength);\n+            if (UtilMethods.isSet(fullMetaDataMap)) {\n+                for (final Map.Entry<String, Object> entry : fullMetaDataMap.entrySet()) {\n+                    if (metaDataKeyFilter.test(entry.getKey())) {\n+                        metadataMap.put(entry.getKey(), entry.getValue());\n+                    }\n+                }\n+            }\n+            //basic meta data should override any previous value that might have exist already.\n+            metadataMap.putAll(this.generateBasicMetaData(binary, metaDataKeyFilter));\n+        } catch (Exception e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            return Collections.emptyMap();\n+        }\n+\n+        return new ImmutableSortedMap.Builder<String, Object>(Comparator.naturalOrder())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE0MTQzMA==", "bodyText": "Probably there to guarantee that the immutable copy is sorted.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r504141430", "createdAt": "2020-10-13T17:42:56Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/FileStorageAPIImpl.java", "diffHunk": "@@ -0,0 +1,359 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.util.MimeTypeUtils;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSortedMap;\n+import io.vavr.control.Try;\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Default implementation\n+ *\n+ * @author jsanca\n+ */\n+public class FileStorageAPIImpl implements FileStorageAPI {\n+\n+    private static final String CACHE_GROUP = \"Contentlet\";\n+\n+    private volatile ObjectReaderDelegate objectReaderDelegate;\n+    private volatile ObjectWriterDelegate objectWriterDelegate;\n+    private volatile MetadataGenerator metadataGenerator;\n+    private final StoragePersistenceProvider persistenceProvider;\n+\n+    /**\n+     * Testing constructor\n+     * @param objectReaderDelegate\n+     * @param objectWriterDelegate\n+     * @param metadataGenerator\n+     * @param persistenceProvider\n+     */\n+    @VisibleForTesting\n+    FileStorageAPIImpl(final ObjectReaderDelegate objectReaderDelegate,\n+            final ObjectWriterDelegate objectWriterDelegate,\n+            final MetadataGenerator metadataGenerator,\n+            final StoragePersistenceProvider persistenceProvider) {\n+        this.objectReaderDelegate = objectReaderDelegate;\n+        this.objectWriterDelegate = objectWriterDelegate;\n+        this.metadataGenerator = metadataGenerator;\n+        this.persistenceProvider = persistenceProvider;\n+    }\n+\n+    /**\n+     * Default constructor\n+     */\n+    public FileStorageAPIImpl() {\n+        this(new JsonReaderDelegate<>(Map.class), new JsonWriterDelegate(),\n+                new TikaMetadataGenerator(), StoragePersistenceProvider.INSTANCE.get());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateRawBasicMetaData(final File binary) {\n+\n+        return this.generateBasicMetaData(binary, s -> true); // raw = no filter\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary  {@link File} file to get the information\n+     * @param maxLength {@link Long} max length is used when parse the content, how many bytes do you want to parse.\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateRawFullMetaData(final File binary, long maxLength) {\n+\n+        return this.generateFullMetaData(binary, s -> true, maxLength); // raw = no filter\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @param metaDataKeyFilter  {@link Predicate} filter the meta data key for the map result generation\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateBasicMetaData(final File binary,\n+            final Predicate<String> metaDataKeyFilter) {\n+\n+        final ImmutableSortedMap.Builder<String, Object> mapBuilder =\n+                new ImmutableSortedMap.Builder<>(Comparator.naturalOrder());\n+\n+        if (this.validBinary(binary)) {\n+\n+\n+            mapBuilder.put(TITLE_META_KEY, binary.getName());\n+\n+            final Optional<String> optional = FileUtil.getRealAssetsPathRelativePiece(binary);\n+            if (optional.isPresent()) {\n+                mapBuilder.put(PATH_META_KEY, optional.get());\n+            } else {\n+                Logger.warn(FileStorageAPIImpl.class, String.format(\n+                        \"Unable to determine relative path for asset `%s`. Using absolute path.\",\n+                        binary));\n+                mapBuilder.put(PATH_META_KEY, binary.getAbsolutePath());\n+            }\n+\n+            if (metaDataKeyFilter.test(LENGTH_META_KEY)) {\n+                mapBuilder.put(LENGTH_META_KEY, binary.length());\n+            }\n+\n+            if (metaDataKeyFilter.test(CONTENT_TYPE_META_KEY)) {\n+                mapBuilder.put(CONTENT_TYPE_META_KEY, MimeTypeUtils.getMimeType(binary));\n+            }\n+\n+            mapBuilder.put(MOD_DATE_META_KEY, System.currentTimeMillis());\n+            mapBuilder.put(SHA226_META_KEY,\n+                    Try.of(() -> FileUtil.sha256toUnixHash(binary)).getOrElse(\"unknown\"));\n+        }\n+\n+        return mapBuilder.build();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary  {@link File} file to get the information\n+     * @param metaDataKeyFilter  {@link Predicate} filter for the map result generation\n+     * @param maxLength {@link Long} max length is used when parse the content, how many bytes do you want to parse.\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateFullMetaData(final File binary,\n+            final Predicate<String> metaDataKeyFilter,\n+            final long maxLength) {\n+\n+        final TreeMap<String, Object> metadataMap = new TreeMap<>(Comparator.naturalOrder());\n+\n+        try {\n+            final Map<String, Object> fullMetaDataMap = this.metadataGenerator.generate(binary, maxLength);\n+            if (UtilMethods.isSet(fullMetaDataMap)) {\n+                for (final Map.Entry<String, Object> entry : fullMetaDataMap.entrySet()) {\n+                    if (metaDataKeyFilter.test(entry.getKey())) {\n+                        metadataMap.put(entry.getKey(), entry.getValue());\n+                    }\n+                }\n+            }\n+            //basic meta data should override any previous value that might have exist already.\n+            metadataMap.putAll(this.generateBasicMetaData(binary, metaDataKeyFilter));\n+        } catch (Exception e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            return Collections.emptyMap();\n+        }\n+\n+        return new ImmutableSortedMap.Builder<String, Object>(Comparator.naturalOrder())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3MzAxMw=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzUyMDQzOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/FileStorageAPIImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODo1MTozN1rOHgJsbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzo1NjowNVrOHiTf4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3NTMxMA==", "bodyText": "Should this throw?", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503475310", "createdAt": "2020-10-12T18:51:37Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/FileStorageAPIImpl.java", "diffHunk": "@@ -0,0 +1,359 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.util.MimeTypeUtils;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSortedMap;\n+import io.vavr.control.Try;\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Default implementation\n+ *\n+ * @author jsanca\n+ */\n+public class FileStorageAPIImpl implements FileStorageAPI {\n+\n+    private static final String CACHE_GROUP = \"Contentlet\";\n+\n+    private volatile ObjectReaderDelegate objectReaderDelegate;\n+    private volatile ObjectWriterDelegate objectWriterDelegate;\n+    private volatile MetadataGenerator metadataGenerator;\n+    private final StoragePersistenceProvider persistenceProvider;\n+\n+    /**\n+     * Testing constructor\n+     * @param objectReaderDelegate\n+     * @param objectWriterDelegate\n+     * @param metadataGenerator\n+     * @param persistenceProvider\n+     */\n+    @VisibleForTesting\n+    FileStorageAPIImpl(final ObjectReaderDelegate objectReaderDelegate,\n+            final ObjectWriterDelegate objectWriterDelegate,\n+            final MetadataGenerator metadataGenerator,\n+            final StoragePersistenceProvider persistenceProvider) {\n+        this.objectReaderDelegate = objectReaderDelegate;\n+        this.objectWriterDelegate = objectWriterDelegate;\n+        this.metadataGenerator = metadataGenerator;\n+        this.persistenceProvider = persistenceProvider;\n+    }\n+\n+    /**\n+     * Default constructor\n+     */\n+    public FileStorageAPIImpl() {\n+        this(new JsonReaderDelegate<>(Map.class), new JsonWriterDelegate(),\n+                new TikaMetadataGenerator(), StoragePersistenceProvider.INSTANCE.get());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateRawBasicMetaData(final File binary) {\n+\n+        return this.generateBasicMetaData(binary, s -> true); // raw = no filter\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary  {@link File} file to get the information\n+     * @param maxLength {@link Long} max length is used when parse the content, how many bytes do you want to parse.\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateRawFullMetaData(final File binary, long maxLength) {\n+\n+        return this.generateFullMetaData(binary, s -> true, maxLength); // raw = no filter\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @param metaDataKeyFilter  {@link Predicate} filter the meta data key for the map result generation\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateBasicMetaData(final File binary,\n+            final Predicate<String> metaDataKeyFilter) {\n+\n+        final ImmutableSortedMap.Builder<String, Object> mapBuilder =\n+                new ImmutableSortedMap.Builder<>(Comparator.naturalOrder());\n+\n+        if (this.validBinary(binary)) {\n+\n+\n+            mapBuilder.put(TITLE_META_KEY, binary.getName());\n+\n+            final Optional<String> optional = FileUtil.getRealAssetsPathRelativePiece(binary);\n+            if (optional.isPresent()) {\n+                mapBuilder.put(PATH_META_KEY, optional.get());\n+            } else {\n+                Logger.warn(FileStorageAPIImpl.class, String.format(\n+                        \"Unable to determine relative path for asset `%s`. Using absolute path.\",\n+                        binary));\n+                mapBuilder.put(PATH_META_KEY, binary.getAbsolutePath());\n+            }\n+\n+            if (metaDataKeyFilter.test(LENGTH_META_KEY)) {\n+                mapBuilder.put(LENGTH_META_KEY, binary.length());\n+            }\n+\n+            if (metaDataKeyFilter.test(CONTENT_TYPE_META_KEY)) {\n+                mapBuilder.put(CONTENT_TYPE_META_KEY, MimeTypeUtils.getMimeType(binary));\n+            }\n+\n+            mapBuilder.put(MOD_DATE_META_KEY, System.currentTimeMillis());\n+            mapBuilder.put(SHA226_META_KEY,\n+                    Try.of(() -> FileUtil.sha256toUnixHash(binary)).getOrElse(\"unknown\"));\n+        }\n+\n+        return mapBuilder.build();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary  {@link File} file to get the information\n+     * @param metaDataKeyFilter  {@link Predicate} filter for the map result generation\n+     * @param maxLength {@link Long} max length is used when parse the content, how many bytes do you want to parse.\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateFullMetaData(final File binary,\n+            final Predicate<String> metaDataKeyFilter,\n+            final long maxLength) {\n+\n+        final TreeMap<String, Object> metadataMap = new TreeMap<>(Comparator.naturalOrder());\n+\n+        try {\n+            final Map<String, Object> fullMetaDataMap = this.metadataGenerator.generate(binary, maxLength);\n+            if (UtilMethods.isSet(fullMetaDataMap)) {\n+                for (final Map.Entry<String, Object> entry : fullMetaDataMap.entrySet()) {\n+                    if (metaDataKeyFilter.test(entry.getKey())) {\n+                        metadataMap.put(entry.getKey(), entry.getValue());\n+                    }\n+                }\n+            }\n+            //basic meta data should override any previous value that might have exist already.\n+            metadataMap.putAll(this.generateBasicMetaData(binary, metaDataKeyFilter));\n+        } catch (Exception e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            return Collections.emptyMap();\n+        }\n+\n+        return new ImmutableSortedMap.Builder<String, Object>(Comparator.naturalOrder())\n+                .putAll(metadataMap).build();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @param configuration {@link GenerateMetadataConfig}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateMetaData(final File binary,\n+            final GenerateMetadataConfig configuration) {\n+\n+        final Map<String, Object> metadataMap;\n+        final StorageKey storageKey = configuration.getStorageKey();\n+        final StoragePersistenceAPI storage = persistenceProvider.getStorage(storageKey.getStorage());\n+\n+        this.checkBucket(storageKey, storage);  //if the group/bucket doesn't exist create it.\n+        this.checkOverride(storage, configuration); //if config states we need to remove and force regen\n+        //if the entry isn't already there skip and simply store in cache.\n+        if (!storage.existsObject(storageKey.getGroup(), storageKey.getPath())) {\n+            if (this.validBinary(binary)) {\n+                Logger.warn(FileStorageAPIImpl.class, String.format(\n+                        \"Object identified by `/%s/%s` didn't exist in storage %s will be generated.\",\n+                        storageKey.getGroup(), storageKey,\n+                        configuration.isFull() ? \"full-metadata\" : \"basic-metadata\"));\n+                final long maxLength = configuration.getMaxLength();\n+                metadataMap = configuration.isFull() ?\n+                        this.generateFullMetaData(binary,\n+                                configuration.getMetaDataKeyFilter(), maxLength) :\n+                        this.generateBasicMetaData(binary,\n+                                configuration.getMetaDataKeyFilter());\n+\n+                if (configuration.isStore()) {\n+                    this.storeMetadata(storageKey, storage, metadataMap);\n+                }\n+\n+            } else {\n+               throw new IllegalArgumentException(String.format(\"the binary `%s` isn't accessible \", binary != null ? binary.getName() : \"unknown\"));\n+            }\n+        } else {\n+            metadataMap = this.retrieveMetadata(storageKey, storage);\n+        }\n+\n+        if (configuration.isCache()) {\n+\n+            this.putIntoCache(configuration.getCacheKeySupplier().get(),\n+                    metadataMap);\n+        }\n+\n+        return metadataMap;\n+    }\n+\n+    /**\n+     * Group existence verifier\n+     * @param storageKey\n+     * @param storage\n+     */\n+    private void checkBucket(final StorageKey storageKey, final StoragePersistenceAPI storage) {\n+        if (!storage.existsGroup(storageKey.getGroup())) {\n+            storage.createGroup(storageKey.getGroup());\n+        }\n+    }\n+\n+    /**\n+     * save into cache\n+     * @param cacheKey\n+     * @param metadataMap\n+     */\n+    private void putIntoCache(final String cacheKey, final Map<String, Object> metadataMap) {\n+\n+        final DotCacheAdministrator cacheAdmin = CacheLocator.getCacheAdministrator();\n+        if (null != cacheAdmin) {\n+\n+            cacheAdmin.put(cacheKey,\n+                    metadataMap, CACHE_GROUP);\n+        }\n+    }\n+\n+    /**\n+     * meta-data retriever\n+     * @param storageKey\n+     * @param storage\n+     * @return\n+     */\n+    private Map<String, Object> retrieveMetadata(final StorageKey storageKey,\n+            final StoragePersistenceAPI storage) {\n+\n+        Map<String, Object> objectMap = Collections.emptyMap();\n+\n+        try {\n+            objectMap = (Map<String, Object>) storage.pullObject(storageKey.getGroup(), storageKey.getPath(), this.objectReaderDelegate);\n+            Logger.info(this, \"Metadata read from: \" + storageKey.getPath());\n+        } catch (Exception e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+        }\n+\n+        return objectMap;\n+    }\n+\n+    /**\n+     * sends metadata to the respective configured storage\n+     * @param storageKey\n+     * @param storage\n+     * @param metadataMap\n+     */\n+    private void storeMetadata(final StorageKey storageKey, final StoragePersistenceAPI storage,\n+            final Map<String, Object> metadataMap) {\n+\n+        try {\n+            storage.pushObject(storageKey.getGroup(), storageKey.getPath(),\n+                    this.objectWriterDelegate, (Serializable) metadataMap, metadataMap);\n+            Logger.info(this, \"Metadata wrote on: \" + storageKey.getPath());\n+        } catch (Exception e) {\n+            Logger.error(this, e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczMzA5MA==", "bodyText": "now it does.. the exception is bubbled up", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505733090", "createdAt": "2020-10-15T17:56:05Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/FileStorageAPIImpl.java", "diffHunk": "@@ -0,0 +1,359 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.util.MimeTypeUtils;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSortedMap;\n+import io.vavr.control.Try;\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Default implementation\n+ *\n+ * @author jsanca\n+ */\n+public class FileStorageAPIImpl implements FileStorageAPI {\n+\n+    private static final String CACHE_GROUP = \"Contentlet\";\n+\n+    private volatile ObjectReaderDelegate objectReaderDelegate;\n+    private volatile ObjectWriterDelegate objectWriterDelegate;\n+    private volatile MetadataGenerator metadataGenerator;\n+    private final StoragePersistenceProvider persistenceProvider;\n+\n+    /**\n+     * Testing constructor\n+     * @param objectReaderDelegate\n+     * @param objectWriterDelegate\n+     * @param metadataGenerator\n+     * @param persistenceProvider\n+     */\n+    @VisibleForTesting\n+    FileStorageAPIImpl(final ObjectReaderDelegate objectReaderDelegate,\n+            final ObjectWriterDelegate objectWriterDelegate,\n+            final MetadataGenerator metadataGenerator,\n+            final StoragePersistenceProvider persistenceProvider) {\n+        this.objectReaderDelegate = objectReaderDelegate;\n+        this.objectWriterDelegate = objectWriterDelegate;\n+        this.metadataGenerator = metadataGenerator;\n+        this.persistenceProvider = persistenceProvider;\n+    }\n+\n+    /**\n+     * Default constructor\n+     */\n+    public FileStorageAPIImpl() {\n+        this(new JsonReaderDelegate<>(Map.class), new JsonWriterDelegate(),\n+                new TikaMetadataGenerator(), StoragePersistenceProvider.INSTANCE.get());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateRawBasicMetaData(final File binary) {\n+\n+        return this.generateBasicMetaData(binary, s -> true); // raw = no filter\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary  {@link File} file to get the information\n+     * @param maxLength {@link Long} max length is used when parse the content, how many bytes do you want to parse.\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateRawFullMetaData(final File binary, long maxLength) {\n+\n+        return this.generateFullMetaData(binary, s -> true, maxLength); // raw = no filter\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @param metaDataKeyFilter  {@link Predicate} filter the meta data key for the map result generation\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateBasicMetaData(final File binary,\n+            final Predicate<String> metaDataKeyFilter) {\n+\n+        final ImmutableSortedMap.Builder<String, Object> mapBuilder =\n+                new ImmutableSortedMap.Builder<>(Comparator.naturalOrder());\n+\n+        if (this.validBinary(binary)) {\n+\n+\n+            mapBuilder.put(TITLE_META_KEY, binary.getName());\n+\n+            final Optional<String> optional = FileUtil.getRealAssetsPathRelativePiece(binary);\n+            if (optional.isPresent()) {\n+                mapBuilder.put(PATH_META_KEY, optional.get());\n+            } else {\n+                Logger.warn(FileStorageAPIImpl.class, String.format(\n+                        \"Unable to determine relative path for asset `%s`. Using absolute path.\",\n+                        binary));\n+                mapBuilder.put(PATH_META_KEY, binary.getAbsolutePath());\n+            }\n+\n+            if (metaDataKeyFilter.test(LENGTH_META_KEY)) {\n+                mapBuilder.put(LENGTH_META_KEY, binary.length());\n+            }\n+\n+            if (metaDataKeyFilter.test(CONTENT_TYPE_META_KEY)) {\n+                mapBuilder.put(CONTENT_TYPE_META_KEY, MimeTypeUtils.getMimeType(binary));\n+            }\n+\n+            mapBuilder.put(MOD_DATE_META_KEY, System.currentTimeMillis());\n+            mapBuilder.put(SHA226_META_KEY,\n+                    Try.of(() -> FileUtil.sha256toUnixHash(binary)).getOrElse(\"unknown\"));\n+        }\n+\n+        return mapBuilder.build();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary  {@link File} file to get the information\n+     * @param metaDataKeyFilter  {@link Predicate} filter for the map result generation\n+     * @param maxLength {@link Long} max length is used when parse the content, how many bytes do you want to parse.\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateFullMetaData(final File binary,\n+            final Predicate<String> metaDataKeyFilter,\n+            final long maxLength) {\n+\n+        final TreeMap<String, Object> metadataMap = new TreeMap<>(Comparator.naturalOrder());\n+\n+        try {\n+            final Map<String, Object> fullMetaDataMap = this.metadataGenerator.generate(binary, maxLength);\n+            if (UtilMethods.isSet(fullMetaDataMap)) {\n+                for (final Map.Entry<String, Object> entry : fullMetaDataMap.entrySet()) {\n+                    if (metaDataKeyFilter.test(entry.getKey())) {\n+                        metadataMap.put(entry.getKey(), entry.getValue());\n+                    }\n+                }\n+            }\n+            //basic meta data should override any previous value that might have exist already.\n+            metadataMap.putAll(this.generateBasicMetaData(binary, metaDataKeyFilter));\n+        } catch (Exception e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            return Collections.emptyMap();\n+        }\n+\n+        return new ImmutableSortedMap.Builder<String, Object>(Comparator.naturalOrder())\n+                .putAll(metadataMap).build();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @param configuration {@link GenerateMetadataConfig}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateMetaData(final File binary,\n+            final GenerateMetadataConfig configuration) {\n+\n+        final Map<String, Object> metadataMap;\n+        final StorageKey storageKey = configuration.getStorageKey();\n+        final StoragePersistenceAPI storage = persistenceProvider.getStorage(storageKey.getStorage());\n+\n+        this.checkBucket(storageKey, storage);  //if the group/bucket doesn't exist create it.\n+        this.checkOverride(storage, configuration); //if config states we need to remove and force regen\n+        //if the entry isn't already there skip and simply store in cache.\n+        if (!storage.existsObject(storageKey.getGroup(), storageKey.getPath())) {\n+            if (this.validBinary(binary)) {\n+                Logger.warn(FileStorageAPIImpl.class, String.format(\n+                        \"Object identified by `/%s/%s` didn't exist in storage %s will be generated.\",\n+                        storageKey.getGroup(), storageKey,\n+                        configuration.isFull() ? \"full-metadata\" : \"basic-metadata\"));\n+                final long maxLength = configuration.getMaxLength();\n+                metadataMap = configuration.isFull() ?\n+                        this.generateFullMetaData(binary,\n+                                configuration.getMetaDataKeyFilter(), maxLength) :\n+                        this.generateBasicMetaData(binary,\n+                                configuration.getMetaDataKeyFilter());\n+\n+                if (configuration.isStore()) {\n+                    this.storeMetadata(storageKey, storage, metadataMap);\n+                }\n+\n+            } else {\n+               throw new IllegalArgumentException(String.format(\"the binary `%s` isn't accessible \", binary != null ? binary.getName() : \"unknown\"));\n+            }\n+        } else {\n+            metadataMap = this.retrieveMetadata(storageKey, storage);\n+        }\n+\n+        if (configuration.isCache()) {\n+\n+            this.putIntoCache(configuration.getCacheKeySupplier().get(),\n+                    metadataMap);\n+        }\n+\n+        return metadataMap;\n+    }\n+\n+    /**\n+     * Group existence verifier\n+     * @param storageKey\n+     * @param storage\n+     */\n+    private void checkBucket(final StorageKey storageKey, final StoragePersistenceAPI storage) {\n+        if (!storage.existsGroup(storageKey.getGroup())) {\n+            storage.createGroup(storageKey.getGroup());\n+        }\n+    }\n+\n+    /**\n+     * save into cache\n+     * @param cacheKey\n+     * @param metadataMap\n+     */\n+    private void putIntoCache(final String cacheKey, final Map<String, Object> metadataMap) {\n+\n+        final DotCacheAdministrator cacheAdmin = CacheLocator.getCacheAdministrator();\n+        if (null != cacheAdmin) {\n+\n+            cacheAdmin.put(cacheKey,\n+                    metadataMap, CACHE_GROUP);\n+        }\n+    }\n+\n+    /**\n+     * meta-data retriever\n+     * @param storageKey\n+     * @param storage\n+     * @return\n+     */\n+    private Map<String, Object> retrieveMetadata(final StorageKey storageKey,\n+            final StoragePersistenceAPI storage) {\n+\n+        Map<String, Object> objectMap = Collections.emptyMap();\n+\n+        try {\n+            objectMap = (Map<String, Object>) storage.pullObject(storageKey.getGroup(), storageKey.getPath(), this.objectReaderDelegate);\n+            Logger.info(this, \"Metadata read from: \" + storageKey.getPath());\n+        } catch (Exception e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+        }\n+\n+        return objectMap;\n+    }\n+\n+    /**\n+     * sends metadata to the respective configured storage\n+     * @param storageKey\n+     * @param storage\n+     * @param metadataMap\n+     */\n+    private void storeMetadata(final StorageKey storageKey, final StoragePersistenceAPI storage,\n+            final Map<String, Object> metadataMap) {\n+\n+        try {\n+            storage.pushObject(storageKey.getGroup(), storageKey.getPath(),\n+                    this.objectWriterDelegate, (Serializable) metadataMap, metadataMap);\n+            Logger.info(this, \"Metadata wrote on: \" + storageKey.getPath());\n+        } catch (Exception e) {\n+            Logger.error(this, e.getMessage(), e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3NTMxMA=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 275}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzUyNjYwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/FileStorageAPIImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODo1Mzo1MFrOHgJwHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzo1NTozNlrOHiTexA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3NjI1Mg==", "bodyText": "I would return metadataMap here - no reason for a big fat nested  \"if/else\"", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503476252", "createdAt": "2020-10-12T18:53:50Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/FileStorageAPIImpl.java", "diffHunk": "@@ -0,0 +1,359 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.util.MimeTypeUtils;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSortedMap;\n+import io.vavr.control.Try;\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Default implementation\n+ *\n+ * @author jsanca\n+ */\n+public class FileStorageAPIImpl implements FileStorageAPI {\n+\n+    private static final String CACHE_GROUP = \"Contentlet\";\n+\n+    private volatile ObjectReaderDelegate objectReaderDelegate;\n+    private volatile ObjectWriterDelegate objectWriterDelegate;\n+    private volatile MetadataGenerator metadataGenerator;\n+    private final StoragePersistenceProvider persistenceProvider;\n+\n+    /**\n+     * Testing constructor\n+     * @param objectReaderDelegate\n+     * @param objectWriterDelegate\n+     * @param metadataGenerator\n+     * @param persistenceProvider\n+     */\n+    @VisibleForTesting\n+    FileStorageAPIImpl(final ObjectReaderDelegate objectReaderDelegate,\n+            final ObjectWriterDelegate objectWriterDelegate,\n+            final MetadataGenerator metadataGenerator,\n+            final StoragePersistenceProvider persistenceProvider) {\n+        this.objectReaderDelegate = objectReaderDelegate;\n+        this.objectWriterDelegate = objectWriterDelegate;\n+        this.metadataGenerator = metadataGenerator;\n+        this.persistenceProvider = persistenceProvider;\n+    }\n+\n+    /**\n+     * Default constructor\n+     */\n+    public FileStorageAPIImpl() {\n+        this(new JsonReaderDelegate<>(Map.class), new JsonWriterDelegate(),\n+                new TikaMetadataGenerator(), StoragePersistenceProvider.INSTANCE.get());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateRawBasicMetaData(final File binary) {\n+\n+        return this.generateBasicMetaData(binary, s -> true); // raw = no filter\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary  {@link File} file to get the information\n+     * @param maxLength {@link Long} max length is used when parse the content, how many bytes do you want to parse.\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateRawFullMetaData(final File binary, long maxLength) {\n+\n+        return this.generateFullMetaData(binary, s -> true, maxLength); // raw = no filter\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @param metaDataKeyFilter  {@link Predicate} filter the meta data key for the map result generation\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateBasicMetaData(final File binary,\n+            final Predicate<String> metaDataKeyFilter) {\n+\n+        final ImmutableSortedMap.Builder<String, Object> mapBuilder =\n+                new ImmutableSortedMap.Builder<>(Comparator.naturalOrder());\n+\n+        if (this.validBinary(binary)) {\n+\n+\n+            mapBuilder.put(TITLE_META_KEY, binary.getName());\n+\n+            final Optional<String> optional = FileUtil.getRealAssetsPathRelativePiece(binary);\n+            if (optional.isPresent()) {\n+                mapBuilder.put(PATH_META_KEY, optional.get());\n+            } else {\n+                Logger.warn(FileStorageAPIImpl.class, String.format(\n+                        \"Unable to determine relative path for asset `%s`. Using absolute path.\",\n+                        binary));\n+                mapBuilder.put(PATH_META_KEY, binary.getAbsolutePath());\n+            }\n+\n+            if (metaDataKeyFilter.test(LENGTH_META_KEY)) {\n+                mapBuilder.put(LENGTH_META_KEY, binary.length());\n+            }\n+\n+            if (metaDataKeyFilter.test(CONTENT_TYPE_META_KEY)) {\n+                mapBuilder.put(CONTENT_TYPE_META_KEY, MimeTypeUtils.getMimeType(binary));\n+            }\n+\n+            mapBuilder.put(MOD_DATE_META_KEY, System.currentTimeMillis());\n+            mapBuilder.put(SHA226_META_KEY,\n+                    Try.of(() -> FileUtil.sha256toUnixHash(binary)).getOrElse(\"unknown\"));\n+        }\n+\n+        return mapBuilder.build();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary  {@link File} file to get the information\n+     * @param metaDataKeyFilter  {@link Predicate} filter for the map result generation\n+     * @param maxLength {@link Long} max length is used when parse the content, how many bytes do you want to parse.\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateFullMetaData(final File binary,\n+            final Predicate<String> metaDataKeyFilter,\n+            final long maxLength) {\n+\n+        final TreeMap<String, Object> metadataMap = new TreeMap<>(Comparator.naturalOrder());\n+\n+        try {\n+            final Map<String, Object> fullMetaDataMap = this.metadataGenerator.generate(binary, maxLength);\n+            if (UtilMethods.isSet(fullMetaDataMap)) {\n+                for (final Map.Entry<String, Object> entry : fullMetaDataMap.entrySet()) {\n+                    if (metaDataKeyFilter.test(entry.getKey())) {\n+                        metadataMap.put(entry.getKey(), entry.getValue());\n+                    }\n+                }\n+            }\n+            //basic meta data should override any previous value that might have exist already.\n+            metadataMap.putAll(this.generateBasicMetaData(binary, metaDataKeyFilter));\n+        } catch (Exception e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            return Collections.emptyMap();\n+        }\n+\n+        return new ImmutableSortedMap.Builder<String, Object>(Comparator.naturalOrder())\n+                .putAll(metadataMap).build();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @param configuration {@link GenerateMetadataConfig}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateMetaData(final File binary,\n+            final GenerateMetadataConfig configuration) {\n+\n+        final Map<String, Object> metadataMap;\n+        final StorageKey storageKey = configuration.getStorageKey();\n+        final StoragePersistenceAPI storage = persistenceProvider.getStorage(storageKey.getStorage());\n+\n+        this.checkBucket(storageKey, storage);  //if the group/bucket doesn't exist create it.\n+        this.checkOverride(storage, configuration); //if config states we need to remove and force regen\n+        //if the entry isn't already there skip and simply store in cache.\n+        if (!storage.existsObject(storageKey.getGroup(), storageKey.getPath())) {\n+            if (this.validBinary(binary)) {\n+                Logger.warn(FileStorageAPIImpl.class, String.format(\n+                        \"Object identified by `/%s/%s` didn't exist in storage %s will be generated.\",\n+                        storageKey.getGroup(), storageKey,\n+                        configuration.isFull() ? \"full-metadata\" : \"basic-metadata\"));\n+                final long maxLength = configuration.getMaxLength();\n+                metadataMap = configuration.isFull() ?\n+                        this.generateFullMetaData(binary,\n+                                configuration.getMetaDataKeyFilter(), maxLength) :\n+                        this.generateBasicMetaData(binary,\n+                                configuration.getMetaDataKeyFilter());\n+\n+                if (configuration.isStore()) {\n+                    this.storeMetadata(storageKey, storage, metadataMap);\n+                }\n+\n+            } else {\n+               throw new IllegalArgumentException(String.format(\"the binary `%s` isn't accessible \", binary != null ? binary.getName() : \"unknown\"));\n+            }\n+        } else {\n+            metadataMap = this.retrieveMetadata(storageKey, storage);\n+        }\n+\n+        if (configuration.isCache()) {\n+\n+            this.putIntoCache(configuration.getCacheKeySupplier().get(),\n+                    metadataMap);\n+        }\n+\n+        return metadataMap;\n+    }\n+\n+    /**\n+     * Group existence verifier\n+     * @param storageKey\n+     * @param storage\n+     */\n+    private void checkBucket(final StorageKey storageKey, final StoragePersistenceAPI storage) {\n+        if (!storage.existsGroup(storageKey.getGroup())) {\n+            storage.createGroup(storageKey.getGroup());\n+        }\n+    }\n+\n+    /**\n+     * save into cache\n+     * @param cacheKey\n+     * @param metadataMap\n+     */\n+    private void putIntoCache(final String cacheKey, final Map<String, Object> metadataMap) {\n+\n+        final DotCacheAdministrator cacheAdmin = CacheLocator.getCacheAdministrator();\n+        if (null != cacheAdmin) {\n+\n+            cacheAdmin.put(cacheKey,\n+                    metadataMap, CACHE_GROUP);\n+        }\n+    }\n+\n+    /**\n+     * meta-data retriever\n+     * @param storageKey\n+     * @param storage\n+     * @return\n+     */\n+    private Map<String, Object> retrieveMetadata(final StorageKey storageKey,\n+            final StoragePersistenceAPI storage) {\n+\n+        Map<String, Object> objectMap = Collections.emptyMap();\n+\n+        try {\n+            objectMap = (Map<String, Object>) storage.pullObject(storageKey.getGroup(), storageKey.getPath(), this.objectReaderDelegate);\n+            Logger.info(this, \"Metadata read from: \" + storageKey.getPath());\n+        } catch (Exception e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+        }\n+\n+        return objectMap;\n+    }\n+\n+    /**\n+     * sends metadata to the respective configured storage\n+     * @param storageKey\n+     * @param storage\n+     * @param metadataMap\n+     */\n+    private void storeMetadata(final StorageKey storageKey, final StoragePersistenceAPI storage,\n+            final Map<String, Object> metadataMap) {\n+\n+        try {\n+            storage.pushObject(storageKey.getGroup(), storageKey.getPath(),\n+                    this.objectWriterDelegate, (Serializable) metadataMap, metadataMap);\n+            Logger.info(this, \"Metadata wrote on: \" + storageKey.getPath());\n+        } catch (Exception e) {\n+            Logger.error(this, e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Check's file is readable and valid\n+     * @param binary\n+     * @return\n+     */\n+    private boolean validBinary(final File binary) {\n+\n+        return null != binary && binary.exists() && binary.canRead();\n+    }\n+\n+    /**\n+     * if the given configuration states we must override the previously existing file will be deleted before re-generating.\n+     * @param storage\n+     * @param generateMetaDataConfiguration\n+     */\n+    private void checkOverride(final StoragePersistenceAPI storage,\n+            final GenerateMetadataConfig generateMetaDataConfiguration) {\n+\n+        final StorageKey storageKey = generateMetaDataConfiguration.getStorageKey();\n+        if (generateMetaDataConfiguration.isOverride() && storage\n+                .existsObject(storageKey.getGroup(), storageKey.getPath())) {\n+\n+            try {\n+\n+                storage.deleteObject(storageKey.getGroup(), storageKey.getPath());\n+            } catch (Exception e) {\n+\n+                Logger.error(this.getClass(),\n+                        String.format(\"Unable to delete existing metadata file [%s] [%s]\",\n+                                storageKey.getPath(), e.getMessage()), e);\n+            }\n+        }\n+    } // checkOverride.\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param requestMetaData {@link RequestMetadata}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> retrieveMetaData(final RequestMetadata requestMetaData) {\n+\n+        Map<String, Object> metadataMap = Collections.emptyMap();\n+\n+        if (requestMetaData.isCache()) {\n+\n+            final DotCacheAdministrator cacheAdmin = CacheLocator.getCacheAdministrator();\n+            if (null != cacheAdmin) {\n+\n+                metadataMap = Try.of(() -> (Map<String, Object>) cacheAdmin\n+                        .get(requestMetaData.getCacheKeySupplier().get(),\n+                                CACHE_GROUP)).getOrElse(Collections.emptyMap());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE2NDc3NA==", "bodyText": "there is a cacheAdmin.getNoThrow(key, group) that returns a null if it is not in cache.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r504164774", "createdAt": "2020-10-13T18:18:04Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/FileStorageAPIImpl.java", "diffHunk": "@@ -0,0 +1,359 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.util.MimeTypeUtils;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSortedMap;\n+import io.vavr.control.Try;\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Default implementation\n+ *\n+ * @author jsanca\n+ */\n+public class FileStorageAPIImpl implements FileStorageAPI {\n+\n+    private static final String CACHE_GROUP = \"Contentlet\";\n+\n+    private volatile ObjectReaderDelegate objectReaderDelegate;\n+    private volatile ObjectWriterDelegate objectWriterDelegate;\n+    private volatile MetadataGenerator metadataGenerator;\n+    private final StoragePersistenceProvider persistenceProvider;\n+\n+    /**\n+     * Testing constructor\n+     * @param objectReaderDelegate\n+     * @param objectWriterDelegate\n+     * @param metadataGenerator\n+     * @param persistenceProvider\n+     */\n+    @VisibleForTesting\n+    FileStorageAPIImpl(final ObjectReaderDelegate objectReaderDelegate,\n+            final ObjectWriterDelegate objectWriterDelegate,\n+            final MetadataGenerator metadataGenerator,\n+            final StoragePersistenceProvider persistenceProvider) {\n+        this.objectReaderDelegate = objectReaderDelegate;\n+        this.objectWriterDelegate = objectWriterDelegate;\n+        this.metadataGenerator = metadataGenerator;\n+        this.persistenceProvider = persistenceProvider;\n+    }\n+\n+    /**\n+     * Default constructor\n+     */\n+    public FileStorageAPIImpl() {\n+        this(new JsonReaderDelegate<>(Map.class), new JsonWriterDelegate(),\n+                new TikaMetadataGenerator(), StoragePersistenceProvider.INSTANCE.get());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateRawBasicMetaData(final File binary) {\n+\n+        return this.generateBasicMetaData(binary, s -> true); // raw = no filter\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary  {@link File} file to get the information\n+     * @param maxLength {@link Long} max length is used when parse the content, how many bytes do you want to parse.\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateRawFullMetaData(final File binary, long maxLength) {\n+\n+        return this.generateFullMetaData(binary, s -> true, maxLength); // raw = no filter\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @param metaDataKeyFilter  {@link Predicate} filter the meta data key for the map result generation\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateBasicMetaData(final File binary,\n+            final Predicate<String> metaDataKeyFilter) {\n+\n+        final ImmutableSortedMap.Builder<String, Object> mapBuilder =\n+                new ImmutableSortedMap.Builder<>(Comparator.naturalOrder());\n+\n+        if (this.validBinary(binary)) {\n+\n+\n+            mapBuilder.put(TITLE_META_KEY, binary.getName());\n+\n+            final Optional<String> optional = FileUtil.getRealAssetsPathRelativePiece(binary);\n+            if (optional.isPresent()) {\n+                mapBuilder.put(PATH_META_KEY, optional.get());\n+            } else {\n+                Logger.warn(FileStorageAPIImpl.class, String.format(\n+                        \"Unable to determine relative path for asset `%s`. Using absolute path.\",\n+                        binary));\n+                mapBuilder.put(PATH_META_KEY, binary.getAbsolutePath());\n+            }\n+\n+            if (metaDataKeyFilter.test(LENGTH_META_KEY)) {\n+                mapBuilder.put(LENGTH_META_KEY, binary.length());\n+            }\n+\n+            if (metaDataKeyFilter.test(CONTENT_TYPE_META_KEY)) {\n+                mapBuilder.put(CONTENT_TYPE_META_KEY, MimeTypeUtils.getMimeType(binary));\n+            }\n+\n+            mapBuilder.put(MOD_DATE_META_KEY, System.currentTimeMillis());\n+            mapBuilder.put(SHA226_META_KEY,\n+                    Try.of(() -> FileUtil.sha256toUnixHash(binary)).getOrElse(\"unknown\"));\n+        }\n+\n+        return mapBuilder.build();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary  {@link File} file to get the information\n+     * @param metaDataKeyFilter  {@link Predicate} filter for the map result generation\n+     * @param maxLength {@link Long} max length is used when parse the content, how many bytes do you want to parse.\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateFullMetaData(final File binary,\n+            final Predicate<String> metaDataKeyFilter,\n+            final long maxLength) {\n+\n+        final TreeMap<String, Object> metadataMap = new TreeMap<>(Comparator.naturalOrder());\n+\n+        try {\n+            final Map<String, Object> fullMetaDataMap = this.metadataGenerator.generate(binary, maxLength);\n+            if (UtilMethods.isSet(fullMetaDataMap)) {\n+                for (final Map.Entry<String, Object> entry : fullMetaDataMap.entrySet()) {\n+                    if (metaDataKeyFilter.test(entry.getKey())) {\n+                        metadataMap.put(entry.getKey(), entry.getValue());\n+                    }\n+                }\n+            }\n+            //basic meta data should override any previous value that might have exist already.\n+            metadataMap.putAll(this.generateBasicMetaData(binary, metaDataKeyFilter));\n+        } catch (Exception e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            return Collections.emptyMap();\n+        }\n+\n+        return new ImmutableSortedMap.Builder<String, Object>(Comparator.naturalOrder())\n+                .putAll(metadataMap).build();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @param configuration {@link GenerateMetadataConfig}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateMetaData(final File binary,\n+            final GenerateMetadataConfig configuration) {\n+\n+        final Map<String, Object> metadataMap;\n+        final StorageKey storageKey = configuration.getStorageKey();\n+        final StoragePersistenceAPI storage = persistenceProvider.getStorage(storageKey.getStorage());\n+\n+        this.checkBucket(storageKey, storage);  //if the group/bucket doesn't exist create it.\n+        this.checkOverride(storage, configuration); //if config states we need to remove and force regen\n+        //if the entry isn't already there skip and simply store in cache.\n+        if (!storage.existsObject(storageKey.getGroup(), storageKey.getPath())) {\n+            if (this.validBinary(binary)) {\n+                Logger.warn(FileStorageAPIImpl.class, String.format(\n+                        \"Object identified by `/%s/%s` didn't exist in storage %s will be generated.\",\n+                        storageKey.getGroup(), storageKey,\n+                        configuration.isFull() ? \"full-metadata\" : \"basic-metadata\"));\n+                final long maxLength = configuration.getMaxLength();\n+                metadataMap = configuration.isFull() ?\n+                        this.generateFullMetaData(binary,\n+                                configuration.getMetaDataKeyFilter(), maxLength) :\n+                        this.generateBasicMetaData(binary,\n+                                configuration.getMetaDataKeyFilter());\n+\n+                if (configuration.isStore()) {\n+                    this.storeMetadata(storageKey, storage, metadataMap);\n+                }\n+\n+            } else {\n+               throw new IllegalArgumentException(String.format(\"the binary `%s` isn't accessible \", binary != null ? binary.getName() : \"unknown\"));\n+            }\n+        } else {\n+            metadataMap = this.retrieveMetadata(storageKey, storage);\n+        }\n+\n+        if (configuration.isCache()) {\n+\n+            this.putIntoCache(configuration.getCacheKeySupplier().get(),\n+                    metadataMap);\n+        }\n+\n+        return metadataMap;\n+    }\n+\n+    /**\n+     * Group existence verifier\n+     * @param storageKey\n+     * @param storage\n+     */\n+    private void checkBucket(final StorageKey storageKey, final StoragePersistenceAPI storage) {\n+        if (!storage.existsGroup(storageKey.getGroup())) {\n+            storage.createGroup(storageKey.getGroup());\n+        }\n+    }\n+\n+    /**\n+     * save into cache\n+     * @param cacheKey\n+     * @param metadataMap\n+     */\n+    private void putIntoCache(final String cacheKey, final Map<String, Object> metadataMap) {\n+\n+        final DotCacheAdministrator cacheAdmin = CacheLocator.getCacheAdministrator();\n+        if (null != cacheAdmin) {\n+\n+            cacheAdmin.put(cacheKey,\n+                    metadataMap, CACHE_GROUP);\n+        }\n+    }\n+\n+    /**\n+     * meta-data retriever\n+     * @param storageKey\n+     * @param storage\n+     * @return\n+     */\n+    private Map<String, Object> retrieveMetadata(final StorageKey storageKey,\n+            final StoragePersistenceAPI storage) {\n+\n+        Map<String, Object> objectMap = Collections.emptyMap();\n+\n+        try {\n+            objectMap = (Map<String, Object>) storage.pullObject(storageKey.getGroup(), storageKey.getPath(), this.objectReaderDelegate);\n+            Logger.info(this, \"Metadata read from: \" + storageKey.getPath());\n+        } catch (Exception e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+        }\n+\n+        return objectMap;\n+    }\n+\n+    /**\n+     * sends metadata to the respective configured storage\n+     * @param storageKey\n+     * @param storage\n+     * @param metadataMap\n+     */\n+    private void storeMetadata(final StorageKey storageKey, final StoragePersistenceAPI storage,\n+            final Map<String, Object> metadataMap) {\n+\n+        try {\n+            storage.pushObject(storageKey.getGroup(), storageKey.getPath(),\n+                    this.objectWriterDelegate, (Serializable) metadataMap, metadataMap);\n+            Logger.info(this, \"Metadata wrote on: \" + storageKey.getPath());\n+        } catch (Exception e) {\n+            Logger.error(this, e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Check's file is readable and valid\n+     * @param binary\n+     * @return\n+     */\n+    private boolean validBinary(final File binary) {\n+\n+        return null != binary && binary.exists() && binary.canRead();\n+    }\n+\n+    /**\n+     * if the given configuration states we must override the previously existing file will be deleted before re-generating.\n+     * @param storage\n+     * @param generateMetaDataConfiguration\n+     */\n+    private void checkOverride(final StoragePersistenceAPI storage,\n+            final GenerateMetadataConfig generateMetaDataConfiguration) {\n+\n+        final StorageKey storageKey = generateMetaDataConfiguration.getStorageKey();\n+        if (generateMetaDataConfiguration.isOverride() && storage\n+                .existsObject(storageKey.getGroup(), storageKey.getPath())) {\n+\n+            try {\n+\n+                storage.deleteObject(storageKey.getGroup(), storageKey.getPath());\n+            } catch (Exception e) {\n+\n+                Logger.error(this.getClass(),\n+                        String.format(\"Unable to delete existing metadata file [%s] [%s]\",\n+                                storageKey.getPath(), e.getMessage()), e);\n+            }\n+        }\n+    } // checkOverride.\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param requestMetaData {@link RequestMetadata}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> retrieveMetaData(final RequestMetadata requestMetaData) {\n+\n+        Map<String, Object> metadataMap = Collections.emptyMap();\n+\n+        if (requestMetaData.isCache()) {\n+\n+            final DotCacheAdministrator cacheAdmin = CacheLocator.getCacheAdministrator();\n+            if (null != cacheAdmin) {\n+\n+                metadataMap = Try.of(() -> (Map<String, Object>) cacheAdmin\n+                        .get(requestMetaData.getCacheKeySupplier().get(),\n+                                CACHE_GROUP)).getOrElse(Collections.emptyMap());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3NjI1Mg=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczMjgwNA==", "bodyText": "done", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505732804", "createdAt": "2020-10-15T17:55:36Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/FileStorageAPIImpl.java", "diffHunk": "@@ -0,0 +1,359 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.util.MimeTypeUtils;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.DotCacheAdministrator;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableSortedMap;\n+import io.vavr.control.Try;\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.Predicate;\n+\n+/**\n+ * Default implementation\n+ *\n+ * @author jsanca\n+ */\n+public class FileStorageAPIImpl implements FileStorageAPI {\n+\n+    private static final String CACHE_GROUP = \"Contentlet\";\n+\n+    private volatile ObjectReaderDelegate objectReaderDelegate;\n+    private volatile ObjectWriterDelegate objectWriterDelegate;\n+    private volatile MetadataGenerator metadataGenerator;\n+    private final StoragePersistenceProvider persistenceProvider;\n+\n+    /**\n+     * Testing constructor\n+     * @param objectReaderDelegate\n+     * @param objectWriterDelegate\n+     * @param metadataGenerator\n+     * @param persistenceProvider\n+     */\n+    @VisibleForTesting\n+    FileStorageAPIImpl(final ObjectReaderDelegate objectReaderDelegate,\n+            final ObjectWriterDelegate objectWriterDelegate,\n+            final MetadataGenerator metadataGenerator,\n+            final StoragePersistenceProvider persistenceProvider) {\n+        this.objectReaderDelegate = objectReaderDelegate;\n+        this.objectWriterDelegate = objectWriterDelegate;\n+        this.metadataGenerator = metadataGenerator;\n+        this.persistenceProvider = persistenceProvider;\n+    }\n+\n+    /**\n+     * Default constructor\n+     */\n+    public FileStorageAPIImpl() {\n+        this(new JsonReaderDelegate<>(Map.class), new JsonWriterDelegate(),\n+                new TikaMetadataGenerator(), StoragePersistenceProvider.INSTANCE.get());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateRawBasicMetaData(final File binary) {\n+\n+        return this.generateBasicMetaData(binary, s -> true); // raw = no filter\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary  {@link File} file to get the information\n+     * @param maxLength {@link Long} max length is used when parse the content, how many bytes do you want to parse.\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateRawFullMetaData(final File binary, long maxLength) {\n+\n+        return this.generateFullMetaData(binary, s -> true, maxLength); // raw = no filter\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @param metaDataKeyFilter  {@link Predicate} filter the meta data key for the map result generation\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateBasicMetaData(final File binary,\n+            final Predicate<String> metaDataKeyFilter) {\n+\n+        final ImmutableSortedMap.Builder<String, Object> mapBuilder =\n+                new ImmutableSortedMap.Builder<>(Comparator.naturalOrder());\n+\n+        if (this.validBinary(binary)) {\n+\n+\n+            mapBuilder.put(TITLE_META_KEY, binary.getName());\n+\n+            final Optional<String> optional = FileUtil.getRealAssetsPathRelativePiece(binary);\n+            if (optional.isPresent()) {\n+                mapBuilder.put(PATH_META_KEY, optional.get());\n+            } else {\n+                Logger.warn(FileStorageAPIImpl.class, String.format(\n+                        \"Unable to determine relative path for asset `%s`. Using absolute path.\",\n+                        binary));\n+                mapBuilder.put(PATH_META_KEY, binary.getAbsolutePath());\n+            }\n+\n+            if (metaDataKeyFilter.test(LENGTH_META_KEY)) {\n+                mapBuilder.put(LENGTH_META_KEY, binary.length());\n+            }\n+\n+            if (metaDataKeyFilter.test(CONTENT_TYPE_META_KEY)) {\n+                mapBuilder.put(CONTENT_TYPE_META_KEY, MimeTypeUtils.getMimeType(binary));\n+            }\n+\n+            mapBuilder.put(MOD_DATE_META_KEY, System.currentTimeMillis());\n+            mapBuilder.put(SHA226_META_KEY,\n+                    Try.of(() -> FileUtil.sha256toUnixHash(binary)).getOrElse(\"unknown\"));\n+        }\n+\n+        return mapBuilder.build();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary  {@link File} file to get the information\n+     * @param metaDataKeyFilter  {@link Predicate} filter for the map result generation\n+     * @param maxLength {@link Long} max length is used when parse the content, how many bytes do you want to parse.\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateFullMetaData(final File binary,\n+            final Predicate<String> metaDataKeyFilter,\n+            final long maxLength) {\n+\n+        final TreeMap<String, Object> metadataMap = new TreeMap<>(Comparator.naturalOrder());\n+\n+        try {\n+            final Map<String, Object> fullMetaDataMap = this.metadataGenerator.generate(binary, maxLength);\n+            if (UtilMethods.isSet(fullMetaDataMap)) {\n+                for (final Map.Entry<String, Object> entry : fullMetaDataMap.entrySet()) {\n+                    if (metaDataKeyFilter.test(entry.getKey())) {\n+                        metadataMap.put(entry.getKey(), entry.getValue());\n+                    }\n+                }\n+            }\n+            //basic meta data should override any previous value that might have exist already.\n+            metadataMap.putAll(this.generateBasicMetaData(binary, metaDataKeyFilter));\n+        } catch (Exception e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            return Collections.emptyMap();\n+        }\n+\n+        return new ImmutableSortedMap.Builder<String, Object>(Comparator.naturalOrder())\n+                .putAll(metadataMap).build();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param binary {@link File} file to get the information\n+     * @param configuration {@link GenerateMetadataConfig}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> generateMetaData(final File binary,\n+            final GenerateMetadataConfig configuration) {\n+\n+        final Map<String, Object> metadataMap;\n+        final StorageKey storageKey = configuration.getStorageKey();\n+        final StoragePersistenceAPI storage = persistenceProvider.getStorage(storageKey.getStorage());\n+\n+        this.checkBucket(storageKey, storage);  //if the group/bucket doesn't exist create it.\n+        this.checkOverride(storage, configuration); //if config states we need to remove and force regen\n+        //if the entry isn't already there skip and simply store in cache.\n+        if (!storage.existsObject(storageKey.getGroup(), storageKey.getPath())) {\n+            if (this.validBinary(binary)) {\n+                Logger.warn(FileStorageAPIImpl.class, String.format(\n+                        \"Object identified by `/%s/%s` didn't exist in storage %s will be generated.\",\n+                        storageKey.getGroup(), storageKey,\n+                        configuration.isFull() ? \"full-metadata\" : \"basic-metadata\"));\n+                final long maxLength = configuration.getMaxLength();\n+                metadataMap = configuration.isFull() ?\n+                        this.generateFullMetaData(binary,\n+                                configuration.getMetaDataKeyFilter(), maxLength) :\n+                        this.generateBasicMetaData(binary,\n+                                configuration.getMetaDataKeyFilter());\n+\n+                if (configuration.isStore()) {\n+                    this.storeMetadata(storageKey, storage, metadataMap);\n+                }\n+\n+            } else {\n+               throw new IllegalArgumentException(String.format(\"the binary `%s` isn't accessible \", binary != null ? binary.getName() : \"unknown\"));\n+            }\n+        } else {\n+            metadataMap = this.retrieveMetadata(storageKey, storage);\n+        }\n+\n+        if (configuration.isCache()) {\n+\n+            this.putIntoCache(configuration.getCacheKeySupplier().get(),\n+                    metadataMap);\n+        }\n+\n+        return metadataMap;\n+    }\n+\n+    /**\n+     * Group existence verifier\n+     * @param storageKey\n+     * @param storage\n+     */\n+    private void checkBucket(final StorageKey storageKey, final StoragePersistenceAPI storage) {\n+        if (!storage.existsGroup(storageKey.getGroup())) {\n+            storage.createGroup(storageKey.getGroup());\n+        }\n+    }\n+\n+    /**\n+     * save into cache\n+     * @param cacheKey\n+     * @param metadataMap\n+     */\n+    private void putIntoCache(final String cacheKey, final Map<String, Object> metadataMap) {\n+\n+        final DotCacheAdministrator cacheAdmin = CacheLocator.getCacheAdministrator();\n+        if (null != cacheAdmin) {\n+\n+            cacheAdmin.put(cacheKey,\n+                    metadataMap, CACHE_GROUP);\n+        }\n+    }\n+\n+    /**\n+     * meta-data retriever\n+     * @param storageKey\n+     * @param storage\n+     * @return\n+     */\n+    private Map<String, Object> retrieveMetadata(final StorageKey storageKey,\n+            final StoragePersistenceAPI storage) {\n+\n+        Map<String, Object> objectMap = Collections.emptyMap();\n+\n+        try {\n+            objectMap = (Map<String, Object>) storage.pullObject(storageKey.getGroup(), storageKey.getPath(), this.objectReaderDelegate);\n+            Logger.info(this, \"Metadata read from: \" + storageKey.getPath());\n+        } catch (Exception e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+        }\n+\n+        return objectMap;\n+    }\n+\n+    /**\n+     * sends metadata to the respective configured storage\n+     * @param storageKey\n+     * @param storage\n+     * @param metadataMap\n+     */\n+    private void storeMetadata(final StorageKey storageKey, final StoragePersistenceAPI storage,\n+            final Map<String, Object> metadataMap) {\n+\n+        try {\n+            storage.pushObject(storageKey.getGroup(), storageKey.getPath(),\n+                    this.objectWriterDelegate, (Serializable) metadataMap, metadataMap);\n+            Logger.info(this, \"Metadata wrote on: \" + storageKey.getPath());\n+        } catch (Exception e) {\n+            Logger.error(this, e.getMessage(), e);\n+        }\n+    }\n+\n+    /**\n+     * Check's file is readable and valid\n+     * @param binary\n+     * @return\n+     */\n+    private boolean validBinary(final File binary) {\n+\n+        return null != binary && binary.exists() && binary.canRead();\n+    }\n+\n+    /**\n+     * if the given configuration states we must override the previously existing file will be deleted before re-generating.\n+     * @param storage\n+     * @param generateMetaDataConfiguration\n+     */\n+    private void checkOverride(final StoragePersistenceAPI storage,\n+            final GenerateMetadataConfig generateMetaDataConfiguration) {\n+\n+        final StorageKey storageKey = generateMetaDataConfiguration.getStorageKey();\n+        if (generateMetaDataConfiguration.isOverride() && storage\n+                .existsObject(storageKey.getGroup(), storageKey.getPath())) {\n+\n+            try {\n+\n+                storage.deleteObject(storageKey.getGroup(), storageKey.getPath());\n+            } catch (Exception e) {\n+\n+                Logger.error(this.getClass(),\n+                        String.format(\"Unable to delete existing metadata file [%s] [%s]\",\n+                                storageKey.getPath(), e.getMessage()), e);\n+            }\n+        }\n+    } // checkOverride.\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param requestMetaData {@link RequestMetadata}\n+     * @return\n+     */\n+    @Override\n+    public Map<String, Object> retrieveMetaData(final RequestMetadata requestMetaData) {\n+\n+        Map<String, Object> metadataMap = Collections.emptyMap();\n+\n+        if (requestMetaData.isCache()) {\n+\n+            final DotCacheAdministrator cacheAdmin = CacheLocator.getCacheAdministrator();\n+            if (null != cacheAdmin) {\n+\n+                metadataMap = Try.of(() -> (Map<String, Object>) cacheAdmin\n+                        .get(requestMetaData.getCacheKeySupplier().get(),\n+                                CACHE_GROUP)).getOrElse(Collections.emptyMap());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3NjI1Mg=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 330}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzUzMjU1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/JsonWriterDelegate.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxODo1NjowMFrOHgJzyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzoyNzo1MlrOHiSc0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3NzE5Mw==", "bodyText": "Should this throw an exception?  I am not sure, but seems so.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503477193", "createdAt": "2020-10-12T18:56:00Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/JsonWriterDelegate.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package com.dotcms.storage;\n+\n+import com.dotmarketing.util.Logger;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+\n+/**\n+ * Simple implementation that basically converts the object into a json\n+ * @author jsanca\n+ */\n+public class JsonWriterDelegate implements ObjectWriterDelegate {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * Delegate writer\n+     * @param out\n+     * @param object {@link Serializable}\n+     */\n+    @Override\n+    public void write(final OutputStream out, final Serializable object) {\n+        try {\n+            this.objectMapper.writeValue(out, object);\n+        } catch (IOException e) {\n+            Logger.error(this, e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxNTkyMw==", "bodyText": "done .. I am a fan of propagating exceptions to upper layers", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505715923", "createdAt": "2020-10-15T17:27:52Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/JsonWriterDelegate.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package com.dotcms.storage;\n+\n+import com.dotmarketing.util.Logger;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+\n+/**\n+ * Simple implementation that basically converts the object into a json\n+ * @author jsanca\n+ */\n+public class JsonWriterDelegate implements ObjectWriterDelegate {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * Delegate writer\n+     * @param out\n+     * @param object {@link Serializable}\n+     */\n+    @Override\n+    public void write(final OutputStream out, final Serializable object) {\n+        try {\n+            this.objectMapper.writeValue(out, object);\n+        } catch (IOException e) {\n+            Logger.error(this, e.getMessage(), e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ3NzE5Mw=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1Mzc0ODg1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadataAPIImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMDoxMjoxOFrOHgL08A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxODowMzowN1rOHiTwdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxMDI1Ng==", "bodyText": "I think this should be named FileMetadataImpl", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503510256", "createdAt": "2020-10-12T20:12:18Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadataAPIImpl.java", "diffHunk": "@@ -0,0 +1,384 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.contenttype.model.field.BinaryField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.portlets.contentlet.business.ContentletCache;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.StringUtils;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Default implementation\n+ * @author jsanca\n+ */\n+public class ContentletMetadataAPIImpl implements ContentletMetadataAPI {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczNzMzNQ==", "bodyText": "done.. renamed to  FileMetadataAPIImpl", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505737335", "createdAt": "2020-10-15T18:03:07Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/ContentletMetadataAPIImpl.java", "diffHunk": "@@ -0,0 +1,384 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.contenttype.model.field.BinaryField;\n+import com.dotcms.contenttype.model.field.Field;\n+import com.dotcms.contenttype.model.field.FieldVariable;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.CacheLocator;\n+import com.dotmarketing.business.FactoryLocator;\n+import com.dotmarketing.portlets.contentlet.business.ContentletCache;\n+import com.dotmarketing.portlets.contentlet.model.Contentlet;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.StringUtils;\n+import com.dotmarketing.util.UtilMethods;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.ImmutableMap;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * Default implementation\n+ * @author jsanca\n+ */\n+public class ContentletMetadataAPIImpl implements ContentletMetadataAPI {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxMDI1Ng=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1Mzc1NjI4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/StorageKey.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMDoxNDo0NVrOHgL5Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNjo1Nzo0M1rOHiRVHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxMTM2Mw==", "bodyText": "should be serializable?", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503511363", "createdAt": "2020-10-12T20:14:45Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/StorageKey.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package com.dotcms.storage;\n+\n+/**\n+ * Encapsulates a storage key, it has the key (for instance the path)\n+ * the group (for instance the bucket, folder, space, etc)\n+ * Storage {@link StorageType}\n+ * @author jsanca\n+ */\n+public class StorageKey {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5NzU2Nw==", "bodyText": "not really. it just a param passed to an API never used to store anything in cache. But I'll make it serializable it wouldn't hurt either", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505697567", "createdAt": "2020-10-15T16:57:43Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/StorageKey.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package com.dotcms.storage;\n+\n+/**\n+ * Encapsulates a storage key, it has the key (for instance the path)\n+ * the group (for instance the bucket, folder, space, etc)\n+ * Storage {@link StorageType}\n+ * @author jsanca\n+ */\n+public class StorageKey {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxMTM2Mw=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1Mzc3MDAxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotmarketing/business/APILocator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMDoyMDowMVrOHgMBhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzoyMjozNVrOHiSROg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxMzQ3Ng==", "bodyText": "Rename FileMetadataAPI", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503513476", "createdAt": "2020-10-12T20:20:01Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotmarketing/business/APILocator.java", "diffHunk": "@@ -528,6 +532,22 @@ public static FileAssetAPI getFileAssetAPI(){\n \t\treturn (FileAssetAPI) getInstance(APIIndex.FILEASSET_API);\r\n \t}\r\n \r\n+\t/**\r\n+\t * Creates the {@link FileStorageAPI}\r\n+\t * @return FileStorageAPI\r\n+\t */\r\n+\tpublic static FileStorageAPI getFileStorageAPI(){\r\n+\t\treturn (FileStorageAPI) getInstance(APIIndex.FILESTORAGE_API);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Creates the {@link FileStorageAPI}\r\n+\t * @return FileStorageAPI\r\n+\t */\r\n+\tpublic static ContentletMetadataAPI getContentletMetadataAPI(){\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMjk1NA==", "bodyText": "done", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505712954", "createdAt": "2020-10-15T17:22:35Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotmarketing/business/APILocator.java", "diffHunk": "@@ -528,6 +532,22 @@ public static FileAssetAPI getFileAssetAPI(){\n \t\treturn (FileAssetAPI) getInstance(APIIndex.FILEASSET_API);\r\n \t}\r\n \r\n+\t/**\r\n+\t * Creates the {@link FileStorageAPI}\r\n+\t * @return FileStorageAPI\r\n+\t */\r\n+\tpublic static FileStorageAPI getFileStorageAPI(){\r\n+\t\treturn (FileStorageAPI) getInstance(APIIndex.FILESTORAGE_API);\r\n+\t}\r\n+\r\n+\t/**\r\n+\t * Creates the {@link FileStorageAPI}\r\n+\t * @return FileStorageAPI\r\n+\t */\r\n+\tpublic static ContentletMetadataAPI getContentletMetadataAPI(){\r", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxMzQ3Ng=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1Mzc3NTc1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotmarketing/common/db/DotConnect.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMDoyMjowOFrOHgME9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzoyMjoyMVrOHiSQtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNDM1Ng==", "bodyText": "This code does not work as expected - regardless of the fetch size, we read all of the results into memory.  We should use raw jdbc, and not use DotConnect  when fetching the file.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503514356", "createdAt": "2020-10-12T20:22:08Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotmarketing/common/db/DotConnect.java", "diffHunk": "@@ -605,6 +606,11 @@ private void executeQuery(Connection conn) throws SQLException {\n                 }\n \n                 // statement.setMaxRows(maxRows);\n+                if (this.fetchSize > 0) {\n+\n+                    statement.setFetchSize(this.fetchSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMjgyMw==", "bodyText": "done", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505712823", "createdAt": "2020-10-15T17:22:21Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotmarketing/common/db/DotConnect.java", "diffHunk": "@@ -605,6 +606,11 @@ private void executeQuery(Connection conn) throws SQLException {\n                 }\n \n                 // statement.setMaxRows(maxRows);\n+                if (this.fetchSize > 0) {\n+\n+                    statement.setFetchSize(this.fetchSize);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNDM1Ng=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1Mzc4MDY1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotmarketing/common/db/DotConnect.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMDoyNDowMlrOHgMH2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzoyMTo1MlrOHiSPhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNTA5OA==", "bodyText": "I think we should not have this here  - b/c it gives a false sense that you are doing something to avoid excessive memory consumption, when in fact all results are still being loaded into. memory.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503515098", "createdAt": "2020-10-12T20:24:02Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotmarketing/common/db/DotConnect.java", "diffHunk": "@@ -1251,4 +1257,14 @@ private static void setTimestampWithTimezone(PreparedStatement statement, int pa\n         }\n     }\n \n+    /**\n+     *  Number of rows to return, if zero is being ignore.\n+     *  for instance, if using a forward cursor to fetch heavy rows, you can set to 1 (it will be slower but memory resources will be happy)\n+     *  The behaviour will depend on the driver\n+     * */\n+    public DotConnect setFetchSize(final int fetchSize) {\n+\n+        this.fetchSize = fetchSize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMjUxNw==", "bodyText": "removed from DotConnect and replaced it use by plain raw JDBC", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505712517", "createdAt": "2020-10-15T17:21:52Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotmarketing/common/db/DotConnect.java", "diffHunk": "@@ -1251,4 +1257,14 @@ private static void setTimestampWithTimezone(PreparedStatement statement, int pa\n         }\n     }\n \n+    /**\n+     *  Number of rows to return, if zero is being ignore.\n+     *  for instance, if using a forward cursor to fetch heavy rows, you can set to 1 (it will be slower but memory resources will be happy)\n+     *  The behaviour will depend on the driver\n+     * */\n+    public DotConnect setFetchSize(final int fetchSize) {\n+\n+        this.fetchSize = fetchSize;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNTA5OA=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1Mzc4MjQxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotmarketing/portlets/contentlet/business/ContentletCacheImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMDoyNDo1MFrOHgMI5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzoyMTowMVrOHiSNcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNTM2Nw==", "bodyText": "Use cache.getNoThrow here", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503515367", "createdAt": "2020-10-12T20:24:50Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotmarketing/portlets/contentlet/business/ContentletCacheImpl.java", "diffHunk": "@@ -59,6 +61,23 @@ public TranslatedQuery getTranslatedQuery(String key) {\n \t\t}\n \t}\n \n+\tpublic void addMetadataMap(final String key, final Map<String, Object> metadataMap) {\n+\n+\t\tcache.put(META_DATA_MAP_KEY + key, UtilMethods.isSet(metadataMap)?\n+\t\t\t\tmetadataMap:EMPTY_METADATA_MAP, metadataGroup);\n+\t}\n+\n+\tpublic  Map<String, Object> getMetadataMap(final String key) {\n+\n+\t\tMap<String, Object>  metadata = null;\n+\t\ttry {\n+\t\t\tmetadata=(Map<String, Object> )cache.get(META_DATA_MAP_KEY + key, metadataGroup);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcxMTk4Ng==", "bodyText": "done.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505711986", "createdAt": "2020-10-15T17:21:01Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotmarketing/portlets/contentlet/business/ContentletCacheImpl.java", "diffHunk": "@@ -59,6 +61,23 @@ public TranslatedQuery getTranslatedQuery(String key) {\n \t\t}\n \t}\n \n+\tpublic void addMetadataMap(final String key, final Map<String, Object> metadataMap) {\n+\n+\t\tcache.put(META_DATA_MAP_KEY + key, UtilMethods.isSet(metadataMap)?\n+\t\t\t\tmetadataMap:EMPTY_METADATA_MAP, metadataGroup);\n+\t}\n+\n+\tpublic  Map<String, Object> getMetadataMap(final String key) {\n+\n+\t\tMap<String, Object>  metadata = null;\n+\t\ttry {\n+\t\t\tmetadata=(Map<String, Object> )cache.get(META_DATA_MAP_KEY + key, metadataGroup);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNTM2Nw=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1Mzc4NTk1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotmarketing/util/FileUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMDoyNjoxMFrOHgMLBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMDoyNjoxMFrOHgMLBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNTkwOA==", "bodyText": "can we rename this method to sha256toUnixHash (final File file)", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503515908", "createdAt": "2020-10-12T20:26:10Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/FileUtil.java", "diffHunk": "@@ -234,6 +242,78 @@ public boolean accept(File pathname) {\n             }\n         };\n     }\n+\n+\t/**\n+\t * Figure out the sha256 of the file content, assumes that the file exists and can be read\n+\t * @param file {@link File}\n+\t * @return String  just as unix sha returns\n+\t * @throws NoSuchAlgorithmException\n+\t * @throws IOException\n+\t */\n+\tpublic static String sha256toUnixHash (final File file) throws NoSuchAlgorithmException, IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1Mzc4NjkxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotmarketing/util/FileUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMDoyNjozMVrOHgMLkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMDoyNjozMVrOHgMLkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxNjA0OA==", "bodyText": "sha256toUnixHash (final Path path)", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503516048", "createdAt": "2020-10-12T20:26:31Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/FileUtil.java", "diffHunk": "@@ -234,6 +242,78 @@ public boolean accept(File pathname) {\n             }\n         };\n     }\n+\n+\t/**\n+\t * Figure out the sha256 of the file content, assumes that the file exists and can be read\n+\t * @param file {@link File}\n+\t * @return String  just as unix sha returns\n+\t * @throws NoSuchAlgorithmException\n+\t * @throws IOException\n+\t */\n+\tpublic static String sha256toUnixHash (final File file) throws NoSuchAlgorithmException, IOException {\n+\n+\t\treturn sha256toUnixHash(file.toPath());\n+\t} // sha256toUnixHash.\n+\n+\t/**\n+\t * Figure out the sha256 of the file content, assumes that the file exists and can be read\n+\t * @param path {@link Path}\n+\t * @return String just as unix sha returns\n+\t * @throws NoSuchAlgorithmException\n+\t * @throws IOException\n+\t */\n+    public static String sha256toUnixHash(final Path path) throws NoSuchAlgorithmException, IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MzgwNDc5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotmarketing/util/FileUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMDozMzozNFrOHgMWhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzowNzozM1rOHiRtXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxODg1Mw==", "bodyText": "We don't need two arguments here - we know the realAssetsPath system wide.  Actually, I think we really don't think we need these two methods in here at all.  why not just do a:\nString relPath = file.getAbsolutePath().replaceAll(ConfigUtils.getAbsoluteAssetsRootPath());", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r503518853", "createdAt": "2020-10-12T20:33:34Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/FileUtil.java", "diffHunk": "@@ -234,6 +242,78 @@ public boolean accept(File pathname) {\n             }\n         };\n     }\n+\n+\t/**\n+\t * Figure out the sha256 of the file content, assumes that the file exists and can be read\n+\t * @param file {@link File}\n+\t * @return String  just as unix sha returns\n+\t * @throws NoSuchAlgorithmException\n+\t * @throws IOException\n+\t */\n+\tpublic static String sha256toUnixHash (final File file) throws NoSuchAlgorithmException, IOException {\n+\n+\t\treturn sha256toUnixHash(file.toPath());\n+\t} // sha256toUnixHash.\n+\n+\t/**\n+\t * Figure out the sha256 of the file content, assumes that the file exists and can be read\n+\t * @param path {@link Path}\n+\t * @return String just as unix sha returns\n+\t * @throws NoSuchAlgorithmException\n+\t * @throws IOException\n+\t */\n+    public static String sha256toUnixHash(final Path path) throws NoSuchAlgorithmException, IOException {\n+\n+\t\tfinal HashBuilder sha256Builder = Encryptor.Hashing.sha256();\n+\t\tfinal byte[] buffer             = new byte[BUFFER_SIZE];\n+\t\tint countBytes \t\t\t\t\t= 0;\n+\n+\t\ttry (InputStream inputStream = new BufferedInputStream(Files.newInputStream(path))) {\n+\n+\t\t\tcountBytes = inputStream.read(buffer);\n+\t\t\twhile (countBytes > 0) {\n+\n+\t\t\t\tsha256Builder.append(buffer, countBytes);\n+\t\t\t\tcountBytes = inputStream.read(buffer);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn sha256Builder.buildUnixHash();\n+\t} // sha256toUnixHash.\n+\n+\t/**\n+\t * Given an absolute path this will figure out if it exists under the real assets and return the relative piece\n+\t * @param file\n+\t * @return\n+\t */\n+\t@VisibleForTesting\n+\tstatic Optional<String> getRealAssetsPathRelativePiece(final File file,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTcwMzc3Mw==", "bodyText": "ok ok", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505703773", "createdAt": "2020-10-15T17:07:33Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotmarketing/util/FileUtil.java", "diffHunk": "@@ -234,6 +242,78 @@ public boolean accept(File pathname) {\n             }\n         };\n     }\n+\n+\t/**\n+\t * Figure out the sha256 of the file content, assumes that the file exists and can be read\n+\t * @param file {@link File}\n+\t * @return String  just as unix sha returns\n+\t * @throws NoSuchAlgorithmException\n+\t * @throws IOException\n+\t */\n+\tpublic static String sha256toUnixHash (final File file) throws NoSuchAlgorithmException, IOException {\n+\n+\t\treturn sha256toUnixHash(file.toPath());\n+\t} // sha256toUnixHash.\n+\n+\t/**\n+\t * Figure out the sha256 of the file content, assumes that the file exists and can be read\n+\t * @param path {@link Path}\n+\t * @return String just as unix sha returns\n+\t * @throws NoSuchAlgorithmException\n+\t * @throws IOException\n+\t */\n+    public static String sha256toUnixHash(final Path path) throws NoSuchAlgorithmException, IOException {\n+\n+\t\tfinal HashBuilder sha256Builder = Encryptor.Hashing.sha256();\n+\t\tfinal byte[] buffer             = new byte[BUFFER_SIZE];\n+\t\tint countBytes \t\t\t\t\t= 0;\n+\n+\t\ttry (InputStream inputStream = new BufferedInputStream(Files.newInputStream(path))) {\n+\n+\t\t\tcountBytes = inputStream.read(buffer);\n+\t\t\twhile (countBytes > 0) {\n+\n+\t\t\t\tsha256Builder.append(buffer, countBytes);\n+\t\t\t\tcountBytes = inputStream.read(buffer);\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn sha256Builder.buildUnixHash();\n+\t} // sha256toUnixHash.\n+\n+\t/**\n+\t * Given an absolute path this will figure out if it exists under the real assets and return the relative piece\n+\t * @param file\n+\t * @return\n+\t */\n+\t@VisibleForTesting\n+\tstatic Optional<String> getRealAssetsPathRelativePiece(final File file,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzUxODg1Mw=="}, "originalCommit": {"oid": "56b32ce665703a8521f530156483f6bde9c16754"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NzkzNjUwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxODoxMjowNVrOHgzbkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxODowMTo1MlrOHiTthQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE1OTEyMg==", "bodyText": "loadObjectResults(connection)", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r504159122", "createdAt": "2020-10-13T18:12:05Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param jdbcPool\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage_group WHERE group_name = ?\")\n+                    .addParam(groupNameLC).loadObjectResults(this.getConnection())).getOrElse(\n+                    Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String}\n+     * @param objectPath {@link String}\n+     * @return\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage WHERE group_name = ? AND path = ?\")\n+                    .addParam(groupNameLC).addParam(objectPathLC)\n+                    .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName    {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options or not.\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f76483ebece737a7d5e16298129373bda85f61cb"}, "originalPosition": 319}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczNjU4MQ==", "bodyText": "done", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505736581", "createdAt": "2020-10-15T18:01:52Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param jdbcPool\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage_group WHERE group_name = ?\")\n+                    .addParam(groupNameLC).loadObjectResults(this.getConnection())).getOrElse(\n+                    Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String}\n+     * @param objectPath {@link String}\n+     * @return\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage WHERE group_name = ? AND path = ?\")\n+                    .addParam(groupNameLC).addParam(objectPathLC)\n+                    .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName    {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options or not.\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE1OTEyMg=="}, "originalCommit": {"oid": "f76483ebece737a7d5e16298129373bda85f61cb"}, "originalPosition": 319}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1Nzk1NDc4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QxODoxNToxNlrOHgzneg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNzo1OTozMFrOHiTn8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE2MjE3MA==", "bodyText": "loadObjectResults(Connection)", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r504162170", "createdAt": "2020-10-13T18:15:16Z", "author": {"login": "wezell"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param jdbcPool\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage_group WHERE group_name = ?\")\n+                    .addParam(groupNameLC).loadObjectResults(this.getConnection())).getOrElse(\n+                    Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String}\n+     * @param objectPath {@link String}\n+     * @return\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage WHERE group_name = ? AND path = ?\")\n+                    .addParam(groupNameLC).addParam(objectPathLC)\n+                    .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName    {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options or not.\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults();\n+\n+            int count = deleteObjects(maps.stream().map(map -> map.get(\"hash\").toString())\n+                    .collect(Collectors.toSet()), dotConnect, connection);\n+\n+            final int storageEntriesCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage WHERE group_name = ?\", groupNameLC);\n+\n+            final int groupsCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_group WHERE group_name = ?\", groupNameLC);\n+\n+            Logger.info(this, () -> String\n+                    .format(\"total of `%d` objects allocated in `%d` removed for `%d` group. \",\n+                            storageEntriesCount, count, groupsCount));\n+            return storageEntriesCount;\n+        });\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @param path   {   @link String} object path\n+     * @return\n+     */\n+    @Override\n+    public boolean deleteObject(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final String hash = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ? \")\n+                    .addParam(groupNameLC).addParam(pathLC).getString(\"hash\");\n+            if(null != hash) {\n+                deleteObjects(ImmutableSet.of(hash), dotConnect, connection);\n+            }\n+            final int count = dotConnect\n+                    .executeUpdate(connection,\n+                            \"DELETE FROM storage WHERE group_name = ? AND path = ?\",\n+                            groupNameLC, pathLC);\n+            return count > 0;\n+        });\n+    }\n+\n+    /**\n+     * object reference removal\n+     * @param hashSet object hash id\n+     * @param dotConnect DotConnect\n+     * @param connection external connection\n+     * @return count of all removed objects\n+     * @throws DotDataException\n+     */\n+    private int deleteObjects(final Set<String> hashSet, final DotConnect dotConnect, final Connection connection)\n+            throws DotDataException {\n+      int count = 0;\n+        for (final String hash:hashSet) {\n+            //We could seriously benefit from a batch update here. The only problem is our current impl does not take an external connection\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_x_data WHERE data_hash = ?\", hash);\n+\n+            count +=  dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_data WHERE hash_id = ?\", hash);\n+\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return\n+     */\n+    @Override\n+    public List<String> listGroups() {\n+\n+        final MutableObject<List<String>> result = new MutableObject<>(Collections.emptyList());\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List<Map<String, Object>> results = Try\n+                    .of(() -> new DotConnect().setSQL(\"SELECT group_name FROM storage_group\")\n+                            .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+\n+            result.setValue(results.stream().map(map -> map.get(\"group_name\").toString())\n+                    .collect(CollectionsUtils.toImmutableList()));\n+        });\n+\n+        return result.getValue();\n+    }\n+\n+    @Override\n+    public Object pushFile(final String groupName, final String path,\n+            final File file, final Map<String, Object> extraMeta) {\n+\n+        // 1. generate metadata\n+        // 2. see if the sha-256 exists\n+        // 2.1 if exists only insert on the reference\n+        // 2.2 if does not exists, insert a new one\n+        final Map<String, Object> metaData = processMetadata(file, extraMeta);\n+        final String fileHash = (String) metaData.get(FileStorageAPI.SHA226_META_KEY);\n+\n+        return this.wrapInTransaction(\n+                () -> {\n+                    if (!existsGroup(groupName)) {\n+                        throw new IllegalArgumentException(\"The groupName: \" + groupName +\n+                                \", does not exist.\");\n+                    }\n+                    if (this.existsObject(groupName, path)) {\n+                        Logger.warn(DataBaseStoragePersistenceAPIImpl.class,\n+                                String.format(\"Attempt to override entry `%s/%s` \", groupName,\n+                                        path));\n+                        return false;\n+                    }\n+                    return this.existsHash(fileHash) ?\n+                            this.pushFileReference(groupName, path, metaData, fileHash) :\n+                            this.pushNewFile(groupName, path, file, metaData);\n+                });\n+    }\n+\n+    /**\n+     * Selects directly on storage-data since hash is the primary key there.\n+     * @param fileHash\n+     * @return\n+     */\n+    private boolean existsHash(final String fileHash) {\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        this.wrapCloseConnection(() -> {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_data WHERE hash_id = ?\")\n+                                        .addParam(fileHash)\n+                                        .loadObjectResults(this.getConnection());\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        });\n+\n+        return exists.getValue();\n+    }\n+\n+    private Map<String, Object> processMetadata(final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        if (UtilMethods.isSet(extraMeta) && extraMeta.containsKey(FileStorageAPI.SHA226_META_KEY)) {\n+\n+            return extraMeta;\n+        }\n+\n+        final ImmutableMap.Builder<String, Object> metaData = new ImmutableMap.Builder<>();\n+\n+        if (UtilMethods.isSet(extraMeta)) {\n+\n+            metaData.putAll(extraMeta);\n+        }\n+\n+        metaData.putAll(APILocator.getFileStorageAPI().generateRawBasicMetaData(file));\n+\n+        return metaData.build();\n+    }\n+\n+    private Object pushFileReference(final String groupName, final String path,\n+            final Map<String, Object> extraMeta, final String objectHash) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try {\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+            return true;\n+        } catch (DotDataException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private Object pushNewFile(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try (final FileByteSplitter fileSplitter = new FileByteSplitter(file)) {\n+\n+            final HashBuilder objectHashBuilder = Encryptor.Hashing.sha256();\n+            final List<String> chunkHashes = new ArrayList<>();\n+\n+            for (final Tuple2<byte[], Integer> bytesRead : fileSplitter) {\n+\n+                objectHashBuilder.append(bytesRead._1(), bytesRead._2());\n+                final String chunkHash = Encryptor.Hashing.sha256().append\n+                        (bytesRead._1(), bytesRead._2()).buildUnixHash();\n+                chunkHashes.add(chunkHash);\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_data(hash_id, data) VALUES (?, ?)\",\n+                        chunkHash,\n+                        bytesRead._1().length == bytesRead._2() ?\n+                                bytesRead._1() : this.chunkBytes(bytesRead._2(), bytesRead._1()));\n+            }\n+\n+            final String objectHash = objectHashBuilder.buildUnixHash();\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+\n+            int order = 1;\n+            for (final String chunkHash : chunkHashes) {\n+\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_x_data(storage_hash, data_hash, data_order) VALUES (?, ?, ?)\",\n+                        objectHash, chunkHash, order++);\n+            }\n+\n+            return true;\n+        } catch (DotDataException | NoSuchAlgorithmException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] chunkBytes(final int bytesLength, final byte[] bytes) {\n+\n+        final byte[] chunkedArray = new byte[bytesLength];\n+\n+        System.arraycopy(bytes, 0, chunkedArray, 0, bytesLength);\n+\n+        return chunkedArray;\n+    }\n+\n+    @Override\n+    public Object pushObject(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        try {\n+\n+            final File file = FileUtil.createTemporalFile(\"object-storage\", \".tmp\");\n+            final byte[] objectBytes = this.objectToBytes(writerDelegate, object);\n+            FileUtils.writeByteArrayToFile(file, objectBytes);\n+\n+            return this.pushFile(groupName, path, file, extraMeta);\n+        } catch (IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] objectToBytes(final ObjectWriterDelegate writerDelegate,\n+            final Serializable object) {\n+\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        writerDelegate.write(byteArrayOutputStream, object);\n+        return byteArrayOutputStream.toByteArray();\n+    }\n+\n+    @Override\n+    public Future<Object> pushFileAsync(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushFile(groupName, path, file, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public Future<Object> pushObjectAsync(final String bucketName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushObject(bucketName, path, writerDelegate, object, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public File pullFile(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        final MutableObject<File> file = new MutableObject<>(null);\n+\n+        this.wrapCloseConnection(() -> {\n+            try {\n+\n+                final List<Map<String, Object>> storageResult = Try.of(() ->\n+                        new DotConnect()\n+                                .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ?\")\n+                                .addParam(groupNameLC).addParam(pathLC).loadObjectResults()).getOrElse(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f76483ebece737a7d5e16298129373bda85f61cb"}, "originalPosition": 614}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTczNTE1Mg==", "bodyText": "done", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r505735152", "createdAt": "2020-10-15T17:59:30Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,721 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotcms.util.VoidDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method\n+     * in case we want to store stuff outside our db\n+     * @return\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    protected void wrapCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            wrapExternalCloseConnection(voidDelegate, jdbcPool);\n+        } else {\n+\n+            wrapLocalCloseConnection(voidDelegate);\n+        }\n+    }\n+\n+    /**\n+     * custom close connection wrapper\n+     * @param voidDelegate\n+     */\n+    private void wrapLocalCloseConnection(final VoidDelegate voidDelegate) {\n+\n+        final boolean isNewConnection = !DbConnectionFactory.connectionExists();\n+\n+        try {\n+\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (isNewConnection) {\n+\n+                DbConnectionFactory.closeSilently();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom external close connection wrapper\n+     * @param voidDelegate\n+     * @param jdbcPool\n+     */\n+    private void wrapExternalCloseConnection(final VoidDelegate voidDelegate,\n+            final String jdbcPool) {\n+\n+        Connection connection = null;\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            voidDelegate.execute();\n+        } catch (DotSecurityException | DotDataException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            CloseUtils.closeQuietly(connection);\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param <T>\n+     * @return\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate) {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(\"DATABASE_STORAGE_JDBC_POOL_NAME\", StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+\n+            try {\n+\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotRuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     * @param delegate\n+     * @param jdbcPool\n+     * @param <T>\n+     * @return\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage_group WHERE group_name = ?\")\n+                    .addParam(groupNameLC).loadObjectResults(this.getConnection())).getOrElse(\n+                    Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String}\n+     * @param objectPath {@link String}\n+     * @return\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean result = new MutableBoolean(false);\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List results = Try.of(() -> new DotConnect()\n+                    .setSQL(\"SELECT * FROM storage WHERE group_name = ? AND path = ?\")\n+                    .addParam(groupNameLC).addParam(objectPathLC)\n+                    .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+            result.setValue(!results.isEmpty());\n+        });\n+\n+        return result.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName    {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options or not.\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults();\n+\n+            int count = deleteObjects(maps.stream().map(map -> map.get(\"hash\").toString())\n+                    .collect(Collectors.toSet()), dotConnect, connection);\n+\n+            final int storageEntriesCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage WHERE group_name = ?\", groupNameLC);\n+\n+            final int groupsCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_group WHERE group_name = ?\", groupNameLC);\n+\n+            Logger.info(this, () -> String\n+                    .format(\"total of `%d` objects allocated in `%d` removed for `%d` group. \",\n+                            storageEntriesCount, count, groupsCount));\n+            return storageEntriesCount;\n+        });\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @param path   {   @link String} object path\n+     * @return\n+     */\n+    @Override\n+    public boolean deleteObject(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        return this.wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final String hash = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ? \")\n+                    .addParam(groupNameLC).addParam(pathLC).getString(\"hash\");\n+            if(null != hash) {\n+                deleteObjects(ImmutableSet.of(hash), dotConnect, connection);\n+            }\n+            final int count = dotConnect\n+                    .executeUpdate(connection,\n+                            \"DELETE FROM storage WHERE group_name = ? AND path = ?\",\n+                            groupNameLC, pathLC);\n+            return count > 0;\n+        });\n+    }\n+\n+    /**\n+     * object reference removal\n+     * @param hashSet object hash id\n+     * @param dotConnect DotConnect\n+     * @param connection external connection\n+     * @return count of all removed objects\n+     * @throws DotDataException\n+     */\n+    private int deleteObjects(final Set<String> hashSet, final DotConnect dotConnect, final Connection connection)\n+            throws DotDataException {\n+      int count = 0;\n+        for (final String hash:hashSet) {\n+            //We could seriously benefit from a batch update here. The only problem is our current impl does not take an external connection\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_x_data WHERE data_hash = ?\", hash);\n+\n+            count +=  dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_data WHERE hash_id = ?\", hash);\n+\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return\n+     */\n+    @Override\n+    public List<String> listGroups() {\n+\n+        final MutableObject<List<String>> result = new MutableObject<>(Collections.emptyList());\n+\n+        this.wrapCloseConnection(() -> {\n+\n+            final List<Map<String, Object>> results = Try\n+                    .of(() -> new DotConnect().setSQL(\"SELECT group_name FROM storage_group\")\n+                            .loadObjectResults(this.getConnection())).getOrElse(Collections::emptyList);\n+\n+            result.setValue(results.stream().map(map -> map.get(\"group_name\").toString())\n+                    .collect(CollectionsUtils.toImmutableList()));\n+        });\n+\n+        return result.getValue();\n+    }\n+\n+    @Override\n+    public Object pushFile(final String groupName, final String path,\n+            final File file, final Map<String, Object> extraMeta) {\n+\n+        // 1. generate metadata\n+        // 2. see if the sha-256 exists\n+        // 2.1 if exists only insert on the reference\n+        // 2.2 if does not exists, insert a new one\n+        final Map<String, Object> metaData = processMetadata(file, extraMeta);\n+        final String fileHash = (String) metaData.get(FileStorageAPI.SHA226_META_KEY);\n+\n+        return this.wrapInTransaction(\n+                () -> {\n+                    if (!existsGroup(groupName)) {\n+                        throw new IllegalArgumentException(\"The groupName: \" + groupName +\n+                                \", does not exist.\");\n+                    }\n+                    if (this.existsObject(groupName, path)) {\n+                        Logger.warn(DataBaseStoragePersistenceAPIImpl.class,\n+                                String.format(\"Attempt to override entry `%s/%s` \", groupName,\n+                                        path));\n+                        return false;\n+                    }\n+                    return this.existsHash(fileHash) ?\n+                            this.pushFileReference(groupName, path, metaData, fileHash) :\n+                            this.pushNewFile(groupName, path, file, metaData);\n+                });\n+    }\n+\n+    /**\n+     * Selects directly on storage-data since hash is the primary key there.\n+     * @param fileHash\n+     * @return\n+     */\n+    private boolean existsHash(final String fileHash) {\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        this.wrapCloseConnection(() -> {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_data WHERE hash_id = ?\")\n+                                        .addParam(fileHash)\n+                                        .loadObjectResults(this.getConnection());\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        });\n+\n+        return exists.getValue();\n+    }\n+\n+    private Map<String, Object> processMetadata(final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        if (UtilMethods.isSet(extraMeta) && extraMeta.containsKey(FileStorageAPI.SHA226_META_KEY)) {\n+\n+            return extraMeta;\n+        }\n+\n+        final ImmutableMap.Builder<String, Object> metaData = new ImmutableMap.Builder<>();\n+\n+        if (UtilMethods.isSet(extraMeta)) {\n+\n+            metaData.putAll(extraMeta);\n+        }\n+\n+        metaData.putAll(APILocator.getFileStorageAPI().generateRawBasicMetaData(file));\n+\n+        return metaData.build();\n+    }\n+\n+    private Object pushFileReference(final String groupName, final String path,\n+            final Map<String, Object> extraMeta, final String objectHash) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try {\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+            return true;\n+        } catch (DotDataException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private Object pushNewFile(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try (final FileByteSplitter fileSplitter = new FileByteSplitter(file)) {\n+\n+            final HashBuilder objectHashBuilder = Encryptor.Hashing.sha256();\n+            final List<String> chunkHashes = new ArrayList<>();\n+\n+            for (final Tuple2<byte[], Integer> bytesRead : fileSplitter) {\n+\n+                objectHashBuilder.append(bytesRead._1(), bytesRead._2());\n+                final String chunkHash = Encryptor.Hashing.sha256().append\n+                        (bytesRead._1(), bytesRead._2()).buildUnixHash();\n+                chunkHashes.add(chunkHash);\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_data(hash_id, data) VALUES (?, ?)\",\n+                        chunkHash,\n+                        bytesRead._1().length == bytesRead._2() ?\n+                                bytesRead._1() : this.chunkBytes(bytesRead._2(), bytesRead._1()));\n+            }\n+\n+            final String objectHash = objectHashBuilder.buildUnixHash();\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+\n+            int order = 1;\n+            for (final String chunkHash : chunkHashes) {\n+\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_x_data(storage_hash, data_hash, data_order) VALUES (?, ?, ?)\",\n+                        objectHash, chunkHash, order++);\n+            }\n+\n+            return true;\n+        } catch (DotDataException | NoSuchAlgorithmException | IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] chunkBytes(final int bytesLength, final byte[] bytes) {\n+\n+        final byte[] chunkedArray = new byte[bytesLength];\n+\n+        System.arraycopy(bytes, 0, chunkedArray, 0, bytesLength);\n+\n+        return chunkedArray;\n+    }\n+\n+    @Override\n+    public Object pushObject(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        try {\n+\n+            final File file = FileUtil.createTemporalFile(\"object-storage\", \".tmp\");\n+            final byte[] objectBytes = this.objectToBytes(writerDelegate, object);\n+            FileUtils.writeByteArrayToFile(file, objectBytes);\n+\n+            return this.pushFile(groupName, path, file, extraMeta);\n+        } catch (IOException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] objectToBytes(final ObjectWriterDelegate writerDelegate,\n+            final Serializable object) {\n+\n+        final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n+        writerDelegate.write(byteArrayOutputStream, object);\n+        return byteArrayOutputStream.toByteArray();\n+    }\n+\n+    @Override\n+    public Future<Object> pushFileAsync(final String groupName, final String path, final File file,\n+            final Map<String, Object> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushFile(groupName, path, file, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public Future<Object> pushObjectAsync(final String bucketName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Object> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushObject(bucketName, path, writerDelegate, object, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public File pullFile(final String groupName, final String path) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        final MutableObject<File> file = new MutableObject<>(null);\n+\n+        this.wrapCloseConnection(() -> {\n+            try {\n+\n+                final List<Map<String, Object>> storageResult = Try.of(() ->\n+                        new DotConnect()\n+                                .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ?\")\n+                                .addParam(groupNameLC).addParam(pathLC).loadObjectResults()).getOrElse(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDE2MjE3MA=="}, "originalCommit": {"oid": "f76483ebece737a7d5e16298129373bda85f61cb"}, "originalPosition": 614}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3MzY5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/datagen/TestDataUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDoyOTo1NlrOHjUKjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDoyOTo1NlrOHjUKjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjU4OA==", "bodyText": "Codacy found an issue: The String literal \"com/dotmarketing/portlets/contentlet/business/test_files/test_image1.jpg\" appears 4 times in this file; the first occurrence is on line 966", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792588", "createdAt": "2020-10-17T04:29:56Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/datagen/TestDataUtils.java", "diffHunk": "@@ -936,28 +945,43 @@ public static Relationship relateContentTypes(final ContentType parentContentTyp\n     }\n \n     public static Contentlet getFileAssetContent(Boolean persist, long languageId) {\n+        return getFileAssetContent(persist, languageId, TestFile.JPG);\n+    }\n+\n+    public static Contentlet getFileAssetSVGContent(Boolean persist, long languageId) {\n+        return getFileAssetContent(persist, languageId, TestFile.SVG);\n+    }\n+\n+    public static Contentlet getFileAssetContent(final Boolean persist, final long languageId, final TestFile testFile) {\n \n         try {\n-            Folder folder = new FolderDataGen().nextPersisted();\n+            final Folder folder = new FolderDataGen().nextPersisted();\n \n             //Test file\n-            final String testImagePath = \"com/dotmarketing/portlets/contentlet/business/test_files/test_image1.jpg\";\n-            return createFileAsset(testImagePath, folder, languageId, persist);\n+            final String testFilePath = testFile.filePath;\n+            return createFileAsset(testFilePath, folder, languageId, persist);\n         } catch (Exception e) {\n             throw new DotRuntimeException(e);\n         }\n     }\n \n-    public static Contentlet getFileAssetSVGContent(Boolean persist, long languageId) {\n+    public enum TestFile {\n \n-        try {\n-            final Folder folder = new FolderDataGen().nextPersisted();\n+        JPG(\"com/dotmarketing/portlets/contentlet/business/test_files/test_image1.jpg\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3MzcxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/StoragePersistenceProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDoyOTo1N1rOHjUKjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDoyOTo1N1rOHjUKjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjU5MA==", "bodyText": "Codacy found an issue: Avoid reassigning parameters such as 'storageType'", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792590", "createdAt": "2020-10-17T04:29:57Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/StoragePersistenceProvider.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.dotcms.storage;\n+\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import java.io.File;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+/**\n+ * Singleton that serves as entry point to the storage api\n+ */\n+public final class StoragePersistenceProvider {\n+\n+    static final String DEFAULT_STORAGE_TYPE = \"DEFAULT_STORAGE_TYPE\";\n+    static final String METADATA_GROUP_NAME = \"METADATA_GROUP_NAME\";\n+\n+    private final Map<StorageType, StoragePersistenceAPI> storageMap = new ConcurrentHashMap<>();\n+\n+    /**\n+     * default constructor\n+     */\n+    private StoragePersistenceProvider() {\n+    }\n+\n+    /**\n+     * default storage type\n+     * @return\n+     */\n+    public static StorageType getStorageType(){\n+        final String storageType = Config.getStringProperty(DEFAULT_STORAGE_TYPE, StorageType.FILE_SYSTEM.name());\n+        return StorageType.valueOf(storageType);\n+    }\n+\n+    /**\n+     * file system storage type\n+     * @return\n+     */\n+    public FileSystemStoragePersistenceAPIImpl getFileSystemStorage() {\n+\n+        return (FileSystemStoragePersistenceAPIImpl) this.storageMap.get(StorageType.FILE_SYSTEM);\n+    }\n+\n+    /**\n+     * db storage type\n+     * @return\n+     */\n+    public DataBaseStoragePersistenceAPIImpl getDbStorage() {\n+\n+        return (DataBaseStoragePersistenceAPIImpl) this.storageMap.get(StorageType.DB);\n+    }\n+\n+    /**\n+     * param based storage type getter\n+     * @param storageType\n+     * @return\n+     */\n+    public StoragePersistenceAPI getStorage (StorageType storageType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3Mzc5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/GenerateMetadataConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDoyOTo1OFrOHjUKmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDoyOTo1OFrOHjUKmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjYwMA==", "bodyText": "Codacy found an issue: Field storageKey has the same name as a method", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792600", "createdAt": "2020-10-17T04:29:58Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/GenerateMetadataConfig.java", "diffHunk": "@@ -0,0 +1,202 @@\n+package com.dotcms.storage;\n+\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Configuration to generate the meta data.\n+ *\n+ * @author jsanca\n+ */\n+public class GenerateMetadataConfig {\n+\n+    /**\n+     * Provides the key for the storage\n+     */\n+    private final StorageKey storageKey;\n+\n+    /**\n+     * If true, means the metadata output will be stores in the metaDataFileSupplier file\n+     */\n+    private final boolean store;\n+\n+    /**\n+     * if store is true, and you want to force always the file generation set this to true (keep in\n+     * mind it could be expensive)\n+     */\n+    private final boolean override;\n+\n+    /**\n+     * On huge file, we probably do not want to parse all the content, so this max will limited how\n+     * much do we want to read\n+     */\n+    private final long maxLength;\n+\n+    /**\n+     * {@link Predicate} filter the meta data key for the map result generation\n+     */\n+    private final Predicate<String> metaDataKeyFilter;\n+\n+    /**\n+     * If true, means the medatada output will be stores in the memory cache.\n+     */\n+    private final boolean cache;\n+\n+    /**\n+     * Cache key supplier, if cache is true\n+     */\n+    private final Supplier<String> cacheKeySupplier;\n+\n+    /**\n+     * If true, means the metadata generated will be full except if there is any metaDataKeyFilter,\n+     * only these fields will be accepted.\n+     */\n+    private final boolean full;\n+\n+    private GenerateMetadataConfig(final Builder builder) {\n+\n+        this.cache = builder.cache;\n+        this.cacheKeySupplier = builder.cacheKeySupplier;\n+        this.maxLength = builder.maxLength;\n+        this.storageKey = builder.storageKey;\n+        this.metaDataKeyFilter = builder.metaDataKeyFilter;\n+        this.override = builder.override;\n+        this.store = builder.store;\n+        this.full = builder.full;\n+    }\n+\n+    public StorageKey getStorageKey() {\n+        return storageKey;\n+    }\n+\n+    public boolean isStore() {\n+        return store;\n+    }\n+\n+    public boolean isOverride() {\n+        return override;\n+    }\n+\n+    public long getMaxLength() {\n+        return maxLength;\n+    }\n+\n+    public Predicate<String> getMetaDataKeyFilter() {\n+        return metaDataKeyFilter;\n+    }\n+\n+    public boolean isCache() {\n+        return cache;\n+    }\n+\n+    public Supplier<String> getCacheKeySupplier() {\n+        return cacheKeySupplier;\n+    }\n+\n+    public boolean isFull() {\n+        return full;\n+    }\n+\n+    public static final class Builder {\n+\n+        /**\n+         * If true, means the metadata generated will be full except if there is any\n+         * metaDataKeyFilter, only these fields will be accepted.\n+         */\n+        private boolean full;\n+\n+        /**\n+         * Provides the supplier to stores the metadata generated, if store is true\n+         */\n+        private StorageKey storageKey;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3Mzg3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/storage/StoragePersistenceAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDoyOTo1OVrOHjUKnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDoyOTo1OVrOHjUKnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjYwNw==", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792607", "createdAt": "2020-10-17T04:29:59Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/storage/StoragePersistenceAPITest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+package com.dotcms.storage;\n+\n+import static com.dotcms.storage.StoragePersistenceProvider.DEFAULT_STORAGE_TYPE;\n+import static com.dotcms.unittest.TestUtil.upperCaseRandom;\n+import static junit.framework.Assert.assertNotSame;\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertFalse;\n+import static junit.framework.TestCase.assertNotNull;\n+import static junit.framework.TestCase.assertTrue;\n+\n+import com.dotcms.datagen.TestDataUtils.TestFile;\n+import com.dotcms.storage.StoragePersistenceProvider.INSTANCE;\n+import com.dotcms.util.ConfigTestHelper;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.Config;\n+import com.google.common.collect.ImmutableMap;\n+import com.liferay.util.Encryptor;\n+import com.tngtech.java.junit.dataprovider.DataProvider;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import com.tngtech.java.junit.dataprovider.UseDataProvider;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Random;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+@RunWith(DataProviderRunner.class)\n+public class StoragePersistenceAPITest {\n+\n+    private static final String textFilePath = \"textFilePath\";\n+    private static final String imageFilePath = \"imageFilePath\";\n+\n+    private static final String TEST_IMAGE_JPG = TestFile.JPG.getFilePath();\n+    private static final String TEST_IMAGE_PNG = TestFile.PNG.getFilePath();\n+    private static final String TEST_TEXT_PATH = TestFile.TEXT.getFilePath();\n+\n+    private static final int LARGE_FILE_SIZE = 1024 * 1024 * 4;\n+\n+    private static final StoragePersistenceProvider persistenceProvider = INSTANCE.get();\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Given Scenario: We call the singleton method that retrieves the default storage\n+     * Expected Result: We expect the default storage to be an instance of FileSystemStoragePersistenceAPIImpl\n+     */\n+    @Test\n+    public void Test_Get_Default_Provider() {\n+        final String stringProperty = Config.getStringProperty(DEFAULT_STORAGE_TYPE);\n+        try {\n+        //if there's a property already set we need to clean it so we can test that by default we will get FileSystem\n+            Config.setProperty(DEFAULT_STORAGE_TYPE, null);\n+            final StoragePersistenceProvider persistenceProvider = INSTANCE.get();\n+            assertTrue(persistenceProvider\n+                    .getStorage() instanceof FileSystemStoragePersistenceAPIImpl);\n+        }finally {\n+            Config.setProperty(DEFAULT_STORAGE_TYPE, stringProperty);\n+        }\n+    }\n+\n+    /**\n+     * Given Scenario:\n+     * Expected Result:\n+     */\n+    @Test\n+    public void Test_Get_Provider_By_StorageType() {\n+        final StoragePersistenceProvider persistenceProvider = INSTANCE.get();\n+        assertTrue(persistenceProvider.getStorage(\n+                StorageType.FILE_SYSTEM) instanceof FileSystemStoragePersistenceAPIImpl);\n+        assertTrue(persistenceProvider\n+                .getStorage(StorageType.DB) instanceof DataBaseStoragePersistenceAPIImpl);\n+    }\n+\n+    /**\n+     * Given scenario: For the same group we send two files of different type.\n+     * Expected Result: The Group should be created then the file should be stored and then removed together with all of its elements.\n+     * Same group is always send to test delete is effective.\n+     */\n+    @Test\n+    @UseDataProvider(\"getMixedStorageTestCases\")\n+    public void Test_Storage_Push_File_Then_Recover_Then_Remove_Group(final TestCase testCase)\n+            throws DotDataException {\n+        final StoragePersistenceAPI storage = persistenceProvider.getStorage(testCase.storageType);\n+        final String groupName = testCase.groupName;\n+        final String path = testCase.path;\n+\n+        try {\n+            assertFalse(storage.existsGroup(groupName));\n+            assertTrue(storage.createGroup(groupName));\n+            assertTrue(storage.listGroups().contains(groupName));\n+\n+            final File pushFile = testCase.file;\n+            final Object resultObject = storage\n+                    .pushFile(groupName, path, pushFile, ImmutableMap.of());\n+            assertNotNull(resultObject);\n+            assertTrue(storage.existsGroup(groupName));\n+            final File pullFile = storage.pullFile(groupName, path);\n+            assertTrue(pullFile.exists());\n+            assertTrue(pullFile.canRead());\n+            assertTrue(pullFile.canWrite());\n+            assertNotSame(pushFile, pullFile);\n+            assertEquals(pullFile.length(), pushFile.length());\n+        } finally {\n+            final int count = storage.deleteGroup(groupName);\n+            assertEquals(1, count);\n+            assertFalse(storage.existsGroup(groupName));\n+            assertFalse(storage.existsObject(groupName, path));\n+        }\n+\n+    }\n+\n+\n+    @DataProvider\n+    public static Object[] getMixedStorageTestCases() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3Mzk1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotmarketing/portlets/contentlet/model/IntegrationResourceLinkTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowMVrOHjUKpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowMVrOHjUKpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjYxNQ==", "bodyText": "Codacy found an issue: Avoid unused local variables such as 'file'.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792615", "createdAt": "2020-10-17T04:30:01Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/portlets/contentlet/model/IntegrationResourceLinkTest.java", "diffHunk": "@@ -179,7 +178,7 @@ public void test_newContentlet_withoutBinary_expectEmptyLink() throws Exception{\n \n         final Host host = APILocator.systemHost();\n         final boolean isSecure = false;\n-        final File file = FileUtil.createTemporalFile(\"comments-list\", \"txt\", \"This is a test temporal file\");\n+        final File file = FileUtil.createTemporaryFile(\"comments-list\", \"txt\", \"This is a test temporal file\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3Mzk3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/storage/StoragePersistenceAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowMlrOHjUKqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowMlrOHjUKqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjYxNw==", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792617", "createdAt": "2020-10-17T04:30:02Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/storage/StoragePersistenceAPITest.java", "diffHunk": "@@ -0,0 +1,347 @@\n+package com.dotcms.storage;\n+\n+import static com.dotcms.storage.StoragePersistenceProvider.DEFAULT_STORAGE_TYPE;\n+import static com.dotcms.unittest.TestUtil.upperCaseRandom;\n+import static junit.framework.Assert.assertNotSame;\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertFalse;\n+import static junit.framework.TestCase.assertNotNull;\n+import static junit.framework.TestCase.assertTrue;\n+\n+import com.dotcms.datagen.TestDataUtils.TestFile;\n+import com.dotcms.storage.StoragePersistenceProvider.INSTANCE;\n+import com.dotcms.util.ConfigTestHelper;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.Config;\n+import com.google.common.collect.ImmutableMap;\n+import com.liferay.util.Encryptor;\n+import com.tngtech.java.junit.dataprovider.DataProvider;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import com.tngtech.java.junit.dataprovider.UseDataProvider;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Random;\n+import org.apache.commons.lang.RandomStringUtils;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+@RunWith(DataProviderRunner.class)\n+public class StoragePersistenceAPITest {\n+\n+    private static final String textFilePath = \"textFilePath\";\n+    private static final String imageFilePath = \"imageFilePath\";\n+\n+    private static final String TEST_IMAGE_JPG = TestFile.JPG.getFilePath();\n+    private static final String TEST_IMAGE_PNG = TestFile.PNG.getFilePath();\n+    private static final String TEST_TEXT_PATH = TestFile.TEXT.getFilePath();\n+\n+    private static final int LARGE_FILE_SIZE = 1024 * 1024 * 4;\n+\n+    private static final StoragePersistenceProvider persistenceProvider = INSTANCE.get();\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3Mzk4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowM1rOHjUKqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowM1rOHjUKqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjYxOA==", "bodyText": "Codacy found an issue: Unnecessary modifier 'final' on resource specification 'fileJoiner': resource specifications are implicitly final", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792618", "createdAt": "2020-10-17T04:30:03Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,652 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.Encryptor.Hashing;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.nio.file.Files;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private static final String DATABASE_STORAGE_JDBC_POOL_NAME = \"DATABASE_STORAGE_JDBC_POOL_NAME\";\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method in case we want to store stuff outside our db\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(DATABASE_STORAGE_JDBC_POOL_NAME, StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate)\n+            throws DotDataException {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(DATABASE_STORAGE_JDBC_POOL_NAME, StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+            try {\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+                Logger.error(DataBaseStoragePersistenceAPIImpl.class, e.getMessage(), e);\n+                throw new DotDataException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        try (Connection connection = getConnection()) {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_group WHERE group_name = ?\")\n+                                        .addParam(groupNameLC)\n+                                        .loadObjectResults(connection);\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        } catch (SQLException e) {\n+            throw new DotDataException(e.getMessage(), e);\n+        }\n+        return exists.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String}\n+     * @param objectPath {@link String}\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath)\n+            throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean exists = new MutableBoolean(false);\n+\n+        try (Connection connection = getConnection()) {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage WHERE group_name = ? AND path = ?\")\n+                                        .addParam(groupNameLC).addParam(objectPathLC)\n+                                        .loadObjectResults(connection);\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        } catch (SQLException e) {\n+            throw new DotDataException(e.getMessage(), e);\n+        }\n+        ;\n+\n+        return exists.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) throws DotDataException {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options\n+     * or not.\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions)\n+            throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults(connection);\n+\n+            int count = deleteObjects(maps.stream().map(map -> map.get(\"hash\").toString())\n+                    .collect(Collectors.toSet()), dotConnect, connection);\n+\n+            final int storageEntriesCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage WHERE group_name = ?\", groupNameLC);\n+\n+            final int groupsCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_group WHERE group_name = ?\", groupNameLC);\n+\n+            Logger.info(this, () -> String\n+                    .format(\"total of `%d` objects allocated in `%d` removed for `%d` group. \",\n+                            storageEntriesCount, count, groupsCount));\n+            return storageEntriesCount;\n+        });\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     * @param path {   @link String} object path\n+     */\n+    @Override\n+    public boolean deleteObject(final String groupName, final String path) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        return wrapInTransaction(() -> {\n+            final Connection connection = getConnection();\n+\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> results = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ? \")\n+                    .addParam(groupNameLC).addParam(pathLC).loadObjectResults(connection);\n+\n+            if (!results.isEmpty()) {\n+                final String hash = (String) results.get(0).get(\"hash\");\n+                deleteObjects(ImmutableSet.of(hash), dotConnect, connection);\n+            }\n+            final int count = dotConnect\n+                    .executeUpdate(connection,\n+                            \"DELETE FROM storage WHERE group_name = ? AND path = ?\",\n+                            groupNameLC, pathLC);\n+            return count > 0;\n+        });\n+    }\n+\n+    /**\n+     * object reference removal\n+     *\n+     * @param hashSet object hash id\n+     * @param dotConnect DotConnect\n+     * @param connection external connection\n+     * @return count of all removed objects\n+     */\n+    private int deleteObjects(final Set<String> hashSet, final DotConnect dotConnect,\n+            final Connection connection)\n+            throws DotDataException {\n+        int count = 0;\n+        for (final String hash : hashSet) {\n+            //We could seriously benefit from a batch update here. The only problem is our current impl does not take an external connection\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_x_data WHERE data_hash = ?\", hash);\n+\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_data WHERE hash_id = ?\", hash);\n+\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<String> listGroups() throws DotDataException {\n+\n+        final MutableObject<List<String>> result = new MutableObject<>(Collections.emptyList());\n+\n+        try (Connection connection = getConnection()) {\n+\n+            final List<Map<String, Object>> results = Try\n+                    .of(() -> new DotConnect().setSQL(\"SELECT group_name FROM storage_group\")\n+                            .loadObjectResults(connection)).getOrElse(Collections::emptyList);\n+\n+            result.setValue(results.stream().map(map -> map.get(\"group_name\").toString())\n+                    .collect(CollectionsUtils.toImmutableList()));\n+        } catch (SQLException e) {\n+            throw new DotDataException(e.getMessage(), e);\n+        }\n+\n+        return result.getValue();\n+    }\n+\n+    @Override\n+    public Object pushFile(final String groupName, final String path,\n+            final File file, final Map<String, Serializable> extraMeta) throws DotDataException {\n+\n+        // 1. generate metadata\n+        // 2. see if the sha-256 exists\n+        // 2.1 if exists only insert on the reference\n+        // 2.2 if does not exists, insert a new one\n+        final Map<String, Serializable> metaData = processMetadata(file, extraMeta);\n+        final String fileHash = (String) metaData.get(FileStorageAPI.SHA226_META_KEY);\n+\n+        return wrapInTransaction(\n+                () -> {\n+                    if (!existsGroup(groupName)) {\n+                        throw new IllegalArgumentException(\"The groupName: \" + groupName +\n+                                \", does not exist.\");\n+                    }\n+                    if (this.existsObject(groupName, path)) {\n+                        Logger.warn(DataBaseStoragePersistenceAPIImpl.class,\n+                                String.format(\"Attempt to override entry `%s/%s` \", groupName,\n+                                        path));\n+                        return false;\n+                    }\n+                    return this.existsHash(fileHash) ?\n+                            this.pushFileReference(groupName, path, metaData, fileHash) :\n+                            this.pushNewFile(groupName, path, file, metaData);\n+                });\n+    }\n+\n+    /**\n+     * Selects directly on storage-data since hash is the primary key there.\n+     */\n+    private boolean existsHash(final String fileHash) throws DotDataException {\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        try (Connection connection = getConnection()) {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_data WHERE hash_id = ?\")\n+                                        .addParam(fileHash)\n+                                        .loadObjectResults(connection);\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        } catch (SQLException e) {\n+            throw new DotDataException(e.getMessage(), e);\n+        }\n+\n+        return exists.getValue();\n+    }\n+\n+    private Map<String, Serializable> processMetadata(final File file,\n+            final Map<String, Serializable> extraMeta) {\n+\n+        if (UtilMethods.isSet(extraMeta) && extraMeta.containsKey(FileStorageAPI.SHA226_META_KEY)) {\n+\n+            return extraMeta;\n+        }\n+\n+        final ImmutableMap.Builder<String, Serializable> metaData = new ImmutableMap.Builder<>();\n+\n+        if (UtilMethods.isSet(extraMeta)) {\n+\n+            metaData.putAll(extraMeta);\n+        }\n+\n+        metaData.putAll(APILocator.getFileStorageAPI().generateRawBasicMetaData(file));\n+\n+        return metaData.build();\n+    }\n+\n+    private Object pushFileReference(final String groupName, final String path,\n+            final Map<String, Serializable> extraMeta, final String objectHash) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try {\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+            return true;\n+        } catch (DotDataException | IOException e) {\n+            Logger.error(DataBaseStoragePersistenceAPIImpl.class, e.getMessage(), e);\n+            throw new DotDataException(e);\n+        }\n+    }\n+\n+    private Object pushNewFile(final String groupName, final String path, final File file,\n+            final Map<String, Serializable> extraMeta) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try (final FileByteSplitter fileSplitter = new FileByteSplitter(file)) {\n+\n+            final HashBuilder objectHashBuilder = Encryptor.Hashing.sha256();\n+            final List<String> chunkHashes = new ArrayList<>();\n+\n+            for (final Tuple2<byte[], Integer> bytesRead : fileSplitter) {\n+\n+                objectHashBuilder.append(bytesRead._1(), bytesRead._2());\n+                final String chunkHash = Encryptor.Hashing.sha256().append\n+                        (bytesRead._1(), bytesRead._2()).buildUnixHash();\n+                chunkHashes.add(chunkHash);\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_data(hash_id, data) VALUES (?, ?)\",\n+                        chunkHash,\n+                        bytesRead._1().length == bytesRead._2() ?\n+                                bytesRead._1() : this.chunkBytes(bytesRead._2(), bytesRead._1()));\n+            }\n+\n+            final String objectHash = objectHashBuilder.buildUnixHash();\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+\n+            int order = 1;\n+            for (final String chunkHash : chunkHashes) {\n+\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_x_data(storage_hash, data_hash, data_order) VALUES (?, ?, ?)\",\n+                        objectHash, chunkHash, order++);\n+            }\n+\n+            return true;\n+        } catch (DotDataException | NoSuchAlgorithmException | IOException e) {\n+            Logger.error(DataBaseStoragePersistenceAPIImpl.class, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] chunkBytes(final int bytesLength, final byte[] bytes) {\n+\n+        final byte[] chunkedArray = new byte[bytesLength];\n+\n+        System.arraycopy(bytes, 0, chunkedArray, 0, bytesLength);\n+\n+        return chunkedArray;\n+    }\n+\n+    @Override\n+    public Object pushObject(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Serializable> extraMeta)\n+            throws DotDataException {\n+        try {\n+            final File file = FileUtil.createTemporaryFile(\"object-storage\", \".tmp\");\n+            writeToFile(writerDelegate, object, file);\n+            return this.pushFile(groupName, path, file, extraMeta);\n+        } catch (Exception e) {\n+            Logger.error(DataBaseStoragePersistenceAPIImpl.class, e.getMessage(), e);\n+            throw new DotDataException(e);\n+        }\n+    }\n+\n+    /**\n+     * This will write directly from the Serializer delegate right into a file. No in memory loading\n+     * takes place like this.\n+     */\n+    private void writeToFile(final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, File file) throws IOException {\n+\n+        try (final OutputStream outputStream = Files.newOutputStream(file.toPath())) {\n+            writerDelegate.write(outputStream, object);\n+        }\n+    }\n+\n+    @Override\n+    public Future<Object> pushFileAsync(final String groupName, final String path, final File file,\n+            final Map<String, Serializable> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushFile(groupName, path, file, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public Future<Object> pushObjectAsync(final String bucketName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Serializable> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushObject(bucketName, path, writerDelegate, object, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public File pullFile(final String groupName, final String path) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        final MutableObject<File> file = new MutableObject<>(null);\n+\n+        try (Connection connection = getConnection()) {\n+            final List<Map<String, Object>> storageResult = Try.of(() ->\n+                    new DotConnect()\n+                            .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ?\")\n+                            .addParam(groupNameLC).addParam(pathLC)\n+                            .loadObjectResults(connection)).getOrElse(Collections::emptyList);\n+\n+            if (!storageResult.isEmpty()) {\n+\n+                final Optional<Object> objectOpt = storageResult.stream()\n+                        .map(map -> map.get(\"hash\")).findFirst();\n+\n+                final String objectHash = (String) objectOpt.get();\n+                if (UtilMethods.isSet(objectHash)) {\n+                    file.setValue(this.createJoinFile(objectHash));\n+                }\n+            } else {\n+                throw new DoesNotExistException(\n+                        \"The storage, group: \" + groupName + \", path: \" + path\n+                                + \" does not exists\");\n+            }\n+\n+        } catch (Exception e) {\n+            Logger.error(DataBaseStoragePersistenceAPIImpl.class, e.getMessage(), e);\n+            throw new DotDataException(e);\n+        }\n+\n+        return file.getValue();\n+    }\n+\n+    private File createJoinFile(final String hashId) throws IOException, DotDataException {\n+\n+        final File file = FileUtil.createTemporaryFile(\"dot-db-storage-recovery\", \".tmp\", true);\n+        try (final FileJoiner fileJoiner = new FileJoiner(file)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 580}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDAwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/RequestMetadata.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowNFrOHjUKrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowNFrOHjUKrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjYyMA==", "bodyText": "Codacy found an issue: Avoid unused imports such as 'com.dotmarketing.util.UtilMethods'", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792620", "createdAt": "2020-10-17T04:30:04Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/RequestMetadata.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.dotcms.storage;\n+\n+import com.dotmarketing.util.UtilMethods;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDAxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/GenerateMetadataConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowNVrOHjUKrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowNVrOHjUKrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjYyMQ==", "bodyText": "Codacy found an issue: Avoid using redundant field initializer for 'cacheKeySupplier'", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792621", "createdAt": "2020-10-17T04:30:05Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/GenerateMetadataConfig.java", "diffHunk": "@@ -0,0 +1,202 @@\n+package com.dotcms.storage;\n+\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Configuration to generate the meta data.\n+ *\n+ * @author jsanca\n+ */\n+public class GenerateMetadataConfig {\n+\n+    /**\n+     * Provides the key for the storage\n+     */\n+    private final StorageKey storageKey;\n+\n+    /**\n+     * If true, means the metadata output will be stores in the metaDataFileSupplier file\n+     */\n+    private final boolean store;\n+\n+    /**\n+     * if store is true, and you want to force always the file generation set this to true (keep in\n+     * mind it could be expensive)\n+     */\n+    private final boolean override;\n+\n+    /**\n+     * On huge file, we probably do not want to parse all the content, so this max will limited how\n+     * much do we want to read\n+     */\n+    private final long maxLength;\n+\n+    /**\n+     * {@link Predicate} filter the meta data key for the map result generation\n+     */\n+    private final Predicate<String> metaDataKeyFilter;\n+\n+    /**\n+     * If true, means the medatada output will be stores in the memory cache.\n+     */\n+    private final boolean cache;\n+\n+    /**\n+     * Cache key supplier, if cache is true\n+     */\n+    private final Supplier<String> cacheKeySupplier;\n+\n+    /**\n+     * If true, means the metadata generated will be full except if there is any metaDataKeyFilter,\n+     * only these fields will be accepted.\n+     */\n+    private final boolean full;\n+\n+    private GenerateMetadataConfig(final Builder builder) {\n+\n+        this.cache = builder.cache;\n+        this.cacheKeySupplier = builder.cacheKeySupplier;\n+        this.maxLength = builder.maxLength;\n+        this.storageKey = builder.storageKey;\n+        this.metaDataKeyFilter = builder.metaDataKeyFilter;\n+        this.override = builder.override;\n+        this.store = builder.store;\n+        this.full = builder.full;\n+    }\n+\n+    public StorageKey getStorageKey() {\n+        return storageKey;\n+    }\n+\n+    public boolean isStore() {\n+        return store;\n+    }\n+\n+    public boolean isOverride() {\n+        return override;\n+    }\n+\n+    public long getMaxLength() {\n+        return maxLength;\n+    }\n+\n+    public Predicate<String> getMetaDataKeyFilter() {\n+        return metaDataKeyFilter;\n+    }\n+\n+    public boolean isCache() {\n+        return cache;\n+    }\n+\n+    public Supplier<String> getCacheKeySupplier() {\n+        return cacheKeySupplier;\n+    }\n+\n+    public boolean isFull() {\n+        return full;\n+    }\n+\n+    public static final class Builder {\n+\n+        /**\n+         * If true, means the metadata generated will be full except if there is any\n+         * metaDataKeyFilter, only these fields will be accepted.\n+         */\n+        private boolean full;\n+\n+        /**\n+         * Provides the supplier to stores the metadata generated, if store is true\n+         */\n+        private StorageKey storageKey;\n+\n+        /**\n+         * If true, means the metadata output will be storage\n+         */\n+        private boolean store;\n+\n+        /**\n+         * if store is true, and you want to force always the file generation set this to true (keep\n+         * in mind it could be expensive)\n+         */\n+        private boolean override;\n+\n+        /**\n+         * On huge file, we probably do not want to parse all the content, so this max will limited\n+         * how much do we want to read\n+         */\n+        private long maxLength = FileStorageAPI.configuredMaxLength();\n+\n+        /**\n+         * {@link Predicate} filter the meta data key for the map result generation\n+         */\n+        private Predicate<String> metaDataKeyFilter = s -> true; // no filter by default\n+\n+        /**\n+         * If true, means the medatada output will be stores in the memory cache.\n+         */\n+        private boolean cache;\n+\n+        /**\n+         * Cache key supplier, if cache is true\n+         */\n+        private Supplier<String> cacheKeySupplier = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 143}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDAyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowNlrOHjUKrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowNlrOHjUKrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjYyMg==", "bodyText": "Codacy found an issue: Ensure that resources like this Connection object are closed after use", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792622", "createdAt": "2020-10-17T04:30:06Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,652 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.Encryptor.Hashing;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.nio.file.Files;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private static final String DATABASE_STORAGE_JDBC_POOL_NAME = \"DATABASE_STORAGE_JDBC_POOL_NAME\";\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method in case we want to store stuff outside our db\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(DATABASE_STORAGE_JDBC_POOL_NAME, StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate)\n+            throws DotDataException {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(DATABASE_STORAGE_JDBC_POOL_NAME, StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+            try {\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+                Logger.error(DataBaseStoragePersistenceAPIImpl.class, e.getMessage(), e);\n+                throw new DotDataException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        try (Connection connection = getConnection()) {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_group WHERE group_name = ?\")\n+                                        .addParam(groupNameLC)\n+                                        .loadObjectResults(connection);\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        } catch (SQLException e) {\n+            throw new DotDataException(e.getMessage(), e);\n+        }\n+        return exists.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String}\n+     * @param objectPath {@link String}\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath)\n+            throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean exists = new MutableBoolean(false);\n+\n+        try (Connection connection = getConnection()) {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage WHERE group_name = ? AND path = ?\")\n+                                        .addParam(groupNameLC).addParam(objectPathLC)\n+                                        .loadObjectResults(connection);\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        } catch (SQLException e) {\n+            throw new DotDataException(e.getMessage(), e);\n+        }\n+        ;\n+\n+        return exists.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) throws DotDataException {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options\n+     * or not.\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions)\n+            throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults(connection);\n+\n+            int count = deleteObjects(maps.stream().map(map -> map.get(\"hash\").toString())\n+                    .collect(Collectors.toSet()), dotConnect, connection);\n+\n+            final int storageEntriesCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage WHERE group_name = ?\", groupNameLC);\n+\n+            final int groupsCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_group WHERE group_name = ?\", groupNameLC);\n+\n+            Logger.info(this, () -> String\n+                    .format(\"total of `%d` objects allocated in `%d` removed for `%d` group. \",\n+                            storageEntriesCount, count, groupsCount));\n+            return storageEntriesCount;\n+        });\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     * @param path {   @link String} object path\n+     */\n+    @Override\n+    public boolean deleteObject(final String groupName, final String path) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        return wrapInTransaction(() -> {\n+            final Connection connection = getConnection();\n+\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> results = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ? \")\n+                    .addParam(groupNameLC).addParam(pathLC).loadObjectResults(connection);\n+\n+            if (!results.isEmpty()) {\n+                final String hash = (String) results.get(0).get(\"hash\");\n+                deleteObjects(ImmutableSet.of(hash), dotConnect, connection);\n+            }\n+            final int count = dotConnect\n+                    .executeUpdate(connection,\n+                            \"DELETE FROM storage WHERE group_name = ? AND path = ?\",\n+                            groupNameLC, pathLC);\n+            return count > 0;\n+        });\n+    }\n+\n+    /**\n+     * object reference removal\n+     *\n+     * @param hashSet object hash id\n+     * @param dotConnect DotConnect\n+     * @param connection external connection\n+     * @return count of all removed objects\n+     */\n+    private int deleteObjects(final Set<String> hashSet, final DotConnect dotConnect,\n+            final Connection connection)\n+            throws DotDataException {\n+        int count = 0;\n+        for (final String hash : hashSet) {\n+            //We could seriously benefit from a batch update here. The only problem is our current impl does not take an external connection\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_x_data WHERE data_hash = ?\", hash);\n+\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_data WHERE hash_id = ?\", hash);\n+\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<String> listGroups() throws DotDataException {\n+\n+        final MutableObject<List<String>> result = new MutableObject<>(Collections.emptyList());\n+\n+        try (Connection connection = getConnection()) {\n+\n+            final List<Map<String, Object>> results = Try\n+                    .of(() -> new DotConnect().setSQL(\"SELECT group_name FROM storage_group\")\n+                            .loadObjectResults(connection)).getOrElse(Collections::emptyList);\n+\n+            result.setValue(results.stream().map(map -> map.get(\"group_name\").toString())\n+                    .collect(CollectionsUtils.toImmutableList()));\n+        } catch (SQLException e) {\n+            throw new DotDataException(e.getMessage(), e);\n+        }\n+\n+        return result.getValue();\n+    }\n+\n+    @Override\n+    public Object pushFile(final String groupName, final String path,\n+            final File file, final Map<String, Serializable> extraMeta) throws DotDataException {\n+\n+        // 1. generate metadata\n+        // 2. see if the sha-256 exists\n+        // 2.1 if exists only insert on the reference\n+        // 2.2 if does not exists, insert a new one\n+        final Map<String, Serializable> metaData = processMetadata(file, extraMeta);\n+        final String fileHash = (String) metaData.get(FileStorageAPI.SHA226_META_KEY);\n+\n+        return wrapInTransaction(\n+                () -> {\n+                    if (!existsGroup(groupName)) {\n+                        throw new IllegalArgumentException(\"The groupName: \" + groupName +\n+                                \", does not exist.\");\n+                    }\n+                    if (this.existsObject(groupName, path)) {\n+                        Logger.warn(DataBaseStoragePersistenceAPIImpl.class,\n+                                String.format(\"Attempt to override entry `%s/%s` \", groupName,\n+                                        path));\n+                        return false;\n+                    }\n+                    return this.existsHash(fileHash) ?\n+                            this.pushFileReference(groupName, path, metaData, fileHash) :\n+                            this.pushNewFile(groupName, path, file, metaData);\n+                });\n+    }\n+\n+    /**\n+     * Selects directly on storage-data since hash is the primary key there.\n+     */\n+    private boolean existsHash(final String fileHash) throws DotDataException {\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        try (Connection connection = getConnection()) {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_data WHERE hash_id = ?\")\n+                                        .addParam(fileHash)\n+                                        .loadObjectResults(connection);\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        } catch (SQLException e) {\n+            throw new DotDataException(e.getMessage(), e);\n+        }\n+\n+        return exists.getValue();\n+    }\n+\n+    private Map<String, Serializable> processMetadata(final File file,\n+            final Map<String, Serializable> extraMeta) {\n+\n+        if (UtilMethods.isSet(extraMeta) && extraMeta.containsKey(FileStorageAPI.SHA226_META_KEY)) {\n+\n+            return extraMeta;\n+        }\n+\n+        final ImmutableMap.Builder<String, Serializable> metaData = new ImmutableMap.Builder<>();\n+\n+        if (UtilMethods.isSet(extraMeta)) {\n+\n+            metaData.putAll(extraMeta);\n+        }\n+\n+        metaData.putAll(APILocator.getFileStorageAPI().generateRawBasicMetaData(file));\n+\n+        return metaData.build();\n+    }\n+\n+    private Object pushFileReference(final String groupName, final String path,\n+            final Map<String, Serializable> extraMeta, final String objectHash) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try {\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+            return true;\n+        } catch (DotDataException | IOException e) {\n+            Logger.error(DataBaseStoragePersistenceAPIImpl.class, e.getMessage(), e);\n+            throw new DotDataException(e);\n+        }\n+    }\n+\n+    private Object pushNewFile(final String groupName, final String path, final File file,\n+            final Map<String, Serializable> extraMeta) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try (final FileByteSplitter fileSplitter = new FileByteSplitter(file)) {\n+\n+            final HashBuilder objectHashBuilder = Encryptor.Hashing.sha256();\n+            final List<String> chunkHashes = new ArrayList<>();\n+\n+            for (final Tuple2<byte[], Integer> bytesRead : fileSplitter) {\n+\n+                objectHashBuilder.append(bytesRead._1(), bytesRead._2());\n+                final String chunkHash = Encryptor.Hashing.sha256().append\n+                        (bytesRead._1(), bytesRead._2()).buildUnixHash();\n+                chunkHashes.add(chunkHash);\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_data(hash_id, data) VALUES (?, ?)\",\n+                        chunkHash,\n+                        bytesRead._1().length == bytesRead._2() ?\n+                                bytesRead._1() : this.chunkBytes(bytesRead._2(), bytesRead._1()));\n+            }\n+\n+            final String objectHash = objectHashBuilder.buildUnixHash();\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+\n+            int order = 1;\n+            for (final String chunkHash : chunkHashes) {\n+\n+                new DotConnect().executeUpdate(this.getConnection(),\n+                        \"INSERT INTO storage_x_data(storage_hash, data_hash, data_order) VALUES (?, ?, ?)\",\n+                        objectHash, chunkHash, order++);\n+            }\n+\n+            return true;\n+        } catch (DotDataException | NoSuchAlgorithmException | IOException e) {\n+            Logger.error(DataBaseStoragePersistenceAPIImpl.class, e.getMessage(), e);\n+            throw new DotRuntimeException(e);\n+        }\n+    }\n+\n+    private byte[] chunkBytes(final int bytesLength, final byte[] bytes) {\n+\n+        final byte[] chunkedArray = new byte[bytesLength];\n+\n+        System.arraycopy(bytes, 0, chunkedArray, 0, bytesLength);\n+\n+        return chunkedArray;\n+    }\n+\n+    @Override\n+    public Object pushObject(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Serializable> extraMeta)\n+            throws DotDataException {\n+        try {\n+            final File file = FileUtil.createTemporaryFile(\"object-storage\", \".tmp\");\n+            writeToFile(writerDelegate, object, file);\n+            return this.pushFile(groupName, path, file, extraMeta);\n+        } catch (Exception e) {\n+            Logger.error(DataBaseStoragePersistenceAPIImpl.class, e.getMessage(), e);\n+            throw new DotDataException(e);\n+        }\n+    }\n+\n+    /**\n+     * This will write directly from the Serializer delegate right into a file. No in memory loading\n+     * takes place like this.\n+     */\n+    private void writeToFile(final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, File file) throws IOException {\n+\n+        try (final OutputStream outputStream = Files.newOutputStream(file.toPath())) {\n+            writerDelegate.write(outputStream, object);\n+        }\n+    }\n+\n+    @Override\n+    public Future<Object> pushFileAsync(final String groupName, final String path, final File file,\n+            final Map<String, Serializable> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushFile(groupName, path, file, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public Future<Object> pushObjectAsync(final String bucketName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Serializable> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushObject(bucketName, path, writerDelegate, object, extraMeta)\n+        );\n+    }\n+\n+    @Override\n+    public File pullFile(final String groupName, final String path) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        final MutableObject<File> file = new MutableObject<>(null);\n+\n+        try (Connection connection = getConnection()) {\n+            final List<Map<String, Object>> storageResult = Try.of(() ->\n+                    new DotConnect()\n+                            .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ?\")\n+                            .addParam(groupNameLC).addParam(pathLC)\n+                            .loadObjectResults(connection)).getOrElse(Collections::emptyList);\n+\n+            if (!storageResult.isEmpty()) {\n+\n+                final Optional<Object> objectOpt = storageResult.stream()\n+                        .map(map -> map.get(\"hash\")).findFirst();\n+\n+                final String objectHash = (String) objectOpt.get();\n+                if (UtilMethods.isSet(objectHash)) {\n+                    file.setValue(this.createJoinFile(objectHash));\n+                }\n+            } else {\n+                throw new DoesNotExistException(\n+                        \"The storage, group: \" + groupName + \", path: \" + path\n+                                + \" does not exists\");\n+            }\n+\n+        } catch (Exception e) {\n+            Logger.error(DataBaseStoragePersistenceAPIImpl.class, e.getMessage(), e);\n+            throw new DotDataException(e);\n+        }\n+\n+        return file.getValue();\n+    }\n+\n+    private File createJoinFile(final String hashId) throws IOException, DotDataException {\n+\n+        final File file = FileUtil.createTemporaryFile(\"dot-db-storage-recovery\", \".tmp\", true);\n+        try (final FileJoiner fileJoiner = new FileJoiner(file)) {\n+            final HashBuilder fileHashBuilder = Try.of(Hashing::sha256)\n+                    .getOrElseThrow(DotRuntimeException::new);\n+            final Connection connection = this.getConnection();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 583}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDEwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/GenerateMetadataConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowN1rOHjUKtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowN1rOHjUKtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjYzMA==", "bodyText": "Codacy found an issue: Field metaDataKeyFilter has the same name as a method", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792630", "createdAt": "2020-10-17T04:30:07Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/GenerateMetadataConfig.java", "diffHunk": "@@ -0,0 +1,202 @@\n+package com.dotcms.storage;\n+\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Configuration to generate the meta data.\n+ *\n+ * @author jsanca\n+ */\n+public class GenerateMetadataConfig {\n+\n+    /**\n+     * Provides the key for the storage\n+     */\n+    private final StorageKey storageKey;\n+\n+    /**\n+     * If true, means the metadata output will be stores in the metaDataFileSupplier file\n+     */\n+    private final boolean store;\n+\n+    /**\n+     * if store is true, and you want to force always the file generation set this to true (keep in\n+     * mind it could be expensive)\n+     */\n+    private final boolean override;\n+\n+    /**\n+     * On huge file, we probably do not want to parse all the content, so this max will limited how\n+     * much do we want to read\n+     */\n+    private final long maxLength;\n+\n+    /**\n+     * {@link Predicate} filter the meta data key for the map result generation\n+     */\n+    private final Predicate<String> metaDataKeyFilter;\n+\n+    /**\n+     * If true, means the medatada output will be stores in the memory cache.\n+     */\n+    private final boolean cache;\n+\n+    /**\n+     * Cache key supplier, if cache is true\n+     */\n+    private final Supplier<String> cacheKeySupplier;\n+\n+    /**\n+     * If true, means the metadata generated will be full except if there is any metaDataKeyFilter,\n+     * only these fields will be accepted.\n+     */\n+    private final boolean full;\n+\n+    private GenerateMetadataConfig(final Builder builder) {\n+\n+        this.cache = builder.cache;\n+        this.cacheKeySupplier = builder.cacheKeySupplier;\n+        this.maxLength = builder.maxLength;\n+        this.storageKey = builder.storageKey;\n+        this.metaDataKeyFilter = builder.metaDataKeyFilter;\n+        this.override = builder.override;\n+        this.store = builder.store;\n+        this.full = builder.full;\n+    }\n+\n+    public StorageKey getStorageKey() {\n+        return storageKey;\n+    }\n+\n+    public boolean isStore() {\n+        return store;\n+    }\n+\n+    public boolean isOverride() {\n+        return override;\n+    }\n+\n+    public long getMaxLength() {\n+        return maxLength;\n+    }\n+\n+    public Predicate<String> getMetaDataKeyFilter() {\n+        return metaDataKeyFilter;\n+    }\n+\n+    public boolean isCache() {\n+        return cache;\n+    }\n+\n+    public Supplier<String> getCacheKeySupplier() {\n+        return cacheKeySupplier;\n+    }\n+\n+    public boolean isFull() {\n+        return full;\n+    }\n+\n+    public static final class Builder {\n+\n+        /**\n+         * If true, means the metadata generated will be full except if there is any\n+         * metaDataKeyFilter, only these fields will be accepted.\n+         */\n+        private boolean full;\n+\n+        /**\n+         * Provides the supplier to stores the metadata generated, if store is true\n+         */\n+        private StorageKey storageKey;\n+\n+        /**\n+         * If true, means the metadata output will be storage\n+         */\n+        private boolean store;\n+\n+        /**\n+         * if store is true, and you want to force always the file generation set this to true (keep\n+         * in mind it could be expensive)\n+         */\n+        private boolean override;\n+\n+        /**\n+         * On huge file, we probably do not want to parse all the content, so this max will limited\n+         * how much do we want to read\n+         */\n+        private long maxLength = FileStorageAPI.configuredMaxLength();\n+\n+        /**\n+         * {@link Predicate} filter the meta data key for the map result generation\n+         */\n+        private Predicate<String> metaDataKeyFilter = s -> true; // no filter by default", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDE0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowOFrOHjUKug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowOFrOHjUKug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjYzNA==", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792634", "createdAt": "2020-10-17T04:30:08Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,652 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.Encryptor.Hashing;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.nio.file.Files;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private static final String DATABASE_STORAGE_JDBC_POOL_NAME = \"DATABASE_STORAGE_JDBC_POOL_NAME\";\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method in case we want to store stuff outside our db\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(DATABASE_STORAGE_JDBC_POOL_NAME, StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate)\n+            throws DotDataException {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(DATABASE_STORAGE_JDBC_POOL_NAME, StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+            try {\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDE1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/TikaMetadataGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowOVrOHjUKuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDowOVrOHjUKuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjYzNQ==", "bodyText": "Codacy found an issue: Avoid unused imports such as 'java.util.function.Function'", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792635", "createdAt": "2020-10-17T04:30:09Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/TikaMetadataGenerator.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.tika.TikaUtils;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.Logger;\n+import com.google.common.collect.ImmutableMap;\n+import java.io.File;\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.function.Function;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDE2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/RequestMetadata.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxMFrOHjUKvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxMFrOHjUKvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjYzNg==", "bodyText": "Codacy found an issue: Field wrapMetadataMapForCache has the same name as a method", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792636", "createdAt": "2020-10-17T04:30:10Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/RequestMetadata.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.dotcms.storage;\n+\n+import com.dotmarketing.util.UtilMethods;\n+import java.io.Serializable;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Encapsulates the parameters to request the metadata\n+ * it could be by cache or file system\n+ * @author jsanca\n+ */\n+public class RequestMetadata {\n+\n+    /**\n+     * Provides the key for the storage\n+     */\n+    private final StorageKey    storageKey;\n+\n+    /**\n+     * If true, means the medatada output will be stores in the memory cache.\n+     */\n+    private final boolean           cache;\n+\n+    /**\n+     * Cache key supplier, if cache is true\n+     */\n+    private final Supplier<String>  cacheKeySupplier;\n+\n+    /**\n+     * In case the metadata is retrieved from the storage instead of the cache,\n+     * you can wrap the metadata recovery from the storage in order to add, mod or remove values\n+     */\n+    private final Function<Map<String, Serializable>, Map<String, Serializable>> wrapMetadataMapForCache;\n+\n+    /**\n+     * Builder based constructor\n+     * @param builder\n+     */\n+    private RequestMetadata(final Builder builder) {\n+        this.cache                   = builder.cache;\n+        this.cacheKeySupplier        = builder.cacheKeySupplier;\n+        this.storageKey              = builder.storageKey;\n+        this.wrapMetadataMapForCache = builder.wrapMetadataMapForCache;\n+    }\n+\n+    public StorageKey getStorageKey() {\n+        return storageKey;\n+    }\n+\n+    /**\n+     * cache setting read\n+     * @return\n+     */\n+    public boolean isCache() {\n+        return cache;\n+    }\n+\n+    public Supplier<String> getCacheKeySupplier() {\n+        return cacheKeySupplier;\n+    }\n+\n+    public Function<Map<String, Serializable>, Map<String, Serializable>> getWrapMetadataMapForCache() {\n+        return wrapMetadataMapForCache;\n+    }\n+\n+    /**\n+     * Convenience Builder\n+     */\n+    public static final class Builder {\n+\n+        /**\n+         * Provides the key for the storage\n+         */\n+        private  StorageKey    storageKey;\n+\n+        /**\n+         * If true, means the medatada output will be stores in the memory cache.\n+         */\n+        private boolean           cache;\n+\n+        /**\n+         * Cache key supplier, if cache is true\n+         */\n+        private Supplier<String>  cacheKeySupplier;\n+\n+        /**\n+         * In case the metadata is retrieved from the storage instead of the cache,\n+         * you can wrap the metadata recovery from the storage in order to add, mod or remove values\n+         */\n+        private Function<Map<String, Serializable>, Map<String, Serializable>> wrapMetadataMapForCache = map-> map;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDE3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxMVrOHjUKvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxMVrOHjUKvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjYzNw==", "bodyText": "Codacy found an issue: Ensure that resources like this Connection object are closed after use", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792637", "createdAt": "2020-10-17T04:30:11Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,652 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.Encryptor.Hashing;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.nio.file.Files;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private static final String DATABASE_STORAGE_JDBC_POOL_NAME = \"DATABASE_STORAGE_JDBC_POOL_NAME\";\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method in case we want to store stuff outside our db\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(DATABASE_STORAGE_JDBC_POOL_NAME, StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate)\n+            throws DotDataException {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(DATABASE_STORAGE_JDBC_POOL_NAME, StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+            try {\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+                Logger.error(DataBaseStoragePersistenceAPIImpl.class, e.getMessage(), e);\n+                throw new DotDataException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDE5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxMlrOHjUKvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxMlrOHjUKvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjYzOQ==", "bodyText": "Codacy found an issue: Unnecessary modifier 'final' on resource specification 'fileSplitter': resource specifications are implicitly final", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792639", "createdAt": "2020-10-17T04:30:12Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,652 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.Encryptor.Hashing;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.nio.file.Files;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private static final String DATABASE_STORAGE_JDBC_POOL_NAME = \"DATABASE_STORAGE_JDBC_POOL_NAME\";\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method in case we want to store stuff outside our db\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(DATABASE_STORAGE_JDBC_POOL_NAME, StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate)\n+            throws DotDataException {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(DATABASE_STORAGE_JDBC_POOL_NAME, StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+            try {\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+                Logger.error(DataBaseStoragePersistenceAPIImpl.class, e.getMessage(), e);\n+                throw new DotDataException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        try (Connection connection = getConnection()) {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_group WHERE group_name = ?\")\n+                                        .addParam(groupNameLC)\n+                                        .loadObjectResults(connection);\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        } catch (SQLException e) {\n+            throw new DotDataException(e.getMessage(), e);\n+        }\n+        return exists.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String}\n+     * @param objectPath {@link String}\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath)\n+            throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean exists = new MutableBoolean(false);\n+\n+        try (Connection connection = getConnection()) {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage WHERE group_name = ? AND path = ?\")\n+                                        .addParam(groupNameLC).addParam(objectPathLC)\n+                                        .loadObjectResults(connection);\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        } catch (SQLException e) {\n+            throw new DotDataException(e.getMessage(), e);\n+        }\n+        ;\n+\n+        return exists.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) throws DotDataException {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options\n+     * or not.\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions)\n+            throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults(connection);\n+\n+            int count = deleteObjects(maps.stream().map(map -> map.get(\"hash\").toString())\n+                    .collect(Collectors.toSet()), dotConnect, connection);\n+\n+            final int storageEntriesCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage WHERE group_name = ?\", groupNameLC);\n+\n+            final int groupsCount = dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_group WHERE group_name = ?\", groupNameLC);\n+\n+            Logger.info(this, () -> String\n+                    .format(\"total of `%d` objects allocated in `%d` removed for `%d` group. \",\n+                            storageEntriesCount, count, groupsCount));\n+            return storageEntriesCount;\n+        });\n+\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     * @param path {   @link String} object path\n+     */\n+    @Override\n+    public boolean deleteObject(final String groupName, final String path) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        return wrapInTransaction(() -> {\n+            final Connection connection = getConnection();\n+\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> results = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ? AND path = ? \")\n+                    .addParam(groupNameLC).addParam(pathLC).loadObjectResults(connection);\n+\n+            if (!results.isEmpty()) {\n+                final String hash = (String) results.get(0).get(\"hash\");\n+                deleteObjects(ImmutableSet.of(hash), dotConnect, connection);\n+            }\n+            final int count = dotConnect\n+                    .executeUpdate(connection,\n+                            \"DELETE FROM storage WHERE group_name = ? AND path = ?\",\n+                            groupNameLC, pathLC);\n+            return count > 0;\n+        });\n+    }\n+\n+    /**\n+     * object reference removal\n+     *\n+     * @param hashSet object hash id\n+     * @param dotConnect DotConnect\n+     * @param connection external connection\n+     * @return count of all removed objects\n+     */\n+    private int deleteObjects(final Set<String> hashSet, final DotConnect dotConnect,\n+            final Connection connection)\n+            throws DotDataException {\n+        int count = 0;\n+        for (final String hash : hashSet) {\n+            //We could seriously benefit from a batch update here. The only problem is our current impl does not take an external connection\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_x_data WHERE data_hash = ?\", hash);\n+\n+            count += dotConnect.executeUpdate(connection,\n+                    \"DELETE FROM storage_data WHERE hash_id = ?\", hash);\n+\n+        }\n+        return count;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public List<String> listGroups() throws DotDataException {\n+\n+        final MutableObject<List<String>> result = new MutableObject<>(Collections.emptyList());\n+\n+        try (Connection connection = getConnection()) {\n+\n+            final List<Map<String, Object>> results = Try\n+                    .of(() -> new DotConnect().setSQL(\"SELECT group_name FROM storage_group\")\n+                            .loadObjectResults(connection)).getOrElse(Collections::emptyList);\n+\n+            result.setValue(results.stream().map(map -> map.get(\"group_name\").toString())\n+                    .collect(CollectionsUtils.toImmutableList()));\n+        } catch (SQLException e) {\n+            throw new DotDataException(e.getMessage(), e);\n+        }\n+\n+        return result.getValue();\n+    }\n+\n+    @Override\n+    public Object pushFile(final String groupName, final String path,\n+            final File file, final Map<String, Serializable> extraMeta) throws DotDataException {\n+\n+        // 1. generate metadata\n+        // 2. see if the sha-256 exists\n+        // 2.1 if exists only insert on the reference\n+        // 2.2 if does not exists, insert a new one\n+        final Map<String, Serializable> metaData = processMetadata(file, extraMeta);\n+        final String fileHash = (String) metaData.get(FileStorageAPI.SHA226_META_KEY);\n+\n+        return wrapInTransaction(\n+                () -> {\n+                    if (!existsGroup(groupName)) {\n+                        throw new IllegalArgumentException(\"The groupName: \" + groupName +\n+                                \", does not exist.\");\n+                    }\n+                    if (this.existsObject(groupName, path)) {\n+                        Logger.warn(DataBaseStoragePersistenceAPIImpl.class,\n+                                String.format(\"Attempt to override entry `%s/%s` \", groupName,\n+                                        path));\n+                        return false;\n+                    }\n+                    return this.existsHash(fileHash) ?\n+                            this.pushFileReference(groupName, path, metaData, fileHash) :\n+                            this.pushNewFile(groupName, path, file, metaData);\n+                });\n+    }\n+\n+    /**\n+     * Selects directly on storage-data since hash is the primary key there.\n+     */\n+    private boolean existsHash(final String fileHash) throws DotDataException {\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        try (Connection connection = getConnection()) {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_data WHERE hash_id = ?\")\n+                                        .addParam(fileHash)\n+                                        .loadObjectResults(connection);\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        } catch (SQLException e) {\n+            throw new DotDataException(e.getMessage(), e);\n+        }\n+\n+        return exists.getValue();\n+    }\n+\n+    private Map<String, Serializable> processMetadata(final File file,\n+            final Map<String, Serializable> extraMeta) {\n+\n+        if (UtilMethods.isSet(extraMeta) && extraMeta.containsKey(FileStorageAPI.SHA226_META_KEY)) {\n+\n+            return extraMeta;\n+        }\n+\n+        final ImmutableMap.Builder<String, Serializable> metaData = new ImmutableMap.Builder<>();\n+\n+        if (UtilMethods.isSet(extraMeta)) {\n+\n+            metaData.putAll(extraMeta);\n+        }\n+\n+        metaData.putAll(APILocator.getFileStorageAPI().generateRawBasicMetaData(file));\n+\n+        return metaData.build();\n+    }\n+\n+    private Object pushFileReference(final String groupName, final String path,\n+            final Map<String, Serializable> extraMeta, final String objectHash) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try {\n+            final StringWriter metaDataJsonWriter = new StringWriter();\n+            this.objectMapper.writeValue(metaDataJsonWriter, extraMeta);\n+            new DotConnect().executeUpdate(this.getConnection(),\n+                    \"INSERT INTO storage(hash, path, group_name, metadata) VALUES (?, ?, ?, ?)\",\n+                    objectHash, pathLC, groupNameLC, metaDataJsonWriter.toString());\n+            return true;\n+        } catch (DotDataException | IOException e) {\n+            Logger.error(DataBaseStoragePersistenceAPIImpl.class, e.getMessage(), e);\n+            throw new DotDataException(e);\n+        }\n+    }\n+\n+    private Object pushNewFile(final String groupName, final String path, final File file,\n+            final Map<String, Serializable> extraMeta) {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String pathLC = path.toLowerCase();\n+        try (final FileByteSplitter fileSplitter = new FileByteSplitter(file)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 446}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDIwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/StorageKey.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxM1rOHjUKwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxM1rOHjUKwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjY0MA==", "bodyText": "Codacy found an issue: Field storage has the same name as a method", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792640", "createdAt": "2020-10-17T04:30:13Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/StorageKey.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package com.dotcms.storage;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Encapsulates a storage key, it has the key (for instance the path)\n+ * the group (for instance the bucket, folder, space, etc)\n+ * Storage {@link StorageType}\n+ * @author jsanca\n+ */\n+public class StorageKey implements Serializable {\n+\n+    //Key components\n+    private final String path;\n+    private final String group;\n+    private final StorageType storage;\n+\n+    /**\n+     * Builder based constructor\n+     * @param builder\n+     */\n+    private StorageKey(final Builder builder) {\n+\n+        this.path = builder.path;\n+        this.group = builder.group;\n+        this.storage    = builder.storage;\n+    }\n+\n+    /**\n+     * read only path\n+     * @return\n+     */\n+    public String getPath() {\n+        return path;\n+    }\n+\n+    /**\n+     * read only group\n+     * @return\n+     */\n+    public String getGroup() {\n+        return group;\n+    }\n+\n+    /**\n+     * read-only storage\n+     * @return\n+     */\n+    public StorageType getStorage() {\n+        return storage;\n+    }\n+\n+    /**\n+     * Convenience builder\n+     */\n+    public static final class Builder {\n+\n+        private String path;\n+        private String group;\n+        private StorageType storage;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDIxOnYy", "diffSide": "LEFT", "path": "dotCMS/src/main/java/com/liferay/util/Encryptor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxNFrOHjUKwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxNFrOHjUKwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjY0MQ==", "bodyText": "Codacy found an issue: All methods are static.  Consider using a utility class instead. Alternatively, you could add a private constructor or make the class abstract to silence this warning.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792641", "createdAt": "2020-10-17T04:30:14Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/liferay/util/Encryptor.java", "diffHunk": "@@ -158,4 +162,60 @@ public static String encrypt(Key key, String plainText)\n \r\n \tprivate static final Log _log = LogFactory.getLog(Encryptor.class);\r\n \r\n-}\n\\ No newline at end of file", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDIyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/RequestMetadata.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxNVrOHjUKwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxNVrOHjUKwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjY0Mg==", "bodyText": "Codacy found an issue: Field cache has the same name as a method", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792642", "createdAt": "2020-10-17T04:30:15Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/RequestMetadata.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.dotcms.storage;\n+\n+import com.dotmarketing.util.UtilMethods;\n+import java.io.Serializable;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Encapsulates the parameters to request the metadata\n+ * it could be by cache or file system\n+ * @author jsanca\n+ */\n+public class RequestMetadata {\n+\n+    /**\n+     * Provides the key for the storage\n+     */\n+    private final StorageKey    storageKey;\n+\n+    /**\n+     * If true, means the medatada output will be stores in the memory cache.\n+     */\n+    private final boolean           cache;\n+\n+    /**\n+     * Cache key supplier, if cache is true\n+     */\n+    private final Supplier<String>  cacheKeySupplier;\n+\n+    /**\n+     * In case the metadata is retrieved from the storage instead of the cache,\n+     * you can wrap the metadata recovery from the storage in order to add, mod or remove values\n+     */\n+    private final Function<Map<String, Serializable>, Map<String, Serializable>> wrapMetadataMapForCache;\n+\n+    /**\n+     * Builder based constructor\n+     * @param builder\n+     */\n+    private RequestMetadata(final Builder builder) {\n+        this.cache                   = builder.cache;\n+        this.cacheKeySupplier        = builder.cacheKeySupplier;\n+        this.storageKey              = builder.storageKey;\n+        this.wrapMetadataMapForCache = builder.wrapMetadataMapForCache;\n+    }\n+\n+    public StorageKey getStorageKey() {\n+        return storageKey;\n+    }\n+\n+    /**\n+     * cache setting read\n+     * @return\n+     */\n+    public boolean isCache() {\n+        return cache;\n+    }\n+\n+    public Supplier<String> getCacheKeySupplier() {\n+        return cacheKeySupplier;\n+    }\n+\n+    public Function<Map<String, Serializable>, Map<String, Serializable>> getWrapMetadataMapForCache() {\n+        return wrapMetadataMapForCache;\n+    }\n+\n+    /**\n+     * Convenience Builder\n+     */\n+    public static final class Builder {\n+\n+        /**\n+         * Provides the key for the storage\n+         */\n+        private  StorageKey    storageKey;\n+\n+        /**\n+         * If true, means the medatada output will be stores in the memory cache.\n+         */\n+        private boolean           cache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDIzOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxNlrOHjUKxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxNlrOHjUKxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjY0NA==", "bodyText": "Codacy found an issue: Avoid unused imports such as 'java.io.ByteArrayInputStream'", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792644", "createdAt": "2020-10-17T04:30:16Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,652 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.Encryptor.Hashing;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.io.ByteArrayInputStream;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDI0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/RequestMetadata.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxN1rOHjUKxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxN1rOHjUKxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjY0NQ==", "bodyText": "Codacy found an issue: Field storageKey has the same name as a method", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792645", "createdAt": "2020-10-17T04:30:17Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/RequestMetadata.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.dotcms.storage;\n+\n+import com.dotmarketing.util.UtilMethods;\n+import java.io.Serializable;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Encapsulates the parameters to request the metadata\n+ * it could be by cache or file system\n+ * @author jsanca\n+ */\n+public class RequestMetadata {\n+\n+    /**\n+     * Provides the key for the storage\n+     */\n+    private final StorageKey    storageKey;\n+\n+    /**\n+     * If true, means the medatada output will be stores in the memory cache.\n+     */\n+    private final boolean           cache;\n+\n+    /**\n+     * Cache key supplier, if cache is true\n+     */\n+    private final Supplier<String>  cacheKeySupplier;\n+\n+    /**\n+     * In case the metadata is retrieved from the storage instead of the cache,\n+     * you can wrap the metadata recovery from the storage in order to add, mod or remove values\n+     */\n+    private final Function<Map<String, Serializable>, Map<String, Serializable>> wrapMetadataMapForCache;\n+\n+    /**\n+     * Builder based constructor\n+     * @param builder\n+     */\n+    private RequestMetadata(final Builder builder) {\n+        this.cache                   = builder.cache;\n+        this.cacheKeySupplier        = builder.cacheKeySupplier;\n+        this.storageKey              = builder.storageKey;\n+        this.wrapMetadataMapForCache = builder.wrapMetadataMapForCache;\n+    }\n+\n+    public StorageKey getStorageKey() {\n+        return storageKey;\n+    }\n+\n+    /**\n+     * cache setting read\n+     * @return\n+     */\n+    public boolean isCache() {\n+        return cache;\n+    }\n+\n+    public Supplier<String> getCacheKeySupplier() {\n+        return cacheKeySupplier;\n+    }\n+\n+    public Function<Map<String, Serializable>, Map<String, Serializable>> getWrapMetadataMapForCache() {\n+        return wrapMetadataMapForCache;\n+    }\n+\n+    /**\n+     * Convenience Builder\n+     */\n+    public static final class Builder {\n+\n+        /**\n+         * Provides the key for the storage\n+         */\n+        private  StorageKey    storageKey;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDI1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/GenerateMetadataConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxN1rOHjUKxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxN1rOHjUKxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjY0Ng==", "bodyText": "Codacy found an issue: Field cache has the same name as a method", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792646", "createdAt": "2020-10-17T04:30:17Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/GenerateMetadataConfig.java", "diffHunk": "@@ -0,0 +1,202 @@\n+package com.dotcms.storage;\n+\n+import java.util.function.Predicate;\n+import java.util.function.Supplier;\n+\n+/**\n+ * Configuration to generate the meta data.\n+ *\n+ * @author jsanca\n+ */\n+public class GenerateMetadataConfig {\n+\n+    /**\n+     * Provides the key for the storage\n+     */\n+    private final StorageKey storageKey;\n+\n+    /**\n+     * If true, means the metadata output will be stores in the metaDataFileSupplier file\n+     */\n+    private final boolean store;\n+\n+    /**\n+     * if store is true, and you want to force always the file generation set this to true (keep in\n+     * mind it could be expensive)\n+     */\n+    private final boolean override;\n+\n+    /**\n+     * On huge file, we probably do not want to parse all the content, so this max will limited how\n+     * much do we want to read\n+     */\n+    private final long maxLength;\n+\n+    /**\n+     * {@link Predicate} filter the meta data key for the map result generation\n+     */\n+    private final Predicate<String> metaDataKeyFilter;\n+\n+    /**\n+     * If true, means the medatada output will be stores in the memory cache.\n+     */\n+    private final boolean cache;\n+\n+    /**\n+     * Cache key supplier, if cache is true\n+     */\n+    private final Supplier<String> cacheKeySupplier;\n+\n+    /**\n+     * If true, means the metadata generated will be full except if there is any metaDataKeyFilter,\n+     * only these fields will be accepted.\n+     */\n+    private final boolean full;\n+\n+    private GenerateMetadataConfig(final Builder builder) {\n+\n+        this.cache = builder.cache;\n+        this.cacheKeySupplier = builder.cacheKeySupplier;\n+        this.maxLength = builder.maxLength;\n+        this.storageKey = builder.storageKey;\n+        this.metaDataKeyFilter = builder.metaDataKeyFilter;\n+        this.override = builder.override;\n+        this.store = builder.store;\n+        this.full = builder.full;\n+    }\n+\n+    public StorageKey getStorageKey() {\n+        return storageKey;\n+    }\n+\n+    public boolean isStore() {\n+        return store;\n+    }\n+\n+    public boolean isOverride() {\n+        return override;\n+    }\n+\n+    public long getMaxLength() {\n+        return maxLength;\n+    }\n+\n+    public Predicate<String> getMetaDataKeyFilter() {\n+        return metaDataKeyFilter;\n+    }\n+\n+    public boolean isCache() {\n+        return cache;\n+    }\n+\n+    public Supplier<String> getCacheKeySupplier() {\n+        return cacheKeySupplier;\n+    }\n+\n+    public boolean isFull() {\n+        return full;\n+    }\n+\n+    public static final class Builder {\n+\n+        /**\n+         * If true, means the metadata generated will be full except if there is any\n+         * metaDataKeyFilter, only these fields will be accepted.\n+         */\n+        private boolean full;\n+\n+        /**\n+         * Provides the supplier to stores the metadata generated, if store is true\n+         */\n+        private StorageKey storageKey;\n+\n+        /**\n+         * If true, means the metadata output will be storage\n+         */\n+        private boolean store;\n+\n+        /**\n+         * if store is true, and you want to force always the file generation set this to true (keep\n+         * in mind it could be expensive)\n+         */\n+        private boolean override;\n+\n+        /**\n+         * On huge file, we probably do not want to parse all the content, so this max will limited\n+         * how much do we want to read\n+         */\n+        private long maxLength = FileStorageAPI.configuredMaxLength();\n+\n+        /**\n+         * {@link Predicate} filter the meta data key for the map result generation\n+         */\n+        private Predicate<String> metaDataKeyFilter = s -> true; // no filter by default\n+\n+        /**\n+         * If true, means the medatada output will be stores in the memory cache.\n+         */\n+        private boolean cache;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDI2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxOFrOHjUKxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxOFrOHjUKxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjY0Nw==", "bodyText": "Codacy found an issue: Avoid unused imports such as 'org.apache.commons.io.FileUtils'", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792647", "createdAt": "2020-10-17T04:30:18Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,652 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.Encryptor.Hashing;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.nio.file.Files;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDMxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxOVrOHjUKzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoxOVrOHjUKzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjY1Mg==", "bodyText": "Codacy found an issue: The String literal \"hash\" appears 4 times in this file; the first occurrence is on line 321", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792652", "createdAt": "2020-10-17T04:30:19Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/DataBaseStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,652 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.util.CloseUtils;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotcms.util.FileByteSplitter;\n+import com.dotcms.util.FileJoiner;\n+import com.dotcms.util.ReturnableDelegate;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.db.DbConnectionFactory;\n+import com.dotmarketing.db.LocalTransaction;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.exception.DotCorruptedDataException;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.FileUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import com.liferay.util.Encryptor;\n+import com.liferay.util.Encryptor.Hashing;\n+import com.liferay.util.HashBuilder;\n+import com.liferay.util.StringPool;\n+import io.vavr.Tuple2;\n+import io.vavr.control.Try;\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.io.StringWriter;\n+import java.nio.file.Files;\n+import java.security.NoSuchAlgorithmException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.stream.Collectors;\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.lang3.mutable.MutableBoolean;\n+import org.apache.commons.lang3.mutable.MutableObject;\n+\n+/**\n+ * Represents a Storage on the database It supports big files since provides the ability to split\n+ * fat object in smaller pieces, see {@link FileByteSplitter} and {@link com.dotcms.util.FileJoiner}\n+ * to get more details about the process\n+ *\n+ * @author jsanca\n+ */\n+public class DataBaseStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private static final String DATABASE_STORAGE_JDBC_POOL_NAME = \"DATABASE_STORAGE_JDBC_POOL_NAME\";\n+    private final ObjectMapper objectMapper = new ObjectMapper();\n+\n+    /**\n+     * custom external connection provider method in case we want to store stuff outside our db\n+     */\n+    protected Connection getConnection() {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(DATABASE_STORAGE_JDBC_POOL_NAME, StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        return isExternalPool ?\n+                DbConnectionFactory.getConnection(jdbcPool) :\n+                DbConnectionFactory.getConnection();\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     */\n+    protected <T> T wrapInTransaction(final ReturnableDelegate<T> delegate)\n+            throws DotDataException {\n+\n+        final String jdbcPool = Config\n+                .getStringProperty(DATABASE_STORAGE_JDBC_POOL_NAME, StringPool.BLANK);\n+        final boolean isExternalPool = UtilMethods.isSet(jdbcPool);\n+\n+        if (isExternalPool) {\n+            return this.wrapInExternalTransaction(delegate, jdbcPool);\n+        } else {\n+            try {\n+                return LocalTransaction.wrapReturnWithListeners(delegate);\n+            } catch (Exception e) {\n+                Logger.error(DataBaseStoragePersistenceAPIImpl.class, e.getMessage(), e);\n+                throw new DotDataException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * custom transaction wrapper\n+     */\n+    private <T> T wrapInExternalTransaction(final ReturnableDelegate<T> delegate,\n+            final String jdbcPool) {\n+\n+        T result = null;\n+        Connection connection = null;\n+        boolean autocommit = false;\n+\n+        try {\n+\n+            connection = DbConnectionFactory.getConnection(jdbcPool);\n+            autocommit = connection.getAutoCommit();\n+            connection.setAutoCommit(false);\n+\n+            result = delegate.execute();\n+\n+            connection.commit();\n+        } catch (Throwable e) {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.rollback();\n+                } catch (SQLException ex) {\n+                    throw new DotRuntimeException(ex);\n+                }\n+            }\n+\n+            throw new DotRuntimeException(e);\n+        } finally {\n+\n+            if (null != connection) {\n+\n+                try {\n+                    connection.setAutoCommit(autocommit);\n+                } catch (SQLException e) {\n+\n+                    Logger.error(this, e.getMessage(), e);\n+                } finally {\n+\n+                    CloseUtils.closeQuietly(connection);\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final MutableBoolean exists = new MutableBoolean(false);\n+        try (Connection connection = getConnection()) {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage_group WHERE group_name = ?\")\n+                                        .addParam(groupNameLC)\n+                                        .loadObjectResults(connection);\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        } catch (SQLException e) {\n+            throw new DotDataException(e.getMessage(), e);\n+        }\n+        return exists.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String}\n+     * @param objectPath {@link String}\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath)\n+            throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final String objectPathLC = objectPath.toLowerCase();\n+        final MutableBoolean exists = new MutableBoolean(false);\n+\n+        try (Connection connection = getConnection()) {\n+            final Number results = Try\n+                    .of(() -> {\n+                                final List<Map<String, Object>> result = new DotConnect()\n+                                        .setSQL(\"SELECT count(*) as x FROM storage WHERE group_name = ? AND path = ?\")\n+                                        .addParam(groupNameLC).addParam(objectPathLC)\n+                                        .loadObjectResults(connection);\n+                                return (Number) result.get(0).get(\"x\");\n+                            }\n+                    ).getOrElse(0);\n+            exists.setValue(results.intValue() > 0);\n+        } catch (SQLException e) {\n+            throw new DotDataException(e.getMessage(), e);\n+        }\n+        ;\n+\n+        return exists.booleanValue();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) throws DotDataException {\n+        return createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options\n+     * or not.\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions)\n+            throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return wrapInTransaction(() ->\n+                Try.of(() -> {\n+                    new DotConnect().setSQL(\" INSERT INTO storage_group (group_name) VALUES (?) \")\n+                            .addParam(groupNameLC).loadResult(\n+                            this.getConnection());\n+                    return true;\n+                }).getOrElseGet(throwable -> false)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @param groupName {@link String} group name\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return wrapInTransaction(() -> {\n+            final Connection connection = this.getConnection();\n+            final DotConnect dotConnect = new DotConnect();\n+\n+            final List<Map<String, Object>> maps = dotConnect\n+                    .setSQL(\"SELECT hash FROM storage WHERE group_name = ?\").addParam(groupNameLC)\n+                    .loadObjectResults(connection);\n+\n+            int count = deleteObjects(maps.stream().map(map -> map.get(\"hash\").toString())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3NDM3NDM3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/storage/FileSystemStoragePersistenceAPIImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoyMFrOHjUK0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xN1QwNDozMDoyMFrOHjUK0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc5MjY1OA==", "bodyText": "Codacy found an issue: Avoid declaring a variable if it is unreferenced before a possible exit point.", "url": "https://github.com/dotCMS/core/pull/19303#discussion_r506792658", "createdAt": "2020-10-17T04:30:20Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/storage/FileSystemStoragePersistenceAPIImpl.java", "diffHunk": "@@ -0,0 +1,456 @@\n+package com.dotcms.storage;\n+\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.liferay.util.FileUtil;\n+import java.nio.file.Paths;\n+import org.apache.commons.io.FileUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import org.apache.commons.lang3.mutable.MutableInt;\n+\n+/**\n+ * Represents a Storage on the file system The groups here are folder previously registered, you can\n+ * subscribe more by using {@link #addGroupMapping(String, File)}\n+ * By default the API loads up and maps a root folder. Which can be override by a property.\n+ * Any new group created will result in a new folder under that root folder.\n+ * @author jsanca\n+ */\n+public class FileSystemStoragePersistenceAPIImpl implements StoragePersistenceAPI {\n+\n+    private static final String DEFAULT_ROOT = \"root\";\n+    private static final String THE_BUCKET_NAME_S_DOES_NOT_HAVE_ANY_FILE_MAPPED = \"The bucketName: `%s`, does not have any files mapped\";\n+    private static final String STORAGE_POOL = \"StoragePool\";\n+\n+    private final Map<String, File> groups = new ConcurrentHashMap<>();\n+\n+    /**\n+     * default constructor\n+     */\n+    FileSystemStoragePersistenceAPIImpl() {\n+        final String rootGroupKey = getRootGroupKey();\n+        final File rootFolder = getRootFolder();\n+        groups.put(rootGroupKey, rootFolder);\n+        Logger.info(FileSystemStoragePersistenceAPIImpl.class, () -> String\n+                .format(\"Default group key is `%s` currently mapped to folder `%s` \", rootGroupKey,\n+                        rootFolder));\n+    }\n+\n+\n+\n+    /**\n+     * Adds a mapping between a bucket name and a file\n+     *\n+     * @param groupName {@link String} bucket name\n+     * @param folder {@link File}\n+     */\n+    void addGroupMapping(final String groupName, final File folder) {\n+        if (!folder.isDirectory() || !folder.exists() || !folder.canWrite()) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Invalid attempt of mapping an non existing or writable folder. Argument`%s` must be a valid. \",\n+                    folder));\n+        }\n+        this.groups.put(groupName.toLowerCase(), folder);\n+        Logger.info(FileSystemStoragePersistenceAPIImpl.class, () -> String.format(\"Registering New Group with key is `%s` mapped to folder `%s` \",groupName, folder));\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean existsGroup(final String groupName) throws DotDataException{\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.groups.containsKey(groupNameLC) && this.groups.get(groupNameLC).exists();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String}\n+     * @param objectPath {@link String}\n+     * @return\n+     */\n+    @Override\n+    public boolean existsObject(final String groupName, final String objectPath) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        return this.existsGroup(groupNameLC) && new File(this.groups.get(groupNameLC), objectPath.toLowerCase())\n+                .exists();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName) throws DotDataException {\n+        return this.createGroup(groupName, ImmutableMap.of());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName    {@link String} group name\n+     * @param extraOptions {@link Map} depending on the implementation it might need extra options or not.\n+     * @return\n+     */\n+    @Override\n+    public boolean createGroup(final String groupName, final Map<String, Object> extraOptions) throws DotDataException {\n+        final String groupNameLC = groupName.toLowerCase();\n+        final File rootGroup = this.groups.get(getRootGroupKey());\n+        final File destBucketFile = new File(rootGroup, groupNameLC);\n+        final boolean mkdirs = destBucketFile.mkdirs();\n+        if(mkdirs) {\n+           this.groups.put(groupNameLC, destBucketFile);\n+        }\n+        return mkdirs;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @return\n+     */\n+    @Override\n+    public int deleteGroup(final String groupName) throws DotDataException {\n+        final File rootGroup = this.groups.get(getRootGroupKey());\n+        final File destBucketFile = new File(rootGroup, groupName.toLowerCase());\n+        if (!rootGroup.equals(destBucketFile)) {\n+            final int count = countFiles(destBucketFile);\n+            FileUtil.deltree(destBucketFile, true);\n+            return count;\n+        }\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @param path   {   @link String} object path\n+     * @return\n+     */\n+    public boolean deleteObject(final String groupName, final String path) throws DotDataException {\n+        return new File(this.groups.get(groupName.toLowerCase()), path.toLowerCase()).delete();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @return\n+     */\n+    @Override\n+    public List<String> listGroups() throws DotDataException {\n+\n+        return new ImmutableList.Builder<String>().addAll(this.groups.keySet()).build();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName  {@link String} the group to upload\n+     * @param path       {@link String} path to upload the file\n+     * @param file       {@link File}   the actual file\n+     * @param extraMeta  {@link Map} optional metadata, this could be null but depending on the implementation it would need some meta info.\n+     * @return\n+     */\n+    @Override\n+    public Object pushFile(final String groupName,\n+            final String path,\n+            final File file,\n+            final Map<String, Serializable> extraMeta) throws DotDataException{\n+\n+        if (!this.existsGroup(groupName)) {\n+\n+            throw new IllegalArgumentException(String.format(\n+                    THE_BUCKET_NAME_S_DOES_NOT_HAVE_ANY_FILE_MAPPED,groupName));\n+        }\n+\n+        final File groupFile = this.groups.get(groupName.toLowerCase());\n+\n+        if (null != file && file.exists() && file.canRead() && groupFile.canWrite()) {\n+\n+            try {\n+\n+                final File destBucketFile = new File(groupFile, path.toLowerCase());\n+                FileUtils.copyFile(file, destBucketFile);\n+            } catch (IOException e) {\n+\n+                Logger.error(this, e.getMessage(), e);\n+                throw new DotDataException(e.getMessage(), e);\n+            }\n+        } else {\n+\n+            throw new IllegalArgumentException(\"The file: \" + file +\n+                    \", is null, does not exist can not be read or bucket: \" + groupName +\n+                    \" could not be written\");\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} the group to upload\n+     * @param path       {@link String} path to upload the file\n+     * @param writerDelegate     {@link ObjectWriterDelegate} stream to upload\n+     * @param object     {@link Serializable} object to write into the storage\n+     * @param extraMeta  {@link Map} optional metadata, this could be null but depending on the implementation it would need some meta info.\n+     * @return\n+     */\n+    @Override\n+    public Object pushObject(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate,\n+            final Serializable object, final Map<String, Serializable> extraMeta) throws DotDataException {\n+\n+        if (!this.existsGroup(groupName)) {\n+\n+            throw new IllegalArgumentException(String.format(\n+                    THE_BUCKET_NAME_S_DOES_NOT_HAVE_ANY_FILE_MAPPED,groupName));\n+        }\n+\n+        final File groupFile = this.groups.get(groupName.toLowerCase());\n+\n+        if (groupFile.canWrite()) {\n+\n+            try {\n+\n+                final File destBucketFile = new File(groupFile, path.toLowerCase());\n+                final String compressor = Config\n+                        .getStringProperty(\"CONTENT_METADATA_COMPRESSOR\", \"none\");\n+                this.prepareParent(destBucketFile);\n+\n+                try (OutputStream outputStream = FileUtil\n+                        .createOutputStream(destBucketFile.toPath(), compressor)) {\n+\n+                    writerDelegate.write(outputStream, object);\n+                    outputStream.flush();\n+                }\n+            } catch (IOException e) {\n+                Logger.error(FileSystemStoragePersistenceAPIImpl.class, e.getMessage(), e);\n+                throw new  DotDataException(e.getMessage(),e);\n+            }\n+        } else {\n+\n+            throw new IllegalArgumentException(\"The bucket: \" + groupName + \" could not write\");\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * makes parent dir if doesnt exist\n+     * @param file\n+     */\n+    private void prepareParent(final File file) {\n+\n+        if (!file.getParentFile().exists()) {\n+\n+            file.getParentFile().mkdirs();\n+        }\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} the bucket to push\n+     * @param path       {@link String} path to push the file\n+     * @param file       {@link File}   the actual file\n+     * @param extraMeta  {@link Map} optional metadata, this could be null but depending on the implementation it would need some meta info.\n+     * @return\n+     */\n+    @Override\n+    public Future<Object> pushFileAsync(final String groupName, final String path,\n+            final File file, final Map<String, Serializable> extraMeta) {\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushFile(groupName, path, file, extraMeta)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName\n+     * @param path       {@link String} path to upload the file\n+     * @param writerDelegate     {@link ObjectWriterDelegate} stream to upload\n+     * @param object     {@link Serializable} object to write into the storage\n+     * @param extraMeta  {@link Map} optional metadata, this could be null but depending on the implementation it would need some meta info.\n+     * @return\n+     */\n+    @Override\n+    public Future<Object> pushObjectAsync(final String groupName, final String path,\n+            final ObjectWriterDelegate writerDelegate, final Serializable object,\n+            final Map<String, Serializable> extraMeta) {\n+\n+        return DotConcurrentFactory.getInstance().getSubmitter(STORAGE_POOL).submit(\n+                () -> this.pushObject(groupName, path, writerDelegate, object, extraMeta)\n+        );\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String} group name\n+     * @param path {@link String}\n+     * @return\n+     */\n+    @Override\n+    public File pullFile(final String groupName, final String path) throws DotDataException {\n+\n+        if (!this.existsGroup(groupName)) {\n+\n+            throw new IllegalArgumentException(String.format(\n+                    THE_BUCKET_NAME_S_DOES_NOT_HAVE_ANY_FILE_MAPPED,groupName));\n+        }\n+        final File clientFile;\n+        final File bucketFile = this.groups.get(groupName.toLowerCase());\n+        if (bucketFile.canRead()) {\n+            final File destBucketFile = new File(bucketFile, path.toLowerCase());\n+            if (destBucketFile.exists()) {\n+                clientFile = destBucketFile;\n+            } else {\n+                throw new IllegalArgumentException(\"The group: \" + destBucketFile + \", does not exists.\");\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"The bucket: \" + groupName + \" could not be read\");\n+        }\n+\n+        return clientFile;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     * @param groupName {@link String}  group name to pull\n+     * @param path {@link String} path to pull the file\n+     * @param readerDelegate {@link ObjectReaderDelegate} to reads the object\n+     * @return\n+     */\n+    @Override\n+    public Object pullObject(final String groupName, final String path,\n+            final ObjectReaderDelegate readerDelegate) throws DotDataException {\n+\n+        Object object;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aff78eb68a5c49f5a4b75dba21d7143fb79255dc"}, "originalPosition": 339}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1897, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}