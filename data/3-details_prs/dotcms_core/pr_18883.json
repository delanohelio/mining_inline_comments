{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5NTU4Mjg5", "number": 18883, "title": "#18846  local system event is broadcast on save", "bodyText": "This changeset is meant to add a system local event (non-blocking and asynchronous)\nThe event is meant to be used to subscribe  event listeners for custom secret validation purposes.\nA small modification was introduced in the LocalSystemEventsAPI adding a callback to the asyncNotify method that to guarantee that AppSecrets will continue to be destroyed after the event has been all consumed.", "createdAt": "2020-07-15T15:28:19Z", "url": "https://github.com/dotCMS/core/pull/18883", "merged": true, "mergeCommit": {"oid": "e40f0e5719b7d6bcd14839a352b3fb6d7f9e8e97"}, "closed": true, "closedAt": "2020-07-16T15:45:35Z", "author": {"login": "fabrizzio-dotCMS"}, "timelineItems": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc1MGACgH2gAyNDQ5NTU4Mjg5OmRmMzhhZDU3OTEyOTIzN2E3NTljYmRkNjNlMTlkYjY0YmEyNTNiNjk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc1gbh5AFqTQ0OTkyNjYxMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "df38ad579129237a759cbdd63e19db64ba253b69", "author": {"user": {"login": "fabrizzio-dotCMS", "name": "Fabrizzio Araya"}}, "url": "https://github.com/dotCMS/core/commit/df38ad579129237a759cbdd63e19db64ba253b69", "committedDate": "2020-07-15T15:09:29Z", "message": "#18846  local system even is broadcast on save"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "780a70ba71f785cb81c15cc901e2a89ffe7c3ae2", "author": {"user": {"login": "fabrizzio-dotCMS", "name": "Fabrizzio Araya"}}, "url": "https://github.com/dotCMS/core/commit/780a70ba71f785cb81c15cc901e2a89ffe7c3ae2", "committedDate": "2020-07-15T15:53:40Z", "message": "#18846 adding doc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MTczMjM5", "url": "https://github.com/dotCMS/core/pull/18883#pullrequestreview-449173239", "createdAt": "2020-07-15T17:24:13Z", "commit": {"oid": "780a70ba71f785cb81c15cc901e2a89ffe7c3ae2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5Mzg5MzY1", "url": "https://github.com/dotCMS/core/pull/18883#pullrequestreview-449389365", "createdAt": "2020-07-15T22:33:46Z", "commit": {"oid": "780a70ba71f785cb81c15cc901e2a89ffe7c3ae2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "717e80e7ada3395d5fa213f3166cafe6999824bb", "author": {"user": {"login": "fabrizzio-dotCMS", "name": "Fabrizzio Araya"}}, "url": "https://github.com/dotCMS/core/commit/717e80e7ada3395d5fa213f3166cafe6999824bb", "committedDate": "2020-07-15T22:45:35Z", "message": "#18846 key  filterable event"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fad7052521dc1caa8cb490cd4cbd1fc68a2ffc21", "author": {"user": {"login": "fabrizzio-dotCMS", "name": "Fabrizzio Araya"}}, "url": "https://github.com/dotCMS/core/commit/fad7052521dc1caa8cb490cd4cbd1fc68a2ffc21", "committedDate": "2020-07-15T22:51:44Z", "message": "#18846 logger info"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e6bc4f9801d55b8ecb36eb011820c40af7ec8d7", "author": {"user": {"login": "fabrizzio-dotCMS", "name": "Fabrizzio Araya"}}, "url": "https://github.com/dotCMS/core/commit/9e6bc4f9801d55b8ecb36eb011820c40af7ec8d7", "committedDate": "2020-07-15T22:54:17Z", "message": "#18846 remove syste,ou.println"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d59f9f0bd59767d1933a8da8784e718eba03478", "author": {"user": {"login": "fabrizzio-dotCMS", "name": "Fabrizzio Araya"}}, "url": "https://github.com/dotCMS/core/commit/9d59f9f0bd59767d1933a8da8784e718eba03478", "committedDate": "2020-07-15T22:59:02Z", "message": "#18846  unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72e67eacfeb98a8579c885044511fa9a27e98258", "author": {"user": {"login": "fabrizzio-dotCMS", "name": "Fabrizzio Araya"}}, "url": "https://github.com/dotCMS/core/commit/72e67eacfeb98a8579c885044511fa9a27e98258", "committedDate": "2020-07-16T02:56:38Z", "message": "#18846 fix broken test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NDg3MjIx", "url": "https://github.com/dotCMS/core/pull/18883#pullrequestreview-449487221", "createdAt": "2020-07-16T03:46:42Z", "commit": {"oid": "72e67eacfeb98a8579c885044511fa9a27e98258"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0Njo0MlrOGyZDuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0Njo0MlrOGyZDuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5MjUzNg==", "bodyText": "level", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455492536", "createdAt": "2020-07-16T03:46:42Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventsAPIImpl.java", "diffHunk": "@@ -185,34 +190,88 @@ public void setOrphanEventSubscriber(final EventSubscriber<OrphanEvent> orphanEv\n \n \n     @Override\n-    public void asyncNotify(final Object event) {\n+    public void asyncNotify(final Object event, final EventCompletionHandler completionHandler) {\n \n         final DotSubmitter dotSubmitter = this.dotConcurrentFactory.getSubmitter(LOCAL_SYSTEM_EVENTS_THREAD_POOL_SUBMITTER_NAME);\n-        dotSubmitter.submit(()-> this.notify(event));\n+        if(null != completionHandler){\n+            dotSubmitter.submit(()-> this.notify(event, completionHandler));\n+        } else {\n+           dotSubmitter.submit(()-> this.notify(event));\n+        }\n     } // asyncNotify.\n \n-\n     @Override\n-    public void notify(final Object event) {\n-\n-        final CopyOnWriteArrayList<EventSubscriber> eventSubscribers =\n-                this.getEventSubscribersByEventType(event.getClass());\n-\n-        if (null != eventSubscribers) {\n-\n-            for (EventSubscriber eventSubscriber : eventSubscribers) {\n-\n-                if (null != eventSubscriber) {\n+    public void asyncNotify(final Object event) {\n+        asyncNotify(event, null);\n+    }\n \n-                    eventSubscriber.notify(event);\n+    /**\n+     * Private implementation that allows firing an event completion handler\n+     */\n+    private void notify(final Object event, final EventCompletionHandler completionHandler) {\n+        try {\n+            final List<EventSubscriber> eventSubscribers =\n+                    this.getEventSubscribersByEventType(event.getClass());\n+\n+            if (null != eventSubscribers) {\n+                if (event instanceof KeyFilterable) {\n+                    synchronized (this) {\n+                        //if we're broadcasting an event that is an instance of KeyFilterable\n+                        //it means it is intended to a limited audience.\n+                        //Both the even and the receiver must be an instance of KeyFilterable\n+                        final KeyFilterable keyFilterableEvent = (KeyFilterable) event;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72e67eacfeb98a8579c885044511fa9a27e98258"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NDg3Mjk1", "url": "https://github.com/dotCMS/core/pull/18883#pullrequestreview-449487295", "createdAt": "2020-07-16T03:46:57Z", "commit": {"oid": "72e67eacfeb98a8579c885044511fa9a27e98258"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0Njo1N1rOGyZD_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0Njo1N1rOGyZD_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5MjYwNA==", "bodyText": "typo", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455492604", "createdAt": "2020-07-16T03:46:57Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventsAPIImpl.java", "diffHunk": "@@ -185,34 +190,88 @@ public void setOrphanEventSubscriber(final EventSubscriber<OrphanEvent> orphanEv\n \n \n     @Override\n-    public void asyncNotify(final Object event) {\n+    public void asyncNotify(final Object event, final EventCompletionHandler completionHandler) {\n \n         final DotSubmitter dotSubmitter = this.dotConcurrentFactory.getSubmitter(LOCAL_SYSTEM_EVENTS_THREAD_POOL_SUBMITTER_NAME);\n-        dotSubmitter.submit(()-> this.notify(event));\n+        if(null != completionHandler){\n+            dotSubmitter.submit(()-> this.notify(event, completionHandler));\n+        } else {\n+           dotSubmitter.submit(()-> this.notify(event));\n+        }\n     } // asyncNotify.\n \n-\n     @Override\n-    public void notify(final Object event) {\n-\n-        final CopyOnWriteArrayList<EventSubscriber> eventSubscribers =\n-                this.getEventSubscribersByEventType(event.getClass());\n-\n-        if (null != eventSubscribers) {\n-\n-            for (EventSubscriber eventSubscriber : eventSubscribers) {\n-\n-                if (null != eventSubscriber) {\n+    public void asyncNotify(final Object event) {\n+        asyncNotify(event, null);\n+    }\n \n-                    eventSubscriber.notify(event);\n+    /**\n+     * Private implementation that allows firing an event completion handler\n+     */\n+    private void notify(final Object event, final EventCompletionHandler completionHandler) {\n+        try {\n+            final List<EventSubscriber> eventSubscribers =\n+                    this.getEventSubscribersByEventType(event.getClass());\n+\n+            if (null != eventSubscribers) {\n+                if (event instanceof KeyFilterable) {\n+                    synchronized (this) {\n+                        //if we're broadcasting an event that is an instance of KeyFilterable\n+                        //it means it is intended to a limited audience.\n+                        //Both the even and the receiver must be an instance of KeyFilterable\n+                        final KeyFilterable keyFilterableEvent = (KeyFilterable) event;\n+                        Logger.info(LocalSystemEventsAPIImpl.class, ()->\" Broadcasting a Filterable Event.\");\n+                        final Stream<KeyFilterable> keyAwareSubscribers = eventSubscribers.stream()\n+                                .filter(eventSubscriber -> eventSubscriber instanceof KeyFilterable)\n+                                .map(KeyFilterable.class::cast)\n+                                .filter(keyFilterable -> keyFilterable.getKey() != null);\n+\n+                        final List<EventSubscriber> eventAudience = keyAwareSubscribers\n+                                .filter(keyFilterable ->\n+                                        keyFilterable.getKey()\n+                                                .compareTo(keyFilterableEvent.getKey()) == 0)\n+                                .map(EventSubscriber.class::cast)\n+                                .collect(Collectors.toList());\n+                        broadcast(eventAudience, event);\n+                        Logger.info(LocalSystemEventsAPIImpl.class, () -> String\n+                                .format(\" Filtered Audience for event with key `%s`  is `%d` long. \",\n+                                        keyFilterableEvent.getKey(), eventAudience.size()));\n+                    }\n+                } else {\n+                    broadcast(eventSubscribers, event);\n                 }\n+            } else {\n+                this.orphanEventSubscriber.notify(new OrphanEvent(event));\n+            }\n+        } finally {\n+            if (null != completionHandler) {\n+                Try.of(() -> {\n+                    completionHandler.onComplete(event);\n+                    return true;\n+                }).get();\n             }\n-        } else {\n-\n-            this.orphanEventSubscriber.notify(new OrphanEvent(event));\n         }\n+\n     } // asyncNotify.\n \n+    /**\n+     * This method basically delivers the event to all the subscribers\n+     * @param subscibers\n+     * @param event\n+     */\n+    private void broadcast(final List<EventSubscriber> subscibers, final Object event){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72e67eacfeb98a8579c885044511fa9a27e98258"}, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NDg3NDAy", "url": "https://github.com/dotCMS/core/pull/18883#pullrequestreview-449487402", "createdAt": "2020-07-16T03:47:19Z", "commit": {"oid": "72e67eacfeb98a8579c885044511fa9a27e98258"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0NzoxOVrOGyZETQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0NzoxOVrOGyZETQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5MjY4NQ==", "bodyText": "Functional interface", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455492685", "createdAt": "2020-07-16T03:47:19Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/system/event/local/model/KeyFilterable.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package com.dotcms.system.event.local.model;\n+\n+public interface KeyFilterable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72e67eacfeb98a8579c885044511fa9a27e98258"}, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5NDg3NTE1", "url": "https://github.com/dotCMS/core/pull/18883#pullrequestreview-449487515", "createdAt": "2020-07-16T03:47:37Z", "commit": {"oid": "72e67eacfeb98a8579c885044511fa9a27e98258"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0NzozOFrOGyZEzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0NzozOFrOGyZEzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5MjgxMw==", "bodyText": "Doc", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455492813", "createdAt": "2020-07-16T03:47:38Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/test/java/com/dotcms/system/event/local/KeyFilterableEvent.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package com.dotcms.system.event.local;\n+\n+import com.dotcms.system.event.local.model.KeyFilterable;\n+\n+public class KeyFilterableEvent implements KeyFilterable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72e67eacfeb98a8579c885044511fa9a27e98258"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca", "author": {"user": {"login": "fabrizzio-dotCMS", "name": "Fabrizzio Araya"}}, "url": "https://github.com/dotCMS/core/commit/0de1414e4a24aba954993f7c358eecd5302f15ca", "committedDate": "2020-07-16T14:28:02Z", "message": "#18846  feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5OTI2NTE2", "url": "https://github.com/dotCMS/core/pull/18883#pullrequestreview-449926516", "createdAt": "2020-07-16T14:51:01Z", "commit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowMVrOGyusAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowMVrOGyusAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0NjkxMw==", "bodyText": "Codacy found an issue: The String literal \"subscriber1\" appears 5 times in this file; the first occurrence is on line 272", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846913", "createdAt": "2020-07-16T14:51:01Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/system/event/local/LocalSystemEventsAPITest.java", "diffHunk": "@@ -212,6 +215,103 @@ public void orphanSubscriberTest() throws DotDataException {\n         Assert.assertTrue(isCalled.get());\n     } // orphanSubscriberTest.\n \n+    /**\n+     * Given scenario: We're testing that even when no subscribers are added the asyncNotify callback gets called\n+     * Expected results: We expect that the callback gets called.\n+     */\n+    @Test\n+    public void Test_Non_Blocking_Notification_On_Event_Consumed_With_No_Subscribers() {\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        final AtomicBoolean isOnCompleteCalled = new AtomicBoolean(false);\n+        final String message = \"Async notify Event.\";\n+        localSystemEventsAPI.asyncNotify(new TestEventType1(message), event -> {\n+            Assert.assertTrue(event instanceof TestEventType1);\n+            final TestEventType1 eventType1 = (TestEventType1)event;\n+            Assert.assertEquals(eventType1.getMsg(), message);\n+            isOnCompleteCalled.set(true);\n+        });\n+        DateUtil.sleep(2000);\n+        Assert.assertTrue(isOnCompleteCalled.get());\n+    }\n+\n+    /**\n+     * Given scenario: We're testing that even when subscribers are added  the asyncNotify callback gets called just once.\n+     * Expected results: We expect that the callback gets called exactly once.\n+     */\n+    @Test\n+    public void Test_Non_Blocking_Notification_On_Event_Consumed_With_Subscribers() {\n+        final String message = \"Async notify Event 2.\";\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        localSystemEventsAPI.subscribe(new TestDelegateSubscriber(){\n+            @Override\n+            public void notify(final TestEventType2 event) {\n+                Assert.assertEquals(event.getMsg(), message);\n+            }\n+        });\n+        final AtomicInteger callsCount = new AtomicInteger(0);\n \n-\n-} // E:O:F:LocalSystemEventsAPITest.\n+        localSystemEventsAPI.asyncNotify(new TestEventType2(message), event -> {\n+            Assert.assertTrue(event instanceof TestEventType2);\n+            final TestEventType2 eventType2 = (TestEventType2)event;\n+            Assert.assertEquals(eventType2.getMsg(), message);\n+            callsCount.incrementAndGet();\n+        });\n+        DateUtil.sleep(2000);\n+        Assert.assertEquals(callsCount.get(), 1);\n+    }\n+\n+    /**\n+     * Given scenario: We're testing that an event that implements KeyFilterable and is broadcast only reaches certain audience.\n+     * We creating a few subscribers each one of the provides a key. The Event must reach only those which have the same id.\n+     * Expected results: Only the subscribers with a matching id will be able to consume the event;\n+     */\n+    @Test\n+    public void Test_Send_Event_For_Limited_Audience() {\n+\n+        final Map<String, AtomicInteger> callsCounts = ImmutableMap\n+                .of(\"subscriber1\", new AtomicInteger(0), \"subscriber2\", new AtomicInteger(0),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5OTI2NTI4", "url": "https://github.com/dotCMS/core/pull/18883#pullrequestreview-449926528", "createdAt": "2020-07-16T14:51:02Z", "commit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowMlrOGyusDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowMlrOGyusDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0NjkyNQ==", "bodyText": "Codacy found an issue: Unnecessary use of fully qualified name 'Assert.assertEquals' due to existing static import 'org.junit.Assert.assertEquals'", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846925", "createdAt": "2020-07-16T14:51:02Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -785,4 +792,72 @@ public void Test_Get_Secret_fallbackOnSystemHost_With_Non_Valid_License()\n         nonValidLicenseAppsAPI.getSecrets(\"anyKey\", true, systemHost, admin);\n     }\n \n+    /**\n+     * Given scenario: We subscribe an event listener and save an event\n+     * Expected Results: We expect that an event is fired and that after firing the event the AppsSecret that was initially passed to the save method is now destroyed\n+     * @throws DotDataException\n+     * @throws DotSecurityException\n+     */\n+    @Test\n+    public void Test_Save_Secret_Expect_Event_Notification() throws DotDataException, DotSecurityException{\n+        final AtomicInteger callsCount = new AtomicInteger(0);\n+        final AppsAPI api = APILocator.getAppsAPI();\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        localSystemEventsAPI.subscribe(AppSecretSavedEvent.class, new AppsSecretEventSubscriber(){\n+            @Override\n+            public void notify(AppSecretSavedEvent event) {\n+                callsCount.incrementAndGet();\n+            }\n+        });\n+\n+        final String appKey = AppsSecretEventSubscriber.appKey;\n+\n+        final AppDescriptor descriptor = mock(AppDescriptor.class);\n+        when(descriptor.isAllowExtraParameters()).thenReturn(false);\n+        final Map<String, ParamDescriptor> params = of(\n+                \"requiredNoDefault\",newParam(null, false, Type.STRING, \"any\", \"hint\", true),\n+                \"requiredDefault\", newParam(\"default\", false, Type.STRING, \"any\", \"hint\", true),\n+                \"nonRequiredNoDefault\", newParam(null, false, Type.STRING, \"any\", \"hint\", false)\n+        );\n+        when(descriptor.getParams()).thenReturn(params);\n+        when(descriptor.getName()).thenReturn(\"any-name\");\n+        when(descriptor.getKey()).thenReturn(appKey);\n+\n+        final Host site = new SiteDataGen().nextPersisted();\n+        final User admin = TestUserUtils.getAdminUser();\n+\n+        //Let's create a set of secrets for a service\n+        final AppSecrets.Builder builder1 = new AppSecrets.Builder();\n+        final AppSecrets secrets = builder1.withKey(appKey)\n+                .withHiddenSecret(\"requiredNoDefault\", \"value\") //We're providing the expected value\n+                .withHiddenSecret(\"requiredDefault\", \"secret-2\")\n+                .build();\n+        //Save it\n+        api.saveSecrets(secrets, site, admin);\n+        DateUtil.sleep(2000);\n+        Assert.assertEquals(callsCount.get(), 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5OTI2NTUw", "url": "https://github.com/dotCMS/core/pull/18883#pullrequestreview-449926550", "createdAt": "2020-07-16T14:51:03Z", "commit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowM1rOGyusHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowM1rOGyusHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0Njk0MQ==", "bodyText": "Codacy found an issue: The String literal \"subscriber3\" appears 7 times in this file; the first occurrence is on line 273", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846941", "createdAt": "2020-07-16T14:51:03Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/system/event/local/LocalSystemEventsAPITest.java", "diffHunk": "@@ -212,6 +215,103 @@ public void orphanSubscriberTest() throws DotDataException {\n         Assert.assertTrue(isCalled.get());\n     } // orphanSubscriberTest.\n \n+    /**\n+     * Given scenario: We're testing that even when no subscribers are added the asyncNotify callback gets called\n+     * Expected results: We expect that the callback gets called.\n+     */\n+    @Test\n+    public void Test_Non_Blocking_Notification_On_Event_Consumed_With_No_Subscribers() {\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        final AtomicBoolean isOnCompleteCalled = new AtomicBoolean(false);\n+        final String message = \"Async notify Event.\";\n+        localSystemEventsAPI.asyncNotify(new TestEventType1(message), event -> {\n+            Assert.assertTrue(event instanceof TestEventType1);\n+            final TestEventType1 eventType1 = (TestEventType1)event;\n+            Assert.assertEquals(eventType1.getMsg(), message);\n+            isOnCompleteCalled.set(true);\n+        });\n+        DateUtil.sleep(2000);\n+        Assert.assertTrue(isOnCompleteCalled.get());\n+    }\n+\n+    /**\n+     * Given scenario: We're testing that even when subscribers are added  the asyncNotify callback gets called just once.\n+     * Expected results: We expect that the callback gets called exactly once.\n+     */\n+    @Test\n+    public void Test_Non_Blocking_Notification_On_Event_Consumed_With_Subscribers() {\n+        final String message = \"Async notify Event 2.\";\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        localSystemEventsAPI.subscribe(new TestDelegateSubscriber(){\n+            @Override\n+            public void notify(final TestEventType2 event) {\n+                Assert.assertEquals(event.getMsg(), message);\n+            }\n+        });\n+        final AtomicInteger callsCount = new AtomicInteger(0);\n \n-\n-} // E:O:F:LocalSystemEventsAPITest.\n+        localSystemEventsAPI.asyncNotify(new TestEventType2(message), event -> {\n+            Assert.assertTrue(event instanceof TestEventType2);\n+            final TestEventType2 eventType2 = (TestEventType2)event;\n+            Assert.assertEquals(eventType2.getMsg(), message);\n+            callsCount.incrementAndGet();\n+        });\n+        DateUtil.sleep(2000);\n+        Assert.assertEquals(callsCount.get(), 1);\n+    }\n+\n+    /**\n+     * Given scenario: We're testing that an event that implements KeyFilterable and is broadcast only reaches certain audience.\n+     * We creating a few subscribers each one of the provides a key. The Event must reach only those which have the same id.\n+     * Expected results: Only the subscribers with a matching id will be able to consume the event;\n+     */\n+    @Test\n+    public void Test_Send_Event_For_Limited_Audience() {\n+\n+        final Map<String, AtomicInteger> callsCounts = ImmutableMap\n+                .of(\"subscriber1\", new AtomicInteger(0), \"subscriber2\", new AtomicInteger(0),\n+                        \"subscriber3\", new AtomicInteger(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5OTI2NTcx", "url": "https://github.com/dotCMS/core/pull/18883#pullrequestreview-449926571", "createdAt": "2020-07-16T14:51:04Z", "commit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowNFrOGyusKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowNFrOGyusKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0Njk1Mw==", "bodyText": "Codacy found an issue: Avoid unused imports such as 'com.dotcms.system.event.local.model.EventSubscriber'", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846953", "createdAt": "2020-07-16T14:51:04Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -17,6 +17,8 @@\n import com.dotcms.datagen.SiteDataGen;\n import com.dotcms.datagen.TestUserUtils;\n import com.dotcms.datagen.UserDataGen;\n+import com.dotcms.system.event.local.business.LocalSystemEventsAPI;\n+import com.dotcms.system.event.local.model.EventSubscriber;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5OTI2NTg4", "url": "https://github.com/dotCMS/core/pull/18883#pullrequestreview-449926588", "createdAt": "2020-07-16T14:51:05Z", "commit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowNVrOGyusNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowNVrOGyusNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0Njk2NA==", "bodyText": "Codacy found an issue: Classes implementing Serializable should set a serialVersionUID", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846964", "createdAt": "2020-07-16T14:51:05Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppSecretSavedEvent.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.dotcms.security.apps;\n+\n+import com.dotcms.system.event.local.model.KeyFilterable;\n+import com.dotmarketing.beans.Host;\n+import java.io.Serializable;\n+\n+/**\n+ * AppSecretSavedEvent\n+ * Broadcast when a secret is saved.\n+ */\n+public class AppSecretSavedEvent implements Serializable, KeyFilterable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5OTI2NjEz", "url": "https://github.com/dotCMS/core/pull/18883#pullrequestreview-449926613", "createdAt": "2020-07-16T14:51:06Z", "commit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowNlrOGyusRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowNlrOGyusRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0Njk4MQ==", "bodyText": "Codacy found an issue: Consider using varargs for methods or constructors which take an array the last parameter.", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846981", "createdAt": "2020-07-16T14:51:06Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -785,4 +792,72 @@ public void Test_Get_Secret_fallbackOnSystemHost_With_Non_Valid_License()\n         nonValidLicenseAppsAPI.getSecrets(\"anyKey\", true, systemHost, admin);\n     }\n \n+    /**\n+     * Given scenario: We subscribe an event listener and save an event\n+     * Expected Results: We expect that an event is fired and that after firing the event the AppsSecret that was initially passed to the save method is now destroyed\n+     * @throws DotDataException\n+     * @throws DotSecurityException\n+     */\n+    @Test\n+    public void Test_Save_Secret_Expect_Event_Notification() throws DotDataException, DotSecurityException{\n+        final AtomicInteger callsCount = new AtomicInteger(0);\n+        final AppsAPI api = APILocator.getAppsAPI();\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        localSystemEventsAPI.subscribe(AppSecretSavedEvent.class, new AppsSecretEventSubscriber(){\n+            @Override\n+            public void notify(AppSecretSavedEvent event) {\n+                callsCount.incrementAndGet();\n+            }\n+        });\n+\n+        final String appKey = AppsSecretEventSubscriber.appKey;\n+\n+        final AppDescriptor descriptor = mock(AppDescriptor.class);\n+        when(descriptor.isAllowExtraParameters()).thenReturn(false);\n+        final Map<String, ParamDescriptor> params = of(\n+                \"requiredNoDefault\",newParam(null, false, Type.STRING, \"any\", \"hint\", true),\n+                \"requiredDefault\", newParam(\"default\", false, Type.STRING, \"any\", \"hint\", true),\n+                \"nonRequiredNoDefault\", newParam(null, false, Type.STRING, \"any\", \"hint\", false)\n+        );\n+        when(descriptor.getParams()).thenReturn(params);\n+        when(descriptor.getName()).thenReturn(\"any-name\");\n+        when(descriptor.getKey()).thenReturn(appKey);\n+\n+        final Host site = new SiteDataGen().nextPersisted();\n+        final User admin = TestUserUtils.getAdminUser();\n+\n+        //Let's create a set of secrets for a service\n+        final AppSecrets.Builder builder1 = new AppSecrets.Builder();\n+        final AppSecrets secrets = builder1.withKey(appKey)\n+                .withHiddenSecret(\"requiredNoDefault\", \"value\") //We're providing the expected value\n+                .withHiddenSecret(\"requiredDefault\", \"secret-2\")\n+                .build();\n+        //Save it\n+        api.saveSecrets(secrets, site, admin);\n+        DateUtil.sleep(2000);\n+        Assert.assertEquals(callsCount.get(), 1);\n+\n+        // Now Test Secret has been destroyed.\n+        final Map<String, Secret> secretsPostSave = secrets.getSecrets();\n+        for(final String key: secretsPostSave.keySet()){\n+            final char[] value = secretsPostSave.get(key).getValue();\n+            assertTrue(isSecretDestroyed(value));\n+        }\n+    }\n+\n+    /**\n+     * for internal use validate a secret has been destroyed\n+     * @param chars\n+     * @return\n+     */\n+    private boolean isSecretDestroyed(final char [] chars){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "originalPosition": 113}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 804, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}