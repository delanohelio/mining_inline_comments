{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MDYwMDk4", "number": 18604, "reviewThreads": {"totalCount": 49, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxMjozN1rOECt3eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMTowMlrOED5lmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjg0MDg4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxMjozN1rOGfWJhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0MDoyMFrOGgAARg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMTkyNg==", "bodyText": "Use Try.of().getOrThrow(DotRuntimeException::new) instead", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435521926", "createdAt": "2020-06-04T20:12:37Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNzY4Ng==", "bodyText": "done fc979e0#diff-63af77826d67a38fb99a8eccd3d5b770R37", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436207686", "createdAt": "2020-06-05T23:40:20Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMTkyNg=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjg0NTQyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxNDowMlrOGfWMQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0MDo0OFrOGgAArA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMjYyNQ==", "bodyText": "rename to isAnyReadOnly", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435522625", "createdAt": "2020-06-04T20:14:02Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTIzNw==", "bodyText": "yes we need to rename as @jdotcms said", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436139237", "createdAt": "2020-06-05T20:04:11Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMjYyNQ=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNzc4OA==", "bodyText": "done fc979e0#diff-63af77826d67a38fb99a8eccd3d5b770R88", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436207788", "createdAt": "2020-06-05T23:40:48Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMjYyNQ=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjg1NzA2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxNzo1OFrOGfWTxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxNzo1OFrOGfWTxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNDU1MA==", "bodyText": "I think you do not need to call the ESIndexUtil if you are already in there", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435524550", "createdAt": "2020-06-04T20:17:58Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");\n+\n+        return Arrays.stream(indexNames).anyMatch((indexName) -> {\n+            final String readOnlyAllowDelete = response.getSetting(indexName, READ_ONLY_ALLOW_DELETE_SETTING);\n+            final String readOnly = response.getSetting(indexName, READ_ONLY_SETTING);\n+\n+            return Boolean.parseBoolean(readOnlyAllowDelete) || Boolean.parseBoolean(readOnly);\n+        });\n+    }\n+\n+    public static AcknowledgedResponse putReadOnlyToFalse(final String... indexName) {\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(indexName);\n+\n+        final Settings.Builder settingBuilder = Settings.builder()\n+                .put(READ_ONLY_ALLOW_DELETE_SETTING, false)\n+                .put(READ_ONLY_SETTING, false);\n+\n+        request.settings(settingBuilder);\n+\n+        return Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .putSettings(request, RequestOptions.DEFAULT)\n+        );\n+    }\n+\n+    public static boolean isAnyCurrentIndicesReadOnly() {\n+        final IndiciesInfo indiciesInfo = loadIndicesInfo();\n+        return ESIndexUtil.isReadOnly(indiciesInfo.getLive(), indiciesInfo.getWorking());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjg2MDA3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxOTowMlrOGfWV3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0MToxNVrOGgABBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNTA4Ng==", "bodyText": "this should be final", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435525086", "createdAt": "2020-06-04T20:19:02Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.enterprise.LicenseUtil;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+\n+/**\n+ * Run a Monitor If the current indices are in read only mode and try to set them to write mode again.\n+ * When the set write mode fail it try again after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private AtomicBoolean started = new AtomicBoolean();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNzg3Nw==", "bodyText": "done fc979e0#diff-8528ec811f60c9aae6301f9071d59872R34", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436207877", "createdAt": "2020-06-05T23:41:15Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.enterprise.LicenseUtil;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+\n+/**\n+ * Run a Monitor If the current indices are in read only mode and try to set them to write mode again.\n+ * When the set write mode fail it try again after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private AtomicBoolean started = new AtomicBoolean();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNTA4Ng=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjg2ODAyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoyMTozMlrOGfWa0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0MTozN1rOGgABPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNjM1Mg==", "bodyText": "remember use the supplier", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435526352", "createdAt": "2020-06-04T20:21:32Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.enterprise.LicenseUtil;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+\n+/**\n+ * Run a Monitor If the current indices are in read only mode and try to set them to write mode again.\n+ * When the set write mode fail it try again after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private AtomicBoolean started = new AtomicBoolean();\n+    private final ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;\n+\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(final SystemMessageEventUtil systemMessageEventUtil, final RoleAPI roleAPI) {\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+\n+        scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);\n+        scheduledThreadPoolExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(true);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(SystemMessageEventUtil.getInstance(), APILocator.getRoleAPI());\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final ReindexEntry reindexEntry, final String cause){\n+        if (started.compareAndSet(false, true)) {\n+            Logger.error(this.getClass(), Thread.currentThread().getName() + \" - Reindex failed for :\" + reindexEntry + \" because \" + cause);\n+\n+            if (ESIndexUtil.isAnyCurrentIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final SystemMessageBuilder message = new SystemMessageBuilder()\n+                    .setMessage(LanguageUtil.get(messageKey))\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            systemMessageEventUtil.pushMessage(message.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), \"Trying to set the current indices to Write mode\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNzkzNQ==", "bodyText": "done fc979e0#diff-8528ec811f60c9aae6301f9071d59872R102", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436207935", "createdAt": "2020-06-05T23:41:37Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.enterprise.LicenseUtil;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+\n+/**\n+ * Run a Monitor If the current indices are in read only mode and try to set them to write mode again.\n+ * When the set write mode fail it try again after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private AtomicBoolean started = new AtomicBoolean();\n+    private final ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;\n+\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(final SystemMessageEventUtil systemMessageEventUtil, final RoleAPI roleAPI) {\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+\n+        scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);\n+        scheduledThreadPoolExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(true);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(SystemMessageEventUtil.getInstance(), APILocator.getRoleAPI());\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final ReindexEntry reindexEntry, final String cause){\n+        if (started.compareAndSet(false, true)) {\n+            Logger.error(this.getClass(), Thread.currentThread().getName() + \" - Reindex failed for :\" + reindexEntry + \" because \" + cause);\n+\n+            if (ESIndexUtil.isAnyCurrentIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final SystemMessageBuilder message = new SystemMessageBuilder()\n+                    .setMessage(LanguageUtil.get(messageKey))\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            systemMessageEventUtil.pushMessage(message.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), \"Trying to set the current indices to Write mode\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNjM1Mg=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjg3MDY4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoyMjoyM1rOGfWcig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0MTo1NFrOGgABew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNjc5NA==", "bodyText": "I am not sure if this is thread-safe", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435526794", "createdAt": "2020-06-04T20:22:23Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.enterprise.LicenseUtil;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+\n+/**\n+ * Run a Monitor If the current indices are in read only mode and try to set them to write mode again.\n+ * When the set write mode fail it try again after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private AtomicBoolean started = new AtomicBoolean();\n+    private final ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;\n+\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(final SystemMessageEventUtil systemMessageEventUtil, final RoleAPI roleAPI) {\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+\n+        scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);\n+        scheduledThreadPoolExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(true);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(SystemMessageEventUtil.getInstance(), APILocator.getRoleAPI());\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final ReindexEntry reindexEntry, final String cause){\n+        if (started.compareAndSet(false, true)) {\n+            Logger.error(this.getClass(), Thread.currentThread().getName() + \" - Reindex failed for :\" + reindexEntry + \" because \" + cause);\n+\n+            if (ESIndexUtil.isAnyCurrentIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final SystemMessageBuilder message = new SystemMessageBuilder()\n+                    .setMessage(LanguageUtil.get(messageKey))\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            systemMessageEventUtil.pushMessage(message.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), \"Trying to set the current indices to Write mode\");\n+            ESIndexUtil.putCurrentIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ESResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void startMonitor() {\n+        timer = new Timer(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwNzk5NQ==", "bodyText": "done fc979e0#diff-8528ec811f60c9aae6301f9071d59872R113", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436207995", "createdAt": "2020-06-05T23:41:54Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.enterprise.LicenseUtil;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+\n+/**\n+ * Run a Monitor If the current indices are in read only mode and try to set them to write mode again.\n+ * When the set write mode fail it try again after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private AtomicBoolean started = new AtomicBoolean();\n+    private final ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;\n+\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(final SystemMessageEventUtil systemMessageEventUtil, final RoleAPI roleAPI) {\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+\n+        scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);\n+        scheduledThreadPoolExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(true);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(SystemMessageEventUtil.getInstance(), APILocator.getRoleAPI());\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final ReindexEntry reindexEntry, final String cause){\n+        if (started.compareAndSet(false, true)) {\n+            Logger.error(this.getClass(), Thread.currentThread().getName() + \" - Reindex failed for :\" + reindexEntry + \" because \" + cause);\n+\n+            if (ESIndexUtil.isAnyCurrentIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final SystemMessageBuilder message = new SystemMessageBuilder()\n+                    .setMessage(LanguageUtil.get(messageKey))\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            systemMessageEventUtil.pushMessage(message.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), \"Trying to set the current indices to Write mode\");\n+            ESIndexUtil.putCurrentIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ESResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void startMonitor() {\n+        timer = new Timer(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNjc5NA=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjg3MzkwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotmarketing/common/reindex/ReindexQueueAPIImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoyMzozMlrOGfWesg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0MjoxMlrOGgABuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNzM0Ng==", "bodyText": "Not sure if we should create thread, DotConcurrentFactory is your friend", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435527346", "createdAt": "2020-06-04T20:23:32Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/common/reindex/ReindexQueueAPIImpl.java", "diffHunk": "@@ -219,14 +222,14 @@ public void deleteReindexEntry(String identiferToDelete) throws DotDataException\n         reindexQueueFactory.deleteReindexEntry(identiferToDelete);\n     }\n \n-\n-\n     @Override\n     @WrapInTransaction\n     public void markAsFailed(final ReindexEntry idx, final String cause) throws DotDataException {\n-        Logger.warn(this.getClass(), \"Reindex failed for :\" + idx + \" because \" + cause);\n         reindexQueueFactory.markAsFailed(idx, UtilMethods.shortenString(cause, 300));\n \n+        new Thread(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODA1Ng==", "bodyText": "done fc979e0#diff-25af5da06ceca449aa6c6a84fca39091R231", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208056", "createdAt": "2020-06-05T23:42:12Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotmarketing/common/reindex/ReindexQueueAPIImpl.java", "diffHunk": "@@ -219,14 +222,14 @@ public void deleteReindexEntry(String identiferToDelete) throws DotDataException\n         reindexQueueFactory.deleteReindexEntry(identiferToDelete);\n     }\n \n-\n-\n     @Override\n     @WrapInTransaction\n     public void markAsFailed(final ReindexEntry idx, final String cause) throws DotDataException {\n-        Logger.warn(this.getClass(), \"Reindex failed for :\" + idx + \" because \" + cause);\n         reindexQueueFactory.markAsFailed(idx, UtilMethods.shortenString(cause, 300));\n \n+        new Thread(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNzM0Ng=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMjg3NTE5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotmarketing/common/reindex/ReindexThread.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoyMzo1OFrOGfWfnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0MjozMFrOGgAB8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNzU4MA==", "bodyText": "set to final", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435527580", "createdAt": "2020-06-04T20:23:58Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/common/reindex/ReindexThread.java", "diffHunk": "@@ -323,4 +328,7 @@ protected void sendNotification(final String key, final Object[] msgParams, fina\n         systemUser.getLocale());\n   }\n \n+    public static void setCurrentIndexReadOnly(boolean currentIndexReadOnly) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODExMw==", "bodyText": "done fc979e0#diff-6aad54df22d1ffe94dc4adf9a1d98637R331", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208113", "createdAt": "2020-06-05T23:42:30Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotmarketing/common/reindex/ReindexThread.java", "diffHunk": "@@ -323,4 +328,7 @@ protected void sendNotification(final String key, final Object[] msgParams, fina\n         systemUser.getLocale());\n   }\n \n+    public static void setCurrentIndexReadOnly(boolean currentIndexReadOnly) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNzU4MA=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzEzNDAwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo0MjowNlrOGfZB6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0MzoxMVrOGgACcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2OTEyOA==", "bodyText": "\"is\" read only", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435569128", "createdAt": "2020-06-04T21:42:06Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTQ4Mw==", "bodyText": "\"Checking if any of the provided indices is ready only\"", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436139483", "createdAt": "2020-06-05T20:04:49Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2OTEyOA=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTkxMw==", "bodyText": "maybe we can remove this Logger?", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436139913", "createdAt": "2020-06-05T20:05:48Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2OTEyOA=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODI0Mw==", "bodyText": "done fc979e0#diff-63af77826d67a38fb99a8eccd3d5b770R35", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208243", "createdAt": "2020-06-05T23:43:11Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2OTEyOA=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzEzOTA3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo0NDowMVrOGfZFHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0MzozNFrOGgACrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2OTk0OA==", "bodyText": "Shouldn't you log the reason of the exception?", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435569948", "createdAt": "2020-06-04T21:44:01Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");\n+\n+        return Arrays.stream(indexNames).anyMatch((indexName) -> {\n+            final String readOnlyAllowDelete = response.getSetting(indexName, READ_ONLY_ALLOW_DELETE_SETTING);\n+            final String readOnly = response.getSetting(indexName, READ_ONLY_SETTING);\n+\n+            return Boolean.parseBoolean(readOnlyAllowDelete) || Boolean.parseBoolean(readOnly);\n+        });\n+    }\n+\n+    public static AcknowledgedResponse putReadOnlyToFalse(final String... indexName) {\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(indexName);\n+\n+        final Settings.Builder settingBuilder = Settings.builder()\n+                .put(READ_ONLY_ALLOW_DELETE_SETTING, false)\n+                .put(READ_ONLY_SETTING, false);\n+\n+        request.settings(settingBuilder);\n+\n+        return Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .putSettings(request, RequestOptions.DEFAULT)\n+        );\n+    }\n+\n+    public static boolean isAnyCurrentIndicesReadOnly() {\n+        final IndiciesInfo indiciesInfo = loadIndicesInfo();\n+        return ESIndexUtil.isReadOnly(indiciesInfo.getLive(), indiciesInfo.getWorking());\n+    }\n+\n+    public static void putCurrentIndicesToWriteMode() throws ESResponseException {\n+        final IndiciesInfo indiciesInfo = loadIndicesInfo();\n+        final AcknowledgedResponse response = ESIndexUtil.putReadOnlyToFalse(indiciesInfo.getLive(), indiciesInfo.getWorking());\n+\n+        if (!response.isAcknowledged()) {\n+            throw new ESResponseException(response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODMwMg==", "bodyText": "the response have the reason", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208302", "createdAt": "2020-06-05T23:43:34Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");\n+\n+        return Arrays.stream(indexNames).anyMatch((indexName) -> {\n+            final String readOnlyAllowDelete = response.getSetting(indexName, READ_ONLY_ALLOW_DELETE_SETTING);\n+            final String readOnly = response.getSetting(indexName, READ_ONLY_SETTING);\n+\n+            return Boolean.parseBoolean(readOnlyAllowDelete) || Boolean.parseBoolean(readOnly);\n+        });\n+    }\n+\n+    public static AcknowledgedResponse putReadOnlyToFalse(final String... indexName) {\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(indexName);\n+\n+        final Settings.Builder settingBuilder = Settings.builder()\n+                .put(READ_ONLY_ALLOW_DELETE_SETTING, false)\n+                .put(READ_ONLY_SETTING, false);\n+\n+        request.settings(settingBuilder);\n+\n+        return Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .putSettings(request, RequestOptions.DEFAULT)\n+        );\n+    }\n+\n+    public static boolean isAnyCurrentIndicesReadOnly() {\n+        final IndiciesInfo indiciesInfo = loadIndicesInfo();\n+        return ESIndexUtil.isReadOnly(indiciesInfo.getLive(), indiciesInfo.getWorking());\n+    }\n+\n+    public static void putCurrentIndicesToWriteMode() throws ESResponseException {\n+        final IndiciesInfo indiciesInfo = loadIndicesInfo();\n+        final AcknowledgedResponse response = ESIndexUtil.putReadOnlyToFalse(indiciesInfo.getLive(), indiciesInfo.getWorking());\n+\n+        if (!response.isAcknowledged()) {\n+            throw new ESResponseException(response);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2OTk0OA=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzE0NDk4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/webapp/WEB-INF/messages/Language.properties", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo0NjowNVrOGfZIpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0Mzo1NVrOGgAC5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MDg1NA==", "bodyText": "\"is\" in read only mode", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435570854", "createdAt": "2020-06-04T21:46:05Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/main/webapp/WEB-INF/messages/Language.properties", "diffHunk": "@@ -4802,5 +4802,8 @@ Default-Action-Archive = Archive\n Default-Action-Unarchive = Unarchive\n Default-Action-Delete = Delete\n Default-Action-Destroy = Destroy\n+es.index.read.only.message = At least one of the Elasticsearch current indices are in read only mode", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NzgxMA==", "bodyText": "Use this message: Either \"Live\" or \"Working\" indices are in read-only mode", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436147810", "createdAt": "2020-06-05T20:25:35Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/webapp/WEB-INF/messages/Language.properties", "diffHunk": "@@ -4802,5 +4802,8 @@ Default-Action-Archive = Archive\n Default-Action-Unarchive = Unarchive\n Default-Action-Delete = Delete\n Default-Action-Destroy = Destroy\n+es.index.read.only.message = At least one of the Elasticsearch current indices are in read only mode", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MDg1NA=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODM1Nw==", "bodyText": "done fc979e0#diff-f9fa0bd825fbf1166d20a7e5348c93c3R4805", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208357", "createdAt": "2020-06-05T23:43:55Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/webapp/WEB-INF/messages/Language.properties", "diffHunk": "@@ -4802,5 +4802,8 @@ Default-Action-Archive = Archive\n Default-Action-Unarchive = Unarchive\n Default-Action-Delete = Delete\n Default-Action-Destroy = Destroy\n+es.index.read.only.message = At least one of the Elasticsearch current indices are in read only mode", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MDg1NA=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzE1MTY5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo0ODozMlrOGfZM2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0NDoxNVrOGgADCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MTkyOA==", "bodyText": "I think the test name should be changed because you are testing a not read only scenario", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435571928", "createdAt": "2020-06-04T21:48:32Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNDM1NQ==", "bodyText": "exactly", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436114355", "createdAt": "2020-06-05T19:11:31Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MTkyOA=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODM5NQ==", "bodyText": "done fc979e0#diff-1e54965847e19cc0a77583c4dbd18afdR36", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208395", "createdAt": "2020-06-05T23:44:15Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MTkyOA=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzE1Mzk1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo0OToyNFrOGfZOSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0NDozNlrOGgADRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MjI5Ng==", "bodyText": "DoesNotExist", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435572296", "createdAt": "2020-06-04T21:49:24Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODQ1Mg==", "bodyText": "done fc979e0#diff-1e54965847e19cc0a77583c4dbd18afdR80", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208452", "createdAt": "2020-06-05T23:44:36Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MjI5Ng=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzE1OTc0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo1MToyMFrOGfZRxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0NTowMVrOGgADgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MzE4OQ==", "bodyText": "is read only", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435573189", "createdAt": "2020-06-04T21:51:20Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldPutReadonlyInTrue() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            ESIndexUtil.putReadOnlyToFalse(indiciesInfo.getWorking());\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, !readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     */\n+    @Test(expected = ElasticsearchStatusException.class)\n+    public void shouldTryPutReadonlyInTrueAndTheIndexDoesNotExists()  {\n+        ESIndexUtil.putReadOnlyToFalse(\"index_not_exists\");\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isAnyCurrentIndicesReadOnly()}\n+     * When: If at least one of the current working index if read only\n+     * Should: return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test()\n+    public void shouldReturnTrueWhenWorkingIndexIsReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getLive(), false);\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean anyCurrentIndicesReadOnly = ESIndexUtil.isAnyCurrentIndicesReadOnly();\n+            assertEquals(true, anyCurrentIndicesReadOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isAnyCurrentIndicesReadOnly()}\n+     * When: If at least one of the current live index if read only", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODUxNA==", "bodyText": "done fc979e0#diff-1e54965847e19cc0a77583c4dbd18afdR142", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208514", "createdAt": "2020-06-05T23:45:01Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldPutReadonlyInTrue() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            ESIndexUtil.putReadOnlyToFalse(indiciesInfo.getWorking());\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, !readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     */\n+    @Test(expected = ElasticsearchStatusException.class)\n+    public void shouldTryPutReadonlyInTrueAndTheIndexDoesNotExists()  {\n+        ESIndexUtil.putReadOnlyToFalse(\"index_not_exists\");\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isAnyCurrentIndicesReadOnly()}\n+     * When: If at least one of the current working index if read only\n+     * Should: return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test()\n+    public void shouldReturnTrueWhenWorkingIndexIsReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getLive(), false);\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean anyCurrentIndicesReadOnly = ESIndexUtil.isAnyCurrentIndicesReadOnly();\n+            assertEquals(true, anyCurrentIndicesReadOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isAnyCurrentIndicesReadOnly()}\n+     * When: If at least one of the current live index if read only", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MzE4OQ=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzE2MDA2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo1MToyN1rOGfZR-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0NToxN1rOGgADvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MzI0Mw==", "bodyText": "is read only", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435573243", "createdAt": "2020-06-04T21:51:27Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldPutReadonlyInTrue() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            ESIndexUtil.putReadOnlyToFalse(indiciesInfo.getWorking());\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, !readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     */\n+    @Test(expected = ElasticsearchStatusException.class)\n+    public void shouldTryPutReadonlyInTrueAndTheIndexDoesNotExists()  {\n+        ESIndexUtil.putReadOnlyToFalse(\"index_not_exists\");\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isAnyCurrentIndicesReadOnly()}\n+     * When: If at least one of the current working index if read only", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODU3NQ==", "bodyText": "done fc979e0#diff-1e54965847e19cc0a77583c4dbd18afdR120", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208575", "createdAt": "2020-06-05T23:45:17Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldPutReadonlyInTrue() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            ESIndexUtil.putReadOnlyToFalse(indiciesInfo.getWorking());\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, !readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     */\n+    @Test(expected = ElasticsearchStatusException.class)\n+    public void shouldTryPutReadonlyInTrueAndTheIndexDoesNotExists()  {\n+        ESIndexUtil.putReadOnlyToFalse(\"index_not_exists\");\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isAnyCurrentIndicesReadOnly()}\n+     * When: If at least one of the current working index if read only", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MzI0Mw=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzE3MjMyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo1Njo0N1rOGfZZxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo1Njo0N1rOGfZZxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3NTIzOA==", "bodyText": "is there another way to know when the monitor is ready? this sleep might cause a race condition", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435575238", "createdAt": "2020-06-04T21:56:47Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void init () {\n+        systemMessageEventUtilMock = mock(SystemMessageEventUtil.class);\n+        roleAPIMock = mock(RoleAPI.class);\n+\n+        esReadOnlyMonitor = ESReadOnlyMonitor.getInstance(systemMessageEventUtilMock, roleAPIMock);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If the LIVE and WORKING current index are not read only\n+     * Should: not sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldNotSendLargeMessage() throws DotDataException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        putReadOnly(indiciesInfo.getWorking(), false);\n+        putReadOnly(indiciesInfo.getLive(), false);\n+\n+        esReadOnlyMonitor.start(reindexEntry, cause);\n+\n+        verify(systemMessageEventUtilMock, never()).pushLargeMessage(any(), any());\n+\n+        assertEquals(false, ESIndexUtil.isReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If any of LIVE and WORKING current index are read only\n+     * Should: sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessage() throws DotDataException, DotSecurityException, InterruptedException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+            putReadOnly(indiciesInfo.getLive(), false);\n+\n+            esReadOnlyMonitor.start(reindexEntry, cause);\n+\n+            Thread.sleep(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjUzODIxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToxNDo0MVrOGf6Yzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0NTo0NFrOGgAEDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNTY2Mw==", "bodyText": "I would rename to setReadOnly", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436115663", "createdAt": "2020-06-05T19:14:41Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void init () {\n+        systemMessageEventUtilMock = mock(SystemMessageEventUtil.class);\n+        roleAPIMock = mock(RoleAPI.class);\n+\n+        esReadOnlyMonitor = ESReadOnlyMonitor.getInstance(systemMessageEventUtilMock, roleAPIMock);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If the LIVE and WORKING current index are not read only\n+     * Should: not sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldNotSendLargeMessage() throws DotDataException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        putReadOnly(indiciesInfo.getWorking(), false);\n+        putReadOnly(indiciesInfo.getLive(), false);\n+\n+        esReadOnlyMonitor.start(reindexEntry, cause);\n+\n+        verify(systemMessageEventUtilMock, never()).pushLargeMessage(any(), any());\n+\n+        assertEquals(false, ESIndexUtil.isReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If any of LIVE and WORKING current index are read only\n+     * Should: sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessage() throws DotDataException, DotSecurityException, InterruptedException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+            putReadOnly(indiciesInfo.getLive(), false);\n+\n+            esReadOnlyMonitor.start(reindexEntry, cause);\n+\n+            Thread.sleep(100);\n+\n+            checkLargeMessageSent(indiciesInfo, user);\n+            assertEquals(false, ESIndexUtil.isReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If call start again after the first call is finished\n+     * Should: should sent the message again\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessageTwice() throws DotDataException, DotSecurityException, InterruptedException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+            putReadOnly(indiciesInfo.getLive(), false);\n+\n+            esReadOnlyMonitor.start(reindexEntry, cause);\n+            checkLargeMessageSent(indiciesInfo, user);\n+\n+            esReadOnlyMonitor.start(reindexEntry, cause);\n+            checkLargeMessageSent(indiciesInfo, user);\n+            assertEquals(false, ESIndexUtil.isReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    private void checkLargeMessageSent(IndiciesInfo indiciesInfo, User user) throws InterruptedException {\n+        Thread.sleep(100);\n+\n+        final SystemMessageBuilder messageReadonly = new SystemMessageBuilder()\n+                .setMessage(\"At least one of the Elasticsearch current indices are in read only mode\")\n+                .setSeverity(MessageSeverity.ERROR)\n+                .setType(MessageType.SIMPLE_MESSAGE)\n+                .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+        verify(systemMessageEventUtilMock).pushMessage(\n+                messageReadonly.create(),\n+                list(user.getUserId())\n+        );\n+\n+        final SystemMessageBuilder messageWriteModeAgain = new SystemMessageBuilder()\n+                .setMessage(\"Elasticsearch current indices are in write mode again\")\n+                .setSeverity(MessageSeverity.ERROR)\n+                .setType(MessageType.SIMPLE_MESSAGE)\n+                .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+        verify(systemMessageEventUtilMock).pushMessage(\n+                messageWriteModeAgain.create(),\n+                list(user.getUserId())\n+        );\n+    }\n+\n+    private static AcknowledgedResponse putReadOnly(final String indexName, final boolean value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODY1NQ==", "bodyText": "done fc979e0#diff-8d99314a049a8e40fb6783cfaf992d60R173", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208655", "createdAt": "2020-06-05T23:45:44Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void init () {\n+        systemMessageEventUtilMock = mock(SystemMessageEventUtil.class);\n+        roleAPIMock = mock(RoleAPI.class);\n+\n+        esReadOnlyMonitor = ESReadOnlyMonitor.getInstance(systemMessageEventUtilMock, roleAPIMock);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If the LIVE and WORKING current index are not read only\n+     * Should: not sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldNotSendLargeMessage() throws DotDataException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        putReadOnly(indiciesInfo.getWorking(), false);\n+        putReadOnly(indiciesInfo.getLive(), false);\n+\n+        esReadOnlyMonitor.start(reindexEntry, cause);\n+\n+        verify(systemMessageEventUtilMock, never()).pushLargeMessage(any(), any());\n+\n+        assertEquals(false, ESIndexUtil.isReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If any of LIVE and WORKING current index are read only\n+     * Should: sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessage() throws DotDataException, DotSecurityException, InterruptedException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+            putReadOnly(indiciesInfo.getLive(), false);\n+\n+            esReadOnlyMonitor.start(reindexEntry, cause);\n+\n+            Thread.sleep(100);\n+\n+            checkLargeMessageSent(indiciesInfo, user);\n+            assertEquals(false, ESIndexUtil.isReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If call start again after the first call is finished\n+     * Should: should sent the message again\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessageTwice() throws DotDataException, DotSecurityException, InterruptedException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+            putReadOnly(indiciesInfo.getLive(), false);\n+\n+            esReadOnlyMonitor.start(reindexEntry, cause);\n+            checkLargeMessageSent(indiciesInfo, user);\n+\n+            esReadOnlyMonitor.start(reindexEntry, cause);\n+            checkLargeMessageSent(indiciesInfo, user);\n+            assertEquals(false, ESIndexUtil.isReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    private void checkLargeMessageSent(IndiciesInfo indiciesInfo, User user) throws InterruptedException {\n+        Thread.sleep(100);\n+\n+        final SystemMessageBuilder messageReadonly = new SystemMessageBuilder()\n+                .setMessage(\"At least one of the Elasticsearch current indices are in read only mode\")\n+                .setSeverity(MessageSeverity.ERROR)\n+                .setType(MessageType.SIMPLE_MESSAGE)\n+                .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+        verify(systemMessageEventUtilMock).pushMessage(\n+                messageReadonly.create(),\n+                list(user.getUserId())\n+        );\n+\n+        final SystemMessageBuilder messageWriteModeAgain = new SystemMessageBuilder()\n+                .setMessage(\"Elasticsearch current indices are in write mode again\")\n+                .setSeverity(MessageSeverity.ERROR)\n+                .setType(MessageType.SIMPLE_MESSAGE)\n+                .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+        verify(systemMessageEventUtilMock).pushMessage(\n+                messageWriteModeAgain.create(),\n+                list(user.getUserId())\n+        );\n+    }\n+\n+    private static AcknowledgedResponse putReadOnly(final String indexName, final boolean value) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNTY2Mw=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjU1NDc2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToyMToyMVrOGf6jnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0NjoxMFrOGgAETA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExODQzMQ==", "bodyText": "this line is not needed", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436118431", "createdAt": "2020-06-05T19:21:21Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODcxNg==", "bodyText": "done fc979e0#diff-1e54965847e19cc0a77583c4dbd18afdL81", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208716", "createdAt": "2020-06-05T23:46:10Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExODQzMQ=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjU2MTM5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToyMzozOFrOGf6npQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0NjoyOFrOGgAEfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTQ2MQ==", "bodyText": "this doesn't seem a correct expected result based on the method's name...", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436119461", "createdAt": "2020-06-05T19:23:38Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODc2NQ==", "bodyText": "done fc979e0#diff-1e54965847e19cc0a77583c4dbd18afdR87", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208765", "createdAt": "2020-06-05T23:46:28Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTQ2MQ=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjU2MjEzOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToyNDowMFrOGf6oLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0Njo1MlrOGgAEvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTU5OQ==", "bodyText": "looks like the expected escenario is wrong..", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436119599", "createdAt": "2020-06-05T19:24:00Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldPutReadonlyInTrue() throws DotDataException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODgzMQ==", "bodyText": "done fc979e0#diff-1e54965847e19cc0a77583c4dbd18afdR87", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208831", "createdAt": "2020-06-05T23:46:52Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldPutReadonlyInTrue() throws DotDataException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTU5OQ=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjU2Mjk2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToyNDoyMFrOGf6ovA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0NzowOFrOGgAE7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTc0MA==", "bodyText": "assertFalse", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436119740", "createdAt": "2020-06-05T19:24:20Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldPutReadonlyInTrue() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            ESIndexUtil.putReadOnlyToFalse(indiciesInfo.getWorking());\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, !readOnly);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODg3Nw==", "bodyText": "done fc979e0#diff-1e54965847e19cc0a77583c4dbd18afdR101", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208877", "createdAt": "2020-06-05T23:47:08Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldPutReadonlyInTrue() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            ESIndexUtil.putReadOnlyToFalse(indiciesInfo.getWorking());\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, !readOnly);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTc0MA=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjY3NjMxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotmarketing/common/reindex/ReindexQueueAPITest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDowMDoyNFrOGf7vCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0NzoyOFrOGgAFLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNzczOQ==", "bodyText": "missing description", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436137739", "createdAt": "2020-06-05T20:00:24Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/common/reindex/ReindexQueueAPITest.java", "diffHunk": "@@ -102,6 +106,61 @@ public void test_getFailedReindexRecords_shouldNotReturnAnyRecord() throws DotDa\n \n     }\n \n+    /**\n+     * Method to Test: {@link ReindexQueueAPIImpl#markAsFailed(ReindexEntry, String)}\n+     * When: Try to mark a reindex as fail\n+     * Should: Should call the {@link ReindexQueueFactory#markAsFailed(ReindexEntry, String)}\n+     *         and\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void markAsFailed() throws DotDataException {\n+\n+        final ReindexQueueFactory reindexQueueFactory = mock(ReindexQueueFactory.class);\n+        final ESReadOnlyMonitor esReadOnlyMonitor = mock(ESReadOnlyMonitor.class);\n+\n+        final ReindexQueueAPIImpl reindexQueueAPI = new ReindexQueueAPIImpl(reindexQueueFactory, esReadOnlyMonitor);\n+\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"Test Cause\";\n+\n+        reindexQueueAPI.markAsFailed(reindexEntry, cause);\n+\n+        verify(reindexQueueFactory).markAsFailed(reindexEntry, cause);\n+        verify(esReadOnlyMonitor).start(reindexEntry, cause);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ReindexQueueAPIImpl#markAsFailed(ReindexEntry, String)}\n+     * When: Try to mark a reindex as fail and the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODk0MQ==", "bodyText": "done fc979e0#diff-d92d85f1b28c94ca9fd49119521d8872R136", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208941", "createdAt": "2020-06-05T23:47:28Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/common/reindex/ReindexQueueAPITest.java", "diffHunk": "@@ -102,6 +106,61 @@ public void test_getFailedReindexRecords_shouldNotReturnAnyRecord() throws DotDa\n \n     }\n \n+    /**\n+     * Method to Test: {@link ReindexQueueAPIImpl#markAsFailed(ReindexEntry, String)}\n+     * When: Try to mark a reindex as fail\n+     * Should: Should call the {@link ReindexQueueFactory#markAsFailed(ReindexEntry, String)}\n+     *         and\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void markAsFailed() throws DotDataException {\n+\n+        final ReindexQueueFactory reindexQueueFactory = mock(ReindexQueueFactory.class);\n+        final ESReadOnlyMonitor esReadOnlyMonitor = mock(ESReadOnlyMonitor.class);\n+\n+        final ReindexQueueAPIImpl reindexQueueAPI = new ReindexQueueAPIImpl(reindexQueueFactory, esReadOnlyMonitor);\n+\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"Test Cause\";\n+\n+        reindexQueueAPI.markAsFailed(reindexEntry, cause);\n+\n+        verify(reindexQueueFactory).markAsFailed(reindexEntry, cause);\n+        verify(esReadOnlyMonitor).start(reindexEntry, cause);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ReindexQueueAPIImpl#markAsFailed(ReindexEntry, String)}\n+     * When: Try to mark a reindex as fail and the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNzczOQ=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjY3ODI5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotmarketing/common/reindex/ReindexQueueAPITest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDowMToxMlrOGf7wYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0Nzo0NlrOGgAFWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzODA4MA==", "bodyText": "incomplete description", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436138080", "createdAt": "2020-06-05T20:01:12Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/common/reindex/ReindexQueueAPITest.java", "diffHunk": "@@ -102,6 +106,61 @@ public void test_getFailedReindexRecords_shouldNotReturnAnyRecord() throws DotDa\n \n     }\n \n+    /**\n+     * Method to Test: {@link ReindexQueueAPIImpl#markAsFailed(ReindexEntry, String)}\n+     * When: Try to mark a reindex as fail\n+     * Should: Should call the {@link ReindexQueueFactory#markAsFailed(ReindexEntry, String)}\n+     *         and\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void markAsFailed() throws DotDataException {\n+\n+        final ReindexQueueFactory reindexQueueFactory = mock(ReindexQueueFactory.class);\n+        final ESReadOnlyMonitor esReadOnlyMonitor = mock(ESReadOnlyMonitor.class);\n+\n+        final ReindexQueueAPIImpl reindexQueueAPI = new ReindexQueueAPIImpl(reindexQueueFactory, esReadOnlyMonitor);\n+\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"Test Cause\";\n+\n+        reindexQueueAPI.markAsFailed(reindexEntry, cause);\n+\n+        verify(reindexQueueFactory).markAsFailed(reindexEntry, cause);\n+        verify(esReadOnlyMonitor).start(reindexEntry, cause);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ReindexQueueAPIImpl#markAsFailed(ReindexEntry, String)}\n+     * When: Try to mark a reindex as fail and the\n+     * Should: Should call the {@link ReindexQueueFactory#markAsFailed(ReindexEntry, String)}\n+     *         and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwODk4Ng==", "bodyText": "done fc979e0#diff-d92d85f1b28c94ca9fd49119521d8872R137", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436208986", "createdAt": "2020-06-05T23:47:46Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/common/reindex/ReindexQueueAPITest.java", "diffHunk": "@@ -102,6 +106,61 @@ public void test_getFailedReindexRecords_shouldNotReturnAnyRecord() throws DotDa\n \n     }\n \n+    /**\n+     * Method to Test: {@link ReindexQueueAPIImpl#markAsFailed(ReindexEntry, String)}\n+     * When: Try to mark a reindex as fail\n+     * Should: Should call the {@link ReindexQueueFactory#markAsFailed(ReindexEntry, String)}\n+     *         and\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void markAsFailed() throws DotDataException {\n+\n+        final ReindexQueueFactory reindexQueueFactory = mock(ReindexQueueFactory.class);\n+        final ESReadOnlyMonitor esReadOnlyMonitor = mock(ESReadOnlyMonitor.class);\n+\n+        final ReindexQueueAPIImpl reindexQueueAPI = new ReindexQueueAPIImpl(reindexQueueFactory, esReadOnlyMonitor);\n+\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"Test Cause\";\n+\n+        reindexQueueAPI.markAsFailed(reindexEntry, cause);\n+\n+        verify(reindexQueueFactory).markAsFailed(reindexEntry, cause);\n+        verify(esReadOnlyMonitor).start(reindexEntry, cause);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ReindexQueueAPIImpl#markAsFailed(ReindexEntry, String)}\n+     * When: Try to mark a reindex as fail and the\n+     * Should: Should call the {@link ReindexQueueFactory#markAsFailed(ReindexEntry, String)}\n+     *         and", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzODA4MA=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjY4OTgwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDowNTo1N1rOGf73xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0ODoxMVrOGgAFmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTk3NA==", "bodyText": "Maybe we can remove this Logger", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436139974", "createdAt": "2020-06-05T20:05:57Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MDM4Ng==", "bodyText": "If you want to leave it, change to \"Response received on checking if any of the provided indices is read only\"", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436140386", "createdAt": "2020-06-05T20:07:00Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTk3NA=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwOTA0OQ==", "bodyText": "done fc979e0#diff-63af77826d67a38fb99a8eccd3d5b770R45", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436209049", "createdAt": "2020-06-05T23:48:11Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTk3NA=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjcwMDQ4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoxMDozMVrOGf7-tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0ODozM1rOGgAF0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MTc1MQ==", "bodyText": "rename to setLiveAndWorkingIndicesToWriteMode", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436141751", "createdAt": "2020-06-05T20:10:31Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");\n+\n+        return Arrays.stream(indexNames).anyMatch((indexName) -> {\n+            final String readOnlyAllowDelete = response.getSetting(indexName, READ_ONLY_ALLOW_DELETE_SETTING);\n+            final String readOnly = response.getSetting(indexName, READ_ONLY_SETTING);\n+\n+            return Boolean.parseBoolean(readOnlyAllowDelete) || Boolean.parseBoolean(readOnly);\n+        });\n+    }\n+\n+    public static AcknowledgedResponse putReadOnlyToFalse(final String... indexName) {\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(indexName);\n+\n+        final Settings.Builder settingBuilder = Settings.builder()\n+                .put(READ_ONLY_ALLOW_DELETE_SETTING, false)\n+                .put(READ_ONLY_SETTING, false);\n+\n+        request.settings(settingBuilder);\n+\n+        return Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .putSettings(request, RequestOptions.DEFAULT)\n+        );\n+    }\n+\n+    public static boolean isAnyCurrentIndicesReadOnly() {\n+        final IndiciesInfo indiciesInfo = loadIndicesInfo();\n+        return ESIndexUtil.isReadOnly(indiciesInfo.getLive(), indiciesInfo.getWorking());\n+    }\n+\n+    public static void putCurrentIndicesToWriteMode() throws ESResponseException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwOTEwNg==", "bodyText": "done fc979e0#diff-63af77826d67a38fb99a8eccd3d5b770R95", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436209106", "createdAt": "2020-06-05T23:48:33Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");\n+\n+        return Arrays.stream(indexNames).anyMatch((indexName) -> {\n+            final String readOnlyAllowDelete = response.getSetting(indexName, READ_ONLY_ALLOW_DELETE_SETTING);\n+            final String readOnly = response.getSetting(indexName, READ_ONLY_SETTING);\n+\n+            return Boolean.parseBoolean(readOnlyAllowDelete) || Boolean.parseBoolean(readOnly);\n+        });\n+    }\n+\n+    public static AcknowledgedResponse putReadOnlyToFalse(final String... indexName) {\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(indexName);\n+\n+        final Settings.Builder settingBuilder = Settings.builder()\n+                .put(READ_ONLY_ALLOW_DELETE_SETTING, false)\n+                .put(READ_ONLY_SETTING, false);\n+\n+        request.settings(settingBuilder);\n+\n+        return Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .putSettings(request, RequestOptions.DEFAULT)\n+        );\n+    }\n+\n+    public static boolean isAnyCurrentIndicesReadOnly() {\n+        final IndiciesInfo indiciesInfo = loadIndicesInfo();\n+        return ESIndexUtil.isReadOnly(indiciesInfo.getLive(), indiciesInfo.getWorking());\n+    }\n+\n+    public static void putCurrentIndicesToWriteMode() throws ESResponseException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MTc1MQ=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjcxMDU5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoxNDo0NFrOGf8FLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0ODo1NVrOGgAGBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MzQwNg==", "bodyText": "rename to isEitherLiveOrWokingIndicesReadOnly", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436143406", "createdAt": "2020-06-05T20:14:44Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");\n+\n+        return Arrays.stream(indexNames).anyMatch((indexName) -> {\n+            final String readOnlyAllowDelete = response.getSetting(indexName, READ_ONLY_ALLOW_DELETE_SETTING);\n+            final String readOnly = response.getSetting(indexName, READ_ONLY_SETTING);\n+\n+            return Boolean.parseBoolean(readOnlyAllowDelete) || Boolean.parseBoolean(readOnly);\n+        });\n+    }\n+\n+    public static AcknowledgedResponse putReadOnlyToFalse(final String... indexName) {\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(indexName);\n+\n+        final Settings.Builder settingBuilder = Settings.builder()\n+                .put(READ_ONLY_ALLOW_DELETE_SETTING, false)\n+                .put(READ_ONLY_SETTING, false);\n+\n+        request.settings(settingBuilder);\n+\n+        return Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .putSettings(request, RequestOptions.DEFAULT)\n+        );\n+    }\n+\n+    public static boolean isAnyCurrentIndicesReadOnly() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwOTE1OA==", "bodyText": "done fc979e0#diff-63af77826d67a38fb99a8eccd3d5b770R86", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436209158", "createdAt": "2020-06-05T23:48:55Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");\n+\n+        return Arrays.stream(indexNames).anyMatch((indexName) -> {\n+            final String readOnlyAllowDelete = response.getSetting(indexName, READ_ONLY_ALLOW_DELETE_SETTING);\n+            final String readOnly = response.getSetting(indexName, READ_ONLY_SETTING);\n+\n+            return Boolean.parseBoolean(readOnlyAllowDelete) || Boolean.parseBoolean(readOnly);\n+        });\n+    }\n+\n+    public static AcknowledgedResponse putReadOnlyToFalse(final String... indexName) {\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(indexName);\n+\n+        final Settings.Builder settingBuilder = Settings.builder()\n+                .put(READ_ONLY_ALLOW_DELETE_SETTING, false)\n+                .put(READ_ONLY_SETTING, false);\n+\n+        request.settings(settingBuilder);\n+\n+        return Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .putSettings(request, RequestOptions.DEFAULT)\n+        );\n+    }\n+\n+    public static boolean isAnyCurrentIndicesReadOnly() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MzQwNg=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjcyMDQzOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoxODo1MFrOGf8Lew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0OToxM1rOGgAGMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NTAxOQ==", "bodyText": "Please correct by using text from below:\n/**\n * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n * When setting write-mode fails it will retry after one minute.\n */", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436145019", "createdAt": "2020-06-05T20:18:50Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.enterprise.LicenseUtil;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+\n+/**\n+ * Run a Monitor If the current indices are in read only mode and try to set them to write mode again.\n+ * When the set write mode fail it try again after one minute.\n+ */\n+public class ESReadOnlyMonitor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwOTIwMg==", "bodyText": "done fc979e0#diff-8528ec811f60c9aae6301f9071d59872R27", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436209202", "createdAt": "2020-06-05T23:49:13Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.enterprise.LicenseUtil;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+\n+/**\n+ * Run a Monitor If the current indices are in read only mode and try to set them to write mode again.\n+ * When the set write mode fail it try again after one minute.\n+ */\n+public class ESReadOnlyMonitor {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NTAxOQ=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNjc0MDgwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/webapp/WEB-INF/messages/Language.properties", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoyNjoyNVrOGf8X7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMzo0OToyOVrOGgAGag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0ODIwNA==", "bodyText": "Use this message:  \"Live\" and \"Working\" indices are in write-mode again", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436148204", "createdAt": "2020-06-05T20:26:25Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/webapp/WEB-INF/messages/Language.properties", "diffHunk": "@@ -4802,5 +4802,8 @@ Default-Action-Archive = Archive\n Default-Action-Unarchive = Unarchive\n Default-Action-Delete = Delete\n Default-Action-Destroy = Destroy\n+es.index.read.only.message = At least one of the Elasticsearch current indices are in read only mode\n+es.index.write.allow.message = Elasticsearch current indices are in write mode again", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIwOTI1OA==", "bodyText": "done fc979e0#diff-f9fa0bd825fbf1166d20a7e5348c93c3R4806", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436209258", "createdAt": "2020-06-05T23:49:29Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/webapp/WEB-INF/messages/Language.properties", "diffHunk": "@@ -4802,5 +4802,8 @@ Default-Action-Archive = Archive\n Default-Action-Unarchive = Unarchive\n Default-Action-Delete = Delete\n Default-Action-Destroy = Destroy\n+es.index.read.only.message = At least one of the Elasticsearch current indices are in read only mode\n+es.index.write.allow.message = Elasticsearch current indices are in write mode again", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0ODIwNA=="}, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NTE2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0MFrOGhMCBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0MFrOGhMCBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzMxNw==", "bodyText": "Issue found: Assigning an Object to null is a code smell.  Consider refactoring.", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453317", "createdAt": "2020-06-09T14:10:40Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n+ * When setting write-mode fails it will retry after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI) {\n+        super();\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(\n+                SystemMessageEventUtil.getInstance(),\n+                APILocator.getRoleAPI()\n+        );\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final String message){\n+        if (this.start()) {\n+            Logger.error(this.getClass(), message);\n+        }\n+    }\n+\n+    /**\n+     * Start a {@link ESReadOnlyMonitor} is it is not started yet\n+     * @return false if a ESReadOnlyMonitor was started before\n+     */\n+    public boolean start(){\n+        if (started.compareAndSet(false, true)) {\n+            if (ElasticsearchUtil.isClusterInReadOnlyMode()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.cluster.read.only.message\");\n+                startClusterMonitor();\n+            } else if (ElasticsearchUtil.isEitherLiveOrWorkingIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startIndexMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final String message = LanguageUtil.get(messageKey);\n+\n+            final SystemMessageBuilder messageBuilder = new SystemMessageBuilder()\n+                    .setMessage(message)\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            Logger.error(ESReadOnlyMonitor.class, message);\n+            systemMessageEventUtil.pushMessage(messageBuilder.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+            ElasticsearchUtil.setLiveAndWorkingIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ElasticsearchResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void putClusterToWriteMode() {\n+        Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+        ElasticsearchUtil.setClusterToWriteMode();\n+        sendMessage(\"es.cluster.write.allow.message\");\n+        ReindexThread.setCurrentIndexReadOnly(false);\n+\n+        this.stop();\n+    }\n+\n+    private void startIndexMonitor() {\n+         schedule(new IndexMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void schedule(final TimerTask timerTask) {\n+        timer = new Timer(true);\n+        timer.schedule(timerTask, 0, TimeUnit.MINUTES.toMillis(1));\n+    }\n+\n+    private void startClusterMonitor() {\n+        schedule(new ClusterMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void stop() {\n+        if (this.timer != null) {\n+            this.timer.cancel();\n+            this.timer = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NTI3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0MVrOGhMCFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0MVrOGhMCFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzMzMw==", "bodyText": "Issue found: It is a good practice to call super() in a constructor", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453333", "createdAt": "2020-06-09T14:10:41Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n+ * When setting write-mode fails it will retry after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI) {\n+        super();\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(\n+                SystemMessageEventUtil.getInstance(),\n+                APILocator.getRoleAPI()\n+        );\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final String message){\n+        if (this.start()) {\n+            Logger.error(this.getClass(), message);\n+        }\n+    }\n+\n+    /**\n+     * Start a {@link ESReadOnlyMonitor} is it is not started yet\n+     * @return false if a ESReadOnlyMonitor was started before\n+     */\n+    public boolean start(){\n+        if (started.compareAndSet(false, true)) {\n+            if (ElasticsearchUtil.isClusterInReadOnlyMode()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.cluster.read.only.message\");\n+                startClusterMonitor();\n+            } else if (ElasticsearchUtil.isEitherLiveOrWorkingIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startIndexMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final String message = LanguageUtil.get(messageKey);\n+\n+            final SystemMessageBuilder messageBuilder = new SystemMessageBuilder()\n+                    .setMessage(message)\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            Logger.error(ESReadOnlyMonitor.class, message);\n+            systemMessageEventUtil.pushMessage(messageBuilder.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+            ElasticsearchUtil.setLiveAndWorkingIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ElasticsearchResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void putClusterToWriteMode() {\n+        Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+        ElasticsearchUtil.setClusterToWriteMode();\n+        sendMessage(\"es.cluster.write.allow.message\");\n+        ReindexThread.setCurrentIndexReadOnly(false);\n+\n+        this.stop();\n+    }\n+\n+    private void startIndexMonitor() {\n+         schedule(new IndexMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void schedule(final TimerTask timerTask) {\n+        timer = new Timer(true);\n+        timer.schedule(timerTask, 0, TimeUnit.MINUTES.toMillis(1));\n+    }\n+\n+    private void startClusterMonitor() {\n+        schedule(new ClusterMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void stop() {\n+        if (this.timer != null) {\n+            this.timer.cancel();\n+            this.timer = null;\n+            this.started.set(false);\n+        }\n+    }\n+\n+    private static class IndexMonitorTimerTask extends TimerTask{\n+        private final ESReadOnlyMonitor esReadOnlyMonitor;\n+\n+        IndexMonitorTimerTask(final ESReadOnlyMonitor esReadOnlyMonitor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NTMyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0MlrOGhMCJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0MlrOGhMCJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzM0OA==", "bodyText": "Issue found: Avoid unused imports such as 'org.mockito.Mockito'", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453348", "createdAt": "2020-06-09T14:10:42Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NTM3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0M1rOGhMCKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0M1rOGhMCKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzM1Mw==", "bodyText": "Issue found: Use block level rather than method level synchronization", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453353", "createdAt": "2020-06-09T14:10:43Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n+ * When setting write-mode fails it will retry after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI) {\n+        super();\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(\n+                SystemMessageEventUtil.getInstance(),\n+                APILocator.getRoleAPI()\n+        );\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final String message){\n+        if (this.start()) {\n+            Logger.error(this.getClass(), message);\n+        }\n+    }\n+\n+    /**\n+     * Start a {@link ESReadOnlyMonitor} is it is not started yet\n+     * @return false if a ESReadOnlyMonitor was started before\n+     */\n+    public boolean start(){\n+        if (started.compareAndSet(false, true)) {\n+            if (ElasticsearchUtil.isClusterInReadOnlyMode()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.cluster.read.only.message\");\n+                startClusterMonitor();\n+            } else if (ElasticsearchUtil.isEitherLiveOrWorkingIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startIndexMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final String message = LanguageUtil.get(messageKey);\n+\n+            final SystemMessageBuilder messageBuilder = new SystemMessageBuilder()\n+                    .setMessage(message)\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            Logger.error(ESReadOnlyMonitor.class, message);\n+            systemMessageEventUtil.pushMessage(messageBuilder.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+            ElasticsearchUtil.setLiveAndWorkingIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ElasticsearchResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void putClusterToWriteMode() {\n+        Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+        ElasticsearchUtil.setClusterToWriteMode();\n+        sendMessage(\"es.cluster.write.allow.message\");\n+        ReindexThread.setCurrentIndexReadOnly(false);\n+\n+        this.stop();\n+    }\n+\n+    private void startIndexMonitor() {\n+         schedule(new IndexMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void schedule(final TimerTask timerTask) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NTQ4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0NFrOGhMCPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0NFrOGhMCPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzM3NA==", "bodyText": "Issue found: Use block level rather than method level synchronization", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453374", "createdAt": "2020-06-09T14:10:44Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n+ * When setting write-mode fails it will retry after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI) {\n+        super();\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(\n+                SystemMessageEventUtil.getInstance(),\n+                APILocator.getRoleAPI()\n+        );\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final String message){\n+        if (this.start()) {\n+            Logger.error(this.getClass(), message);\n+        }\n+    }\n+\n+    /**\n+     * Start a {@link ESReadOnlyMonitor} is it is not started yet\n+     * @return false if a ESReadOnlyMonitor was started before\n+     */\n+    public boolean start(){\n+        if (started.compareAndSet(false, true)) {\n+            if (ElasticsearchUtil.isClusterInReadOnlyMode()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.cluster.read.only.message\");\n+                startClusterMonitor();\n+            } else if (ElasticsearchUtil.isEitherLiveOrWorkingIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startIndexMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final String message = LanguageUtil.get(messageKey);\n+\n+            final SystemMessageBuilder messageBuilder = new SystemMessageBuilder()\n+                    .setMessage(message)\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            Logger.error(ESReadOnlyMonitor.class, message);\n+            systemMessageEventUtil.pushMessage(messageBuilder.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+            ElasticsearchUtil.setLiveAndWorkingIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ElasticsearchResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void putClusterToWriteMode() {\n+        Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+        ElasticsearchUtil.setClusterToWriteMode();\n+        sendMessage(\"es.cluster.write.allow.message\");\n+        ReindexThread.setCurrentIndexReadOnly(false);\n+\n+        this.stop();\n+    }\n+\n+    private void startIndexMonitor() {\n+         schedule(new IndexMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void schedule(final TimerTask timerTask) {\n+        timer = new Timer(true);\n+        timer.schedule(timerTask, 0, TimeUnit.MINUTES.toMillis(1));\n+    }\n+\n+    private void startClusterMonitor() {\n+        schedule(new ClusterMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void stop() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NTU3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0NVrOGhMCTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0NVrOGhMCTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzM4OQ==", "bodyText": "Issue found: Avoid unused imports such as 'org.elasticsearch.ElasticsearchStatusException'", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453389", "createdAt": "2020-06-09T14:10:45Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtil.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import io.vavr.control.Try;\n+import org.elasticsearch.ElasticsearchStatusException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NTcxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ElasticsearchResponseException.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0NlrOGhMCXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0NlrOGhMCXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQwNw==", "bodyText": "Issue found: Classes implementing Serializable should set a serialVersionUID", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453407", "createdAt": "2020-06-09T14:10:46Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ElasticsearchResponseException.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+\n+/**\n+ * Throw when a Elasticsearch request fail\n+ */\n+public class ElasticsearchResponseException extends Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NTgwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESContentletAPIImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0N1rOGhMCaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0N1rOGhMCaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQxOQ==", "bodyText": "Issue found: Avoid unused imports such as 'com.dotmarketing.exception.DotRuntimeException'", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453419", "createdAt": "2020-06-09T14:10:47Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESContentletAPIImplTest.java", "diffHunk": "@@ -27,6 +30,7 @@\n import com.dotmarketing.beans.Permission;\n import com.dotmarketing.business.*;\n import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NTg4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0OFrOGhMCeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0OFrOGhMCeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQzMw==", "bodyText": "Issue found: The String literal \"message\" appears 5 times in this file; the first occurrence is on line 61", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453433", "createdAt": "2020-06-09T14:10:48Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void init () {\n+        systemMessageEventUtilMock = mock(SystemMessageEventUtil.class);\n+        roleAPIMock = mock(RoleAPI.class);\n+\n+        esReadOnlyMonitor = ESReadOnlyMonitor.getInstance(systemMessageEventUtilMock, roleAPIMock);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(String)}\n+     * When: If the LIVE and WORKING current index are not read only\n+     * Should: not sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldNotSendLargeMessage() throws DotDataException, IOException {\n+        final String message = \"message\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NTkzOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/api/system/event/message/builder/SystemMessage.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0OVrOGhMCgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0OVrOGhMCgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQ0Mg==", "bodyText": "Issue found: This statement should have braces", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453442", "createdAt": "2020-06-09T14:10:49Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/api/system/event/message/builder/SystemMessage.java", "diffHunk": "@@ -67,4 +69,23 @@ public String toString() {\n                 \", type=\" + type +\n                 '}';\n     }\n+\n+    @Override\n+    public boolean equals(final Object another) {\n+        if (this == another) return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NjAyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1MVrOGhMCjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1MVrOGhMCjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQ1Mg==", "bodyText": "Issue found: It is a good practice to call super() in a constructor", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453452", "createdAt": "2020-06-09T14:10:51Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n+ * When setting write-mode fails it will retry after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI) {\n+        super();\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(\n+                SystemMessageEventUtil.getInstance(),\n+                APILocator.getRoleAPI()\n+        );\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final String message){\n+        if (this.start()) {\n+            Logger.error(this.getClass(), message);\n+        }\n+    }\n+\n+    /**\n+     * Start a {@link ESReadOnlyMonitor} is it is not started yet\n+     * @return false if a ESReadOnlyMonitor was started before\n+     */\n+    public boolean start(){\n+        if (started.compareAndSet(false, true)) {\n+            if (ElasticsearchUtil.isClusterInReadOnlyMode()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.cluster.read.only.message\");\n+                startClusterMonitor();\n+            } else if (ElasticsearchUtil.isEitherLiveOrWorkingIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startIndexMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final String message = LanguageUtil.get(messageKey);\n+\n+            final SystemMessageBuilder messageBuilder = new SystemMessageBuilder()\n+                    .setMessage(message)\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            Logger.error(ESReadOnlyMonitor.class, message);\n+            systemMessageEventUtil.pushMessage(messageBuilder.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+            ElasticsearchUtil.setLiveAndWorkingIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ElasticsearchResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void putClusterToWriteMode() {\n+        Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+        ElasticsearchUtil.setClusterToWriteMode();\n+        sendMessage(\"es.cluster.write.allow.message\");\n+        ReindexThread.setCurrentIndexReadOnly(false);\n+\n+        this.stop();\n+    }\n+\n+    private void startIndexMonitor() {\n+         schedule(new IndexMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void schedule(final TimerTask timerTask) {\n+        timer = new Timer(true);\n+        timer.schedule(timerTask, 0, TimeUnit.MINUTES.toMillis(1));\n+    }\n+\n+    private void startClusterMonitor() {\n+        schedule(new ClusterMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void stop() {\n+        if (this.timer != null) {\n+            this.timer.cancel();\n+            this.timer = null;\n+            this.started.set(false);\n+        }\n+    }\n+\n+    private static class IndexMonitorTimerTask extends TimerTask{\n+        private final ESReadOnlyMonitor esReadOnlyMonitor;\n+\n+        IndexMonitorTimerTask(final ESReadOnlyMonitor esReadOnlyMonitor) {\n+            this.esReadOnlyMonitor = esReadOnlyMonitor;\n+        }\n+\n+        @Override\n+        public void run() {\n+            this.esReadOnlyMonitor.putCurrentIndicesToWriteMode();\n+        }\n+    }\n+\n+    private static class ClusterMonitorTimerTask extends TimerTask{\n+        private final ESReadOnlyMonitor esReadOnlyMonitor;\n+\n+        ClusterMonitorTimerTask(final ESReadOnlyMonitor esReadOnlyMonitor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NjEwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtilTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1MlrOGhMCmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1MlrOGhMCmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQ2NA==", "bodyText": "Issue found: Avoid unused imports such as 'org.jgroups.util.Util.assertEquals'", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453464", "createdAt": "2020-06-09T14:10:52Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtilTest.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static org.jgroups.util.Util.assertEquals;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NjE2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1M1rOGhMCow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1M1rOGhMCow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQ3NQ==", "bodyText": "Issue found: Avoid unused imports such as 'com.dotmarketing.common.reindex.ReindexEntry'", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453475", "createdAt": "2020-06-09T14:10:53Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NjI2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1NFrOGhMCsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1NFrOGhMCsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQ4OQ==", "bodyText": "Issue found: Use assertTrue(x)/assertFalse(x) instead of assertEquals(true, x)/assertEquals(false, x) or assertEquals(Boolean.TRUE, x)/assertEquals(Boolean.FALSE, x).", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453489", "createdAt": "2020-06-09T14:10:54Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void init () {\n+        systemMessageEventUtilMock = mock(SystemMessageEventUtil.class);\n+        roleAPIMock = mock(RoleAPI.class);\n+\n+        esReadOnlyMonitor = ESReadOnlyMonitor.getInstance(systemMessageEventUtilMock, roleAPIMock);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(String)}\n+     * When: If the LIVE and WORKING current index are not read only\n+     * Should: not sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldNotSendLargeMessage() throws DotDataException, IOException {\n+        final String message = \"message\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        setReadOnly(indiciesInfo.getWorking(), false);\n+        setReadOnly(indiciesInfo.getLive(), false);\n+\n+        esReadOnlyMonitor.start(message);\n+\n+        verify(systemMessageEventUtilMock, never()).pushLargeMessage(any(), any());\n+\n+        assertEquals(false, ElasticsearchUtil.isAnyReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(String)}\n+     * When: If any of LIVE and WORKING current index are read only\n+     * Should: sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessage() throws DotDataException, DotSecurityException, InterruptedException, IOException {\n+        final String message = \"message\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            setReadOnly(indiciesInfo.getWorking(), true);\n+            setReadOnly(indiciesInfo.getLive(), false);\n+\n+            esReadOnlyMonitor.start(message);\n+\n+            Thread.sleep(100);\n+\n+            checkLargeMessageSent(user);\n+            assertEquals(false, ElasticsearchUtil.isAnyReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+        } finally {\n+            setReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start()}\n+     * When: If the cluster is read only\n+     * Should: sent message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessageIfTheClusterIsInReadOnly() throws DotDataException, DotSecurityException, InterruptedException, IOException {\n+        final String message = \"message\";\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            setClusterAsReadOnly(true);\n+\n+            esReadOnlyMonitor.start(message);\n+\n+            Thread.sleep(100);\n+\n+            checkClusterLargeMessageSent(user);\n+            assertEquals(false, ElasticsearchUtil.isClusterInReadOnlyMode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NjM2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESContentletAPIImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1NVrOGhMCvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1NVrOGhMCvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzUwMw==", "bodyText": "Issue found: Avoid unused imports such as 'org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest'", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453503", "createdAt": "2020-06-09T14:10:55Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESContentletAPIImplTest.java", "diffHunk": "@@ -48,6 +52,12 @@\n import java.util.Date;\n import java.util.List;\n \n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NjU3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotmarketing/common/reindex/ReindexQueueAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1NlrOGhMC3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1NlrOGhMC3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzUzMw==", "bodyText": "Issue found: Avoid unused imports such as 'org.mockito.Mockito'", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453533", "createdAt": "2020-06-09T14:10:56Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/common/reindex/ReindexQueueAPITest.java", "diffHunk": "@@ -5,7 +5,9 @@\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NjY2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1OFrOGhMC6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1OFrOGhMC6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzU0Nw==", "bodyText": "Issue found: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453547", "createdAt": "2020-06-09T14:10:58Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NjcxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtilTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1OFrOGhMC9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1OFrOGhMC9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzU1OQ==", "bodyText": "Issue found: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453559", "createdAt": "2020-06-09T14:10:58Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtilTest.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class ElasticsearchUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NjgwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMTowMFrOGhMDBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMTowMFrOGhMDBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzU3Mw==", "bodyText": "Issue found: Use assertTrue(x)/assertFalse(x) instead of assertEquals(true, x)/assertEquals(false, x) or assertEquals(Boolean.TRUE, x)/assertEquals(Boolean.FALSE, x).", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453573", "createdAt": "2020-06-09T14:11:00Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void init () {\n+        systemMessageEventUtilMock = mock(SystemMessageEventUtil.class);\n+        roleAPIMock = mock(RoleAPI.class);\n+\n+        esReadOnlyMonitor = ESReadOnlyMonitor.getInstance(systemMessageEventUtilMock, roleAPIMock);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(String)}\n+     * When: If the LIVE and WORKING current index are not read only\n+     * Should: not sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldNotSendLargeMessage() throws DotDataException, IOException {\n+        final String message = \"message\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        setReadOnly(indiciesInfo.getWorking(), false);\n+        setReadOnly(indiciesInfo.getLive(), false);\n+\n+        esReadOnlyMonitor.start(message);\n+\n+        verify(systemMessageEventUtilMock, never()).pushLargeMessage(any(), any());\n+\n+        assertEquals(false, ElasticsearchUtil.isAnyReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0NjkwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMTowMVrOGhMDGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMTowMVrOGhMDGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzU5NA==", "bodyText": "Issue found: Avoid unused imports such as 'io.vavr.control.Try'", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453594", "createdAt": "2020-06-09T14:11:01Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtil.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import io.vavr.control.Try;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNTI0Njk5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/api/system/event/message/builder/SystemMessage.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMTowMlrOGhMDKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMTowMlrOGhMDKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzYwOA==", "bodyText": "Issue found: This statement should have braces", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453608", "createdAt": "2020-06-09T14:11:02Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/api/system/event/message/builder/SystemMessage.java", "diffHunk": "@@ -67,4 +69,23 @@ public String toString() {\n                 \", type=\" + type +\n                 '}';\n     }\n+\n+    @Override\n+    public boolean equals(final Object another) {\n+        if (this == another) return true;\n+        if (another == null || getClass() != another.getClass()) return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2133, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}