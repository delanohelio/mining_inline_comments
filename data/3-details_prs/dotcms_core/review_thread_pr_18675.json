{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM1NDAxMTk0", "number": 18675, "reviewThreads": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNTo1NzoxM1rOETvhaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToyMFrOEUJYIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTM3MDAwOnYy", "diffSide": "RIGHT", "path": "dotCMS/build.gradle", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNTo1NzoxM1rOG5pdrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNjozOTo0OVrOG6O7LQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwMTM1OQ==", "bodyText": "Please remove commented dependencies", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463101359", "createdAt": "2020-07-30T15:57:13Z", "author": {"login": "nollymar"}, "path": "dotCMS/build.gradle", "diffHunk": "@@ -161,10 +161,21 @@ dependencies {\n     felix(group: 'org.apache.tika', name: 'tika-bundle', version: '1.17') {\n         transitive = false\n     }\n+\n     felix group: 'org.slf4j', name: 'slf4j-simple', version: '1.7.25'\n     felix group: 'org.slf4j', name: 'jcl-over-slf4j', version: '1.7.25'\n     felix group: 'com.dotcms.tika', name: 'com.dotcms.tika', version: '0.2'\n \n+  /*  felix group: 'org.opensaml',          name: 'opensaml-core',           version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-saml-api',       version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-security-api',   version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-xmlsec-impl',    version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-xmlsec-api',     version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-security-impl',  version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-messaging-impl', version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-messaging-api',  version: '3.4.5'*/\n+\n+    felix group: 'com.dotcms.samlbundle', name: 'com.dotcms.samlbundle', version: '5.3.3'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcxNTExNw==", "bodyText": "Done", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463715117", "createdAt": "2020-07-31T16:39:49Z", "author": {"login": "jdotcms"}, "path": "dotCMS/build.gradle", "diffHunk": "@@ -161,10 +161,21 @@ dependencies {\n     felix(group: 'org.apache.tika', name: 'tika-bundle', version: '1.17') {\n         transitive = false\n     }\n+\n     felix group: 'org.slf4j', name: 'slf4j-simple', version: '1.7.25'\n     felix group: 'org.slf4j', name: 'jcl-over-slf4j', version: '1.7.25'\n     felix group: 'com.dotcms.tika', name: 'com.dotcms.tika', version: '0.2'\n \n+  /*  felix group: 'org.opensaml',          name: 'opensaml-core',           version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-saml-api',       version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-security-api',   version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-xmlsec-impl',    version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-xmlsec-api',     version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-security-impl',  version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-messaging-impl', version: '3.4.5'\n+    felix group: 'org.opensaml',          name: 'opensaml-messaging-api',  version: '3.4.5'*/\n+\n+    felix group: 'com.dotcms.samlbundle', name: 'com.dotcms.samlbundle', version: '5.3.3'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwMTM1OQ=="}, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTM3NDQzOnYy", "diffSide": "RIGHT", "path": "dotCMS/dependencies.gradle", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNTo1ODoxOFrOG5pgnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxNjo0MDoyNFrOG6O8WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwMjEwOQ==", "bodyText": "same here", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463102109", "createdAt": "2020-07-30T15:58:18Z", "author": {"login": "nollymar"}, "path": "dotCMS/dependencies.gradle", "diffHunk": "@@ -509,4 +509,8 @@ dependencies {\n     providedCompile \"javax.servlet:javax.servlet-api:3.1.0\"\n     providedCompile fileTree(\"../libs/buildlibs\").include('**/*.jar')\n     providedCompile fileTree(\"../libs/buildlibs\").include('mail.jar')\n+\n+    // todo: remove this when deploy saml bundle on artifactory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzcxNTQxNw==", "bodyText": "Done", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463715417", "createdAt": "2020-07-31T16:40:24Z", "author": {"login": "jdotcms"}, "path": "dotCMS/dependencies.gradle", "diffHunk": "@@ -509,4 +509,8 @@ dependencies {\n     providedCompile \"javax.servlet:javax.servlet-api:3.1.0\"\n     providedCompile fileTree(\"../libs/buildlibs\").include('**/*.jar')\n     providedCompile fileTree(\"../libs/buildlibs\").include('mail.jar')\n+\n+    // todo: remove this when deploy saml bundle on artifactory", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwMjEwOQ=="}, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTM5ODY1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjowNDoxN1rOG5pv_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjozNDozN1rOG5q68Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwNjA0Nw==", "bodyText": "Why Serializable??", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463106047", "createdAt": "2020-07-30T16:04:17Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.rest.annotation.NoCache;\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.IdentityProviderConfigurationFactory;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.WebKeys;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.server.JSONP;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Path(\"/v1/dotsaml\")\n+public class DotSamlResource implements Serializable {\n+\n+\tprivate static final long serialVersionUID = 8015545653539491684L;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEyNTIzMw==", "bodyText": "Javadoc the whole thing.", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463125233", "createdAt": "2020-07-30T16:34:37Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.rest.annotation.NoCache;\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.IdentityProviderConfigurationFactory;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.WebKeys;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.server.JSONP;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Path(\"/v1/dotsaml\")\n+public class DotSamlResource implements Serializable {\n+\n+\tprivate static final long serialVersionUID = 8015545653539491684L;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwNjA0Nw=="}, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTQxMTExOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/saml/MockIdentityProviderConfigurationFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjowNzoyNVrOG5p3uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjowNzoyNVrOG5p3uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwODAyNQ==", "bodyText": "Needs javadoc", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463108025", "createdAt": "2020-07-30T16:07:25Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/integration-test/java/com/dotcms/saml/MockIdentityProviderConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.dotcms.saml;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyPair;\n+import java.security.cert.Certificate;\n+\n+public class MockIdentityProviderConfigurationFactory implements IdentityProviderConfigurationFactory {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTQxNTU2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/saml/TestSamlConfigurationService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjowODoyNlrOG5p6TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjowODoyNlrOG5p6TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwODY4NQ==", "bodyText": "The name should be SamlConfigurationServiceTest to follow naming convention", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463108685", "createdAt": "2020-07-30T16:08:26Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/integration-test/java/com/dotcms/saml/TestSamlConfigurationService.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.util.Config;\n+import org.apache.felix.framework.OSGIUtil;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+public class TestSamlConfigurationService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTQyNzQyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjoxMToxOVrOG5qBmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjoxMToxOVrOG5qBmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzExMDU1Mg==", "bodyText": "Is there any place where these endpoints are documented? For example, it is not clear for me the difference between doLogin and processLogin", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463110552", "createdAt": "2020-07-30T16:11:19Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.rest.annotation.NoCache;\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.IdentityProviderConfigurationFactory;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.WebKeys;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.server.JSONP;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Path(\"/v1/dotsaml\")\n+public class DotSamlResource implements Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTQzMjk1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjoxMjozOFrOG5qE0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjoxMjozOFrOG5qE0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzExMTM3Nw==", "bodyText": "Needs javadoc and testing", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463111377", "createdAt": "2020-07-30T16:12:38Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "diffHunk": "@@ -0,0 +1,469 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotcms.saml.SamlName;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.cms.factories.PublicEncryptionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.ActivityLogger;\n+import com.dotmarketing.util.AdminLogger;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UUIDGenerator;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.User;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.dotmarketing.util.UtilMethods.isSet;\n+\n+public class SAMLHelper {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTUyNjk1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjozNjoxMFrOG5q-dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjozNjoxMFrOG5q-dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEyNjEzMw==", "bodyText": "could have used a return here. instead of the noConfig flag", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463126133", "createdAt": "2020-07-30T16:36:10Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.rest.annotation.NoCache;\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.IdentityProviderConfigurationFactory;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.WebKeys;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.server.JSONP;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Path(\"/v1/dotsaml\")\n+public class DotSamlResource implements Serializable {\n+\n+\tprivate static final long serialVersionUID = 8015545653539491684L;\n+\n+\tprivate final SAMLHelper           \t\t\t\t   samlHelper;\n+\tprivate final SamlAuthenticationService            samlAuthenticationService;\n+\tprivate final IdentityProviderConfigurationFactory identityProviderConfigurationFactory;\n+\n+\tpublic static final List<String> dotsamlPathSegments = new ArrayList<String>() {\n+\t\t{\n+\t\t\tadd(\"login\");\n+\t\t\tadd(\"logout\");\n+\t\t\tadd(\"metadata\");\n+\t\t}\n+\t};\n+\n+\n+\tpublic DotSamlResource() {\n+\n+\t\tthis.samlAuthenticationService            = DotSamlProxyFactory.getInstance().samlAuthenticationService();\n+\t\tthis.identityProviderConfigurationFactory = DotSamlProxyFactory.getInstance().identityProviderConfigurationFactory();\n+\t\tthis.samlHelper                           = new SAMLHelper(this.samlAuthenticationService);\n+\t}\n+\n+\t// Login configuration by id\n+\t@GET\n+\t@Path( \"/login/{idpConfigId}\" )\n+\t@JSONP\n+\t@NoCache\n+\t@Produces( { MediaType.APPLICATION_JSON, \"application/javascript\" } )\n+\tpublic Response doLogin(@PathParam( \"idpConfigId\" ) final String idpConfigId,\n+\t\t\t\t\t\t  @Context final HttpServletRequest httpServletRequest,\n+\t\t\t\t\t\t  @Context final HttpServletResponse httpServletResponse) {\n+\n+\t\tIdentityProviderConfiguration identityProviderConfiguration = null;\n+\n+\t\ttry {\n+\t\t\tif (DotSamlProxyFactory.getInstance().isAnyHostConfiguredAsSAML()) {\n+\n+\t\t\t\tidentityProviderConfiguration =\n+\t\t\t\t\t\tthis.identityProviderConfigurationFactory.findIdentityProviderConfigurationById(idpConfigId);\n+\n+\t\t\t\t// If idpConfig is null, means this site does not need SAML processing\n+\t\t\t\tif (identityProviderConfiguration != null && identityProviderConfiguration.isEnabled()) {\n+\n+\t\t\t\t\tLogger.debug(this, () -> \"Processing saml login request for idpConfig id: \" + idpConfigId);\n+\t\t\t\t\tthis.samlHelper.doRequestLoginSecurityLog(httpServletRequest, identityProviderConfiguration);\n+\n+\t\t\t\t\t// This will redirect the user to the IdP Login Page.\n+\t\t\t\t\tthis.samlAuthenticationService.authentication(httpServletRequest,\n+\t\t\t\t\t\t\thttpServletResponse, identityProviderConfiguration);\n+\n+\t\t\t\t\treturn Response.ok().build();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} finally {\n+\n+\t\t\tif (null != identityProviderConfiguration) {\n+\t\t\t\tidentityProviderConfiguration.destroy();\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal String message = \"No idpConfig for idpConfigId: \" + idpConfigId + \". At \" + httpServletRequest.getRequestURI();\n+\t\tLogger.debug( this, ()-> message);\n+\t\tthrow new SamlException(message);\n+\t}\n+\n+\t@POST\n+\t@Path(\"/login/{idpConfigId}\")\n+\t@Consumes({MediaType.APPLICATION_XML, MediaType.APPLICATION_FORM_URLENCODED})\n+\t@NoCache\n+\tpublic void processLogin(@PathParam(\"idpConfigId\") final String idpConfigId,\n+\t\t\t\t\t  @Context final HttpServletRequest httpServletRequest,\n+\t\t\t\t\t  @Context final HttpServletResponse httpServletResponse) throws IOException {\n+\n+\t\tif (DotSamlProxyFactory.getInstance().isAnyHostConfiguredAsSAML()) {\n+\n+\t\t\tfinal IdentityProviderConfiguration identityProviderConfiguration =\n+\t\t\t\t\tthis.identityProviderConfigurationFactory.findIdentityProviderConfigurationById(idpConfigId);\n+\t\t\ttry {\n+\n+\t\t\t\t// If idpConfig is null, means this site does not need SAML processing\n+\t\t\t\tif (identityProviderConfiguration != null && identityProviderConfiguration.isEnabled()) {\n+\n+\t\t\t\t\tLogger.debug(this, () -> \"Processing saml login request for idpConfig id: \" + idpConfigId);\n+\t\t\t\t\tthis.samlHelper.doRequestLoginSecurityLog(httpServletRequest, identityProviderConfiguration);\n+\n+\t\t\t\t\tfinal HttpSession session = httpServletRequest.getSession();\n+\t\t\t\t\tif (null == session) {\n+\n+\t\t\t\t\t\tthrow new SamlException(\"No session has been created.\");\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Extracts data from the assertion - if it can't process a DotSamlException is thrown\n+\t\t\t\t\tfinal Attributes attributes = this.samlAuthenticationService.resolveAttributes(httpServletRequest,\n+\t\t\t\t\t\t\thttpServletResponse, identityProviderConfiguration);\n+\n+\t\t\t\t\tif (null == attributes) {\n+\n+\t\t\t\t\t\tthrow new SamlException(\"User cannot be extracted from Assertion!\");\n+\t\t\t\t\t}\n+\t\t\t\t\t// Creates the user object and adds a user if it doesn't already exist\n+\t\t\t\t\tfinal User user = this.samlHelper.resolveUser(attributes, identityProviderConfiguration);\n+\t\t\t\t\tif (null == user) {\n+\n+\t\t\t\t\t\tthrow new SamlException(\"User cannot be extracted from Assertion!\");\n+\t\t\t\t\t}\n+\n+\t\t\t\t\tLogger.debug(this, ()-> \"Resolved user: \" + user);\n+\n+\t\t\t\t\tfinal String samlSessionIndex = attributes.getSessionIndex();\n+\t\t\t\t\tif (null != samlSessionIndex) {\n+\n+\t\t\t\t\t\tLogger.debug(this, ()-> \"SAMLSessionIndex: \" + samlSessionIndex);\n+\t\t\t\t\t\t// Session Attributes used to build logout request\n+\t\t\t\t\t\tfinal String sessionIndexKey = identityProviderConfiguration.getId() + DotSamlConstants.SAML_SESSION_INDEX;\n+\t\t\t\t\t\tfinal String samlNameIdKey   = identityProviderConfiguration.getId() + DotSamlConstants.SAML_NAME_ID;\n+\t\t\t\t\t\tsession.setAttribute(sessionIndexKey, samlSessionIndex);\n+\t\t\t\t\t\tsession.setAttribute(samlNameIdKey,  attributes.getNameID());\n+\t\t\t\t\t\tLogger.debug(this, ()->\"Session index with key: \" + sessionIndexKey + \" and value: \" + session.getAttribute(sessionIndexKey) + \" is already set.\");\n+\t\t\t\t\t\tLogger.debug(this, ()->\"NameID with key: \" + samlNameIdKey + \" and value: \" + session.getAttribute(samlNameIdKey) + \" is already set.\");\n+\t\t\t\t\t}\n+\n+\t\t\t\t\t// Add session based user ID to be used on the redirect.\n+\t\t\t\t\tsession.setAttribute(identityProviderConfiguration.getId() + DotSamlConstants.SAML_USER_ID, user.getUserId());\n+\t\t\t\t\tsession.setAttribute(com.liferay.portal.util.WebKeys.USER,    user);\n+\t\t\t\t\tsession.setAttribute(com.liferay.portal.util.WebKeys.USER_ID, user.getUserId());\n+\t\t\t\t\tsession.setAttribute(WebKeys.CMS_USER, user);\n+\n+\t\t\t\t\tString loginPath = (String) session.getAttribute(WebKeys.REDIRECT_AFTER_LOGIN);\n+\t\t\t\t\tif (null == loginPath) {\n+\t\t\t\t\t\t// At this stage we cannot determine whether this was a front\n+\t\t\t\t\t\t// end or back end request since we cannot determine\n+\t\t\t\t\t\t// original request.\n+\t\t\t\t\t\t//\n+\t\t\t\t\t\t// REDIRECT_AFTER_LOGIN should have already been set in relay\n+\t\t\t\t\t\t// request to IdP. 'autoLogin' will check the ORIGINAL_REQUEST\n+\t\t\t\t\t\t// session attribute.\n+\t\t\t\t\t\tloginPath = DotSamlConstants.DEFAULT_LOGIN_PATH;\n+\t\t\t\t\t} else {\n+\n+\t\t\t\t\t\tsession.removeAttribute(WebKeys.REDIRECT_AFTER_LOGIN);\n+\t\t\t\t\t}\n+\n+\t\t\t\t\thttpServletResponse.sendRedirect(loginPath);\n+\t\t\t\t}\n+\t\t\t} finally {\n+\t\t\t\tif (null != identityProviderConfiguration) {\n+\t\t\t\t\tidentityProviderConfiguration.destroy();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tfinal String message = \"No idpConfig for idpConfigId: \" + idpConfigId + \". At \" + httpServletRequest.getRequestURI();\n+\t\tLogger.debug( this, ()-> message);\n+\t\tthrow new SamlException(message);\n+\t}\n+\n+\t// Gets metadata configuration by id\n+\t@GET\n+\t@Path( \"/metadata/{idpConfigId}\" )\n+\t@JSONP\n+\t@NoCache\n+\t@Produces( { MediaType.APPLICATION_JSON, \"application/javascript\" } )\n+\tpublic void metadata( @PathParam( \"idpConfigId\" ) final String idpConfigId,\n+\t\t\t\t\t\t  @Context final HttpServletRequest httpServletRequest,\n+\t\t\t\t\t\t  @Context final HttpServletResponse httpServletResponse ) throws IOException {\n+\n+\t\tboolean noConfig = true;\n+\n+\t\tif (DotSamlProxyFactory.getInstance().isAnyHostConfiguredAsSAML()) {\n+\n+\t\t\tfinal IdentityProviderConfiguration identityProviderConfiguration =\n+\t\t\t\t\tthis.identityProviderConfigurationFactory.findIdentityProviderConfigurationById(idpConfigId);\n+\t\t\ttry {\n+\t\t\t\t// If idpConfig is null, means this site does not need SAML processing\n+\t\t\t\tif (identityProviderConfiguration != null && identityProviderConfiguration.isEnabled()) {\n+\n+\t\t\t\t\tLogger.debug(this, () -> \"Processing saml login request for idpConfig id: \" + idpConfigId);\n+\t\t\t\t\tthis.samlAuthenticationService.renderMetadataXML(httpServletResponse.getWriter(), identityProviderConfiguration);\n+\t\t\t\t\tnoConfig = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTU4NjU2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/saml/DotSamlProxyFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjo1MTozOFrOG5rj0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxOToxMzowOFrOG6TMfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEzNTY5OQ==", "bodyText": "is this the intended???? We're adding the same rule to the DotUrlRewriteFilter every time we call getInstance", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463135699", "createdAt": "2020-07-30T16:51:38Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/saml/DotSamlProxyFactory.java", "diffHunk": "@@ -0,0 +1,267 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.auth.providers.saml.v1.DotSamlResource;\n+import com.dotcms.osgi.OSGIConstants;\n+import com.dotcms.security.apps.AppDescriptor;\n+import com.dotcms.security.apps.AppSecretSavedEvent;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.security.apps.Secret;\n+import com.dotcms.system.event.local.model.EventSubscriber;\n+import com.dotcms.system.event.local.model.KeyFilterable;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.filters.DotUrlRewriteFilter;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+import org.apache.felix.framework.OSGIUtil;\n+import org.tuckey.web.filters.urlrewrite.NormalRule;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * This is the proxy to provides the object to interact with the Saml Osgi Bundle\n+ *\n+ * @author jsanca\n+ */\n+public class DotSamlProxyFactory implements EventSubscriber<AppSecretSavedEvent>, KeyFilterable {\n+\n+    public static final String SAML_APP_CONFIG_KEY = \"dotsaml-config\";\n+    public static final String PROPERTIES_PATH     = File.separator + \"saml\" + File.separator + \"dotcms-saml-default.properties\";\n+\n+    private static final String ASSETS_PATH   = Config.getStringProperty(\"ASSET_REAL_PATH\",\n+            FileUtil.getRealPath(Config.getStringProperty(\"ASSET_PATH\", \"/assets\")));\n+    private static final String IDP_FILE_PATH = ASSETS_PATH + PROPERTIES_PATH;\n+\n+    private final MessageObserver    messageObserver    = new DotLoggerMessageObserver();\n+    private final AppsAPI            appsAPI            = APILocator.getAppsAPI();\n+    private final IdentityProviderConfigurationFactory identityProviderConfigurationFactory =\n+            new DotIdentityProviderConfigurationFactoryImpl(this.appsAPI, APILocator.getHostAPI());\n+\n+    private SamlServiceBuilder        samlServiceBuilder;\n+    private SamlConfigurationService  samlConfigurationService;\n+    private SamlAuthenticationService samlAuthenticationService;\n+\n+    private static class SingletonHolder {\n+\n+        private static final DotSamlProxyFactory INSTANCE = new DotSamlProxyFactory();\n+    }\n+    /**\n+     * Get the instance.\n+     * @return DotSamlFactory\n+     */\n+    public static DotSamlProxyFactory getInstance() {\n+\n+        addRedirects();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc4NTA4NQ==", "bodyText": "Good catch", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463785085", "createdAt": "2020-07-31T19:13:08Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/saml/DotSamlProxyFactory.java", "diffHunk": "@@ -0,0 +1,267 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.auth.providers.saml.v1.DotSamlResource;\n+import com.dotcms.osgi.OSGIConstants;\n+import com.dotcms.security.apps.AppDescriptor;\n+import com.dotcms.security.apps.AppSecretSavedEvent;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.security.apps.Secret;\n+import com.dotcms.system.event.local.model.EventSubscriber;\n+import com.dotcms.system.event.local.model.KeyFilterable;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.filters.DotUrlRewriteFilter;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+import org.apache.felix.framework.OSGIUtil;\n+import org.tuckey.web.filters.urlrewrite.NormalRule;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * This is the proxy to provides the object to interact with the Saml Osgi Bundle\n+ *\n+ * @author jsanca\n+ */\n+public class DotSamlProxyFactory implements EventSubscriber<AppSecretSavedEvent>, KeyFilterable {\n+\n+    public static final String SAML_APP_CONFIG_KEY = \"dotsaml-config\";\n+    public static final String PROPERTIES_PATH     = File.separator + \"saml\" + File.separator + \"dotcms-saml-default.properties\";\n+\n+    private static final String ASSETS_PATH   = Config.getStringProperty(\"ASSET_REAL_PATH\",\n+            FileUtil.getRealPath(Config.getStringProperty(\"ASSET_PATH\", \"/assets\")));\n+    private static final String IDP_FILE_PATH = ASSETS_PATH + PROPERTIES_PATH;\n+\n+    private final MessageObserver    messageObserver    = new DotLoggerMessageObserver();\n+    private final AppsAPI            appsAPI            = APILocator.getAppsAPI();\n+    private final IdentityProviderConfigurationFactory identityProviderConfigurationFactory =\n+            new DotIdentityProviderConfigurationFactoryImpl(this.appsAPI, APILocator.getHostAPI());\n+\n+    private SamlServiceBuilder        samlServiceBuilder;\n+    private SamlConfigurationService  samlConfigurationService;\n+    private SamlAuthenticationService samlAuthenticationService;\n+\n+    private static class SingletonHolder {\n+\n+        private static final DotSamlProxyFactory INSTANCE = new DotSamlProxyFactory();\n+    }\n+    /**\n+     * Get the instance.\n+     * @return DotSamlFactory\n+     */\n+    public static DotSamlProxyFactory getInstance() {\n+\n+        addRedirects();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEzNTY5OQ=="}, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTU5OTE0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/saml/DotSamlProxyFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjo1NDo1M1rOG5rrWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjo1NDo1M1rOG5rrWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEzNzYyNA==", "bodyText": "good.", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463137624", "createdAt": "2020-07-30T16:54:53Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/saml/DotSamlProxyFactory.java", "diffHunk": "@@ -0,0 +1,267 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.auth.providers.saml.v1.DotSamlResource;\n+import com.dotcms.osgi.OSGIConstants;\n+import com.dotcms.security.apps.AppDescriptor;\n+import com.dotcms.security.apps.AppSecretSavedEvent;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.security.apps.Secret;\n+import com.dotcms.system.event.local.model.EventSubscriber;\n+import com.dotcms.system.event.local.model.KeyFilterable;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.filters.DotUrlRewriteFilter;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+import org.apache.felix.framework.OSGIUtil;\n+import org.tuckey.web.filters.urlrewrite.NormalRule;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * This is the proxy to provides the object to interact with the Saml Osgi Bundle\n+ *\n+ * @author jsanca\n+ */\n+public class DotSamlProxyFactory implements EventSubscriber<AppSecretSavedEvent>, KeyFilterable {\n+\n+    public static final String SAML_APP_CONFIG_KEY = \"dotsaml-config\";\n+    public static final String PROPERTIES_PATH     = File.separator + \"saml\" + File.separator + \"dotcms-saml-default.properties\";\n+\n+    private static final String ASSETS_PATH   = Config.getStringProperty(\"ASSET_REAL_PATH\",\n+            FileUtil.getRealPath(Config.getStringProperty(\"ASSET_PATH\", \"/assets\")));\n+    private static final String IDP_FILE_PATH = ASSETS_PATH + PROPERTIES_PATH;\n+\n+    private final MessageObserver    messageObserver    = new DotLoggerMessageObserver();\n+    private final AppsAPI            appsAPI            = APILocator.getAppsAPI();\n+    private final IdentityProviderConfigurationFactory identityProviderConfigurationFactory =\n+            new DotIdentityProviderConfigurationFactoryImpl(this.appsAPI, APILocator.getHostAPI());\n+\n+    private SamlServiceBuilder        samlServiceBuilder;\n+    private SamlConfigurationService  samlConfigurationService;\n+    private SamlAuthenticationService samlAuthenticationService;\n+\n+    private static class SingletonHolder {\n+\n+        private static final DotSamlProxyFactory INSTANCE = new DotSamlProxyFactory();\n+    }\n+    /**\n+     * Get the instance.\n+     * @return DotSamlFactory\n+     */\n+    public static DotSamlProxyFactory getInstance() {\n+\n+        addRedirects();\n+        return DotSamlProxyFactory.SingletonHolder.INSTANCE;\n+    } // getInstance.\n+\n+    /**\n+     * Key for the discard non-SAML AppSecretSavedEvent\n+     * @return Comparable\n+     */\n+    @Override\n+    public Comparable getKey() {\n+        return SAML_APP_CONFIG_KEY;\n+    }\n+\n+    /**\n+     * When\n+     * @param event\n+     */\n+    @Override\n+    public void notify(final AppSecretSavedEvent event) {\n+\n+        final  Map<String, Secret> secretMap = event.getAppSecrets().getSecrets();\n+        if (null != secretMap) {\n+\n+            SamlValidator.validateURL(\"sPEndpointHostname\", secretMap.get(\"sPEndpointHostname\").getString(), event.getUserId());\n+            SamlValidator.validateXML(\"idPMetadataFile\",    secretMap.get(\"idPMetadataFile\").getString(),    event.getUserId());\n+        }\n+    }\n+\n+    /**\n+     * Returns the dotCMS implementation of the identity provider config.\n+     * This one basically returns (if exists) the configuration for a idp for a host\n+     * @return IdentityProviderConfigurationFactory\n+     */\n+    public IdentityProviderConfigurationFactory identityProviderConfigurationFactory() {\n+\n+        return identityProviderConfigurationFactory;\n+    }\n+\n+    private static void addRedirects() {\n+\n+        final NormalRule rule = new NormalRule();\n+        rule.setFrom(\"^\\\\/dotsaml\\\\/(\"+String.join(\"|\", DotSamlResource.dotsamlPathSegments)+\")\\\\/(.+)$\");\n+        rule.setToType(\"forward\");\n+        rule.setTo(\"/api/v1/dotsaml/$1/$2\");\n+        rule.setName(\"Dotsaml REST Service Redirect\");\n+        DotUrlRewriteFilter urlRewriteFilter = DotUrlRewriteFilter.getUrlRewriteFilter();\n+        try {\n+            if(urlRewriteFilter != null) {\n+                urlRewriteFilter.addRule(rule);\n+            }else {\n+                throw new Exception();\n+            }\n+        } catch (Exception e) {\n+            Logger.error(DotSamlProxyFactory.class, \"Could not add the Dotsaml REST Service Redirect Rule. Requests to \" +\n+                    \"/dotsaml/login/{UUID} will fail!\");\n+        }\n+    }\n+\n+    private SamlServiceBuilder samlServiceBuilder() {\n+\n+        if (null == this.samlServiceBuilder) {\n+\n+            synchronized (this) {\n+\n+                if (null == this.samlServiceBuilder) {\n+\n+\n+                    try {\n+                        if (!OSGIUtil.getInstance().isInitialized()) {\n+                            Logger.warn(this.getClass(),\n+                                    \"OSGI Framework not initialized, trying to initialize...\");\n+                            OSGIUtil.getInstance().initializeFramework(Config.CONTEXT);\n+                        }\n+                    } catch (Exception e) {\n+\n+                        Logger.error(this.getClass(), \"Unable to initialized OSGI Framework\", e);\n+                    }\n+\n+                    if (OSGIUtil.getInstance().isInitialized()) {\n+                        try {\n+\n+                            this.samlServiceBuilder = OSGIUtil.getInstance().getService(SamlServiceBuilder.class,\n+                                    OSGIConstants.BUNDLE_NAME_DOTCMS_SAML);\n+\n+                            Logger.info(this, \"SAML Osgi Bundle has been started\");\n+                        } catch (Exception e) {\n+                            Logger.error(this.getClass(),\n+                                    String.format(\"Failure retrieving OSGI Service [%s] in bundle [%s]\",\n+                                            SamlServiceBuilder.class,\n+                                            OSGIConstants.BUNDLE_NAME_DOTCMS_SAML), e);\n+                        }\n+                    } else {\n+\n+                        Logger.error(this.getClass(), \"OSGI Framework is not initialized, SAML couldn't start\");\n+                    }\n+                }\n+            }\n+        }\n+\n+        return this.samlServiceBuilder;\n+    }\n+\n+    /**\n+     * Returns the dotCMS implementation of the {@link MessageObserver} for the saml osgi bundle\n+     * @return MessageObserver\n+     */\n+    private MessageObserver messageObserver() {\n+\n+        return this.messageObserver;\n+    }\n+\n+    /**\n+     * Returns the service that helps to retrieve the actual values or default values from the {@link com.dotcms.saml.IdentityProviderConfiguration}\n+     *\n+     * @return SamlConfigurationService\n+     */\n+    public SamlConfigurationService samlConfigurationService() {\n+\n+        if (null == this.samlConfigurationService) {\n+\n+            final SamlServiceBuilder samlServiceBuilder = this.samlServiceBuilder();\n+            if (null != samlServiceBuilder) {\n+\n+                synchronized (this) {\n+\n+                    if (null == this.samlConfigurationService) {\n+\n+                        this.samlConfigurationService = samlServiceBuilder.buildSamlConfigurationService();\n+                        this.samlConfigurationService.initService(\n+                                CollectionsUtils.map(SamlConfigurationService.DOT_SAML_DEFAULT_PROPERTIES_CONTEXT_MAP_KEY, IDP_FILE_PATH));\n+                    }\n+                }\n+            } else {\n+\n+                Logger.error(this.getClass(), \"OSGI Framework may be not initialized, couldn't get the Saml Configuration\");\n+            }\n+        }\n+\n+        return this.samlConfigurationService;\n+    }\n+\n+    /**\n+     * Retrieve the authentication service, this is the proxy with the SAML Osgi bundle and must exists at least one host configurated with SAML in order to init this service.\n+     * @return SamlAuthenticationService\n+     */\n+    public SamlAuthenticationService samlAuthenticationService() {\n+\n+        if (this.isAnyHostConfiguredAsSAML()) {\n+\n+            if (null == this.samlAuthenticationService) {\n+\n+                final SamlServiceBuilder samlServiceBuilder = this.samlServiceBuilder();\n+\n+                if (null != samlServiceBuilder) {\n+\n+                    synchronized (this) {\n+\n+                        if (null == this.samlAuthenticationService) {\n+\n+                            this.samlAuthenticationService =\n+                                    this.samlServiceBuilder.buildAuthenticationService(this.identityProviderConfigurationFactory(),\n+                                            this.messageObserver(), this.samlConfigurationService());\n+\n+                            Logger.info(this, \"Initing SAML Authentication\");\n+                            samlAuthenticationService.initService(Collections.emptyMap());\n+                        }\n+                    }\n+                } else {\n+\n+                    Logger.error(this.getClass(), \"OSGI Framework may be not initialized, couldn't get the Saml Configuration\");\n+                }\n+            }\n+\n+            return this.samlAuthenticationService;\n+        }\n+\n+        throw new SamlException(\"Not any host has been configured as a SAML\");\n+    }\n+\n+    /**\n+     * Returns true is any host is configured as a SAML\n+     * @return boolean\n+     */\n+    public boolean isAnyHostConfiguredAsSAML () {\n+\n+        boolean isAnyConfigured = false;\n+        final User user         = APILocator.systemUser();\n+\n+        final Optional<AppDescriptor> appDescriptorOptional = Try.of(\n+                ()-> this.appsAPI\n+                        .getAppDescriptor(SAML_APP_CONFIG_KEY, user)).getOrElseGet(e-> Optional.empty());\n+        if (appDescriptorOptional.isPresent()) {\n+\n+            final AppDescriptor appDescriptor = appDescriptorOptional.get();\n+\n+            final Map<String, Set<String>>  appKeysByHost = Try.of(()-> this.appsAPI.appKeysByHost())\n+                    .getOrElseGet(e -> Collections.emptyMap());\n+            final Set<String> sitesWithConfigurations     = this.appsAPI\n+                    .filterSitesForAppKey(appDescriptor.getKey(), appKeysByHost.keySet(), user);\n+\n+            isAnyConfigured                   = !sitesWithConfigurations.isEmpty();\n+        }\n+\n+        return isAnyConfigured;\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 266}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTc0NTMwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/saml/DotIdentityProviderConfigurationImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNzozNjoxNFrOG5tHGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxOToxMTozM1rOG6TJ3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2MTExMw==", "bodyText": "seems like you're assuming you're never gonna get an \"empty\".\nyou should probably make appSecrets var Optional and not assume its present at all times", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463161113", "createdAt": "2020-07-30T17:36:14Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/saml/DotIdentityProviderConfigurationImpl.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.security.apps.AppSecrets;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.security.apps.Secret;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Default implementation to retrieve the configuration from apps\n+ * @author jsanca\n+ */\n+public class DotIdentityProviderConfigurationImpl implements IdentityProviderConfiguration {\n+\n+    private final AppsAPI    appsAPI;\n+    private final Host       host;\n+    private final AppSecrets appSecrets;\n+\n+    public DotIdentityProviderConfigurationImpl(final AppsAPI appsAPI, final Host host) throws DotSecurityException, DotDataException {\n+\n+        this.appsAPI    = appsAPI;\n+        this.host       = host;\n+        this.appSecrets = this.appsAPI.getSecrets(DotSamlProxyFactory.SAML_APP_CONFIG_KEY,\n+                true, host, APILocator.systemUser()).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc4NDQxMg==", "bodyText": "before making this, we verify that the secrets exists, so I guess it should be ok", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463784412", "createdAt": "2020-07-31T19:11:33Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/saml/DotIdentityProviderConfigurationImpl.java", "diffHunk": "@@ -0,0 +1,130 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.security.apps.AppSecrets;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.security.apps.Secret;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Default implementation to retrieve the configuration from apps\n+ * @author jsanca\n+ */\n+public class DotIdentityProviderConfigurationImpl implements IdentityProviderConfiguration {\n+\n+    private final AppsAPI    appsAPI;\n+    private final Host       host;\n+    private final AppSecrets appSecrets;\n+\n+    public DotIdentityProviderConfigurationImpl(final AppsAPI appsAPI, final Host host) throws DotSecurityException, DotDataException {\n+\n+        this.appsAPI    = appsAPI;\n+        this.host       = host;\n+        this.appSecrets = this.appsAPI.getSecrets(DotSamlProxyFactory.SAML_APP_CONFIG_KEY,\n+                true, host, APILocator.systemUser()).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2MTExMw=="}, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTg4MDQ2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODoxNDo0MFrOG5ucKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODoxNDo0MFrOG5ucKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4Mjg5MA==", "bodyText": "This destroys the secrets. NICE", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463182890", "createdAt": "2020-07-30T18:14:40Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.rest.annotation.NoCache;\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.IdentityProviderConfigurationFactory;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotmarketing.exception.DoesNotExistException;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.WebKeys;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.server.JSONP;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@Path(\"/v1/dotsaml\")\n+public class DotSamlResource implements Serializable {\n+\n+\tprivate static final long serialVersionUID = 8015545653539491684L;\n+\n+\tprivate final SAMLHelper           \t\t\t\t   samlHelper;\n+\tprivate final SamlAuthenticationService            samlAuthenticationService;\n+\tprivate final IdentityProviderConfigurationFactory identityProviderConfigurationFactory;\n+\n+\tpublic static final List<String> dotsamlPathSegments = new ArrayList<String>() {\n+\t\t{\n+\t\t\tadd(\"login\");\n+\t\t\tadd(\"logout\");\n+\t\t\tadd(\"metadata\");\n+\t\t}\n+\t};\n+\n+\n+\tpublic DotSamlResource() {\n+\n+\t\tthis.samlAuthenticationService            = DotSamlProxyFactory.getInstance().samlAuthenticationService();\n+\t\tthis.identityProviderConfigurationFactory = DotSamlProxyFactory.getInstance().identityProviderConfigurationFactory();\n+\t\tthis.samlHelper                           = new SAMLHelper(this.samlAuthenticationService);\n+\t}\n+\n+\t// Login configuration by id\n+\t@GET\n+\t@Path( \"/login/{idpConfigId}\" )\n+\t@JSONP\n+\t@NoCache\n+\t@Produces( { MediaType.APPLICATION_JSON, \"application/javascript\" } )\n+\tpublic Response doLogin(@PathParam( \"idpConfigId\" ) final String idpConfigId,\n+\t\t\t\t\t\t  @Context final HttpServletRequest httpServletRequest,\n+\t\t\t\t\t\t  @Context final HttpServletResponse httpServletResponse) {\n+\n+\t\tIdentityProviderConfiguration identityProviderConfiguration = null;\n+\n+\t\ttry {\n+\t\t\tif (DotSamlProxyFactory.getInstance().isAnyHostConfiguredAsSAML()) {\n+\n+\t\t\t\tidentityProviderConfiguration =\n+\t\t\t\t\t\tthis.identityProviderConfigurationFactory.findIdentityProviderConfigurationById(idpConfigId);\n+\n+\t\t\t\t// If idpConfig is null, means this site does not need SAML processing\n+\t\t\t\tif (identityProviderConfiguration != null && identityProviderConfiguration.isEnabled()) {\n+\n+\t\t\t\t\tLogger.debug(this, () -> \"Processing saml login request for idpConfig id: \" + idpConfigId);\n+\t\t\t\t\tthis.samlHelper.doRequestLoginSecurityLog(httpServletRequest, identityProviderConfiguration);\n+\n+\t\t\t\t\t// This will redirect the user to the IdP Login Page.\n+\t\t\t\t\tthis.samlAuthenticationService.authentication(httpServletRequest,\n+\t\t\t\t\t\t\thttpServletResponse, identityProviderConfiguration);\n+\n+\t\t\t\t\treturn Response.ok().build();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} finally {\n+\n+\t\t\tif (null != identityProviderConfiguration) {\n+\t\t\t\tidentityProviderConfiguration.destroy();\n+\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTkwNjkzOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxODoyMjoxNVrOG5usQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoyMDowMlrOG6RyVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4NzAxMQ==", "bodyText": "rename to DotSamlException for consistency", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463187011", "createdAt": "2020-07-30T18:22:15Z", "author": {"login": "fabrizzio-dotCMS"}, "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.rest.annotation.NoCache;\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.IdentityProviderConfigurationFactory;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc2MjAwNw==", "bodyText": "Done", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463762007", "createdAt": "2020-07-31T18:20:02Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/DotSamlResource.java", "diffHunk": "@@ -0,0 +1,232 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.rest.annotation.NoCache;\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.IdentityProviderConfigurationFactory;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE4NzAxMQ=="}, "originalCommit": {"oid": "c9ab4a5741e430712727366c1e06afdc7ed62ade"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNDY3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMDo1NVrOG6RhwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMDo1NVrOG6RhwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzc2MA==", "bodyText": "Codacy found an issue: Substitute calls to size() == 0 (or size() != 0, size() > 0, size() < 1) with calls to isEmpty()", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757760", "createdAt": "2020-07-31T18:10:55Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "diffHunk": "@@ -0,0 +1,469 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotcms.saml.SamlName;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.cms.factories.PublicEncryptionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.ActivityLogger;\n+import com.dotmarketing.util.AdminLogger;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UUIDGenerator;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.User;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.dotmarketing.util.UtilMethods.isSet;\n+\n+public class SAMLHelper {\n+\n+    private final HostWebAPI hostWebAPI;\n+    private final UserAPI    userAPI;\n+    private final RoleAPI    roleAPI;\n+    private final SamlAuthenticationService  samlAuthenticationService;\n+\n+    public SAMLHelper(final SamlAuthenticationService samlAuthenticationService) {\n+\n+        this.userAPI      = APILocator.getUserAPI();\n+        this.roleAPI      = APILocator.getRoleAPI();\n+        this.hostWebAPI   = WebAPILocator.getHostWebAPI();\n+        this.samlAuthenticationService = samlAuthenticationService;\n+    }\n+\n+    // Gets the attributes from the Assertion, based on the attributes\n+    // see if the user exists return it from the dotCMS records, if does not\n+    // exist then, tries to create it.\n+    // the existing or created user, will be updated the roles if they present\n+    // on the assertion.\n+    protected User resolveUser(final Attributes attributes,\n+                             final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        User user       = null;\n+        User systemUser = null;\n+        try {\n+\n+            Logger.debug(this, ()-> \"Validating user - \" + attributes);\n+\n+            systemUser             = this.userAPI.getSystemUser();\n+            final Company company  = APILocator.getCompanyAPI().getDefaultCompany();\n+            final String  authType = company.getAuthType();\n+            user                   = Company.AUTH_TYPE_ID.equals(authType)?\n+                    this.userAPI.loadUserById(this.samlAuthenticationService.getValue(attributes.getNameID()),      systemUser, false):\n+                    this.userAPI.loadByUserByEmail(this.samlAuthenticationService.getValue(attributes.getNameID()), systemUser, false);\n+        } catch (NoSuchUserException e) {\n+\n+            Logger.error(this, \"No user matches ID '\" +\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()) + \"'. Creating one...\", e);\n+            user = null;\n+        } catch (Exception e) {\n+\n+            Logger.error(this, \"An error occurred when loading user with ID '\" +\n+                    (null != attributes && null != attributes.getNameID()?\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()): \"null\") + \"'\", e);\n+            user = null;\n+        }\n+\n+        // check if the client wants synchronization\n+        final boolean createUserWhenDoesNotExists = DotSamlProxyFactory.getInstance()\n+                .samlConfigurationService().getConfigAsBoolean(identityProviderConfiguration, SamlName.DOT_SAML_ALLOW_USER_SYNCHRONIZATION);\n+        if (createUserWhenDoesNotExists) {\n+\n+            user = null == user?\n+                    this.createNewUser(systemUser,    attributes, identityProviderConfiguration):  // if user does not exists, create a new one.\n+                    this.updateUser(user, systemUser, attributes, identityProviderConfiguration); // update it, since exists\n+\n+            if (user.isActive()) {\n+\n+                this.addRoles(user, attributes, identityProviderConfiguration);\n+            } else {\n+\n+                Logger.info(this, ()-> \"User with ID '\" + this.samlAuthenticationService.getValue(attributes.getNameID()) + \"' is not active. No roles \" +\n+                        \"were added.\");\n+            }\n+        }\n+\n+        return user;\n+    }\n+\n+    protected User updateUser(final User user, final User systemUser,\n+                              final Attributes attributesBean, final IdentityProviderConfiguration identityProviderConfiguration) {\n+        try {\n+\n+            if (DotSamlProxyFactory.getInstance().samlConfigurationService()\n+                    .getConfigAsBoolean(identityProviderConfiguration, SamlName.DOTCMS_SAML_LOGIN_UPDATE_EMAIL)){\n+\n+                user.setEmailAddress(attributesBean.getEmail());\n+            }\n+\n+            user.setFirstName(attributesBean.getFirstName());\n+            user.setLastName(attributesBean.getLastName());\n+\n+            this.userAPI.save(user, systemUser, false);\n+            Logger.debug(this, ()-> \"User with email '\" + attributesBean.getEmail() + \"' has been updated\");\n+        } catch (Exception e) {\n+\n+            Logger.error(this, \"Error updating user with email '\" + attributesBean.getEmail() + \"': \" + e.getMessage()\n+                    , e);\n+            throw new SamlException(e.getMessage());\n+        }\n+\n+        return user;\n+    }\n+\n+    private String getBuildRoles(final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        final String buildRolesStrategy = DotSamlProxyFactory.getInstance()\n+                .samlConfigurationService().getConfigAsString(identityProviderConfiguration, SamlName.DOTCMS_SAML_BUILD_ROLES);\n+\n+        return this.checkBuildRoles(buildRolesStrategy)?\n+                buildRolesStrategy: this.getDefaultBuildRoles(buildRolesStrategy);\n+    }\n+\n+    private String getDefaultBuildRoles(final String invalidBuildRolesStrategy) {\n+        Logger.info(this, ()-> \"The build.roles: \" + invalidBuildRolesStrategy + \", property is invalid. Using the default \" +\n+                \"strategy: \" + DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_ALL_VALUE);\n+\n+        return DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_ALL_VALUE;\n+    }\n+\n+    public boolean checkBuildRoles(final String buildRolesProperty) {\n+\n+        return DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_ALL_VALUE.equalsIgnoreCase( buildRolesProperty )  ||\n+                DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_IDP_VALUE.equalsIgnoreCase( buildRolesProperty ) ||\n+                DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_STATIC_ONLY_VALUE.equalsIgnoreCase( buildRolesProperty ) ||\n+                DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_STATIC_ADD_VALUE.equalsIgnoreCase( buildRolesProperty )  ||\n+                DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_NONE_VALUE.equalsIgnoreCase( buildRolesProperty );\n+    }\n+\n+    private void addRoles(final User user, final Attributes attributesBean, final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        final String buildRolesStrategy = this.getBuildRoles(identityProviderConfiguration);\n+\n+        Logger.debug(this, ()-> \"Using the build roles Strategy: \" + buildRolesStrategy);\n+\n+        if (!DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_NONE_VALUE.equalsIgnoreCase(buildRolesStrategy)) {\n+            try {\n+                // remove previous roles\n+                if (!DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_STATIC_ADD_VALUE.equalsIgnoreCase(buildRolesStrategy)) {\n+\n+                    Logger.debug(this, ()-> \"Removing ALL existing roles from user '\" + user.getUserId() + \"'...\");\n+                    this.roleAPI.removeAllRolesFromUser(user);\n+                } else {\n+\n+                    Logger.debug(this, ()-> \"The buildRoles strategy is: 'staticadd'. It won't remove any existing dotCMS role\");\n+                }\n+\n+                this.handleRoles(user, attributesBean, identityProviderConfiguration, buildRolesStrategy);\n+            } catch (DotDataException e) {\n+\n+                Logger.error(this, \"Error adding roles to user '\" + user.getUserId() + \"': \" + e.getMessage(), e);\n+                throw new SamlException(e.getMessage());\n+            }\n+        } else {\n+\n+            Logger.info(this, ()->\"The build roles strategy is 'none'. No user roles were added/changed.\");\n+        }\n+    }\n+\n+    private void handleRoles(final User user, final Attributes attributesBean,\n+                             final IdentityProviderConfiguration identityProviderConfiguration,\n+                             final String buildRolesStrategy) throws DotDataException {\n+\n+        this.addRolesFromIDP(user, attributesBean, identityProviderConfiguration, buildRolesStrategy);\n+\n+        // Add SAML User role\n+        this.addRole(user, DotSamlConstants.DOTCMS_SAML_USER_ROLE, true, true);\n+        Logger.debug(this, ()->\"Default SAML User role has been assigned\");\n+\n+        // the only strategy that does not include the saml user role is the \"idp\"\n+        if (!DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_IDP_VALUE.equalsIgnoreCase(buildRolesStrategy)) {\n+            // Add DOTCMS_SAML_OPTIONAL_USER_ROLE\n+            if (DotSamlProxyFactory.getInstance().samlConfigurationService().getConfigAsString(identityProviderConfiguration,\n+                    SamlName.DOTCMS_SAML_OPTIONAL_USER_ROLE) != null) {\n+\n+                this.addRole(user, DotSamlProxyFactory.getInstance().samlConfigurationService().getConfigAsString(identityProviderConfiguration,\n+                        SamlName.DOTCMS_SAML_OPTIONAL_USER_ROLE), false, false);\n+                Logger.debug(this, ()-> \"Optional user role: \" +\n+                        DotSamlProxyFactory.getInstance().samlConfigurationService().getConfigAsString(identityProviderConfiguration,\n+                                SamlName.DOTCMS_SAML_OPTIONAL_USER_ROLE) + \" has been assigned\");\n+            }\n+        } else {\n+\n+            Logger.info(this, \"The build roles strategy is 'idp'. No saml_user_role has been added\");\n+        }\n+    }\n+\n+    private boolean isValidRole(final String role, final String[] rolePatterns) {\n+\n+        boolean isValidRole = false;\n+\n+        if (null != rolePatterns) {\n+            for (final String rolePattern : rolePatterns) {\n+                Logger.debug(this, ()-> \"Valid Role: \" + role + \", pattern: \" + rolePattern);\n+                isValidRole |= this.match(role, rolePattern);\n+            }\n+        } else {\n+            // if not pattern, role is valid.\n+            isValidRole = true;\n+        }\n+\n+        return isValidRole;\n+    }\n+\n+    private boolean match(final String role, final String rolePattern) {\n+        String uftRole = null;\n+\n+        try {\n+\n+            uftRole = URLDecoder.decode(role, \"UTF-8\");\n+        } catch (UnsupportedEncodingException e) {\n+            uftRole = role;\n+        }\n+\n+        return RegEX.contains(uftRole, rolePattern);\n+    }\n+\n+    private void addRolesFromIDP(final User user, final Attributes attributesBean, final IdentityProviderConfiguration identityProviderConfiguration,\n+                                 final String buildRolesStrategy) throws DotDataException {\n+\n+        final boolean includeIDPRoles = DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_ALL_VALUE.equalsIgnoreCase(buildRolesStrategy)\n+                || DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_IDP_VALUE.equalsIgnoreCase(buildRolesStrategy);\n+\n+        Logger.debug(this, ()-> \"Including roles from IdP '\" + includeIDPRoles + \"' for the build roles Strategy: \" + buildRolesStrategy);\n+\n+        if (includeIDPRoles && attributesBean.isAddRoles() && null != attributesBean.getRoles()) {\n+\n+            final List<String> roleList = this.samlAuthenticationService.getValues(attributesBean.getRoles());\n+            if (null != roleList && roleList.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 261}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNDcyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMDo1NlrOG6Rhxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMDo1NlrOG6Rhxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzc2Nw==", "bodyText": "Codacy found an issue: Consider using varargs for methods or constructors which take an array the last parameter.", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757767", "createdAt": "2020-07-31T18:10:56Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "diffHunk": "@@ -0,0 +1,469 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotcms.saml.SamlName;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.cms.factories.PublicEncryptionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.ActivityLogger;\n+import com.dotmarketing.util.AdminLogger;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UUIDGenerator;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.User;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.dotmarketing.util.UtilMethods.isSet;\n+\n+public class SAMLHelper {\n+\n+    private final HostWebAPI hostWebAPI;\n+    private final UserAPI    userAPI;\n+    private final RoleAPI    roleAPI;\n+    private final SamlAuthenticationService  samlAuthenticationService;\n+\n+    public SAMLHelper(final SamlAuthenticationService samlAuthenticationService) {\n+\n+        this.userAPI      = APILocator.getUserAPI();\n+        this.roleAPI      = APILocator.getRoleAPI();\n+        this.hostWebAPI   = WebAPILocator.getHostWebAPI();\n+        this.samlAuthenticationService = samlAuthenticationService;\n+    }\n+\n+    // Gets the attributes from the Assertion, based on the attributes\n+    // see if the user exists return it from the dotCMS records, if does not\n+    // exist then, tries to create it.\n+    // the existing or created user, will be updated the roles if they present\n+    // on the assertion.\n+    protected User resolveUser(final Attributes attributes,\n+                             final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        User user       = null;\n+        User systemUser = null;\n+        try {\n+\n+            Logger.debug(this, ()-> \"Validating user - \" + attributes);\n+\n+            systemUser             = this.userAPI.getSystemUser();\n+            final Company company  = APILocator.getCompanyAPI().getDefaultCompany();\n+            final String  authType = company.getAuthType();\n+            user                   = Company.AUTH_TYPE_ID.equals(authType)?\n+                    this.userAPI.loadUserById(this.samlAuthenticationService.getValue(attributes.getNameID()),      systemUser, false):\n+                    this.userAPI.loadByUserByEmail(this.samlAuthenticationService.getValue(attributes.getNameID()), systemUser, false);\n+        } catch (NoSuchUserException e) {\n+\n+            Logger.error(this, \"No user matches ID '\" +\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()) + \"'. Creating one...\", e);\n+            user = null;\n+        } catch (Exception e) {\n+\n+            Logger.error(this, \"An error occurred when loading user with ID '\" +\n+                    (null != attributes && null != attributes.getNameID()?\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()): \"null\") + \"'\", e);\n+            user = null;\n+        }\n+\n+        // check if the client wants synchronization\n+        final boolean createUserWhenDoesNotExists = DotSamlProxyFactory.getInstance()\n+                .samlConfigurationService().getConfigAsBoolean(identityProviderConfiguration, SamlName.DOT_SAML_ALLOW_USER_SYNCHRONIZATION);\n+        if (createUserWhenDoesNotExists) {\n+\n+            user = null == user?\n+                    this.createNewUser(systemUser,    attributes, identityProviderConfiguration):  // if user does not exists, create a new one.\n+                    this.updateUser(user, systemUser, attributes, identityProviderConfiguration); // update it, since exists\n+\n+            if (user.isActive()) {\n+\n+                this.addRoles(user, attributes, identityProviderConfiguration);\n+            } else {\n+\n+                Logger.info(this, ()-> \"User with ID '\" + this.samlAuthenticationService.getValue(attributes.getNameID()) + \"' is not active. No roles \" +\n+                        \"were added.\");\n+            }\n+        }\n+\n+        return user;\n+    }\n+\n+    protected User updateUser(final User user, final User systemUser,\n+                              final Attributes attributesBean, final IdentityProviderConfiguration identityProviderConfiguration) {\n+        try {\n+\n+            if (DotSamlProxyFactory.getInstance().samlConfigurationService()\n+                    .getConfigAsBoolean(identityProviderConfiguration, SamlName.DOTCMS_SAML_LOGIN_UPDATE_EMAIL)){\n+\n+                user.setEmailAddress(attributesBean.getEmail());\n+            }\n+\n+            user.setFirstName(attributesBean.getFirstName());\n+            user.setLastName(attributesBean.getLastName());\n+\n+            this.userAPI.save(user, systemUser, false);\n+            Logger.debug(this, ()-> \"User with email '\" + attributesBean.getEmail() + \"' has been updated\");\n+        } catch (Exception e) {\n+\n+            Logger.error(this, \"Error updating user with email '\" + attributesBean.getEmail() + \"': \" + e.getMessage()\n+                    , e);\n+            throw new SamlException(e.getMessage());\n+        }\n+\n+        return user;\n+    }\n+\n+    private String getBuildRoles(final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        final String buildRolesStrategy = DotSamlProxyFactory.getInstance()\n+                .samlConfigurationService().getConfigAsString(identityProviderConfiguration, SamlName.DOTCMS_SAML_BUILD_ROLES);\n+\n+        return this.checkBuildRoles(buildRolesStrategy)?\n+                buildRolesStrategy: this.getDefaultBuildRoles(buildRolesStrategy);\n+    }\n+\n+    private String getDefaultBuildRoles(final String invalidBuildRolesStrategy) {\n+        Logger.info(this, ()-> \"The build.roles: \" + invalidBuildRolesStrategy + \", property is invalid. Using the default \" +\n+                \"strategy: \" + DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_ALL_VALUE);\n+\n+        return DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_ALL_VALUE;\n+    }\n+\n+    public boolean checkBuildRoles(final String buildRolesProperty) {\n+\n+        return DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_ALL_VALUE.equalsIgnoreCase( buildRolesProperty )  ||\n+                DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_IDP_VALUE.equalsIgnoreCase( buildRolesProperty ) ||\n+                DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_STATIC_ONLY_VALUE.equalsIgnoreCase( buildRolesProperty ) ||\n+                DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_STATIC_ADD_VALUE.equalsIgnoreCase( buildRolesProperty )  ||\n+                DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_NONE_VALUE.equalsIgnoreCase( buildRolesProperty );\n+    }\n+\n+    private void addRoles(final User user, final Attributes attributesBean, final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        final String buildRolesStrategy = this.getBuildRoles(identityProviderConfiguration);\n+\n+        Logger.debug(this, ()-> \"Using the build roles Strategy: \" + buildRolesStrategy);\n+\n+        if (!DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_NONE_VALUE.equalsIgnoreCase(buildRolesStrategy)) {\n+            try {\n+                // remove previous roles\n+                if (!DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_STATIC_ADD_VALUE.equalsIgnoreCase(buildRolesStrategy)) {\n+\n+                    Logger.debug(this, ()-> \"Removing ALL existing roles from user '\" + user.getUserId() + \"'...\");\n+                    this.roleAPI.removeAllRolesFromUser(user);\n+                } else {\n+\n+                    Logger.debug(this, ()-> \"The buildRoles strategy is: 'staticadd'. It won't remove any existing dotCMS role\");\n+                }\n+\n+                this.handleRoles(user, attributesBean, identityProviderConfiguration, buildRolesStrategy);\n+            } catch (DotDataException e) {\n+\n+                Logger.error(this, \"Error adding roles to user '\" + user.getUserId() + \"': \" + e.getMessage(), e);\n+                throw new SamlException(e.getMessage());\n+            }\n+        } else {\n+\n+            Logger.info(this, ()->\"The build roles strategy is 'none'. No user roles were added/changed.\");\n+        }\n+    }\n+\n+    private void handleRoles(final User user, final Attributes attributesBean,\n+                             final IdentityProviderConfiguration identityProviderConfiguration,\n+                             final String buildRolesStrategy) throws DotDataException {\n+\n+        this.addRolesFromIDP(user, attributesBean, identityProviderConfiguration, buildRolesStrategy);\n+\n+        // Add SAML User role\n+        this.addRole(user, DotSamlConstants.DOTCMS_SAML_USER_ROLE, true, true);\n+        Logger.debug(this, ()->\"Default SAML User role has been assigned\");\n+\n+        // the only strategy that does not include the saml user role is the \"idp\"\n+        if (!DotSamlConstants.DOTCMS_SAML_BUILD_ROLES_IDP_VALUE.equalsIgnoreCase(buildRolesStrategy)) {\n+            // Add DOTCMS_SAML_OPTIONAL_USER_ROLE\n+            if (DotSamlProxyFactory.getInstance().samlConfigurationService().getConfigAsString(identityProviderConfiguration,\n+                    SamlName.DOTCMS_SAML_OPTIONAL_USER_ROLE) != null) {\n+\n+                this.addRole(user, DotSamlProxyFactory.getInstance().samlConfigurationService().getConfigAsString(identityProviderConfiguration,\n+                        SamlName.DOTCMS_SAML_OPTIONAL_USER_ROLE), false, false);\n+                Logger.debug(this, ()-> \"Optional user role: \" +\n+                        DotSamlProxyFactory.getInstance().samlConfigurationService().getConfigAsString(identityProviderConfiguration,\n+                                SamlName.DOTCMS_SAML_OPTIONAL_USER_ROLE) + \" has been assigned\");\n+            }\n+        } else {\n+\n+            Logger.info(this, \"The build roles strategy is 'idp'. No saml_user_role has been added\");\n+        }\n+    }\n+\n+    private boolean isValidRole(final String role, final String[] rolePatterns) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNDgwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/saml/Attributes.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMDo1N1rOG6Rh0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMDo1N1rOG6Rh0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzc3Ng==", "bodyText": "Codacy found an issue: Field lastName has the same name as a method", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757776", "createdAt": "2020-07-31T18:10:57Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/saml/Attributes.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.saml;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Encapsulates the attributes retrieve from the Saml Assertion\n+ *\n+ * @author jsanca\n+ */\n+public class Attributes implements Serializable {\n+\n+\tprivate static final long serialVersionUID = 1836313856887837731L;\n+\n+\t// user email from opensaml\n+\tprivate final String email;\n+\n+\t// user last name from opensaml\n+\tprivate final String lastName;\n+\n+\t// user first name from opensaml\n+\tprivate final String firstName;\n+\n+\t// true if opensaml returned roles\n+\tprivate final boolean addRoles;\n+\n+\t// Saml object with the roles info.\n+\tprivate final Object roles;\n+\n+\t// Saml object with the NameID.\n+\tprivate final Object nameID;\n+\n+\t// SAML Session Index\n+\tprivate final String sessionIndex;\n+\n+\tprivate Attributes(final Builder builder) {\n+\n+\t\tthis.email        = builder.email;\n+\t\tthis.lastName     = builder.lastName;\n+\t\tthis.firstName    = builder.firstName;\n+\t\tthis.addRoles     = builder.addRoles;\n+\t\tthis.roles        = builder.roles;\n+\t\tthis.nameID       = builder.nameID;\n+\t\tthis.sessionIndex = builder.sessionIndex;\n+\t}\n+\n+\tpublic String getEmail()\n+\t{\n+\t\treturn email;\n+\t}\n+\n+\tpublic String getLastName()\n+\t{\n+\t\treturn lastName;\n+\t}\n+\n+\tpublic String getFirstName()\n+\t{\n+\t\treturn firstName;\n+\t}\n+\n+\tpublic boolean isAddRoles()\n+\t{\n+\t\treturn addRoles;\n+\t}\n+\n+\tpublic Object getRoles()\n+\t{\n+\t\treturn roles;\n+\t}\n+\n+\tpublic Object getNameID()\n+\t{\n+\t\treturn nameID;\n+\t}\n+\n+\tpublic String getSessionIndex() {\n+\t\treturn sessionIndex;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"AttributesBean{\" + \"nameID='\" + nameID + '\\'' + \", email='\" + email + '\\'' + \", lastName='\" + lastName + '\\''\n+\t\t\t\t+ \", firstName='\" + firstName + '\\'' + \", addRoles=\" + addRoles + \", roles=\" + roles + '}';\n+\t}\n+\n+\tpublic static final class Builder {\n+\t\tString email     = \"\";\n+\t\tString lastName  = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNDg3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/saml/Attributes.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMDo1OFrOG6Rh2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMDo1OFrOG6Rh2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzc4Nw==", "bodyText": "Codacy found an issue: Field nameID has the same name as a method", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757787", "createdAt": "2020-07-31T18:10:58Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/saml/Attributes.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.saml;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Encapsulates the attributes retrieve from the Saml Assertion\n+ *\n+ * @author jsanca\n+ */\n+public class Attributes implements Serializable {\n+\n+\tprivate static final long serialVersionUID = 1836313856887837731L;\n+\n+\t// user email from opensaml\n+\tprivate final String email;\n+\n+\t// user last name from opensaml\n+\tprivate final String lastName;\n+\n+\t// user first name from opensaml\n+\tprivate final String firstName;\n+\n+\t// true if opensaml returned roles\n+\tprivate final boolean addRoles;\n+\n+\t// Saml object with the roles info.\n+\tprivate final Object roles;\n+\n+\t// Saml object with the NameID.\n+\tprivate final Object nameID;\n+\n+\t// SAML Session Index\n+\tprivate final String sessionIndex;\n+\n+\tprivate Attributes(final Builder builder) {\n+\n+\t\tthis.email        = builder.email;\n+\t\tthis.lastName     = builder.lastName;\n+\t\tthis.firstName    = builder.firstName;\n+\t\tthis.addRoles     = builder.addRoles;\n+\t\tthis.roles        = builder.roles;\n+\t\tthis.nameID       = builder.nameID;\n+\t\tthis.sessionIndex = builder.sessionIndex;\n+\t}\n+\n+\tpublic String getEmail()\n+\t{\n+\t\treturn email;\n+\t}\n+\n+\tpublic String getLastName()\n+\t{\n+\t\treturn lastName;\n+\t}\n+\n+\tpublic String getFirstName()\n+\t{\n+\t\treturn firstName;\n+\t}\n+\n+\tpublic boolean isAddRoles()\n+\t{\n+\t\treturn addRoles;\n+\t}\n+\n+\tpublic Object getRoles()\n+\t{\n+\t\treturn roles;\n+\t}\n+\n+\tpublic Object getNameID()\n+\t{\n+\t\treturn nameID;\n+\t}\n+\n+\tpublic String getSessionIndex() {\n+\t\treturn sessionIndex;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"AttributesBean{\" + \"nameID='\" + nameID + '\\'' + \", email='\" + email + '\\'' + \", lastName='\" + lastName + '\\''\n+\t\t\t\t+ \", firstName='\" + firstName + '\\'' + \", addRoles=\" + addRoles + \", roles=\" + roles + '}';\n+\t}\n+\n+\tpublic static final class Builder {\n+\t\tString email     = \"\";\n+\t\tString lastName  = \"\";\n+\t\tString firstName = \"\";\n+\t\tboolean addRoles = false;\n+\t\tObject roles     = null;\n+\t\tObject nameID    = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNDkwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/saml/DotAbstractSamlConfigurationServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMDo1OVrOG6Rh4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMDo1OVrOG6Rh4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzc5Mw==", "bodyText": "Codacy found an issue: Return an empty array rather than null.", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757793", "createdAt": "2020-07-31T18:10:59Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/saml/DotAbstractSamlConfigurationServiceImpl.java", "diffHunk": "@@ -0,0 +1,254 @@\n+package com.dotcms.saml;\n+\n+import com.dotmarketing.util.Logger;\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Supplier;\n+\n+/**\n+ * This service will retrieve information form the idp config, but also if the value is not set will provide the default value for the saml name.\n+ * It has different implementation for several kinds of values\n+ * @author jsanca\n+ */\n+public abstract class DotAbstractSamlConfigurationServiceImpl implements SamlConfigurationService {\n+\n+    private static final String NULL = \"NULL\";\n+    private static final String UNABLE_TO_READ_FILE = \"File does not exist or unable to read : \";\n+    private static final String NOT_FOUND_ERROR = \"Property Name not Found: \";\n+\n+    private AtomicBoolean init = new AtomicBoolean(false);\n+    private final Map<String, String> defaultProperties = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public void initService(final Map<String, Object> contextMap) {\n+\n+        if (!this.init.get()) {\n+\n+            final Map<String, String> samlInitialMap = this.createInitialMap();\n+            for (final Map.Entry<String, String> entry : samlInitialMap.entrySet()) {\n+\n+                this.defaultProperties.put(entry.getKey(), null == entry.getValue()?NULL:entry.getValue());\n+            }\n+\n+            this.internalInit(contextMap);\n+        }\n+    }\n+\n+    private synchronized void internalInit(final Map<String, Object> contextMap) {\n+\n+        final String dotSamlDefaultPropertiesValue = (String)contextMap.get(DOT_SAML_DEFAULT_PROPERTIES_CONTEXT_MAP_KEY);\n+\n+        if (null == dotSamlDefaultPropertiesValue) {\n+\n+            Logger.warn(this, DOT_SAML_DEFAULT_PROPERTIES_CONTEXT_MAP_KEY + \" must be set on the argument context map\");\n+        } else {\n+\n+            final File dotSamlDefaultPropertiesFile = new File(dotSamlDefaultPropertiesValue);\n+\n+            if (!dotSamlDefaultPropertiesFile.exists() || !dotSamlDefaultPropertiesFile.canRead()) {\n+\n+                Logger.warn(this, \"The \" + dotSamlDefaultPropertiesValue + \" does not exists or can not read\");\n+            } else {\n+\n+                final Properties properties = new Properties();\n+\n+                try (InputStream input = Files.newInputStream(dotSamlDefaultPropertiesFile.toPath())) {\n+\n+                    properties.load(input);\n+                } catch (IOException ex) {\n+                    // Since this is optional, it is valid to not have the file.\n+                    // Log and go on.\n+                    Logger.warn(this, UNABLE_TO_READ_FILE + dotSamlDefaultPropertiesValue);\n+\n+                }\n+\n+                properties.forEach((key, value) -> {\n+\n+                    final SamlName samlName = SamlName.findProperty((String)key);\n+                    if (null != samlName) {\n+\n+                        this.defaultProperties.put(samlName.getPropertyName(), (String)value);\n+                    }\n+                });\n+\n+                this.init.set(true);\n+            }\n+        }\n+    }\n+\n+\n+    @Override\n+    public String getConfigAsString(final IdentityProviderConfiguration identityProviderConfiguration, final SamlName samlName) {\n+\n+        try {\n+\n+            final String value = identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                    (String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName()):\n+                    this.getDefaultStringParameter(samlName);\n+\n+            Logger.debug(this,\n+                    ()-> \"Found \" + samlName.getPropertyName() + \" : \" + ((value == null) ? \"null\" : value));\n+\n+            return value;\n+        } catch (Exception e) {\n+\n+            Logger.warn(this, ()-> \"Cast exception on \" + samlName.getPropertyName()\n+                    + \" property. idpConfigId: \" + identityProviderConfiguration.getId());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public String getConfigAsString(final IdentityProviderConfiguration identityProviderConfiguration,\n+                                    final SamlName samlName, final Supplier<String> defaultValueSupplier) {\n+\n+        try {\n+\n+            final String value = identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                    (String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName()):\n+                    defaultValueSupplier.get();\n+\n+            Logger.debug(this,\n+                    ()-> \"Found \" + samlName.getPropertyName() + \" : \" + ((value == null) ? \"null\" : value));\n+\n+            return value;\n+        } catch (Exception e) {\n+\n+            Logger.warn(this, ()-> \"Cast exception on \" + samlName.getPropertyName()\n+                    + \" property. idpConfigId: \" + identityProviderConfiguration.getId());\n+        }\n+\n+        return defaultValueSupplier.get();\n+    }\n+\n+    @Override\n+    public Boolean getConfigAsBoolean(final IdentityProviderConfiguration identityProviderConfiguration, final SamlName samlName) {\n+\n+        try {\n+\n+            final Boolean value =  identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                Boolean.parseBoolean((String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName())):\n+                this.getDefaultBooleanParameter(samlName);\n+\n+            Logger.debug(this,\n+                    ()->\"Found \" + samlName.getPropertyName() + \" : \" + ((value == null) ? \"null\" : value));\n+\n+            return value;\n+        } catch (Exception e) {\n+\n+            Logger.warn(this, \"Cast exception on \" + samlName.getPropertyName()\n+                    + \" property. idpConfigId: \" + identityProviderConfiguration.getId());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public String[] getConfigAsArrayString(final IdentityProviderConfiguration identityProviderConfiguration, final SamlName samlName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNDk0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/saml/MockIdentityProviderConfigurationFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowMFrOG6Rh6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowMFrOG6Rh6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzgwMA==", "bodyText": "Codacy found an issue: Document empty method body", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757800", "createdAt": "2020-07-31T18:11:00Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/saml/MockIdentityProviderConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.dotcms.saml;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyPair;\n+import java.security.cert.Certificate;\n+\n+public class MockIdentityProviderConfigurationFactory implements IdentityProviderConfigurationFactory {\n+\n+\n+    @Override\n+    public IdentityProviderConfiguration findIdentityProviderConfigurationById(String s) {\n+        return new IdentityProviderConfiguration() {\n+            @Override\n+            public boolean isEnabled() {\n+                return true;\n+            }\n+\n+            @Override\n+            public String getSpIssuerURL() {\n+                return \"https://test.com\";\n+            }\n+\n+            @Override\n+            public String getIdpName() {\n+                return \"test.com/sp\";\n+            }\n+\n+            @Override\n+            public String getId() {\n+                return \"123\";\n+            }\n+\n+            @Override\n+            public String getSpEndpointHostname() {\n+                return \"test.com\";\n+            }\n+\n+            @Override\n+            public String getSignatureValidationType() {\n+                return \"signature\";\n+            }\n+\n+            @Override\n+            public char[] getIdPMetadataFile() {\n+\n+                return new char[0];\n+            }\n+\n+            @Override\n+            public char[] getPublicCert() {\n+                return new char[0];\n+            }\n+\n+            @Override\n+            public char[] getPrivateKey() {\n+                return new char[0];\n+            }\n+\n+            @Override\n+            public Object getOptionalProperty(String s) {\n+                return null;\n+            }\n+\n+            @Override\n+            public boolean containsOptionalProperty(String s) {\n+                return false;\n+            }\n+\n+            @Override\n+            public void destroy() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNDk5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/saml/MockIdentityProviderConfigurationFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowMVrOG6Rh7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowMVrOG6Rh7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzgwNw==", "bodyText": "Codacy found an issue: Avoid unused imports such as 'java.io.IOException'", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757807", "createdAt": "2020-07-31T18:11:01Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/saml/MockIdentityProviderConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.dotcms.saml;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNTAxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/saml/DotAbstractSamlConfigurationServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowMlrOG6Rh8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowMlrOG6Rh8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzgxMA==", "bodyText": "Codacy found an issue: Use equals() to compare object references.", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757810", "createdAt": "2020-07-31T18:11:02Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/saml/DotAbstractSamlConfigurationServiceImpl.java", "diffHunk": "@@ -0,0 +1,254 @@\n+package com.dotcms.saml;\n+\n+import com.dotmarketing.util.Logger;\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Supplier;\n+\n+/**\n+ * This service will retrieve information form the idp config, but also if the value is not set will provide the default value for the saml name.\n+ * It has different implementation for several kinds of values\n+ * @author jsanca\n+ */\n+public abstract class DotAbstractSamlConfigurationServiceImpl implements SamlConfigurationService {\n+\n+    private static final String NULL = \"NULL\";\n+    private static final String UNABLE_TO_READ_FILE = \"File does not exist or unable to read : \";\n+    private static final String NOT_FOUND_ERROR = \"Property Name not Found: \";\n+\n+    private AtomicBoolean init = new AtomicBoolean(false);\n+    private final Map<String, String> defaultProperties = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public void initService(final Map<String, Object> contextMap) {\n+\n+        if (!this.init.get()) {\n+\n+            final Map<String, String> samlInitialMap = this.createInitialMap();\n+            for (final Map.Entry<String, String> entry : samlInitialMap.entrySet()) {\n+\n+                this.defaultProperties.put(entry.getKey(), null == entry.getValue()?NULL:entry.getValue());\n+            }\n+\n+            this.internalInit(contextMap);\n+        }\n+    }\n+\n+    private synchronized void internalInit(final Map<String, Object> contextMap) {\n+\n+        final String dotSamlDefaultPropertiesValue = (String)contextMap.get(DOT_SAML_DEFAULT_PROPERTIES_CONTEXT_MAP_KEY);\n+\n+        if (null == dotSamlDefaultPropertiesValue) {\n+\n+            Logger.warn(this, DOT_SAML_DEFAULT_PROPERTIES_CONTEXT_MAP_KEY + \" must be set on the argument context map\");\n+        } else {\n+\n+            final File dotSamlDefaultPropertiesFile = new File(dotSamlDefaultPropertiesValue);\n+\n+            if (!dotSamlDefaultPropertiesFile.exists() || !dotSamlDefaultPropertiesFile.canRead()) {\n+\n+                Logger.warn(this, \"The \" + dotSamlDefaultPropertiesValue + \" does not exists or can not read\");\n+            } else {\n+\n+                final Properties properties = new Properties();\n+\n+                try (InputStream input = Files.newInputStream(dotSamlDefaultPropertiesFile.toPath())) {\n+\n+                    properties.load(input);\n+                } catch (IOException ex) {\n+                    // Since this is optional, it is valid to not have the file.\n+                    // Log and go on.\n+                    Logger.warn(this, UNABLE_TO_READ_FILE + dotSamlDefaultPropertiesValue);\n+\n+                }\n+\n+                properties.forEach((key, value) -> {\n+\n+                    final SamlName samlName = SamlName.findProperty((String)key);\n+                    if (null != samlName) {\n+\n+                        this.defaultProperties.put(samlName.getPropertyName(), (String)value);\n+                    }\n+                });\n+\n+                this.init.set(true);\n+            }\n+        }\n+    }\n+\n+\n+    @Override\n+    public String getConfigAsString(final IdentityProviderConfiguration identityProviderConfiguration, final SamlName samlName) {\n+\n+        try {\n+\n+            final String value = identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                    (String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName()):\n+                    this.getDefaultStringParameter(samlName);\n+\n+            Logger.debug(this,\n+                    ()-> \"Found \" + samlName.getPropertyName() + \" : \" + ((value == null) ? \"null\" : value));\n+\n+            return value;\n+        } catch (Exception e) {\n+\n+            Logger.warn(this, ()-> \"Cast exception on \" + samlName.getPropertyName()\n+                    + \" property. idpConfigId: \" + identityProviderConfiguration.getId());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public String getConfigAsString(final IdentityProviderConfiguration identityProviderConfiguration,\n+                                    final SamlName samlName, final Supplier<String> defaultValueSupplier) {\n+\n+        try {\n+\n+            final String value = identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                    (String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName()):\n+                    defaultValueSupplier.get();\n+\n+            Logger.debug(this,\n+                    ()-> \"Found \" + samlName.getPropertyName() + \" : \" + ((value == null) ? \"null\" : value));\n+\n+            return value;\n+        } catch (Exception e) {\n+\n+            Logger.warn(this, ()-> \"Cast exception on \" + samlName.getPropertyName()\n+                    + \" property. idpConfigId: \" + identityProviderConfiguration.getId());\n+        }\n+\n+        return defaultValueSupplier.get();\n+    }\n+\n+    @Override\n+    public Boolean getConfigAsBoolean(final IdentityProviderConfiguration identityProviderConfiguration, final SamlName samlName) {\n+\n+        try {\n+\n+            final Boolean value =  identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                Boolean.parseBoolean((String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName())):\n+                this.getDefaultBooleanParameter(samlName);\n+\n+            Logger.debug(this,\n+                    ()->\"Found \" + samlName.getPropertyName() + \" : \" + ((value == null) ? \"null\" : value));\n+\n+            return value;\n+        } catch (Exception e) {\n+\n+            Logger.warn(this, \"Cast exception on \" + samlName.getPropertyName()\n+                    + \" property. idpConfigId: \" + identityProviderConfiguration.getId());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public String[] getConfigAsArrayString(final IdentityProviderConfiguration identityProviderConfiguration, final SamlName samlName) {\n+\n+        try {\n+\n+            final String[] array = identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                    StringUtils.split((String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName()), DotSamlConstants.ARRAY_SEPARATOR_CHAR):\n+                    this.getDefaultArrayStringParameter(samlName);\n+\n+            Logger.debug(this, ()-> \"Found \" + samlName.getPropertyName() + \" : \" + ((array == null) ? \"null\" : array));\n+\n+            return array;\n+        } catch (Exception e) {\n+\n+            Logger.warn(this, \"Cast exception on \" + samlName.getPropertyName()\n+                    + \" property. idpConfigId: \" + identityProviderConfiguration.getId());\n+        }\n+\n+        return null;\n+    }\n+\n+    @Override\n+    public Integer getConfigAsInteger(final IdentityProviderConfiguration identityProviderConfiguration, final SamlName samlName) {\n+\n+        try {\n+\n+            final Integer value = identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                Integer.parseInt((String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName())):\n+                this.getDefaultIntegerParameter(samlName);\n+\n+            Logger.debug(this, ()-> \"Found \" + samlName.getPropertyName() + \" : \" + ((value == null) ? \"null\" : value));\n+\n+            return value;\n+        } catch (Exception e) {\n+\n+            Logger.warn(this, \"Cast exception on \" + samlName.getPropertyName()\n+                    + \" property. idpConfigId: \" + identityProviderConfiguration.getId());\n+        }\n+\n+        return null;\n+    }\n+\n+    ////////\n+\n+    private Integer getDefaultIntegerParameter(final SamlName samlName) {\n+\n+        if (samlName == null) {\n+\n+            throw new SamlException(\"The 'getDefaultIntegerParameter' property is null\");\n+        }\n+\n+        if (this.defaultProperties.containsKey(samlName.getPropertyName())) {\n+\n+            return Integer.parseInt(this.defaultProperties.get(samlName.getPropertyName()));\n+        }\n+\n+        throw new SamlException(NOT_FOUND_ERROR + samlName.getPropertyName());\n+    }\n+\n+    private String[] getDefaultArrayStringParameter(final SamlName samlName) {\n+\n+        final String value = this.getDefaultStringParameter(samlName);\n+        if (value != null) {\n+            return StringUtils.split(value, DotSamlConstants.ARRAY_SEPARATOR_CHAR);\n+        }\n+\n+        throw new SamlException(NOT_FOUND_ERROR + samlName.getPropertyName());\n+    }\n+\n+    public String getDefaultStringParameter(final SamlName property) {\n+\n+        if (property == null) {\n+\n+            throw new SamlException(\"The 'getDefaultStringParameter' property is null\");\n+        }\n+\n+        if (this.defaultProperties.containsKey(property.getPropertyName())) {\n+\n+            final String string = this.defaultProperties.get(property.getPropertyName());\n+            return NULL == string? null : string;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 234}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNTExOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/saml/Attributes.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowM1rOG6Rh_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowM1rOG6Rh_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzgyMg==", "bodyText": "Codacy found an issue: Field sessionIndex has the same name as a method", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757822", "createdAt": "2020-07-31T18:11:03Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/saml/Attributes.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.saml;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Encapsulates the attributes retrieve from the Saml Assertion\n+ *\n+ * @author jsanca\n+ */\n+public class Attributes implements Serializable {\n+\n+\tprivate static final long serialVersionUID = 1836313856887837731L;\n+\n+\t// user email from opensaml\n+\tprivate final String email;\n+\n+\t// user last name from opensaml\n+\tprivate final String lastName;\n+\n+\t// user first name from opensaml\n+\tprivate final String firstName;\n+\n+\t// true if opensaml returned roles\n+\tprivate final boolean addRoles;\n+\n+\t// Saml object with the roles info.\n+\tprivate final Object roles;\n+\n+\t// Saml object with the NameID.\n+\tprivate final Object nameID;\n+\n+\t// SAML Session Index\n+\tprivate final String sessionIndex;\n+\n+\tprivate Attributes(final Builder builder) {\n+\n+\t\tthis.email        = builder.email;\n+\t\tthis.lastName     = builder.lastName;\n+\t\tthis.firstName    = builder.firstName;\n+\t\tthis.addRoles     = builder.addRoles;\n+\t\tthis.roles        = builder.roles;\n+\t\tthis.nameID       = builder.nameID;\n+\t\tthis.sessionIndex = builder.sessionIndex;\n+\t}\n+\n+\tpublic String getEmail()\n+\t{\n+\t\treturn email;\n+\t}\n+\n+\tpublic String getLastName()\n+\t{\n+\t\treturn lastName;\n+\t}\n+\n+\tpublic String getFirstName()\n+\t{\n+\t\treturn firstName;\n+\t}\n+\n+\tpublic boolean isAddRoles()\n+\t{\n+\t\treturn addRoles;\n+\t}\n+\n+\tpublic Object getRoles()\n+\t{\n+\t\treturn roles;\n+\t}\n+\n+\tpublic Object getNameID()\n+\t{\n+\t\treturn nameID;\n+\t}\n+\n+\tpublic String getSessionIndex() {\n+\t\treturn sessionIndex;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"AttributesBean{\" + \"nameID='\" + nameID + '\\'' + \", email='\" + email + '\\'' + \", lastName='\" + lastName + '\\''\n+\t\t\t\t+ \", firstName='\" + firstName + '\\'' + \", addRoles=\" + addRoles + \", roles=\" + roles + '}';\n+\t}\n+\n+\tpublic static final class Builder {\n+\t\tString email     = \"\";\n+\t\tString lastName  = \"\";\n+\t\tString firstName = \"\";\n+\t\tboolean addRoles = false;\n+\t\tObject roles     = null;\n+\t\tObject nameID    = null;\n+\t\tString sessionIndex;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNTE4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/saml/DotSamlProxyFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowNFrOG6RiCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowNFrOG6RiCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzgzMg==", "bodyText": "Codacy found an issue: Avoid throwing raw exception types.", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757832", "createdAt": "2020-07-31T18:11:04Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/saml/DotSamlProxyFactory.java", "diffHunk": "@@ -0,0 +1,267 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.auth.providers.saml.v1.DotSamlResource;\n+import com.dotcms.osgi.OSGIConstants;\n+import com.dotcms.security.apps.AppDescriptor;\n+import com.dotcms.security.apps.AppSecretSavedEvent;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.security.apps.Secret;\n+import com.dotcms.system.event.local.model.EventSubscriber;\n+import com.dotcms.system.event.local.model.KeyFilterable;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.filters.DotUrlRewriteFilter;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+import org.apache.felix.framework.OSGIUtil;\n+import org.tuckey.web.filters.urlrewrite.NormalRule;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * This is the proxy to provides the object to interact with the Saml Osgi Bundle\n+ *\n+ * @author jsanca\n+ */\n+public class DotSamlProxyFactory implements EventSubscriber<AppSecretSavedEvent>, KeyFilterable {\n+\n+    public static final String SAML_APP_CONFIG_KEY = \"dotsaml-config\";\n+    public static final String PROPERTIES_PATH     = File.separator + \"saml\" + File.separator + \"dotcms-saml-default.properties\";\n+\n+    private static final String ASSETS_PATH   = Config.getStringProperty(\"ASSET_REAL_PATH\",\n+            FileUtil.getRealPath(Config.getStringProperty(\"ASSET_PATH\", \"/assets\")));\n+    private static final String IDP_FILE_PATH = ASSETS_PATH + PROPERTIES_PATH;\n+\n+    private final MessageObserver    messageObserver    = new DotLoggerMessageObserver();\n+    private final AppsAPI            appsAPI            = APILocator.getAppsAPI();\n+    private final IdentityProviderConfigurationFactory identityProviderConfigurationFactory =\n+            new DotIdentityProviderConfigurationFactoryImpl(this.appsAPI, APILocator.getHostAPI());\n+\n+    private SamlServiceBuilder        samlServiceBuilder;\n+    private SamlConfigurationService  samlConfigurationService;\n+    private SamlAuthenticationService samlAuthenticationService;\n+\n+    private static class SingletonHolder {\n+\n+        private static final DotSamlProxyFactory INSTANCE = new DotSamlProxyFactory();\n+    }\n+    /**\n+     * Get the instance.\n+     * @return DotSamlFactory\n+     */\n+    public static DotSamlProxyFactory getInstance() {\n+\n+        addRedirects();\n+        return DotSamlProxyFactory.SingletonHolder.INSTANCE;\n+    } // getInstance.\n+\n+    /**\n+     * Key for the discard non-SAML AppSecretSavedEvent\n+     * @return Comparable\n+     */\n+    @Override\n+    public Comparable getKey() {\n+        return SAML_APP_CONFIG_KEY;\n+    }\n+\n+    /**\n+     * When\n+     * @param event\n+     */\n+    @Override\n+    public void notify(final AppSecretSavedEvent event) {\n+\n+        final  Map<String, Secret> secretMap = event.getAppSecrets().getSecrets();\n+        if (null != secretMap) {\n+\n+            SamlValidator.validateURL(\"sPEndpointHostname\", secretMap.get(\"sPEndpointHostname\").getString(), event.getUserId());\n+            SamlValidator.validateXML(\"idPMetadataFile\",    secretMap.get(\"idPMetadataFile\").getString(),    event.getUserId());\n+        }\n+    }\n+\n+    /**\n+     * Returns the dotCMS implementation of the identity provider config.\n+     * This one basically returns (if exists) the configuration for a idp for a host\n+     * @return IdentityProviderConfigurationFactory\n+     */\n+    public IdentityProviderConfigurationFactory identityProviderConfigurationFactory() {\n+\n+        return identityProviderConfigurationFactory;\n+    }\n+\n+    private static void addRedirects() {\n+\n+        final NormalRule rule = new NormalRule();\n+        rule.setFrom(\"^\\\\/dotsaml\\\\/(\"+String.join(\"|\", DotSamlResource.dotsamlPathSegments)+\")\\\\/(.+)$\");\n+        rule.setToType(\"forward\");\n+        rule.setTo(\"/api/v1/dotsaml/$1/$2\");\n+        rule.setName(\"Dotsaml REST Service Redirect\");\n+        DotUrlRewriteFilter urlRewriteFilter = DotUrlRewriteFilter.getUrlRewriteFilter();\n+        try {\n+            if(urlRewriteFilter != null) {\n+                urlRewriteFilter.addRule(rule);\n+            }else {\n+                throw new Exception();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNTM2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/saml/Attributes.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowNVrOG6RiHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowNVrOG6RiHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzg1NA==", "bodyText": "Codacy found an issue: Field firstName has the same name as a method", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757854", "createdAt": "2020-07-31T18:11:05Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/saml/Attributes.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.saml;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Encapsulates the attributes retrieve from the Saml Assertion\n+ *\n+ * @author jsanca\n+ */\n+public class Attributes implements Serializable {\n+\n+\tprivate static final long serialVersionUID = 1836313856887837731L;\n+\n+\t// user email from opensaml\n+\tprivate final String email;\n+\n+\t// user last name from opensaml\n+\tprivate final String lastName;\n+\n+\t// user first name from opensaml\n+\tprivate final String firstName;\n+\n+\t// true if opensaml returned roles\n+\tprivate final boolean addRoles;\n+\n+\t// Saml object with the roles info.\n+\tprivate final Object roles;\n+\n+\t// Saml object with the NameID.\n+\tprivate final Object nameID;\n+\n+\t// SAML Session Index\n+\tprivate final String sessionIndex;\n+\n+\tprivate Attributes(final Builder builder) {\n+\n+\t\tthis.email        = builder.email;\n+\t\tthis.lastName     = builder.lastName;\n+\t\tthis.firstName    = builder.firstName;\n+\t\tthis.addRoles     = builder.addRoles;\n+\t\tthis.roles        = builder.roles;\n+\t\tthis.nameID       = builder.nameID;\n+\t\tthis.sessionIndex = builder.sessionIndex;\n+\t}\n+\n+\tpublic String getEmail()\n+\t{\n+\t\treturn email;\n+\t}\n+\n+\tpublic String getLastName()\n+\t{\n+\t\treturn lastName;\n+\t}\n+\n+\tpublic String getFirstName()\n+\t{\n+\t\treturn firstName;\n+\t}\n+\n+\tpublic boolean isAddRoles()\n+\t{\n+\t\treturn addRoles;\n+\t}\n+\n+\tpublic Object getRoles()\n+\t{\n+\t\treturn roles;\n+\t}\n+\n+\tpublic Object getNameID()\n+\t{\n+\t\treturn nameID;\n+\t}\n+\n+\tpublic String getSessionIndex() {\n+\t\treturn sessionIndex;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"AttributesBean{\" + \"nameID='\" + nameID + '\\'' + \", email='\" + email + '\\'' + \", lastName='\" + lastName + '\\''\n+\t\t\t\t+ \", firstName='\" + firstName + '\\'' + \", addRoles=\" + addRoles + \", roles=\" + roles + '}';\n+\t}\n+\n+\tpublic static final class Builder {\n+\t\tString email     = \"\";\n+\t\tString lastName  = \"\";\n+\t\tString firstName = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNTQyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/saml/IdentityProviderConfigurationFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowNlrOG6RiJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowNlrOG6RiJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzg2MQ==", "bodyText": "Codacy found an issue: Avoid variables with short names like id", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757861", "createdAt": "2020-07-31T18:11:06Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/saml/IdentityProviderConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package com.dotcms.saml;\n+\n+/**\n+ * This factory is in charge of provide the configuration associated to the identifier in the parameters.\n+ * @author jsanca\n+ */\n+public interface IdentityProviderConfigurationFactory {\n+\n+    /**\n+     * Returns the configuration for the identifier passed as a parameters\n+     * @param id String\n+     * @return IdentityProviderConfiguration\n+     */\n+    IdentityProviderConfiguration findIdentityProviderConfigurationById(String id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNTQ5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/saml/MockIdentityProviderConfigurationFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowN1rOG6RiLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowN1rOG6RiLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzg2OA==", "bodyText": "Codacy found an issue: Avoid variables with short names like s", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757868", "createdAt": "2020-07-31T18:11:07Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/saml/MockIdentityProviderConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.dotcms.saml;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyPair;\n+import java.security.cert.Certificate;\n+\n+public class MockIdentityProviderConfigurationFactory implements IdentityProviderConfigurationFactory {\n+\n+\n+    @Override\n+    public IdentityProviderConfiguration findIdentityProviderConfigurationById(String s) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNTU1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/filters/interceptor/saml/SamlWebInterceptor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowOFrOG6RiMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMTowOFrOG6RiMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzg3NQ==", "bodyText": "Codacy found an issue: A catch statement should never catch throwable since it includes errors.", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757875", "createdAt": "2020-07-31T18:11:08Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/filters/interceptor/saml/SamlWebInterceptor.java", "diffHunk": "@@ -0,0 +1,557 @@\n+package com.dotcms.filters.interceptor.saml;\n+\n+import com.dotcms.cms.login.LoginServiceAPI;\n+import com.dotcms.filters.interceptor.Result;\n+import com.dotcms.filters.interceptor.WebInterceptor;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.IdentityProviderConfigurationFactory;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlConfigurationService;\n+import com.dotcms.saml.SamlName;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.util.security.Encryptor;\n+import com.dotcms.util.security.EncryptorFactory;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.dotmarketing.util.WebKeys;\n+import com.liferay.portal.auth.PrincipalThreadLocal;\n+import com.liferay.portal.model.User;\n+import com.liferay.portal.servlet.PortletSessionPool;\n+import io.vavr.control.Try;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.dotcms.saml.DotSamlConstants.SAML_USER_ID;\n+\n+/**\n+ * This interceptor encapsulates the logic for Saml\n+ * Basically if there is any configuration set on dot apps portlet for \"app-saml-config\" and there is a configuration for the current host,\n+ * the interceptor will try to autologin the user (if there is any saml user id on the session) otherwise will redirect to the IDP login.\n+ * In addition if there is any saml host configuration for logout and the interceptor realized it is a logout request, will do the logout on dotCMS\n+ * in addition to the logout on the idp if the configuration requires.\n+ * @author jsanca\n+ */\n+public class SamlWebInterceptor implements WebInterceptor {\n+\n+    public static final String REFERRER_PARAMETER_KEY = \"referrer\";\n+    public static final String ORIGINAL_REQUEST       = \"original_request\";\n+\n+    protected final Encryptor       encryptor;\n+    protected final LoginServiceAPI loginService;\n+    protected final UserAPI         userAPI;\n+    protected final HostWebAPI      hostWebAPI;\n+    protected final AppsAPI         appsAPI;\n+    protected final SamlWebUtils    samlWebUtils;\n+    protected final IdentityProviderConfigurationFactory identityProviderConfigurationFactory;\n+    protected volatile SamlConfigurationService samlConfigurationService;\n+\n+    public SamlWebInterceptor() {\n+\n+        this(EncryptorFactory.getInstance().getEncryptor(),\n+                APILocator.getLoginServiceAPI(),\n+                APILocator.getUserAPI(),\n+                WebAPILocator.getHostWebAPI(),\n+                APILocator.getAppsAPI(),\n+                new SamlWebUtils(),\n+                DotSamlProxyFactory.getInstance().identityProviderConfigurationFactory());\n+    }\n+\n+    public SamlWebInterceptor(final Encryptor       encryptor,\n+            final LoginServiceAPI loginService,\n+            final UserAPI         userAPI,\n+            final HostWebAPI      hostWebAPI,\n+            final AppsAPI         appsAPI,\n+            final SamlWebUtils    samlWebUtils,\n+            final IdentityProviderConfigurationFactory identityProviderConfigurationFactory) {\n+\n+        this.encryptor    = encryptor;\n+        this.loginService = loginService;\n+        this.userAPI      = userAPI;\n+        this.hostWebAPI   = hostWebAPI;\n+        this.appsAPI      = appsAPI;\n+        this.samlWebUtils = samlWebUtils;\n+        this.identityProviderConfigurationFactory = identityProviderConfigurationFactory;\n+    }\n+\n+    private SamlConfigurationService samlConfig() {\n+\n+        if (null == samlConfigurationService) {\n+\n+            this.samlConfigurationService = Try.of(()->DotSamlProxyFactory.getInstance().samlConfigurationService()).getOrNull();\n+        }\n+\n+        return this.samlConfigurationService;\n+    }\n+\n+    @Override\n+    public Result intercept(final HttpServletRequest request,\n+                            final HttpServletResponse response) throws IOException {\n+\n+        HttpSession session = request.getSession(false);\n+\n+        if (this.samlWebUtils.isByPass(request, session)) {\n+\n+            Logger.info(this, ()->\"Using SAML by pass\");\n+            return Result.NEXT;\n+        }\n+\n+        IdentityProviderConfiguration identityProviderConfiguration = null;\n+\n+        try {\n+\n+            if (null != this.samlConfig() && null != session && this.isAnySamlConfigurated()) {\n+\n+                final Host host = hostWebAPI.getCurrentHostNoThrow(request);\n+                identityProviderConfiguration = // gets the SAML Configuration for this site.\n+                        this.identityProviderConfigurationFactory.findIdentityProviderConfigurationById(\n+                                host.getIdentifier());\n+\n+                // If idpConfig is null, means this site does not need SAML processing\n+                if (null != identityProviderConfiguration && identityProviderConfiguration.isEnabled()) { // SAML is configurated, so continue\n+\n+                    // check if there is any exception filter path, to avoid to canApply all the logic.\n+                    if (!this.checkAccessFilters(request.getRequestURI(), this.getAccessFilterArray(identityProviderConfiguration))\n+                            && this.checkIncludePath(request.getRequestURI(), this.getIncludePathArray(identityProviderConfiguration))) {\n+\n+                        if (this.samlWebUtils.isNotLogged(request)) {\n+\n+                            final AutoLoginResult autoLoginResult = this.autoLogin(request, response, session, identityProviderConfiguration);\n+\n+                            // we have to assign again the session, since the doAutoLogin might be renewed.\n+                            session = autoLoginResult.getSession();\n+\n+                            // if the auto login couldn't logged the user, then send it to the IdP login page (if it is not already logged in).\n+                            if (null == session || !autoLoginResult.isAutoLogin() || this.samlWebUtils.isNotLogged(request)) {\n+\n+                                this.doAuthentication(request, response, session, identityProviderConfiguration);\n+                                return Result.SKIP_NO_CHAIN;\n+                            }\n+                        }\n+                    }\n+\n+                    final boolean isLogoutNeed = this.samlConfigurationService.getConfigAsBoolean(\n+                            identityProviderConfiguration, SamlName.DOTCMS_SAML_IS_LOGOUT_NEED);\n+                    // Starting the logout if it is logout\n+                    Logger.debug(this, ()-> \"----------------------------- doFilter --------------------------------\");\n+                    Logger.debug(this, ()-> \"- isLogoutNeed = \" + isLogoutNeed);\n+                    Logger.debug(this, ()-> \"- httpServletRequest.getRequestURI() = \" + request.getRequestURI());\n+\n+                    if (isLogoutNeed &&\n+                            this.samlWebUtils.isLogoutRequest(request.getRequestURI(), this.getLogoutPathArray(identityProviderConfiguration))) {\n+\n+                        if (this.doLogout(response, request, session, identityProviderConfiguration)) {\n+\n+                            Logger.info(this, \"SAML Logout DONE!!!\");\n+                        }\n+                    }\n+                } else {\n+\n+                    Logger.info(this, \"No idpConfig for site '\" + request.getServerName()\n+                            + \"'. No SAML filtering for this request: \" + request.getRequestURI());\n+                }\n+            }\n+        } catch (final Exception exception) { // todo: better error handling?\n+\n+            Logger.error(this,  \"Error [\" + exception.getMessage() + \"] Unable to get idpConfig for Site '\" +\n+                    request.getServerName() + \"'. Incoming URL: \" + request.getRequestURL(), exception);\n+            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n+            return Result.SKIP_NO_CHAIN;\n+        } finally {\n+            if (null != identityProviderConfiguration) {\n+                identityProviderConfiguration.destroy();\n+            }\n+        }\n+\n+        return Result.NEXT;\n+    } // intercept.\n+\n+    private void doAuthentication(final HttpServletRequest request,\n+                                  final HttpServletResponse response,\n+                                  final HttpSession session,\n+                                  final IdentityProviderConfiguration identityProviderConfiguration) throws IOException {\n+\n+        Logger.debug(this, ()-> \"There's no logged-in user. Processing SAML request...\");\n+        this.doRequestLoginSecurityLog(request, identityProviderConfiguration);\n+\n+        final String originalRequest = request.getRequestURI() +\n+                (UtilMethods.isSet(request.getQueryString())?\n+                    \"?\" + request.getQueryString() : StringUtils.EMPTY);\n+\n+        final String redirectAfterLogin = UtilMethods.isSet(request.getParameter(REFERRER_PARAMETER_KEY))\n+                ?request.getParameter(REFERRER_PARAMETER_KEY) :\n+                // this is safe, just to make a redirection when the user get's logged.\n+                originalRequest;\n+\n+        Logger.debug(this.getClass(),\n+                ()-> \"Executing SAML Login Redirection with request: \" + redirectAfterLogin);\n+\n+        // if we don't have a redirect yet\n+        if (null != session) {\n+\n+            session.setAttribute(WebKeys.REDIRECT_AFTER_LOGIN, redirectAfterLogin);\n+            session.setAttribute(ORIGINAL_REQUEST,             originalRequest);\n+        }\n+\n+        try {\n+            // this will redirect the user to the IdP Login Page.\n+            DotSamlProxyFactory.getInstance().samlAuthenticationService()\n+                    .authentication(request, response, identityProviderConfiguration);\n+        } catch (Exception exception) {\n+\n+            Logger.error(this,  \"An error occurred when redirecting to the IdP Login page: \" +\n+                    exception.getMessage(), exception);\n+            Logger.debug(this, ()-> \"An error occurred when redirecting to the IdP Login page. Setting 500 \" +\n+                    \"response status.\");\n+            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n+        }\n+    }\n+\n+    protected boolean isAnySamlConfigurated() {\n+\n+        return\n+                Try.of(()->this.appsAPI.getAppDescriptor(DotSamlProxyFactory.SAML_APP_CONFIG_KEY,\n+                        APILocator.systemUser())).getOrElseGet(e->Optional.empty()).isPresent();\n+    }\n+\n+    protected AutoLoginResult autoLogin(final HttpServletRequest request,\n+                                        final HttpServletResponse response,\n+                                        HttpSession session,\n+                                        final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        final User user          = this.getUser(request, identityProviderConfiguration);\n+        boolean continueFilter   = null != user; // by default continue with the filter\n+        HttpSession renewSession = session;\n+\n+        if (continueFilter) {\n+            // we are going to do the autologin, so if the session is null,\n+            // create it!\n+            try {\n+\n+                Logger.debug(this, \"User with ID '\" + user.getUserId()\n+                        + \"' has been returned by SAML Service. User \" + \"Map: \" + user.toMap());\n+            } catch (Exception e) {\n+\n+                Logger.error(this,\n+                        \"An error occurred when retrieving data from user '\" + user.getUserId() + \"': \" + e.getMessage(), e);\n+            }\n+\n+            final boolean doCookieLogin = this.loginService\n+                    .doCookieLogin(this.encryptor.encryptString(user.getUserId()), request, response);\n+\n+            Logger.debug(this, ()->\"Cookie Login by LoginService = \" + doCookieLogin);\n+\n+            if (doCookieLogin) {\n+\n+                session = request.getSession(false);\n+                if (null != session && null != user.getUserId()) {\n+                    // this is what the PortalRequestProcessor needs to check the login.\n+                    Logger.debug(this, ()->\"Adding user ID '\" + user.getUserId() + \"' to the session\");\n+\n+                    final String uri = session.getAttribute(ORIGINAL_REQUEST) != null?\n+                            (String) session.getAttribute(ORIGINAL_REQUEST):\n+                            request.getRequestURI();\n+\n+                    session.removeAttribute(ORIGINAL_REQUEST);\n+\n+                    Logger.debug(this, ()->  \"URI '\" + uri + \"' belongs to the back-end. Setting the user session data\");\n+                    session.setAttribute(com.liferay.portal.util.WebKeys.USER_ID, user.getUserId());\n+                    session.setAttribute(com.liferay.portal.util.WebKeys.USER,    user);\n+                    PrincipalThreadLocal.setName(user.getUserId());\n+\n+                    renewSession =\n+                            this.samlConfigurationService.getConfigAsBoolean(identityProviderConfiguration, SamlName.DOT_RENEW_SESSION)?\n+                                this.samlWebUtils.renewSession(request, session): session;\n+\n+                    this.doAuthenticationLoginSecurityLog(request, identityProviderConfiguration, user);\n+                }\n+            }\n+        }\n+\n+        return new AutoLoginResult(renewSession, continueFilter);\n+    }\n+\n+    public boolean doLogout(final HttpServletResponse response, final HttpServletRequest request,\n+                            final HttpSession session, final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        Logger.debug(this, ()-> \"------------------------------ IdP doLogout ---------------------------------\");\n+\n+        final Object nameID           = session.getAttribute(identityProviderConfiguration.getId() + SamlAuthenticationService.SAML_NAME_ID);\n+        final String samlSessionIndex = (String) session.getAttribute(identityProviderConfiguration.getId() + SamlAuthenticationService.SAML_SESSION_INDEX);\n+        boolean doLogoutDone          = false;\n+        Logger.debug(this, ()-> \"- idpConfig = \" + identityProviderConfiguration);\n+        Logger.debug(this, ()-> \"- NameID = \" + nameID);\n+        Logger.debug(this, ()-> \"- samlSessionIndex = \" + samlSessionIndex);\n+\n+        try {\n+\n+            if (null != nameID && null != samlSessionIndex) {\n+\n+                Logger.debug(this, ()-> \"The URI '\" + request.getRequestURI() + \"' is a logout request. Executing the logout call to SAML\");\n+                Logger.debug(this, ()-> \"Executing dotCMS logout\");\n+\n+                doLogout(response, request);\n+\n+                Logger.debug(this, ()-> \"Executing SAML redirect logout\");\n+\n+                DotSamlProxyFactory.getInstance().samlAuthenticationService().logout(request, response, nameID, samlSessionIndex, identityProviderConfiguration);\n+\n+                Logger.info(this, ()-> \"User '\" + nameID + \"' has logged out\");\n+\n+                doLogoutDone = true;\n+            } else {\n+\n+                Logger.warn(this, ()->\"Couldn't execute the logout request. The SAML NameID or the SAML session index are not in the HTTP session\");\n+            }\n+        } catch (Throwable e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 323}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNTYyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/saml/TestSamlConfigurationService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxMFrOG6RiPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxMFrOG6RiPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzg4Ng==", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757886", "createdAt": "2020-07-31T18:11:10Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/saml/TestSamlConfigurationService.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.util.Config;\n+import org.apache.felix.framework.OSGIUtil;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+public class TestSamlConfigurationService {\n+\n+    @BeforeClass\n+    public static void prepare() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNTY2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/filters/interceptor/saml/SamlWebInterceptor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxMVrOG6RiRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxMVrOG6RiRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzg5Mw==", "bodyText": "Codacy found an issue: Avoid reassigning parameters such as 'session'", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757893", "createdAt": "2020-07-31T18:11:11Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/filters/interceptor/saml/SamlWebInterceptor.java", "diffHunk": "@@ -0,0 +1,557 @@\n+package com.dotcms.filters.interceptor.saml;\n+\n+import com.dotcms.cms.login.LoginServiceAPI;\n+import com.dotcms.filters.interceptor.Result;\n+import com.dotcms.filters.interceptor.WebInterceptor;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.IdentityProviderConfigurationFactory;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlConfigurationService;\n+import com.dotcms.saml.SamlName;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.util.security.Encryptor;\n+import com.dotcms.util.security.EncryptorFactory;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UtilMethods;\n+import com.dotmarketing.util.WebKeys;\n+import com.liferay.portal.auth.PrincipalThreadLocal;\n+import com.liferay.portal.model.User;\n+import com.liferay.portal.servlet.PortletSessionPool;\n+import io.vavr.control.Try;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.Cookie;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpSession;\n+import java.io.IOException;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.dotcms.saml.DotSamlConstants.SAML_USER_ID;\n+\n+/**\n+ * This interceptor encapsulates the logic for Saml\n+ * Basically if there is any configuration set on dot apps portlet for \"app-saml-config\" and there is a configuration for the current host,\n+ * the interceptor will try to autologin the user (if there is any saml user id on the session) otherwise will redirect to the IDP login.\n+ * In addition if there is any saml host configuration for logout and the interceptor realized it is a logout request, will do the logout on dotCMS\n+ * in addition to the logout on the idp if the configuration requires.\n+ * @author jsanca\n+ */\n+public class SamlWebInterceptor implements WebInterceptor {\n+\n+    public static final String REFERRER_PARAMETER_KEY = \"referrer\";\n+    public static final String ORIGINAL_REQUEST       = \"original_request\";\n+\n+    protected final Encryptor       encryptor;\n+    protected final LoginServiceAPI loginService;\n+    protected final UserAPI         userAPI;\n+    protected final HostWebAPI      hostWebAPI;\n+    protected final AppsAPI         appsAPI;\n+    protected final SamlWebUtils    samlWebUtils;\n+    protected final IdentityProviderConfigurationFactory identityProviderConfigurationFactory;\n+    protected volatile SamlConfigurationService samlConfigurationService;\n+\n+    public SamlWebInterceptor() {\n+\n+        this(EncryptorFactory.getInstance().getEncryptor(),\n+                APILocator.getLoginServiceAPI(),\n+                APILocator.getUserAPI(),\n+                WebAPILocator.getHostWebAPI(),\n+                APILocator.getAppsAPI(),\n+                new SamlWebUtils(),\n+                DotSamlProxyFactory.getInstance().identityProviderConfigurationFactory());\n+    }\n+\n+    public SamlWebInterceptor(final Encryptor       encryptor,\n+            final LoginServiceAPI loginService,\n+            final UserAPI         userAPI,\n+            final HostWebAPI      hostWebAPI,\n+            final AppsAPI         appsAPI,\n+            final SamlWebUtils    samlWebUtils,\n+            final IdentityProviderConfigurationFactory identityProviderConfigurationFactory) {\n+\n+        this.encryptor    = encryptor;\n+        this.loginService = loginService;\n+        this.userAPI      = userAPI;\n+        this.hostWebAPI   = hostWebAPI;\n+        this.appsAPI      = appsAPI;\n+        this.samlWebUtils = samlWebUtils;\n+        this.identityProviderConfigurationFactory = identityProviderConfigurationFactory;\n+    }\n+\n+    private SamlConfigurationService samlConfig() {\n+\n+        if (null == samlConfigurationService) {\n+\n+            this.samlConfigurationService = Try.of(()->DotSamlProxyFactory.getInstance().samlConfigurationService()).getOrNull();\n+        }\n+\n+        return this.samlConfigurationService;\n+    }\n+\n+    @Override\n+    public Result intercept(final HttpServletRequest request,\n+                            final HttpServletResponse response) throws IOException {\n+\n+        HttpSession session = request.getSession(false);\n+\n+        if (this.samlWebUtils.isByPass(request, session)) {\n+\n+            Logger.info(this, ()->\"Using SAML by pass\");\n+            return Result.NEXT;\n+        }\n+\n+        IdentityProviderConfiguration identityProviderConfiguration = null;\n+\n+        try {\n+\n+            if (null != this.samlConfig() && null != session && this.isAnySamlConfigurated()) {\n+\n+                final Host host = hostWebAPI.getCurrentHostNoThrow(request);\n+                identityProviderConfiguration = // gets the SAML Configuration for this site.\n+                        this.identityProviderConfigurationFactory.findIdentityProviderConfigurationById(\n+                                host.getIdentifier());\n+\n+                // If idpConfig is null, means this site does not need SAML processing\n+                if (null != identityProviderConfiguration && identityProviderConfiguration.isEnabled()) { // SAML is configurated, so continue\n+\n+                    // check if there is any exception filter path, to avoid to canApply all the logic.\n+                    if (!this.checkAccessFilters(request.getRequestURI(), this.getAccessFilterArray(identityProviderConfiguration))\n+                            && this.checkIncludePath(request.getRequestURI(), this.getIncludePathArray(identityProviderConfiguration))) {\n+\n+                        if (this.samlWebUtils.isNotLogged(request)) {\n+\n+                            final AutoLoginResult autoLoginResult = this.autoLogin(request, response, session, identityProviderConfiguration);\n+\n+                            // we have to assign again the session, since the doAutoLogin might be renewed.\n+                            session = autoLoginResult.getSession();\n+\n+                            // if the auto login couldn't logged the user, then send it to the IdP login page (if it is not already logged in).\n+                            if (null == session || !autoLoginResult.isAutoLogin() || this.samlWebUtils.isNotLogged(request)) {\n+\n+                                this.doAuthentication(request, response, session, identityProviderConfiguration);\n+                                return Result.SKIP_NO_CHAIN;\n+                            }\n+                        }\n+                    }\n+\n+                    final boolean isLogoutNeed = this.samlConfigurationService.getConfigAsBoolean(\n+                            identityProviderConfiguration, SamlName.DOTCMS_SAML_IS_LOGOUT_NEED);\n+                    // Starting the logout if it is logout\n+                    Logger.debug(this, ()-> \"----------------------------- doFilter --------------------------------\");\n+                    Logger.debug(this, ()-> \"- isLogoutNeed = \" + isLogoutNeed);\n+                    Logger.debug(this, ()-> \"- httpServletRequest.getRequestURI() = \" + request.getRequestURI());\n+\n+                    if (isLogoutNeed &&\n+                            this.samlWebUtils.isLogoutRequest(request.getRequestURI(), this.getLogoutPathArray(identityProviderConfiguration))) {\n+\n+                        if (this.doLogout(response, request, session, identityProviderConfiguration)) {\n+\n+                            Logger.info(this, \"SAML Logout DONE!!!\");\n+                        }\n+                    }\n+                } else {\n+\n+                    Logger.info(this, \"No idpConfig for site '\" + request.getServerName()\n+                            + \"'. No SAML filtering for this request: \" + request.getRequestURI());\n+                }\n+            }\n+        } catch (final Exception exception) { // todo: better error handling?\n+\n+            Logger.error(this,  \"Error [\" + exception.getMessage() + \"] Unable to get idpConfig for Site '\" +\n+                    request.getServerName() + \"'. Incoming URL: \" + request.getRequestURL(), exception);\n+            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n+            return Result.SKIP_NO_CHAIN;\n+        } finally {\n+            if (null != identityProviderConfiguration) {\n+                identityProviderConfiguration.destroy();\n+            }\n+        }\n+\n+        return Result.NEXT;\n+    } // intercept.\n+\n+    private void doAuthentication(final HttpServletRequest request,\n+                                  final HttpServletResponse response,\n+                                  final HttpSession session,\n+                                  final IdentityProviderConfiguration identityProviderConfiguration) throws IOException {\n+\n+        Logger.debug(this, ()-> \"There's no logged-in user. Processing SAML request...\");\n+        this.doRequestLoginSecurityLog(request, identityProviderConfiguration);\n+\n+        final String originalRequest = request.getRequestURI() +\n+                (UtilMethods.isSet(request.getQueryString())?\n+                    \"?\" + request.getQueryString() : StringUtils.EMPTY);\n+\n+        final String redirectAfterLogin = UtilMethods.isSet(request.getParameter(REFERRER_PARAMETER_KEY))\n+                ?request.getParameter(REFERRER_PARAMETER_KEY) :\n+                // this is safe, just to make a redirection when the user get's logged.\n+                originalRequest;\n+\n+        Logger.debug(this.getClass(),\n+                ()-> \"Executing SAML Login Redirection with request: \" + redirectAfterLogin);\n+\n+        // if we don't have a redirect yet\n+        if (null != session) {\n+\n+            session.setAttribute(WebKeys.REDIRECT_AFTER_LOGIN, redirectAfterLogin);\n+            session.setAttribute(ORIGINAL_REQUEST,             originalRequest);\n+        }\n+\n+        try {\n+            // this will redirect the user to the IdP Login Page.\n+            DotSamlProxyFactory.getInstance().samlAuthenticationService()\n+                    .authentication(request, response, identityProviderConfiguration);\n+        } catch (Exception exception) {\n+\n+            Logger.error(this,  \"An error occurred when redirecting to the IdP Login page: \" +\n+                    exception.getMessage(), exception);\n+            Logger.debug(this, ()-> \"An error occurred when redirecting to the IdP Login page. Setting 500 \" +\n+                    \"response status.\");\n+            response.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\n+        }\n+    }\n+\n+    protected boolean isAnySamlConfigurated() {\n+\n+        return\n+                Try.of(()->this.appsAPI.getAppDescriptor(DotSamlProxyFactory.SAML_APP_CONFIG_KEY,\n+                        APILocator.systemUser())).getOrElseGet(e->Optional.empty()).isPresent();\n+    }\n+\n+    protected AutoLoginResult autoLogin(final HttpServletRequest request,\n+                                        final HttpServletResponse response,\n+                                        HttpSession session,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 236}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNTczOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventSubscribersInitializer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxMlrOG6RiUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxMlrOG6RiUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzkwNQ==", "bodyText": "Codacy found an issue: Avoid unused imports such as 'com.dotcms.concurrent.DotConcurrentFactory'", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757905", "createdAt": "2020-07-31T18:11:12Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventSubscribersInitializer.java", "diffHunk": "@@ -1,6 +1,9 @@\n package com.dotcms.system.event.local.business;\n \n+import com.dotcms.concurrent.DotConcurrentFactory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNTc3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxM1rOG6RiWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxM1rOG6RiWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzkxMg==", "bodyText": "Codacy found an issue: New exception is thrown in catch block, original stack trace may be lost", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757912", "createdAt": "2020-07-31T18:11:13Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "diffHunk": "@@ -0,0 +1,469 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotcms.saml.SamlName;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.cms.factories.PublicEncryptionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.ActivityLogger;\n+import com.dotmarketing.util.AdminLogger;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UUIDGenerator;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.User;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.dotmarketing.util.UtilMethods.isSet;\n+\n+public class SAMLHelper {\n+\n+    private final HostWebAPI hostWebAPI;\n+    private final UserAPI    userAPI;\n+    private final RoleAPI    roleAPI;\n+    private final SamlAuthenticationService  samlAuthenticationService;\n+\n+    public SAMLHelper(final SamlAuthenticationService samlAuthenticationService) {\n+\n+        this.userAPI      = APILocator.getUserAPI();\n+        this.roleAPI      = APILocator.getRoleAPI();\n+        this.hostWebAPI   = WebAPILocator.getHostWebAPI();\n+        this.samlAuthenticationService = samlAuthenticationService;\n+    }\n+\n+    // Gets the attributes from the Assertion, based on the attributes\n+    // see if the user exists return it from the dotCMS records, if does not\n+    // exist then, tries to create it.\n+    // the existing or created user, will be updated the roles if they present\n+    // on the assertion.\n+    protected User resolveUser(final Attributes attributes,\n+                             final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        User user       = null;\n+        User systemUser = null;\n+        try {\n+\n+            Logger.debug(this, ()-> \"Validating user - \" + attributes);\n+\n+            systemUser             = this.userAPI.getSystemUser();\n+            final Company company  = APILocator.getCompanyAPI().getDefaultCompany();\n+            final String  authType = company.getAuthType();\n+            user                   = Company.AUTH_TYPE_ID.equals(authType)?\n+                    this.userAPI.loadUserById(this.samlAuthenticationService.getValue(attributes.getNameID()),      systemUser, false):\n+                    this.userAPI.loadByUserByEmail(this.samlAuthenticationService.getValue(attributes.getNameID()), systemUser, false);\n+        } catch (NoSuchUserException e) {\n+\n+            Logger.error(this, \"No user matches ID '\" +\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()) + \"'. Creating one...\", e);\n+            user = null;\n+        } catch (Exception e) {\n+\n+            Logger.error(this, \"An error occurred when loading user with ID '\" +\n+                    (null != attributes && null != attributes.getNameID()?\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()): \"null\") + \"'\", e);\n+            user = null;\n+        }\n+\n+        // check if the client wants synchronization\n+        final boolean createUserWhenDoesNotExists = DotSamlProxyFactory.getInstance()\n+                .samlConfigurationService().getConfigAsBoolean(identityProviderConfiguration, SamlName.DOT_SAML_ALLOW_USER_SYNCHRONIZATION);\n+        if (createUserWhenDoesNotExists) {\n+\n+            user = null == user?\n+                    this.createNewUser(systemUser,    attributes, identityProviderConfiguration):  // if user does not exists, create a new one.\n+                    this.updateUser(user, systemUser, attributes, identityProviderConfiguration); // update it, since exists\n+\n+            if (user.isActive()) {\n+\n+                this.addRoles(user, attributes, identityProviderConfiguration);\n+            } else {\n+\n+                Logger.info(this, ()-> \"User with ID '\" + this.samlAuthenticationService.getValue(attributes.getNameID()) + \"' is not active. No roles \" +\n+                        \"were added.\");\n+            }\n+        }\n+\n+        return user;\n+    }\n+\n+    protected User updateUser(final User user, final User systemUser,\n+                              final Attributes attributesBean, final IdentityProviderConfiguration identityProviderConfiguration) {\n+        try {\n+\n+            if (DotSamlProxyFactory.getInstance().samlConfigurationService()\n+                    .getConfigAsBoolean(identityProviderConfiguration, SamlName.DOTCMS_SAML_LOGIN_UPDATE_EMAIL)){\n+\n+                user.setEmailAddress(attributesBean.getEmail());\n+            }\n+\n+            user.setFirstName(attributesBean.getFirstName());\n+            user.setLastName(attributesBean.getLastName());\n+\n+            this.userAPI.save(user, systemUser, false);\n+            Logger.debug(this, ()-> \"User with email '\" + attributesBean.getEmail() + \"' has been updated\");\n+        } catch (Exception e) {\n+\n+            Logger.error(this, \"Error updating user with email '\" + attributesBean.getEmail() + \"': \" + e.getMessage()\n+                    , e);\n+            throw new SamlException(e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNTgxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/filters/interceptor/saml/SamlWebUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxNFrOG6RiXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxNFrOG6RiXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzkxOA==", "bodyText": "Codacy found an issue: Consider using varargs for methods or constructors which take an array the last parameter.", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757918", "createdAt": "2020-07-31T18:11:14Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/filters/interceptor/saml/SamlWebUtils.java", "diffHunk": "@@ -0,0 +1,188 @@\n+package com.dotcms.filters.interceptor.saml;\n+\n+import com.dotmarketing.business.web.UserWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.PageMode;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.liferay.portal.PortalException;\n+import com.liferay.portal.SystemException;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpSession;\n+import java.util.Arrays;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Encapsulates Saml util methods for Web.\n+ * @author jsanca\n+ */\n+public class SamlWebUtils {\n+\n+    public static final String BY_PASS_KEY   = \"native\";\n+    public static final String BY_PASS_VALUE = \"true\";\n+\n+    protected     final UserWebAPI userWebAPI;\n+\n+    public SamlWebUtils() {\n+        this(WebAPILocator.getUserWebAPI());\n+    }\n+\n+    @VisibleForTesting\n+    public SamlWebUtils(final UserWebAPI userWebAPI) {\n+        this.userWebAPI = userWebAPI;\n+    }\n+\n+    protected boolean isByPass(final HttpServletRequest request, final HttpSession session) {\n+\n+        String byPass = request.getParameter(BY_PASS_KEY);\n+\n+        if (null != session) {\n+            if (null != byPass) {\n+\n+                session.setAttribute(BY_PASS_KEY, byPass);\n+            } else {\n+\n+                if (this.isNotLogged(request)) {\n+\n+                    byPass = (String) session.getAttribute(BY_PASS_KEY);\n+                } else if (null != session.getAttribute(BY_PASS_KEY)) {\n+\n+                    session.removeAttribute(BY_PASS_KEY);\n+                }\n+            }\n+        }\n+\n+        return BY_PASS_VALUE.equalsIgnoreCase(byPass);\n+    }\n+\n+    /**\n+     * Return true if the user is not logged. Work for FE and BE\n+     *\n+     * @param request\n+     *            {@link HttpServletRequest}\n+     * @return boolean\n+     */\n+    protected boolean isNotLogged(final HttpServletRequest request) {\n+\n+        boolean isNotLogged     = true;\n+        final boolean isBackend = this.isBackEndAdmin(request, request.getRequestURI());\n+\n+        try {\n+\n+            isNotLogged = isBackend?\n+                    !this.userWebAPI.isLoggedToBackend(request):\n+                    null == this.userWebAPI.getLoggedInFrontendUser(request);\n+\n+            Logger.debug(this, \"Trying to go to back-end login? \" + isBackend\n+                    + \", Is user NOT logged in? \" + isNotLogged);\n+        } catch (PortalException | SystemException e) {\n+\n+            Logger.error(this, e.getMessage(), e);\n+            isNotLogged = true;\n+        }\n+\n+        return isNotLogged;\n+    }\n+\n+    /**\n+     * Determines whether the user in the {@link HttpServletRequest} object or the incoming URI belong to the\n+     * dotCMS back-end login mechanism or not.\n+     *\n+     * @param request The {@link HttpServletRequest} request\n+     * @param uri     The incoming URI for login.\n+     *\n+     * @return If the user or its URI can be associated to the dotCMS back-end login, returns {@code true}. Otherwise,\n+     * returns {@code false}.\n+     */\n+    protected boolean isBackEndAdmin(final HttpServletRequest request, final String uri) {\n+\n+        return PageMode.get(request).isAdmin || this.isBackEndLoginPage(uri);\n+    }\n+\n+    /**\n+     * Analyzes the incoming URI and determines whether it belongs to dotCMS back-end login or logout URIs or not.\n+     *\n+     * @param uri The incoming URI.\n+     *\n+     * @return If the URI can be associated to the dotCMS back-end login or logout, returns {@code true}. Otherwise,\n+     * returns {@code false}.\n+     */\n+    protected boolean isBackEndLoginPage(final String uri) {\n+\n+        return uri.startsWith(\"/dotAdmin\") || uri.startsWith(\"/html/portal/login\") || uri.startsWith(\"/c/public/login\")\n+                || uri.startsWith(\"/c/portal_public/login\") || uri.startsWith(\"/c/portal/logout\");\n+    }\n+\n+    protected boolean isFrontEndLoginPage(final String uri){\n+\n+        return uri.startsWith(\"/dotCMS/login\") || uri.startsWith(\"/application/login\");\n+    }\n+\n+    public boolean isLogoutRequest(final String requestURI, final String[] logoutPathArray) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNTkwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/saml/MockIdentityProviderConfigurationFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxNVrOG6Riag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxNVrOG6Riag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzkzMA==", "bodyText": "Codacy found an issue: Avoid variables with short names like s", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757930", "createdAt": "2020-07-31T18:11:15Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/saml/MockIdentityProviderConfigurationFactory.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package com.dotcms.saml;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyPair;\n+import java.security.cert.Certificate;\n+\n+public class MockIdentityProviderConfigurationFactory implements IdentityProviderConfigurationFactory {\n+\n+\n+    @Override\n+    public IdentityProviderConfiguration findIdentityProviderConfigurationById(String s) {\n+        return new IdentityProviderConfiguration() {\n+            @Override\n+            public boolean isEnabled() {\n+                return true;\n+            }\n+\n+            @Override\n+            public String getSpIssuerURL() {\n+                return \"https://test.com\";\n+            }\n+\n+            @Override\n+            public String getIdpName() {\n+                return \"test.com/sp\";\n+            }\n+\n+            @Override\n+            public String getId() {\n+                return \"123\";\n+            }\n+\n+            @Override\n+            public String getSpEndpointHostname() {\n+                return \"test.com\";\n+            }\n+\n+            @Override\n+            public String getSignatureValidationType() {\n+                return \"signature\";\n+            }\n+\n+            @Override\n+            public char[] getIdPMetadataFile() {\n+\n+                return new char[0];\n+            }\n+\n+            @Override\n+            public char[] getPublicCert() {\n+                return new char[0];\n+            }\n+\n+            @Override\n+            public char[] getPrivateKey() {\n+                return new char[0];\n+            }\n+\n+            @Override\n+            public Object getOptionalProperty(String s) {\n+                return null;\n+            }\n+\n+            @Override\n+            public boolean containsOptionalProperty(String s) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNTkxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/saml/TestSamlConfigurationService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxNlrOG6Ribw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxNlrOG6Ribw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NzkzNQ==", "bodyText": "Codacy found an issue: Avoid unused imports such as 'org.junit.Assert'", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757935", "createdAt": "2020-07-31T18:11:16Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/saml/TestSamlConfigurationService.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.util.Config;\n+import org.apache.felix.framework.OSGIUtil;\n+import org.junit.Assert;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNTk1OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/saml/DotSamlProxyFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxN1rOG6RidQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxN1rOG6RidQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzk0MQ==", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757941", "createdAt": "2020-07-31T18:11:17Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/saml/DotSamlProxyFactory.java", "diffHunk": "@@ -0,0 +1,267 @@\n+package com.dotcms.saml;\n+\n+import com.dotcms.auth.providers.saml.v1.DotSamlResource;\n+import com.dotcms.osgi.OSGIConstants;\n+import com.dotcms.security.apps.AppDescriptor;\n+import com.dotcms.security.apps.AppSecretSavedEvent;\n+import com.dotcms.security.apps.AppsAPI;\n+import com.dotcms.security.apps.Secret;\n+import com.dotcms.system.event.local.model.EventSubscriber;\n+import com.dotcms.system.event.local.model.KeyFilterable;\n+import com.dotcms.util.CollectionsUtils;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.filters.DotUrlRewriteFilter;\n+import com.dotmarketing.util.Config;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.model.User;\n+import com.liferay.util.FileUtil;\n+import io.vavr.control.Try;\n+import org.apache.felix.framework.OSGIUtil;\n+import org.tuckey.web.filters.urlrewrite.NormalRule;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+/**\n+ * This is the proxy to provides the object to interact with the Saml Osgi Bundle\n+ *\n+ * @author jsanca\n+ */\n+public class DotSamlProxyFactory implements EventSubscriber<AppSecretSavedEvent>, KeyFilterable {\n+\n+    public static final String SAML_APP_CONFIG_KEY = \"dotsaml-config\";\n+    public static final String PROPERTIES_PATH     = File.separator + \"saml\" + File.separator + \"dotcms-saml-default.properties\";\n+\n+    private static final String ASSETS_PATH   = Config.getStringProperty(\"ASSET_REAL_PATH\",\n+            FileUtil.getRealPath(Config.getStringProperty(\"ASSET_PATH\", \"/assets\")));\n+    private static final String IDP_FILE_PATH = ASSETS_PATH + PROPERTIES_PATH;\n+\n+    private final MessageObserver    messageObserver    = new DotLoggerMessageObserver();\n+    private final AppsAPI            appsAPI            = APILocator.getAppsAPI();\n+    private final IdentityProviderConfigurationFactory identityProviderConfigurationFactory =\n+            new DotIdentityProviderConfigurationFactoryImpl(this.appsAPI, APILocator.getHostAPI());\n+\n+    private SamlServiceBuilder        samlServiceBuilder;\n+    private SamlConfigurationService  samlConfigurationService;\n+    private SamlAuthenticationService samlAuthenticationService;\n+\n+    private static class SingletonHolder {\n+\n+        private static final DotSamlProxyFactory INSTANCE = new DotSamlProxyFactory();\n+    }\n+    /**\n+     * Get the instance.\n+     * @return DotSamlFactory\n+     */\n+    public static DotSamlProxyFactory getInstance() {\n+\n+        addRedirects();\n+        return DotSamlProxyFactory.SingletonHolder.INSTANCE;\n+    } // getInstance.\n+\n+    /**\n+     * Key for the discard non-SAML AppSecretSavedEvent\n+     * @return Comparable\n+     */\n+    @Override\n+    public Comparable getKey() {\n+        return SAML_APP_CONFIG_KEY;\n+    }\n+\n+    /**\n+     * When\n+     * @param event\n+     */\n+    @Override\n+    public void notify(final AppSecretSavedEvent event) {\n+\n+        final  Map<String, Secret> secretMap = event.getAppSecrets().getSecrets();\n+        if (null != secretMap) {\n+\n+            SamlValidator.validateURL(\"sPEndpointHostname\", secretMap.get(\"sPEndpointHostname\").getString(), event.getUserId());\n+            SamlValidator.validateXML(\"idPMetadataFile\",    secretMap.get(\"idPMetadataFile\").getString(),    event.getUserId());\n+        }\n+    }\n+\n+    /**\n+     * Returns the dotCMS implementation of the identity provider config.\n+     * This one basically returns (if exists) the configuration for a idp for a host\n+     * @return IdentityProviderConfigurationFactory\n+     */\n+    public IdentityProviderConfigurationFactory identityProviderConfigurationFactory() {\n+\n+        return identityProviderConfigurationFactory;\n+    }\n+\n+    private static void addRedirects() {\n+\n+        final NormalRule rule = new NormalRule();\n+        rule.setFrom(\"^\\\\/dotsaml\\\\/(\"+String.join(\"|\", DotSamlResource.dotsamlPathSegments)+\")\\\\/(.+)$\");\n+        rule.setToType(\"forward\");\n+        rule.setTo(\"/api/v1/dotsaml/$1/$2\");\n+        rule.setName(\"Dotsaml REST Service Redirect\");\n+        DotUrlRewriteFilter urlRewriteFilter = DotUrlRewriteFilter.getUrlRewriteFilter();\n+        try {\n+            if(urlRewriteFilter != null) {\n+                urlRewriteFilter.addRule(rule);\n+            }else {\n+                throw new Exception();\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNjAwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxOFrOG6Rifg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODozODoyMVrOG6SR8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzk1MA==", "bodyText": "Codacy found an issue: Assigning an Object to null is a code smell.  Consider refactoring.", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757950", "createdAt": "2020-07-31T18:11:18Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "diffHunk": "@@ -0,0 +1,469 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotcms.saml.SamlName;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.cms.factories.PublicEncryptionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.ActivityLogger;\n+import com.dotmarketing.util.AdminLogger;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UUIDGenerator;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.User;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.dotmarketing.util.UtilMethods.isSet;\n+\n+public class SAMLHelper {\n+\n+    private final HostWebAPI hostWebAPI;\n+    private final UserAPI    userAPI;\n+    private final RoleAPI    roleAPI;\n+    private final SamlAuthenticationService  samlAuthenticationService;\n+\n+    public SAMLHelper(final SamlAuthenticationService samlAuthenticationService) {\n+\n+        this.userAPI      = APILocator.getUserAPI();\n+        this.roleAPI      = APILocator.getRoleAPI();\n+        this.hostWebAPI   = WebAPILocator.getHostWebAPI();\n+        this.samlAuthenticationService = samlAuthenticationService;\n+    }\n+\n+    // Gets the attributes from the Assertion, based on the attributes\n+    // see if the user exists return it from the dotCMS records, if does not\n+    // exist then, tries to create it.\n+    // the existing or created user, will be updated the roles if they present\n+    // on the assertion.\n+    protected User resolveUser(final Attributes attributes,\n+                             final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        User user       = null;\n+        User systemUser = null;\n+        try {\n+\n+            Logger.debug(this, ()-> \"Validating user - \" + attributes);\n+\n+            systemUser             = this.userAPI.getSystemUser();\n+            final Company company  = APILocator.getCompanyAPI().getDefaultCompany();\n+            final String  authType = company.getAuthType();\n+            user                   = Company.AUTH_TYPE_ID.equals(authType)?\n+                    this.userAPI.loadUserById(this.samlAuthenticationService.getValue(attributes.getNameID()),      systemUser, false):\n+                    this.userAPI.loadByUserByEmail(this.samlAuthenticationService.getValue(attributes.getNameID()), systemUser, false);\n+        } catch (NoSuchUserException e) {\n+\n+            Logger.error(this, \"No user matches ID '\" +\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()) + \"'. Creating one...\", e);\n+            user = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc3MDA5Nw==", "bodyText": "it is ok", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463770097", "createdAt": "2020-07-31T18:38:21Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "diffHunk": "@@ -0,0 +1,469 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotcms.saml.SamlName;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.cms.factories.PublicEncryptionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.ActivityLogger;\n+import com.dotmarketing.util.AdminLogger;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UUIDGenerator;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.User;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.dotmarketing.util.UtilMethods.isSet;\n+\n+public class SAMLHelper {\n+\n+    private final HostWebAPI hostWebAPI;\n+    private final UserAPI    userAPI;\n+    private final RoleAPI    roleAPI;\n+    private final SamlAuthenticationService  samlAuthenticationService;\n+\n+    public SAMLHelper(final SamlAuthenticationService samlAuthenticationService) {\n+\n+        this.userAPI      = APILocator.getUserAPI();\n+        this.roleAPI      = APILocator.getRoleAPI();\n+        this.hostWebAPI   = WebAPILocator.getHostWebAPI();\n+        this.samlAuthenticationService = samlAuthenticationService;\n+    }\n+\n+    // Gets the attributes from the Assertion, based on the attributes\n+    // see if the user exists return it from the dotCMS records, if does not\n+    // exist then, tries to create it.\n+    // the existing or created user, will be updated the roles if they present\n+    // on the assertion.\n+    protected User resolveUser(final Attributes attributes,\n+                             final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        User user       = null;\n+        User systemUser = null;\n+        try {\n+\n+            Logger.debug(this, ()-> \"Validating user - \" + attributes);\n+\n+            systemUser             = this.userAPI.getSystemUser();\n+            final Company company  = APILocator.getCompanyAPI().getDefaultCompany();\n+            final String  authType = company.getAuthType();\n+            user                   = Company.AUTH_TYPE_ID.equals(authType)?\n+                    this.userAPI.loadUserById(this.samlAuthenticationService.getValue(attributes.getNameID()),      systemUser, false):\n+                    this.userAPI.loadByUserByEmail(this.samlAuthenticationService.getValue(attributes.getNameID()), systemUser, false);\n+        } catch (NoSuchUserException e) {\n+\n+            Logger.error(this, \"No user matches ID '\" +\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()) + \"'. Creating one...\", e);\n+            user = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzk1MA=="}, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNjA2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/saml/DotAbstractSamlConfigurationServiceImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxOVrOG6RiiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToxOVrOG6RiiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzk2MQ==", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757961", "createdAt": "2020-07-31T18:11:19Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/saml/DotAbstractSamlConfigurationServiceImpl.java", "diffHunk": "@@ -0,0 +1,254 @@\n+package com.dotcms.saml;\n+\n+import com.dotmarketing.util.Logger;\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Supplier;\n+\n+/**\n+ * This service will retrieve information form the idp config, but also if the value is not set will provide the default value for the saml name.\n+ * It has different implementation for several kinds of values\n+ * @author jsanca\n+ */\n+public abstract class DotAbstractSamlConfigurationServiceImpl implements SamlConfigurationService {\n+\n+    private static final String NULL = \"NULL\";\n+    private static final String UNABLE_TO_READ_FILE = \"File does not exist or unable to read : \";\n+    private static final String NOT_FOUND_ERROR = \"Property Name not Found: \";\n+\n+    private AtomicBoolean init = new AtomicBoolean(false);\n+    private final Map<String, String> defaultProperties = new ConcurrentHashMap<>();\n+\n+    @Override\n+    public void initService(final Map<String, Object> contextMap) {\n+\n+        if (!this.init.get()) {\n+\n+            final Map<String, String> samlInitialMap = this.createInitialMap();\n+            for (final Map.Entry<String, String> entry : samlInitialMap.entrySet()) {\n+\n+                this.defaultProperties.put(entry.getKey(), null == entry.getValue()?NULL:entry.getValue());\n+            }\n+\n+            this.internalInit(contextMap);\n+        }\n+    }\n+\n+    private synchronized void internalInit(final Map<String, Object> contextMap) {\n+\n+        final String dotSamlDefaultPropertiesValue = (String)contextMap.get(DOT_SAML_DEFAULT_PROPERTIES_CONTEXT_MAP_KEY);\n+\n+        if (null == dotSamlDefaultPropertiesValue) {\n+\n+            Logger.warn(this, DOT_SAML_DEFAULT_PROPERTIES_CONTEXT_MAP_KEY + \" must be set on the argument context map\");\n+        } else {\n+\n+            final File dotSamlDefaultPropertiesFile = new File(dotSamlDefaultPropertiesValue);\n+\n+            if (!dotSamlDefaultPropertiesFile.exists() || !dotSamlDefaultPropertiesFile.canRead()) {\n+\n+                Logger.warn(this, \"The \" + dotSamlDefaultPropertiesValue + \" does not exists or can not read\");\n+            } else {\n+\n+                final Properties properties = new Properties();\n+\n+                try (InputStream input = Files.newInputStream(dotSamlDefaultPropertiesFile.toPath())) {\n+\n+                    properties.load(input);\n+                } catch (IOException ex) {\n+                    // Since this is optional, it is valid to not have the file.\n+                    // Log and go on.\n+                    Logger.warn(this, UNABLE_TO_READ_FILE + dotSamlDefaultPropertiesValue);\n+\n+                }\n+\n+                properties.forEach((key, value) -> {\n+\n+                    final SamlName samlName = SamlName.findProperty((String)key);\n+                    if (null != samlName) {\n+\n+                        this.defaultProperties.put(samlName.getPropertyName(), (String)value);\n+                    }\n+                });\n+\n+                this.init.set(true);\n+            }\n+        }\n+    }\n+\n+\n+    @Override\n+    public String getConfigAsString(final IdentityProviderConfiguration identityProviderConfiguration, final SamlName samlName) {\n+\n+        try {\n+\n+            final String value = identityProviderConfiguration.containsOptionalProperty(samlName.getPropertyName())?\n+                    (String) identityProviderConfiguration.getOptionalProperty(samlName.getPropertyName()):\n+                    this.getDefaultStringParameter(samlName);\n+\n+            Logger.debug(this,\n+                    ()-> \"Found \" + samlName.getPropertyName() + \" : \" + ((value == null) ? \"null\" : value));\n+\n+            return value;\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5NTYwNjEwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToyMFrOG6RikA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMVQxODoxMToyMFrOG6RikA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1Nzk2OA==", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "url": "https://github.com/dotCMS/core/pull/18675#discussion_r463757968", "createdAt": "2020-07-31T18:11:20Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/auth/providers/saml/v1/SAMLHelper.java", "diffHunk": "@@ -0,0 +1,469 @@\n+package com.dotcms.auth.providers.saml.v1;\n+\n+import com.dotcms.saml.Attributes;\n+import com.dotcms.saml.DotSamlConstants;\n+import com.dotcms.saml.DotSamlProxyFactory;\n+import com.dotcms.saml.IdentityProviderConfiguration;\n+import com.dotcms.saml.SamlAuthenticationService;\n+import com.dotcms.saml.SamlException;\n+import com.dotcms.saml.SamlName;\n+import com.dotmarketing.beans.Host;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.DotStateException;\n+import com.dotmarketing.business.DuplicateUserException;\n+import com.dotmarketing.business.NoSuchUserException;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.business.UserAPI;\n+import com.dotmarketing.business.web.HostWebAPI;\n+import com.dotmarketing.business.web.WebAPILocator;\n+import com.dotmarketing.cms.factories.PublicEncryptionFactory;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.util.ActivityLogger;\n+import com.dotmarketing.util.AdminLogger;\n+import com.dotmarketing.util.DateUtil;\n+import com.dotmarketing.util.Logger;\n+import com.dotmarketing.util.RegEX;\n+import com.dotmarketing.util.SecurityLogger;\n+import com.dotmarketing.util.UUIDGenerator;\n+import com.liferay.portal.model.Company;\n+import com.liferay.portal.model.User;\n+import org.apache.commons.lang.StringUtils;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URLDecoder;\n+import java.util.Arrays;\n+import java.util.Date;\n+import java.util.List;\n+\n+import static com.dotmarketing.util.UtilMethods.isSet;\n+\n+public class SAMLHelper {\n+\n+    private final HostWebAPI hostWebAPI;\n+    private final UserAPI    userAPI;\n+    private final RoleAPI    roleAPI;\n+    private final SamlAuthenticationService  samlAuthenticationService;\n+\n+    public SAMLHelper(final SamlAuthenticationService samlAuthenticationService) {\n+\n+        this.userAPI      = APILocator.getUserAPI();\n+        this.roleAPI      = APILocator.getRoleAPI();\n+        this.hostWebAPI   = WebAPILocator.getHostWebAPI();\n+        this.samlAuthenticationService = samlAuthenticationService;\n+    }\n+\n+    // Gets the attributes from the Assertion, based on the attributes\n+    // see if the user exists return it from the dotCMS records, if does not\n+    // exist then, tries to create it.\n+    // the existing or created user, will be updated the roles if they present\n+    // on the assertion.\n+    protected User resolveUser(final Attributes attributes,\n+                             final IdentityProviderConfiguration identityProviderConfiguration) {\n+\n+        User user       = null;\n+        User systemUser = null;\n+        try {\n+\n+            Logger.debug(this, ()-> \"Validating user - \" + attributes);\n+\n+            systemUser             = this.userAPI.getSystemUser();\n+            final Company company  = APILocator.getCompanyAPI().getDefaultCompany();\n+            final String  authType = company.getAuthType();\n+            user                   = Company.AUTH_TYPE_ID.equals(authType)?\n+                    this.userAPI.loadUserById(this.samlAuthenticationService.getValue(attributes.getNameID()),      systemUser, false):\n+                    this.userAPI.loadByUserByEmail(this.samlAuthenticationService.getValue(attributes.getNameID()), systemUser, false);\n+        } catch (NoSuchUserException e) {\n+\n+            Logger.error(this, \"No user matches ID '\" +\n+                    this.samlAuthenticationService.getValue(attributes.getNameID()) + \"'. Creating one...\", e);\n+            user = null;\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0789e86cbd09a03821cbd5ccc6fc29f6389c679b"}, "originalPosition": 82}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2168, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}