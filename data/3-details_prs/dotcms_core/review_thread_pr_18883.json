{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5NTU4Mjg5", "number": 18883, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0Njo0MlrOEO841A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowNlrOEPKsMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTEzMTA4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventsAPIImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0Njo0MlrOGyZDuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0Njo0MlrOGyZDuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5MjUzNg==", "bodyText": "level", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455492536", "createdAt": "2020-07-16T03:46:42Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventsAPIImpl.java", "diffHunk": "@@ -185,34 +190,88 @@ public void setOrphanEventSubscriber(final EventSubscriber<OrphanEvent> orphanEv\n \n \n     @Override\n-    public void asyncNotify(final Object event) {\n+    public void asyncNotify(final Object event, final EventCompletionHandler completionHandler) {\n \n         final DotSubmitter dotSubmitter = this.dotConcurrentFactory.getSubmitter(LOCAL_SYSTEM_EVENTS_THREAD_POOL_SUBMITTER_NAME);\n-        dotSubmitter.submit(()-> this.notify(event));\n+        if(null != completionHandler){\n+            dotSubmitter.submit(()-> this.notify(event, completionHandler));\n+        } else {\n+           dotSubmitter.submit(()-> this.notify(event));\n+        }\n     } // asyncNotify.\n \n-\n     @Override\n-    public void notify(final Object event) {\n-\n-        final CopyOnWriteArrayList<EventSubscriber> eventSubscribers =\n-                this.getEventSubscribersByEventType(event.getClass());\n-\n-        if (null != eventSubscribers) {\n-\n-            for (EventSubscriber eventSubscriber : eventSubscribers) {\n-\n-                if (null != eventSubscriber) {\n+    public void asyncNotify(final Object event) {\n+        asyncNotify(event, null);\n+    }\n \n-                    eventSubscriber.notify(event);\n+    /**\n+     * Private implementation that allows firing an event completion handler\n+     */\n+    private void notify(final Object event, final EventCompletionHandler completionHandler) {\n+        try {\n+            final List<EventSubscriber> eventSubscribers =\n+                    this.getEventSubscribersByEventType(event.getClass());\n+\n+            if (null != eventSubscribers) {\n+                if (event instanceof KeyFilterable) {\n+                    synchronized (this) {\n+                        //if we're broadcasting an event that is an instance of KeyFilterable\n+                        //it means it is intended to a limited audience.\n+                        //Both the even and the receiver must be an instance of KeyFilterable\n+                        final KeyFilterable keyFilterableEvent = (KeyFilterable) event;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72e67eacfeb98a8579c885044511fa9a27e98258"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTEzMTYxOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventsAPIImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0Njo1N1rOGyZD_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0Njo1N1rOGyZD_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5MjYwNA==", "bodyText": "typo", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455492604", "createdAt": "2020-07-16T03:46:57Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/system/event/local/business/LocalSystemEventsAPIImpl.java", "diffHunk": "@@ -185,34 +190,88 @@ public void setOrphanEventSubscriber(final EventSubscriber<OrphanEvent> orphanEv\n \n \n     @Override\n-    public void asyncNotify(final Object event) {\n+    public void asyncNotify(final Object event, final EventCompletionHandler completionHandler) {\n \n         final DotSubmitter dotSubmitter = this.dotConcurrentFactory.getSubmitter(LOCAL_SYSTEM_EVENTS_THREAD_POOL_SUBMITTER_NAME);\n-        dotSubmitter.submit(()-> this.notify(event));\n+        if(null != completionHandler){\n+            dotSubmitter.submit(()-> this.notify(event, completionHandler));\n+        } else {\n+           dotSubmitter.submit(()-> this.notify(event));\n+        }\n     } // asyncNotify.\n \n-\n     @Override\n-    public void notify(final Object event) {\n-\n-        final CopyOnWriteArrayList<EventSubscriber> eventSubscribers =\n-                this.getEventSubscribersByEventType(event.getClass());\n-\n-        if (null != eventSubscribers) {\n-\n-            for (EventSubscriber eventSubscriber : eventSubscribers) {\n-\n-                if (null != eventSubscriber) {\n+    public void asyncNotify(final Object event) {\n+        asyncNotify(event, null);\n+    }\n \n-                    eventSubscriber.notify(event);\n+    /**\n+     * Private implementation that allows firing an event completion handler\n+     */\n+    private void notify(final Object event, final EventCompletionHandler completionHandler) {\n+        try {\n+            final List<EventSubscriber> eventSubscribers =\n+                    this.getEventSubscribersByEventType(event.getClass());\n+\n+            if (null != eventSubscribers) {\n+                if (event instanceof KeyFilterable) {\n+                    synchronized (this) {\n+                        //if we're broadcasting an event that is an instance of KeyFilterable\n+                        //it means it is intended to a limited audience.\n+                        //Both the even and the receiver must be an instance of KeyFilterable\n+                        final KeyFilterable keyFilterableEvent = (KeyFilterable) event;\n+                        Logger.info(LocalSystemEventsAPIImpl.class, ()->\" Broadcasting a Filterable Event.\");\n+                        final Stream<KeyFilterable> keyAwareSubscribers = eventSubscribers.stream()\n+                                .filter(eventSubscriber -> eventSubscriber instanceof KeyFilterable)\n+                                .map(KeyFilterable.class::cast)\n+                                .filter(keyFilterable -> keyFilterable.getKey() != null);\n+\n+                        final List<EventSubscriber> eventAudience = keyAwareSubscribers\n+                                .filter(keyFilterable ->\n+                                        keyFilterable.getKey()\n+                                                .compareTo(keyFilterableEvent.getKey()) == 0)\n+                                .map(EventSubscriber.class::cast)\n+                                .collect(Collectors.toList());\n+                        broadcast(eventAudience, event);\n+                        Logger.info(LocalSystemEventsAPIImpl.class, () -> String\n+                                .format(\" Filtered Audience for event with key `%s`  is `%d` long. \",\n+                                        keyFilterableEvent.getKey(), eventAudience.size()));\n+                    }\n+                } else {\n+                    broadcast(eventSubscribers, event);\n                 }\n+            } else {\n+                this.orphanEventSubscriber.notify(new OrphanEvent(event));\n+            }\n+        } finally {\n+            if (null != completionHandler) {\n+                Try.of(() -> {\n+                    completionHandler.onComplete(event);\n+                    return true;\n+                }).get();\n             }\n-        } else {\n-\n-            this.orphanEventSubscriber.notify(new OrphanEvent(event));\n         }\n+\n     } // asyncNotify.\n \n+    /**\n+     * This method basically delivers the event to all the subscribers\n+     * @param subscibers\n+     * @param event\n+     */\n+    private void broadcast(final List<EventSubscriber> subscibers, final Object event){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72e67eacfeb98a8579c885044511fa9a27e98258"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTEzMjE5OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/system/event/local/model/KeyFilterable.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0NzoxOVrOGyZETQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0NzoyOFrOGyZEjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5MjY4NQ==", "bodyText": "Functional interface", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455492685", "createdAt": "2020-07-16T03:47:19Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/system/event/local/model/KeyFilterable.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package com.dotcms.system.event.local.model;\n+\n+public interface KeyFilterable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72e67eacfeb98a8579c885044511fa9a27e98258"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5Mjc1MA==", "bodyText": "Doc", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455492750", "createdAt": "2020-07-16T03:47:28Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/system/event/local/model/KeyFilterable.java", "diffHunk": "@@ -0,0 +1,7 @@\n+package com.dotcms.system.event.local.model;\n+\n+public interface KeyFilterable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5MjY4NQ=="}, "originalCommit": {"oid": "72e67eacfeb98a8579c885044511fa9a27e98258"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MTEzMzE3OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/test/java/com/dotcms/system/event/local/KeyFilterableEvent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0NzozOFrOGyZEzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwMzo0NzozOFrOGyZEzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ5MjgxMw==", "bodyText": "Doc", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455492813", "createdAt": "2020-07-16T03:47:38Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/test/java/com/dotcms/system/event/local/KeyFilterableEvent.java", "diffHunk": "@@ -0,0 +1,17 @@\n+package com.dotcms.system.event.local;\n+\n+import com.dotcms.system.event.local.model.KeyFilterable;\n+\n+public class KeyFilterableEvent implements KeyFilterable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "72e67eacfeb98a8579c885044511fa9a27e98258"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzM5MjA0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/test/java/com/dotcms/system/event/local/LocalSystemEventsAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowMVrOGyusAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowMVrOGyusAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0NjkxMw==", "bodyText": "Codacy found an issue: The String literal \"subscriber1\" appears 5 times in this file; the first occurrence is on line 272", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846913", "createdAt": "2020-07-16T14:51:01Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/system/event/local/LocalSystemEventsAPITest.java", "diffHunk": "@@ -212,6 +215,103 @@ public void orphanSubscriberTest() throws DotDataException {\n         Assert.assertTrue(isCalled.get());\n     } // orphanSubscriberTest.\n \n+    /**\n+     * Given scenario: We're testing that even when no subscribers are added the asyncNotify callback gets called\n+     * Expected results: We expect that the callback gets called.\n+     */\n+    @Test\n+    public void Test_Non_Blocking_Notification_On_Event_Consumed_With_No_Subscribers() {\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        final AtomicBoolean isOnCompleteCalled = new AtomicBoolean(false);\n+        final String message = \"Async notify Event.\";\n+        localSystemEventsAPI.asyncNotify(new TestEventType1(message), event -> {\n+            Assert.assertTrue(event instanceof TestEventType1);\n+            final TestEventType1 eventType1 = (TestEventType1)event;\n+            Assert.assertEquals(eventType1.getMsg(), message);\n+            isOnCompleteCalled.set(true);\n+        });\n+        DateUtil.sleep(2000);\n+        Assert.assertTrue(isOnCompleteCalled.get());\n+    }\n+\n+    /**\n+     * Given scenario: We're testing that even when subscribers are added  the asyncNotify callback gets called just once.\n+     * Expected results: We expect that the callback gets called exactly once.\n+     */\n+    @Test\n+    public void Test_Non_Blocking_Notification_On_Event_Consumed_With_Subscribers() {\n+        final String message = \"Async notify Event 2.\";\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        localSystemEventsAPI.subscribe(new TestDelegateSubscriber(){\n+            @Override\n+            public void notify(final TestEventType2 event) {\n+                Assert.assertEquals(event.getMsg(), message);\n+            }\n+        });\n+        final AtomicInteger callsCount = new AtomicInteger(0);\n \n-\n-} // E:O:F:LocalSystemEventsAPITest.\n+        localSystemEventsAPI.asyncNotify(new TestEventType2(message), event -> {\n+            Assert.assertTrue(event instanceof TestEventType2);\n+            final TestEventType2 eventType2 = (TestEventType2)event;\n+            Assert.assertEquals(eventType2.getMsg(), message);\n+            callsCount.incrementAndGet();\n+        });\n+        DateUtil.sleep(2000);\n+        Assert.assertEquals(callsCount.get(), 1);\n+    }\n+\n+    /**\n+     * Given scenario: We're testing that an event that implements KeyFilterable and is broadcast only reaches certain audience.\n+     * We creating a few subscribers each one of the provides a key. The Event must reach only those which have the same id.\n+     * Expected results: Only the subscribers with a matching id will be able to consume the event;\n+     */\n+    @Test\n+    public void Test_Send_Event_For_Limited_Audience() {\n+\n+        final Map<String, AtomicInteger> callsCounts = ImmutableMap\n+                .of(\"subscriber1\", new AtomicInteger(0), \"subscriber2\", new AtomicInteger(0),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzM5MjE0OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowMlrOGyusDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowMlrOGyusDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0NjkyNQ==", "bodyText": "Codacy found an issue: Unnecessary use of fully qualified name 'Assert.assertEquals' due to existing static import 'org.junit.Assert.assertEquals'", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846925", "createdAt": "2020-07-16T14:51:02Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -785,4 +792,72 @@ public void Test_Get_Secret_fallbackOnSystemHost_With_Non_Valid_License()\n         nonValidLicenseAppsAPI.getSecrets(\"anyKey\", true, systemHost, admin);\n     }\n \n+    /**\n+     * Given scenario: We subscribe an event listener and save an event\n+     * Expected Results: We expect that an event is fired and that after firing the event the AppsSecret that was initially passed to the save method is now destroyed\n+     * @throws DotDataException\n+     * @throws DotSecurityException\n+     */\n+    @Test\n+    public void Test_Save_Secret_Expect_Event_Notification() throws DotDataException, DotSecurityException{\n+        final AtomicInteger callsCount = new AtomicInteger(0);\n+        final AppsAPI api = APILocator.getAppsAPI();\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        localSystemEventsAPI.subscribe(AppSecretSavedEvent.class, new AppsSecretEventSubscriber(){\n+            @Override\n+            public void notify(AppSecretSavedEvent event) {\n+                callsCount.incrementAndGet();\n+            }\n+        });\n+\n+        final String appKey = AppsSecretEventSubscriber.appKey;\n+\n+        final AppDescriptor descriptor = mock(AppDescriptor.class);\n+        when(descriptor.isAllowExtraParameters()).thenReturn(false);\n+        final Map<String, ParamDescriptor> params = of(\n+                \"requiredNoDefault\",newParam(null, false, Type.STRING, \"any\", \"hint\", true),\n+                \"requiredDefault\", newParam(\"default\", false, Type.STRING, \"any\", \"hint\", true),\n+                \"nonRequiredNoDefault\", newParam(null, false, Type.STRING, \"any\", \"hint\", false)\n+        );\n+        when(descriptor.getParams()).thenReturn(params);\n+        when(descriptor.getName()).thenReturn(\"any-name\");\n+        when(descriptor.getKey()).thenReturn(appKey);\n+\n+        final Host site = new SiteDataGen().nextPersisted();\n+        final User admin = TestUserUtils.getAdminUser();\n+\n+        //Let's create a set of secrets for a service\n+        final AppSecrets.Builder builder1 = new AppSecrets.Builder();\n+        final AppSecrets secrets = builder1.withKey(appKey)\n+                .withHiddenSecret(\"requiredNoDefault\", \"value\") //We're providing the expected value\n+                .withHiddenSecret(\"requiredDefault\", \"secret-2\")\n+                .build();\n+        //Save it\n+        api.saveSecrets(secrets, site, admin);\n+        DateUtil.sleep(2000);\n+        Assert.assertEquals(callsCount.get(), 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzM5MjIyOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/test/java/com/dotcms/system/event/local/LocalSystemEventsAPITest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowM1rOGyusHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowM1rOGyusHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0Njk0MQ==", "bodyText": "Codacy found an issue: The String literal \"subscriber3\" appears 7 times in this file; the first occurrence is on line 273", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846941", "createdAt": "2020-07-16T14:51:03Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/test/java/com/dotcms/system/event/local/LocalSystemEventsAPITest.java", "diffHunk": "@@ -212,6 +215,103 @@ public void orphanSubscriberTest() throws DotDataException {\n         Assert.assertTrue(isCalled.get());\n     } // orphanSubscriberTest.\n \n+    /**\n+     * Given scenario: We're testing that even when no subscribers are added the asyncNotify callback gets called\n+     * Expected results: We expect that the callback gets called.\n+     */\n+    @Test\n+    public void Test_Non_Blocking_Notification_On_Event_Consumed_With_No_Subscribers() {\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        final AtomicBoolean isOnCompleteCalled = new AtomicBoolean(false);\n+        final String message = \"Async notify Event.\";\n+        localSystemEventsAPI.asyncNotify(new TestEventType1(message), event -> {\n+            Assert.assertTrue(event instanceof TestEventType1);\n+            final TestEventType1 eventType1 = (TestEventType1)event;\n+            Assert.assertEquals(eventType1.getMsg(), message);\n+            isOnCompleteCalled.set(true);\n+        });\n+        DateUtil.sleep(2000);\n+        Assert.assertTrue(isOnCompleteCalled.get());\n+    }\n+\n+    /**\n+     * Given scenario: We're testing that even when subscribers are added  the asyncNotify callback gets called just once.\n+     * Expected results: We expect that the callback gets called exactly once.\n+     */\n+    @Test\n+    public void Test_Non_Blocking_Notification_On_Event_Consumed_With_Subscribers() {\n+        final String message = \"Async notify Event 2.\";\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        localSystemEventsAPI.subscribe(new TestDelegateSubscriber(){\n+            @Override\n+            public void notify(final TestEventType2 event) {\n+                Assert.assertEquals(event.getMsg(), message);\n+            }\n+        });\n+        final AtomicInteger callsCount = new AtomicInteger(0);\n \n-\n-} // E:O:F:LocalSystemEventsAPITest.\n+        localSystemEventsAPI.asyncNotify(new TestEventType2(message), event -> {\n+            Assert.assertTrue(event instanceof TestEventType2);\n+            final TestEventType2 eventType2 = (TestEventType2)event;\n+            Assert.assertEquals(eventType2.getMsg(), message);\n+            callsCount.incrementAndGet();\n+        });\n+        DateUtil.sleep(2000);\n+        Assert.assertEquals(callsCount.get(), 1);\n+    }\n+\n+    /**\n+     * Given scenario: We're testing that an event that implements KeyFilterable and is broadcast only reaches certain audience.\n+     * We creating a few subscribers each one of the provides a key. The Event must reach only those which have the same id.\n+     * Expected results: Only the subscribers with a matching id will be able to consume the event;\n+     */\n+    @Test\n+    public void Test_Send_Event_For_Limited_Audience() {\n+\n+        final Map<String, AtomicInteger> callsCounts = ImmutableMap\n+                .of(\"subscriber1\", new AtomicInteger(0), \"subscriber2\", new AtomicInteger(0),\n+                        \"subscriber3\", new AtomicInteger(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzM5MjMwOnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowNFrOGyusKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowNFrOGyusKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0Njk1Mw==", "bodyText": "Codacy found an issue: Avoid unused imports such as 'com.dotcms.system.event.local.model.EventSubscriber'", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846953", "createdAt": "2020-07-16T14:51:04Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -17,6 +17,8 @@\n import com.dotcms.datagen.SiteDataGen;\n import com.dotcms.datagen.TestUserUtils;\n import com.dotcms.datagen.UserDataGen;\n+import com.dotcms.system.event.local.business.LocalSystemEventsAPI;\n+import com.dotcms.system.event.local.model.EventSubscriber;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzM5MjM2OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppSecretSavedEvent.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowNVrOGyusNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowNVrOGyusNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0Njk2NA==", "bodyText": "Codacy found an issue: Classes implementing Serializable should set a serialVersionUID", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846964", "createdAt": "2020-07-16T14:51:05Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/security/apps/AppSecretSavedEvent.java", "diffHunk": "@@ -0,0 +1,52 @@\n+package com.dotcms.security.apps;\n+\n+import com.dotcms.system.event.local.model.KeyFilterable;\n+import com.dotmarketing.beans.Host;\n+import java.io.Serializable;\n+\n+/**\n+ * AppSecretSavedEvent\n+ * Broadcast when a secret is saved.\n+ */\n+public class AppSecretSavedEvent implements Serializable, KeyFilterable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzM5MjQ4OnYy", "diffSide": "RIGHT", "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowNlrOGyusRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNDo1MTowNlrOGyusRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg0Njk4MQ==", "bodyText": "Codacy found an issue: Consider using varargs for methods or constructors which take an array the last parameter.", "url": "https://github.com/dotCMS/core/pull/18883#discussion_r455846981", "createdAt": "2020-07-16T14:51:06Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/security/apps/AppsAPIImplTest.java", "diffHunk": "@@ -785,4 +792,72 @@ public void Test_Get_Secret_fallbackOnSystemHost_With_Non_Valid_License()\n         nonValidLicenseAppsAPI.getSecrets(\"anyKey\", true, systemHost, admin);\n     }\n \n+    /**\n+     * Given scenario: We subscribe an event listener and save an event\n+     * Expected Results: We expect that an event is fired and that after firing the event the AppsSecret that was initially passed to the save method is now destroyed\n+     * @throws DotDataException\n+     * @throws DotSecurityException\n+     */\n+    @Test\n+    public void Test_Save_Secret_Expect_Event_Notification() throws DotDataException, DotSecurityException{\n+        final AtomicInteger callsCount = new AtomicInteger(0);\n+        final AppsAPI api = APILocator.getAppsAPI();\n+        final LocalSystemEventsAPI localSystemEventsAPI = APILocator.getLocalSystemEventsAPI();\n+        localSystemEventsAPI.subscribe(AppSecretSavedEvent.class, new AppsSecretEventSubscriber(){\n+            @Override\n+            public void notify(AppSecretSavedEvent event) {\n+                callsCount.incrementAndGet();\n+            }\n+        });\n+\n+        final String appKey = AppsSecretEventSubscriber.appKey;\n+\n+        final AppDescriptor descriptor = mock(AppDescriptor.class);\n+        when(descriptor.isAllowExtraParameters()).thenReturn(false);\n+        final Map<String, ParamDescriptor> params = of(\n+                \"requiredNoDefault\",newParam(null, false, Type.STRING, \"any\", \"hint\", true),\n+                \"requiredDefault\", newParam(\"default\", false, Type.STRING, \"any\", \"hint\", true),\n+                \"nonRequiredNoDefault\", newParam(null, false, Type.STRING, \"any\", \"hint\", false)\n+        );\n+        when(descriptor.getParams()).thenReturn(params);\n+        when(descriptor.getName()).thenReturn(\"any-name\");\n+        when(descriptor.getKey()).thenReturn(appKey);\n+\n+        final Host site = new SiteDataGen().nextPersisted();\n+        final User admin = TestUserUtils.getAdminUser();\n+\n+        //Let's create a set of secrets for a service\n+        final AppSecrets.Builder builder1 = new AppSecrets.Builder();\n+        final AppSecrets secrets = builder1.withKey(appKey)\n+                .withHiddenSecret(\"requiredNoDefault\", \"value\") //We're providing the expected value\n+                .withHiddenSecret(\"requiredDefault\", \"secret-2\")\n+                .build();\n+        //Save it\n+        api.saveSecrets(secrets, site, admin);\n+        DateUtil.sleep(2000);\n+        Assert.assertEquals(callsCount.get(), 1);\n+\n+        // Now Test Secret has been destroyed.\n+        final Map<String, Secret> secretsPostSave = secrets.getSecrets();\n+        for(final String key: secretsPostSave.keySet()){\n+            final char[] value = secretsPostSave.get(key).getValue();\n+            assertTrue(isSecretDestroyed(value));\n+        }\n+    }\n+\n+    /**\n+     * for internal use validate a secret has been destroyed\n+     * @param chars\n+     * @return\n+     */\n+    private boolean isSecretDestroyed(final char [] chars){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0de1414e4a24aba954993f7c358eecd5302f15ca"}, "originalPosition": 113}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2041, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}