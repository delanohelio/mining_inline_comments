{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyOTQwNTQx", "number": 19243, "title": "#18554: Adding support quartz job for when executing integrity check in a receiver cluster ", "bodyText": "The introduced code has the purpose of provide to the integrity check tool the support to generate the integrity data file (to get conflicts prior to perform a Push-Publish) in a multi node environment.\nPreviously when running an integrity check, the \"sender\" host hits a \"receiver\" endpoint to generate the integrity data file by starting a thread to so on the receiver node.  Then right after that the sender starts a thread to query the generation process by hitting another \"receiver\" endpoint until something meaningful occurs..\nAll the control data was kept in the sender session and in the servlet context of one receiver node therefore there were no guarantee that the node generating the data file is the same one that is being queried about the status. If it's the same, then no problem but if not it won't know anything about the process and where the file is finally stored.\nTo fix this, a Quartz stateful IntegrityDataGenerationJob class was introduced to make sure that no more than one receiver node generates the file. The job replaces the first thread.\nThen a status file is created at the same location the integrity data file is saved to which is somewhere in the node shared location: assets directory. The file is a properties file so it stores data in a key-value pairs and it what it store is the current status of the file generation among other metadata. Since receivers share this location it's a centralized way of storing control data about the process.", "createdAt": "2020-09-09T15:48:36Z", "url": "https://github.com/dotCMS/core/pull/19243", "merged": true, "mergeCommit": {"oid": "0d91067d667879edaec9ab4773dcdfce7c50fb6f"}, "closed": true, "closedAt": "2020-09-22T19:04:09Z", "author": {"login": "victoralfaro-dotcms"}, "timelineItems": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdI3HGnABqjM3NjQ2ODE4MzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdLcUZCgFqTQ5MzczODAyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "88bba8a35fa8d26120365fc31e93c7a1ed32e36f", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/88bba8a35fa8d26120365fc31e93c7a1ed32e36f", "committedDate": "2020-09-10T21:21:06Z", "message": "test"}, "afterCommit": {"oid": "ed0294df40e6d9ec64d79d9331a61c60faa94f7a", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/ed0294df40e6d9ec64d79d9331a61c60faa94f7a", "committedDate": "2020-09-14T17:39:39Z", "message": "Addint integration tests for new job"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed0294df40e6d9ec64d79d9331a61c60faa94f7a", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/ed0294df40e6d9ec64d79d9331a61c60faa94f7a", "committedDate": "2020-09-14T17:39:39Z", "message": "Addint integration tests for new job"}, "afterCommit": {"oid": "974b8964b1ce20f9534bf900d656c5aad174d7e8", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/974b8964b1ce20f9534bf900d656c5aad174d7e8", "committedDate": "2020-09-14T21:40:57Z", "message": "#18554: Introducing IntegritiGenerationDataJob to support multi node receivers creation of file and query process for status"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "974b8964b1ce20f9534bf900d656c5aad174d7e8", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/974b8964b1ce20f9534bf900d656c5aad174d7e8", "committedDate": "2020-09-14T21:40:57Z", "message": "#18554: Introducing IntegritiGenerationDataJob to support multi node receivers creation of file and query process for status"}, "afterCommit": {"oid": "3e7f99f163978aacc7c06b80d1a5aa33e374b21d", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/3e7f99f163978aacc7c06b80d1a5aa33e374b21d", "committedDate": "2020-09-14T22:57:42Z", "message": "#18554: Introducing IntegritiGenerationDataJob to support multi node receivers creation of file and query process for status"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cc63c6e2d079ad73372396c88655515dc092240f", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/cc63c6e2d079ad73372396c88655515dc092240f", "committedDate": "2020-09-15T15:34:57Z", "message": "Applying codacy feedback"}, "afterCommit": {"oid": "4e39e4135f52861792260306f1f961d31c4ef37e", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/4e39e4135f52861792260306f1f961d31c4ef37e", "committedDate": "2020-09-15T16:16:57Z", "message": "Applying codacy feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4Nzk0ODI5", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-488794829", "createdAt": "2020-09-15T15:17:10Z", "commit": {"oid": "3e7f99f163978aacc7c06b80d1a5aa33e374b21d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNToxNzoxMFrOHSHBeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQxNjoxMTo0M1rOHSJa4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MTQ4MQ==", "bodyText": "remove this commented code", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488751481", "createdAt": "2020-09-15T15:17:10Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/quartz/job/CleanUpFieldReferencesJobTest.java", "diffHunk": "@@ -133,7 +134,7 @@ public void testCleanUpFieldJob(TestCase testCase)\n                 cal1.setTime((Date) fieldValue);\n                 cal2.setTime((Date) testCase.fieldValue);\n \n-                assertNotEquals(cal1.get(Calendar.DAY_OF_YEAR), cal2.get(Calendar.DAY_OF_YEAR));\n+                //assertNotEquals(cal1.get(Calendar.DAY_OF_YEAR), cal2.get(Calendar.DAY_OF_YEAR));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e7f99f163978aacc7c06b80d1a5aa33e374b21d"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MzUxMg==", "bodyText": "more than a String this is a path, right?", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488753512", "createdAt": "2020-09-15T15:19:50Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityUtil.java", "diffHunk": "@@ -243,79 +256,212 @@ public static void unzipFile(InputStream zipFile, String outputDir) throws Excep\n         }\n     }\n \n+    /**\n+     * Creates a String representing the integrity data path based on provided endpointId.\n+     *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e7f99f163978aacc7c06b80d1a5aa33e374b21d"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1MzYzNA==", "bodyText": "same before", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488753634", "createdAt": "2020-09-15T15:20:02Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityUtil.java", "diffHunk": "@@ -243,79 +256,212 @@ public static void unzipFile(InputStream zipFile, String outputDir) throws Excep\n         }\n     }\n \n+    /**\n+     * Creates a String representing the integrity data path based on provided endpointId.\n+     *\n+     * @param endpointId endpoint if\n+     * @return integrity data path\n+     */\n+    public static String getIntegrityDataPath(final String endpointId) {\n+        return ConfigUtils.getIntegrityPath() + File.separator + endpointId;\n+    }\n+\n+    /**\n+     * Creates a String representing the integrity data file path based on provided endpointId and the file name.\n+     * File names to be used: DataToCheck.zip, DataToFix.zip and DataStatus.properties.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e7f99f163978aacc7c06b80d1a5aa33e374b21d"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc1NDcwOA==", "bodyText": "I think a better name is getIntegrityDataFilePath because it really return the path", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488754708", "createdAt": "2020-09-15T15:21:29Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityUtil.java", "diffHunk": "@@ -243,79 +256,212 @@ public static void unzipFile(InputStream zipFile, String outputDir) throws Excep\n         }\n     }\n \n+    /**\n+     * Creates a String representing the integrity data path based on provided endpointId.\n+     *\n+     * @param endpointId endpoint if\n+     * @return integrity data path\n+     */\n+    public static String getIntegrityDataPath(final String endpointId) {\n+        return ConfigUtils.getIntegrityPath() + File.separator + endpointId;\n+    }\n+\n+    /**\n+     * Creates a String representing the integrity data file path based on provided endpointId and the file name.\n+     * File names to be used: DataToCheck.zip, DataToFix.zip and DataStatus.properties.\n+     *\n+     * @param endpointId endpoint gid\n+     * @param dataFile data filename\n+     * @return path to filename\n+     */\n+    public static String getIntegrityDataFile(final String endpointId, final String dataFile) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e7f99f163978aacc7c06b80d1a5aa33e374b21d"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc4OTY1Nw==", "bodyText": "I think that the triggerIntegrityDataGeneration method should check if the Quartz is running inner, I mean this code:\nhttps://github.com/dotCMS/core/pull/19243/files#diff-1c1ba904ed03287c1c0b48a6f3971449R204\nand if the quartz is running throw a exception then in the resource catch the exception and send the response", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488789657", "createdAt": "2020-09-15T16:10:11Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -153,68 +149,99 @@ private Response postWithEndpointState(String endpointId, String url, MediaType\n \t\treturn response;\n \t}\n \n+    /**\n+     * Resolves remote IP address from request.\n+     * @param request {@link HttpServletRequest}\n+     * @return a String representing the remote IP address (or hostname)\n+     */\n+    private static String resolveRemoteIp(@Context final HttpServletRequest request) {\n+        final String remoteIP = request.getRemoteHost();\n+        return !UtilMethods.isSet(remoteIP) ? remoteIP : request.getRemoteAddr();\n+    }\n+\n+    private static String getFullLocalIp(@Context final HttpServletRequest request) {\n+        final String localIp = request.getLocalName();\n+        Optional<String> port = HttpRequestDataUtil.getServerPort();\n+        return (!UtilMethods.isSet(localIp) ? localIp : request.getLocalName())\n+                + ':' + port.orElse(request.getLocalPort() + \"\");\n+    }\n \n     /**\n      * <p>Returns a zip with data from structures and folders for integrity check\n-     *\n-     * Usage: /getdata\n-     *\n      */\n-\n     @POST\n     @Path(\"/generateintegritydata/{params:.*}\")\n     @Consumes(MediaType.MULTIPART_FORM_DATA)\n     @Produces(\"text/plain\")\n-    public Response generateIntegrityData(@Context HttpServletRequest request, @FormDataParam(\"AUTH_TOKEN\") String auth_token_digest)  {\n+    public Response generateIntegrityData(\n+            @Context final HttpServletRequest request,\n+            @FormDataParam(\"AUTH_TOKEN\") final String auth_token_digest)  {\n+        final String localAddress = getFullLocalIp(request);\n+        if (!UtilMethods.isSet(auth_token_digest)) {\n+            final String message = \"Error: Authentication Token was not found.\";\n+            Logger.error(IntegrityResource.class, String.format(\"Receiver at %s> :%s\", localAddress, message));\n+            return Response\n+                    .status(HttpStatus.SC_BAD_REQUEST)\n+                    .entity(message)\n+                    .build();\n+        }\n \n-        String remoteIP = null;\n+        final String remoteIp = resolveRemoteIp(request);\n+        final PublishingEndPointAPI endpointAPI = APILocator.getPublisherEndPointAPI();\n         try {\n-\n-            if ( !UtilMethods.isSet( auth_token_digest ) ) {\n-                return Response.status( HttpStatus.SC_BAD_REQUEST ).entity( \"Error: 'endpoint' is a required param.\" ).build();\n-            }\n-\n-\n-\n-            remoteIP = request.getRemoteHost();\n-            if(!UtilMethods.isSet(remoteIP))\n-                remoteIP = request.getRemoteAddr();\n-\n-            PublishingEndPointAPI endpointAPI = APILocator.getPublisherEndPointAPI();\n-            final PublishingEndPoint requesterEndPoint = endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n-\n-            if(!BundlePublisherResource.isValidToken(auth_token_digest, remoteIP, requesterEndPoint)) {\n+            final PublishingEndPoint requesterEndpoint = endpointAPI.findEnabledSendingEndPointByAddress(remoteIp);\n+            if (!BundlePublisherResource.isValidToken(auth_token_digest, remoteIp, requesterEndpoint)) {\n+                Logger.error(\n+                        IntegrityResource.class,\n+                        String.format(\n+                                \"Receiver at %s:> Authentication Token is invalid for ip: %s and endpoint id %s\",\n+                                localAddress,\n+                                remoteIp,\n+                                requesterEndpoint.getId()));\n                 return Response.status(HttpStatus.SC_UNAUTHORIZED).build();\n             }\n \n-            ServletContext servletContext = request.getSession().getServletContext();\n-\n-            if(servletContext.getAttribute(\"integrityRunning\")!=null && ((Boolean) servletContext.getAttribute(\"integrityRunning\"))) {\n-                throw new WebApplicationException(Response.status(HttpStatus.SC_CONFLICT).entity(\"Already Running\").build());\n+            if (QuartzUtils.isJobRunning(\n+                    IntegrityDataGenerationJob.JOB_NAME,\n+                    IntegrityDataGenerationJob.JOB_GROUP)) {\n+                Logger.error(\n+                        IntegrityResource.class,\n+                        String.format(\n+                                \"Receiver at %s:> job is already running for endpoint id: %s, so aborting generation\",\n+                                localAddress,\n+                                requesterEndpoint.getId()));\n+                throw new WebApplicationException(\n+                        Response.status(HttpStatus.SC_CONFLICT)\n+                                .entity(\"Already Running\")\n+                                .build());\n             }\n \n-            String transactionId = UUIDGenerator.generateUuid();\n-            servletContext.setAttribute(\"integrityDataRequestID\", transactionId);\n-\n-            // start data generation process\n-            IntegrityDataGeneratorThread idg = new IntegrityDataGeneratorThread( requesterEndPoint, request.getSession().getServletContext() );\n-            idg.start();\n-            //Saving the thread on the session context for a later use\n-            servletContext.setAttribute( \"integrityDataGeneratorThread_\" + transactionId, idg );\n+            final String transactionId = UUIDGenerator.generateUuid();\n+            IntegrityDataGenerationJob.triggerIntegrityDataGeneration(requesterEndpoint, transactionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e7f99f163978aacc7c06b80d1a5aa33e374b21d"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc5MDc1Mg==", "bodyText": "same before", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488790752", "createdAt": "2020-09-15T16:11:43Z", "author": {"login": "freddyucv"}, "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -230,79 +257,139 @@ public Response generateIntegrityData(@Context HttpServletRequest request, @Form\n     @Path(\"/getintegritydata/{params:.*}\")\n     @Produces(\"application/zip\")\n     @Consumes(MediaType.MULTIPART_FORM_DATA)\n-    public Response getIntegrityData(@Context HttpServletRequest request, @FormDataParam(\"AUTH_TOKEN\") String auth_token_digest, @FormDataParam(\"REQUEST_ID\") String requestId)  {\n-        String remoteIP = null;\n+    public Response getIntegrityData(@Context final HttpServletRequest request,\n+                                     @FormDataParam(\"AUTH_TOKEN\") final String auth_token_digest,\n+                                     @FormDataParam(\"REQUEST_ID\") final String requestId)  {\n+        final String remoteIp = resolveRemoteIp(request);\n+        final String localAddress = getFullLocalIp(request);\n \n+        final PublishingEndPointAPI endpointAPI = APILocator.getPublisherEndPointAPI();\n         try {\n+            final PublishingEndPoint requesterEndpoint = endpointAPI.findEnabledSendingEndPointByAddress(remoteIp);\n+\n+            if (!BundlePublisherResource.isValidToken(auth_token_digest, remoteIp, requesterEndpoint) ||\n+                    !UtilMethods.isSet(requestId)) {\n+                Logger.error(\n+                        IntegrityResource.class,\n+                        String.format(\n+                                \"Receiver at %s:> Authentication Token is invalid for ip: %s and endpoint id %s\",\n+                                localAddress,\n+                                remoteIp,\n+                                requesterEndpoint.getId()));\n+                return Response.status(HttpStatus.SC_UNAUTHORIZED).build();\n+            }\n \n+            if (QuartzUtils.isJobRunning(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e7f99f163978aacc7c06b80d1a5aa33e374b21d"}, "originalPosition": 230}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MTI2OTU4", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-489126958", "createdAt": "2020-09-15T21:39:29Z", "commit": {"oid": "3582e642600efd7982e82aef08539fcb17969afd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMTozOToyOVrOHSVmdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMTozOToyOVrOHSVmdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk5MDMyNg==", "bodyText": "This needs to be the *Test class instead of the Job itself", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488990326", "createdAt": "2020-09-15T21:39:29Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotcms/MainSuite.java", "diffHunk": "@@ -316,7 +317,9 @@\n         ContentletWebAPIImplIntegrationTest.class,\n         Task05370AddAppsPortletToLayoutTest.class,\n         FolderFactoryImplTest.class,\n-        DotSamlResourceTest.class\n+        DotSamlResourceTest.class,\n+        FolderFactoryImplTest.class,\n+        IntegrityDataGenerationJob.class", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3582e642600efd7982e82aef08539fcb17969afd"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MTI3NzA2", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-489127706", "createdAt": "2020-09-15T21:40:45Z", "commit": {"oid": "3582e642600efd7982e82aef08539fcb17969afd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMTo0MDo0NlrOHSVq3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMTo0MDo0NlrOHSVq3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk5MTQ1Mw==", "bodyText": "@victoralfaro-dotcms here we use the following convention for the test javadoc:\n/**\n* Method to test: include this in case the method to test does not belong to the class this test-class is testing \n* Given Scenario: Scenario under test\n* ExpectedResult: Expected result that the assertion is checking against\n*\n*/", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488991453", "createdAt": "2020-09-15T21:40:46Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/quartz/job/IntegrityDataGenerationJobTest.java", "diffHunk": "@@ -0,0 +1,169 @@\n+package com.dotmarketing.quartz.job;\n+\n+import com.dotcms.IntegrationTestBase;\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.publisher.endpoint.bean.impl.PushPublishingEndPoint;\n+import com.dotcms.rest.IntegrityResource;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.exception.DotDataException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.quartz.JobDataMap;\n+import org.quartz.JobDetail;\n+import org.quartz.JobExecutionContext;\n+import org.quartz.SchedulerException;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * @author victor\n+ */\n+@RunWith(DataProviderRunner.class)\n+public class IntegrityDataGenerationJobTest extends IntegrationTestBase {\n+\n+    private IntegrityDataGenerationJob integrityDataGenerationJob;\n+    private PublishingEndPoint endpoint;\n+    private String requestId;\n+\n+    @BeforeClass\n+    public static void beforeClass() throws Exception {\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void before() throws DotDataException {\n+        integrityDataGenerationJob = new IntegrityDataGenerationJob();\n+        endpoint = new PushPublishingEndPoint();\n+        endpoint.setId(UUID.randomUUID().toString());\n+        requestId = UUID.randomUUID().toString();\n+\n+        DotConnect dotConnect = new DotConnect();\n+        dotConnect\n+                .setSQL(\"delete from QRTZ_EXCL_SIMPLE_TRIGGERS where TRIGGER_NAME = ? and TRIGGER_GROUP = ?\")\n+                .addParam(IntegrityDataGenerationJob.TRIGGER_NAME)\n+                .addParam(IntegrityDataGenerationJob.TRIGGER_GROUP)\n+                .loadObjectResults();\n+        dotConnect\n+                .setSQL(\"delete from QRTZ_EXCL_TRIGGERS where TRIGGER_NAME = ? and TRIGGER_GROUP = ?\")\n+                .addParam(IntegrityDataGenerationJob.TRIGGER_NAME)\n+                .addParam(IntegrityDataGenerationJob.TRIGGER_GROUP)\n+                .loadObjectResults();\n+        dotConnect\n+                .setSQL(\"delete from QRTZ_EXCL_JOB_DETAILS where JOB_NAME = ? and JOB_GROUP = ?\")\n+                .addParam(IntegrityDataGenerationJob.JOB_NAME)\n+                .addParam(IntegrityDataGenerationJob.JOB_GROUP)\n+                .loadObjectResults();\n+    }\n+\n+    @Test\n+    public void testGenerateIntegrationData() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3582e642600efd7982e82aef08539fcb17969afd"}, "originalPosition": 72}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MTMxNjg5", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-489131689", "createdAt": "2020-09-15T21:48:14Z", "commit": {"oid": "3582e642600efd7982e82aef08539fcb17969afd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMTo0ODoxNFrOHSWD0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMTo0ODoxNFrOHSWD0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk5Nzg0MA==", "bodyText": "good thing to rename the variable", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r488997840", "createdAt": "2020-09-15T21:48:14Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityUtil.java", "diffHunk": "@@ -243,83 +256,216 @@ public static void unzipFile(InputStream zipFile, String outputDir) throws Excep\n         }\n     }\n \n+    /**\n+     * Creates a String representing the integrity data path based on provided endpointId.\n+     *\n+     * @param endpointId endpoint if\n+     * @return integrity data path\n+     */\n+    public static String getIntegrityDataPath(final String endpointId) {\n+        return ConfigUtils.getIntegrityPath() + File.separator + endpointId;\n+    }\n+\n+    /**\n+     * Creates a String representing the integrity data file path based on provided endpointId and the file name.\n+     * File names to be used: DataToCheck.zip, DataToFix.zip and DataStatus.properties.\n+     *\n+     * @param endpointId endpoint gid\n+     * @param dataFile data filename\n+     * @return path to filename\n+     */\n+    public static String getIntegrityDataFile(final String endpointId, final String dataFile) {\n+        return getIntegrityDataPath(endpointId) + File.separator + dataFile;\n+    }\n+\n+    /**\n+     * Tells whether a integrity file exists based on provided endpointId and the file name.\n+     *\n+     * @param endpointId endpoint id\n+     * @param dataFile data filename\n+     * @return path to filename\n+     */\n+    public static boolean doesIntegrityDataFileExist(final String endpointId, final String dataFile) {\n+        return new File(getIntegrityDataFile(endpointId, dataFile)).exists();\n+    }\n+\n+    /**\n+     * Gets a {@link IntegrityDataExecutionMetadata} instance based on provided endpoint id which contains metadata of the\n+     * integrity data generation execution.\n+     *\n+     * @param endpointId endpoint id\n+     * @return Optional wrapping the integrity generation  metadata\n+     */\n+    public static Optional<IntegrityDataExecutionMetadata> getIntegrityMetadata(final String endpointId) {\n+        final File statusFile = new File(getIntegrityDataFile(endpointId, INTEGRITY_DATA_STATUS_FILENAME));\n+        if (!statusFile.exists()) {\n+            return Optional.empty();\n+        }\n+\n+        final Properties statusData = new Properties();\n+        try {\n+            statusData.load(new FileInputStream(statusFile));\n+        } catch (IOException e) {\n+            Logger.error(\n+                    IntegrityUtil.class,\n+                    String.format(\"Could load status from %s\", statusFile.getAbsolutePath()),\n+                    e);\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(new IntegrityDataExecutionMetadata(\n+                statusData.getProperty(REQUESTER_ENDPOINT),\n+                statusData.getProperty(INTEGRITY_DATA_REQUEST_ID),\n+                statusData.getProperty(INTEGRITY_DATA_STATUS),\n+                statusData.getProperty(INTEGRITY_DATA_ERROR_MESSAGE)));\n+    }\n+\n+    /**\n+     * Saves a integrity data generation metadata in a to-be-discovered location so it can be read by concurrent parts\n+     * that need to know what is the status of the integrity data generation.\n+     * The data is saved as {@link Properties} file.\n+     *\n+     * @param integrityDataExecutionMetadata execution metadata\n+     */\n+    private static void saveIntegrityDataStatus(IntegrityDataExecutionMetadata integrityDataExecutionMetadata) {\n+        final String endpointId = integrityDataExecutionMetadata.getEndpointId();\n+        final File integrityDir = new File(getIntegrityDataPath(endpointId));\n+        if (!integrityDir.exists()) {\n+            integrityDir.mkdir();\n+        }\n+\n+        final File statusFile = new File(getIntegrityDataFile(endpointId, INTEGRITY_DATA_STATUS_FILENAME));\n+        if (statusFile.exists()) {\n+            statusFile.delete();\n+        }\n+\n+        final Properties statusData = new Properties();\n+        final BiConsumer<String, String> addData = (data, name) -> {\n+            if (StringUtils.isNotBlank(data)) {\n+                statusData.setProperty(name, data);\n+            }\n+        };\n+\n+        addData.accept(endpointId, REQUESTER_ENDPOINT);\n+        addData.accept(integrityDataExecutionMetadata.getRequestId(), INTEGRITY_DATA_REQUEST_ID);\n+        statusData.setProperty(INTEGRITY_DATA_STATUS, integrityDataExecutionMetadata.getProcessStatus().toString().toUpperCase());\n+        addData.accept(integrityDataExecutionMetadata.getErrorMessage(), INTEGRITY_DATA_ERROR_MESSAGE);\n+\n+        try (FileOutputStream output = new FileOutputStream(statusFile)) {\n+            statusData.store(output, null);\n+        } catch (IOException e) {\n+            throw new DotExecutionException(\n+                    String.format(\"Could not save status to %s\", statusFile.getAbsolutePath()),\n+                    e);\n+        }\n+    }\n+\n+    /**\n+     * Saves a integrity data generation metadata in a to-be-discovered location so it can be read by concurrent parts\n+     * that need to know what is the status of the integrity data generation.\n+     * Individual parameters are used to create a {@link IntegrityDataExecutionMetadata}.\n+     *\n+     * @param endpointId endpoint id\n+     * @param requestId request id\n+     * @param processStatus {@link IntegrityResource.ProcessStatus} instance to reflect the current status\n+     * @param errorMessage error message associated to detected error\n+     */\n+    public static void saveIntegrityDataStatus(final String endpointId,\n+                                               final String requestId,\n+                                               final IntegrityResource.ProcessStatus processStatus,\n+                                               final String errorMessage) {\n+        saveIntegrityDataStatus(new IntegrityDataExecutionMetadata(endpointId, requestId, processStatus, errorMessage));\n+    }\n+\n+    /**\n+     * Saves a integrity data generation metadata in a to-be-discovered location so it can be read by concurrent parts\n+     * that need to know what is the status of the integrity data generation.\n+     * Individual parameters are used to create a {@link IntegrityDataExecutionMetadata}.\n+     *\n+     * @param endpointId endpoint id\n+     * @param requestId request id\n+     * @param processStatus {@link IntegrityResource.ProcessStatus} instance to reflect the current status\n+     */\n+    public static void saveIntegrityDataStatus(final String endpointId,\n+                                               final String requestId,\n+                                               final IntegrityResource.ProcessStatus processStatus) {\n+        saveIntegrityDataStatus(endpointId, requestId, processStatus, null);\n+    }\n+\n     /**\n      * Creates all the CSV from End Point database table and store them inside\n      * zip file.\n      *\n      * @param endpointId\n      * @throws Exception\n      */\n-    public void generateDataToCheckZip(String endpointId) throws Exception {\n-        File zipFile = null;\n-\n-        try {\n-            if (!UtilMethods.isSet(endpointId))\n-                return;\n-\n-            final String outputPath = ConfigUtils.getIntegrityPath() + File.separator + endpointId;\n+    public static void generateDataToCheckZip(final String endpointId) {\n+        if (!UtilMethods.isSet(endpointId)) {\n+            Logger.error(IntegrityUtil.class, \"Endpoint was not provided\");\n+            return;\n+        }\n \n-            File dir = new File(outputPath);\n+        Logger.info(\n+                IntegrityUtil.class,\n+                String.format(\"Starting integrity data generation job for endpoint %s\", endpointId));\n \n+        File zipFile = null;\n+        try {\n+            final String outputPath = getIntegrityDataPath(endpointId);\n+            final File dir = new File(outputPath);\n             // if file doesn't exist, create it\n             if (!dir.exists()) {\n                 dir.mkdir();\n             }\n \n-            zipFile = new File(outputPath + File.separator\n-                    + IntegrityResource.INTEGRITY_DATA_TO_CHECK_ZIP_FILE_NAME);\n-\n-            try (OutputStream os = Files.newOutputStream(zipFile.toPath());\n-                    ZipOutputStream zos = new ZipOutputStream(os)) {\n-                IntegrityType[] types = IntegrityType.values();\n+            zipFile = new File(getIntegrityDataFile(endpointId, INTEGRITY_DATA_TO_CHECK_ZIP_FILENAME));\n+            try(final OutputStream os = Files.newOutputStream(zipFile.toPath());\n+                final ZipOutputStream zos = new ZipOutputStream(os)) {\n+                final IntegrityType[] types = IntegrityType.values();\n                 for (IntegrityType integrityType : types) {\n                     File fileToCheckCsvFile = null;\n \n                     try {\n-                        fileToCheckCsvFile = integrityType.getIntegrityChecker()\n-                        \t\t.generateCSVFile(outputPath);\n-\n-                        addToZipFile(fileToCheckCsvFile.getAbsolutePath(), zos,\n-                                integrityType.getDataToCheckCSVName());\n+                        fileToCheckCsvFile = integrityType.getIntegrityChecker().generateCSVFile(outputPath);\n+                        addToZipFile(fileToCheckCsvFile.getAbsolutePath(), zos, integrityType.getDataToCheckCSVName());\n                     } finally {\n-                        if (fileToCheckCsvFile != null && fileToCheckCsvFile.exists())\n+                        if (fileToCheckCsvFile != null && fileToCheckCsvFile.exists()) {\n                             fileToCheckCsvFile.delete();\n+                        }\n                     }\n                 }\n             }\n         } catch (Exception e) {\n-            if (zipFile != null && zipFile.exists())\n+            if (zipFile != null && zipFile.exists()) {\n                 zipFile.delete();\n+            }\n \n-            throw new Exception(e);\n+            throw new DotExecutionException(e);\n         }\n     }\n \n-    public void generateDataToFixZip(String endpointId, IntegrityType type) {\n+    public void generateDataToFixZip(final String endpointId, final IntegrityType type) {\n+        if (!UtilMethods.isSet(endpointId)) {\n+            return;\n+        }\n+\n         File dataToFixCsvFile = null;\n         File zipFile = null;\n-\n         try {\n-            if (!UtilMethods.isSet(endpointId))\n-                return;\n-\n-            final String outputPath = ConfigUtils.getIntegrityPath() + File.separator + endpointId;\n-\n-            File dir = new File(outputPath);\n-\n+            final String outputPath = getIntegrityDataPath(endpointId);\n+            final File dir = new File(outputPath);\n             // if file doesn't exist, create it\n             if (!dir.exists()) {\n                 dir.mkdir();\n             }\n \n-            zipFile = new File(outputPath + File.separator\n-                    + IntegrityResource.INTEGRITY_DATA_TO_FIX_ZIP_FILE_NAME);\n-            try (OutputStream os = Files.newOutputStream(zipFile.toPath());\n-                    ZipOutputStream zos = new ZipOutputStream(os)) {\n+            zipFile = new File(getIntegrityDataFile(endpointId, INTEGRITY_DATA_TO_FIX_ZIP_FILENAME));\n+            try (OutputStream outputStream = Files.newOutputStream(zipFile.toPath());\n+                 ZipOutputStream zipOutputStream = new ZipOutputStream(outputStream)) {\n                 // create Folders CSV\n                 dataToFixCsvFile = generateDataToFixCSV(outputPath, endpointId, type);\n \n-                addToZipFile(dataToFixCsvFile.getAbsolutePath(), zos, type.getDataToFixCSVName());\n+                addToZipFile(dataToFixCsvFile.getAbsolutePath(), zipOutputStream, type.getDataToFixCSVName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3582e642600efd7982e82aef08539fcb17969afd"}, "originalPosition": 290}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MjcxNTQ1", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-489271545", "createdAt": "2020-09-16T04:55:07Z", "commit": {"oid": "19487250aaad39a2eb9e74175f2c6fa7a2c81682"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNDo1NTowN1rOHSgAwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNDo1NTowN1rOHSgAwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2MDg5Nw==", "bodyText": "this is a static method, not sure if the context annotation make sense here", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r489160897", "createdAt": "2020-09-16T04:55:07Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -153,68 +149,104 @@ private Response postWithEndpointState(String endpointId, String url, MediaType\n \t\treturn response;\n \t}\n \n+    /**\n+     * Resolves remote IP address from request.\n+     * @param request {@link HttpServletRequest}\n+     * @return a String representing the remote IP address (or hostname)\n+     */\n+    private static String resolveRemoteIp(@Context final HttpServletRequest request) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19487250aaad39a2eb9e74175f2c6fa7a2c81682"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5Mjc1NTY4", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-489275568", "createdAt": "2020-09-16T05:00:17Z", "commit": {"oid": "19487250aaad39a2eb9e74175f2c6fa7a2c81682"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNTowMDoxOFrOHSgL5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNTowMDoxOFrOHSgL5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTE2Mzc1MA==", "bodyText": "This method looks very bad I would separated in a new class as a Runnable and do some refactoring and transaction handling etc", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r489163750", "createdAt": "2020-09-16T05:00:18Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -373,81 +463,75 @@ public Response checkIntegrity(@Context HttpServletRequest httpServletRequest, @\n             return response( \"Error checking existence of integrity data\" , true );\n         }\n \n-        try {\n-\n-            //Setting the process status\n-            setStatus( httpServletRequest, endpointId, ProcessStatus.PROCESSING );\n+        //Setting the process status\n+        setStatus(httpServletRequest, endpointId, ProcessStatus.PROCESSING);\n \n+        try {\n             final PublishingEndPoint endpoint = APILocator.getPublisherEndPointAPI().findEndPointById(endpointId);\n             final Optional<String> authToken = PushPublisher.retriveEndpointKeyDigest(endpoint);\n-            if(!authToken.isPresent()) {\n+            if (!authToken.isPresent()) {\n               Logger.warn(IntegrityResource.class, \"No Auth Token set for endpoint:\" + endpointId);\n               return response(\"No Auth Token set for endpoint\", true);\n             }\n-            FormDataMultiPart form = new FormDataMultiPart();\n-            form.field(\"AUTH_TOKEN\",authToken.get());\n \n-            //Sending bundle to endpoint\n-            String url = endpoint.toURL()+\"/api/integrity/generateintegritydata/\";\n+            final FormDataMultiPart form = new FormDataMultiPart();\n+            form.field(\"AUTH_TOKEN\", authToken.get());\n \n-            Response response = postWithEndpointState(\n-            \tendpoint.getId(), url, MediaType.TEXT_PLAIN_TYPE, Entity.entity(form, form.getMediaType())\n+            //Sending bundle to endpoint\n+            final String url = endpoint.toURL() + \"/api/integrity/generateintegritydata/\";\n+            final Response response = postWithEndpointState(\n+                    endpoint.getId(),\n+                    url,\n+                    MediaType.TEXT_PLAIN_TYPE,\n+                    Entity.entity(form, form.getMediaType())\n             );\n \n-            if(response.getStatus() == HttpStatus.SC_OK) {\n+            if (response.getStatus() == HttpStatus.SC_OK) {\n                 final String integrityDataRequestID = response.readEntity(String.class);\n-\n-                Thread integrityDataRequestChecker = new Thread() {\n-\n+                final Thread integrityDataRequestChecker = new Thread() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19487250aaad39a2eb9e74175f2c6fa7a2c81682"}, "originalPosition": 500}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9865ac6a852d8fe87bcbaee6cd80ebf8933d1a1e", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/9865ac6a852d8fe87bcbaee6cd80ebf8933d1a1e", "committedDate": "2020-09-17T14:24:43Z", "message": "test"}, "afterCommit": {"oid": "39039e53e5d35451c7a80124eb3f009b92860481", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/39039e53e5d35451c7a80124eb3f009b92860481", "committedDate": "2020-09-17T21:28:47Z", "message": "Attempt to fix integration test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "380e059dcd1202c2d721c2b3ae8e10d2bce152f1", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/380e059dcd1202c2d721c2b3ae8e10d2bce152f1", "committedDate": "2020-09-17T21:49:50Z", "message": "18554: Introducing IntegritiGenerationDataJob to support multi node receivers creation of file and query process for status"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f44d02fac21853b75748443f26618c48ad12f42", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/2f44d02fac21853b75748443f26618c48ad12f42", "committedDate": "2020-09-17T21:52:31Z", "message": "Applying codacy feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "39039e53e5d35451c7a80124eb3f009b92860481", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/39039e53e5d35451c7a80124eb3f009b92860481", "committedDate": "2020-09-17T21:28:47Z", "message": "Attempt to fix integration test"}, "afterCommit": {"oid": "506d9fdd15d52dec15f170deb09a0f97f85f3fb3", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/506d9fdd15d52dec15f170deb09a0f97f85f3fb3", "committedDate": "2020-09-17T21:52:35Z", "message": "Applying more feedback\n\nAttempt to fix integration test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "506d9fdd15d52dec15f170deb09a0f97f85f3fb3", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/506d9fdd15d52dec15f170deb09a0f97f85f3fb3", "committedDate": "2020-09-17T21:52:35Z", "message": "Applying more feedback\n\nAttempt to fix integration test"}, "afterCommit": {"oid": "06afc2bc1630fc6c8d3a16d314bddf753f0a1a2f", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/06afc2bc1630fc6c8d3a16d314bddf753f0a1a2f", "committedDate": "2020-09-17T22:22:51Z", "message": "Applying more feedback\n\nAttempt to fix integration test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "06afc2bc1630fc6c8d3a16d314bddf753f0a1a2f", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/06afc2bc1630fc6c8d3a16d314bddf753f0a1a2f", "committedDate": "2020-09-17T22:22:51Z", "message": "Applying more feedback\n\nAttempt to fix integration test"}, "afterCommit": {"oid": "69d6e4a25b1ffd22ecd1778d0921b94494530d94", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/69d6e4a25b1ffd22ecd1778d0921b94494530d94", "committedDate": "2020-09-18T01:58:18Z", "message": "Applying more feedback\n\nAttempt to fix integration test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "69d6e4a25b1ffd22ecd1778d0921b94494530d94", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/69d6e4a25b1ffd22ecd1778d0921b94494530d94", "committedDate": "2020-09-18T01:58:18Z", "message": "Applying more feedback\n\nAttempt to fix integration test"}, "afterCommit": {"oid": "823395c96667b62ed06c7a6d91c7c5575a4af002", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/823395c96667b62ed06c7a6d91c7c5575a4af002", "committedDate": "2020-09-18T02:55:47Z", "message": "Applying more feedback\n\nAttempt to fix integration test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2615465da169dc121d453829b52538c2bf3f3c2", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/a2615465da169dc121d453829b52538c2bf3f3c2", "committedDate": "2020-09-18T13:56:33Z", "message": "Applying more feedback\n\nAttempt to fix integration test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "823395c96667b62ed06c7a6d91c7c5575a4af002", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/823395c96667b62ed06c7a6d91c7c5575a4af002", "committedDate": "2020-09-18T02:55:47Z", "message": "Applying more feedback\n\nAttempt to fix integration test"}, "afterCommit": {"oid": "a2615465da169dc121d453829b52538c2bf3f3c2", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/a2615465da169dc121d453829b52538c2bf3f3c2", "committedDate": "2020-09-18T13:56:33Z", "message": "Applying more feedback\n\nAttempt to fix integration test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ac298d325841b015d9827ab6f8ef76ae70db83b6", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/ac298d325841b015d9827ab6f8ef76ae70db83b6", "committedDate": "2020-09-18T18:12:54Z", "message": "Fix of tests"}, "afterCommit": {"oid": "27f755491956ce8c6f990869e5a2013e8af4d886", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/27f755491956ce8c6f990869e5a2013e8af4d886", "committedDate": "2020-09-18T20:17:46Z", "message": "Fix broken of tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a27c0efc8d35b3952112e417badb6159f0595c9a", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/a27c0efc8d35b3952112e417badb6159f0595c9a", "committedDate": "2020-09-18T22:48:50Z", "message": "Fix broken of tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "27f755491956ce8c6f990869e5a2013e8af4d886", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/27f755491956ce8c6f990869e5a2013e8af4d886", "committedDate": "2020-09-18T20:17:46Z", "message": "Fix broken of tests"}, "afterCommit": {"oid": "a27c0efc8d35b3952112e417badb6159f0595c9a", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/a27c0efc8d35b3952112e417badb6159f0595c9a", "committedDate": "2020-09-18T22:48:50Z", "message": "Fix broken of tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNzUyOTQx", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492752941", "createdAt": "2020-09-21T15:48:36Z", "commit": {"oid": "a27c0efc8d35b3952112e417badb6159f0595c9a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo0ODozN1rOHVXdFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo0ODozN1rOHVXdFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjQyMA==", "bodyText": "we should annotate IntegrityUtil.completeDiscardConflicts as @WrapInTransaction", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492166420", "createdAt": "2020-09-21T15:48:37Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityDataRequestChecker.java", "diffHunk": "@@ -0,0 +1,188 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.repackage.org.apache.commons.httpclient.HttpStatus;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotHibernateException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.media.multipart.FormDataMultiPart;\n+\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+/**\n+ * Thread to constantly check the integrity check status by hitting on receiver host endpoint.\n+ * Anything but {@link com.dotcms.rest.IntegrityResource.ProcessStatus}.PROCESSING is considered that the integrity data\n+ * generation process is done.\n+ */\n+public class IntegrityDataRequestChecker implements Runnable {\n+\n+    private final String authToken;\n+    private final PublishingEndPoint endpoint;\n+    private final String integrityDataRequestId;\n+    private final HttpSession session;\n+    private final InitDataObject initData;\n+\n+    public IntegrityDataRequestChecker(String authToken,\n+                                       PublishingEndPoint endpoint,\n+                                       String integrityDataRequestId,\n+                                       HttpSession session,\n+                                       InitDataObject initData) {\n+        this.authToken = authToken;\n+        this.endpoint = endpoint;\n+        this.integrityDataRequestId = integrityDataRequestId;\n+        this.session = session;\n+        this.initData = initData;\n+    }\n+\n+    @Override\n+    public void run() {\n+        final Map<String, String> paramsMap = initData.getParamsMap();\n+        final String endpointId = paramsMap.get(\"endpoint\");\n+        final User loggedUser = initData.getUser();\n+        final FormDataMultiPart form = new FormDataMultiPart();\n+        form.field(\"AUTH_TOKEN\",authToken);\n+        form.field(\"REQUEST_ID\", integrityDataRequestId);\n+        final String url = endpoint.toURL() + \"/api/integrity/getintegritydata/\";\n+\n+        boolean processing = true;\n+        while(processing) {\n+            final Response response = IntegrityResource.postWithEndpointState(\n+                    endpoint.getId(),\n+                    url,\n+                    new MediaType(\"application\", \"zip\"),\n+                    Entity.entity(form, form.getMediaType()));\n+\n+            if (response.getStatus() == HttpStatus.SC_OK) {\n+                processing = false;\n+\n+                final String outputDir = IntegrityUtil.getIntegrityDataPath(endpoint.getId());\n+                final InputStream zipFile = response.readEntity(InputStream.class);\n+\n+                try {\n+                    IntegrityUtil.unzipFile(zipFile, outputDir);\n+                } catch(Exception e) {\n+                    //Special handling if the thread was interrupted\n+                    if (e instanceof InterruptedException) {\n+                        //Setting the process status\n+                        IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.CANCELLED, null);\n+                        final String message = \"Requested interruption of the integrity checking process [unzipping Integrity Data] by the user.\";\n+                        Logger.debug(IntegrityResource.class, message, e);\n+                        throw new RuntimeException(message, e);\n+                    }\n+\n+                    //Setting the process status\n+                    IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.ERROR, null);\n+                    final String message = \"Error while unzipping Integrity Data\";\n+                    Logger.error(IntegrityResource.class, message, e);\n+                    throw new RuntimeException(message, e);\n+                } finally {\n+                    if (zipFile != null) {\n+                        try {\n+                            zipFile.close();\n+                        } catch ( IOException e ) {\n+                            Logger.warn(IntegrityResource.class, \"Error closing zip file stream\", e);\n+                        }\n+                    }\n+                }\n+\n+                // set session variable\n+                // call IntegrityChecker\n+                boolean conflictPresent ;\n+                try {\n+                    HibernateUtil.startTransaction();\n+                    IntegrityUtil.completeDiscardConflicts(endpointId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27c0efc8d35b3952112e417badb6159f0595c9a"}, "originalPosition": 104}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyNzUzMDcx", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492753071", "createdAt": "2020-09-21T15:48:45Z", "commit": {"oid": "a27c0efc8d35b3952112e417badb6159f0595c9a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo0ODo0NVrOHVXdhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNTo0ODo0NVrOHVXdhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2NjUzMw==", "bodyText": "we should annotate IntegrityUtil.completeDiscardConflicts as @WrapInTransaction", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492166533", "createdAt": "2020-09-21T15:48:45Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityDataRequestChecker.java", "diffHunk": "@@ -0,0 +1,188 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.repackage.org.apache.commons.httpclient.HttpStatus;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotHibernateException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.media.multipart.FormDataMultiPart;\n+\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+/**\n+ * Thread to constantly check the integrity check status by hitting on receiver host endpoint.\n+ * Anything but {@link com.dotcms.rest.IntegrityResource.ProcessStatus}.PROCESSING is considered that the integrity data\n+ * generation process is done.\n+ */\n+public class IntegrityDataRequestChecker implements Runnable {\n+\n+    private final String authToken;\n+    private final PublishingEndPoint endpoint;\n+    private final String integrityDataRequestId;\n+    private final HttpSession session;\n+    private final InitDataObject initData;\n+\n+    public IntegrityDataRequestChecker(String authToken,\n+                                       PublishingEndPoint endpoint,\n+                                       String integrityDataRequestId,\n+                                       HttpSession session,\n+                                       InitDataObject initData) {\n+        this.authToken = authToken;\n+        this.endpoint = endpoint;\n+        this.integrityDataRequestId = integrityDataRequestId;\n+        this.session = session;\n+        this.initData = initData;\n+    }\n+\n+    @Override\n+    public void run() {\n+        final Map<String, String> paramsMap = initData.getParamsMap();\n+        final String endpointId = paramsMap.get(\"endpoint\");\n+        final User loggedUser = initData.getUser();\n+        final FormDataMultiPart form = new FormDataMultiPart();\n+        form.field(\"AUTH_TOKEN\",authToken);\n+        form.field(\"REQUEST_ID\", integrityDataRequestId);\n+        final String url = endpoint.toURL() + \"/api/integrity/getintegritydata/\";\n+\n+        boolean processing = true;\n+        while(processing) {\n+            final Response response = IntegrityResource.postWithEndpointState(\n+                    endpoint.getId(),\n+                    url,\n+                    new MediaType(\"application\", \"zip\"),\n+                    Entity.entity(form, form.getMediaType()));\n+\n+            if (response.getStatus() == HttpStatus.SC_OK) {\n+                processing = false;\n+\n+                final String outputDir = IntegrityUtil.getIntegrityDataPath(endpoint.getId());\n+                final InputStream zipFile = response.readEntity(InputStream.class);\n+\n+                try {\n+                    IntegrityUtil.unzipFile(zipFile, outputDir);\n+                } catch(Exception e) {\n+                    //Special handling if the thread was interrupted\n+                    if (e instanceof InterruptedException) {\n+                        //Setting the process status\n+                        IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.CANCELLED, null);\n+                        final String message = \"Requested interruption of the integrity checking process [unzipping Integrity Data] by the user.\";\n+                        Logger.debug(IntegrityResource.class, message, e);\n+                        throw new RuntimeException(message, e);\n+                    }\n+\n+                    //Setting the process status\n+                    IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.ERROR, null);\n+                    final String message = \"Error while unzipping Integrity Data\";\n+                    Logger.error(IntegrityResource.class, message, e);\n+                    throw new RuntimeException(message, e);\n+                } finally {\n+                    if (zipFile != null) {\n+                        try {\n+                            zipFile.close();\n+                        } catch ( IOException e ) {\n+                            Logger.warn(IntegrityResource.class, \"Error closing zip file stream\", e);\n+                        }\n+                    }\n+                }\n+\n+                // set session variable\n+                // call IntegrityChecker\n+                boolean conflictPresent ;\n+                try {\n+                    HibernateUtil.startTransaction();\n+                    IntegrityUtil.completeDiscardConflicts(endpointId);\n+                    HibernateUtil.commitTransaction();\n+\n+                    HibernateUtil.startTransaction();\n+                    conflictPresent = IntegrityUtil.completeCheckIntegrity(endpointId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a27c0efc8d35b3952112e417badb6159f0595c9a"}, "originalPosition": 108}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3732e947085bd528c7950a2fbd8153b17d71324d", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/3732e947085bd528c7950a2fbd8153b17d71324d", "committedDate": "2020-09-21T16:24:39Z", "message": "Replacing manual transaction handling by @WrapInTransaction"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3", "author": {"user": {"login": "victoralfaro-dotcms", "name": "Victor Alfaro"}}, "url": "https://github.com/dotCMS/core/commit/bec50a104819f020e85de9a754b814af4422bed3", "committedDate": "2020-09-21T16:26:19Z", "message": "Replacing manual transaction handling by @WrapInTransaction"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODI1MDI4", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492825028", "createdAt": "2020-09-21T17:19:11Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxMVrOHVa5Hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxMVrOHVa5Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjc1MA==", "bodyText": "Codacy found an issue: Avoid instantiating FileInputStream, FileOutputStream, FileReader, or FileWriter", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222750", "createdAt": "2020-09-21T17:19:11Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/quartz/job/IntegrityDataGenerationJobTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.dotmarketing.quartz.job;\n+\n+import com.dotcms.IntegrationTestBase;\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.publisher.endpoint.bean.impl.PushPublishingEndPoint;\n+import com.dotcms.rest.IntegrityResource;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.exception.DotDataException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.quartz.JobDataMap;\n+import org.quartz.JobDetail;\n+import org.quartz.JobExecutionContext;\n+import org.quartz.SchedulerException;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * @author victor\n+ */\n+@RunWith(DataProviderRunner.class)\n+public class IntegrityDataGenerationJobTest extends IntegrationTestBase {\n+\n+    private IntegrityDataGenerationJob integrityDataGenerationJob;\n+    private PublishingEndPoint endpoint;\n+    private String requestId;\n+\n+    @BeforeClass\n+    public static void beforeClass() throws Exception {\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void before() throws DotDataException {\n+        integrityDataGenerationJob = new IntegrityDataGenerationJob();\n+        endpoint = new PushPublishingEndPoint();\n+        endpoint.setId(UUID.randomUUID().toString());\n+        requestId = UUID.randomUUID().toString();\n+\n+        DotConnect dotConnect = new DotConnect();\n+        dotConnect\n+                .setSQL(\"delete from QRTZ_EXCL_SIMPLE_TRIGGERS where TRIGGER_NAME = ? and TRIGGER_GROUP = ?\")\n+                .addParam(IntegrityDataGenerationJob.TRIGGER_NAME)\n+                .addParam(IntegrityDataGenerationJob.TRIGGER_GROUP)\n+                .loadObjectResults();\n+        dotConnect\n+                .setSQL(\"delete from QRTZ_EXCL_TRIGGERS where TRIGGER_NAME = ? and TRIGGER_GROUP = ?\")\n+                .addParam(IntegrityDataGenerationJob.TRIGGER_NAME)\n+                .addParam(IntegrityDataGenerationJob.TRIGGER_GROUP)\n+                .loadObjectResults();\n+        dotConnect\n+                .setSQL(\"delete from QRTZ_EXCL_JOB_DETAILS where JOB_NAME = ? and JOB_GROUP = ?\")\n+                .addParam(IntegrityDataGenerationJob.JOB_NAME)\n+                .addParam(IntegrityDataGenerationJob.JOB_GROUP)\n+                .loadObjectResults();\n+    }\n+\n+    /**\n+     * Method to test: IntegrityDataGenerationJob.run() which generates integrity data generation.\n+     * Given Scenario: Given an integrity data generation is triggered for a provided endpoint and request id.\n+     * ExpectedResult: to have Quartz job tables populated as well as the integrity data file created with its status file.\n+     *\n+     */\n+    @Test\n+    public void test_generateIntegrationData() throws Exception {\n+        runJob(Sneaky.sneaked(() -> integrityDataGenerationJob.run(getJobContext())));\n+\n+        assertTrue(new File(\n+                IntegrityUtil.getIntegrityDataFilePath(\n+                        endpoint.getId(),\n+                        IntegrityUtil.INTEGRITY_DATA_TO_CHECK_ZIP_FILENAME))\n+                .exists());\n+        assertTrue(new File(\n+                IntegrityUtil.getIntegrityDataFilePath(endpoint.getId(), IntegrityUtil.INTEGRITY_DATA_STATUS_FILENAME))\n+                .exists());\n+        assertStatus(IntegrityResource.ProcessStatus.FINISHED.toString());\n+    }\n+\n+    /**\n+     * Method to test: IntegrityDataGenerationJob.interrupt() which is run when job is attempted to be interrupted.\n+     * Given Scenario: Given an integrity data generation is triggered and running for a provided endpoint and request id.\n+     * ExpectedResult: to have a status file with the CANCELLED status.\n+     *\n+     */\n+    @Test\n+    public void test_interrupt() throws Exception {\n+        integrityDataGenerationJob = new IntegrityDataGenerationJob() {\n+            @Override\n+            public void run(JobExecutionContext jobContext) {\n+                try {\n+                    Thread.sleep(4000);\n+                } catch (InterruptedException e) {}\n+                super.run(jobContext);\n+            }\n+        };\n+\n+        runJob(Sneaky.sneaked(() -> integrityDataGenerationJob.run(getJobContext())));\n+        interruptJob(Sneaky.sneaked(() -> integrityDataGenerationJob.interrupt()));\n+        assertStatus(\n+                IntegrityResource.ProcessStatus.CANCELLED.name(),\n+                IntegrityResource.ProcessStatus.FINISHED.name());\n+    }\n+\n+    private void runJob(Runnable runnable) {\n+        runnable.run();\n+    }\n+\n+    private void interruptJob(Runnable runnable) throws SchedulerException {\n+        IntegrityDataGenerationJob.getJobScheduler().interrupt(\n+                IntegrityDataGenerationJob.JOB_NAME,\n+                IntegrityDataGenerationJob.JOB_GROUP);\n+        runnable.run();\n+    }\n+\n+    private JobExecutionContext getJobContext() throws SchedulerException {\n+        return new JobExecutionContext(\n+                IntegrityDataGenerationJob.getJobScheduler(),\n+                new TestJobExecutor.TriggerFiredBundleTest(getJobDetail(endpoint, requestId)),\n+                integrityDataGenerationJob);\n+    }\n+\n+    private JobDetail getJobDetail(PublishingEndPoint endpoint, String requestId) {\n+        JobDataMap jobDataMap = new JobDataMap();\n+        jobDataMap.put(IntegrityUtil.REQUESTER_ENDPOINT, endpoint);\n+        jobDataMap.put(IntegrityUtil.INTEGRITY_DATA_REQUEST_ID, requestId);\n+\n+        final JobDetail jobDetail = new JobDetail(\n+                IntegrityDataGenerationJob.JOB_NAME,\n+                IntegrityDataGenerationJob.JOB_GROUP, IntegrityDataGenerationJob.class);\n+        jobDetail.setJobDataMap(jobDataMap);\n+        jobDetail.setDurability(false);\n+        jobDetail.setVolatility(false);\n+        jobDetail.setRequestsRecovery(true);\n+\n+        return jobDetail;\n+    }\n+\n+    private void assertStatus(String status) throws IOException {\n+        Properties properties = new Properties();\n+        properties.load(new FileInputStream(IntegrityUtil.getIntegrityDataFilePath(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODI1MDM4", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492825038", "createdAt": "2020-09-21T17:19:12Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxMlrOHVa5KA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxMlrOHVa5KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjc2MA==", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222760", "createdAt": "2020-09-21T17:19:12Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/quartz/job/IntegrityDataGenerationJobTest.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package com.dotmarketing.quartz.job;\n+\n+import com.dotcms.IntegrationTestBase;\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.publisher.endpoint.bean.impl.PushPublishingEndPoint;\n+import com.dotcms.rest.IntegrityResource;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.common.db.DotConnect;\n+import com.dotmarketing.exception.DotDataException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import com.tngtech.java.junit.dataprovider.DataProviderRunner;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.quartz.JobDataMap;\n+import org.quartz.JobDetail;\n+import org.quartz.JobExecutionContext;\n+import org.quartz.SchedulerException;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import java.util.UUID;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * @author victor\n+ */\n+@RunWith(DataProviderRunner.class)\n+public class IntegrityDataGenerationJobTest extends IntegrationTestBase {\n+\n+    private IntegrityDataGenerationJob integrityDataGenerationJob;\n+    private PublishingEndPoint endpoint;\n+    private String requestId;\n+\n+    @BeforeClass\n+    public static void beforeClass() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODI1MDU1", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492825055", "createdAt": "2020-09-21T17:19:13Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxM1rOHVa5Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxM1rOHVa5Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjc3OA==", "bodyText": "Codacy found an issue: Classes implementing Serializable should set a serialVersionUID", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222778", "createdAt": "2020-09-21T17:19:13Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityUtil.java", "diffHunk": "@@ -625,4 +792,50 @@ public boolean completeCheckIntegrity(final String endpointId) throws Exception\n \n         return existConflicts;\n     }\n+\n+    /**\n+     * Integrity data generation metadata bean to be saved.\n+     */\n+    public static class IntegrityDataExecutionMetadata implements Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "originalPosition": 368}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODI1MDcx", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492825071", "createdAt": "2020-09-21T17:19:14Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxNFrOHVa5SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxNFrOHVa5SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjc5Mg==", "bodyText": "Codacy found an issue: Avoid throwing raw exception types.", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222792", "createdAt": "2020-09-21T17:19:14Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityDataRequestChecker.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.repackage.org.apache.commons.httpclient.HttpStatus;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotHibernateException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.media.multipart.FormDataMultiPart;\n+\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+/**\n+ * Thread to constantly check the integrity check status by hitting on receiver host endpoint.\n+ * Anything but {@link com.dotcms.rest.IntegrityResource.ProcessStatus}.PROCESSING is considered that the integrity data\n+ * generation process is done.\n+ */\n+public class IntegrityDataRequestChecker implements Runnable {\n+\n+    private final String authToken;\n+    private final PublishingEndPoint endpoint;\n+    private final String integrityDataRequestId;\n+    private final HttpSession session;\n+    private final InitDataObject initData;\n+\n+    public IntegrityDataRequestChecker(String authToken,\n+                                       PublishingEndPoint endpoint,\n+                                       String integrityDataRequestId,\n+                                       HttpSession session,\n+                                       InitDataObject initData) {\n+        this.authToken = authToken;\n+        this.endpoint = endpoint;\n+        this.integrityDataRequestId = integrityDataRequestId;\n+        this.session = session;\n+        this.initData = initData;\n+    }\n+\n+    @Override\n+    public void run() {\n+        final Map<String, String> paramsMap = initData.getParamsMap();\n+        final String endpointId = paramsMap.get(\"endpoint\");\n+        final User loggedUser = initData.getUser();\n+        final FormDataMultiPart form = new FormDataMultiPart();\n+        form.field(\"AUTH_TOKEN\",authToken);\n+        form.field(\"REQUEST_ID\", integrityDataRequestId);\n+        final String url = endpoint.toURL() + \"/api/integrity/getintegritydata/\";\n+\n+        boolean processing = true;\n+        while(processing) {\n+            final Response response = IntegrityResource.postWithEndpointState(\n+                    endpoint.getId(),\n+                    url,\n+                    new MediaType(\"application\", \"zip\"),\n+                    Entity.entity(form, form.getMediaType()));\n+\n+            if (response.getStatus() == HttpStatus.SC_OK) {\n+                processing = false;\n+\n+                final String outputDir = IntegrityUtil.getIntegrityDataPath(endpoint.getId());\n+                final InputStream zipFile = response.readEntity(InputStream.class);\n+\n+                try {\n+                    IntegrityUtil.unzipFile(zipFile, outputDir);\n+                } catch(Exception e) {\n+                    //Special handling if the thread was interrupted\n+                    if (e instanceof InterruptedException) {\n+                        //Setting the process status\n+                        IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.CANCELLED, null);\n+                        final String message = \"Requested interruption of the integrity checking process [unzipping Integrity Data] by the user.\";\n+                        Logger.debug(IntegrityResource.class, message, e);\n+                        throw new RuntimeException(message, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODI1MDgy", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492825082", "createdAt": "2020-09-21T17:19:15Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxNVrOHVa5Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxNVrOHVa5Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjc5OQ==", "bodyText": "Codacy found an issue: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222799", "createdAt": "2020-09-21T17:19:15Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityUtil.java", "diffHunk": "@@ -614,7 +780,8 @@ public void completeDiscardConflicts(final String endpointId) throws DotDataExce\n      * @return is there is at least one conflict returns true, otherwise false\n      * @throws Exception\n      */\n-    public boolean completeCheckIntegrity(final String endpointId) throws Exception {\n+    @WrapInTransaction\n+    public static boolean completeCheckIntegrity(final String endpointId) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "originalPosition": 356}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODI1MDk4", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492825098", "createdAt": "2020-09-21T17:19:16Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxNlrOHVa5Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxNlrOHVa5Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjgxMQ==", "bodyText": "Codacy found an issue: The String literal \"params\" appears 6 times in this file; the first occurrence is on line 328", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222811", "createdAt": "2020-09-21T17:19:16Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -332,38 +421,37 @@ public void write(OutputStream output) throws IOException, WebApplicationExcepti\n     @GET\n     @Path(\"/checkintegrity/{params:.*}\")\n     @Produces (MediaType.APPLICATION_JSON)\n-    public Response checkIntegrity(@Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam(\"params\") String params)  {\n-        InitDataObject initData = webResource.init(params, httpServletRequest, httpServletResponse, true, null);\n-\n-        Map<String, String> paramsMap = initData.getParamsMap();\n-\n+    public Response checkIntegrity(@Context final HttpServletRequest httpServletRequest,\n+                                   @Context final HttpServletResponse httpServletResponse,\n+                                   @PathParam(\"params\") final String params)  {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "originalPosition": 446}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODI1MTEz", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492825113", "createdAt": "2020-09-21T17:19:17Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxN1rOHVa5aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxN1rOHVa5aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjgyNA==", "bodyText": "Codacy found an issue: [The String literal \"Error checking the integrity process status for End Point server: \" appears 5 times in this file; the first occurrence is on line 667", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222824", "createdAt": "2020-09-21T17:19:17Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -570,98 +556,104 @@ public void run(){\n     @GET\n     @Path (\"/cancelIntegrityProcess/{params:.*}\")\n     @Produces (MediaType.APPLICATION_JSON)\n-    public Response cancelIntegrityProcess ( @Context HttpServletRequest httpServletRequest, @Context final HttpServletResponse httpServletResponse, @PathParam (\"params\") String params ) throws JSONException {\n-\n-        StringBuilder responseMessage = new StringBuilder();\n-\n-        InitDataObject initData = webResource.init(params, httpServletRequest, httpServletResponse, true, null);\n-        Map<String, String> paramsMap = initData.getParamsMap();\n+    public Response cancelIntegrityProcess(@Context final HttpServletRequest httpServletRequest,\n+                                           @Context final HttpServletResponse httpServletResponse,\n+                                           @PathParam(\"params\") final String params ) {\n+        final StringBuilder responseMessage = new StringBuilder();\n+        final InitDataObject initData = webResource.init(params, httpServletRequest, httpServletResponse, true, null);\n+        final Map<String, String> paramsMap = initData.getParamsMap();\n \n         //Validate the parameters\n-        String endpointId = paramsMap.get( \"endpoint\" );\n-        if ( !UtilMethods.isSet( endpointId ) ) {\n-            Response.ResponseBuilder responseBuilder = Response.status( HttpStatus.SC_BAD_REQUEST );\n-            responseBuilder.entity( responseMessage.append( \"Error: \" ).append( \"endpoint\" ).append( \" is a required Field.\" ) );\n-\n+        final String endpointId = paramsMap.get(\"endpoint\");\n+        if (!UtilMethods.isSet(endpointId)) {\n+            final Response.ResponseBuilder responseBuilder = Response.status(HttpStatus.SC_BAD_REQUEST);\n+            responseBuilder.entity(responseMessage.append(\"Error: endpoint is a required Field.\"));\n             return responseBuilder.build();\n         }\n \n         try {\n-            JSONObject jsonResponse = new JSONObject();\n+            final JSONObject jsonResponse = new JSONObject();\n+            final HttpSession session = httpServletRequest.getSession();\n \n-            HttpSession session = httpServletRequest.getSession();\n             //Verify if we have something set on the session\n             if ( session.getAttribute( \"integrityCheck_\" + endpointId ) == null ) {\n                 //And prepare the response\n-                jsonResponse.put( \"success\", false );\n-                jsonResponse.put( \"message\", \"No checking process found for End point server [\" + endpointId + \"]\" );\n-            } else if ( session.getAttribute( \"integrityThread_\" + endpointId ) == null ) {\n+                jsonResponse.put(\"success\", false);\n+                jsonResponse.put(\"message\", \"No checking process found for End point server [\" + endpointId + \"]\");\n+            } else if (session.getAttribute(\"integrityThread_\" + endpointId) == null) {\n                 //And prepare the response\n-                jsonResponse.put( \"success\", false );\n-                jsonResponse.put( \"message\", \"No checking process found for End point server [\" + endpointId + \"]\" );\n+                jsonResponse.put(\"success\", false);\n+                jsonResponse.put(\"message\", \"No checking process found for End point server [\" + endpointId + \"]\");\n             } else {\n-\n                 //Search for the status on session\n-                ProcessStatus status = (ProcessStatus) session.getAttribute( \"integrityCheck_\" + endpointId );\n+                final ProcessStatus status = (ProcessStatus) session.getAttribute(\"integrityCheck_\" + endpointId);\n \n                 //And prepare the response\n-                jsonResponse.put( \"endPoint\", endpointId );\n-                if ( status == ProcessStatus.PROCESSING ) {\n-\n-                    //Get the thread associated to this endpoint and the integrity request id\n-                    Thread runningThread = (Thread) session.getAttribute( \"integrityThread_\" + endpointId );\n-                    String integrityDataRequestId = (String) session.getAttribute( \"integrityDataRequest_\" + endpointId );\n-\n+                jsonResponse.put(\"endPoint\", endpointId);\n+                if (status == ProcessStatus.PROCESSING) {\n                     //Find the registered auth token in order to connect to the end point server\n-                    PublishingEndPoint endpoint = APILocator.getPublisherEndPointAPI().findEndPointById( endpointId );\n-                    Optional<String> authToken = PushPublisher.retriveEndpointKeyDigest(endpoint);\n+                    final PublishingEndPoint endpoint = APILocator.getPublisherEndPointAPI().findEndPointById(endpointId);\n+                    final Optional<String> authToken = PushPublisher.retriveEndpointKeyDigest(endpoint);\n                     if(!authToken.isPresent()) {\n-                      return Response.status( HttpStatus.SC_BAD_REQUEST )\n-                          .entity( responseMessage.append( \"Error: endpoint requires an authorization key\" ) ).build();\n-\n+                        return Response\n+                                .status(HttpStatus.SC_BAD_REQUEST)\n+                                .entity(responseMessage.append(\"Error: endpoint requires an authorization key\"))\n+                                .build();\n                     }\n-                    FormDataMultiPart form = new FormDataMultiPart();\n-                    form.field( \"AUTH_TOKEN\", authToken.get() );\n-                    form.field( \"REQUEST_ID\", integrityDataRequestId );\n \n+                    final String integrityDataRequestId = (String) session.getAttribute( \"integrityDataRequest_\" + endpointId );\n+                    final FormDataMultiPart form = new FormDataMultiPart();\n+                    form.field(\"AUTH_TOKEN\", authToken.get());\n+                    form.field(\"REQUEST_ID\", integrityDataRequestId);\n                     //Prepare the connection\n-                    String url = endpoint.toURL() + \"/api/integrity/cancelIntegrityProcessOnEndpoint/\";\n-\n+                    final String url = endpoint.toURL() + \"/api/integrity/cancelIntegrityProcessOnEndpoint/\";\n                     //Execute the call\n-                \tResponse response = postWithEndpointState(\n-                \t\tendpoint.getId(), url, MediaType.APPLICATION_JSON_TYPE, Entity.entity(form, form.getMediaType())\n-                \t);\n+                    final Response response = postWithEndpointState(\n+                            endpoint.getId(),\n+                            url,\n+                            MediaType.APPLICATION_JSON_TYPE,\n+                            Entity.entity(form, form.getMediaType()));\n \n-                    if ( response.getStatus() == HttpStatus.SC_OK ) {\n+                    if (response.getStatus() == HttpStatus.SC_OK) {\n                         //Nothing to do here, we found no process to cancel\n-                    } else if ( response.getStatus() == HttpStatus.SC_RESET_CONTENT ) {\n+                    } else if (response.getStatus() == HttpStatus.SC_RESET_CONTENT) {\n                         //Expected return status if a cancel was made on the end point server\n                     } else {\n-                        Logger.error( this.getClass(), \"Response indicating a \" + response.getStatusInfo().getReasonPhrase() + \" (\" + response.getStatus() + \") Error trying to interrupt the running process on the Endpoint [ \" + endpointId + \"].\" );\n+                        Logger.error(\n+                                this.getClass(),\n+                                \"Response indicating a \" + response.getStatusInfo().getReasonPhrase() + \" (\"\n+                                        + response.getStatus()\n+                                        + \") Error trying to interrupt the running process on the Endpoint [ \"\n+                                        + endpointId + \"].\");\n                     }\n \n+                    //Get the thread associated to this endpoint and the integrity request id\n+                    final Thread runningThread = (Thread) session.getAttribute( \"integrityThread_\" + endpointId );\n                     //Interrupt the Thread process\n                     runningThread.interrupt();\n-\n                     //Remove the thread from the session\n-                    clearThreadInSession( httpServletRequest, endpointId );\n+                    clearThreadInSession(httpServletRequest, endpointId);\n \n-                    jsonResponse.put( \"success\", true );\n-                    jsonResponse.put( \"message\", LanguageUtil.get( initData.getUser().getLocale(), \"IntegrityCheckingCanceled\" ) );\n-                } else {\n-                    jsonResponse.put( \"success\", false );\n-                    jsonResponse.put( \"message\", \"The integrity process for End Point server: [\" + endpointId + \"] was already stopped.\" );\n+                    jsonResponse.put(\"success\", true);\n+                    jsonResponse.put(\n+                            \"message\",\n+                            LanguageUtil.get(initData.getUser().getLocale(), \"IntegrityCheckingCanceled\"));\n                 }\n             }\n \n-            responseMessage.append( jsonResponse.toString() );\n-\n-        } catch ( Exception e ) {\n-            Logger.error( this.getClass(), \"Error checking the integrity process status for End Point server: [\" + endpointId + \"]\", e );\n+            responseMessage.append(jsonResponse.toString());\n+        } catch (Exception e) {\n+            Logger.error(\n+                    this.getClass(),\n+                    \"Error checking the integrity process status for End Point server: [\" + endpointId + \"]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "originalPosition": 884}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODI1MTMw", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492825130", "createdAt": "2020-09-21T17:19:18Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxOFrOHVa5dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxOFrOHVa5dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjgzNg==", "bodyText": "Codacy found an issue: Avoid throwing raw exception types.", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222836", "createdAt": "2020-09-21T17:19:18Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityDataRequestChecker.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.repackage.org.apache.commons.httpclient.HttpStatus;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotHibernateException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.media.multipart.FormDataMultiPart;\n+\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+/**\n+ * Thread to constantly check the integrity check status by hitting on receiver host endpoint.\n+ * Anything but {@link com.dotcms.rest.IntegrityResource.ProcessStatus}.PROCESSING is considered that the integrity data\n+ * generation process is done.\n+ */\n+public class IntegrityDataRequestChecker implements Runnable {\n+\n+    private final String authToken;\n+    private final PublishingEndPoint endpoint;\n+    private final String integrityDataRequestId;\n+    private final HttpSession session;\n+    private final InitDataObject initData;\n+\n+    public IntegrityDataRequestChecker(String authToken,\n+                                       PublishingEndPoint endpoint,\n+                                       String integrityDataRequestId,\n+                                       HttpSession session,\n+                                       InitDataObject initData) {\n+        this.authToken = authToken;\n+        this.endpoint = endpoint;\n+        this.integrityDataRequestId = integrityDataRequestId;\n+        this.session = session;\n+        this.initData = initData;\n+    }\n+\n+    @Override\n+    public void run() {\n+        final Map<String, String> paramsMap = initData.getParamsMap();\n+        final String endpointId = paramsMap.get(\"endpoint\");\n+        final User loggedUser = initData.getUser();\n+        final FormDataMultiPart form = new FormDataMultiPart();\n+        form.field(\"AUTH_TOKEN\",authToken);\n+        form.field(\"REQUEST_ID\", integrityDataRequestId);\n+        final String url = endpoint.toURL() + \"/api/integrity/getintegritydata/\";\n+\n+        boolean processing = true;\n+        while(processing) {\n+            final Response response = IntegrityResource.postWithEndpointState(\n+                    endpoint.getId(),\n+                    url,\n+                    new MediaType(\"application\", \"zip\"),\n+                    Entity.entity(form, form.getMediaType()));\n+\n+            if (response.getStatus() == HttpStatus.SC_OK) {\n+                processing = false;\n+\n+                final String outputDir = IntegrityUtil.getIntegrityDataPath(endpoint.getId());\n+                final InputStream zipFile = response.readEntity(InputStream.class);\n+\n+                try {\n+                    IntegrityUtil.unzipFile(zipFile, outputDir);\n+                } catch(Exception e) {\n+                    //Special handling if the thread was interrupted\n+                    if (e instanceof InterruptedException) {\n+                        //Setting the process status\n+                        IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.CANCELLED, null);\n+                        final String message = \"Requested interruption of the integrity checking process [unzipping Integrity Data] by the user.\";\n+                        Logger.debug(IntegrityResource.class, message, e);\n+                        throw new RuntimeException(message, e);\n+                    }\n+\n+                    //Setting the process status\n+                    IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.ERROR, null);\n+                    final String message = \"Error while unzipping Integrity Data\";\n+                    Logger.error(IntegrityResource.class, message, e);\n+                    throw new RuntimeException(message, e);\n+                } finally {\n+                    if (zipFile != null) {\n+                        try {\n+                            zipFile.close();\n+                        } catch ( IOException e ) {\n+                            Logger.warn(IntegrityResource.class, \"Error closing zip file stream\", e);\n+                        }\n+                    }\n+                }\n+\n+                // set session variable\n+                // call IntegrityChecker\n+                boolean conflictPresent ;\n+                try {\n+                    IntegrityUtil.completeDiscardConflicts(endpointId);\n+                    conflictPresent = IntegrityUtil.completeCheckIntegrity(endpointId);\n+                } catch(Exception e) {\n+                    //Special handling if the thread was interrupted\n+                    if (e instanceof InterruptedException) {\n+                        //Setting the process status\n+                        IntegrityResource.setStatus(\n+                                session,\n+                                endpointId,\n+                                IntegrityResource.ProcessStatus.CANCELLED,\n+                                null);\n+                        final String message =\n+                                \"Requested interruption of the integrity checking process by the user.\";\n+                        Logger.debug(IntegrityResource.class, message, e);\n+                        throw new RuntimeException(message, e);\n+                    }\n+\n+                    Logger.error(IntegrityResource.class, \"Error checking integrity\", e);\n+                    //Setting the process status\n+                    IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.ERROR, null);\n+                    throw new RuntimeException(\"Error checking integrity\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODI1MTQ3", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492825147", "createdAt": "2020-09-21T17:19:19Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxOVrOHVa5fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToxOVrOHVa5fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjg0NA==", "bodyText": "Codacy found an issue: An instanceof check is being performed on the caught exception.  Create a separate catch clause for this exception type.", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222844", "createdAt": "2020-09-21T17:19:19Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityDataRequestChecker.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.repackage.org.apache.commons.httpclient.HttpStatus;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotHibernateException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.media.multipart.FormDataMultiPart;\n+\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+/**\n+ * Thread to constantly check the integrity check status by hitting on receiver host endpoint.\n+ * Anything but {@link com.dotcms.rest.IntegrityResource.ProcessStatus}.PROCESSING is considered that the integrity data\n+ * generation process is done.\n+ */\n+public class IntegrityDataRequestChecker implements Runnable {\n+\n+    private final String authToken;\n+    private final PublishingEndPoint endpoint;\n+    private final String integrityDataRequestId;\n+    private final HttpSession session;\n+    private final InitDataObject initData;\n+\n+    public IntegrityDataRequestChecker(String authToken,\n+                                       PublishingEndPoint endpoint,\n+                                       String integrityDataRequestId,\n+                                       HttpSession session,\n+                                       InitDataObject initData) {\n+        this.authToken = authToken;\n+        this.endpoint = endpoint;\n+        this.integrityDataRequestId = integrityDataRequestId;\n+        this.session = session;\n+        this.initData = initData;\n+    }\n+\n+    @Override\n+    public void run() {\n+        final Map<String, String> paramsMap = initData.getParamsMap();\n+        final String endpointId = paramsMap.get(\"endpoint\");\n+        final User loggedUser = initData.getUser();\n+        final FormDataMultiPart form = new FormDataMultiPart();\n+        form.field(\"AUTH_TOKEN\",authToken);\n+        form.field(\"REQUEST_ID\", integrityDataRequestId);\n+        final String url = endpoint.toURL() + \"/api/integrity/getintegritydata/\";\n+\n+        boolean processing = true;\n+        while(processing) {\n+            final Response response = IntegrityResource.postWithEndpointState(\n+                    endpoint.getId(),\n+                    url,\n+                    new MediaType(\"application\", \"zip\"),\n+                    Entity.entity(form, form.getMediaType()));\n+\n+            if (response.getStatus() == HttpStatus.SC_OK) {\n+                processing = false;\n+\n+                final String outputDir = IntegrityUtil.getIntegrityDataPath(endpoint.getId());\n+                final InputStream zipFile = response.readEntity(InputStream.class);\n+\n+                try {\n+                    IntegrityUtil.unzipFile(zipFile, outputDir);\n+                } catch(Exception e) {\n+                    //Special handling if the thread was interrupted\n+                    if (e instanceof InterruptedException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "originalPosition": 76}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODI1MTYw", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492825160", "createdAt": "2020-09-21T17:19:20Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToyMFrOHVa5jA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToyMFrOHVa5jA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjg2MA==", "bodyText": "Codacy found an issue: The String literal \"AUTH_TOKEN\" appears 8 times in this file; the first occurrence is on line 169", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222860", "createdAt": "2020-09-21T17:19:20Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -153,68 +147,104 @@ private Response postWithEndpointState(String endpointId, String url, MediaType\n \t\treturn response;\n \t}\n \n+    /**\n+     * Resolves remote IP address from request.\n+     * @param request {@link HttpServletRequest}\n+     * @return a String representing the remote IP address (or hostname)\n+     */\n+    private static String resolveRemoteIp(final HttpServletRequest request) {\n+        final String remoteIP = request.getRemoteHost();\n+        return !UtilMethods.isSet(remoteIP) ? remoteIP : request.getRemoteAddr();\n+    }\n \n     /**\n-     * <p>Returns a zip with data from structures and folders for integrity check\n-     *\n-     * Usage: /getdata\n-     *\n+     * Tries to get the local address plus the port in a \"host:port\" format\n+     * @param request http servlet request\n+     * @return a string representing the address plus the port\n      */\n+    private static String getFullLocalIp(@Context final HttpServletRequest request) {\n+        final String localIp = request.getLocalName();\n+        final Optional<String> port = HttpRequestDataUtil.getServerPort();\n+        return (!UtilMethods.isSet(localIp) ? localIp : request.getLocalName())\n+                + ':' + port.orElse(String.valueOf(request.getLocalPort()));\n+    }\n \n+    /**\n+     * <p>Returns a zip with data from structures and folders for integrity check\n+     */\n     @POST\n     @Path(\"/generateintegritydata/{params:.*}\")\n     @Consumes(MediaType.MULTIPART_FORM_DATA)\n     @Produces(\"text/plain\")\n-    public Response generateIntegrityData(@Context HttpServletRequest request, @FormDataParam(\"AUTH_TOKEN\") String auth_token_digest)  {\n+    public Response generateIntegrityData(\n+            @Context final HttpServletRequest request,\n+            @FormDataParam(\"AUTH_TOKEN\") final String auth_token_digest)  {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODI1MTc4", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492825178", "createdAt": "2020-09-21T17:19:21Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToyMVrOHVa5mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToyMVrOHVa5mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjg3Mg==", "bodyText": "Codacy found an issue: Avoid empty if statements", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222872", "createdAt": "2020-09-21T17:19:21Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityDataRequestChecker.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.repackage.org.apache.commons.httpclient.HttpStatus;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotHibernateException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.media.multipart.FormDataMultiPart;\n+\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+/**\n+ * Thread to constantly check the integrity check status by hitting on receiver host endpoint.\n+ * Anything but {@link com.dotcms.rest.IntegrityResource.ProcessStatus}.PROCESSING is considered that the integrity data\n+ * generation process is done.\n+ */\n+public class IntegrityDataRequestChecker implements Runnable {\n+\n+    private final String authToken;\n+    private final PublishingEndPoint endpoint;\n+    private final String integrityDataRequestId;\n+    private final HttpSession session;\n+    private final InitDataObject initData;\n+\n+    public IntegrityDataRequestChecker(String authToken,\n+                                       PublishingEndPoint endpoint,\n+                                       String integrityDataRequestId,\n+                                       HttpSession session,\n+                                       InitDataObject initData) {\n+        this.authToken = authToken;\n+        this.endpoint = endpoint;\n+        this.integrityDataRequestId = integrityDataRequestId;\n+        this.session = session;\n+        this.initData = initData;\n+    }\n+\n+    @Override\n+    public void run() {\n+        final Map<String, String> paramsMap = initData.getParamsMap();\n+        final String endpointId = paramsMap.get(\"endpoint\");\n+        final User loggedUser = initData.getUser();\n+        final FormDataMultiPart form = new FormDataMultiPart();\n+        form.field(\"AUTH_TOKEN\",authToken);\n+        form.field(\"REQUEST_ID\", integrityDataRequestId);\n+        final String url = endpoint.toURL() + \"/api/integrity/getintegritydata/\";\n+\n+        boolean processing = true;\n+        while(processing) {\n+            final Response response = IntegrityResource.postWithEndpointState(\n+                    endpoint.getId(),\n+                    url,\n+                    new MediaType(\"application\", \"zip\"),\n+                    Entity.entity(form, form.getMediaType()));\n+\n+            if (response.getStatus() == HttpStatus.SC_OK) {\n+                processing = false;\n+\n+                final String outputDir = IntegrityUtil.getIntegrityDataPath(endpoint.getId());\n+                final InputStream zipFile = response.readEntity(InputStream.class);\n+\n+                try {\n+                    IntegrityUtil.unzipFile(zipFile, outputDir);\n+                } catch(Exception e) {\n+                    //Special handling if the thread was interrupted\n+                    if (e instanceof InterruptedException) {\n+                        //Setting the process status\n+                        IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.CANCELLED, null);\n+                        final String message = \"Requested interruption of the integrity checking process [unzipping Integrity Data] by the user.\";\n+                        Logger.debug(IntegrityResource.class, message, e);\n+                        throw new RuntimeException(message, e);\n+                    }\n+\n+                    //Setting the process status\n+                    IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.ERROR, null);\n+                    final String message = \"Error while unzipping Integrity Data\";\n+                    Logger.error(IntegrityResource.class, message, e);\n+                    throw new RuntimeException(message, e);\n+                } finally {\n+                    if (zipFile != null) {\n+                        try {\n+                            zipFile.close();\n+                        } catch ( IOException e ) {\n+                            Logger.warn(IntegrityResource.class, \"Error closing zip file stream\", e);\n+                        }\n+                    }\n+                }\n+\n+                // set session variable\n+                // call IntegrityChecker\n+                boolean conflictPresent ;\n+                try {\n+                    IntegrityUtil.completeDiscardConflicts(endpointId);\n+                    conflictPresent = IntegrityUtil.completeCheckIntegrity(endpointId);\n+                } catch(Exception e) {\n+                    //Special handling if the thread was interrupted\n+                    if (e instanceof InterruptedException) {\n+                        //Setting the process status\n+                        IntegrityResource.setStatus(\n+                                session,\n+                                endpointId,\n+                                IntegrityResource.ProcessStatus.CANCELLED,\n+                                null);\n+                        final String message =\n+                                \"Requested interruption of the integrity checking process by the user.\";\n+                        Logger.debug(IntegrityResource.class, message, e);\n+                        throw new RuntimeException(message, e);\n+                    }\n+\n+                    Logger.error(IntegrityResource.class, \"Error checking integrity\", e);\n+                    //Setting the process status\n+                    IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.ERROR, null);\n+                    throw new RuntimeException(\"Error checking integrity\", e);\n+                } finally {\n+                    try {\n+                        IntegrityUtil.dropTempTables(endpointId);\n+                        HibernateUtil.closeSession();\n+                    } catch (DotHibernateException e) {\n+                        Logger.warn(this, e.getMessage(), e);\n+                    } catch (DotDataException e) {\n+                        Logger.error(IntegrityResource.class, \"Error while deleting temp tables\", e);\n+                    }\n+                }\n+\n+                if (conflictPresent) {\n+                    //Setting the process status\n+                    IntegrityResource.setStatus(session, endpointId, IntegrityResource.ProcessStatus.FINISHED, null);\n+                } else {\n+                    String noConflictMessage;\n+                    try {\n+                        noConflictMessage = LanguageUtil.get(\n+                                loggedUser.getLocale(),\n+                                \"push_publish_integrity_conflicts_not_found\");\n+                    } catch ( LanguageException e ) {\n+                        noConflictMessage = \"No Integrity Conflicts found\";\n+                    }\n+                    //Setting the process status\n+                    IntegrityResource.setStatus(\n+                            session,\n+                            endpointId,\n+                            IntegrityResource.ProcessStatus.NO_CONFLICTS,\n+                            noConflictMessage);\n+                }\n+            } else if ( response.getStatus() == HttpStatus.SC_PROCESSING ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "originalPosition": 154}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODI1MTkx", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492825191", "createdAt": "2020-09-21T17:19:22Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToyMlrOHVa5oQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToyMlrOHVa5oQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjg4MQ==", "bodyText": "Codacy found an issue: Avoid assignments in operands", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222881", "createdAt": "2020-09-21T17:19:22Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityResource.java", "diffHunk": "@@ -230,79 +260,138 @@ public Response generateIntegrityData(@Context HttpServletRequest request, @Form\n     @Path(\"/getintegritydata/{params:.*}\")\n     @Produces(\"application/zip\")\n     @Consumes(MediaType.MULTIPART_FORM_DATA)\n-    public Response getIntegrityData(@Context HttpServletRequest request, @FormDataParam(\"AUTH_TOKEN\") String auth_token_digest, @FormDataParam(\"REQUEST_ID\") String requestId)  {\n-        String remoteIP = null;\n+    public Response getIntegrityData(@Context final HttpServletRequest request,\n+                                     @FormDataParam(\"AUTH_TOKEN\") final String auth_token_digest,\n+                                     @FormDataParam(\"REQUEST_ID\") final String requestId)  {\n+        final String remoteIp = resolveRemoteIp(request);\n+        final String localAddress = getFullLocalIp(request);\n \n+        final PublishingEndPointAPI endpointAPI = APILocator.getPublisherEndPointAPI();\n         try {\n+            final PublishingEndPoint requesterEndpoint = endpointAPI.findEnabledSendingEndPointByAddress(remoteIp);\n+\n+            if (!BundlePublisherResource.isValidToken(auth_token_digest, remoteIp, requesterEndpoint) ||\n+                    !UtilMethods.isSet(requestId)) {\n+                Logger.error(\n+                        IntegrityResource.class,\n+                        String.format(\n+                                \"Receiver at %s:> Authentication Token is invalid for ip: %s and endpoint id %s\",\n+                                localAddress,\n+                                remoteIp,\n+                                requesterEndpoint.getId()));\n+                return Response.status(HttpStatus.SC_UNAUTHORIZED).build();\n+            }\n \n+            if (QuartzUtils.isJobRunning(\n+                    IntegrityDataGenerationJob.JOB_NAME,\n+                    IntegrityDataGenerationJob.JOB_GROUP)) {\n+                Logger.error(\n+                        IntegrityResource.class,\n+                        String.format(\n+                                \"Receiver at %s:> job is already running for endpoint id: %s, therefore it's not ready and need to wait\",\n+                                localAddress,\n+                                requesterEndpoint.getId()));\n+                return Response.status(HttpStatus.SC_PROCESSING).build();\n+            }\n \n-            remoteIP = request.getRemoteHost();\n-            if(!UtilMethods.isSet(remoteIP))\n-                remoteIP = request.getRemoteAddr();\n-\n-            PublishingEndPointAPI endpointAPI = APILocator.getPublisherEndPointAPI();\n-            final PublishingEndPoint requesterEndPoint = endpointAPI.findEnabledSendingEndPointByAddress(remoteIP);\n-\n-            if(!BundlePublisherResource.isValidToken(auth_token_digest, remoteIP, requesterEndPoint) || !UtilMethods.isSet(requestId)) {\n+            final Optional<IntegrityUtil.IntegrityDataExecutionMetadata> integrityMetadata =\n+                    IntegrityUtil.getIntegrityMetadata(requesterEndpoint.getId());\n+            if (!integrityMetadata.isPresent()) {\n+                Logger.error(\n+                        IntegrityResource.class,\n+                        String.format(\n+                                \"Receiver at %s:> integrity data generation metadata for endpoint id %s is not found \",\n+                                localAddress,\n+                                requesterEndpoint.getId()));\n                 return Response.status(HttpStatus.SC_UNAUTHORIZED).build();\n             }\n \n-            ServletContext servletContext = request.getSession().getServletContext();\n-            if(!UtilMethods.isSet(servletContext.getAttribute(\"integrityDataRequestID\"))\n-                    || !((String) servletContext.getAttribute(\"integrityDataRequestID\")).equals(requestId)) {\n+            if (!requestId.equals(integrityMetadata.get().getRequestId())) {\n+                Logger.error(\n+                        IntegrityResource.class,\n+                        String.format(\n+                                \"Receiver at %s:> integrity data generation metadata for endpoint id %s has a request id %s which does not match the provided %s\",\n+                                localAddress,\n+                                requesterEndpoint.getId(),\n+                                integrityMetadata.get().getRequestId(),\n+                                requestId));\n                 return Response.status(HttpStatus.SC_UNAUTHORIZED).build();\n             }\n \n-            ProcessStatus integrityDataGeneratorStatus = (ProcessStatus) servletContext.getAttribute(\"integrityDataGenerationStatus\");\n-\n-            if(UtilMethods.isSet( integrityDataGeneratorStatus )) {\n-                switch (integrityDataGeneratorStatus) {\n-                    case PROCESSING:\n-                        return Response.status(HttpStatus.SC_PROCESSING).build();\n-                    case FINISHED:\n-                        StreamingOutput output = new StreamingOutput() {\n-                            public void write(OutputStream output) throws IOException, WebApplicationException {\n-                                InputStream is = Files.newInputStream(Paths.get(\n-                                        ConfigUtils.getIntegrityPath() + File.separator\n-                                                + requesterEndPoint.getId() + File.separator\n-                                                + INTEGRITY_DATA_TO_CHECK_ZIP_FILE_NAME));\n-\n-                                byte[] buffer = new byte[1024];\n-                                int bytesRead;\n-                                //read from is to buffer\n-                                while((bytesRead = is.read(buffer)) !=-1){\n-                                    output.write(buffer, 0, bytesRead);\n-                                }\n-                                is.close();\n-                                //flush OutputStream to write any buffered data to file\n-                                output.flush();\n-                                output.close();\n-\n-                            }\n-                        };\n-                        return Response.ok(output).build();\n-\n-                    case CANCELED:\n-                        return Response.status( HttpStatus.SC_RESET_CONTENT ).entity( servletContext.getAttribute( \"integrityDataGenerationError\" ) ).build();\n-\n-                    case ERROR:\n-                        return Response.status(HttpStatus.SC_INTERNAL_SERVER_ERROR).entity(servletContext.getAttribute(\"integrityDataGenerationError\")).build();\n+            if (integrityMetadata.get().getProcessStatus() == ProcessStatus.PROCESSING) {\n+                Logger.info(\n+                        IntegrityResource.class,\n+                        String.format(\n+                                \"Receiver at %s:> integrity data generation for endpoint id %s still ongoing therefore it's not ready and need to wait\",\n+                                localAddress,\n+                                requesterEndpoint.getId()));\n+                return Response.status(HttpStatus.SC_PROCESSING).build();\n+            } else if (integrityMetadata.get().getProcessStatus() == ProcessStatus.FINISHED &&\n+                    IntegrityUtil.doesIntegrityDataFileExist(\n+                            requesterEndpoint.getId(),\n+                            IntegrityUtil.INTEGRITY_DATA_TO_CHECK_ZIP_FILENAME)) {\n+                final String zipFilePath = IntegrityUtil.getIntegrityDataFilePath(\n+                        requesterEndpoint.getId(),\n+                        IntegrityUtil.INTEGRITY_DATA_TO_CHECK_ZIP_FILENAME);\n+                final StreamingOutput output = so -> {\n+                    final InputStream inputStream = Files.newInputStream(Paths.get(zipFilePath));\n+                    final byte[] buffer = new byte[1024];\n+                    int bytesRead;\n+                    //read from is to buffer\n+                    while((bytesRead = inputStream.read(buffer)) != -1){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "originalPosition": 371}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODI1MjA1", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492825205", "createdAt": "2020-09-21T17:19:24Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToyNFrOHVa5rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToyNFrOHVa5rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjg5NA==", "bodyText": "Codacy found an issue: Avoid instantiating FileInputStream, FileOutputStream, FileReader, or FileWriter", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222894", "createdAt": "2020-09-21T17:19:24Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityUtil.java", "diffHunk": "@@ -243,83 +257,234 @@ public static void unzipFile(InputStream zipFile, String outputDir) throws Excep\n         }\n     }\n \n+    /**\n+     * Resolves the integrity data path based on provided endpoint id.\n+     *\n+     * @param endpointId endpoint if\n+     * @return integrity data path as a string\n+     */\n+    public static String getIntegrityDataPath(final String endpointId) {\n+        return ConfigUtils.getIntegrityPath() + File.separator + endpointId;\n+    }\n+\n+    /**\n+     * Generated the integrity data file path based on provided endpointId and the file name.\n+     * File names to be used: DataToCheck.zip, DataToFix.zip and DataStatus.properties.\n+     *\n+     * @param endpointId endpoint gid\n+     * @param dataFile data filename\n+     * @return path to filename\n+     */\n+    public static String getIntegrityDataFilePath(final String endpointId, final String dataFile) {\n+        return getIntegrityDataPath(endpointId) + File.separator + dataFile;\n+    }\n+\n+    /**\n+     * Tells whether a integrity file exists based on provided endpointId and the file name.\n+     *\n+     * @param endpointId endpoint id\n+     * @param dataFile data filename\n+     * @return path to filename\n+     */\n+    public static boolean doesIntegrityDataFileExist(final String endpointId, final String dataFile) {\n+        return new File(getIntegrityDataFilePath(endpointId, dataFile)).exists();\n+    }\n+\n+    /**\n+     * Gets a {@link IntegrityDataExecutionMetadata} instance based on provided endpoint id which contains metadata of the\n+     * integrity data generation execution.\n+     *\n+     * @param endpointId endpoint id\n+     * @return Optional wrapping the integrity generation  metadata\n+     */\n+    public static Optional<IntegrityDataExecutionMetadata> getIntegrityMetadata(final String endpointId) {\n+        final File statusFile = new File(getIntegrityDataFilePath(endpointId, INTEGRITY_DATA_STATUS_FILENAME));\n+        if (!statusFile.exists()) {\n+            return Optional.empty();\n+        }\n+\n+        final Properties statusData = new Properties();\n+        try {\n+            statusData.load(new FileInputStream(statusFile));\n+        } catch (IOException e) {\n+            Logger.error(\n+                    IntegrityUtil.class,\n+                    String.format(\"Could load status from %s\", statusFile.getAbsolutePath()),\n+                    e);\n+            return Optional.empty();\n+        }\n+\n+        return Optional.of(new IntegrityDataExecutionMetadata(\n+                statusData.getProperty(REQUESTER_ENDPOINT),\n+                statusData.getProperty(INTEGRITY_DATA_REQUEST_ID),\n+                statusData.getProperty(INTEGRITY_DATA_STATUS),\n+                statusData.getProperty(INTEGRITY_DATA_ERROR_MESSAGE)));\n+    }\n+\n+    /**\n+     * Removes any file leftovers from other integrity checks at the location based on the endpoint id.\n+     * That will be any data check and status files.\n+     *\n+     * @param endpointId endpoint id\n+     */\n+    public static void cleanUpIntegrityData(String endpointId) {\n+        final BiConsumer<String, String> resetConsumer = (id, filename) -> {\n+            final File file = new File(getIntegrityDataFilePath(id, filename));\n+            if (file.exists()) {\n+                file.delete();\n+            }\n+        };\n+\n+        resetConsumer.accept(endpointId, INTEGRITY_DATA_STATUS_FILENAME);\n+        resetConsumer.accept(endpointId, INTEGRITY_DATA_TO_CHECK_ZIP_FILENAME);\n+    }\n+\n+    /**\n+     * Saves a integrity data generation metadata in a to-be-discovered location so it can be read by concurrent parts\n+     * that need to know what is the status of the integrity data generation.\n+     * The data is saved as {@link Properties} file.\n+     *\n+     * @param integrityDataExecutionMetadata execution metadata\n+     */\n+    private static void saveIntegrityDataStatus(IntegrityDataExecutionMetadata integrityDataExecutionMetadata) {\n+        final String endpointId = integrityDataExecutionMetadata.getEndpointId();\n+        final File integrityDir = new File(getIntegrityDataPath(endpointId));\n+        if (!integrityDir.exists()) {\n+            integrityDir.mkdir();\n+        }\n+\n+        final File statusFile = new File(getIntegrityDataFilePath(endpointId, INTEGRITY_DATA_STATUS_FILENAME));\n+        /*if (statusFile.exists()) {\n+            statusFile.delete();\n+        }*/\n+\n+        final Properties statusData = new Properties();\n+        final BiConsumer<String, String> addData = (data, name) -> {\n+            if (StringUtils.isNotBlank(data)) {\n+                statusData.setProperty(name, data);\n+            }\n+        };\n+\n+        addData.accept(endpointId, REQUESTER_ENDPOINT);\n+        addData.accept(integrityDataExecutionMetadata.getRequestId(), INTEGRITY_DATA_REQUEST_ID);\n+        statusData.setProperty(INTEGRITY_DATA_STATUS, integrityDataExecutionMetadata.getProcessStatus().toString().toUpperCase());\n+        addData.accept(integrityDataExecutionMetadata.getErrorMessage(), INTEGRITY_DATA_ERROR_MESSAGE);\n+\n+        try (FileOutputStream output = new FileOutputStream(statusFile)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "originalPosition": 158}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODI1MjI0", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492825224", "createdAt": "2020-09-21T17:19:25Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToyNVrOHVa5vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToyNVrOHVa5vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjkxMA==", "bodyText": "Codacy found an issue: Avoid catching generic exceptions such as NullPointerException, RuntimeException, Exception in try-catch block", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222910", "createdAt": "2020-09-21T17:19:25Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/rest/IntegrityDataRequestChecker.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.dotcms.rest;\n+\n+import com.dotcms.integritycheckers.IntegrityUtil;\n+import com.dotcms.publisher.endpoint.bean.PublishingEndPoint;\n+import com.dotcms.repackage.org.apache.commons.httpclient.HttpStatus;\n+import com.dotmarketing.db.HibernateUtil;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotHibernateException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import org.glassfish.jersey.media.multipart.FormDataMultiPart;\n+\n+import javax.servlet.http.HttpSession;\n+import javax.ws.rs.client.Entity;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+/**\n+ * Thread to constantly check the integrity check status by hitting on receiver host endpoint.\n+ * Anything but {@link com.dotcms.rest.IntegrityResource.ProcessStatus}.PROCESSING is considered that the integrity data\n+ * generation process is done.\n+ */\n+public class IntegrityDataRequestChecker implements Runnable {\n+\n+    private final String authToken;\n+    private final PublishingEndPoint endpoint;\n+    private final String integrityDataRequestId;\n+    private final HttpSession session;\n+    private final InitDataObject initData;\n+\n+    public IntegrityDataRequestChecker(String authToken,\n+                                       PublishingEndPoint endpoint,\n+                                       String integrityDataRequestId,\n+                                       HttpSession session,\n+                                       InitDataObject initData) {\n+        this.authToken = authToken;\n+        this.endpoint = endpoint;\n+        this.integrityDataRequestId = integrityDataRequestId;\n+        this.session = session;\n+        this.initData = initData;\n+    }\n+\n+    @Override\n+    public void run() {\n+        final Map<String, String> paramsMap = initData.getParamsMap();\n+        final String endpointId = paramsMap.get(\"endpoint\");\n+        final User loggedUser = initData.getUser();\n+        final FormDataMultiPart form = new FormDataMultiPart();\n+        form.field(\"AUTH_TOKEN\",authToken);\n+        form.field(\"REQUEST_ID\", integrityDataRequestId);\n+        final String url = endpoint.toURL() + \"/api/integrity/getintegritydata/\";\n+\n+        boolean processing = true;\n+        while(processing) {\n+            final Response response = IntegrityResource.postWithEndpointState(\n+                    endpoint.getId(),\n+                    url,\n+                    new MediaType(\"application\", \"zip\"),\n+                    Entity.entity(form, form.getMediaType()));\n+\n+            if (response.getStatus() == HttpStatus.SC_OK) {\n+                processing = false;\n+\n+                final String outputDir = IntegrityUtil.getIntegrityDataPath(endpoint.getId());\n+                final InputStream zipFile = response.readEntity(InputStream.class);\n+\n+                try {\n+                    IntegrityUtil.unzipFile(zipFile, outputDir);\n+                } catch(Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODI1MjM1", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492825235", "createdAt": "2020-09-21T17:19:26Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToyNlrOHVa5yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxOToyNlrOHVa5yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMjkyMA==", "bodyText": "Codacy found an issue: Avoid instantiating FileInputStream, FileOutputStream, FileReader, or FileWriter", "url": "https://github.com/dotCMS/core/pull/19243#discussion_r492222920", "createdAt": "2020-09-21T17:19:26Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/integritycheckers/IntegrityUtil.java", "diffHunk": "@@ -243,83 +257,234 @@ public static void unzipFile(InputStream zipFile, String outputDir) throws Excep\n         }\n     }\n \n+    /**\n+     * Resolves the integrity data path based on provided endpoint id.\n+     *\n+     * @param endpointId endpoint if\n+     * @return integrity data path as a string\n+     */\n+    public static String getIntegrityDataPath(final String endpointId) {\n+        return ConfigUtils.getIntegrityPath() + File.separator + endpointId;\n+    }\n+\n+    /**\n+     * Generated the integrity data file path based on provided endpointId and the file name.\n+     * File names to be used: DataToCheck.zip, DataToFix.zip and DataStatus.properties.\n+     *\n+     * @param endpointId endpoint gid\n+     * @param dataFile data filename\n+     * @return path to filename\n+     */\n+    public static String getIntegrityDataFilePath(final String endpointId, final String dataFile) {\n+        return getIntegrityDataPath(endpointId) + File.separator + dataFile;\n+    }\n+\n+    /**\n+     * Tells whether a integrity file exists based on provided endpointId and the file name.\n+     *\n+     * @param endpointId endpoint id\n+     * @param dataFile data filename\n+     * @return path to filename\n+     */\n+    public static boolean doesIntegrityDataFileExist(final String endpointId, final String dataFile) {\n+        return new File(getIntegrityDataFilePath(endpointId, dataFile)).exists();\n+    }\n+\n+    /**\n+     * Gets a {@link IntegrityDataExecutionMetadata} instance based on provided endpoint id which contains metadata of the\n+     * integrity data generation execution.\n+     *\n+     * @param endpointId endpoint id\n+     * @return Optional wrapping the integrity generation  metadata\n+     */\n+    public static Optional<IntegrityDataExecutionMetadata> getIntegrityMetadata(final String endpointId) {\n+        final File statusFile = new File(getIntegrityDataFilePath(endpointId, INTEGRITY_DATA_STATUS_FILENAME));\n+        if (!statusFile.exists()) {\n+            return Optional.empty();\n+        }\n+\n+        final Properties statusData = new Properties();\n+        try {\n+            statusData.load(new FileInputStream(statusFile));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODcyODA5", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-492872809", "createdAt": "2020-09-21T18:25:22Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkzNzM4MDI3", "url": "https://github.com/dotCMS/core/pull/19243#pullrequestreview-493738027", "createdAt": "2020-09-22T18:30:01Z", "commit": {"oid": "bec50a104819f020e85de9a754b814af4422bed3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1839, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}