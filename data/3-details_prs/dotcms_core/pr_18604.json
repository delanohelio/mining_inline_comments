{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MDYwMDk4", "number": 18604, "title": "Issue 17842 show notification if es is read only", "bodyText": "After a reindex fail because the current index are in Read only mode, should trigger a Monitor to try to set the current index in write mode again", "createdAt": "2020-06-04T20:06:34Z", "url": "https://github.com/dotCMS/core/pull/18604", "merged": true, "mergeCommit": {"oid": "87e59fdf172ce70e126a2ca898b974f8bf45cf30"}, "closed": true, "closedAt": "2020-06-09T15:17:21Z", "author": {"login": "freddyucv"}, "timelineItems": {"totalCount": 66, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjkrNygH2gAyNDI4MDYwMDk4OmY4YTM3MTkwYjc1YjNiMjE0NmYxMjIxOGI5YmUyYTgxODA2ZTU1ZDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcplrjPAFqTQyNzE5MTk2MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f8a37190b75b3b2146f12218b9be2a81806e55d1", "author": {"user": {"login": "freddyucv", "name": "Freddy Rodriguez"}}, "url": "https://github.com/dotCMS/core/commit/f8a37190b75b3b2146f12218b9be2a81806e55d1", "committedDate": "2020-05-21T21:37:13Z", "message": "#17842 Show Notification if ES is read-only"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "848212aeb38c115e58188a366dd1fbc0dca3fead", "author": {"user": {"login": "freddyucv", "name": "Freddy Rodriguez"}}, "url": "https://github.com/dotCMS/core/commit/848212aeb38c115e58188a366dd1fbc0dca3fead", "committedDate": "2020-05-26T16:03:26Z", "message": "#17842 Show Notification if ES is read-only"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "016df3d98fc2306584781385221e91b5519cf028", "author": {"user": {"login": "freddyucv", "name": "Freddy Rodriguez"}}, "url": "https://github.com/dotCMS/core/commit/016df3d98fc2306584781385221e91b5519cf028", "committedDate": "2020-05-27T18:14:09Z", "message": "#17842"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ed082f856f94321eee397f6a8e59fac1b2587fc", "author": {"user": {"login": "freddyucv", "name": "Freddy Rodriguez"}}, "url": "https://github.com/dotCMS/core/commit/7ed082f856f94321eee397f6a8e59fac1b2587fc", "committedDate": "2020-06-03T15:13:39Z", "message": "merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f8add6764dee9ca65d7bdcd74e8a53f0922c8be", "author": {"user": {"login": "freddyucv", "name": "Freddy Rodriguez"}}, "url": "https://github.com/dotCMS/core/commit/8f8add6764dee9ca65d7bdcd74e8a53f0922c8be", "committedDate": "2020-06-03T15:16:11Z", "message": "merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fbb7a079df458b7457ab615b5e8fc04c0942e35", "author": {"user": {"login": "freddyucv", "name": "Freddy Rodriguez"}}, "url": "https://github.com/dotCMS/core/commit/8fbb7a079df458b7457ab615b5e8fc04c0942e35", "committedDate": "2020-06-04T15:31:34Z", "message": "#17842 Fixing and cleaning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87c6f9705f910814eb87b1b13c49c773d6ad1edd", "author": {"user": {"login": "freddyucv", "name": "Freddy Rodriguez"}}, "url": "https://github.com/dotCMS/core/commit/87c6f9705f910814eb87b1b13c49c773d6ad1edd", "committedDate": "2020-06-04T19:15:28Z", "message": "#17842 Testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "525111a7d3b1082c3bb069ed901498dd3317cda9", "author": {"user": {"login": "freddyucv", "name": "Freddy Rodriguez"}}, "url": "https://github.com/dotCMS/core/commit/525111a7d3b1082c3bb069ed901498dd3317cda9", "committedDate": "2020-06-04T19:19:33Z", "message": "#17842 Merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528", "author": {"user": {"login": "freddyucv", "name": "Freddy Rodriguez"}}, "url": "https://github.com/dotCMS/core/commit/0bf0a53f796560307f7908e3992ac85bba031528", "committedDate": "2020-06-04T19:21:42Z", "message": "#17842 Removing unnecessary logger"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NzkyOTc1", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-424792975", "createdAt": "2020-06-04T20:12:36Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxMjozN1rOGfWJhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxMjozN1rOGfWJhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMTkyNg==", "bodyText": "Use Try.of().getOrThrow(DotRuntimeException::new) instead", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435521926", "createdAt": "2020-06-04T20:12:37Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0NzkzODc1", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-424793875", "createdAt": "2020-06-04T20:14:02Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxNDowMlrOGfWMQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxNDowMlrOGfWMQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMjYyNQ==", "bodyText": "rename to isAnyReadOnly", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435522625", "createdAt": "2020-06-04T20:14:02Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 25}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0Nzk2NDIz", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-424796423", "createdAt": "2020-06-04T20:17:58Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxNzo1OFrOGfWTxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxNzo1OFrOGfWTxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNDU1MA==", "bodyText": "I think you do not need to call the ESIndexUtil if you are already in there", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435524550", "createdAt": "2020-06-04T20:17:58Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");\n+\n+        return Arrays.stream(indexNames).anyMatch((indexName) -> {\n+            final String readOnlyAllowDelete = response.getSetting(indexName, READ_ONLY_ALLOW_DELETE_SETTING);\n+            final String readOnly = response.getSetting(indexName, READ_ONLY_SETTING);\n+\n+            return Boolean.parseBoolean(readOnlyAllowDelete) || Boolean.parseBoolean(readOnly);\n+        });\n+    }\n+\n+    public static AcknowledgedResponse putReadOnlyToFalse(final String... indexName) {\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(indexName);\n+\n+        final Settings.Builder settingBuilder = Settings.builder()\n+                .put(READ_ONLY_ALLOW_DELETE_SETTING, false)\n+                .put(READ_ONLY_SETTING, false);\n+\n+        request.settings(settingBuilder);\n+\n+        return Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .putSettings(request, RequestOptions.DEFAULT)\n+        );\n+    }\n+\n+    public static boolean isAnyCurrentIndicesReadOnly() {\n+        final IndiciesInfo indiciesInfo = loadIndicesInfo();\n+        return ESIndexUtil.isReadOnly(indiciesInfo.getLive(), indiciesInfo.getWorking());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0Nzk3MTA2", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-424797106", "createdAt": "2020-06-04T20:19:02Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxOTowMlrOGfWV3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoxOTowMlrOGfWV3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNTA4Ng==", "bodyText": "this should be final", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435525086", "createdAt": "2020-06-04T20:19:02Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.enterprise.LicenseUtil;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+\n+/**\n+ * Run a Monitor If the current indices are in read only mode and try to set them to write mode again.\n+ * When the set write mode fail it try again after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private AtomicBoolean started = new AtomicBoolean();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0Nzk4NzM5", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-424798739", "createdAt": "2020-06-04T20:21:31Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoyMTozMlrOGfWa0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoyMTozMlrOGfWa0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNjM1Mg==", "bodyText": "remember use the supplier", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435526352", "createdAt": "2020-06-04T20:21:32Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.enterprise.LicenseUtil;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+\n+/**\n+ * Run a Monitor If the current indices are in read only mode and try to set them to write mode again.\n+ * When the set write mode fail it try again after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private AtomicBoolean started = new AtomicBoolean();\n+    private final ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;\n+\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(final SystemMessageEventUtil systemMessageEventUtil, final RoleAPI roleAPI) {\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+\n+        scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);\n+        scheduledThreadPoolExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(true);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(SystemMessageEventUtil.getInstance(), APILocator.getRoleAPI());\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final ReindexEntry reindexEntry, final String cause){\n+        if (started.compareAndSet(false, true)) {\n+            Logger.error(this.getClass(), Thread.currentThread().getName() + \" - Reindex failed for :\" + reindexEntry + \" because \" + cause);\n+\n+            if (ESIndexUtil.isAnyCurrentIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final SystemMessageBuilder message = new SystemMessageBuilder()\n+                    .setMessage(LanguageUtil.get(messageKey))\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            systemMessageEventUtil.pushMessage(message.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), \"Trying to set the current indices to Write mode\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0Nzk5MzIx", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-424799321", "createdAt": "2020-06-04T20:22:22Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoyMjoyM1rOGfWcig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoyMjoyM1rOGfWcig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNjc5NA==", "bodyText": "I am not sure if this is thread-safe", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435526794", "createdAt": "2020-06-04T20:22:23Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.enterprise.LicenseUtil;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+\n+/**\n+ * Run a Monitor If the current indices are in read only mode and try to set them to write mode again.\n+ * When the set write mode fail it try again after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private AtomicBoolean started = new AtomicBoolean();\n+    private final ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;\n+\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(final SystemMessageEventUtil systemMessageEventUtil, final RoleAPI roleAPI) {\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+\n+        scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(1);\n+        scheduledThreadPoolExecutor.setContinueExistingPeriodicTasksAfterShutdownPolicy(true);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(SystemMessageEventUtil.getInstance(), APILocator.getRoleAPI());\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final ReindexEntry reindexEntry, final String cause){\n+        if (started.compareAndSet(false, true)) {\n+            Logger.error(this.getClass(), Thread.currentThread().getName() + \" - Reindex failed for :\" + reindexEntry + \" because \" + cause);\n+\n+            if (ESIndexUtil.isAnyCurrentIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final SystemMessageBuilder message = new SystemMessageBuilder()\n+                    .setMessage(LanguageUtil.get(messageKey))\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            systemMessageEventUtil.pushMessage(message.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), \"Trying to set the current indices to Write mode\");\n+            ESIndexUtil.putCurrentIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ESResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void startMonitor() {\n+        timer = new Timer(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0ODAwMDY4", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-424800068", "createdAt": "2020-06-04T20:23:32Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoyMzozMlrOGfWesg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoyMzozMlrOGfWesg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNzM0Ng==", "bodyText": "Not sure if we should create thread, DotConcurrentFactory is your friend", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435527346", "createdAt": "2020-06-04T20:23:32Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/common/reindex/ReindexQueueAPIImpl.java", "diffHunk": "@@ -219,14 +222,14 @@ public void deleteReindexEntry(String identiferToDelete) throws DotDataException\n         reindexQueueFactory.deleteReindexEntry(identiferToDelete);\n     }\n \n-\n-\n     @Override\n     @WrapInTransaction\n     public void markAsFailed(final ReindexEntry idx, final String cause) throws DotDataException {\n-        Logger.warn(this.getClass(), \"Reindex failed for :\" + idx + \" because \" + cause);\n         reindexQueueFactory.markAsFailed(idx, UtilMethods.shortenString(cause, 300));\n \n+        new Thread(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0ODAwMzgx", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-424800381", "createdAt": "2020-06-04T20:23:58Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoyMzo1OFrOGfWfnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMDoyMzo1OFrOGfWfnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyNzU4MA==", "bodyText": "set to final", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435527580", "createdAt": "2020-06-04T20:23:58Z", "author": {"login": "jdotcms"}, "path": "dotCMS/src/main/java/com/dotmarketing/common/reindex/ReindexThread.java", "diffHunk": "@@ -323,4 +328,7 @@ protected void sendNotification(final String key, final Object[] msgParams, fina\n         systemUser.getLocale());\n   }\n \n+    public static void setCurrentIndexReadOnly(boolean currentIndexReadOnly) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 98}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0ODU2MTE1", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-424856115", "createdAt": "2020-06-04T21:42:06Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo0MjowNlrOGfZB6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo0MjowNlrOGfZB6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2OTEyOA==", "bodyText": "\"is\" read only", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435569128", "createdAt": "2020-06-04T21:42:06Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0ODU3MTIy", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-424857122", "createdAt": "2020-06-04T21:44:01Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo0NDowMVrOGfZFHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo0NDowMVrOGfZFHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2OTk0OA==", "bodyText": "Shouldn't you log the reason of the exception?", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435569948", "createdAt": "2020-06-04T21:44:01Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");\n+\n+        return Arrays.stream(indexNames).anyMatch((indexName) -> {\n+            final String readOnlyAllowDelete = response.getSetting(indexName, READ_ONLY_ALLOW_DELETE_SETTING);\n+            final String readOnly = response.getSetting(indexName, READ_ONLY_SETTING);\n+\n+            return Boolean.parseBoolean(readOnlyAllowDelete) || Boolean.parseBoolean(readOnly);\n+        });\n+    }\n+\n+    public static AcknowledgedResponse putReadOnlyToFalse(final String... indexName) {\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(indexName);\n+\n+        final Settings.Builder settingBuilder = Settings.builder()\n+                .put(READ_ONLY_ALLOW_DELETE_SETTING, false)\n+                .put(READ_ONLY_SETTING, false);\n+\n+        request.settings(settingBuilder);\n+\n+        return Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .putSettings(request, RequestOptions.DEFAULT)\n+        );\n+    }\n+\n+    public static boolean isAnyCurrentIndicesReadOnly() {\n+        final IndiciesInfo indiciesInfo = loadIndicesInfo();\n+        return ESIndexUtil.isReadOnly(indiciesInfo.getLive(), indiciesInfo.getWorking());\n+    }\n+\n+    public static void putCurrentIndicesToWriteMode() throws ESResponseException {\n+        final IndiciesInfo indiciesInfo = loadIndicesInfo();\n+        final AcknowledgedResponse response = ESIndexUtil.putReadOnlyToFalse(indiciesInfo.getLive(), indiciesInfo.getWorking());\n+\n+        if (!response.isAcknowledged()) {\n+            throw new ESResponseException(response);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0ODU4MTcw", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-424858170", "createdAt": "2020-06-04T21:46:04Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo0NjowNVrOGfZIpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo0NjowNVrOGfZIpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MDg1NA==", "bodyText": "\"is\" in read only mode", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435570854", "createdAt": "2020-06-04T21:46:05Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/main/webapp/WEB-INF/messages/Language.properties", "diffHunk": "@@ -4802,5 +4802,8 @@ Default-Action-Archive = Archive\n Default-Action-Unarchive = Unarchive\n Default-Action-Delete = Delete\n Default-Action-Destroy = Destroy\n+es.index.read.only.message = At least one of the Elasticsearch current indices are in read only mode", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0ODU5NTM3", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-424859537", "createdAt": "2020-06-04T21:48:32Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo0ODozMlrOGfZM2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo0ODozMlrOGfZM2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MTkyOA==", "bodyText": "I think the test name should be changed because you are testing a not read only scenario", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435571928", "createdAt": "2020-06-04T21:48:32Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0ODYwMDE0", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-424860014", "createdAt": "2020-06-04T21:49:23Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo0OToyNFrOGfZOSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo0OToyNFrOGfZOSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MjI5Ng==", "bodyText": "DoesNotExist", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435572296", "createdAt": "2020-06-04T21:49:24Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0ODYxMDk2", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-424861096", "createdAt": "2020-06-04T21:51:20Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo1MToyMFrOGfZRxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo1MToyMFrOGfZRxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MzE4OQ==", "bodyText": "is read only", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435573189", "createdAt": "2020-06-04T21:51:20Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldPutReadonlyInTrue() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            ESIndexUtil.putReadOnlyToFalse(indiciesInfo.getWorking());\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, !readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     */\n+    @Test(expected = ElasticsearchStatusException.class)\n+    public void shouldTryPutReadonlyInTrueAndTheIndexDoesNotExists()  {\n+        ESIndexUtil.putReadOnlyToFalse(\"index_not_exists\");\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isAnyCurrentIndicesReadOnly()}\n+     * When: If at least one of the current working index if read only\n+     * Should: return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test()\n+    public void shouldReturnTrueWhenWorkingIndexIsReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getLive(), false);\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean anyCurrentIndicesReadOnly = ESIndexUtil.isAnyCurrentIndicesReadOnly();\n+            assertEquals(true, anyCurrentIndicesReadOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isAnyCurrentIndicesReadOnly()}\n+     * When: If at least one of the current live index if read only", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 141}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0ODYxMTY0", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-424861164", "createdAt": "2020-06-04T21:51:27Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo1MToyN1rOGfZR-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo1MToyN1rOGfZR-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3MzI0Mw==", "bodyText": "is read only", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435573243", "createdAt": "2020-06-04T21:51:27Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldPutReadonlyInTrue() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            ESIndexUtil.putReadOnlyToFalse(indiciesInfo.getWorking());\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, !readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     */\n+    @Test(expected = ElasticsearchStatusException.class)\n+    public void shouldTryPutReadonlyInTrueAndTheIndexDoesNotExists()  {\n+        ESIndexUtil.putReadOnlyToFalse(\"index_not_exists\");\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isAnyCurrentIndicesReadOnly()}\n+     * When: If at least one of the current working index if read only", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0ODYzODE0", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-424863814", "createdAt": "2020-06-04T21:56:47Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo1Njo0N1rOGfZZxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMTo1Njo0N1rOGfZZxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU3NTIzOA==", "bodyText": "is there another way to know when the monitor is ready? this sleep might cause a race condition", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r435575238", "createdAt": "2020-06-04T21:56:47Z", "author": {"login": "nollymar"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void init () {\n+        systemMessageEventUtilMock = mock(SystemMessageEventUtil.class);\n+        roleAPIMock = mock(RoleAPI.class);\n+\n+        esReadOnlyMonitor = ESReadOnlyMonitor.getInstance(systemMessageEventUtilMock, roleAPIMock);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If the LIVE and WORKING current index are not read only\n+     * Should: not sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldNotSendLargeMessage() throws DotDataException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        putReadOnly(indiciesInfo.getWorking(), false);\n+        putReadOnly(indiciesInfo.getLive(), false);\n+\n+        esReadOnlyMonitor.start(reindexEntry, cause);\n+\n+        verify(systemMessageEventUtilMock, never()).pushLargeMessage(any(), any());\n+\n+        assertEquals(false, ESIndexUtil.isReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If any of LIVE and WORKING current index are read only\n+     * Should: sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessage() throws DotDataException, DotSecurityException, InterruptedException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+            putReadOnly(indiciesInfo.getLive(), false);\n+\n+            esReadOnlyMonitor.start(reindexEntry, cause);\n+\n+            Thread.sleep(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTU5NTA4", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-425559508", "createdAt": "2020-06-05T19:14:41Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToxNDo0MVrOGf6Yzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToxNDo0MVrOGf6Yzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExNTY2Mw==", "bodyText": "I would rename to setReadOnly", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436115663", "createdAt": "2020-06-05T19:14:41Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,191 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.language.LanguageUtil;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void init () {\n+        systemMessageEventUtilMock = mock(SystemMessageEventUtil.class);\n+        roleAPIMock = mock(RoleAPI.class);\n+\n+        esReadOnlyMonitor = ESReadOnlyMonitor.getInstance(systemMessageEventUtilMock, roleAPIMock);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If the LIVE and WORKING current index are not read only\n+     * Should: not sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldNotSendLargeMessage() throws DotDataException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        putReadOnly(indiciesInfo.getWorking(), false);\n+        putReadOnly(indiciesInfo.getLive(), false);\n+\n+        esReadOnlyMonitor.start(reindexEntry, cause);\n+\n+        verify(systemMessageEventUtilMock, never()).pushLargeMessage(any(), any());\n+\n+        assertEquals(false, ESIndexUtil.isReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If any of LIVE and WORKING current index are read only\n+     * Should: sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessage() throws DotDataException, DotSecurityException, InterruptedException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+            putReadOnly(indiciesInfo.getLive(), false);\n+\n+            esReadOnlyMonitor.start(reindexEntry, cause);\n+\n+            Thread.sleep(100);\n+\n+            checkLargeMessageSent(indiciesInfo, user);\n+            assertEquals(false, ESIndexUtil.isReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(ReindexEntry, String)}\n+     * When: If call start again after the first call is finished\n+     * Should: should sent the message again\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessageTwice() throws DotDataException, DotSecurityException, InterruptedException {\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"cause\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+            putReadOnly(indiciesInfo.getLive(), false);\n+\n+            esReadOnlyMonitor.start(reindexEntry, cause);\n+            checkLargeMessageSent(indiciesInfo, user);\n+\n+            esReadOnlyMonitor.start(reindexEntry, cause);\n+            checkLargeMessageSent(indiciesInfo, user);\n+            assertEquals(false, ESIndexUtil.isReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    private void checkLargeMessageSent(IndiciesInfo indiciesInfo, User user) throws InterruptedException {\n+        Thread.sleep(100);\n+\n+        final SystemMessageBuilder messageReadonly = new SystemMessageBuilder()\n+                .setMessage(\"At least one of the Elasticsearch current indices are in read only mode\")\n+                .setSeverity(MessageSeverity.ERROR)\n+                .setType(MessageType.SIMPLE_MESSAGE)\n+                .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+        verify(systemMessageEventUtilMock).pushMessage(\n+                messageReadonly.create(),\n+                list(user.getUserId())\n+        );\n+\n+        final SystemMessageBuilder messageWriteModeAgain = new SystemMessageBuilder()\n+                .setMessage(\"Elasticsearch current indices are in write mode again\")\n+                .setSeverity(MessageSeverity.ERROR)\n+                .setType(MessageType.SIMPLE_MESSAGE)\n+                .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+        verify(systemMessageEventUtilMock).pushMessage(\n+                messageWriteModeAgain.create(),\n+                list(user.getUserId())\n+        );\n+    }\n+\n+    private static AcknowledgedResponse putReadOnly(final String indexName, final boolean value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 177}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTYzMjAx", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-425563201", "createdAt": "2020-06-05T19:21:21Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToyMToyMVrOGf6jnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToyMToyMVrOGf6jnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExODQzMQ==", "bodyText": "this line is not needed", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436118431", "createdAt": "2020-06-05T19:21:21Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTY0NTU0", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-425564554", "createdAt": "2020-06-05T19:23:38Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToyMzozOFrOGf6npQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToyMzozOFrOGf6npQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTQ2MQ==", "bodyText": "this doesn't seem a correct expected result based on the method's name...", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436119461", "createdAt": "2020-06-05T19:23:38Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTY0NzMx", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-425564731", "createdAt": "2020-06-05T19:23:59Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToyNDowMFrOGf6oLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToyNDowMFrOGf6oLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTU5OQ==", "bodyText": "looks like the expected escenario is wrong..", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436119599", "createdAt": "2020-06-05T19:24:00Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldPutReadonlyInTrue() throws DotDataException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 92}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTY0OTIw", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-425564920", "createdAt": "2020-06-05T19:24:20Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToyNDoyMFrOGf6ovA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxOToyNDoyMFrOGf6ovA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjExOTc0MA==", "bodyText": "assertFalse", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436119740", "createdAt": "2020-06-05T19:24:20Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESIndexUtilTest.java", "diffHunk": "@@ -0,0 +1,199 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+\n+public class ESIndexUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is not read only\n+     * Should:return false\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnFalseIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(false, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index is read only\n+     * Should:return true\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldReturnTrueIfTheCurrentIndicesAreReadOnly() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            putReadOnly(indiciesInfo.getWorking(), true);\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, readOnly);\n+        } finally {\n+            putReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#isReadOnly(String...)}\n+     * When: The Index not exists\n+     * Should: throw a {@link org.elasticsearch.ElasticsearchStatusException}\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test (expected = ElasticsearchStatusException.class)\n+    public void whenTheIndexNotExistsShouldThrowException() {\n+        final boolean readOnly = ESIndexUtil.isReadOnly(\"not_Exists\");\n+        assertEquals(true, readOnly);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESIndexUtil#putReadOnlyToFalse(String...)}\n+     * When: The index exists\n+     * Should: should set it to read only\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldPutReadonlyInTrue() throws DotDataException {\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        try {\n+            ESIndexUtil.putReadOnlyToFalse(indiciesInfo.getWorking());\n+\n+            final boolean readOnly = ESIndexUtil.isReadOnly(indiciesInfo.getWorking());\n+\n+            assertEquals(true, !readOnly);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 100}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTkwNTY4", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-425590568", "createdAt": "2020-06-05T20:00:24Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDowMDoyNFrOGf7vCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDowMDoyNFrOGf7vCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNzczOQ==", "bodyText": "missing description", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436137739", "createdAt": "2020-06-05T20:00:24Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/common/reindex/ReindexQueueAPITest.java", "diffHunk": "@@ -102,6 +106,61 @@ public void test_getFailedReindexRecords_shouldNotReturnAnyRecord() throws DotDa\n \n     }\n \n+    /**\n+     * Method to Test: {@link ReindexQueueAPIImpl#markAsFailed(ReindexEntry, String)}\n+     * When: Try to mark a reindex as fail\n+     * Should: Should call the {@link ReindexQueueFactory#markAsFailed(ReindexEntry, String)}\n+     *         and\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void markAsFailed() throws DotDataException {\n+\n+        final ReindexQueueFactory reindexQueueFactory = mock(ReindexQueueFactory.class);\n+        final ESReadOnlyMonitor esReadOnlyMonitor = mock(ESReadOnlyMonitor.class);\n+\n+        final ReindexQueueAPIImpl reindexQueueAPI = new ReindexQueueAPIImpl(reindexQueueFactory, esReadOnlyMonitor);\n+\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"Test Cause\";\n+\n+        reindexQueueAPI.markAsFailed(reindexEntry, cause);\n+\n+        verify(reindexQueueFactory).markAsFailed(reindexEntry, cause);\n+        verify(esReadOnlyMonitor).start(reindexEntry, cause);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ReindexQueueAPIImpl#markAsFailed(ReindexEntry, String)}\n+     * When: Try to mark a reindex as fail and the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTkxMDA1", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-425591005", "createdAt": "2020-06-05T20:01:12Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDowMToxMlrOGf7wYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDowMToxMlrOGf7wYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzODA4MA==", "bodyText": "incomplete description", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436138080", "createdAt": "2020-06-05T20:01:12Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/common/reindex/ReindexQueueAPITest.java", "diffHunk": "@@ -102,6 +106,61 @@ public void test_getFailedReindexRecords_shouldNotReturnAnyRecord() throws DotDa\n \n     }\n \n+    /**\n+     * Method to Test: {@link ReindexQueueAPIImpl#markAsFailed(ReindexEntry, String)}\n+     * When: Try to mark a reindex as fail\n+     * Should: Should call the {@link ReindexQueueFactory#markAsFailed(ReindexEntry, String)}\n+     *         and\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void markAsFailed() throws DotDataException {\n+\n+        final ReindexQueueFactory reindexQueueFactory = mock(ReindexQueueFactory.class);\n+        final ESReadOnlyMonitor esReadOnlyMonitor = mock(ESReadOnlyMonitor.class);\n+\n+        final ReindexQueueAPIImpl reindexQueueAPI = new ReindexQueueAPIImpl(reindexQueueFactory, esReadOnlyMonitor);\n+\n+        final ReindexEntry reindexEntry = mock(ReindexEntry.class);\n+        final String cause = \"Test Cause\";\n+\n+        reindexQueueAPI.markAsFailed(reindexEntry, cause);\n+\n+        verify(reindexQueueFactory).markAsFailed(reindexEntry, cause);\n+        verify(esReadOnlyMonitor).start(reindexEntry, cause);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ReindexQueueAPIImpl#markAsFailed(ReindexEntry, String)}\n+     * When: Try to mark a reindex as fail and the\n+     * Should: Should call the {@link ReindexQueueFactory#markAsFailed(ReindexEntry, String)}\n+     *         and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTkzNTg2", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-425593586", "createdAt": "2020-06-05T20:05:57Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDowNTo1N1rOGf73xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDowNTo1N1rOGf73xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTk3NA==", "bodyText": "Maybe we can remove this Logger", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436139974", "createdAt": "2020-06-05T20:05:57Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTk2MDc0", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-425596074", "createdAt": "2020-06-05T20:10:31Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoxMDozMVrOGf7-tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoxMDozMVrOGf7-tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MTc1MQ==", "bodyText": "rename to setLiveAndWorkingIndicesToWriteMode", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436141751", "createdAt": "2020-06-05T20:10:31Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");\n+\n+        return Arrays.stream(indexNames).anyMatch((indexName) -> {\n+            final String readOnlyAllowDelete = response.getSetting(indexName, READ_ONLY_ALLOW_DELETE_SETTING);\n+            final String readOnly = response.getSetting(indexName, READ_ONLY_SETTING);\n+\n+            return Boolean.parseBoolean(readOnlyAllowDelete) || Boolean.parseBoolean(readOnly);\n+        });\n+    }\n+\n+    public static AcknowledgedResponse putReadOnlyToFalse(final String... indexName) {\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(indexName);\n+\n+        final Settings.Builder settingBuilder = Settings.builder()\n+                .put(READ_ONLY_ALLOW_DELETE_SETTING, false)\n+                .put(READ_ONLY_SETTING, false);\n+\n+        request.settings(settingBuilder);\n+\n+        return Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .putSettings(request, RequestOptions.DEFAULT)\n+        );\n+    }\n+\n+    public static boolean isAnyCurrentIndicesReadOnly() {\n+        final IndiciesInfo indiciesInfo = loadIndicesInfo();\n+        return ESIndexUtil.isReadOnly(indiciesInfo.getLive(), indiciesInfo.getWorking());\n+    }\n+\n+    public static void putCurrentIndicesToWriteMode() throws ESResponseException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NTk4MzEw", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-425598310", "createdAt": "2020-06-05T20:14:44Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoxNDo0NFrOGf8FLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoxNDo0NFrOGf8FLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MzQwNg==", "bodyText": "rename to isEitherLiveOrWokingIndicesReadOnly", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436143406", "createdAt": "2020-06-05T20:14:44Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESIndexUtil.java", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.get.GetSettingsResponse;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+\n+public class ESIndexUtil {\n+    private final static String READ_ONLY_ALLOW_DELETE_SETTING = \"index.blocks.read_only_allow_delete\";\n+    private final static String READ_ONLY_SETTING = \"index.blocks.read_only\";\n+\n+    private ESIndexUtil(){}\n+\n+    public static  boolean isReadOnly(final String... indexNames) {\n+        final GetSettingsRequest request = new GetSettingsRequest().indices(indexNames);\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- Checking if current index are read only\");\n+\n+        final GetSettingsResponse response = Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .getSettings(request, RequestOptions.DEFAULT));\n+\n+        Logger.info(ESIndexUtil.class, Thread.currentThread().getName() + \"- RESPONSE Checking if current index are read only\");\n+\n+        return Arrays.stream(indexNames).anyMatch((indexName) -> {\n+            final String readOnlyAllowDelete = response.getSetting(indexName, READ_ONLY_ALLOW_DELETE_SETTING);\n+            final String readOnly = response.getSetting(indexName, READ_ONLY_SETTING);\n+\n+            return Boolean.parseBoolean(readOnlyAllowDelete) || Boolean.parseBoolean(readOnly);\n+        });\n+    }\n+\n+    public static AcknowledgedResponse putReadOnlyToFalse(final String... indexName) {\n+        final UpdateSettingsRequest request = new UpdateSettingsRequest(indexName);\n+\n+        final Settings.Builder settingBuilder = Settings.builder()\n+                .put(READ_ONLY_ALLOW_DELETE_SETTING, false)\n+                .put(READ_ONLY_SETTING, false);\n+\n+        request.settings(settingBuilder);\n+\n+        return Sneaky.sneak(() ->\n+                RestHighLevelClientProvider.getInstance().getClient().indices()\n+                        .putSettings(request, RequestOptions.DEFAULT)\n+        );\n+    }\n+\n+    public static boolean isAnyCurrentIndicesReadOnly() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NjAwNDI3", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-425600427", "createdAt": "2020-06-05T20:18:50Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoxODo1MFrOGf8Lew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoxODo1MFrOGf8Lew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0NTAxOQ==", "bodyText": "Please correct by using text from below:\n/**\n * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n * When setting write-mode fails it will retry after one minute.\n */", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436145019", "createdAt": "2020-06-05T20:18:50Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.concurrent.DotConcurrentFactory;\n+import com.dotcms.enterprise.LicenseUtil;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+\n+/**\n+ * Run a Monitor If the current indices are in read only mode and try to set them to write mode again.\n+ * When the set write mode fail it try again after one minute.\n+ */\n+public class ESReadOnlyMonitor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1NjA0NjA3", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-425604607", "createdAt": "2020-06-05T20:26:25Z", "commit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoyNjoyNVrOGf8X7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoyNjoyNVrOGf8X7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0ODIwNA==", "bodyText": "Use this message:  \"Live\" and \"Working\" indices are in write-mode again", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r436148204", "createdAt": "2020-06-05T20:26:25Z", "author": {"login": "dsilvam"}, "path": "dotCMS/src/main/webapp/WEB-INF/messages/Language.properties", "diffHunk": "@@ -4802,5 +4802,8 @@ Default-Action-Archive = Archive\n Default-Action-Unarchive = Unarchive\n Default-Action-Delete = Delete\n Default-Action-Destroy = Destroy\n+es.index.read.only.message = At least one of the Elasticsearch current indices are in read only mode\n+es.index.write.allow.message = Elasticsearch current indices are in write mode again", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bf0a53f796560307f7908e3992ac85bba031528"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc979e0e1d04475951dbb213b379b17022474a8e", "author": {"user": {"login": "freddyucv", "name": "Freddy Rodriguez"}}, "url": "https://github.com/dotCMS/core/commit/fc979e0e1d04475951dbb213b379b17022474a8e", "committedDate": "2020-06-05T23:33:55Z", "message": "#17842 Refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ced8270d9c33509b2d5000ddbdc7d4f6f91f6a59", "author": {"user": {"login": "freddyucv", "name": "Freddy Rodriguez"}}, "url": "https://github.com/dotCMS/core/commit/ced8270d9c33509b2d5000ddbdc7d4f6f91f6a59", "committedDate": "2020-06-08T14:23:04Z", "message": "removing vhange"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f73efded56b7c4bc77957cf6dbbabce11fbac17", "author": {"user": {"login": "freddyucv", "name": "Freddy Rodriguez"}}, "url": "https://github.com/dotCMS/core/commit/6f73efded56b7c4bc77957cf6dbbabce11fbac17", "committedDate": "2020-06-08T20:22:21Z", "message": "#17842 Refactoring"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NjAyMjkx", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-426602291", "createdAt": "2020-06-08T20:37:50Z", "commit": {"oid": "6f73efded56b7c4bc77957cf6dbbabce11fbac17"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NjMzODQ0", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-426633844", "createdAt": "2020-06-08T21:26:51Z", "commit": {"oid": "6f73efded56b7c4bc77957cf6dbbabce11fbac17"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2d22001f72149b37fbcdf76b852e1930d4e8084", "author": {"user": {"login": "freddyucv", "name": "Freddy Rodriguez"}}, "url": "https://github.com/dotCMS/core/commit/e2d22001f72149b37fbcdf76b852e1930d4e8084", "committedDate": "2020-06-08T21:45:41Z", "message": "#17842 Message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f669c19d37c101e1742103f506edf0121f613125", "author": {"user": {"login": "freddyucv", "name": "Freddy Rodriguez"}}, "url": "https://github.com/dotCMS/core/commit/f669c19d37c101e1742103f506edf0121f613125", "committedDate": "2020-06-08T23:32:18Z", "message": "#17842 Fixing test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437", "author": {"user": {"login": "freddyucv", "name": "Freddy Rodriguez"}}, "url": "https://github.com/dotCMS/core/commit/9790a598c2ce5dadb7258f312a7360c571552437", "committedDate": "2020-06-09T13:50:18Z", "message": "#17842 Fixing test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxNTU2", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191556", "createdAt": "2020-06-09T14:10:40Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0MFrOGhMCBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0MFrOGhMCBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzMxNw==", "bodyText": "Issue found: Assigning an Object to null is a code smell.  Consider refactoring.", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453317", "createdAt": "2020-06-09T14:10:40Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n+ * When setting write-mode fails it will retry after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI) {\n+        super();\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(\n+                SystemMessageEventUtil.getInstance(),\n+                APILocator.getRoleAPI()\n+        );\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final String message){\n+        if (this.start()) {\n+            Logger.error(this.getClass(), message);\n+        }\n+    }\n+\n+    /**\n+     * Start a {@link ESReadOnlyMonitor} is it is not started yet\n+     * @return false if a ESReadOnlyMonitor was started before\n+     */\n+    public boolean start(){\n+        if (started.compareAndSet(false, true)) {\n+            if (ElasticsearchUtil.isClusterInReadOnlyMode()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.cluster.read.only.message\");\n+                startClusterMonitor();\n+            } else if (ElasticsearchUtil.isEitherLiveOrWorkingIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startIndexMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final String message = LanguageUtil.get(messageKey);\n+\n+            final SystemMessageBuilder messageBuilder = new SystemMessageBuilder()\n+                    .setMessage(message)\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            Logger.error(ESReadOnlyMonitor.class, message);\n+            systemMessageEventUtil.pushMessage(messageBuilder.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+            ElasticsearchUtil.setLiveAndWorkingIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ElasticsearchResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void putClusterToWriteMode() {\n+        Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+        ElasticsearchUtil.setClusterToWriteMode();\n+        sendMessage(\"es.cluster.write.allow.message\");\n+        ReindexThread.setCurrentIndexReadOnly(false);\n+\n+        this.stop();\n+    }\n+\n+    private void startIndexMonitor() {\n+         schedule(new IndexMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void schedule(final TimerTask timerTask) {\n+        timer = new Timer(true);\n+        timer.schedule(timerTask, 0, TimeUnit.MINUTES.toMillis(1));\n+    }\n+\n+    private void startClusterMonitor() {\n+        schedule(new ClusterMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void stop() {\n+        if (this.timer != null) {\n+            this.timer.cancel();\n+            this.timer = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 162}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxNTgw", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191580", "createdAt": "2020-06-09T14:10:41Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0MVrOGhMCFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0MVrOGhMCFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzMzMw==", "bodyText": "Issue found: It is a good practice to call super() in a constructor", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453333", "createdAt": "2020-06-09T14:10:41Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n+ * When setting write-mode fails it will retry after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI) {\n+        super();\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(\n+                SystemMessageEventUtil.getInstance(),\n+                APILocator.getRoleAPI()\n+        );\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final String message){\n+        if (this.start()) {\n+            Logger.error(this.getClass(), message);\n+        }\n+    }\n+\n+    /**\n+     * Start a {@link ESReadOnlyMonitor} is it is not started yet\n+     * @return false if a ESReadOnlyMonitor was started before\n+     */\n+    public boolean start(){\n+        if (started.compareAndSet(false, true)) {\n+            if (ElasticsearchUtil.isClusterInReadOnlyMode()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.cluster.read.only.message\");\n+                startClusterMonitor();\n+            } else if (ElasticsearchUtil.isEitherLiveOrWorkingIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startIndexMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final String message = LanguageUtil.get(messageKey);\n+\n+            final SystemMessageBuilder messageBuilder = new SystemMessageBuilder()\n+                    .setMessage(message)\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            Logger.error(ESReadOnlyMonitor.class, message);\n+            systemMessageEventUtil.pushMessage(messageBuilder.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+            ElasticsearchUtil.setLiveAndWorkingIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ElasticsearchResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void putClusterToWriteMode() {\n+        Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+        ElasticsearchUtil.setClusterToWriteMode();\n+        sendMessage(\"es.cluster.write.allow.message\");\n+        ReindexThread.setCurrentIndexReadOnly(false);\n+\n+        this.stop();\n+    }\n+\n+    private void startIndexMonitor() {\n+         schedule(new IndexMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void schedule(final TimerTask timerTask) {\n+        timer = new Timer(true);\n+        timer.schedule(timerTask, 0, TimeUnit.MINUTES.toMillis(1));\n+    }\n+\n+    private void startClusterMonitor() {\n+        schedule(new ClusterMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void stop() {\n+        if (this.timer != null) {\n+            this.timer.cancel();\n+            this.timer = null;\n+            this.started.set(false);\n+        }\n+    }\n+\n+    private static class IndexMonitorTimerTask extends TimerTask{\n+        private final ESReadOnlyMonitor esReadOnlyMonitor;\n+\n+        IndexMonitorTimerTask(final ESReadOnlyMonitor esReadOnlyMonitor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 170}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxNTk1", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191595", "createdAt": "2020-06-09T14:10:42Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0MlrOGhMCJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0MlrOGhMCJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzM0OA==", "bodyText": "Issue found: Avoid unused imports such as 'org.mockito.Mockito'", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453348", "createdAt": "2020-06-09T14:10:42Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxNjEy", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191612", "createdAt": "2020-06-09T14:10:43Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0M1rOGhMCKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0M1rOGhMCKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzM1Mw==", "bodyText": "Issue found: Use block level rather than method level synchronization", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453353", "createdAt": "2020-06-09T14:10:43Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n+ * When setting write-mode fails it will retry after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI) {\n+        super();\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(\n+                SystemMessageEventUtil.getInstance(),\n+                APILocator.getRoleAPI()\n+        );\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final String message){\n+        if (this.start()) {\n+            Logger.error(this.getClass(), message);\n+        }\n+    }\n+\n+    /**\n+     * Start a {@link ESReadOnlyMonitor} is it is not started yet\n+     * @return false if a ESReadOnlyMonitor was started before\n+     */\n+    public boolean start(){\n+        if (started.compareAndSet(false, true)) {\n+            if (ElasticsearchUtil.isClusterInReadOnlyMode()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.cluster.read.only.message\");\n+                startClusterMonitor();\n+            } else if (ElasticsearchUtil.isEitherLiveOrWorkingIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startIndexMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final String message = LanguageUtil.get(messageKey);\n+\n+            final SystemMessageBuilder messageBuilder = new SystemMessageBuilder()\n+                    .setMessage(message)\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            Logger.error(ESReadOnlyMonitor.class, message);\n+            systemMessageEventUtil.pushMessage(messageBuilder.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+            ElasticsearchUtil.setLiveAndWorkingIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ElasticsearchResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void putClusterToWriteMode() {\n+        Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+        ElasticsearchUtil.setClusterToWriteMode();\n+        sendMessage(\"es.cluster.write.allow.message\");\n+        ReindexThread.setCurrentIndexReadOnly(false);\n+\n+        this.stop();\n+    }\n+\n+    private void startIndexMonitor() {\n+         schedule(new IndexMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void schedule(final TimerTask timerTask) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxNjQx", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191641", "createdAt": "2020-06-09T14:10:44Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0NFrOGhMCPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0NFrOGhMCPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzM3NA==", "bodyText": "Issue found: Use block level rather than method level synchronization", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453374", "createdAt": "2020-06-09T14:10:44Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n+ * When setting write-mode fails it will retry after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI) {\n+        super();\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(\n+                SystemMessageEventUtil.getInstance(),\n+                APILocator.getRoleAPI()\n+        );\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final String message){\n+        if (this.start()) {\n+            Logger.error(this.getClass(), message);\n+        }\n+    }\n+\n+    /**\n+     * Start a {@link ESReadOnlyMonitor} is it is not started yet\n+     * @return false if a ESReadOnlyMonitor was started before\n+     */\n+    public boolean start(){\n+        if (started.compareAndSet(false, true)) {\n+            if (ElasticsearchUtil.isClusterInReadOnlyMode()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.cluster.read.only.message\");\n+                startClusterMonitor();\n+            } else if (ElasticsearchUtil.isEitherLiveOrWorkingIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startIndexMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final String message = LanguageUtil.get(messageKey);\n+\n+            final SystemMessageBuilder messageBuilder = new SystemMessageBuilder()\n+                    .setMessage(message)\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            Logger.error(ESReadOnlyMonitor.class, message);\n+            systemMessageEventUtil.pushMessage(messageBuilder.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+            ElasticsearchUtil.setLiveAndWorkingIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ElasticsearchResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void putClusterToWriteMode() {\n+        Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+        ElasticsearchUtil.setClusterToWriteMode();\n+        sendMessage(\"es.cluster.write.allow.message\");\n+        ReindexThread.setCurrentIndexReadOnly(false);\n+\n+        this.stop();\n+    }\n+\n+    private void startIndexMonitor() {\n+         schedule(new IndexMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void schedule(final TimerTask timerTask) {\n+        timer = new Timer(true);\n+        timer.schedule(timerTask, 0, TimeUnit.MINUTES.toMillis(1));\n+    }\n+\n+    private void startClusterMonitor() {\n+        schedule(new ClusterMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void stop() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 159}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxNjYz", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191663", "createdAt": "2020-06-09T14:10:45Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0NVrOGhMCTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0NVrOGhMCTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzM4OQ==", "bodyText": "Issue found: Avoid unused imports such as 'org.elasticsearch.ElasticsearchStatusException'", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453389", "createdAt": "2020-06-09T14:10:45Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtil.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import io.vavr.control.Try;\n+import org.elasticsearch.ElasticsearchStatusException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxNjgy", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191682", "createdAt": "2020-06-09T14:10:46Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0NlrOGhMCXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0NlrOGhMCXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQwNw==", "bodyText": "Issue found: Classes implementing Serializable should set a serialVersionUID", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453407", "createdAt": "2020-06-09T14:10:46Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ElasticsearchResponseException.java", "diffHunk": "@@ -0,0 +1,19 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+\n+/**\n+ * Throw when a Elasticsearch request fail\n+ */\n+public class ElasticsearchResponseException extends Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxNjk3", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191697", "createdAt": "2020-06-09T14:10:47Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0N1rOGhMCaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0N1rOGhMCaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQxOQ==", "bodyText": "Issue found: Avoid unused imports such as 'com.dotmarketing.exception.DotRuntimeException'", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453419", "createdAt": "2020-06-09T14:10:47Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESContentletAPIImplTest.java", "diffHunk": "@@ -27,6 +30,7 @@\n import com.dotmarketing.beans.Permission;\n import com.dotmarketing.business.*;\n import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxNzE5", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191719", "createdAt": "2020-06-09T14:10:48Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0OFrOGhMCeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0OFrOGhMCeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQzMw==", "bodyText": "Issue found: The String literal \"message\" appears 5 times in this file; the first occurrence is on line 61", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453433", "createdAt": "2020-06-09T14:10:48Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void init () {\n+        systemMessageEventUtilMock = mock(SystemMessageEventUtil.class);\n+        roleAPIMock = mock(RoleAPI.class);\n+\n+        esReadOnlyMonitor = ESReadOnlyMonitor.getInstance(systemMessageEventUtilMock, roleAPIMock);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(String)}\n+     * When: If the LIVE and WORKING current index are not read only\n+     * Should: not sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldNotSendLargeMessage() throws DotDataException, IOException {\n+        final String message = \"message\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxNzM2", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191736", "createdAt": "2020-06-09T14:10:49Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0OVrOGhMCgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo0OVrOGhMCgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQ0Mg==", "bodyText": "Issue found: This statement should have braces", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453442", "createdAt": "2020-06-09T14:10:49Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/api/system/event/message/builder/SystemMessage.java", "diffHunk": "@@ -67,4 +69,23 @@ public String toString() {\n                 \", type=\" + type +\n                 '}';\n     }\n+\n+    @Override\n+    public boolean equals(final Object another) {\n+        if (this == another) return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxNzUz", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191753", "createdAt": "2020-06-09T14:10:50Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1MVrOGhMCjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1MVrOGhMCjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQ1Mg==", "bodyText": "Issue found: It is a good practice to call super() in a constructor", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453452", "createdAt": "2020-06-09T14:10:51Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;\n+import com.dotmarketing.common.reindex.ReindexThread;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.dotmarketing.util.Logger;\n+import com.liferay.portal.language.LanguageException;\n+import com.liferay.portal.language.LanguageUtil;\n+\n+import java.util.List;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This monitor is run when either the Live or Working indices are in read-only mode.  It attempts to set both Live and Working indices to write mode again.\n+ * When setting write-mode fails it will retry after one minute.\n+ */\n+public class ESReadOnlyMonitor {\n+    private final RoleAPI roleAPI;\n+    private final SystemMessageEventUtil systemMessageEventUtil;\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private Timer timer;\n+\n+    private ESReadOnlyMonitor(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI) {\n+        super();\n+        this.systemMessageEventUtil = systemMessageEventUtil;\n+        this.roleAPI = roleAPI;\n+        started.set(false);\n+    }\n+\n+    private ESReadOnlyMonitor() {\n+        this(\n+                SystemMessageEventUtil.getInstance(),\n+                APILocator.getRoleAPI()\n+        );\n+    }\n+\n+    // Inner class to provide instance of class\n+    private static class Singleton\n+    {\n+        private static final ESReadOnlyMonitor INSTANCE = new ESReadOnlyMonitor();\n+    }\n+\n+    @VisibleForTesting\n+    public static ESReadOnlyMonitor getInstance(\n+            final SystemMessageEventUtil systemMessageEventUtil,\n+            final RoleAPI roleAPI)\n+    {\n+        return new ESReadOnlyMonitor(systemMessageEventUtil, roleAPI);\n+    }\n+    public static ESReadOnlyMonitor getInstance()\n+    {\n+        return Singleton.INSTANCE;\n+    }\n+\n+    public void start(final String message){\n+        if (this.start()) {\n+            Logger.error(this.getClass(), message);\n+        }\n+    }\n+\n+    /**\n+     * Start a {@link ESReadOnlyMonitor} is it is not started yet\n+     * @return false if a ESReadOnlyMonitor was started before\n+     */\n+    public boolean start(){\n+        if (started.compareAndSet(false, true)) {\n+            if (ElasticsearchUtil.isClusterInReadOnlyMode()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.cluster.read.only.message\");\n+                startClusterMonitor();\n+            } else if (ElasticsearchUtil.isEitherLiveOrWorkingIndicesReadOnly()) {\n+                ReindexThread.setCurrentIndexReadOnly(true);\n+                sendMessage(\"es.index.read.only.message\");\n+                startIndexMonitor();\n+            } else {\n+                started.set(false);\n+            }\n+\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    private void sendMessage(final String messageKey) {\n+        try {\n+            final Role adminRole = roleAPI.loadCMSAdminRole();\n+            final List<String> usersId = roleAPI.findUsersForRole(adminRole)\n+                    .stream()\n+                    .map(user -> user.getUserId())\n+                    .collect(Collectors.toList());\n+\n+            final String message = LanguageUtil.get(messageKey);\n+\n+            final SystemMessageBuilder messageBuilder = new SystemMessageBuilder()\n+                    .setMessage(message)\n+                    .setSeverity(MessageSeverity.ERROR)\n+                    .setType(MessageType.SIMPLE_MESSAGE)\n+                    .setLife(TimeUnit.SECONDS.toMillis(5));\n+\n+            Logger.error(ESReadOnlyMonitor.class, message);\n+            systemMessageEventUtil.pushMessage(messageBuilder.create(), usersId);\n+        } catch (final LanguageException | DotDataException | DotSecurityException e) {\n+            Logger.warn(ESReadOnlyMonitor.class, () -> e.getMessage());\n+        }\n+    }\n+\n+    private void putCurrentIndicesToWriteMode() {\n+        try {\n+            Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+            ElasticsearchUtil.setLiveAndWorkingIndicesToWriteMode();\n+            sendMessage(\"es.index.write.allow.message\");\n+            ReindexThread.setCurrentIndexReadOnly(false);\n+\n+            this.stop();\n+        } catch (final ElasticsearchResponseException e) {\n+            Logger.info(ESReadOnlyMonitor.class, ()  -> e.getMessage());\n+        }\n+    }\n+\n+    private void putClusterToWriteMode() {\n+        Logger.debug(this.getClass(), () -> \"Trying to set the current indices to Write mode\");\n+        ElasticsearchUtil.setClusterToWriteMode();\n+        sendMessage(\"es.cluster.write.allow.message\");\n+        ReindexThread.setCurrentIndexReadOnly(false);\n+\n+        this.stop();\n+    }\n+\n+    private void startIndexMonitor() {\n+         schedule(new IndexMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void schedule(final TimerTask timerTask) {\n+        timer = new Timer(true);\n+        timer.schedule(timerTask, 0, TimeUnit.MINUTES.toMillis(1));\n+    }\n+\n+    private void startClusterMonitor() {\n+        schedule(new ClusterMonitorTimerTask(this));\n+    }\n+\n+    private synchronized void stop() {\n+        if (this.timer != null) {\n+            this.timer.cancel();\n+            this.timer = null;\n+            this.started.set(false);\n+        }\n+    }\n+\n+    private static class IndexMonitorTimerTask extends TimerTask{\n+        private final ESReadOnlyMonitor esReadOnlyMonitor;\n+\n+        IndexMonitorTimerTask(final ESReadOnlyMonitor esReadOnlyMonitor) {\n+            this.esReadOnlyMonitor = esReadOnlyMonitor;\n+        }\n+\n+        @Override\n+        public void run() {\n+            this.esReadOnlyMonitor.putCurrentIndicesToWriteMode();\n+        }\n+    }\n+\n+    private static class ClusterMonitorTimerTask extends TimerTask{\n+        private final ESReadOnlyMonitor esReadOnlyMonitor;\n+\n+        ClusterMonitorTimerTask(final ESReadOnlyMonitor esReadOnlyMonitor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 183}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxNzY4", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191768", "createdAt": "2020-06-09T14:10:52Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1MlrOGhMCmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1MlrOGhMCmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQ2NA==", "bodyText": "Issue found: Avoid unused imports such as 'org.jgroups.util.Util.assertEquals'", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453464", "createdAt": "2020-06-09T14:10:52Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtilTest.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static org.jgroups.util.Util.assertEquals;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxNzg5", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191789", "createdAt": "2020-06-09T14:10:53Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1M1rOGhMCow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1M1rOGhMCow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQ3NQ==", "bodyText": "Issue found: Avoid unused imports such as 'com.dotmarketing.common.reindex.ReindexEntry'", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453475", "createdAt": "2020-06-09T14:10:53Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitor.java", "diffHunk": "@@ -0,0 +1,192 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.repackage.com.google.common.annotations.VisibleForTesting;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.common.reindex.ReindexEntry;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxODEw", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191810", "createdAt": "2020-06-09T14:10:53Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1NFrOGhMCsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1NFrOGhMCsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzQ4OQ==", "bodyText": "Issue found: Use assertTrue(x)/assertFalse(x) instead of assertEquals(true, x)/assertEquals(false, x) or assertEquals(Boolean.TRUE, x)/assertEquals(Boolean.FALSE, x).", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453489", "createdAt": "2020-06-09T14:10:54Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void init () {\n+        systemMessageEventUtilMock = mock(SystemMessageEventUtil.class);\n+        roleAPIMock = mock(RoleAPI.class);\n+\n+        esReadOnlyMonitor = ESReadOnlyMonitor.getInstance(systemMessageEventUtilMock, roleAPIMock);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(String)}\n+     * When: If the LIVE and WORKING current index are not read only\n+     * Should: not sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldNotSendLargeMessage() throws DotDataException, IOException {\n+        final String message = \"message\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        setReadOnly(indiciesInfo.getWorking(), false);\n+        setReadOnly(indiciesInfo.getLive(), false);\n+\n+        esReadOnlyMonitor.start(message);\n+\n+        verify(systemMessageEventUtilMock, never()).pushLargeMessage(any(), any());\n+\n+        assertEquals(false, ElasticsearchUtil.isAnyReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(String)}\n+     * When: If any of LIVE and WORKING current index are read only\n+     * Should: sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessage() throws DotDataException, DotSecurityException, InterruptedException, IOException {\n+        final String message = \"message\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            setReadOnly(indiciesInfo.getWorking(), true);\n+            setReadOnly(indiciesInfo.getLive(), false);\n+\n+            esReadOnlyMonitor.start(message);\n+\n+            Thread.sleep(100);\n+\n+            checkLargeMessageSent(user);\n+            assertEquals(false, ElasticsearchUtil.isAnyReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));\n+        } finally {\n+            setReadOnly(indiciesInfo.getWorking(), false);\n+        }\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start()}\n+     * When: If the cluster is read only\n+     * Should: sent message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldSendLargeMessageIfTheClusterIsInReadOnly() throws DotDataException, DotSecurityException, InterruptedException, IOException {\n+        final String message = \"message\";\n+\n+        final Role adminRole = mock(Role.class);\n+        when(roleAPIMock.loadCMSAdminRole()).thenReturn(adminRole);\n+\n+        final User user = mock(User.class);\n+        when(user.getUserId()).thenReturn(\"1\");\n+\n+        when(roleAPIMock.findUsersForRole(adminRole)).thenReturn(list(user));\n+\n+        try {\n+            setClusterAsReadOnly(true);\n+\n+            esReadOnlyMonitor.start(message);\n+\n+            Thread.sleep(100);\n+\n+            checkClusterLargeMessageSent(user);\n+            assertEquals(false, ElasticsearchUtil.isClusterInReadOnlyMode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxODI5", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191829", "createdAt": "2020-06-09T14:10:54Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1NVrOGhMCvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1NVrOGhMCvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzUwMw==", "bodyText": "Issue found: Avoid unused imports such as 'org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest'", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453503", "createdAt": "2020-06-09T14:10:55Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESContentletAPIImplTest.java", "diffHunk": "@@ -48,6 +52,12 @@\n import java.util.Date;\n import java.util.List;\n \n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxODYy", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191862", "createdAt": "2020-06-09T14:10:56Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1NlrOGhMC3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1NlrOGhMC3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzUzMw==", "bodyText": "Issue found: Avoid unused imports such as 'org.mockito.Mockito'", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453533", "createdAt": "2020-06-09T14:10:56Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotmarketing/common/reindex/ReindexQueueAPITest.java", "diffHunk": "@@ -5,7 +5,9 @@\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertNotNull;\n import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxODgw", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191880", "createdAt": "2020-06-09T14:10:57Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1OFrOGhMC6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1OFrOGhMC6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzU0Nw==", "bodyText": "Issue found: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453547", "createdAt": "2020-06-09T14:10:58Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxODk1", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191895", "createdAt": "2020-06-09T14:10:58Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1OFrOGhMC9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMDo1OFrOGhMC9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzU1OQ==", "bodyText": "Issue found: A method/constructor should not explicitly throw java.lang.Exception", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453559", "createdAt": "2020-06-09T14:10:58Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtilTest.java", "diffHunk": "@@ -0,0 +1,264 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.ElasticsearchStatusException;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.BeforeClass;\n+import com.dotcms.util.IntegrationTestInitService;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static org.jgroups.util.Util.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class ElasticsearchUtilTest {\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxOTEy", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191912", "createdAt": "2020-06-09T14:10:59Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMTowMFrOGhMDBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMTowMFrOGhMDBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzU3Mw==", "bodyText": "Issue found: Use assertTrue(x)/assertFalse(x) instead of assertEquals(true, x)/assertEquals(false, x) or assertEquals(Boolean.TRUE, x)/assertEquals(Boolean.FALSE, x).", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453573", "createdAt": "2020-06-09T14:11:00Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/integration-test/java/com/dotcms/content/elasticsearch/business/ESReadOnlyMonitorTest.java", "diffHunk": "@@ -0,0 +1,317 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.api.system.event.message.MessageSeverity;\n+import com.dotcms.api.system.event.message.MessageType;\n+import com.dotcms.api.system.event.message.SystemMessageEventUtil;\n+import com.dotcms.api.system.event.message.builder.SystemMessageBuilder;\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotcms.util.IntegrationTestInitService;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.business.Role;\n+import com.dotmarketing.business.RoleAPI;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotSecurityException;\n+import com.liferay.portal.model.User;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import org.elasticsearch.action.admin.cluster.settings.ClusterUpdateSettingsRequest;\n+import org.elasticsearch.action.admin.indices.settings.put.UpdateSettingsRequest;\n+import org.elasticsearch.action.support.master.AcknowledgedResponse;\n+import org.elasticsearch.client.RequestOptions;\n+import org.elasticsearch.common.settings.Settings;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.dotcms.util.CollectionsUtils.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.Mockito.*;\n+\n+public class ESReadOnlyMonitorTest {\n+\n+    private static ESReadOnlyMonitor esReadOnlyMonitor;\n+    private SystemMessageEventUtil systemMessageEventUtilMock;\n+    private RoleAPI roleAPIMock;\n+\n+    @BeforeClass\n+    public static void prepare () throws Exception {\n+        //Setting web app environment\n+        IntegrationTestInitService.getInstance().init();\n+    }\n+\n+    @Before\n+    public void init () {\n+        systemMessageEventUtilMock = mock(SystemMessageEventUtil.class);\n+        roleAPIMock = mock(RoleAPI.class);\n+\n+        esReadOnlyMonitor = ESReadOnlyMonitor.getInstance(systemMessageEventUtilMock, roleAPIMock);\n+    }\n+\n+    /**\n+     * Method to Test: {@link ESReadOnlyMonitor#start(String)}\n+     * When: If the LIVE and WORKING current index are not read only\n+     * Should: not sent large message\n+     *\n+     * @throws DotDataException\n+     */\n+    @Test\n+    public void shouldNotSendLargeMessage() throws DotDataException, IOException {\n+        final String message = \"message\";\n+\n+        final IndiciesInfo indiciesInfo = APILocator.getIndiciesAPI().loadIndicies();\n+\n+        setReadOnly(indiciesInfo.getWorking(), false);\n+        setReadOnly(indiciesInfo.getLive(), false);\n+\n+        esReadOnlyMonitor.start(message);\n+\n+        verify(systemMessageEventUtilMock, never()).pushLargeMessage(any(), any());\n+\n+        assertEquals(false, ElasticsearchUtil.isAnyReadOnly(indiciesInfo.getWorking(), indiciesInfo.getLive()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 72}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxOTM5", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191939", "createdAt": "2020-06-09T14:11:01Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMTowMVrOGhMDGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMTowMVrOGhMDGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzU5NA==", "bodyText": "Issue found: Avoid unused imports such as 'io.vavr.control.Try'", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453594", "createdAt": "2020-06-09T14:11:01Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/content/elasticsearch/business/ElasticsearchUtil.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.dotcms.content.elasticsearch.business;\n+\n+import com.dotcms.content.elasticsearch.util.RestHighLevelClientProvider;\n+import com.dotmarketing.business.APILocator;\n+import com.dotmarketing.exception.DotDataException;\n+import com.dotmarketing.exception.DotRuntimeException;\n+import com.dotmarketing.util.Logger;\n+import com.rainerhahnekamp.sneakythrow.Sneaky;\n+import io.vavr.control.Try;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3MTkxOTYx", "url": "https://github.com/dotCMS/core/pull/18604#pullrequestreview-427191961", "createdAt": "2020-06-09T14:11:02Z", "commit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMTowMlrOGhMDKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDoxMTowMlrOGhMDKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ1MzYwOA==", "bodyText": "Issue found: This statement should have braces", "url": "https://github.com/dotCMS/core/pull/18604#discussion_r437453608", "createdAt": "2020-06-09T14:11:02Z", "author": {"login": "dev-dotcms"}, "path": "dotCMS/src/main/java/com/dotcms/api/system/event/message/builder/SystemMessage.java", "diffHunk": "@@ -67,4 +69,23 @@ public String toString() {\n                 \", type=\" + type +\n                 '}';\n     }\n+\n+    @Override\n+    public boolean equals(final Object another) {\n+        if (this == another) return true;\n+        if (another == null || getClass() != another.getClass()) return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9790a598c2ce5dadb7258f312a7360c571552437"}, "originalPosition": 17}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 904, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}