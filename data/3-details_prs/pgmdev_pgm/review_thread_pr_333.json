{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4Njg2MDEz", "number": 333, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjo0OTo0N1rODigYOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwODoxOTowM1rODi-lxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTA4NjY2OnYy", "diffSide": "RIGHT", "path": "src/main/i18n/templates/strings.properties", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjo0OTo0N1rOFtyutw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjo0OTo0N1rOFtyutw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2MTM5OQ==", "bodyText": "This type of thing doesn't need a translation. Just append the \"[\" and \"]\" to the translated part.", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383561399", "createdAt": "2020-02-24T22:49:47Z", "author": {"login": "Electroid"}, "path": "src/main/i18n/templates/strings.properties", "diffHunk": "@@ -898,3 +898,57 @@ observer.tools.visibility.hidden = Hidden\n # {1} = List of staff players\n moderation.staff.name = Online Staff ({0}): {1}\n moderation.staff.empty = No staff online :(\n+\n+# {0} = Name of punishment type\n+moderation.punishment.prefix = [{0}]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTA4NzkzOnYy", "diffSide": "RIGHT", "path": "src/main/i18n/templates/strings.properties", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjo1MDoxOVrOFtyvew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjo1MDoxOVrOFtyvew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2MTU5NQ==", "bodyText": "Kind of looks weird.. can this just be Ban?", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383561595", "createdAt": "2020-02-24T22:50:19Z", "author": {"login": "Electroid"}, "path": "src/main/i18n/templates/strings.properties", "diffHunk": "@@ -898,3 +898,57 @@ observer.tools.visibility.hidden = Hidden\n # {1} = List of staff players\n moderation.staff.name = Online Staff ({0}): {1}\n moderation.staff.empty = No staff online :(\n+\n+# {0} = Name of punishment type\n+moderation.punishment.prefix = [{0}]\n+\n+# {0} = Reason for punishment\n+moderation.screen.kick = You were kicked for {0}\n+moderation.screen.ban = You were banned for {0}\n+moderation.screen.temp_ban = You were temporarily banned for {0}\n+\n+# {0} = Formatted date of expiry\n+moderation.screen.banExpire = Expires on {0}\n+\n+moderation.screen.rulesLink = Please review our rules at {0}\n+\n+# {0} = Name of staff member \n+moderation.screen.signoff = Issued by {0}\n+\n+# {0} = Time until the ban expires\n+moderation.screen.expires = Expires in {0}\n+\n+moderation.warning = WARNING\n+\n+moderation.mute.message = You have been muted and are unable to send chat messages.\n+\n+# {0} = Name of muted player\n+moderation.mute.existing = {0} is already muted!\n+\n+moderation.type.kick = Kick\n+moderation.type.mute = Mute\n+moderation.type.warn = Warn\n+moderation.type.ban = Ban\n+moderation.type.temp_ban = Temp-Ban", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTA4OTA0OnYy", "diffSide": "RIGHT", "path": "src/main/i18n/templates/strings.properties", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjo1MDo0OFrOFtywLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjo1MDo0OFrOFtywLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2MTc3NA==", "bodyText": "Also should not be a translation string.", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383561774", "createdAt": "2020-02-24T22:50:48Z", "author": {"login": "Electroid"}, "path": "src/main/i18n/templates/strings.properties", "diffHunk": "@@ -898,3 +898,57 @@ observer.tools.visibility.hidden = Hidden\n # {1} = List of staff players\n moderation.staff.name = Online Staff ({0}): {1}\n moderation.staff.empty = No staff online :(\n+\n+# {0} = Name of punishment type\n+moderation.punishment.prefix = [{0}]\n+\n+# {0} = Reason for punishment\n+moderation.screen.kick = You were kicked for {0}\n+moderation.screen.ban = You were banned for {0}\n+moderation.screen.temp_ban = You were temporarily banned for {0}\n+\n+# {0} = Formatted date of expiry\n+moderation.screen.banExpire = Expires on {0}\n+\n+moderation.screen.rulesLink = Please review our rules at {0}\n+\n+# {0} = Name of staff member \n+moderation.screen.signoff = Issued by {0}\n+\n+# {0} = Time until the ban expires\n+moderation.screen.expires = Expires in {0}\n+\n+moderation.warning = WARNING\n+\n+moderation.mute.message = You have been muted and are unable to send chat messages.\n+\n+# {0} = Name of muted player\n+moderation.mute.existing = {0} is already muted!\n+\n+moderation.type.kick = Kick\n+moderation.type.mute = Mute\n+moderation.type.warn = Warn\n+moderation.type.ban = Ban\n+moderation.type.temp_ban = Temp-Ban\n+\n+# {0} = Name of unmuted target\n+moderation.unmute.sender = You have unmuted {0}\n+moderation.unmute.target = You have been unmuted and may now send messages\n+\n+# {0} = Name of target\n+moderation.unmute.none = {0} is not muted.\n+\n+moderation.reports.none = There have been no recent reports!\n+\n+# {0} = Amount of recent reports\n+# {1} = Page number\n+moderation.reports.header = Recent Reports ({0}) \ufffd {1}\n+\n+# {0} = Index of report\n+# {1} = Name of player reported\n+# {2} = Reason for report\n+moderation.reports.format = {0}: {1} \ufffd {2}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTA5MDM2OnYy", "diffSide": "RIGHT", "path": "src/main/i18n/templates/strings.properties", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjo1MToxMVrOFtyw6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjo1MToxMVrOFtyw6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2MTk2Mw==", "bodyText": "Only the \"Recent Reports\" should be in the translation string. The rest is hard coded.", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383561963", "createdAt": "2020-02-24T22:51:11Z", "author": {"login": "Electroid"}, "path": "src/main/i18n/templates/strings.properties", "diffHunk": "@@ -898,3 +898,57 @@ observer.tools.visibility.hidden = Hidden\n # {1} = List of staff players\n moderation.staff.name = Online Staff ({0}): {1}\n moderation.staff.empty = No staff online :(\n+\n+# {0} = Name of punishment type\n+moderation.punishment.prefix = [{0}]\n+\n+# {0} = Reason for punishment\n+moderation.screen.kick = You were kicked for {0}\n+moderation.screen.ban = You were banned for {0}\n+moderation.screen.temp_ban = You were temporarily banned for {0}\n+\n+# {0} = Formatted date of expiry\n+moderation.screen.banExpire = Expires on {0}\n+\n+moderation.screen.rulesLink = Please review our rules at {0}\n+\n+# {0} = Name of staff member \n+moderation.screen.signoff = Issued by {0}\n+\n+# {0} = Time until the ban expires\n+moderation.screen.expires = Expires in {0}\n+\n+moderation.warning = WARNING\n+\n+moderation.mute.message = You have been muted and are unable to send chat messages.\n+\n+# {0} = Name of muted player\n+moderation.mute.existing = {0} is already muted!\n+\n+moderation.type.kick = Kick\n+moderation.type.mute = Mute\n+moderation.type.warn = Warn\n+moderation.type.ban = Ban\n+moderation.type.temp_ban = Temp-Ban\n+\n+# {0} = Name of unmuted target\n+moderation.unmute.sender = You have unmuted {0}\n+moderation.unmute.target = You have been unmuted and may now send messages\n+\n+# {0} = Name of target\n+moderation.unmute.none = {0} is not muted.\n+\n+moderation.reports.none = There have been no recent reports!\n+\n+# {0} = Amount of recent reports\n+# {1} = Page number\n+moderation.reports.header = Recent Reports ({0}) \ufffd {1}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTA5MTkyOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/named/NameStyle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjo1MTo0OFrOFtyx3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMzo0ODoxMVrOFtz-CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2MjIwNg==", "bodyText": "Do we really need this? Why not just use VERBOSE ?", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383562206", "createdAt": "2020-02-24T22:51:48Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/named/NameStyle.java", "diffHunk": "@@ -12,7 +12,8 @@\n   TAB(\n       true, true, true, true, true, false, true,\n       true), // Color, flair, friend status, nick status, death status\n-  VERBOSE(true, true, true, true, true, true, false, true); // Fancy plus nickname\n+  VERBOSE(true, true, true, true, true, true, false, true), // Fancy plus nickname\n+  CONCISE(true, true, true, true, true, true, false, false); // Verbose, but removes teleport", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MTcwNQ==", "bodyText": "If you're getting banned or kicked, a \"teleport to this player\" makes no sense", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383581705", "createdAt": "2020-02-24T23:48:11Z", "author": {"login": "Pablete1234"}, "path": "src/main/java/tc/oc/named/NameStyle.java", "diffHunk": "@@ -12,7 +12,8 @@\n   TAB(\n       true, true, true, true, true, false, true,\n       true), // Color, flair, friend status, nick status, death status\n-  VERBOSE(true, true, true, true, true, true, false, true); // Fancy plus nickname\n+  VERBOSE(true, true, true, true, true, true, false, true), // Fancy plus nickname\n+  CONCISE(true, true, true, true, true, true, false, false); // Verbose, but removes teleport", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2MjIwNg=="}, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTA5Njc0OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/api/Permissions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjo1Mzo0MFrOFty02w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMzowMzoyNlrOFtzDxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2Mjk3MQ==", "bodyText": "No need for a MODERATION, just do String KICK = ROOT + \".kick\";", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383562971", "createdAt": "2020-02-24T22:53:40Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/api/Permissions.java", "diffHunk": "@@ -31,6 +31,13 @@\n   String STAFF = ROOT + \".staff\"; // Considered apart of the staff team\n   String RELOAD = ROOT + \".reload\"; // Reload the PGM configuration\n \n+  // Individual permissions related to moderation\n+  String MODERATION = ROOT + \".moderation\"; // General node for moderation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2Njc5MA==", "bodyText": "Also make sure MOD has these permissions as default.", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383566790", "createdAt": "2020-02-24T23:03:26Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/api/Permissions.java", "diffHunk": "@@ -31,6 +31,13 @@\n   String STAFF = ROOT + \".staff\"; // Considered apart of the staff team\n   String RELOAD = ROOT + \".reload\"; // Reload the PGM configuration\n \n+  // Individual permissions related to moderation\n+  String MODERATION = ROOT + \".moderation\"; // General node for moderation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2Mjk3MQ=="}, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTEwMjk3OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/community/ModerationCommands.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjo1NjowOVrOFty4qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMzo1NDoxOVrOFt0Ftg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2Mzk0Nw==", "bodyText": "Not sure what the -w flag does, it's ambiguous.", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383563947", "createdAt": "2020-02-24T22:56:09Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/community/ModerationCommands.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package tc.oc.pgm.community;\n+\n+import app.ashcon.intake.Command;\n+import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Text;\n+import com.google.common.collect.Lists;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.BanList;\n+import org.bukkit.Bukkit;\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+import tc.oc.component.Component;\n+import tc.oc.component.render.ComponentRenderers;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.component.types.PersonalizedTranslatable;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.chat.Sound;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.events.PlayerPunishmentEvent;\n+import tc.oc.pgm.events.PlayerTimedPunishmentEvent;\n+import tc.oc.pgm.listeners.ChatDispatcher;\n+import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n+import tc.oc.util.components.PeriodFormats;\n+\n+public class ModerationCommands {\n+\n+  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n+\n+  private static final Component WARN_SYMBOL =\n+      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n+  private static final Component BROADCAST_DIV =\n+      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n+  private static final Component CONSOLE_NAME =\n+      new PersonalizedTranslatable(\"console\")\n+          .getPersonalizedText()\n+          .color(ChatColor.DARK_AQUA)\n+          .italic(true);\n+\n+  private final ChatDispatcher chat;\n+\n+  public ModerationCommands(ChatDispatcher chat) {\n+    this.chat = chat;\n+  }\n+\n+  @Command(\n+      aliases = {\"staff\", \"mods\", \"admins\"},\n+      desc = \"List the online staff members\")\n+  public void staff(CommandSender sender, Match match) {\n+    // List of online staff based off of permission\n+    List<Component> onlineStaff =\n+        match.getPlayers().stream()\n+            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n+            .map(player -> player.getStyledName(NameStyle.FANCY))\n+            .collect(Collectors.toList());\n+\n+    // FORMAT: Online Staff ({count}): {names}\n+    Component staffCount =\n+        new PersonalizedText(Integer.toString(onlineStaff.size()))\n+            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n+\n+    Component content =\n+        onlineStaff.isEmpty()\n+            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n+                .getPersonalizedText()\n+                .color(ChatColor.RED)\n+            : new Component(\n+                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+\n+    Component staff =\n+        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+            .getPersonalizedText()\n+            .color(ChatColor.GRAY);\n+\n+    // Send message\n+    sender.sendMessage(staff);\n+  }\n+\n+  @Command(\n+      aliases = {\"mute\", \"m\"},\n+      usage = \"<player> <reason> -s (silent) -w (warn)\",\n+      desc = \"Mute a player\",\n+      perms = Permissions.MUTE)\n+  public void mute(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent,\n+      @Switch('w') boolean warn) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MzY3MA==", "bodyText": "If it should also send the mute message as a warn to the player (title/dragon noise).\nEquivalent to doing 2 commands at once:\n/mute player reason\n/warn player reason", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383583670", "createdAt": "2020-02-24T23:54:19Z", "author": {"login": "Pablete1234"}, "path": "src/main/java/tc/oc/pgm/community/ModerationCommands.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package tc.oc.pgm.community;\n+\n+import app.ashcon.intake.Command;\n+import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Text;\n+import com.google.common.collect.Lists;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.BanList;\n+import org.bukkit.Bukkit;\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+import tc.oc.component.Component;\n+import tc.oc.component.render.ComponentRenderers;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.component.types.PersonalizedTranslatable;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.chat.Sound;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.events.PlayerPunishmentEvent;\n+import tc.oc.pgm.events.PlayerTimedPunishmentEvent;\n+import tc.oc.pgm.listeners.ChatDispatcher;\n+import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n+import tc.oc.util.components.PeriodFormats;\n+\n+public class ModerationCommands {\n+\n+  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n+\n+  private static final Component WARN_SYMBOL =\n+      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n+  private static final Component BROADCAST_DIV =\n+      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n+  private static final Component CONSOLE_NAME =\n+      new PersonalizedTranslatable(\"console\")\n+          .getPersonalizedText()\n+          .color(ChatColor.DARK_AQUA)\n+          .italic(true);\n+\n+  private final ChatDispatcher chat;\n+\n+  public ModerationCommands(ChatDispatcher chat) {\n+    this.chat = chat;\n+  }\n+\n+  @Command(\n+      aliases = {\"staff\", \"mods\", \"admins\"},\n+      desc = \"List the online staff members\")\n+  public void staff(CommandSender sender, Match match) {\n+    // List of online staff based off of permission\n+    List<Component> onlineStaff =\n+        match.getPlayers().stream()\n+            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n+            .map(player -> player.getStyledName(NameStyle.FANCY))\n+            .collect(Collectors.toList());\n+\n+    // FORMAT: Online Staff ({count}): {names}\n+    Component staffCount =\n+        new PersonalizedText(Integer.toString(onlineStaff.size()))\n+            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n+\n+    Component content =\n+        onlineStaff.isEmpty()\n+            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n+                .getPersonalizedText()\n+                .color(ChatColor.RED)\n+            : new Component(\n+                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+\n+    Component staff =\n+        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+            .getPersonalizedText()\n+            .color(ChatColor.GRAY);\n+\n+    // Send message\n+    sender.sendMessage(staff);\n+  }\n+\n+  @Command(\n+      aliases = {\"mute\", \"m\"},\n+      usage = \"<player> <reason> -s (silent) -w (warn)\",\n+      desc = \"Mute a player\",\n+      perms = Permissions.MUTE)\n+  public void mute(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent,\n+      @Switch('w') boolean warn) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2Mzk0Nw=="}, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTEwNDM2OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/community/ModerationCommands.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjo1NjozNFrOFty5dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMzo1NjoxN1rOFt0ITQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NDE0OA==", "bodyText": "What's the point of a silent mute?", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383564148", "createdAt": "2020-02-24T22:56:34Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/community/ModerationCommands.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package tc.oc.pgm.community;\n+\n+import app.ashcon.intake.Command;\n+import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Text;\n+import com.google.common.collect.Lists;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.BanList;\n+import org.bukkit.Bukkit;\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+import tc.oc.component.Component;\n+import tc.oc.component.render.ComponentRenderers;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.component.types.PersonalizedTranslatable;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.chat.Sound;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.events.PlayerPunishmentEvent;\n+import tc.oc.pgm.events.PlayerTimedPunishmentEvent;\n+import tc.oc.pgm.listeners.ChatDispatcher;\n+import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n+import tc.oc.util.components.PeriodFormats;\n+\n+public class ModerationCommands {\n+\n+  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n+\n+  private static final Component WARN_SYMBOL =\n+      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n+  private static final Component BROADCAST_DIV =\n+      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n+  private static final Component CONSOLE_NAME =\n+      new PersonalizedTranslatable(\"console\")\n+          .getPersonalizedText()\n+          .color(ChatColor.DARK_AQUA)\n+          .italic(true);\n+\n+  private final ChatDispatcher chat;\n+\n+  public ModerationCommands(ChatDispatcher chat) {\n+    this.chat = chat;\n+  }\n+\n+  @Command(\n+      aliases = {\"staff\", \"mods\", \"admins\"},\n+      desc = \"List the online staff members\")\n+  public void staff(CommandSender sender, Match match) {\n+    // List of online staff based off of permission\n+    List<Component> onlineStaff =\n+        match.getPlayers().stream()\n+            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n+            .map(player -> player.getStyledName(NameStyle.FANCY))\n+            .collect(Collectors.toList());\n+\n+    // FORMAT: Online Staff ({count}): {names}\n+    Component staffCount =\n+        new PersonalizedText(Integer.toString(onlineStaff.size()))\n+            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n+\n+    Component content =\n+        onlineStaff.isEmpty()\n+            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n+                .getPersonalizedText()\n+                .color(ChatColor.RED)\n+            : new Component(\n+                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+\n+    Component staff =\n+        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+            .getPersonalizedText()\n+            .color(ChatColor.GRAY);\n+\n+    // Send message\n+    sender.sendMessage(staff);\n+  }\n+\n+  @Command(\n+      aliases = {\"mute\", \"m\"},\n+      usage = \"<player> <reason> -s (silent) -w (warn)\",\n+      desc = \"Mute a player\",\n+      perms = Permissions.MUTE)\n+  public void mute(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4NDMzMw==", "bodyText": "Not telling the whole server you have muted someone.\nAll punishments, if not silent, send a global message announcing the punishment, like: \"Mod punishment Player for reason\"", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383584333", "createdAt": "2020-02-24T23:56:17Z", "author": {"login": "Pablete1234"}, "path": "src/main/java/tc/oc/pgm/community/ModerationCommands.java", "diffHunk": "@@ -0,0 +1,434 @@\n+package tc.oc.pgm.community;\n+\n+import app.ashcon.intake.Command;\n+import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Text;\n+import com.google.common.collect.Lists;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.BanList;\n+import org.bukkit.Bukkit;\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+import tc.oc.component.Component;\n+import tc.oc.component.render.ComponentRenderers;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.component.types.PersonalizedTranslatable;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.chat.Sound;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.events.PlayerPunishmentEvent;\n+import tc.oc.pgm.events.PlayerTimedPunishmentEvent;\n+import tc.oc.pgm.listeners.ChatDispatcher;\n+import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n+import tc.oc.util.components.PeriodFormats;\n+\n+public class ModerationCommands {\n+\n+  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n+\n+  private static final Component WARN_SYMBOL =\n+      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n+  private static final Component BROADCAST_DIV =\n+      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n+  private static final Component CONSOLE_NAME =\n+      new PersonalizedTranslatable(\"console\")\n+          .getPersonalizedText()\n+          .color(ChatColor.DARK_AQUA)\n+          .italic(true);\n+\n+  private final ChatDispatcher chat;\n+\n+  public ModerationCommands(ChatDispatcher chat) {\n+    this.chat = chat;\n+  }\n+\n+  @Command(\n+      aliases = {\"staff\", \"mods\", \"admins\"},\n+      desc = \"List the online staff members\")\n+  public void staff(CommandSender sender, Match match) {\n+    // List of online staff based off of permission\n+    List<Component> onlineStaff =\n+        match.getPlayers().stream()\n+            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n+            .map(player -> player.getStyledName(NameStyle.FANCY))\n+            .collect(Collectors.toList());\n+\n+    // FORMAT: Online Staff ({count}): {names}\n+    Component staffCount =\n+        new PersonalizedText(Integer.toString(onlineStaff.size()))\n+            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n+\n+    Component content =\n+        onlineStaff.isEmpty()\n+            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n+                .getPersonalizedText()\n+                .color(ChatColor.RED)\n+            : new Component(\n+                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+\n+    Component staff =\n+        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+            .getPersonalizedText()\n+            .color(ChatColor.GRAY);\n+\n+    // Send message\n+    sender.sendMessage(staff);\n+  }\n+\n+  @Command(\n+      aliases = {\"mute\", \"m\"},\n+      usage = \"<player> <reason> -s (silent) -w (warn)\",\n+      desc = \"Mute a player\",\n+      perms = Permissions.MUTE)\n+  public void mute(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NDE0OA=="}, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTExMTM0OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/community/ReportCommands.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjo1OToxOFrOFty9mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMjo1OToxOFrOFty9mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NTIwOA==", "bodyText": "Should this be a Cache instead? Maybe only keep reports for the last hour? If the server stays up for a day, doesn't make sense to show reports from the previous day.", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383565208", "createdAt": "2020-02-24T22:59:18Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/community/ReportCommands.java", "diffHunk": "@@ -27,22 +35,26 @@\n import tc.oc.pgm.api.setting.SettingKey;\n import tc.oc.pgm.api.setting.SettingValue;\n import tc.oc.pgm.events.PlayerReportEvent;\n-import tc.oc.util.components.Components;\n+import tc.oc.pgm.util.PrettyPaginatedComponentResults;\n+import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.PeriodFormats;\n \n-public class ModerationCommands {\n+public class ReportCommands {\n+\n+  private static final Sound REPORT_NOTIFY_SOUND = new Sound(\"random.pop\", 1f, 1.2f);\n \n   private static final int REPORT_COOLDOWN_SECONDS = 15;\n \n-  private static final Cache<UUID, Instant> LAST_REPORT_SENT =\n+  private final Cache<UUID, Instant> LAST_REPORT_SENT =\n       CacheBuilder.newBuilder().expireAfterWrite(REPORT_COOLDOWN_SECONDS, TimeUnit.SECONDS).build();\n \n-  private static final Sound REPORT_NOTIFY_SOUND = new Sound(\"random.pop\", 1f, 1.2f);\n+  private final List<Report> RECENT_REPORTS = Lists.newArrayList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTExMzc3OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/community/ReportCommands.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMzowMDoyN1rOFty_OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMzo1MTo0OFrOFt0CwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NTYyNQ==", "bodyText": "I think this can be simplified to Instant.compare(getTimeSent(), o.getTimeSent())", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383565625", "createdAt": "2020-02-24T23:00:27Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/community/ReportCommands.java", "diffHunk": "@@ -125,35 +144,125 @@ public static void report(\n   }\n \n   @Command(\n-      aliases = {\"staff\", \"mods\", \"admins\"},\n-      desc = \"List the online staff members\")\n-  public void staff(CommandSender sender, Match match) {\n-    // List of online staff\n-    List<Component> onlineStaff =\n-        match.getPlayers().stream()\n-            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n-            .map(player -> player.getStyledName(NameStyle.FANCY))\n-            .collect(Collectors.toList());\n-\n-    // FORMAT: Online Staff ({count}): {names}\n-    Component staffCount =\n-        new PersonalizedText(Integer.toString(onlineStaff.size()))\n-            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n-\n-    Component content =\n-        onlineStaff.isEmpty()\n-            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n-                .getPersonalizedText()\n-                .color(ChatColor.RED)\n-            : new Component(\n-                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+      aliases = {\"reports\", \"reps\", \"reporthistory\"},\n+      desc = \"Display a list of recent reports\",\n+      usage = \"(page) -t [target player]\",\n+      flags = \"t\",\n+      perms = Permissions.STAFF)\n+  public void reportHistory(\n+      Audience audience,\n+      CommandSender sender,\n+      @Default(\"1\") int page,\n+      @Fallback(Type.NULL) @Switch('t') String target)\n+      throws CommandException {\n+    if (RECENT_REPORTS.isEmpty()) {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\"moderation.reports.none\")\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+      return;\n+    }\n+\n+    List<Report> reportList = RECENT_REPORTS;\n+    if (target != null) {\n+      reportList =\n+          RECENT_REPORTS.stream()\n+              .filter(r -> r.getId().equalsIgnoreCase(target))\n+              .collect(Collectors.toList());\n+    }\n \n-    Component staff =\n-        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+    Collections.sort(reportList); // Sort list so most recent show up first\n+\n+    Component headerResultCount =\n+        new PersonalizedText(Long.toString(reportList.size())).color(ChatColor.RED);\n+\n+    int perPage = 6;\n+    int pages = (reportList.size() + perPage - 1) / perPage;\n+\n+    Component pageNum =\n+        new PersonalizedTranslatable(\n+                \"command.paginatedResult.page\",\n+                new PersonalizedText(Integer.toString(page)).color(ChatColor.RED),\n+                new PersonalizedText(Integer.toString(pages)).color(ChatColor.RED))\n+            .add(ChatColor.AQUA);\n+\n+    Component header =\n+        new PersonalizedTranslatable(\"moderation.reports.header\", headerResultCount, pageNum)\n             .getPersonalizedText()\n             .color(ChatColor.GRAY);\n \n-    // Send message\n-    sender.sendMessage(staff);\n+    Component formattedHeader =\n+        new PersonalizedText(\n+            ComponentUtils.horizontalLineHeading(\n+                ComponentRenderers.toLegacyText(header, sender), ChatColor.RED));\n+\n+    new PrettyPaginatedComponentResults<Report>(formattedHeader, perPage) {\n+      @Override\n+      public Component format(Report data, int index) {\n+        Component timeAgo =\n+            PeriodFormats.relativePastApproximate(\n+                    org.joda.time.Instant.ofEpochMilli(data.getTimeSent().toEpochMilli()))\n+                .color(ChatColor.DARK_AQUA);\n+        Component hover =\n+            new PersonalizedTranslatable(\"moderation.reports.hover\", data.getSenderName())\n+                .getPersonalizedText()\n+                .color(ChatColor.GRAY);\n+        Component formatted =\n+            new PersonalizedTranslatable(\n+                \"moderation.reports.format\",\n+                timeAgo,\n+                data.getTargetName(),\n+                new PersonalizedText(data.getReason()).italic(true).color(ChatColor.WHITE));\n+\n+        return formatted.hoverEvent(Action.SHOW_TEXT, hover.render(sender));\n+      }\n+    }.display(audience, reportList, page);\n+  }\n+\n+  public static class Report implements Comparable<Report> {\n+    private final String id;\n+    private final String reason;\n+    private final Component targetName;\n+    private final Component sender;\n+    private final Instant timeSent;\n+\n+    public Report(String id, String reason, Component targetName, Component sender) {\n+      this.id = id;\n+      this.reason = reason;\n+      this.targetName = targetName;\n+      this.sender = sender;\n+      this.timeSent = Instant.now();\n+    }\n+\n+    public String getId() {\n+      return id;\n+    }\n+\n+    public String getReason() {\n+      return reason;\n+    }\n+\n+    public Component getTargetName() {\n+      return targetName;\n+    }\n+\n+    public Component getSenderName() {\n+      return sender;\n+    }\n+\n+    public Instant getTimeSent() {\n+      return timeSent;\n+    }\n+\n+    @Override\n+    public int compareTo(Report o) {\n+      if (getTimeSent().equals(o.getTimeSent())) {\n+        return 0;\n+      } else if (getTimeSent().isBefore(o.getTimeSent())) {\n+        return 1;\n+      } else {\n+        return -1;\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MjkxMw==", "bodyText": "Can be simplified to return timeSent.compareTo(o.timeSent);", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383582913", "createdAt": "2020-02-24T23:51:48Z", "author": {"login": "Pablete1234"}, "path": "src/main/java/tc/oc/pgm/community/ReportCommands.java", "diffHunk": "@@ -125,35 +144,125 @@ public static void report(\n   }\n \n   @Command(\n-      aliases = {\"staff\", \"mods\", \"admins\"},\n-      desc = \"List the online staff members\")\n-  public void staff(CommandSender sender, Match match) {\n-    // List of online staff\n-    List<Component> onlineStaff =\n-        match.getPlayers().stream()\n-            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n-            .map(player -> player.getStyledName(NameStyle.FANCY))\n-            .collect(Collectors.toList());\n-\n-    // FORMAT: Online Staff ({count}): {names}\n-    Component staffCount =\n-        new PersonalizedText(Integer.toString(onlineStaff.size()))\n-            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n-\n-    Component content =\n-        onlineStaff.isEmpty()\n-            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n-                .getPersonalizedText()\n-                .color(ChatColor.RED)\n-            : new Component(\n-                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+      aliases = {\"reports\", \"reps\", \"reporthistory\"},\n+      desc = \"Display a list of recent reports\",\n+      usage = \"(page) -t [target player]\",\n+      flags = \"t\",\n+      perms = Permissions.STAFF)\n+  public void reportHistory(\n+      Audience audience,\n+      CommandSender sender,\n+      @Default(\"1\") int page,\n+      @Fallback(Type.NULL) @Switch('t') String target)\n+      throws CommandException {\n+    if (RECENT_REPORTS.isEmpty()) {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\"moderation.reports.none\")\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+      return;\n+    }\n+\n+    List<Report> reportList = RECENT_REPORTS;\n+    if (target != null) {\n+      reportList =\n+          RECENT_REPORTS.stream()\n+              .filter(r -> r.getId().equalsIgnoreCase(target))\n+              .collect(Collectors.toList());\n+    }\n \n-    Component staff =\n-        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+    Collections.sort(reportList); // Sort list so most recent show up first\n+\n+    Component headerResultCount =\n+        new PersonalizedText(Long.toString(reportList.size())).color(ChatColor.RED);\n+\n+    int perPage = 6;\n+    int pages = (reportList.size() + perPage - 1) / perPage;\n+\n+    Component pageNum =\n+        new PersonalizedTranslatable(\n+                \"command.paginatedResult.page\",\n+                new PersonalizedText(Integer.toString(page)).color(ChatColor.RED),\n+                new PersonalizedText(Integer.toString(pages)).color(ChatColor.RED))\n+            .add(ChatColor.AQUA);\n+\n+    Component header =\n+        new PersonalizedTranslatable(\"moderation.reports.header\", headerResultCount, pageNum)\n             .getPersonalizedText()\n             .color(ChatColor.GRAY);\n \n-    // Send message\n-    sender.sendMessage(staff);\n+    Component formattedHeader =\n+        new PersonalizedText(\n+            ComponentUtils.horizontalLineHeading(\n+                ComponentRenderers.toLegacyText(header, sender), ChatColor.RED));\n+\n+    new PrettyPaginatedComponentResults<Report>(formattedHeader, perPage) {\n+      @Override\n+      public Component format(Report data, int index) {\n+        Component timeAgo =\n+            PeriodFormats.relativePastApproximate(\n+                    org.joda.time.Instant.ofEpochMilli(data.getTimeSent().toEpochMilli()))\n+                .color(ChatColor.DARK_AQUA);\n+        Component hover =\n+            new PersonalizedTranslatable(\"moderation.reports.hover\", data.getSenderName())\n+                .getPersonalizedText()\n+                .color(ChatColor.GRAY);\n+        Component formatted =\n+            new PersonalizedTranslatable(\n+                \"moderation.reports.format\",\n+                timeAgo,\n+                data.getTargetName(),\n+                new PersonalizedText(data.getReason()).italic(true).color(ChatColor.WHITE));\n+\n+        return formatted.hoverEvent(Action.SHOW_TEXT, hover.render(sender));\n+      }\n+    }.display(audience, reportList, page);\n+  }\n+\n+  public static class Report implements Comparable<Report> {\n+    private final String id;\n+    private final String reason;\n+    private final Component targetName;\n+    private final Component sender;\n+    private final Instant timeSent;\n+\n+    public Report(String id, String reason, Component targetName, Component sender) {\n+      this.id = id;\n+      this.reason = reason;\n+      this.targetName = targetName;\n+      this.sender = sender;\n+      this.timeSent = Instant.now();\n+    }\n+\n+    public String getId() {\n+      return id;\n+    }\n+\n+    public String getReason() {\n+      return reason;\n+    }\n+\n+    public Component getTargetName() {\n+      return targetName;\n+    }\n+\n+    public Component getSenderName() {\n+      return sender;\n+    }\n+\n+    public Instant getTimeSent() {\n+      return timeSent;\n+    }\n+\n+    @Override\n+    public int compareTo(Report o) {\n+      if (getTimeSent().equals(o.getTimeSent())) {\n+        return 0;\n+      } else if (getTimeSent().isBefore(o.getTimeSent())) {\n+        return 1;\n+      } else {\n+        return -1;\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NTYyNQ=="}, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTExNTkwOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/events/PlayerPunishmentEvent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMzowMToxMVrOFtzAcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMzowMToxMVrOFtzAcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NTkzOA==", "bodyText": "Keep all of these files, including events, in the tc.oc.pgm.community package.\nSo this would be tc.oc.pgm.community.events", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383565938", "createdAt": "2020-02-24T23:01:11Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/events/PlayerPunishmentEvent.java", "diffHunk": "@@ -0,0 +1,63 @@\n+package tc.oc.pgm.events;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NTExODM5OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/events/PlayerTimedPunishmentEvent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMzowMjoxN1rOFtzB-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMzowMjoxN1rOFtzB-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2NjMyOA==", "bodyText": "Instead of having 2 events, remove this and add a Duration field to PlayerPunishmentEvent.\nIf the ban is permanent, then the Duration is MAX_VALUE.", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383566328", "createdAt": "2020-02-24T23:02:17Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/events/PlayerTimedPunishmentEvent.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package tc.oc.pgm.events;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import org.bukkit.command.CommandSender;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.ModerationCommands.PunishmentType;\n+\n+/** Called when a punishment that expires after a duration of time is created * */\n+public class PlayerTimedPunishmentEvent extends PlayerPunishmentEvent {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d407e34f89b63fc049ded76b12e0aa5673b60805"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzA2NzU3OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/community/commands/ModerationCommands.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxMzowOTo0N1rOFuFaeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOTo0OToxMFrOFuS5ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NzUxNA==", "bodyText": "This will punish the player with Duration.ZERO, shouldn't this be defined with Duration.MAX_VALUE?", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r383867514", "createdAt": "2020-02-25T13:09:47Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/community/commands/ModerationCommands.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package tc.oc.pgm.community.commands;\n+\n+import app.ashcon.intake.Command;\n+import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Text;\n+import com.google.common.collect.Lists;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.BanList;\n+import org.bukkit.Bukkit;\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+import tc.oc.component.Component;\n+import tc.oc.component.render.ComponentRenderers;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.component.types.PersonalizedTranslatable;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.chat.Sound;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerPunishmentEvent;\n+import tc.oc.pgm.listeners.ChatDispatcher;\n+import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n+import tc.oc.util.components.PeriodFormats;\n+\n+public class ModerationCommands {\n+\n+  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n+\n+  private static final Component WARN_SYMBOL =\n+      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n+  private static final Component BROADCAST_DIV =\n+      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n+  private static final Component CONSOLE_NAME =\n+      new PersonalizedTranslatable(\"console\")\n+          .getPersonalizedText()\n+          .color(ChatColor.DARK_AQUA)\n+          .italic(true);\n+\n+  private final ChatDispatcher chat;\n+\n+  public ModerationCommands(ChatDispatcher chat) {\n+    this.chat = chat;\n+  }\n+\n+  @Command(\n+      aliases = {\"staff\", \"mods\", \"admins\"},\n+      desc = \"List the online staff members\")\n+  public void staff(CommandSender sender, Match match) {\n+    // List of online staff based off of permission\n+    List<Component> onlineStaff =\n+        match.getPlayers().stream()\n+            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n+            .map(player -> player.getStyledName(NameStyle.FANCY))\n+            .collect(Collectors.toList());\n+\n+    // FORMAT: Online Staff ({count}): {names}\n+    Component staffCount =\n+        new PersonalizedText(Integer.toString(onlineStaff.size()))\n+            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n+\n+    Component content =\n+        onlineStaff.isEmpty()\n+            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n+                .getPersonalizedText()\n+                .color(ChatColor.RED)\n+            : new Component(\n+                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+\n+    Component staff =\n+        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+            .getPersonalizedText()\n+            .color(ChatColor.GRAY);\n+\n+    // Send message\n+    sender.sendMessage(staff);\n+  }\n+\n+  @Command(\n+      aliases = {\"mute\", \"m\"},\n+      usage = \"<player> <reason> -s (silent) -w (warn)\",\n+      desc = \"Mute a player\",\n+      perms = Permissions.MUTE)\n+  public void mute(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent,\n+      @Switch('w') boolean warn) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+\n+    if (chat.isMuted(targetMatchPlayer)) {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.mute.existing\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+      return;\n+    }\n+\n+    // if -w flag, also warn the player but don't broadcast warning\n+    if (warn) {\n+      warn(sender, target, match, reason, true);\n+    }\n+\n+    if (punish(PunishmentType.MUTE, targetMatchPlayer, sender, reason, silent)) {\n+      chat.addMuted(targetMatchPlayer);\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"unmute\", \"um\"},\n+      usage = \"<player>\",\n+      desc = \"Unmute a player\",\n+      perms = Permissions.MUTE)\n+  public void unMute(CommandSender sender, Player target, Match match) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (chat.isMuted(targetMatchPlayer)) {\n+      chat.removeMuted(targetMatchPlayer);\n+\n+      targetMatchPlayer.sendMessage(\n+          new PersonalizedTranslatable(\"moderation.unmute.target\")\n+              .getPersonalizedText()\n+              .color(ChatColor.GREEN));\n+\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.unmute.sender\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .color(ChatColor.GRAY));\n+    } else {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.unmute.none\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"warn\", \"w\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Warn a player for bad behavior\",\n+      perms = Permissions.WARN)\n+  public void warn(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+\n+    if (punish(PunishmentType.WARN, targetMatchPlayer, sender, reason, silent)) {\n+      sendWarning(targetMatchPlayer, reason);\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"kick\", \"k\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Kick a player from the server\",\n+      perms = Permissions.KICK)\n+  public void kick(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (punish(PunishmentType.KICK, targetMatchPlayer, sender, reason, silent)) {\n+      target.kickPlayer(\n+          formatPunishmentScreen(\n+              PunishmentType.KICK, formatPunisherName(sender, match), reason, null));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"ban\", \"permban\", \"pb\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Ban a player from the server forever\",\n+      perms = Permissions.BAN)\n+  public void ban(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    Component senderName = formatPunisherName(sender, match);\n+    if (punish(PunishmentType.BAN, targetMatchPlayer, sender, reason, silent)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e53fa85e5c58273ff3917c108dadd05a836b6396"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAwMDUwNA==", "bodyText": "I should have made a comment regarding this, but from what I understand there is no Duration.MAX_VALUE See here\nBut basically I\u2019m using the logic so that: if a punishment has a duration then it must be able to expire, otherwise a zero value represents infinity.", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r384000504", "createdAt": "2020-02-25T16:58:24Z", "author": {"login": "applenick"}, "path": "src/main/java/tc/oc/pgm/community/commands/ModerationCommands.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package tc.oc.pgm.community.commands;\n+\n+import app.ashcon.intake.Command;\n+import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Text;\n+import com.google.common.collect.Lists;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.BanList;\n+import org.bukkit.Bukkit;\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+import tc.oc.component.Component;\n+import tc.oc.component.render.ComponentRenderers;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.component.types.PersonalizedTranslatable;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.chat.Sound;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerPunishmentEvent;\n+import tc.oc.pgm.listeners.ChatDispatcher;\n+import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n+import tc.oc.util.components.PeriodFormats;\n+\n+public class ModerationCommands {\n+\n+  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n+\n+  private static final Component WARN_SYMBOL =\n+      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n+  private static final Component BROADCAST_DIV =\n+      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n+  private static final Component CONSOLE_NAME =\n+      new PersonalizedTranslatable(\"console\")\n+          .getPersonalizedText()\n+          .color(ChatColor.DARK_AQUA)\n+          .italic(true);\n+\n+  private final ChatDispatcher chat;\n+\n+  public ModerationCommands(ChatDispatcher chat) {\n+    this.chat = chat;\n+  }\n+\n+  @Command(\n+      aliases = {\"staff\", \"mods\", \"admins\"},\n+      desc = \"List the online staff members\")\n+  public void staff(CommandSender sender, Match match) {\n+    // List of online staff based off of permission\n+    List<Component> onlineStaff =\n+        match.getPlayers().stream()\n+            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n+            .map(player -> player.getStyledName(NameStyle.FANCY))\n+            .collect(Collectors.toList());\n+\n+    // FORMAT: Online Staff ({count}): {names}\n+    Component staffCount =\n+        new PersonalizedText(Integer.toString(onlineStaff.size()))\n+            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n+\n+    Component content =\n+        onlineStaff.isEmpty()\n+            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n+                .getPersonalizedText()\n+                .color(ChatColor.RED)\n+            : new Component(\n+                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+\n+    Component staff =\n+        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+            .getPersonalizedText()\n+            .color(ChatColor.GRAY);\n+\n+    // Send message\n+    sender.sendMessage(staff);\n+  }\n+\n+  @Command(\n+      aliases = {\"mute\", \"m\"},\n+      usage = \"<player> <reason> -s (silent) -w (warn)\",\n+      desc = \"Mute a player\",\n+      perms = Permissions.MUTE)\n+  public void mute(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent,\n+      @Switch('w') boolean warn) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+\n+    if (chat.isMuted(targetMatchPlayer)) {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.mute.existing\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+      return;\n+    }\n+\n+    // if -w flag, also warn the player but don't broadcast warning\n+    if (warn) {\n+      warn(sender, target, match, reason, true);\n+    }\n+\n+    if (punish(PunishmentType.MUTE, targetMatchPlayer, sender, reason, silent)) {\n+      chat.addMuted(targetMatchPlayer);\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"unmute\", \"um\"},\n+      usage = \"<player>\",\n+      desc = \"Unmute a player\",\n+      perms = Permissions.MUTE)\n+  public void unMute(CommandSender sender, Player target, Match match) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (chat.isMuted(targetMatchPlayer)) {\n+      chat.removeMuted(targetMatchPlayer);\n+\n+      targetMatchPlayer.sendMessage(\n+          new PersonalizedTranslatable(\"moderation.unmute.target\")\n+              .getPersonalizedText()\n+              .color(ChatColor.GREEN));\n+\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.unmute.sender\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .color(ChatColor.GRAY));\n+    } else {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.unmute.none\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"warn\", \"w\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Warn a player for bad behavior\",\n+      perms = Permissions.WARN)\n+  public void warn(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+\n+    if (punish(PunishmentType.WARN, targetMatchPlayer, sender, reason, silent)) {\n+      sendWarning(targetMatchPlayer, reason);\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"kick\", \"k\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Kick a player from the server\",\n+      perms = Permissions.KICK)\n+  public void kick(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (punish(PunishmentType.KICK, targetMatchPlayer, sender, reason, silent)) {\n+      target.kickPlayer(\n+          formatPunishmentScreen(\n+              PunishmentType.KICK, formatPunisherName(sender, match), reason, null));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"ban\", \"permban\", \"pb\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Ban a player from the server forever\",\n+      perms = Permissions.BAN)\n+  public void ban(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    Component senderName = formatPunisherName(sender, match);\n+    if (punish(PunishmentType.BAN, targetMatchPlayer, sender, reason, silent)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NzUxNA=="}, "originalCommit": {"oid": "e53fa85e5c58273ff3917c108dadd05a836b6396"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4ODQ0Mw==", "bodyText": "Ah ok, that works", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r384088443", "createdAt": "2020-02-25T19:49:10Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/community/commands/ModerationCommands.java", "diffHunk": "@@ -0,0 +1,436 @@\n+package tc.oc.pgm.community.commands;\n+\n+import app.ashcon.intake.Command;\n+import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Text;\n+import com.google.common.collect.Lists;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.BanList;\n+import org.bukkit.Bukkit;\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+import tc.oc.component.Component;\n+import tc.oc.component.render.ComponentRenderers;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.component.types.PersonalizedTranslatable;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.chat.Sound;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerPunishmentEvent;\n+import tc.oc.pgm.listeners.ChatDispatcher;\n+import tc.oc.util.components.ComponentUtils;\n+import tc.oc.util.components.Components;\n+import tc.oc.util.components.PeriodFormats;\n+\n+public class ModerationCommands {\n+\n+  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n+\n+  private static final Component WARN_SYMBOL =\n+      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n+  private static final Component BROADCAST_DIV =\n+      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n+  private static final Component CONSOLE_NAME =\n+      new PersonalizedTranslatable(\"console\")\n+          .getPersonalizedText()\n+          .color(ChatColor.DARK_AQUA)\n+          .italic(true);\n+\n+  private final ChatDispatcher chat;\n+\n+  public ModerationCommands(ChatDispatcher chat) {\n+    this.chat = chat;\n+  }\n+\n+  @Command(\n+      aliases = {\"staff\", \"mods\", \"admins\"},\n+      desc = \"List the online staff members\")\n+  public void staff(CommandSender sender, Match match) {\n+    // List of online staff based off of permission\n+    List<Component> onlineStaff =\n+        match.getPlayers().stream()\n+            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n+            .map(player -> player.getStyledName(NameStyle.FANCY))\n+            .collect(Collectors.toList());\n+\n+    // FORMAT: Online Staff ({count}): {names}\n+    Component staffCount =\n+        new PersonalizedText(Integer.toString(onlineStaff.size()))\n+            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n+\n+    Component content =\n+        onlineStaff.isEmpty()\n+            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n+                .getPersonalizedText()\n+                .color(ChatColor.RED)\n+            : new Component(\n+                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+\n+    Component staff =\n+        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+            .getPersonalizedText()\n+            .color(ChatColor.GRAY);\n+\n+    // Send message\n+    sender.sendMessage(staff);\n+  }\n+\n+  @Command(\n+      aliases = {\"mute\", \"m\"},\n+      usage = \"<player> <reason> -s (silent) -w (warn)\",\n+      desc = \"Mute a player\",\n+      perms = Permissions.MUTE)\n+  public void mute(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent,\n+      @Switch('w') boolean warn) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+\n+    if (chat.isMuted(targetMatchPlayer)) {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.mute.existing\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+      return;\n+    }\n+\n+    // if -w flag, also warn the player but don't broadcast warning\n+    if (warn) {\n+      warn(sender, target, match, reason, true);\n+    }\n+\n+    if (punish(PunishmentType.MUTE, targetMatchPlayer, sender, reason, silent)) {\n+      chat.addMuted(targetMatchPlayer);\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"unmute\", \"um\"},\n+      usage = \"<player>\",\n+      desc = \"Unmute a player\",\n+      perms = Permissions.MUTE)\n+  public void unMute(CommandSender sender, Player target, Match match) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (chat.isMuted(targetMatchPlayer)) {\n+      chat.removeMuted(targetMatchPlayer);\n+\n+      targetMatchPlayer.sendMessage(\n+          new PersonalizedTranslatable(\"moderation.unmute.target\")\n+              .getPersonalizedText()\n+              .color(ChatColor.GREEN));\n+\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.unmute.sender\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .color(ChatColor.GRAY));\n+    } else {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.unmute.none\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"warn\", \"w\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Warn a player for bad behavior\",\n+      perms = Permissions.WARN)\n+  public void warn(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+\n+    if (punish(PunishmentType.WARN, targetMatchPlayer, sender, reason, silent)) {\n+      sendWarning(targetMatchPlayer, reason);\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"kick\", \"k\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Kick a player from the server\",\n+      perms = Permissions.KICK)\n+  public void kick(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (punish(PunishmentType.KICK, targetMatchPlayer, sender, reason, silent)) {\n+      target.kickPlayer(\n+          formatPunishmentScreen(\n+              PunishmentType.KICK, formatPunisherName(sender, match), reason, null));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"ban\", \"permban\", \"pb\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Ban a player from the server forever\",\n+      perms = Permissions.BAN)\n+  public void ban(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    Component senderName = formatPunisherName(sender, match);\n+    if (punish(PunishmentType.BAN, targetMatchPlayer, sender, reason, silent)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NzUxNA=="}, "originalCommit": {"oid": "e53fa85e5c58273ff3917c108dadd05a836b6396"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MDAzNjUzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/community/commands/ModerationCommands.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwODoxOTowM1rOFuhuYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwODoxOTowM1rOFuhuYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMzMTM2MQ==", "bodyText": "Just commenting for visibility", "url": "https://github.com/PGMDev/PGM/pull/333#discussion_r384331361", "createdAt": "2020-02-26T08:19:03Z", "author": {"login": "applenick"}, "path": "core/src/main/java/tc/oc/pgm/community/commands/ModerationCommands.java", "diffHunk": "@@ -0,0 +1,495 @@\n+package tc.oc.pgm.community.commands;\n+\n+import app.ashcon.intake.Command;\n+import app.ashcon.intake.CommandException;\n+import app.ashcon.intake.parametric.annotation.Switch;\n+import app.ashcon.intake.parametric.annotation.Text;\n+import com.google.common.collect.Lists;\n+import com.google.common.net.InetAddresses;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.BanList;\n+import org.bukkit.Bukkit;\n+import org.bukkit.command.CommandSender;\n+import org.bukkit.entity.Player;\n+import tc.oc.pgm.Config;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.chat.Sound;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerPunishmentEvent;\n+import tc.oc.pgm.listeners.ChatDispatcher;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentRenderers;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.PeriodFormats;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.named.NameStyle;\n+\n+public class ModerationCommands {\n+\n+  private static final Sound WARN_SOUND = new Sound(\"mob.enderdragon.growl\", 1f, 1f);\n+\n+  private static final Component WARN_SYMBOL =\n+      new PersonalizedText(\" \\u26a0 \").color(ChatColor.YELLOW);\n+  private static final Component BROADCAST_DIV =\n+      new PersonalizedText(\" \\u00BB \").color(ChatColor.GOLD);\n+  private static final Component CONSOLE_NAME =\n+      new PersonalizedTranslatable(\"console\")\n+          .getPersonalizedText()\n+          .color(ChatColor.DARK_AQUA)\n+          .italic(true);\n+\n+  private final ChatDispatcher chat;\n+\n+  public ModerationCommands(ChatDispatcher chat) {\n+    this.chat = chat;\n+  }\n+\n+  @Command(\n+      aliases = {\"staff\", \"mods\", \"admins\"},\n+      desc = \"List the online staff members\")\n+  public void staff(CommandSender sender, Match match) {\n+    // List of online staff based off of permission\n+    List<Component> onlineStaff =\n+        match.getPlayers().stream()\n+            .filter(player -> player.getBukkit().hasPermission(Permissions.STAFF))\n+            .map(player -> player.getStyledName(NameStyle.FANCY))\n+            .collect(Collectors.toList());\n+\n+    // FORMAT: Online Staff ({count}): {names}\n+    Component staffCount =\n+        new PersonalizedText(Integer.toString(onlineStaff.size()))\n+            .color(onlineStaff.isEmpty() ? ChatColor.RED : ChatColor.AQUA);\n+\n+    Component content =\n+        onlineStaff.isEmpty()\n+            ? new PersonalizedTranslatable(\"moderation.staff.empty\")\n+                .getPersonalizedText()\n+                .color(ChatColor.RED)\n+            : new Component(\n+                Components.join(new PersonalizedText(\", \").color(ChatColor.GRAY), onlineStaff));\n+\n+    Component staff =\n+        new PersonalizedTranslatable(\"moderation.staff.name\", staffCount, content)\n+            .getPersonalizedText()\n+            .color(ChatColor.GRAY);\n+\n+    // Send message\n+    sender.sendMessage(staff);\n+  }\n+\n+  @Command(\n+      aliases = {\"mute\", \"m\"},\n+      usage = \"<player> <reason> -s (silent) -w (warn)\",\n+      desc = \"Mute a player\",\n+      perms = Permissions.MUTE)\n+  public void mute(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent,\n+      @Switch('w') boolean warn) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+\n+    if (chat.isMuted(targetMatchPlayer)) {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.mute.existing\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+      return;\n+    }\n+\n+    // if -w flag, also warn the player but don't broadcast warning\n+    if (warn) {\n+      warn(sender, target, match, reason, true);\n+    }\n+\n+    if (punish(PunishmentType.MUTE, targetMatchPlayer, sender, reason, silent)) {\n+      chat.addMuted(targetMatchPlayer);\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"unmute\", \"um\"},\n+      usage = \"<player>\",\n+      desc = \"Unmute a player\",\n+      perms = Permissions.MUTE)\n+  public void unMute(CommandSender sender, Player target, Match match) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (chat.isMuted(targetMatchPlayer)) {\n+      chat.removeMuted(targetMatchPlayer);\n+\n+      targetMatchPlayer.sendMessage(\n+          new PersonalizedTranslatable(\"moderation.unmute.target\")\n+              .getPersonalizedText()\n+              .color(ChatColor.GREEN));\n+\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.unmute.sender\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .color(ChatColor.GRAY));\n+    } else {\n+      sender.sendMessage(\n+          new PersonalizedTranslatable(\n+                  \"moderation.unmute.none\", targetMatchPlayer.getStyledName(NameStyle.FANCY))\n+              .getPersonalizedText()\n+              .color(ChatColor.RED));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"warn\", \"w\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Warn a player for bad behavior\",\n+      perms = Permissions.WARN)\n+  public void warn(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+\n+    if (punish(PunishmentType.WARN, targetMatchPlayer, sender, reason, silent)) {\n+      sendWarning(targetMatchPlayer, reason);\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"kick\", \"k\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Kick a player from the server\",\n+      perms = Permissions.KICK)\n+  public void kick(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (punish(PunishmentType.KICK, targetMatchPlayer, sender, reason, silent)) {\n+      target.kickPlayer(\n+          formatPunishmentScreen(\n+              PunishmentType.KICK, formatPunisherName(sender, match), reason, null));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"ban\", \"permban\", \"pb\"},\n+      usage = \"<player> <reason> -s (silent)\",\n+      desc = \"Ban a player from the server forever\",\n+      perms = Permissions.BAN)\n+  public void ban(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    Component senderName = formatPunisherName(sender, match);\n+    if (punish(PunishmentType.BAN, targetMatchPlayer, sender, reason, silent)) {\n+      banPlayer(target, reason, senderName, null);\n+      target.kickPlayer(formatPunishmentScreen(PunishmentType.BAN, senderName, reason, null));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"tempban\", \"tban\", \"tb\"},\n+      usage = \"<player> <time> <reason> -s (silent)\",\n+      desc = \"Ban a player from the server for a period of time\",\n+      perms = Permissions.BAN)\n+  public void tempBan(\n+      CommandSender sender,\n+      Player target,\n+      Match match,\n+      Duration banLength,\n+      @Text String reason,\n+      @Switch('s') boolean silent) {\n+    MatchPlayer targetMatchPlayer = match.getPlayer(target);\n+    if (punish(PunishmentType.BAN, targetMatchPlayer, sender, reason, banLength, silent)) {\n+      banPlayer(target, reason, formatPunisherName(sender, match), Instant.now().plus(banLength));\n+      target.kickPlayer(\n+          formatPunishmentScreen(\n+              PunishmentType.BAN, formatPunisherName(sender, match), reason, banLength));\n+    }\n+  }\n+\n+  @Command(\n+      aliases = {\"ipban\", \"banip\", \"ipb\"},\n+      usage = \"<player|ip address> <reason>\",\n+      desc = \"IP Ban a player from the server\",\n+      perms = Permissions.BAN)\n+  public void ipBan(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4293abcff754bfdcc456c77698ba27b892da98a"}, "originalPosition": 233}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1131, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}