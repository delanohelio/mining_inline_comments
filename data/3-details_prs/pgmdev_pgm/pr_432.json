{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5MjAzNzQ0", "number": 432, "title": "Add spawner module", "bodyText": "This XML module will allow the map maker to define custom regions where various entities (currently items only) can spawn, without using NBT editors to edit physical spawner blocks.  The syntax is as follows (borrowed from #360, but modified slightly)\n<spawners> \n    <spawner id=\"\" spawn-region=\"\"  player-region=\"\" max-entities=\"\" delay=\"\" min-delay=\"\" max-delay=\"\" filter=\"\">\n        <item amount=\"4\" name=\"`6Golden Sword\" material=\"gold sword\"/> \n        ...\n    </spawner>\n...\n</spawners>\n\nid - ID of the spawner\nspawn-region - Region in which the entity can spawn (required, points to a region in the XML)\nplayer-region - There must be at least 1 player in this region for the spawner to be active\nmax-entities - Cap of how many entities of the spawner can spawn (this only applies to mobs and items, TNT and Potions to not contribute to this cap)\ndelay - Spawn speed in seconds (defaults to 10 seconds)\nmin-delay, max-delay - Minimum/Maximum delay to allow randomness if specified (defaults to the delay attribute)\nfilter - Filter to further control spawn conditions, will return true if at least one player in player-region meets criteria\nAs of now, ONLY items are supported as PGM does not have a good system for parsing and creating Entity objects. Once the entity system is completed, the following Spawnables will be supported.\n\nDropped Items (already supported)\n\nUses the same syntax as kits, but with singular <item> tags\n\n\nMobs\nPrimed TNT\n\nCan specify fuse and power\n\n\nSplash Potions\n\nUses the same syntax as kits, but with singular <effect> tags", "createdAt": "2020-04-27T01:47:14Z", "url": "https://github.com/PGMDev/PGM/pull/432", "merged": true, "mergeCommit": {"oid": "df13efcd6687c2281b22e877ea0734b6e39a3ab5"}, "closed": true, "closedAt": "2020-05-03T16:26:19Z", "author": {"login": "EricZeiberg"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcbSZcNgH2gAyNDA5MjAzNzQ0Ojc5N2I4YTdiMmU5NTI2MzEyYTBmYzE4NmM2OGM0NmVjM2EyYmYyNzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcdtbSQgFqTQwNDYzNDg2Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "797b8a7b2e9526312a0fc186c68c46ec3a2bf271", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/797b8a7b2e9526312a0fc186c68c46ec3a2bf271", "committedDate": "2020-04-26T03:48:07Z", "message": "Initial module structure and parsing\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "469dd2d125d7579c5ba9d482e1a313f0a1596adc", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/469dd2d125d7579c5ba9d482e1a313f0a1596adc", "committedDate": "2020-04-26T04:43:28Z", "message": "Add object structure\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e535bc713b2edb995065e744e28f659faea7c5c", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/9e535bc713b2edb995065e744e28f659faea7c5c", "committedDate": "2020-04-26T19:30:58Z", "message": "Initial spawning behavior\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d50ac1a4e9d7bb9819cb17afae8187ae4270bd7", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/7d50ac1a4e9d7bb9819cb17afae8187ae4270bd7", "committedDate": "2020-04-26T19:47:15Z", "message": "Merge branch 'master' of https://github.com/Electroid/PGM into spawner-module"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e110f08e6ab7c3f2522dc6ba7855ac4f8d98fab", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/6e110f08e6ab7c3f2522dc6ba7855ac4f8d98fab", "committedDate": "2020-04-26T21:01:34Z", "message": "Finish mob spawning\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d31d99600a0437047a421cbcfc606643093e644", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/0d31d99600a0437047a421cbcfc606643093e644", "committedDate": "2020-04-26T22:20:25Z", "message": "Add TNT and Potions\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20423df11258ba8d6869b5495511111506a98925", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/20423df11258ba8d6869b5495511111506a98925", "committedDate": "2020-04-26T23:18:15Z", "message": "Add item object\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c975bf9c4bb2e782659e58fbf34dcbb5b0482972", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/c975bf9c4bb2e782659e58fbf34dcbb5b0482972", "committedDate": "2020-04-26T23:25:20Z", "message": "Fix extra stack spawning\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e78c890977a634d9b185a24456b2c40ec3014d68", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/e78c890977a634d9b185a24456b2c40ec3014d68", "committedDate": "2020-04-26T23:52:21Z", "message": "Format code\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f2755f958498293299c419ecd44a5585de4cf4d2", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/f2755f958498293299c419ecd44a5585de4cf4d2", "committedDate": "2020-04-28T00:15:51Z", "message": "Format\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}, "afterCommit": {"oid": "f0d602128e794468325ada8bef767d5bce0dbb4f", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/f0d602128e794468325ada8bef767d5bce0dbb4f", "committedDate": "2020-04-28T00:16:43Z", "message": "Format\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f0d602128e794468325ada8bef767d5bce0dbb4f", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/f0d602128e794468325ada8bef767d5bce0dbb4f", "committedDate": "2020-04-28T00:16:43Z", "message": "Format\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}, "afterCommit": {"oid": "60a68714d335acf085d63a837b51ce467dea497c", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/60a68714d335acf085d63a837b51ce467dea497c", "committedDate": "2020-04-28T00:14:37Z", "message": "Add filter support"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b12f6fbef7e44df6451c61c23a5120f9fa9f1ad", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/3b12f6fbef7e44df6451c61c23a5120f9fa9f1ad", "committedDate": "2020-04-28T00:26:27Z", "message": "Add filter support\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "60a68714d335acf085d63a837b51ce467dea497c", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/60a68714d335acf085d63a837b51ce467dea497c", "committedDate": "2020-04-28T00:14:37Z", "message": "Add filter support"}, "afterCommit": {"oid": "3b12f6fbef7e44df6451c61c23a5120f9fa9f1ad", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/3b12f6fbef7e44df6451c61c23a5120f9fa9f1ad", "committedDate": "2020-04-28T00:26:27Z", "message": "Add filter support\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/ff23cb29ee991482a9b3789ab7ec9f831223cd59", "committedDate": "2020-04-28T00:29:37Z", "message": "Format\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMjA2NTM3", "url": "https://github.com/PGMDev/PGM/pull/432#pullrequestreview-402206537", "createdAt": "2020-04-28T20:58:39Z", "commit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMDo1ODozOVrOGNmqVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQyMTo1NDo0OFrOGNocpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkxODEwMw==", "bodyText": "See Feature and other examples of it, you'll want Spawner implements Feature.", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416918103", "createdAt": "2020-04-28T20:58:39Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkxODM3Ng==", "bodyText": "Is this nessecary, looks unused?", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416918376", "createdAt": "2020-04-28T20:59:07Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+  private final Logger logger;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyMzMyMg==", "bodyText": "Instead of storing a static variable, just use Match#getRandom when you need it.", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416923322", "createdAt": "2020-04-28T21:07:51Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+  private final Logger logger;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private List<Player> trackedPlayers = new ArrayList<>();\n+\n+  private static final Random RANDOM = new Random();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNDU2Mg==", "bodyText": "We should avoid at all costs having any Collection with a hard reference to a Player or MatchPlayer, it's essentially a trouble maker for memory leaks. Try using OnlinePlayerMapAdapter", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416924562", "createdAt": "2020-04-28T21:10:02Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+  private final Logger logger;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private List<Player> trackedPlayers = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNTI2Nw==", "bodyText": "Is this a filter on the players or the spawner location? If it's players, you'll want to name is playerFilter.", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416925267", "createdAt": "2020-04-28T21:11:23Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerDefinition.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import tc.oc.pgm.api.filter.Filter;\n+import tc.oc.pgm.api.region.Region;\n+\n+public class SpawnerDefinition {\n+\n+  public Region spawnRegion;\n+  public String id;\n+  public int count;\n+  public Region playerRegion;\n+  public int maxEntities;\n+  public Duration minDelay, maxDelay, delay;\n+  public List<SpawnerObject> objects;\n+  public Filter filter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNTY2Ng==", "bodyText": "Be more specific than count, what does this mean?", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416925666", "createdAt": "2020-04-28T21:12:02Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerDefinition.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import tc.oc.pgm.api.filter.Filter;\n+import tc.oc.pgm.api.region.Region;\n+\n+public class SpawnerDefinition {\n+\n+  public Region spawnRegion;\n+  public String id;\n+  public int count;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNjgwNw==", "bodyText": "Other than augmenting vanilla, what's the use-case for varied delays?", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416926807", "createdAt": "2020-04-28T21:14:01Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerDefinition.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import tc.oc.pgm.api.filter.Filter;\n+import tc.oc.pgm.api.region.Region;\n+\n+public class SpawnerDefinition {\n+\n+  public Region spawnRegion;\n+  public String id;\n+  public int count;\n+  public Region playerRegion;\n+  public int maxEntities;\n+  public Duration minDelay, maxDelay, delay;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNzIzNg==", "bodyText": "This should not be in a MapModule class.", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416927236", "createdAt": "2020-04-28T21:14:52Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerModule.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package tc.oc.pgm.spawner;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.potion.PotionEffect;\n+import org.jdom2.Attribute;\n+import org.jdom2.Document;\n+import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.filters.FilterModule;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.filters.StaticFilter;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionModule;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectEntity;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectItem;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectPotion;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectTNT;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.xml.InvalidXMLException;\n+import tc.oc.pgm.util.xml.XMLUtils;\n+\n+public class SpawnerModule implements MapModule {\n+\n+  private static final List<SpawnerDefinition> spawnerDefinitions = new ArrayList<>();\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTgwNA==", "bodyText": "Be careful, can't use static, since each MapContext will have it's own MapModule.\nAs of right now, all maps will share the same spawners!", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416929804", "createdAt": "2020-04-28T21:19:58Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerModule.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package tc.oc.pgm.spawner;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.potion.PotionEffect;\n+import org.jdom2.Attribute;\n+import org.jdom2.Document;\n+import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.filters.FilterModule;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.filters.StaticFilter;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionModule;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectEntity;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectItem;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectPotion;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectTNT;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.xml.InvalidXMLException;\n+import tc.oc.pgm.util.xml.XMLUtils;\n+\n+public class SpawnerModule implements MapModule {\n+\n+  private static final List<SpawnerDefinition> spawnerDefinitions = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMDQyOQ==", "bodyText": "TimeUtils has helpful methods for comparing durations.", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416930429", "createdAt": "2020-04-28T21:21:08Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerModule.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package tc.oc.pgm.spawner;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.potion.PotionEffect;\n+import org.jdom2.Attribute;\n+import org.jdom2.Document;\n+import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.filters.FilterModule;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.filters.StaticFilter;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionModule;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectEntity;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectItem;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectPotion;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectTNT;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.xml.InvalidXMLException;\n+import tc.oc.pgm.util.xml.XMLUtils;\n+\n+public class SpawnerModule implements MapModule {\n+\n+  private static final List<SpawnerDefinition> spawnerDefinitions = new ArrayList<>();\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  @Override\n+  public MatchModule createMatchModule(Match match) {\n+    return new SpawnerMatchModule(match, spawnerDefinitions);\n+  }\n+\n+  public static class Factory implements MapModuleFactory<SpawnerModule> {\n+    @Override\n+    public Collection<Class<? extends MapModule>> getWeakDependencies() {\n+      return ImmutableList.of(RegionModule.class, FilterModule.class);\n+    }\n+\n+    @Override\n+    public SpawnerModule parse(MapFactory factory, Logger logger, Document doc)\n+        throws InvalidXMLException {\n+      SpawnerModule spawnerModule = new SpawnerModule();\n+      RegionParser regionParser = factory.getRegions();\n+      KitParser kitParser = factory.getKits();\n+      FilterParser filterParser = factory.getFilters();\n+\n+      for (Element element :\n+          XMLUtils.flattenElements(doc.getRootElement(), \"spawners\", \"spawner\")) {\n+        SpawnerDefinition spawnerDefinition = new SpawnerDefinition();\n+        spawnerDefinition.spawnRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"spawn-region\");\n+        spawnerDefinition.playerRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"player-region\");\n+        spawnerDefinition.id = element.getAttributeValue(\"id\");\n+        Attribute delay = element.getAttribute(\"delay\");\n+        Attribute minDelay = element.getAttribute(\"min-delay\");\n+        Attribute maxDelay = element.getAttribute(\"max-delay\");\n+\n+        if ((minDelay != null || maxDelay != null) && delay != null) {\n+          throw new InvalidXMLException(\n+              \"Attribute 'minDelay' and 'maxDelay' cannot be combined with 'delay'\", element);\n+        }\n+\n+        spawnerDefinition.delay = XMLUtils.parseDuration(delay, Duration.ofSeconds(10));\n+        spawnerDefinition.minDelay = XMLUtils.parseDuration(minDelay, spawnerDefinition.delay);\n+        spawnerDefinition.maxDelay = XMLUtils.parseDuration(maxDelay, spawnerDefinition.delay);\n+\n+        if (spawnerDefinition.maxDelay.compareTo(spawnerDefinition.minDelay) < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzOTkxOA==", "bodyText": "One of the more difficult parts of contributing to PGM modules is finding the right balance between features and abstraction. While I think these are all cool features, we don't have the proper abstractions to support them yet.\nWhile PGM has a comprehensive system for parsing items, it does not have an approach for parsing entities (such as tnt, potions, or projectiles). For instance, <projectiles> has its own syntax for spawning projectile entities.\nBefore introducing these features, I think we will need to brainstorm a way to create entity \"templates\" similar to how we create item \"templates\" whenever you parse a kit.\nSince that will take a lot of work, I would suggest changing the MVP of this module to just be items.", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416939918", "createdAt": "2020-04-28T21:38:54Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerModule.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package tc.oc.pgm.spawner;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.potion.PotionEffect;\n+import org.jdom2.Attribute;\n+import org.jdom2.Document;\n+import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.filters.FilterModule;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.filters.StaticFilter;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionModule;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectEntity;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectItem;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectPotion;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectTNT;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.xml.InvalidXMLException;\n+import tc.oc.pgm.util.xml.XMLUtils;\n+\n+public class SpawnerModule implements MapModule {\n+\n+  private static final List<SpawnerDefinition> spawnerDefinitions = new ArrayList<>();\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  @Override\n+  public MatchModule createMatchModule(Match match) {\n+    return new SpawnerMatchModule(match, spawnerDefinitions);\n+  }\n+\n+  public static class Factory implements MapModuleFactory<SpawnerModule> {\n+    @Override\n+    public Collection<Class<? extends MapModule>> getWeakDependencies() {\n+      return ImmutableList.of(RegionModule.class, FilterModule.class);\n+    }\n+\n+    @Override\n+    public SpawnerModule parse(MapFactory factory, Logger logger, Document doc)\n+        throws InvalidXMLException {\n+      SpawnerModule spawnerModule = new SpawnerModule();\n+      RegionParser regionParser = factory.getRegions();\n+      KitParser kitParser = factory.getKits();\n+      FilterParser filterParser = factory.getFilters();\n+\n+      for (Element element :\n+          XMLUtils.flattenElements(doc.getRootElement(), \"spawners\", \"spawner\")) {\n+        SpawnerDefinition spawnerDefinition = new SpawnerDefinition();\n+        spawnerDefinition.spawnRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"spawn-region\");\n+        spawnerDefinition.playerRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"player-region\");\n+        spawnerDefinition.id = element.getAttributeValue(\"id\");\n+        Attribute delay = element.getAttribute(\"delay\");\n+        Attribute minDelay = element.getAttribute(\"min-delay\");\n+        Attribute maxDelay = element.getAttribute(\"max-delay\");\n+\n+        if ((minDelay != null || maxDelay != null) && delay != null) {\n+          throw new InvalidXMLException(\n+              \"Attribute 'minDelay' and 'maxDelay' cannot be combined with 'delay'\", element);\n+        }\n+\n+        spawnerDefinition.delay = XMLUtils.parseDuration(delay, Duration.ofSeconds(10));\n+        spawnerDefinition.minDelay = XMLUtils.parseDuration(minDelay, spawnerDefinition.delay);\n+        spawnerDefinition.maxDelay = XMLUtils.parseDuration(maxDelay, spawnerDefinition.delay);\n+\n+        if (spawnerDefinition.maxDelay.compareTo(spawnerDefinition.minDelay) < 0) {\n+          throw new InvalidXMLException(\"Max delay cannot be smaller than min delay\", element);\n+        }\n+\n+        spawnerDefinition.maxEntities =\n+            XMLUtils.parseNumber(\n+                element.getAttribute(\"max-entities\"), Integer.class, Integer.MAX_VALUE);\n+        spawnerDefinition.filter =\n+            filterParser.parseFilterProperty(element, \"filter\", StaticFilter.ALLOW);\n+\n+        List<SpawnerObject> objects = new ArrayList<>();\n+        for (Element object : XMLUtils.getChildren(element, \"entity\", \"item\", \"tnt\", \"effect\")) {\n+          int count;\n+          switch (object.getName()) {\n+            case \"entity\":\n+              count = XMLUtils.parseNumber(object.getAttribute(\"count\"), Integer.class, 1);\n+              SpawnerObjectEntity entity =\n+                  new SpawnerObjectEntity(XMLUtils.parseEntityType(object), count);\n+              objects.add(entity);\n+              break;\n+            case \"tnt\":\n+              Duration fuse = XMLUtils.parseDuration(object.getAttribute(\"fuse\"));\n+              float power = XMLUtils.parseNumber(object.getAttribute(\"power\"), Float.class);\n+              count = XMLUtils.parseNumber(object.getAttribute(\"count\"), Integer.class, 1);\n+              SpawnerObjectTNT tnt =\n+                  new SpawnerObjectTNT(power, (int) TimeUtils.toTicks(fuse), count);\n+              objects.add(tnt);\n+              break;\n+            case \"effect\":\n+              PotionEffect effect = XMLUtils.parsePotionEffect(object);\n+              count = XMLUtils.parseNumber(object.getAttribute(\"count\"), Integer.class, 1);\n+              SpawnerObjectPotion potion = new SpawnerObjectPotion(count, effect);\n+              objects.add(potion);\n+              break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDY2Nw==", "bodyText": "This doesn't seem necessary, because you could just have non-trackable entities return 0 on spawnCount", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416940667", "createdAt": "2020-04-28T21:40:20Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerObject.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+\n+public interface SpawnerObject {\n+\n+  void spawn(Location location);\n+\n+  /**\n+   * Some objects are tracked and added to the max entities count (Mobs, items) while others\n+   * (ThrownPotions, TNT) are not.\n+   *\n+   * @return whether the object affects the entity count.\n+   */\n+  boolean isTracked();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDc2NQ==", "bodyText": "getSpawnCount", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416940765", "createdAt": "2020-04-28T21:40:30Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerObject.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+\n+public interface SpawnerObject {\n+\n+  void spawn(Location location);\n+\n+  /**\n+   * Some objects are tracked and added to the max entities count (Mobs, items) while others\n+   * (ThrownPotions, TNT) are not.\n+   *\n+   * @return whether the object affects the entity count.\n+   */\n+  boolean isTracked();\n+\n+  int spawnCount();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDk2MQ==", "bodyText": "Spawnable", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416940961", "createdAt": "2020-04-28T21:40:57Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerObject.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+\n+public interface SpawnerObject {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MjA3MA==", "bodyText": "I think you'll need to clamp this value so map makers can't spawn 10k entities.", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416942070", "createdAt": "2020-04-28T21:43:11Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerModule.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package tc.oc.pgm.spawner;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.potion.PotionEffect;\n+import org.jdom2.Attribute;\n+import org.jdom2.Document;\n+import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.filters.FilterModule;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.filters.StaticFilter;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionModule;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectEntity;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectItem;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectPotion;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectTNT;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.xml.InvalidXMLException;\n+import tc.oc.pgm.util.xml.XMLUtils;\n+\n+public class SpawnerModule implements MapModule {\n+\n+  private static final List<SpawnerDefinition> spawnerDefinitions = new ArrayList<>();\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  @Override\n+  public MatchModule createMatchModule(Match match) {\n+    return new SpawnerMatchModule(match, spawnerDefinitions);\n+  }\n+\n+  public static class Factory implements MapModuleFactory<SpawnerModule> {\n+    @Override\n+    public Collection<Class<? extends MapModule>> getWeakDependencies() {\n+      return ImmutableList.of(RegionModule.class, FilterModule.class);\n+    }\n+\n+    @Override\n+    public SpawnerModule parse(MapFactory factory, Logger logger, Document doc)\n+        throws InvalidXMLException {\n+      SpawnerModule spawnerModule = new SpawnerModule();\n+      RegionParser regionParser = factory.getRegions();\n+      KitParser kitParser = factory.getKits();\n+      FilterParser filterParser = factory.getFilters();\n+\n+      for (Element element :\n+          XMLUtils.flattenElements(doc.getRootElement(), \"spawners\", \"spawner\")) {\n+        SpawnerDefinition spawnerDefinition = new SpawnerDefinition();\n+        spawnerDefinition.spawnRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"spawn-region\");\n+        spawnerDefinition.playerRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"player-region\");\n+        spawnerDefinition.id = element.getAttributeValue(\"id\");\n+        Attribute delay = element.getAttribute(\"delay\");\n+        Attribute minDelay = element.getAttribute(\"min-delay\");\n+        Attribute maxDelay = element.getAttribute(\"max-delay\");\n+\n+        if ((minDelay != null || maxDelay != null) && delay != null) {\n+          throw new InvalidXMLException(\n+              \"Attribute 'minDelay' and 'maxDelay' cannot be combined with 'delay'\", element);\n+        }\n+\n+        spawnerDefinition.delay = XMLUtils.parseDuration(delay, Duration.ofSeconds(10));\n+        spawnerDefinition.minDelay = XMLUtils.parseDuration(minDelay, spawnerDefinition.delay);\n+        spawnerDefinition.maxDelay = XMLUtils.parseDuration(maxDelay, spawnerDefinition.delay);\n+\n+        if (spawnerDefinition.maxDelay.compareTo(spawnerDefinition.minDelay) < 0) {\n+          throw new InvalidXMLException(\"Max delay cannot be smaller than min delay\", element);\n+        }\n+\n+        spawnerDefinition.maxEntities =\n+            XMLUtils.parseNumber(\n+                element.getAttribute(\"max-entities\"), Integer.class, Integer.MAX_VALUE);\n+        spawnerDefinition.filter =\n+            filterParser.parseFilterProperty(element, \"filter\", StaticFilter.ALLOW);\n+\n+        List<SpawnerObject> objects = new ArrayList<>();\n+        for (Element object : XMLUtils.getChildren(element, \"entity\", \"item\", \"tnt\", \"effect\")) {\n+          int count;\n+          switch (object.getName()) {\n+            case \"entity\":\n+              count = XMLUtils.parseNumber(object.getAttribute(\"count\"), Integer.class, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjMxMg==", "bodyText": "Make a helper method for that if check.", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416946312", "createdAt": "2020-04-28T21:52:25Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+  private final Logger logger;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private List<Player> trackedPlayers = new ArrayList<>();\n+\n+  private static final Random RANDOM = new Random();\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match, Logger logger) {\n+    this.definition = definition;\n+    this.match = match;\n+    this.logger = logger;\n+\n+    this.lastTick = match.getTick().tick;\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (SpawnerObject object : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(RANDOM);\n+        object.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()));\n+        if (object.isTracked()) {\n+          spawnedEntities = spawnedEntities + object.spawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (RANDOM.nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities < definition.maxEntities && trackedPlayers.size() != 0) {\n+      for (Player p : trackedPlayers) {\n+        if (definition.filter.query(match.getPlayer(p).getQuery()).isAllowed()) {\n+          return true;\n+        }\n+      }\n+      return false;\n+    }\n+    return false;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (event.getEntity().getMetadata(SpawnerModule.METADATA_KEY, PGM.get()) != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NzM2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (spawnedEntities < definition.maxEntities && trackedPlayers.size() != 0) {\n          \n          \n            \n               if (spawnedEntities  > definition.maxEntities || trackedPlayers.isEmpty()) return false;", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416947367", "createdAt": "2020-04-28T21:54:48Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+  private final Logger logger;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private List<Player> trackedPlayers = new ArrayList<>();\n+\n+  private static final Random RANDOM = new Random();\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match, Logger logger) {\n+    this.definition = definition;\n+    this.match = match;\n+    this.logger = logger;\n+\n+    this.lastTick = match.getTick().tick;\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (SpawnerObject object : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(RANDOM);\n+        object.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()));\n+        if (object.isTracked()) {\n+          spawnedEntities = spawnedEntities + object.spawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (RANDOM.nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities < definition.maxEntities && trackedPlayers.size() != 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59"}, "originalPosition": 84}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75d0e3c087261fd7eec035462609ad66caddf167", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/75d0e3c087261fd7eec035462609ad66caddf167", "committedDate": "2020-04-29T00:52:21Z", "message": "Make Spawner implement Feature and refactor some stuff\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "committedDate": "2020-04-29T19:13:20Z", "message": "Add particles and remove non-item spawnables\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMDkwMzY2", "url": "https://github.com/PGMDev/PGM/pull/432#pullrequestreview-403090366", "createdAt": "2020-04-29T22:41:00Z", "commit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMjo0MTowMFrOGOTnNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMzoxNDoyNlrOGOUULg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1NDU4MQ==", "bodyText": "So typically the best way to sort variables in a class is (at least in this project)\n// static variables\n//\n// final variables\n//\n// other variables\n\nprotected final static String METADATA_KEY = \"spawner\";\n\nprivate final Match match;\nprivate final SpawnerDefinition definition;\nprivate final OnlinePlayerMapAdapter<MatchPlayer> players;\n\nprivate long lastTick;\nprivate long currentDelay;\nprivate long spawnedEntities;", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417654581", "createdAt": "2020-04-29T22:41:00Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1NjEwOQ==", "bodyText": "Small if guards can be collapsed.\nif (!canSpawn()) return;\nCould also change this to be:\nif (!canSpawn() || match.getTick().tick - lastTick < generatedDelay) return;", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417656109", "createdAt": "2020-04-29T22:45:09Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1OTYyNA==", "bodyText": "Use final whenever you can.", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417659624", "createdAt": "2020-04-29T22:55:17Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1OTcwNw==", "bodyText": "Also this variable name can just be location", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417659707", "createdAt": "2020-04-29T22:55:32Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1OTYyNA=="}, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MDA3NQ==", "bodyText": "Use player instead of p, 1 letter arguments are usually only okay for Exception e in try/catch blocks.", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417660075", "createdAt": "2020-04-29T22:56:29Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MDE3Ng==", "bodyText": "isTracked", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417660176", "createdAt": "2020-04-29T22:56:45Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MDM1NQ==", "bodyText": "spawnedEntities -= event.getEntity().getItemStack().getAmount()", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417660355", "createdAt": "2020-04-29T22:57:16Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities = spawnedEntities - event.getEntity().getItemStack().getAmount();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MTYzMg==", "bodyText": "final MatchPlayer player = match.getParticipant(event.getPlayer());\nif (player == null) return;\n// ...", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417661632", "createdAt": "2020-04-29T23:01:10Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities = spawnedEntities - event.getEntity().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerPickup(PlayerPickupItemEvent event) {\n+    if (isTrackedEntity(event.getItem())) {\n+      spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerMove(CoarsePlayerMoveEvent event) {\n+    Player player = event.getPlayer();\n+    if (match.getPlayer(player).isObserving()) {\n+      return;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MjA0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (definition.playerRegion.contains(event.getPlayer()) && trackedPlayers.get(player) == null) {\n          \n          \n            \n                  trackedPlayers.put(player, match.getPlayer(player));\n          \n          \n            \n                } else if (!definition.playerRegion.contains(event.getPlayer())) {\n          \n          \n            \n                  trackedPlayers.remove(player);\n          \n          \n            \n                }\n          \n          \n            \n                if (definition.playerRegion.contains(event.getPlayer())) {\n          \n          \n            \n                  trackedPlayers.putIfAbsent(player, match.getPlayer(player));\n          \n          \n            \n                } else {\n          \n          \n            \n                  trackedPlayers.remove(player);\n          \n          \n            \n                }", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417662042", "createdAt": "2020-04-29T23:02:26Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities = spawnedEntities - event.getEntity().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerPickup(PlayerPickupItemEvent event) {\n+    if (isTrackedEntity(event.getItem())) {\n+      spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerMove(CoarsePlayerMoveEvent event) {\n+    Player player = event.getPlayer();\n+    if (match.getPlayer(player).isObserving()) {\n+      return;\n+    }\n+    if (definition.playerRegion.contains(event.getPlayer()) && trackedPlayers.get(player) == null) {\n+      trackedPlayers.put(player, match.getPlayer(player));\n+    } else if (!definition.playerRegion.contains(event.getPlayer())) {\n+      trackedPlayers.remove(player);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MjI1NQ==", "bodyText": "Since you're using OnlinePlayerMapAdapter players are automatically removed on quit, so you can remove this.", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417662255", "createdAt": "2020-04-29T23:03:08Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities = spawnedEntities - event.getEntity().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerPickup(PlayerPickupItemEvent event) {\n+    if (isTrackedEntity(event.getItem())) {\n+      spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerMove(CoarsePlayerMoveEvent event) {\n+    Player player = event.getPlayer();\n+    if (match.getPlayer(player).isObserving()) {\n+      return;\n+    }\n+    if (definition.playerRegion.contains(event.getPlayer()) && trackedPlayers.get(player) == null) {\n+      trackedPlayers.put(player, match.getPlayer(player));\n+    } else if (!definition.playerRegion.contains(event.getPlayer())) {\n+      trackedPlayers.remove(player);\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerQuit(PlayerQuitEvent event) {\n+    trackedPlayers.remove(event.getPlayer());\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MjkxMA==", "bodyText": "You'll want to clear this when the match ends. MatchFinishEvent", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417662910", "createdAt": "2020-04-29T23:05:03Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2Mzc1Ng==", "bodyText": "I'd make a constructor for this and use it. Make all these variables final.", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417663756", "createdAt": "2020-04-29T23:07:39Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerDefinition.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import tc.oc.pgm.api.feature.FeatureDefinition;\n+import tc.oc.pgm.api.feature.FeatureInfo;\n+import tc.oc.pgm.api.filter.Filter;\n+import tc.oc.pgm.api.region.Region;\n+\n+@FeatureInfo(name = \"spawner\")\n+public class SpawnerDefinition implements FeatureDefinition {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2NTIzNA==", "bodyText": "final", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417665234", "createdAt": "2020-04-29T23:11:57Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerMatchModule.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.List;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+\n+public class SpawnerMatchModule implements MatchModule {\n+\n+  private Match match;\n+  private List<SpawnerDefinition> definitions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2NTYwMg==", "bodyText": "Make this a private static final, change to spawner-item", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417665602", "createdAt": "2020-04-29T23:13:04Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/objects/SpawnableItem.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package tc.oc.pgm.spawner.objects;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Item;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.spawner.Spawnable;\n+import tc.oc.pgm.spawner.Spawner;\n+import tc.oc.pgm.util.nms.NMSHacks;\n+\n+public class SpawnableItem implements Spawnable {\n+\n+  private int count;\n+  private ItemStack stack;\n+  private String metadataValue = \"Spawner Item\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2NTc2NQ==", "bodyText": "Can't you set the count in ItemStack#setAmount ? And not need to store count?", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417665765", "createdAt": "2020-04-29T23:13:30Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/objects/SpawnableItem.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package tc.oc.pgm.spawner.objects;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Item;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.spawner.Spawnable;\n+import tc.oc.pgm.spawner.Spawner;\n+import tc.oc.pgm.util.nms.NMSHacks;\n+\n+public class SpawnableItem implements Spawnable {\n+\n+  private int count;\n+  private ItemStack stack;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2NjA5NA==", "bodyText": "Don't use NMSHacks it will soon be totally gone. For that API you can use World#spigot#playParticle (I think that's what it is)", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417666094", "createdAt": "2020-04-29T23:14:26Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/objects/SpawnableItem.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package tc.oc.pgm.spawner.objects;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Item;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.spawner.Spawnable;\n+import tc.oc.pgm.spawner.Spawner;\n+import tc.oc.pgm.util.nms.NMSHacks;\n+\n+public class SpawnableItem implements Spawnable {\n+\n+  private int count;\n+  private ItemStack stack;\n+  private String metadataValue = \"Spawner Item\";\n+\n+  public SpawnableItem(ItemStack stack) {\n+    this.count = stack.getAmount();\n+    this.stack = stack;\n+  }\n+\n+  @Override\n+  public void spawn(Location location, Match match) {\n+    Item item = location.getWorld().dropItem(location.add(0, 1, 0), stack);\n+    item.setMetadata(Spawner.METADATA_KEY, new FixedMetadataValue(PGM.get(), metadataValue));\n+\n+    Object particle =\n+        NMSHacks.particlesPacket(\n+            \"FLAME\", true, location.toVector(), new Vector(0.15, 0.15, 0.15), 0, 40);\n+    for (MatchPlayer player : match.getPlayers()) {\n+      NMSHacks.sendPacket(player.getBukkit(), particle);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0MTEzMzc1", "url": "https://github.com/PGMDev/PGM/pull/432#pullrequestreview-404113375", "createdAt": "2020-05-01T11:02:58Z", "commit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMTowMjo1OFrOGPHQkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxMTowNjozNFrOGPHUXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMDc1Mg==", "bodyText": "Can be one line\nif (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) return false;", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418500752", "createdAt": "2020-05-01T11:02:58Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMDg0OQ==", "bodyText": "Can also be one line:\nif (definition.playerFilter.query(p.getQuery()).isAllowed()) return true;", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418500849", "createdAt": "2020-05-01T11:03:30Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMTA2MA==", "bodyText": "final long", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418501060", "createdAt": "2020-05-01T11:04:19Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMTQzMg==", "bodyText": "if (isTrackedEntity(event.getEntity())) spawnedEntities--;", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418501432", "createdAt": "2020-05-01T11:05:42Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMTcyNA==", "bodyText": "if (match.getPlayer(player).isObserving()) return;", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418501724", "createdAt": "2020-05-01T11:06:34Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities = spawnedEntities - event.getEntity().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerPickup(PlayerPickupItemEvent event) {\n+    if (isTrackedEntity(event.getItem())) {\n+      spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerMove(CoarsePlayerMoveEvent event) {\n+    Player player = event.getPlayer();\n+    if (match.getPlayer(player).isObserving()) {\n+      return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7"}, "originalPosition": 135}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8943829d855b3a2b65dad079e1b2ff69e64814af", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/8943829d855b3a2b65dad079e1b2ff69e64814af", "committedDate": "2020-05-01T23:43:52Z", "message": "Merge branch 'master' into spawner-module"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fc649c86dc38581d2c1a9f3c93f42b7abef98c4", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/4fc649c86dc38581d2c1a9f3c93f42b7abef98c4", "committedDate": "2020-05-02T00:30:20Z", "message": "More code style changes, use #playEffect\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTM4Mjcz", "url": "https://github.com/PGMDev/PGM/pull/432#pullrequestreview-404538273", "createdAt": "2020-05-02T15:44:56Z", "commit": {"oid": "4fc649c86dc38581d2c1a9f3c93f42b7abef98c4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxNTo0NDo1NlrOGPkHSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxNTo0NTo1OFrOGPkHpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3MzUxNQ==", "bodyText": "Since you do toLocation twice below. Just have location be a Location.", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418973515", "createdAt": "2020-05-02T15:44:56Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Effect;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  public static final String METADATA_KEY = \"spawner\";\n+\n+  private final Match match;\n+  private final SpawnerDefinition definition;\n+  private final OnlinePlayerMapAdapter<MatchPlayer> players;\n+\n+  private long lastTick;\n+  private long currentDelay;\n+  private long spawnedEntities;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.players = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) return;\n+    if (match.getTick().tick - lastTick >= currentDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        final Vector location = definition.spawnRegion.getRandom(match.getRandom());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fc649c86dc38581d2c1a9f3c93f42b7abef98c4"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3MzU2Nw==", "bodyText": "I think this should be handled in generateDelay. Maybe rename the method calculateDelay", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418973567", "createdAt": "2020-05-02T15:45:36Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Effect;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  public static final String METADATA_KEY = \"spawner\";\n+\n+  private final Match match;\n+  private final SpawnerDefinition definition;\n+  private final OnlinePlayerMapAdapter<MatchPlayer> players;\n+\n+  private long lastTick;\n+  private long currentDelay;\n+  private long spawnedEntities;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.players = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) return;\n+    if (match.getTick().tick - lastTick >= currentDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        final Vector location = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(location.toLocation(match.getWorld()), match);\n+        match\n+            .getWorld()\n+            .spigot()\n+            .playEffect(\n+                location.toLocation(match.getWorld()), Effect.FLAME, 0, 0, 0, 0.15f, 0, 0, 40, 64);\n+\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fc649c86dc38581d2c1a9f3c93f42b7abef98c4"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3MzYwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();\n          \n          \n            \n                  spawnedEntities -= event.getItem().getItemStack().getAmount();", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418973605", "createdAt": "2020-05-02T15:45:58Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Effect;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  public static final String METADATA_KEY = \"spawner\";\n+\n+  private final Match match;\n+  private final SpawnerDefinition definition;\n+  private final OnlinePlayerMapAdapter<MatchPlayer> players;\n+\n+  private long lastTick;\n+  private long currentDelay;\n+  private long spawnedEntities;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.players = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) return;\n+    if (match.getTick().tick - lastTick >= currentDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        final Vector location = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(location.toLocation(match.getWorld()), match);\n+        match\n+            .getWorld()\n+            .spigot()\n+            .playEffect(\n+                location.toLocation(match.getWorld()), Effect.FLAME, 0, 0, 0, 0.15f, 0, 0, 40, 64);\n+\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      currentDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      currentDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || players.isEmpty()) return false;\n+    for (MatchPlayer player : players.values()) {\n+      if (definition.playerFilter.query(player.getQuery()).isAllowed()) return true;\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTracked(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTracked(event.getEntity())) spawnedEntities--;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTracked(event.getEntity()))\n+      spawnedEntities -= event.getEntity().getItemStack().getAmount();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerPickup(PlayerPickupItemEvent event) {\n+    if (isTracked(event.getItem()))\n+      spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4fc649c86dc38581d2c1a9f3c93f42b7abef98c4"}, "originalPosition": 115}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24760b150d33fef1d757cc8a398f4169d4d19f68", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/24760b150d33fef1d757cc8a398f4169d4d19f68", "committedDate": "2020-05-02T15:48:24Z", "message": "Merge branch 'master' into spawner-module"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c3b1f945cf605802246f444a9e74b8a59b781ab", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/5c3b1f945cf605802246f444a9e74b8a59b781ab", "committedDate": "2020-05-02T15:54:27Z", "message": "More small code style changes\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ccb62b0842a7c131b6cc352232116f0f0616f28", "author": {"user": {"login": "EricZeiberg", "name": "Eric Zeiberg"}}, "url": "https://github.com/PGMDev/PGM/commit/0ccb62b0842a7c131b6cc352232116f0f0616f28", "committedDate": "2020-05-02T15:54:44Z", "message": "Merge branch 'spawner-module' of https://github.com/EricZeiberg/PGM into spawner-module"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjM0ODY3", "url": "https://github.com/PGMDev/PGM/pull/432#pullrequestreview-404634867", "createdAt": "2020-05-03T16:25:25Z", "commit": {"oid": "0ccb62b0842a7c131b6cc352232116f0f0616f28"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 483, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}