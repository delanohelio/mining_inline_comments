{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2NTAyODc0", "number": 572, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxNDo0MToyOFrOESDnHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxNToyOToyN1rOESKKRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzY4OTg4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/tablist/LegacyMatchTabDisplay.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxNDo0MToyOFrOG3FSAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxNDo0MToyOFrOG3FSAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQxMTM5Mg==", "bodyText": "Can we use PGM scheduler primitives?", "url": "https://github.com/PGMDev/PGM/pull/572#discussion_r460411392", "createdAt": "2020-07-25T14:41:28Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/tablist/LegacyMatchTabDisplay.java", "diffHunk": "@@ -0,0 +1,419 @@\n+package tc.oc.pgm.tablist;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.TreeSet;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.kyori.text.format.TextDecoration;\n+import org.bukkit.ChatColor;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.HandlerList;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.player.PlayerJoinEvent;\n+import org.bukkit.event.player.PlayerLocaleChangeEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.scheduler.BukkitTask;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.party.Party;\n+import tc.oc.pgm.api.party.event.PartyRenameEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerVanishEvent;\n+import tc.oc.pgm.events.PlayerJoinMatchEvent;\n+import tc.oc.pgm.events.PlayerPartyChangeEvent;\n+import tc.oc.pgm.ffa.FreeForAllMatchModule;\n+import tc.oc.pgm.ffa.Tribute;\n+import tc.oc.pgm.teams.Team;\n+import tc.oc.pgm.teams.events.TeamResizeEvent;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.ViaUtils;\n+import tc.oc.pgm.util.named.NameStyle;\n+import tc.oc.pgm.util.tablist.TabDisplay;\n+import tc.oc.pgm.util.text.TextTranslations;\n+import tc.oc.pgm.util.text.types.PlayerComponent;\n+\n+/** 1.7 legacy tablist implementation */\n+public class LegacyMatchTabDisplay implements Listener {\n+\n+  private static final int WIDTH = 3;\n+\n+  // Maximum players that can be listed per team in non-compact mode, which is\n+  // the full height minus the header, blank row, and team header.\n+  private static final int MAX_TEAM_SIZE = TabDisplay.HEIGHT - 3;\n+\n+  // Number of players below the max before changing back to non-compact mode\n+  private static final int COMPACT_MODE_HYSTERESIS = 2;\n+\n+  private final PGM pgm;\n+  private final TabDisplay tabDisplay;\n+  private BukkitTask timeUpdateTask;\n+  private BukkitTask deferredRenderTask;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eafe1e11fcbffac8f9d30ddfabb4c94449936b30"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzY5MDQwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/tablist/LegacyMatchTabDisplay.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxNDo0MTo1OVrOG3FSOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxNDo0MTo1OVrOG3FSOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQxMTQ1MQ==", "bodyText": ">", "url": "https://github.com/PGMDev/PGM/pull/572#discussion_r460411451", "createdAt": "2020-07-25T14:41:59Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/tablist/LegacyMatchTabDisplay.java", "diffHunk": "@@ -0,0 +1,419 @@\n+package tc.oc.pgm.tablist;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.TreeSet;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.kyori.text.format.TextDecoration;\n+import org.bukkit.ChatColor;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.HandlerList;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.player.PlayerJoinEvent;\n+import org.bukkit.event.player.PlayerLocaleChangeEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.scheduler.BukkitTask;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.party.Party;\n+import tc.oc.pgm.api.party.event.PartyRenameEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerVanishEvent;\n+import tc.oc.pgm.events.PlayerJoinMatchEvent;\n+import tc.oc.pgm.events.PlayerPartyChangeEvent;\n+import tc.oc.pgm.ffa.FreeForAllMatchModule;\n+import tc.oc.pgm.ffa.Tribute;\n+import tc.oc.pgm.teams.Team;\n+import tc.oc.pgm.teams.events.TeamResizeEvent;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.ViaUtils;\n+import tc.oc.pgm.util.named.NameStyle;\n+import tc.oc.pgm.util.tablist.TabDisplay;\n+import tc.oc.pgm.util.text.TextTranslations;\n+import tc.oc.pgm.util.text.types.PlayerComponent;\n+\n+/** 1.7 legacy tablist implementation */\n+public class LegacyMatchTabDisplay implements Listener {\n+\n+  private static final int WIDTH = 3;\n+\n+  // Maximum players that can be listed per team in non-compact mode, which is\n+  // the full height minus the header, blank row, and team header.\n+  private static final int MAX_TEAM_SIZE = TabDisplay.HEIGHT - 3;\n+\n+  // Number of players below the max before changing back to non-compact mode\n+  private static final int COMPACT_MODE_HYSTERESIS = 2;\n+\n+  private final PGM pgm;\n+  private final TabDisplay tabDisplay;\n+  private BukkitTask timeUpdateTask;\n+  private BukkitTask deferredRenderTask;\n+\n+  // True: use all columns as a single list of all players\n+  // False: use a full column for each team\n+  private boolean compact;\n+\n+  public LegacyMatchTabDisplay(PGM pgm) {\n+    this.pgm = pgm;\n+    this.tabDisplay = new TabDisplay(pgm, WIDTH);\n+  }\n+\n+  public void enable() {\n+    this.tabDisplay.enable();\n+\n+    for (Player viewer : this.pgm.getServer().getOnlinePlayers()) {\n+      if (ViaUtils.getProtocolVersion(viewer) != ViaUtils.VERSION_1_7) return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eafe1e11fcbffac8f9d30ddfabb4c94449936b30"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzY5MDc0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/tablist/LegacyMatchTabDisplay.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxNDo0MjozOFrOG3FSZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxNDo0MjozOFrOG3FSZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQxMTQ5Mg==", "bodyText": "> Same for all these checks, if someone we can allow 1.6 players then why not", "url": "https://github.com/PGMDev/PGM/pull/572#discussion_r460411492", "createdAt": "2020-07-25T14:42:38Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/tablist/LegacyMatchTabDisplay.java", "diffHunk": "@@ -0,0 +1,419 @@\n+package tc.oc.pgm.tablist;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.TreeSet;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.kyori.text.format.TextDecoration;\n+import org.bukkit.ChatColor;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.HandlerList;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.player.PlayerJoinEvent;\n+import org.bukkit.event.player.PlayerLocaleChangeEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.scheduler.BukkitTask;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.party.Party;\n+import tc.oc.pgm.api.party.event.PartyRenameEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerVanishEvent;\n+import tc.oc.pgm.events.PlayerJoinMatchEvent;\n+import tc.oc.pgm.events.PlayerPartyChangeEvent;\n+import tc.oc.pgm.ffa.FreeForAllMatchModule;\n+import tc.oc.pgm.ffa.Tribute;\n+import tc.oc.pgm.teams.Team;\n+import tc.oc.pgm.teams.events.TeamResizeEvent;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.ViaUtils;\n+import tc.oc.pgm.util.named.NameStyle;\n+import tc.oc.pgm.util.tablist.TabDisplay;\n+import tc.oc.pgm.util.text.TextTranslations;\n+import tc.oc.pgm.util.text.types.PlayerComponent;\n+\n+/** 1.7 legacy tablist implementation */\n+public class LegacyMatchTabDisplay implements Listener {\n+\n+  private static final int WIDTH = 3;\n+\n+  // Maximum players that can be listed per team in non-compact mode, which is\n+  // the full height minus the header, blank row, and team header.\n+  private static final int MAX_TEAM_SIZE = TabDisplay.HEIGHT - 3;\n+\n+  // Number of players below the max before changing back to non-compact mode\n+  private static final int COMPACT_MODE_HYSTERESIS = 2;\n+\n+  private final PGM pgm;\n+  private final TabDisplay tabDisplay;\n+  private BukkitTask timeUpdateTask;\n+  private BukkitTask deferredRenderTask;\n+\n+  // True: use all columns as a single list of all players\n+  // False: use a full column for each team\n+  private boolean compact;\n+\n+  public LegacyMatchTabDisplay(PGM pgm) {\n+    this.pgm = pgm;\n+    this.tabDisplay = new TabDisplay(pgm, WIDTH);\n+  }\n+\n+  public void enable() {\n+    this.tabDisplay.enable();\n+\n+    for (Player viewer : this.pgm.getServer().getOnlinePlayers()) {\n+      if (ViaUtils.getProtocolVersion(viewer) != ViaUtils.VERSION_1_7) return;\n+      this.tabDisplay.addViewer(viewer);\n+    }\n+\n+    this.pgm.getServer().getPluginManager().registerEvents(this, this.pgm);\n+    this.timeUpdateTask =\n+        this.pgm\n+            .getServer()\n+            .getScheduler()\n+            .runTaskTimer(\n+                this.pgm,\n+                () -> {\n+                  Iterator<Match> matches = PGM.get().getMatchManager().getMatches();\n+                  if (matches.hasNext()) {\n+                    for (MatchPlayer viewer : matches.next().getPlayers()) {\n+                      LegacyMatchTabDisplay.this.renderTime(viewer);\n+                    }\n+                  }\n+                },\n+                0,\n+                20);\n+  }\n+\n+  public void disable() {\n+    if (this.deferredRenderTask != null) {\n+      this.deferredRenderTask.cancel();\n+      this.deferredRenderTask = null;\n+    }\n+\n+    this.timeUpdateTask.cancel();\n+    this.timeUpdateTask = null;\n+\n+    HandlerList.unregisterAll(this);\n+    this.tabDisplay.disable();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onPlayerJoin(PlayerJoinEvent event) {\n+    if (ViaUtils.getProtocolVersion(event.getPlayer()) != ViaUtils.VERSION_1_7) return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eafe1e11fcbffac8f9d30ddfabb4c94449936b30"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzY5MTcxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/tablist/LegacyMatchTabDisplay.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxNDo0NDowMFrOG3FS0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQwNzowODo0MlrOG3KDhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQxMTYwMw==", "bodyText": "TBH I think we can leave this out. If too many, just show the first one.", "url": "https://github.com/PGMDev/PGM/pull/572#discussion_r460411603", "createdAt": "2020-07-25T14:44:00Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/tablist/LegacyMatchTabDisplay.java", "diffHunk": "@@ -0,0 +1,419 @@\n+package tc.oc.pgm.tablist;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.TreeSet;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.kyori.text.format.TextDecoration;\n+import org.bukkit.ChatColor;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.HandlerList;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.player.PlayerJoinEvent;\n+import org.bukkit.event.player.PlayerLocaleChangeEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.scheduler.BukkitTask;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.party.Party;\n+import tc.oc.pgm.api.party.event.PartyRenameEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerVanishEvent;\n+import tc.oc.pgm.events.PlayerJoinMatchEvent;\n+import tc.oc.pgm.events.PlayerPartyChangeEvent;\n+import tc.oc.pgm.ffa.FreeForAllMatchModule;\n+import tc.oc.pgm.ffa.Tribute;\n+import tc.oc.pgm.teams.Team;\n+import tc.oc.pgm.teams.events.TeamResizeEvent;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.ViaUtils;\n+import tc.oc.pgm.util.named.NameStyle;\n+import tc.oc.pgm.util.tablist.TabDisplay;\n+import tc.oc.pgm.util.text.TextTranslations;\n+import tc.oc.pgm.util.text.types.PlayerComponent;\n+\n+/** 1.7 legacy tablist implementation */\n+public class LegacyMatchTabDisplay implements Listener {\n+\n+  private static final int WIDTH = 3;\n+\n+  // Maximum players that can be listed per team in non-compact mode, which is\n+  // the full height minus the header, blank row, and team header.\n+  private static final int MAX_TEAM_SIZE = TabDisplay.HEIGHT - 3;\n+\n+  // Number of players below the max before changing back to non-compact mode\n+  private static final int COMPACT_MODE_HYSTERESIS = 2;\n+\n+  private final PGM pgm;\n+  private final TabDisplay tabDisplay;\n+  private BukkitTask timeUpdateTask;\n+  private BukkitTask deferredRenderTask;\n+\n+  // True: use all columns as a single list of all players\n+  // False: use a full column for each team\n+  private boolean compact;\n+\n+  public LegacyMatchTabDisplay(PGM pgm) {\n+    this.pgm = pgm;\n+    this.tabDisplay = new TabDisplay(pgm, WIDTH);\n+  }\n+\n+  public void enable() {\n+    this.tabDisplay.enable();\n+\n+    for (Player viewer : this.pgm.getServer().getOnlinePlayers()) {\n+      if (ViaUtils.getProtocolVersion(viewer) != ViaUtils.VERSION_1_7) return;\n+      this.tabDisplay.addViewer(viewer);\n+    }\n+\n+    this.pgm.getServer().getPluginManager().registerEvents(this, this.pgm);\n+    this.timeUpdateTask =\n+        this.pgm\n+            .getServer()\n+            .getScheduler()\n+            .runTaskTimer(\n+                this.pgm,\n+                () -> {\n+                  Iterator<Match> matches = PGM.get().getMatchManager().getMatches();\n+                  if (matches.hasNext()) {\n+                    for (MatchPlayer viewer : matches.next().getPlayers()) {\n+                      LegacyMatchTabDisplay.this.renderTime(viewer);\n+                    }\n+                  }\n+                },\n+                0,\n+                20);\n+  }\n+\n+  public void disable() {\n+    if (this.deferredRenderTask != null) {\n+      this.deferredRenderTask.cancel();\n+      this.deferredRenderTask = null;\n+    }\n+\n+    this.timeUpdateTask.cancel();\n+    this.timeUpdateTask = null;\n+\n+    HandlerList.unregisterAll(this);\n+    this.tabDisplay.disable();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onPlayerJoin(PlayerJoinEvent event) {\n+    if (ViaUtils.getProtocolVersion(event.getPlayer()) != ViaUtils.VERSION_1_7) return;\n+    this.tabDisplay.addViewer(event.getPlayer());\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onPlayerQuit(PlayerQuitEvent event) {\n+    if (PGM.get().getMatchManager().getMatch(event.getPlayer()) != null) {\n+      this.deferredRender();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onPlayerJoinMatch(final PlayerJoinMatchEvent event) {\n+    this.deferredRender();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onPlayerTeamChange(PlayerPartyChangeEvent event) {\n+    this.deferredRender();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onTeamRename(PartyRenameEvent event) {\n+    this.deferredRender();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onTeamResize(TeamResizeEvent event) {\n+    this.deferredRender();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerVanish(PlayerVanishEvent event) {\n+    this.deferredRender();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerLocaleChange(PlayerLocaleChangeEvent event) {\n+    MatchPlayer player = PGM.get().getMatchManager().getPlayer(event.getPlayer());\n+    if (player != null) {\n+      this.render(player);\n+    }\n+  }\n+\n+  public void deferredRender() {\n+    if (this.deferredRenderTask != null) return;\n+\n+    // Render one tick later so the effects of the event are visible, and so multiple updates are\n+    // batched\n+    this.deferredRenderTask =\n+        PGM.get()\n+            .getServer()\n+            .getScheduler()\n+            .runTask(\n+                PGM.get(),\n+                () -> {\n+                  Match last = null;\n+                  Iterator<Match> it = PGM.get().getMatchManager().getMatches();\n+                  while (it.hasNext()) last = it.next();\n+                  if (last != null) LegacyMatchTabDisplay.this.render(last);\n+                  LegacyMatchTabDisplay.this.deferredRenderTask = null;\n+                });\n+  }\n+\n+  public void render(Match match) {\n+    int largestTeam = 0;\n+    for (Competitor team : match.getCompetitors()) {\n+      if (team.getPlayers().size() > largestTeam) {\n+        largestTeam = team.getPlayers().size();\n+      }\n+    }\n+\n+    // Have a margin between switching modes, so it doesn't flicker back and forth\n+    this.compact =\n+        match.getCompetitors().size() > WIDTH\n+            || largestTeam > MAX_TEAM_SIZE\n+            || (this.compact && largestTeam > MAX_TEAM_SIZE - COMPACT_MODE_HYSTERESIS);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      this.render(viewer);\n+    }\n+  }\n+\n+  public void render(MatchPlayer viewer) {\n+    if (viewer.getProtocolVersion() != ViaUtils.VERSION_1_7) return;\n+\n+    Player bukkit = viewer.getBukkit();\n+    MapInfo mapInfo = viewer.getMatch().getMap();\n+\n+    // Show map name in the top left corner, taking a very rough guess at the length limit.\n+    // We could maybe use ChatUtils.pixelWidth() in the future for more accuracy.\n+    String mapName = mapInfo.getName();\n+    if (mapName.length() > 15) {\n+      mapName = mapName.substring(0, 14) + \"...\";\n+    }\n+    this.tabDisplay.set(bukkit, 0, 0, ChatColor.AQUA + mapName);\n+\n+    // If there is exactly one map author, show their name in the top middle slot.\n+    // Multiple names will surely not fit, so showing none of them is the only fair thing.\n+    if (mapInfo.getAuthors().size() == 1) {\n+      this.tabDisplay.set(\n+          bukkit,\n+          1,\n+          0,\n+          TextTranslations.translateLegacy(\n+              TranslatableComponent.of(\n+                  \"misc.by\",\n+                  TextColor.DARK_GRAY,\n+                  TextComponent.of(\n+                      mapInfo.getAuthors().iterator().next().getNameLegacy(), TextColor.GRAY)),\n+              viewer.getBukkit()));\n+    } else {\n+      this.tabDisplay.set(\n+          bukkit,\n+          1,\n+          0,\n+          TextTranslations.translateLegacy(\n+              TranslatableComponent.of(\n+                  \"tablist.authors.tooMany\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eafe1e11fcbffac8f9d30ddfabb4c94449936b30"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQ4OTYwNQ==", "bodyText": "Showing first author, would be unfair for the other authors on there", "url": "https://github.com/PGMDev/PGM/pull/572#discussion_r460489605", "createdAt": "2020-07-26T07:08:42Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/tablist/LegacyMatchTabDisplay.java", "diffHunk": "@@ -0,0 +1,419 @@\n+package tc.oc.pgm.tablist;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.TreeSet;\n+import net.kyori.text.TextComponent;\n+import net.kyori.text.TranslatableComponent;\n+import net.kyori.text.format.TextColor;\n+import net.kyori.text.format.TextDecoration;\n+import org.bukkit.ChatColor;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.HandlerList;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.player.PlayerJoinEvent;\n+import org.bukkit.event.player.PlayerLocaleChangeEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.scheduler.BukkitTask;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.Permissions;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.party.Competitor;\n+import tc.oc.pgm.api.party.Party;\n+import tc.oc.pgm.api.party.event.PartyRenameEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.community.events.PlayerVanishEvent;\n+import tc.oc.pgm.events.PlayerJoinMatchEvent;\n+import tc.oc.pgm.events.PlayerPartyChangeEvent;\n+import tc.oc.pgm.ffa.FreeForAllMatchModule;\n+import tc.oc.pgm.ffa.Tribute;\n+import tc.oc.pgm.teams.Team;\n+import tc.oc.pgm.teams.events.TeamResizeEvent;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.ViaUtils;\n+import tc.oc.pgm.util.named.NameStyle;\n+import tc.oc.pgm.util.tablist.TabDisplay;\n+import tc.oc.pgm.util.text.TextTranslations;\n+import tc.oc.pgm.util.text.types.PlayerComponent;\n+\n+/** 1.7 legacy tablist implementation */\n+public class LegacyMatchTabDisplay implements Listener {\n+\n+  private static final int WIDTH = 3;\n+\n+  // Maximum players that can be listed per team in non-compact mode, which is\n+  // the full height minus the header, blank row, and team header.\n+  private static final int MAX_TEAM_SIZE = TabDisplay.HEIGHT - 3;\n+\n+  // Number of players below the max before changing back to non-compact mode\n+  private static final int COMPACT_MODE_HYSTERESIS = 2;\n+\n+  private final PGM pgm;\n+  private final TabDisplay tabDisplay;\n+  private BukkitTask timeUpdateTask;\n+  private BukkitTask deferredRenderTask;\n+\n+  // True: use all columns as a single list of all players\n+  // False: use a full column for each team\n+  private boolean compact;\n+\n+  public LegacyMatchTabDisplay(PGM pgm) {\n+    this.pgm = pgm;\n+    this.tabDisplay = new TabDisplay(pgm, WIDTH);\n+  }\n+\n+  public void enable() {\n+    this.tabDisplay.enable();\n+\n+    for (Player viewer : this.pgm.getServer().getOnlinePlayers()) {\n+      if (ViaUtils.getProtocolVersion(viewer) != ViaUtils.VERSION_1_7) return;\n+      this.tabDisplay.addViewer(viewer);\n+    }\n+\n+    this.pgm.getServer().getPluginManager().registerEvents(this, this.pgm);\n+    this.timeUpdateTask =\n+        this.pgm\n+            .getServer()\n+            .getScheduler()\n+            .runTaskTimer(\n+                this.pgm,\n+                () -> {\n+                  Iterator<Match> matches = PGM.get().getMatchManager().getMatches();\n+                  if (matches.hasNext()) {\n+                    for (MatchPlayer viewer : matches.next().getPlayers()) {\n+                      LegacyMatchTabDisplay.this.renderTime(viewer);\n+                    }\n+                  }\n+                },\n+                0,\n+                20);\n+  }\n+\n+  public void disable() {\n+    if (this.deferredRenderTask != null) {\n+      this.deferredRenderTask.cancel();\n+      this.deferredRenderTask = null;\n+    }\n+\n+    this.timeUpdateTask.cancel();\n+    this.timeUpdateTask = null;\n+\n+    HandlerList.unregisterAll(this);\n+    this.tabDisplay.disable();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onPlayerJoin(PlayerJoinEvent event) {\n+    if (ViaUtils.getProtocolVersion(event.getPlayer()) != ViaUtils.VERSION_1_7) return;\n+    this.tabDisplay.addViewer(event.getPlayer());\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onPlayerQuit(PlayerQuitEvent event) {\n+    if (PGM.get().getMatchManager().getMatch(event.getPlayer()) != null) {\n+      this.deferredRender();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onPlayerJoinMatch(final PlayerJoinMatchEvent event) {\n+    this.deferredRender();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onPlayerTeamChange(PlayerPartyChangeEvent event) {\n+    this.deferredRender();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onTeamRename(PartyRenameEvent event) {\n+    this.deferredRender();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n+  public void onTeamResize(TeamResizeEvent event) {\n+    this.deferredRender();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerVanish(PlayerVanishEvent event) {\n+    this.deferredRender();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerLocaleChange(PlayerLocaleChangeEvent event) {\n+    MatchPlayer player = PGM.get().getMatchManager().getPlayer(event.getPlayer());\n+    if (player != null) {\n+      this.render(player);\n+    }\n+  }\n+\n+  public void deferredRender() {\n+    if (this.deferredRenderTask != null) return;\n+\n+    // Render one tick later so the effects of the event are visible, and so multiple updates are\n+    // batched\n+    this.deferredRenderTask =\n+        PGM.get()\n+            .getServer()\n+            .getScheduler()\n+            .runTask(\n+                PGM.get(),\n+                () -> {\n+                  Match last = null;\n+                  Iterator<Match> it = PGM.get().getMatchManager().getMatches();\n+                  while (it.hasNext()) last = it.next();\n+                  if (last != null) LegacyMatchTabDisplay.this.render(last);\n+                  LegacyMatchTabDisplay.this.deferredRenderTask = null;\n+                });\n+  }\n+\n+  public void render(Match match) {\n+    int largestTeam = 0;\n+    for (Competitor team : match.getCompetitors()) {\n+      if (team.getPlayers().size() > largestTeam) {\n+        largestTeam = team.getPlayers().size();\n+      }\n+    }\n+\n+    // Have a margin between switching modes, so it doesn't flicker back and forth\n+    this.compact =\n+        match.getCompetitors().size() > WIDTH\n+            || largestTeam > MAX_TEAM_SIZE\n+            || (this.compact && largestTeam > MAX_TEAM_SIZE - COMPACT_MODE_HYSTERESIS);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      this.render(viewer);\n+    }\n+  }\n+\n+  public void render(MatchPlayer viewer) {\n+    if (viewer.getProtocolVersion() != ViaUtils.VERSION_1_7) return;\n+\n+    Player bukkit = viewer.getBukkit();\n+    MapInfo mapInfo = viewer.getMatch().getMap();\n+\n+    // Show map name in the top left corner, taking a very rough guess at the length limit.\n+    // We could maybe use ChatUtils.pixelWidth() in the future for more accuracy.\n+    String mapName = mapInfo.getName();\n+    if (mapName.length() > 15) {\n+      mapName = mapName.substring(0, 14) + \"...\";\n+    }\n+    this.tabDisplay.set(bukkit, 0, 0, ChatColor.AQUA + mapName);\n+\n+    // If there is exactly one map author, show their name in the top middle slot.\n+    // Multiple names will surely not fit, so showing none of them is the only fair thing.\n+    if (mapInfo.getAuthors().size() == 1) {\n+      this.tabDisplay.set(\n+          bukkit,\n+          1,\n+          0,\n+          TextTranslations.translateLegacy(\n+              TranslatableComponent.of(\n+                  \"misc.by\",\n+                  TextColor.DARK_GRAY,\n+                  TextComponent.of(\n+                      mapInfo.getAuthors().iterator().next().getNameLegacy(), TextColor.GRAY)),\n+              viewer.getBukkit()));\n+    } else {\n+      this.tabDisplay.set(\n+          bukkit,\n+          1,\n+          0,\n+          TextTranslations.translateLegacy(\n+              TranslatableComponent.of(\n+                  \"tablist.authors.tooMany\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQxMTYwMw=="}, "originalCommit": {"oid": "eafe1e11fcbffac8f9d30ddfabb4c94449936b30"}, "originalPosition": 229}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3MzY5Mjc2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/tablist/MatchTabManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxNDo0NToxN1rOG3FTRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxNDo0NToxN1rOG3FTRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQxMTcxOA==", "bodyText": "<=", "url": "https://github.com/PGMDev/PGM/pull/572#discussion_r460411718", "createdAt": "2020-07-25T14:45:17Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/tablist/MatchTabManager.java", "diffHunk": "@@ -117,7 +122,8 @@ protected void invalidate(MatchPlayer player) {\n \n   @EventHandler(priority = EventPriority.MONITOR, ignoreCancelled = true)\n   public void onJoin(PlayerJoinEvent event) {\n-    TabView view = this.getView(event.getPlayer());\n+    if (ViaUtils.getProtocolVersion(event.getPlayer()) == ViaUtils.VERSION_1_7) return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eafe1e11fcbffac8f9d30ddfabb4c94449936b30"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NDc2MjkyOnYy", "diffSide": "RIGHT", "path": "util/src/main/i18n/templates/map.properties", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxNToyOToyN1rOG3NLZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxNToyOToyN1rOG3NLZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU0MDc3Mg==", "bodyText": "map.info.commandHint = Type {0} for info", "url": "https://github.com/PGMDev/PGM/pull/572#discussion_r460540772", "createdAt": "2020-07-26T15:29:27Z", "author": {"login": "Electroid"}, "path": "util/src/main/i18n/templates/map.properties", "diffHunk": "@@ -56,6 +56,8 @@ map.setNext.revert = {0} has removed {1} as the next map\n \n map.noNextMap = No next map\n \n+tablist.authors.tooMany = type {0} for info", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da21445d845465bed8bd3388f6efdcc8a833efe9"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1015, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}