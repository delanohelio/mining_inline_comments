{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg4MDU5OTY5", "number": 356, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNVQyMTo0MDozN1rODoJQHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNjowODozNVrODqKyIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNDIxMjEyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/listeners/ChatDispatcher.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNVQyMTo0MDozN1rOF2hcqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQxNjo1NzowMVrOF29SgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcxNTQzNQ==", "bodyText": "I think this should be translatable too.", "url": "https://github.com/PGMDev/PGM/pull/356#discussion_r392715435", "createdAt": "2020-03-15T21:40:37Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/listeners/ChatDispatcher.java", "diffHunk": "@@ -217,6 +218,12 @@ public void sendReply(Match match, Audience audience, MatchPlayer sender, @Text\n     sendDirect(match, sender, receiver.getBukkit(), message);\n   }\n \n+  private static PersonalizedText formatPrivateMessage(String key) {\n+    return new PersonalizedText(\n+        new PersonalizedTranslatable(key).getPersonalizedText().color(ChatColor.GRAY).italic(true),\n+        new PersonalizedText(\" {0}: {1}\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f7349ce9380cfea58ef8e392d8bf8d7564ad14e"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyNDEzNA==", "bodyText": "@TheMolkaPL In a previous PR(not sure which of mine) I\u2019m pretty sure someone stated they would rather keep formatting \u201cstyles\" outside of the translation files. I\u2019m been trying to adhere to that. Do you think this situation would be acceptable to be translatable?", "url": "https://github.com/PGMDev/PGM/pull/356#discussion_r392724134", "createdAt": "2020-03-15T23:17:06Z", "author": {"login": "applenick"}, "path": "core/src/main/java/tc/oc/pgm/listeners/ChatDispatcher.java", "diffHunk": "@@ -217,6 +218,12 @@ public void sendReply(Match match, Audience audience, MatchPlayer sender, @Text\n     sendDirect(match, sender, receiver.getBukkit(), message);\n   }\n \n+  private static PersonalizedText formatPrivateMessage(String key) {\n+    return new PersonalizedText(\n+        new PersonalizedTranslatable(key).getPersonalizedText().color(ChatColor.GRAY).italic(true),\n+        new PersonalizedText(\" {0}: {1}\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcxNTQzNQ=="}, "originalCommit": {"oid": "7f7349ce9380cfea58ef8e392d8bf8d7564ad14e"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcyOTY2NQ==", "bodyText": "In Arabic this should be TEST :applenick3 [A] since they read right-to-left.", "url": "https://github.com/PGMDev/PGM/pull/356#discussion_r392729665", "createdAt": "2020-03-16T00:05:38Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/listeners/ChatDispatcher.java", "diffHunk": "@@ -217,6 +218,12 @@ public void sendReply(Match match, Audience audience, MatchPlayer sender, @Text\n     sendDirect(match, sender, receiver.getBukkit(), message);\n   }\n \n+  private static PersonalizedText formatPrivateMessage(String key) {\n+    return new PersonalizedText(\n+        new PersonalizedTranslatable(key).getPersonalizedText().color(ChatColor.GRAY).italic(true),\n+        new PersonalizedText(\" {0}: {1}\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcxNTQzNQ=="}, "originalCommit": {"oid": "7f7349ce9380cfea58ef8e392d8bf8d7564ad14e"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3MTU4NQ==", "bodyText": "Excuse me, but i'm not sure this makes much sense. Minecraft doesn't support right-to-left to start with, and it's not like changing order of parameters in formatting is the way that you apply RTL", "url": "https://github.com/PGMDev/PGM/pull/356#discussion_r393171585", "createdAt": "2020-03-16T16:57:01Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/listeners/ChatDispatcher.java", "diffHunk": "@@ -217,6 +218,12 @@ public void sendReply(Match match, Audience audience, MatchPlayer sender, @Text\n     sendDirect(match, sender, receiver.getBukkit(), message);\n   }\n \n+  private static PersonalizedText formatPrivateMessage(String key) {\n+    return new PersonalizedText(\n+        new PersonalizedTranslatable(key).getPersonalizedText().color(ChatColor.GRAY).italic(true),\n+        new PersonalizedText(\" {0}: {1}\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcxNTQzNQ=="}, "originalCommit": {"oid": "7f7349ce9380cfea58ef8e392d8bf8d7564ad14e"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NTQzNDU4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/listeners/ChatDispatcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNjowODozNVrOF5wrMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNjowODozNVrOF5wrMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMDY0MQ==", "bodyText": "I think this is neat, but we don't need it. If staff want to say something, they can just use global, rarely do you need to address a single team.", "url": "https://github.com/PGMDev/PGM/pull/356#discussion_r396110641", "createdAt": "2020-03-22T16:08:35Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/listeners/ChatDispatcher.java", "diffHunk": "@@ -172,54 +188,91 @@ public void sendDirect(Match match, MatchPlayer sender, Player receiver, @Text S\n                 .color(ChatColor.RED));\n         return; // Only allow staff to message muted players\n       } else {\n-        playMessageSound(matchReceiver);\n+        playSound(matchReceiver, DM_SOUND);\n       }\n     }\n \n     if (sender != null) {\n       lastMessagedBy.put(receiver, sender.getId());\n     }\n \n+    // Send message to receiver\n     send(\n         match,\n         sender,\n         message,\n-        \"[\" + ChatColor.GOLD + \"DM\" + ChatColor.WHITE + \"] {0}: {1}\",\n+        formatPrivateMessage(\"commands.message.from\", matchReceiver.getBukkit()),\n         viewer -> viewer.getBukkit().equals(receiver),\n         null);\n \n+    // Send message to the sender\n     send(\n         match,\n         manager.getPlayer(receiver), // Allow for cross-match messages\n         message,\n-        \"[\" + ChatColor.GOLD + \"DM\" + ChatColor.WHITE + \"] -> {0}: {1}\",\n+        formatPrivateMessage(\"commands.message.to\", sender.getBukkit()),\n         viewer -> viewer.getBukkit().equals(sender.getBukkit()),\n         null);\n   }\n \n+  private String formatPrivateMessage(String key, CommandSender viewer) {\n+    Component action =\n+        new PersonalizedTranslatable(key).getPersonalizedText().color(ChatColor.GRAY).italic(true);\n+    return ComponentRenderers.toLegacyText(\n+        new PersonalizedText(action, new PersonalizedText(\" {0}: {1}\")), viewer);\n+  }\n+\n   @Command(\n       aliases = {\"reply\", \"r\"},\n       desc = \"Reply to a direct message\",\n       usage = \"[message]\")\n   public void sendReply(Match match, Audience audience, MatchPlayer sender, @Text String message) {\n     final MatchPlayer receiver = manager.getPlayer(lastMessagedBy.get(sender.getBukkit()));\n     if (receiver == null) {\n-      audience.sendWarning(\n-          new PersonalizedText(\"Did not find a message to reply to, use /msg\")); // TODO: translate\n+      audience.sendWarning(new PersonalizedTranslatable(\"commands.message.noReply\"));\n       return;\n     }\n \n     sendDirect(match, sender, receiver.getBukkit(), message);\n   }\n \n-  private static MatchPlayer getApproximatePlayer(Match match, String query, CommandSender sender) {\n-    return StringUtils.bestFuzzyMatch(\n-        query,\n-        match.getPlayers().stream()\n-            .collect(\n-                Collectors.toMap(\n-                    player -> player.getBukkit().getName(sender), Function.identity())),\n-        0.75);\n+  @Command(\n+      aliases = {\"s\", \"say\", \"send\", \"sendteam\"},\n+      desc = \"Send a message to a specfic team chat\",\n+      usage = \"[team] [message]\",\n+      perms = Permissions.STAFF)\n+  public void sendOtherTeamChat(\n+      MatchPlayer player, Match match, String targetParty, @Text String message) {\n+    Party party = getApproximateParty(match, targetParty);\n+\n+    if (party == null) {\n+      player.sendWarning(\n+          new PersonalizedTranslatable(\n+              \"commands.chat.send.noParty\", new PersonalizedText(message).color(ChatColor.AQUA)));\n+      return;\n+    }\n+\n+    if (match.isFinished() || party instanceof Tribute) {\n+      player.sendWarning(new PersonalizedTranslatable(\"commands.chat.send.finished\"));\n+      return;\n+    }\n+\n+    if (!player.isObserving()) {\n+      player.sendWarning(new PersonalizedTranslatable(\"commands.chat.send.notObs\"));\n+      return;\n+    }\n+\n+    // Same format as team chat command\n+    send(\n+        match,\n+        player,\n+        message,\n+        party.getChatPrefix().toLegacyText() + PREFIX_FORMAT,\n+        viewer ->\n+            party.equals(viewer.getParty())\n+                || (viewer.isObserving()\n+                    && viewer.getBukkit().hasPermission(Permissions.ADMINCHAT)),\n+        SettingValue.CHAT_TEAM);\n   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6616e45b0f7b708733aee3814a0d7b469ef324ea"}, "originalPosition": 205}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1055, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}