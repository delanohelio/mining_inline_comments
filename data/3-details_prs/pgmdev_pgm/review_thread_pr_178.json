{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU4NzQ0NDIx", "number": 178, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wMlQxODoxMjo1MVrODVgoSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wMlQxODoxMjo1MVrODVgoSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjIzODgxMjkxOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/match/MatchManagerImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wMlQxODoxMjo1MVrOFZxpnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wMlQxODoyMDoyMlrOFZxzLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MjE4OA==", "bodyText": "Logger?", "url": "https://github.com/PGMDev/PGM/pull/178#discussion_r362572188", "createdAt": "2020-01-02T18:12:51Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/match/MatchManagerImpl.java", "diffHunk": "@@ -197,39 +197,30 @@ private World createMatchWorld(String worldName, MapInfo info, TerrainModule ter\n   }\n \n   /**\n-   * Creates a new world, wich must be done on the primary thread. If already running on the primary\n-   * thread, calls createWorld, otherwise, starts a sync task to run create world, and waits until\n-   * it's done.\n+   * Creates a new world, which must be done on the primary thread. If already running on the\n+   * primary thread, calls createWorld, otherwise, starts a sync task to run create world, and waits\n+   * until it's done.\n    *\n    * @param creator The creator for the world\n    * @return A world if it was able to be created, null otherwise\n    */\n   private World createWorld(final WorldCreator creator) {\n     if (server.isPrimaryThread()) return server.createWorld(creator);\n-\n-    // FIXME: This is pretty dirty, there must be a better way to run & wait on main\n-    final Object LOCK = new Object();\n+    final CountDownLatch latch = new CountDownLatch(1);\n     final AtomicReference<World> world = new AtomicReference<>();\n-    final AtomicBoolean isDone = new AtomicBoolean();\n     PGM.get()\n         .getServer()\n         .getScheduler()\n         .runTask(\n             PGM.get(),\n             () -> {\n               world.set(server.createWorld(creator));\n-              isDone.set(true);\n-              synchronized (LOCK) {\n-                LOCK.notifyAll();\n-              }\n+              latch.countDown();\n             });\n-    while (!isDone.get()) {\n-      synchronized (LOCK) {\n-        try {\n-          LOCK.wait();\n-        } catch (InterruptedException ignore) {\n-        }\n-      }\n+    try {\n+      latch.await();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0313bd663f2fb5c8d9edf2bdfb069ac809247c63"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MjQ1MQ==", "bodyText": "This is the main thread, if it's getting interrupted it's likely shutting down the server anyways, but will add the logger", "url": "https://github.com/PGMDev/PGM/pull/178#discussion_r362572451", "createdAt": "2020-01-02T18:13:37Z", "author": {"login": "Pablete1234"}, "path": "src/main/java/tc/oc/pgm/match/MatchManagerImpl.java", "diffHunk": "@@ -197,39 +197,30 @@ private World createMatchWorld(String worldName, MapInfo info, TerrainModule ter\n   }\n \n   /**\n-   * Creates a new world, wich must be done on the primary thread. If already running on the primary\n-   * thread, calls createWorld, otherwise, starts a sync task to run create world, and waits until\n-   * it's done.\n+   * Creates a new world, which must be done on the primary thread. If already running on the\n+   * primary thread, calls createWorld, otherwise, starts a sync task to run create world, and waits\n+   * until it's done.\n    *\n    * @param creator The creator for the world\n    * @return A world if it was able to be created, null otherwise\n    */\n   private World createWorld(final WorldCreator creator) {\n     if (server.isPrimaryThread()) return server.createWorld(creator);\n-\n-    // FIXME: This is pretty dirty, there must be a better way to run & wait on main\n-    final Object LOCK = new Object();\n+    final CountDownLatch latch = new CountDownLatch(1);\n     final AtomicReference<World> world = new AtomicReference<>();\n-    final AtomicBoolean isDone = new AtomicBoolean();\n     PGM.get()\n         .getServer()\n         .getScheduler()\n         .runTask(\n             PGM.get(),\n             () -> {\n               world.set(server.createWorld(creator));\n-              isDone.set(true);\n-              synchronized (LOCK) {\n-                LOCK.notifyAll();\n-              }\n+              latch.countDown();\n             });\n-    while (!isDone.get()) {\n-      synchronized (LOCK) {\n-        try {\n-          LOCK.wait();\n-        } catch (InterruptedException ignore) {\n-        }\n-      }\n+    try {\n+      latch.await();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MjE4OA=="}, "originalCommit": {"oid": "0313bd663f2fb5c8d9edf2bdfb069ac809247c63"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3NDQ1NQ==", "bodyText": "logger.log(Level.SEVERE, \"...\", e)\nWe want to always use the logger for when I add Sentry/other logging support.", "url": "https://github.com/PGMDev/PGM/pull/178#discussion_r362574455", "createdAt": "2020-01-02T18:19:42Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/match/MatchManagerImpl.java", "diffHunk": "@@ -197,39 +197,30 @@ private World createMatchWorld(String worldName, MapInfo info, TerrainModule ter\n   }\n \n   /**\n-   * Creates a new world, wich must be done on the primary thread. If already running on the primary\n-   * thread, calls createWorld, otherwise, starts a sync task to run create world, and waits until\n-   * it's done.\n+   * Creates a new world, which must be done on the primary thread. If already running on the\n+   * primary thread, calls createWorld, otherwise, starts a sync task to run create world, and waits\n+   * until it's done.\n    *\n    * @param creator The creator for the world\n    * @return A world if it was able to be created, null otherwise\n    */\n   private World createWorld(final WorldCreator creator) {\n     if (server.isPrimaryThread()) return server.createWorld(creator);\n-\n-    // FIXME: This is pretty dirty, there must be a better way to run & wait on main\n-    final Object LOCK = new Object();\n+    final CountDownLatch latch = new CountDownLatch(1);\n     final AtomicReference<World> world = new AtomicReference<>();\n-    final AtomicBoolean isDone = new AtomicBoolean();\n     PGM.get()\n         .getServer()\n         .getScheduler()\n         .runTask(\n             PGM.get(),\n             () -> {\n               world.set(server.createWorld(creator));\n-              isDone.set(true);\n-              synchronized (LOCK) {\n-                LOCK.notifyAll();\n-              }\n+              latch.countDown();\n             });\n-    while (!isDone.get()) {\n-      synchronized (LOCK) {\n-        try {\n-          LOCK.wait();\n-        } catch (InterruptedException ignore) {\n-        }\n-      }\n+    try {\n+      latch.await();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MjE4OA=="}, "originalCommit": {"oid": "0313bd663f2fb5c8d9edf2bdfb069ac809247c63"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3NDYzOQ==", "bodyText": "Had already changed it, was failing to push stuff properly", "url": "https://github.com/PGMDev/PGM/pull/178#discussion_r362574639", "createdAt": "2020-01-02T18:20:22Z", "author": {"login": "Pablete1234"}, "path": "src/main/java/tc/oc/pgm/match/MatchManagerImpl.java", "diffHunk": "@@ -197,39 +197,30 @@ private World createMatchWorld(String worldName, MapInfo info, TerrainModule ter\n   }\n \n   /**\n-   * Creates a new world, wich must be done on the primary thread. If already running on the primary\n-   * thread, calls createWorld, otherwise, starts a sync task to run create world, and waits until\n-   * it's done.\n+   * Creates a new world, which must be done on the primary thread. If already running on the\n+   * primary thread, calls createWorld, otherwise, starts a sync task to run create world, and waits\n+   * until it's done.\n    *\n    * @param creator The creator for the world\n    * @return A world if it was able to be created, null otherwise\n    */\n   private World createWorld(final WorldCreator creator) {\n     if (server.isPrimaryThread()) return server.createWorld(creator);\n-\n-    // FIXME: This is pretty dirty, there must be a better way to run & wait on main\n-    final Object LOCK = new Object();\n+    final CountDownLatch latch = new CountDownLatch(1);\n     final AtomicReference<World> world = new AtomicReference<>();\n-    final AtomicBoolean isDone = new AtomicBoolean();\n     PGM.get()\n         .getServer()\n         .getScheduler()\n         .runTask(\n             PGM.get(),\n             () -> {\n               world.set(server.createWorld(creator));\n-              isDone.set(true);\n-              synchronized (LOCK) {\n-                LOCK.notifyAll();\n-              }\n+              latch.countDown();\n             });\n-    while (!isDone.get()) {\n-      synchronized (LOCK) {\n-        try {\n-          LOCK.wait();\n-        } catch (InterruptedException ignore) {\n-        }\n-      }\n+    try {\n+      latch.await();\n+    } catch (InterruptedException e) {\n+      e.printStackTrace();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MjU3MjE4OA=="}, "originalCommit": {"oid": "0313bd663f2fb5c8d9edf2bdfb069ac809247c63"}, "originalPosition": 55}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1146, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}