{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxNTU2NDg4", "number": 218, "reviewThreads": {"totalCount": 39, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwMzo1OTo1NlrODap3Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMDo1NTo1NVrODbBTqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc1NDc5OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwMzo1OTo1NlrOFhurkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzo0NzowMFrOFhwwlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjE0NA==", "bodyText": "Why is this an int instead of Difficulty?", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912144", "createdAt": "2020-01-25T03:59:56Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package tc.oc.pgm.api.map;\n+\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+import tc.oc.named.Named;\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+\n+  /**\n+   * Get a unique id for the map.\n+   *\n+   * @return A unique id.\n+   */\n+  String getId();\n+\n+  /**\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n+   *\n+   * @see MapProtos\n+   * @return The proto.\n+   */\n+  Version getProto();\n+\n+  /**\n+   * Get the version of the map.\n+   *\n+   * @return The version.\n+   */\n+  Version getVersion();\n+\n+  /**\n+   * Get a unique, human-readable name for the map.\n+   *\n+   * @return A name, alphanumeric with spaces are allowed.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get a short, human-readable description of the map's objective.\n+   *\n+   * @return A description.\n+   */\n+  String getDescription();\n+\n+  /**\n+   * Get all {@link Contributor}s that contributed significantly to the map.\n+   *\n+   * <p>There must be at least 1 author.\n+   *\n+   * @return The authors.\n+   */\n+  Collection<Contributor> getAuthors();\n+\n+  /**\n+   * Get all {@link Contributor}s that helped contribute to the map.\n+   *\n+   * @return The contributors.\n+   */\n+  Collection<Contributor> getContributors();\n+\n+  /**\n+   * Get any special rules that players must follow for the map.\n+   *\n+   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n+   *\n+   * @return A collection of rules.\n+   */\n+  Collection<String> getRules();\n+\n+  /**\n+   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   *\n+   * @return The difficulty level.\n+   */\n+  int getDifficulty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDA0NQ==", "bodyText": "Moving away from having Bukkit literals in the api.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944045", "createdAt": "2020-01-25T17:03:01Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package tc.oc.pgm.api.map;\n+\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+import tc.oc.named.Named;\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+\n+  /**\n+   * Get a unique id for the map.\n+   *\n+   * @return A unique id.\n+   */\n+  String getId();\n+\n+  /**\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n+   *\n+   * @see MapProtos\n+   * @return The proto.\n+   */\n+  Version getProto();\n+\n+  /**\n+   * Get the version of the map.\n+   *\n+   * @return The version.\n+   */\n+  Version getVersion();\n+\n+  /**\n+   * Get a unique, human-readable name for the map.\n+   *\n+   * @return A name, alphanumeric with spaces are allowed.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get a short, human-readable description of the map's objective.\n+   *\n+   * @return A description.\n+   */\n+  String getDescription();\n+\n+  /**\n+   * Get all {@link Contributor}s that contributed significantly to the map.\n+   *\n+   * <p>There must be at least 1 author.\n+   *\n+   * @return The authors.\n+   */\n+  Collection<Contributor> getAuthors();\n+\n+  /**\n+   * Get all {@link Contributor}s that helped contribute to the map.\n+   *\n+   * @return The contributors.\n+   */\n+  Collection<Contributor> getContributors();\n+\n+  /**\n+   * Get any special rules that players must follow for the map.\n+   *\n+   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n+   *\n+   * @return A collection of rules.\n+   */\n+  Collection<String> getRules();\n+\n+  /**\n+   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   *\n+   * @return The difficulty level.\n+   */\n+  int getDifficulty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjE0NA=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NjE5OQ==", "bodyText": "why?", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370946199", "createdAt": "2020-01-25T17:47:00Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package tc.oc.pgm.api.map;\n+\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+import tc.oc.named.Named;\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+\n+  /**\n+   * Get a unique id for the map.\n+   *\n+   * @return A unique id.\n+   */\n+  String getId();\n+\n+  /**\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n+   *\n+   * @see MapProtos\n+   * @return The proto.\n+   */\n+  Version getProto();\n+\n+  /**\n+   * Get the version of the map.\n+   *\n+   * @return The version.\n+   */\n+  Version getVersion();\n+\n+  /**\n+   * Get a unique, human-readable name for the map.\n+   *\n+   * @return A name, alphanumeric with spaces are allowed.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get a short, human-readable description of the map's objective.\n+   *\n+   * @return A description.\n+   */\n+  String getDescription();\n+\n+  /**\n+   * Get all {@link Contributor}s that contributed significantly to the map.\n+   *\n+   * <p>There must be at least 1 author.\n+   *\n+   * @return The authors.\n+   */\n+  Collection<Contributor> getAuthors();\n+\n+  /**\n+   * Get all {@link Contributor}s that helped contribute to the map.\n+   *\n+   * @return The contributors.\n+   */\n+  Collection<Contributor> getContributors();\n+\n+  /**\n+   * Get any special rules that players must follow for the map.\n+   *\n+   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n+   *\n+   * @return A collection of rules.\n+   */\n+  Collection<String> getRules();\n+\n+  /**\n+   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   *\n+   * @return The difficulty level.\n+   */\n+  int getDifficulty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjE0NA=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc1NTIzOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDowMTozMFrOFhuryA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowMzo1MlrOFhwoVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjIwMA==", "bodyText": "What about a BaseComponent?", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912200", "createdAt": "2020-01-25T04:01:30Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package tc.oc.pgm.api.map;\n+\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+import tc.oc.named.Named;\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+\n+  /**\n+   * Get a unique id for the map.\n+   *\n+   * @return A unique id.\n+   */\n+  String getId();\n+\n+  /**\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n+   *\n+   * @see MapProtos\n+   * @return The proto.\n+   */\n+  Version getProto();\n+\n+  /**\n+   * Get the version of the map.\n+   *\n+   * @return The version.\n+   */\n+  Version getVersion();\n+\n+  /**\n+   * Get a unique, human-readable name for the map.\n+   *\n+   * @return A name, alphanumeric with spaces are allowed.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get a short, human-readable description of the map's objective.\n+   *\n+   * @return A description.\n+   */\n+  String getDescription();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDA4NA==", "bodyText": "Components are rendering level stuff, this interface is just descriptive.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944084", "createdAt": "2020-01-25T17:03:52Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package tc.oc.pgm.api.map;\n+\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+import tc.oc.named.Named;\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+\n+  /**\n+   * Get a unique id for the map.\n+   *\n+   * @return A unique id.\n+   */\n+  String getId();\n+\n+  /**\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n+   *\n+   * @see MapProtos\n+   * @return The proto.\n+   */\n+  Version getProto();\n+\n+  /**\n+   * Get the version of the map.\n+   *\n+   * @return The version.\n+   */\n+  Version getVersion();\n+\n+  /**\n+   * Get a unique, human-readable name for the map.\n+   *\n+   * @return A name, alphanumeric with spaces are allowed.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get a short, human-readable description of the map's objective.\n+   *\n+   * @return A description.\n+   */\n+  String getDescription();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjIwMA=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc1NTg0OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDowMzoyNVrOFhusFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDowMzoyNVrOFhusFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjI3Nw==", "bodyText": "The documentation should say if these are all maptags (with automatic maptags) or just XML defined.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912277", "createdAt": "2020-01-25T04:03:25Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package tc.oc.pgm.api.map;\n+\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+import tc.oc.named.Named;\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+\n+  /**\n+   * Get a unique id for the map.\n+   *\n+   * @return A unique id.\n+   */\n+  String getId();\n+\n+  /**\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n+   *\n+   * @see MapProtos\n+   * @return The proto.\n+   */\n+  Version getProto();\n+\n+  /**\n+   * Get the version of the map.\n+   *\n+   * @return The version.\n+   */\n+  Version getVersion();\n+\n+  /**\n+   * Get a unique, human-readable name for the map.\n+   *\n+   * @return A name, alphanumeric with spaces are allowed.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get a short, human-readable description of the map's objective.\n+   *\n+   * @return A description.\n+   */\n+  String getDescription();\n+\n+  /**\n+   * Get all {@link Contributor}s that contributed significantly to the map.\n+   *\n+   * <p>There must be at least 1 author.\n+   *\n+   * @return The authors.\n+   */\n+  Collection<Contributor> getAuthors();\n+\n+  /**\n+   * Get all {@link Contributor}s that helped contribute to the map.\n+   *\n+   * @return The contributors.\n+   */\n+  Collection<Contributor> getContributors();\n+\n+  /**\n+   * Get any special rules that players must follow for the map.\n+   *\n+   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n+   *\n+   * @return A collection of rules.\n+   */\n+  Collection<String> getRules();\n+\n+  /**\n+   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   *\n+   * @return The difficulty level.\n+   */\n+  int getDifficulty();\n+\n+  /**\n+   * Get a collection of \"hash tags\" used to describe the map.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc1NjI1OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDowNDo1NFrOFhusSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxMjoyOTowMlrOFhv1Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjMzMA==", "bodyText": "If it's null why should throw NPE to find bugs easier.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912330", "createdAt": "2020-01-25T04:04:54Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package tc.oc.pgm.api.map;\n+\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+import tc.oc.named.Named;\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+\n+  /**\n+   * Get a unique id for the map.\n+   *\n+   * @return A unique id.\n+   */\n+  String getId();\n+\n+  /**\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n+   *\n+   * @see MapProtos\n+   * @return The proto.\n+   */\n+  Version getProto();\n+\n+  /**\n+   * Get the version of the map.\n+   *\n+   * @return The version.\n+   */\n+  Version getVersion();\n+\n+  /**\n+   * Get a unique, human-readable name for the map.\n+   *\n+   * @return A name, alphanumeric with spaces are allowed.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get a short, human-readable description of the map's objective.\n+   *\n+   * @return A description.\n+   */\n+  String getDescription();\n+\n+  /**\n+   * Get all {@link Contributor}s that contributed significantly to the map.\n+   *\n+   * <p>There must be at least 1 author.\n+   *\n+   * @return The authors.\n+   */\n+  Collection<Contributor> getAuthors();\n+\n+  /**\n+   * Get all {@link Contributor}s that helped contribute to the map.\n+   *\n+   * @return The contributors.\n+   */\n+  Collection<Contributor> getContributors();\n+\n+  /**\n+   * Get any special rules that players must follow for the map.\n+   *\n+   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n+   *\n+   * @return A collection of rules.\n+   */\n+  Collection<String> getRules();\n+\n+  /**\n+   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   *\n+   * @return The difficulty level.\n+   */\n+  int getDifficulty();\n+\n+  /**\n+   * Get a collection of \"hash tags\" used to describe the map.\n+   *\n+   * @return A collection of tags.\n+   */\n+  Collection<MapTag> getTags();\n+\n+  /**\n+   * Get the maximum number of players that can participate on each team.\n+   *\n+   * @return Maximum number of players on each team.\n+   */\n+  Collection<Integer> getMaxPlayers();\n+\n+  /**\n+   * Create an immutable copy of this info.\n+   *\n+   * @return A cloned {@link MapInfo}.\n+   */\n+  MapInfo clone();\n+\n+  @Override\n+  default int compareTo(MapInfo o) {\n+    return getId().compareTo(o.getId());\n+  }\n+\n+  static String normalizeName(@Nullable String idOrName) {\n+    return idOrName == null\n+        ? \"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkzMTAzMA==", "bodyText": "Since it's @Nullable, i assume if you use the /map without map argument it will get thru this and then if the result is an empty string will get replaced with the current map.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370931030", "createdAt": "2020-01-25T12:29:02Z", "author": {"login": "Pablete1234"}, "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package tc.oc.pgm.api.map;\n+\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+import tc.oc.named.Named;\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+\n+  /**\n+   * Get a unique id for the map.\n+   *\n+   * @return A unique id.\n+   */\n+  String getId();\n+\n+  /**\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n+   *\n+   * @see MapProtos\n+   * @return The proto.\n+   */\n+  Version getProto();\n+\n+  /**\n+   * Get the version of the map.\n+   *\n+   * @return The version.\n+   */\n+  Version getVersion();\n+\n+  /**\n+   * Get a unique, human-readable name for the map.\n+   *\n+   * @return A name, alphanumeric with spaces are allowed.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get a short, human-readable description of the map's objective.\n+   *\n+   * @return A description.\n+   */\n+  String getDescription();\n+\n+  /**\n+   * Get all {@link Contributor}s that contributed significantly to the map.\n+   *\n+   * <p>There must be at least 1 author.\n+   *\n+   * @return The authors.\n+   */\n+  Collection<Contributor> getAuthors();\n+\n+  /**\n+   * Get all {@link Contributor}s that helped contribute to the map.\n+   *\n+   * @return The contributors.\n+   */\n+  Collection<Contributor> getContributors();\n+\n+  /**\n+   * Get any special rules that players must follow for the map.\n+   *\n+   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n+   *\n+   * @return A collection of rules.\n+   */\n+  Collection<String> getRules();\n+\n+  /**\n+   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   *\n+   * @return The difficulty level.\n+   */\n+  int getDifficulty();\n+\n+  /**\n+   * Get a collection of \"hash tags\" used to describe the map.\n+   *\n+   * @return A collection of tags.\n+   */\n+  Collection<MapTag> getTags();\n+\n+  /**\n+   * Get the maximum number of players that can participate on each team.\n+   *\n+   * @return Maximum number of players on each team.\n+   */\n+  Collection<Integer> getMaxPlayers();\n+\n+  /**\n+   * Create an immutable copy of this info.\n+   *\n+   * @return A cloned {@link MapInfo}.\n+   */\n+  MapInfo clone();\n+\n+  @Override\n+  default int compareTo(MapInfo o) {\n+    return getId().compareTo(o.getId());\n+  }\n+\n+  static String normalizeName(@Nullable String idOrName) {\n+    return idOrName == null\n+        ? \"\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjMzMA=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc1NzU2OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDowOTo1MVrOFhus5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowMToxOVrOFhwn2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjQ4NQ==", "bodyText": "We should deprecate these three parsers and explain why they shouldn't be here imho.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912485", "createdAt": "2020-01-25T04:09:51Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package tc.oc.pgm.api.map.factory;\n+\n+import tc.oc.pgm.api.map.MapContext;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.exception.MapException;\n+import tc.oc.pgm.api.module.ModuleContext;\n+import tc.oc.pgm.features.FeatureDefinitionContext;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.util.Version;\n+\n+/** A factory for creating {@link MapInfo}s and {@link MapContext}s. */\n+public interface MapFactory extends ModuleContext<MapModule>, AutoCloseable {\n+\n+  RegionParser getRegions();\n+\n+  FilterParser getFilters();\n+\n+  KitParser getKits();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mzk2Mw==", "bodyText": "It's too widely used at this point. But I'll add some descriptions.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943963", "createdAt": "2020-01-25T17:01:19Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package tc.oc.pgm.api.map.factory;\n+\n+import tc.oc.pgm.api.map.MapContext;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.exception.MapException;\n+import tc.oc.pgm.api.module.ModuleContext;\n+import tc.oc.pgm.features.FeatureDefinitionContext;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.util.Version;\n+\n+/** A factory for creating {@link MapInfo}s and {@link MapContext}s. */\n+public interface MapFactory extends ModuleContext<MapModule>, AutoCloseable {\n+\n+  RegionParser getRegions();\n+\n+  FilterParser getFilters();\n+\n+  KitParser getKits();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjQ4NQ=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc2MDExOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/blockdrops/BlockDropsMatchModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDoxODozN1rOFhuuKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowMDo1MFrOFhwnyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjgxMA==", "bodyText": "This match field will now pop up in each MatchModule implementation. We should have MatchModule.Impl with this to keep it DRY.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912810", "createdAt": "2020-01-25T04:18:37Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/blockdrops/BlockDropsMatchModule.java", "diffHunk": "@@ -52,9 +52,10 @@\n   // die that do not fire an event e.g. the tick age limit, but this should be\n   // rare and they will only leak until the end of the match.\n   private final Set<FallingBlock> fallingBlocksThatWillNotLand = new HashSet<>();\n+  private final Match match;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mzk0NQ==", "bodyText": "There are some MatchModules that don't even need a Match reference. They just use event listeners. Not really nessecary.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943945", "createdAt": "2020-01-25T17:00:50Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/blockdrops/BlockDropsMatchModule.java", "diffHunk": "@@ -52,9 +52,10 @@\n   // die that do not fire an event e.g. the tick age limit, but this should be\n   // rare and they will only leak until the end of the match.\n   private final Set<FallingBlock> fallingBlocksThatWillNotLand = new HashSet<>();\n+  private final Match match;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjgxMA=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc2MTgyOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDoyMzo1MFrOFhuvAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowMDowNlrOFhwnnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzAyNg==", "bodyText": "Keep that * import :P", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913026", "createdAt": "2020-01-25T04:23:50Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -1,16 +1,15 @@\n package tc.oc.pgm.commands;\n \n-import static com.google.common.base.Preconditions.*;\n+import static com.google.common.base.Preconditions.checkNotNull;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0MzkwMQ==", "bodyText": "? It's just the google syntax cleaner.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943901", "createdAt": "2020-01-25T17:00:06Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -1,16 +1,15 @@\n package tc.oc.pgm.commands;\n \n-import static com.google.common.base.Preconditions.*;\n+import static com.google.common.base.Preconditions.checkNotNull;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzAyNg=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc2MjQ4OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDoyNjozMVrOFhuvXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDoyNjozMVrOFhuvXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzExOA==", "bodyText": "The previous syntax was way easier imo. Just /maps #many #tags instead of commas, dashes and other difficult combinations you need to do to put multiple maptags.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913118", "createdAt": "2020-01-25T04:26:31Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -27,43 +26,53 @@\n import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapLibrary;\n+import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n-import tc.oc.pgm.map.Contributor;\n-import tc.oc.pgm.map.MapInfo;\n-import tc.oc.pgm.map.MapLibrary;\n-import tc.oc.pgm.map.MapPersistentContext;\n-import tc.oc.pgm.map.PGMMap;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.maptag.MapTagsCondition;\n+import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n import tc.oc.util.components.ComponentUtils;\n import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n+  @Command(\n+      aliases = {\"loadnewmaps\"},\n+      desc = \"Loads new maps and outputs any errors\")\n+  public static void loadNewMaps(MapLibrary library, @Switch('f') boolean force) {\n+    library.loadNewMaps(force); // MapLibrary will handle sending output asynchronously\n+  }\n+\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-p <page>] [[!]#<maptag>...]\",\n+      usage = \"[-a <author>] [-p <page>] [-# <tag1>,<tag2>]\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc2MzI4OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDozMDowMlrOFhuvvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowNDo0MFrOFhwocw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzIxMw==", "bodyText": "This should fix the page number input I think? Also doing flags for maptags which always start with # isn't obvious to end-user.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913213", "createdAt": "2020-01-25T04:30:02Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -27,43 +26,53 @@\n import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapLibrary;\n+import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n-import tc.oc.pgm.map.Contributor;\n-import tc.oc.pgm.map.MapInfo;\n-import tc.oc.pgm.map.MapLibrary;\n-import tc.oc.pgm.map.MapPersistentContext;\n-import tc.oc.pgm.map.PGMMap;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.maptag.MapTagsCondition;\n+import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n import tc.oc.util.components.ComponentUtils;\n import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n+  @Command(\n+      aliases = {\"loadnewmaps\"},\n+      desc = \"Loads new maps and outputs any errors\")\n+  public static void loadNewMaps(MapLibrary library, @Switch('f') boolean force) {\n+    library.loadNewMaps(force); // MapLibrary will handle sending output asynchronously\n+  }\n+\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-p <page>] [[!]#<maptag>...]\",\n+      usage = \"[-a <author>] [-p <page>] [-# <tag1>,<tag2>]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n       Audience audience,\n       CommandSender sender,\n       MapLibrary library,\n-      MapTagsCondition mapTags,\n+      @Fallback(Type.NULL) @Switch('t') String tags,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDExNQ==", "bodyText": "Yea, will remove the -p, because everyone was just using /maps N", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944115", "createdAt": "2020-01-25T17:04:40Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -27,43 +26,53 @@\n import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapLibrary;\n+import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n-import tc.oc.pgm.map.Contributor;\n-import tc.oc.pgm.map.MapInfo;\n-import tc.oc.pgm.map.MapLibrary;\n-import tc.oc.pgm.map.MapPersistentContext;\n-import tc.oc.pgm.map.PGMMap;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.maptag.MapTagsCondition;\n+import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n import tc.oc.util.components.ComponentUtils;\n import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n+  @Command(\n+      aliases = {\"loadnewmaps\"},\n+      desc = \"Loads new maps and outputs any errors\")\n+  public static void loadNewMaps(MapLibrary library, @Switch('f') boolean force) {\n+    library.loadNewMaps(force); // MapLibrary will handle sending output asynchronously\n+  }\n+\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-p <page>] [[!]#<maptag>...]\",\n+      usage = \"[-a <author>] [-p <page>] [-# <tag1>,<tag2>]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n       Audience audience,\n       CommandSender sender,\n       MapLibrary library,\n-      MapTagsCondition mapTags,\n+      @Fallback(Type.NULL) @Switch('t') String tags,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzIxMw=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc2NDUwOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDozMzoxNVrOFhuwUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDozMzoxNVrOFhuwUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzM2Mw==", "bodyText": "People can no longer negate maptags as @Pablete1234 suggested me to do. Let's say if people would want to search for all DTM maps except the ones mixed with cores (SSB) - /maps #monument !#core", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913363", "createdAt": "2020-01-25T04:33:15Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -27,43 +26,53 @@\n import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapLibrary;\n+import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n-import tc.oc.pgm.map.Contributor;\n-import tc.oc.pgm.map.MapInfo;\n-import tc.oc.pgm.map.MapLibrary;\n-import tc.oc.pgm.map.MapPersistentContext;\n-import tc.oc.pgm.map.PGMMap;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.maptag.MapTagsCondition;\n+import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n import tc.oc.util.components.ComponentUtils;\n import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n+  @Command(\n+      aliases = {\"loadnewmaps\"},\n+      desc = \"Loads new maps and outputs any errors\")\n+  public static void loadNewMaps(MapLibrary library, @Switch('f') boolean force) {\n+    library.loadNewMaps(force); // MapLibrary will handle sending output asynchronously\n+  }\n+\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-p <page>] [[!]#<maptag>...]\",\n+      usage = \"[-a <author>] [-p <page>] [-# <tag1>,<tag2>]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n       Audience audience,\n       CommandSender sender,\n       MapLibrary library,\n-      MapTagsCondition mapTags,\n+      @Fallback(Type.NULL) @Switch('t') String tags,\n       @Fallback(Type.NULL) @Switch('a') String author,\n       @Fallback(Type.NULL) @Switch('p') Integer page)\n       throws CommandException {\n     if (page == null) page = 1;\n \n-    Stream<PGMMap> search = library.getMaps().stream().filter(mapTags);\n+    Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n+    if (tags != null) {\n+      final Set<String> tagSet =\n+          Stream.of(tags.split(\",\")).map(String::trim).collect(Collectors.toSet());\n+      search = search.filter(map -> matchesTags(map, tagSet));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc2NDg5OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDozNToyNlrOFhuwjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDozNToyNlrOFhuwjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzQyMA==", "bodyText": "tags aren't always lower case, getId() is.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913420", "createdAt": "2020-01-25T04:35:26Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -73,20 +82,30 @@ public static void maplist(\n     String listHeader =\n         ComponentUtils.horizontalLineHeading(title, ChatColor.BLUE, ComponentUtils.MAX_CHAT_WIDTH);\n \n-    new PrettyPaginatedResult<PGMMap>(listHeader, resultsPerPage) {\n+    new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n-      public String format(PGMMap map, int index) {\n-        return (index + 1) + \". \" + map.getInfo().getShortDescription(sender);\n+      public String format(MapInfo map, int index) {\n+        return (index + 1) + \". \" + map.getStyledName(NameStyle.FANCY).toLegacyText();\n       }\n     }.display(audience, ImmutableSortedSet.copyOf(maps), page);\n   }\n \n-  private static boolean matchesAuthor(PGMMap map, String query) {\n+  private static boolean matchesTags(MapInfo map, Set<String> tags) {\n+    if (checkNotNull(tags).isEmpty()) return true;\n+    for (MapTag tag : checkNotNull(map).getTags()) {\n+      if (tags.contains(tag.getId())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc2NTU1OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDozNzo0MlrOFhuw4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzo0OTowM1rOFhww3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzUwNg==", "bodyText": "I think this should be translatable? I guess in Arabic you should have v1.0 Airship Battle since they read right-to-left.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913506", "createdAt": "2020-01-25T04:37:42Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -97,144 +116,113 @@ private static boolean matchesAuthor(PGMMap map, String query) {\n       aliases = {\"mapinfo\", \"map\"},\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n-  public void map(Audience audience, CommandSender sender, @Text PGMMap map) {\n-    MapInfo mapInfo = map.getInfo();\n-    audience.sendMessage(mapInfo.getFormattedMapTitle());\n-\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    Component edition = new PersonalizedText(mapInfo.getLocalizedEdition(), ChatColor.GOLD);\n-    if (!edition.toPlainText().isEmpty()) {\n-      audience.sendMessage(\n-          new PersonalizedText(mapInfoLabel(\"command.map.mapInfo.edition\"), edition));\n-    }\n+  public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n+    audience.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_AQUA\n+                + map.getName()\n+                + \" \"\n+                + ChatColor.GRAY\n+                + map.getVersion().toString(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDE3Mw==", "bodyText": "Sure, but not a high priority.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944173", "createdAt": "2020-01-25T17:05:47Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -97,144 +116,113 @@ private static boolean matchesAuthor(PGMMap map, String query) {\n       aliases = {\"mapinfo\", \"map\"},\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n-  public void map(Audience audience, CommandSender sender, @Text PGMMap map) {\n-    MapInfo mapInfo = map.getInfo();\n-    audience.sendMessage(mapInfo.getFormattedMapTitle());\n-\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    Component edition = new PersonalizedText(mapInfo.getLocalizedEdition(), ChatColor.GOLD);\n-    if (!edition.toPlainText().isEmpty()) {\n-      audience.sendMessage(\n-          new PersonalizedText(mapInfoLabel(\"command.map.mapInfo.edition\"), edition));\n-    }\n+  public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n+    audience.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_AQUA\n+                + map.getName()\n+                + \" \"\n+                + ChatColor.GRAY\n+                + map.getVersion().toString(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzUwNg=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NjI3MQ==", "bodyText": "Leave a todo there so we don't forget it when we migrate to text library.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370946271", "createdAt": "2020-01-25T17:49:03Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -97,144 +116,113 @@ private static boolean matchesAuthor(PGMMap map, String query) {\n       aliases = {\"mapinfo\", \"map\"},\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n-  public void map(Audience audience, CommandSender sender, @Text PGMMap map) {\n-    MapInfo mapInfo = map.getInfo();\n-    audience.sendMessage(mapInfo.getFormattedMapTitle());\n-\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    Component edition = new PersonalizedText(mapInfo.getLocalizedEdition(), ChatColor.GOLD);\n-    if (!edition.toPlainText().isEmpty()) {\n-      audience.sendMessage(\n-          new PersonalizedText(mapInfoLabel(\"command.map.mapInfo.edition\"), edition));\n-    }\n+  public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n+    audience.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_AQUA\n+                + map.getName()\n+                + \" \"\n+                + ChatColor.GRAY\n+                + map.getVersion().toString(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzUwNg=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc2NjI4OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDo0MDoxNVrOFhuxTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowNjo0MFrOFhwo5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzYxMw==", "bodyText": "Instead of putting # here we should call toString() instead.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913613", "createdAt": "2020-01-25T04:40:15Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -97,144 +116,113 @@ private static boolean matchesAuthor(PGMMap map, String query) {\n       aliases = {\"mapinfo\", \"map\"},\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n-  public void map(Audience audience, CommandSender sender, @Text PGMMap map) {\n-    MapInfo mapInfo = map.getInfo();\n-    audience.sendMessage(mapInfo.getFormattedMapTitle());\n-\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    Component edition = new PersonalizedText(mapInfo.getLocalizedEdition(), ChatColor.GOLD);\n-    if (!edition.toPlainText().isEmpty()) {\n-      audience.sendMessage(\n-          new PersonalizedText(mapInfoLabel(\"command.map.mapInfo.edition\"), edition));\n-    }\n+  public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n+    audience.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_AQUA\n+                + map.getName()\n+                + \" \"\n+                + ChatColor.GRAY\n+                + map.getVersion().toString(),\n+            ChatColor.RED));\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.objective\"),\n-            new PersonalizedText(mapInfo.objective, ChatColor.GOLD)));\n+            new PersonalizedText(map.getDescription(), ChatColor.GOLD)));\n \n-    List<Contributor> authors = mapInfo.getNamedAuthors();\n+    Collection<Contributor> authors = map.getAuthors();\n     if (authors.size() == 1) {\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.authorSingular\"),\n-              formatContribution(authors.get(0))));\n+              formatContribution(authors.iterator().next())));\n     } else {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.authorPlural\"));\n       for (Contributor author : authors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(author)));\n       }\n     }\n \n-    List<Contributor> contributors = mapInfo.getNamedContributors();\n+    Collection<Contributor> contributors = map.getContributors();\n     if (!contributors.isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.contributors\"));\n       for (Contributor contributor : contributors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(contributor)));\n       }\n     }\n \n-    if (mapInfo.rules.size() > 0) {\n+    if (!map.getRules().isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.rules\"));\n \n-      for (int i = 0; i < mapInfo.rules.size(); i++) {\n+      int i = 0;\n+      for (String rule : map.getRules()) {\n         audience.sendMessage(\n             new PersonalizedText(\n-                new PersonalizedText((i + 1) + \") \", ChatColor.WHITE),\n-                new PersonalizedText(mapInfo.rules.get(i), ChatColor.GOLD)));\n+                new PersonalizedText(++i + \") \", ChatColor.WHITE),\n+                new PersonalizedText(rule, ChatColor.GOLD)));\n       }\n     }\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.playerLimit\"),\n-            createPlayerLimitComponent(sender, persistentContext)));\n+            createPlayerLimitComponent(sender, map)));\n \n     if (sender.hasPermission(Permissions.DEBUG)) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.genre\"),\n-              new PersonalizedText(mapInfo.getLocalizedGenre(), ChatColor.GOLD)));\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.proto\"),\n-              new PersonalizedText(mapInfo.proto.toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.folder\"),\n-              new PersonalizedText(map.getFolder().getRelativePath().toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.source\"),\n-              new PersonalizedText(map.getSource().getPath().toString(), ChatColor.GOLD)));\n+              new PersonalizedText(map.getProto().toString(), ChatColor.GOLD)));\n     }\n \n-    URL xmlLink = map.getFolder().getDescriptionFileUrl();\n-    if (xmlLink != null) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              new PersonalizedText(ChatColor.DARK_PURPLE, ChatColor.BOLD)\n-                  .extra(new PersonalizedTranslatable(\"command.map.mapInfo.xml\"))\n-                  .extra(\": \"),\n-              Components.link(xmlLink)\n-                  .hoverEvent(\n-                      HoverEvent.Action.SHOW_TEXT,\n-                      new PersonalizedTranslatable(\"command.map.mapInfo.sourceCode.tip\")\n-                          .render())));\n-    }\n-\n-    Set<MapTag> mapTags = persistentContext.getMapTags();\n-    audience.sendMessage(createTagsComponent(mapTags).color(ChatColor.YELLOW));\n+    audience.sendMessage(createTagsComponent(map.getTags()));\n   }\n \n-  private static Component createTagsComponent(Set<MapTag> tags) {\n+  private Component createTagsComponent(Collection<MapTag> tags) {\n     checkNotNull(tags);\n \n-    Component result = new PersonalizedText();\n+    Component result = mapInfoLabel(\"command.map.mapInfo.tags\");\n     MapTag[] mapTags = tags.toArray(new MapTag[0]);\n     for (int i = 0; i < mapTags.length; i++) {\n       if (i != 0) {\n         result.extra(Components.space());\n       }\n \n-      MapTag mapTag = mapTags[i];\n+      String mapTag = mapTags[i].getId();\n       Component component =\n-          mapTags[i]\n-              .getComponentName()\n-              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maplist \" + mapTag.toString())\n+          new PersonalizedText(\"#\" + mapTag, ChatColor.GOLD)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzY2MQ==", "bodyText": "BTW, maptags in voting books are yellow so I would keep them yellow here too for consistency.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913661", "createdAt": "2020-01-25T04:41:25Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -97,144 +116,113 @@ private static boolean matchesAuthor(PGMMap map, String query) {\n       aliases = {\"mapinfo\", \"map\"},\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n-  public void map(Audience audience, CommandSender sender, @Text PGMMap map) {\n-    MapInfo mapInfo = map.getInfo();\n-    audience.sendMessage(mapInfo.getFormattedMapTitle());\n-\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    Component edition = new PersonalizedText(mapInfo.getLocalizedEdition(), ChatColor.GOLD);\n-    if (!edition.toPlainText().isEmpty()) {\n-      audience.sendMessage(\n-          new PersonalizedText(mapInfoLabel(\"command.map.mapInfo.edition\"), edition));\n-    }\n+  public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n+    audience.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_AQUA\n+                + map.getName()\n+                + \" \"\n+                + ChatColor.GRAY\n+                + map.getVersion().toString(),\n+            ChatColor.RED));\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.objective\"),\n-            new PersonalizedText(mapInfo.objective, ChatColor.GOLD)));\n+            new PersonalizedText(map.getDescription(), ChatColor.GOLD)));\n \n-    List<Contributor> authors = mapInfo.getNamedAuthors();\n+    Collection<Contributor> authors = map.getAuthors();\n     if (authors.size() == 1) {\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.authorSingular\"),\n-              formatContribution(authors.get(0))));\n+              formatContribution(authors.iterator().next())));\n     } else {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.authorPlural\"));\n       for (Contributor author : authors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(author)));\n       }\n     }\n \n-    List<Contributor> contributors = mapInfo.getNamedContributors();\n+    Collection<Contributor> contributors = map.getContributors();\n     if (!contributors.isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.contributors\"));\n       for (Contributor contributor : contributors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(contributor)));\n       }\n     }\n \n-    if (mapInfo.rules.size() > 0) {\n+    if (!map.getRules().isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.rules\"));\n \n-      for (int i = 0; i < mapInfo.rules.size(); i++) {\n+      int i = 0;\n+      for (String rule : map.getRules()) {\n         audience.sendMessage(\n             new PersonalizedText(\n-                new PersonalizedText((i + 1) + \") \", ChatColor.WHITE),\n-                new PersonalizedText(mapInfo.rules.get(i), ChatColor.GOLD)));\n+                new PersonalizedText(++i + \") \", ChatColor.WHITE),\n+                new PersonalizedText(rule, ChatColor.GOLD)));\n       }\n     }\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.playerLimit\"),\n-            createPlayerLimitComponent(sender, persistentContext)));\n+            createPlayerLimitComponent(sender, map)));\n \n     if (sender.hasPermission(Permissions.DEBUG)) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.genre\"),\n-              new PersonalizedText(mapInfo.getLocalizedGenre(), ChatColor.GOLD)));\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.proto\"),\n-              new PersonalizedText(mapInfo.proto.toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.folder\"),\n-              new PersonalizedText(map.getFolder().getRelativePath().toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.source\"),\n-              new PersonalizedText(map.getSource().getPath().toString(), ChatColor.GOLD)));\n+              new PersonalizedText(map.getProto().toString(), ChatColor.GOLD)));\n     }\n \n-    URL xmlLink = map.getFolder().getDescriptionFileUrl();\n-    if (xmlLink != null) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              new PersonalizedText(ChatColor.DARK_PURPLE, ChatColor.BOLD)\n-                  .extra(new PersonalizedTranslatable(\"command.map.mapInfo.xml\"))\n-                  .extra(\": \"),\n-              Components.link(xmlLink)\n-                  .hoverEvent(\n-                      HoverEvent.Action.SHOW_TEXT,\n-                      new PersonalizedTranslatable(\"command.map.mapInfo.sourceCode.tip\")\n-                          .render())));\n-    }\n-\n-    Set<MapTag> mapTags = persistentContext.getMapTags();\n-    audience.sendMessage(createTagsComponent(mapTags).color(ChatColor.YELLOW));\n+    audience.sendMessage(createTagsComponent(map.getTags()));\n   }\n \n-  private static Component createTagsComponent(Set<MapTag> tags) {\n+  private Component createTagsComponent(Collection<MapTag> tags) {\n     checkNotNull(tags);\n \n-    Component result = new PersonalizedText();\n+    Component result = mapInfoLabel(\"command.map.mapInfo.tags\");\n     MapTag[] mapTags = tags.toArray(new MapTag[0]);\n     for (int i = 0; i < mapTags.length; i++) {\n       if (i != 0) {\n         result.extra(Components.space());\n       }\n \n-      MapTag mapTag = mapTags[i];\n+      String mapTag = mapTags[i].getId();\n       Component component =\n-          mapTags[i]\n-              .getComponentName()\n-              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maplist \" + mapTag.toString())\n+          new PersonalizedText(\"#\" + mapTag, ChatColor.GOLD)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzYxMw=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDIyOQ==", "bodyText": "I made them gold to keep the output consistent in /map. So might look at the voting book too.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944229", "createdAt": "2020-01-25T17:06:40Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -97,144 +116,113 @@ private static boolean matchesAuthor(PGMMap map, String query) {\n       aliases = {\"mapinfo\", \"map\"},\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n-  public void map(Audience audience, CommandSender sender, @Text PGMMap map) {\n-    MapInfo mapInfo = map.getInfo();\n-    audience.sendMessage(mapInfo.getFormattedMapTitle());\n-\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    Component edition = new PersonalizedText(mapInfo.getLocalizedEdition(), ChatColor.GOLD);\n-    if (!edition.toPlainText().isEmpty()) {\n-      audience.sendMessage(\n-          new PersonalizedText(mapInfoLabel(\"command.map.mapInfo.edition\"), edition));\n-    }\n+  public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n+    audience.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_AQUA\n+                + map.getName()\n+                + \" \"\n+                + ChatColor.GRAY\n+                + map.getVersion().toString(),\n+            ChatColor.RED));\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.objective\"),\n-            new PersonalizedText(mapInfo.objective, ChatColor.GOLD)));\n+            new PersonalizedText(map.getDescription(), ChatColor.GOLD)));\n \n-    List<Contributor> authors = mapInfo.getNamedAuthors();\n+    Collection<Contributor> authors = map.getAuthors();\n     if (authors.size() == 1) {\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.authorSingular\"),\n-              formatContribution(authors.get(0))));\n+              formatContribution(authors.iterator().next())));\n     } else {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.authorPlural\"));\n       for (Contributor author : authors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(author)));\n       }\n     }\n \n-    List<Contributor> contributors = mapInfo.getNamedContributors();\n+    Collection<Contributor> contributors = map.getContributors();\n     if (!contributors.isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.contributors\"));\n       for (Contributor contributor : contributors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(contributor)));\n       }\n     }\n \n-    if (mapInfo.rules.size() > 0) {\n+    if (!map.getRules().isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.rules\"));\n \n-      for (int i = 0; i < mapInfo.rules.size(); i++) {\n+      int i = 0;\n+      for (String rule : map.getRules()) {\n         audience.sendMessage(\n             new PersonalizedText(\n-                new PersonalizedText((i + 1) + \") \", ChatColor.WHITE),\n-                new PersonalizedText(mapInfo.rules.get(i), ChatColor.GOLD)));\n+                new PersonalizedText(++i + \") \", ChatColor.WHITE),\n+                new PersonalizedText(rule, ChatColor.GOLD)));\n       }\n     }\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.playerLimit\"),\n-            createPlayerLimitComponent(sender, persistentContext)));\n+            createPlayerLimitComponent(sender, map)));\n \n     if (sender.hasPermission(Permissions.DEBUG)) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.genre\"),\n-              new PersonalizedText(mapInfo.getLocalizedGenre(), ChatColor.GOLD)));\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.proto\"),\n-              new PersonalizedText(mapInfo.proto.toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.folder\"),\n-              new PersonalizedText(map.getFolder().getRelativePath().toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.source\"),\n-              new PersonalizedText(map.getSource().getPath().toString(), ChatColor.GOLD)));\n+              new PersonalizedText(map.getProto().toString(), ChatColor.GOLD)));\n     }\n \n-    URL xmlLink = map.getFolder().getDescriptionFileUrl();\n-    if (xmlLink != null) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              new PersonalizedText(ChatColor.DARK_PURPLE, ChatColor.BOLD)\n-                  .extra(new PersonalizedTranslatable(\"command.map.mapInfo.xml\"))\n-                  .extra(\": \"),\n-              Components.link(xmlLink)\n-                  .hoverEvent(\n-                      HoverEvent.Action.SHOW_TEXT,\n-                      new PersonalizedTranslatable(\"command.map.mapInfo.sourceCode.tip\")\n-                          .render())));\n-    }\n-\n-    Set<MapTag> mapTags = persistentContext.getMapTags();\n-    audience.sendMessage(createTagsComponent(mapTags).color(ChatColor.YELLOW));\n+    audience.sendMessage(createTagsComponent(map.getTags()));\n   }\n \n-  private static Component createTagsComponent(Set<MapTag> tags) {\n+  private Component createTagsComponent(Collection<MapTag> tags) {\n     checkNotNull(tags);\n \n-    Component result = new PersonalizedText();\n+    Component result = mapInfoLabel(\"command.map.mapInfo.tags\");\n     MapTag[] mapTags = tags.toArray(new MapTag[0]);\n     for (int i = 0; i < mapTags.length; i++) {\n       if (i != 0) {\n         result.extra(Components.space());\n       }\n \n-      MapTag mapTag = mapTags[i];\n+      String mapTag = mapTags[i].getId();\n       Component component =\n-          mapTags[i]\n-              .getComponentName()\n-              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maplist \" + mapTag.toString())\n+          new PersonalizedText(\"#\" + mapTag, ChatColor.GOLD)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzYxMw=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc2NzMzOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDo0NDoxM1rOFhux1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowNjo1OFrOFhwo9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzc0OQ==", "bodyText": "/maps is an alias to /maplist so I would keep /maplist here. :P", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913749", "createdAt": "2020-01-25T04:44:13Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -97,144 +116,113 @@ private static boolean matchesAuthor(PGMMap map, String query) {\n       aliases = {\"mapinfo\", \"map\"},\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n-  public void map(Audience audience, CommandSender sender, @Text PGMMap map) {\n-    MapInfo mapInfo = map.getInfo();\n-    audience.sendMessage(mapInfo.getFormattedMapTitle());\n-\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    Component edition = new PersonalizedText(mapInfo.getLocalizedEdition(), ChatColor.GOLD);\n-    if (!edition.toPlainText().isEmpty()) {\n-      audience.sendMessage(\n-          new PersonalizedText(mapInfoLabel(\"command.map.mapInfo.edition\"), edition));\n-    }\n+  public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n+    audience.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_AQUA\n+                + map.getName()\n+                + \" \"\n+                + ChatColor.GRAY\n+                + map.getVersion().toString(),\n+            ChatColor.RED));\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.objective\"),\n-            new PersonalizedText(mapInfo.objective, ChatColor.GOLD)));\n+            new PersonalizedText(map.getDescription(), ChatColor.GOLD)));\n \n-    List<Contributor> authors = mapInfo.getNamedAuthors();\n+    Collection<Contributor> authors = map.getAuthors();\n     if (authors.size() == 1) {\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.authorSingular\"),\n-              formatContribution(authors.get(0))));\n+              formatContribution(authors.iterator().next())));\n     } else {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.authorPlural\"));\n       for (Contributor author : authors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(author)));\n       }\n     }\n \n-    List<Contributor> contributors = mapInfo.getNamedContributors();\n+    Collection<Contributor> contributors = map.getContributors();\n     if (!contributors.isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.contributors\"));\n       for (Contributor contributor : contributors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(contributor)));\n       }\n     }\n \n-    if (mapInfo.rules.size() > 0) {\n+    if (!map.getRules().isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.rules\"));\n \n-      for (int i = 0; i < mapInfo.rules.size(); i++) {\n+      int i = 0;\n+      for (String rule : map.getRules()) {\n         audience.sendMessage(\n             new PersonalizedText(\n-                new PersonalizedText((i + 1) + \") \", ChatColor.WHITE),\n-                new PersonalizedText(mapInfo.rules.get(i), ChatColor.GOLD)));\n+                new PersonalizedText(++i + \") \", ChatColor.WHITE),\n+                new PersonalizedText(rule, ChatColor.GOLD)));\n       }\n     }\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.playerLimit\"),\n-            createPlayerLimitComponent(sender, persistentContext)));\n+            createPlayerLimitComponent(sender, map)));\n \n     if (sender.hasPermission(Permissions.DEBUG)) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.genre\"),\n-              new PersonalizedText(mapInfo.getLocalizedGenre(), ChatColor.GOLD)));\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.proto\"),\n-              new PersonalizedText(mapInfo.proto.toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.folder\"),\n-              new PersonalizedText(map.getFolder().getRelativePath().toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.source\"),\n-              new PersonalizedText(map.getSource().getPath().toString(), ChatColor.GOLD)));\n+              new PersonalizedText(map.getProto().toString(), ChatColor.GOLD)));\n     }\n \n-    URL xmlLink = map.getFolder().getDescriptionFileUrl();\n-    if (xmlLink != null) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              new PersonalizedText(ChatColor.DARK_PURPLE, ChatColor.BOLD)\n-                  .extra(new PersonalizedTranslatable(\"command.map.mapInfo.xml\"))\n-                  .extra(\": \"),\n-              Components.link(xmlLink)\n-                  .hoverEvent(\n-                      HoverEvent.Action.SHOW_TEXT,\n-                      new PersonalizedTranslatable(\"command.map.mapInfo.sourceCode.tip\")\n-                          .render())));\n-    }\n-\n-    Set<MapTag> mapTags = persistentContext.getMapTags();\n-    audience.sendMessage(createTagsComponent(mapTags).color(ChatColor.YELLOW));\n+    audience.sendMessage(createTagsComponent(map.getTags()));\n   }\n \n-  private static Component createTagsComponent(Set<MapTag> tags) {\n+  private Component createTagsComponent(Collection<MapTag> tags) {\n     checkNotNull(tags);\n \n-    Component result = new PersonalizedText();\n+    Component result = mapInfoLabel(\"command.map.mapInfo.tags\");\n     MapTag[] mapTags = tags.toArray(new MapTag[0]);\n     for (int i = 0; i < mapTags.length; i++) {\n       if (i != 0) {\n         result.extra(Components.space());\n       }\n \n-      MapTag mapTag = mapTags[i];\n+      String mapTag = mapTags[i].getId();\n       Component component =\n-          mapTags[i]\n-              .getComponentName()\n-              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maplist \" + mapTag.toString())\n+          new PersonalizedText(\"#\" + mapTag, ChatColor.GOLD)\n+              .bold(false)\n+              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maps -t \" + mapTag)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDI0Nw==", "bodyText": "/maps is the main command.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944247", "createdAt": "2020-01-25T17:06:58Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -97,144 +116,113 @@ private static boolean matchesAuthor(PGMMap map, String query) {\n       aliases = {\"mapinfo\", \"map\"},\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n-  public void map(Audience audience, CommandSender sender, @Text PGMMap map) {\n-    MapInfo mapInfo = map.getInfo();\n-    audience.sendMessage(mapInfo.getFormattedMapTitle());\n-\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    Component edition = new PersonalizedText(mapInfo.getLocalizedEdition(), ChatColor.GOLD);\n-    if (!edition.toPlainText().isEmpty()) {\n-      audience.sendMessage(\n-          new PersonalizedText(mapInfoLabel(\"command.map.mapInfo.edition\"), edition));\n-    }\n+  public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n+    audience.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_AQUA\n+                + map.getName()\n+                + \" \"\n+                + ChatColor.GRAY\n+                + map.getVersion().toString(),\n+            ChatColor.RED));\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.objective\"),\n-            new PersonalizedText(mapInfo.objective, ChatColor.GOLD)));\n+            new PersonalizedText(map.getDescription(), ChatColor.GOLD)));\n \n-    List<Contributor> authors = mapInfo.getNamedAuthors();\n+    Collection<Contributor> authors = map.getAuthors();\n     if (authors.size() == 1) {\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.authorSingular\"),\n-              formatContribution(authors.get(0))));\n+              formatContribution(authors.iterator().next())));\n     } else {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.authorPlural\"));\n       for (Contributor author : authors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(author)));\n       }\n     }\n \n-    List<Contributor> contributors = mapInfo.getNamedContributors();\n+    Collection<Contributor> contributors = map.getContributors();\n     if (!contributors.isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.contributors\"));\n       for (Contributor contributor : contributors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(contributor)));\n       }\n     }\n \n-    if (mapInfo.rules.size() > 0) {\n+    if (!map.getRules().isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.rules\"));\n \n-      for (int i = 0; i < mapInfo.rules.size(); i++) {\n+      int i = 0;\n+      for (String rule : map.getRules()) {\n         audience.sendMessage(\n             new PersonalizedText(\n-                new PersonalizedText((i + 1) + \") \", ChatColor.WHITE),\n-                new PersonalizedText(mapInfo.rules.get(i), ChatColor.GOLD)));\n+                new PersonalizedText(++i + \") \", ChatColor.WHITE),\n+                new PersonalizedText(rule, ChatColor.GOLD)));\n       }\n     }\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.playerLimit\"),\n-            createPlayerLimitComponent(sender, persistentContext)));\n+            createPlayerLimitComponent(sender, map)));\n \n     if (sender.hasPermission(Permissions.DEBUG)) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.genre\"),\n-              new PersonalizedText(mapInfo.getLocalizedGenre(), ChatColor.GOLD)));\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.proto\"),\n-              new PersonalizedText(mapInfo.proto.toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.folder\"),\n-              new PersonalizedText(map.getFolder().getRelativePath().toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.source\"),\n-              new PersonalizedText(map.getSource().getPath().toString(), ChatColor.GOLD)));\n+              new PersonalizedText(map.getProto().toString(), ChatColor.GOLD)));\n     }\n \n-    URL xmlLink = map.getFolder().getDescriptionFileUrl();\n-    if (xmlLink != null) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              new PersonalizedText(ChatColor.DARK_PURPLE, ChatColor.BOLD)\n-                  .extra(new PersonalizedTranslatable(\"command.map.mapInfo.xml\"))\n-                  .extra(\": \"),\n-              Components.link(xmlLink)\n-                  .hoverEvent(\n-                      HoverEvent.Action.SHOW_TEXT,\n-                      new PersonalizedTranslatable(\"command.map.mapInfo.sourceCode.tip\")\n-                          .render())));\n-    }\n-\n-    Set<MapTag> mapTags = persistentContext.getMapTags();\n-    audience.sendMessage(createTagsComponent(mapTags).color(ChatColor.YELLOW));\n+    audience.sendMessage(createTagsComponent(map.getTags()));\n   }\n \n-  private static Component createTagsComponent(Set<MapTag> tags) {\n+  private Component createTagsComponent(Collection<MapTag> tags) {\n     checkNotNull(tags);\n \n-    Component result = new PersonalizedText();\n+    Component result = mapInfoLabel(\"command.map.mapInfo.tags\");\n     MapTag[] mapTags = tags.toArray(new MapTag[0]);\n     for (int i = 0; i < mapTags.length; i++) {\n       if (i != 0) {\n         result.extra(Components.space());\n       }\n \n-      MapTag mapTag = mapTags[i];\n+      String mapTag = mapTags[i].getId();\n       Component component =\n-          mapTags[i]\n-              .getComponentName()\n-              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maplist \" + mapTag.toString())\n+          new PersonalizedText(\"#\" + mapTag, ChatColor.GOLD)\n+              .bold(false)\n+              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maps -t \" + mapTag)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzc0OQ=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 260}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc2ODY2OnYy", "diffSide": "LEFT", "path": "src/main/java/tc/oc/pgm/commands/provider/MapTagsConditionProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDo0OToyMlrOFhuygA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDo0OToyMlrOFhuygA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzkyMA==", "bodyText": "We completly have lost tab suggestion for maptags :(", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913920", "createdAt": "2020-01-25T04:49:22Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/commands/provider/MapTagsConditionProvider.java", "diffHunk": "@@ -1,108 +0,0 @@\n-package tc.oc.pgm.commands.provider;\n-\n-import static com.google.common.base.Preconditions.*;\n-\n-import app.ashcon.intake.argument.ArgumentException;\n-import app.ashcon.intake.argument.CommandArgs;\n-import app.ashcon.intake.argument.Namespace;\n-import app.ashcon.intake.parametric.Provider;\n-import app.ashcon.intake.parametric.ProvisionException;\n-import java.lang.annotation.Annotation;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.TreeSet;\n-import javax.annotation.Nullable;\n-import tc.oc.pgm.map.MapLibrary;\n-import tc.oc.pgm.map.PGMMap;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.maptag.MapTagsCondition;\n-import tc.oc.util.Pair;\n-\n-public class MapTagsConditionProvider implements Provider<MapTagsCondition> {\n-\n-  private static final String PREFIX = Character.toString(MapTag.SYMBOL);\n-  private static final String NEGATION = \"!\";\n-\n-  private final MapLibrary mapLibrary;\n-\n-  public MapTagsConditionProvider(MapLibrary mapLibrary) {\n-    this.mapLibrary = checkNotNull(mapLibrary);\n-  }\n-\n-  @Override\n-  public String getName() {\n-    return \"maptags\";\n-  }\n-\n-  @Nullable\n-  @Override\n-  public MapTagsCondition get(CommandArgs args, List<? extends Annotation> list)\n-      throws ArgumentException, ProvisionException {\n-    Map<MapTag, Boolean> mapTags = new HashMap<>();\n-    while (args.hasNext()) {\n-      parseMapTag(args.next())\n-          .ifPresent(\n-              pair -> {\n-                if (!pair.first.isEmpty()) {\n-                  mapTags.put(MapTag.forName(pair.first), pair.second);\n-                }\n-              });\n-    }\n-\n-    return new MapTagsCondition(mapTags);\n-  }\n-\n-  @Override\n-  public List<String> getSuggestions(\n-      String prefix, Namespace namespace, List<? extends Annotation> modifiers) {\n-    return parseMapTag(prefix)\n-        .map(\n-            pair -> {\n-              Set<String> mapTags = new TreeSet<>(Comparator.naturalOrder());\n-              for (PGMMap map : mapLibrary.getMaps()) {\n-                for (MapTag mapTag : map.getPersistentContext().getMapTags()) {\n-                  if (mapTag.getName().startsWith(pair.first)) {\n-                    mapTags.add(mapTagToString(mapTag, pair.second));\n-                  }\n-                }\n-              }\n-\n-              return (List<String>) new ArrayList<>(mapTags);\n-            })\n-        .orElse(Collections.emptyList());\n-  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc2OTM3OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDo1MTo1OFrOFhuy3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowNzoxNVrOFhwpAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDAxMw==", "bodyText": "I feel that we should make the description a BaseComponent too. Control The Point should be translatable.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914013", "createdAt": "2020-01-25T04:51:58Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java", "diffHunk": "@@ -2,81 +2,92 @@\n \n import com.google.common.collect.ImmutableList;\n import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n import java.util.List;\n-import java.util.Set;\n import java.util.logging.Logger;\n import org.jdom2.Document;\n import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.MapTag;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n import tc.oc.pgm.filters.FilterModule;\n import tc.oc.pgm.goals.GoalMatchModule;\n-import tc.oc.pgm.goals.GoalModule;\n-import tc.oc.pgm.map.MapModule;\n-import tc.oc.pgm.map.MapModuleContext;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.module.ModuleDescription;\n import tc.oc.pgm.regions.RegionModule;\n import tc.oc.pgm.teams.TeamModule;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.xml.InvalidXMLException;\n \n-@ModuleDescription(\n-    name = \"Control Points\",\n-    depends = {TeamModule.class, GoalModule.class, RegionModule.class, FilterModule.class})\n-public class ControlPointModule extends MapModule<ControlPointMatchModule> {\n-\n-  private static final MapTag CONTROLPOINT_TAG = MapTag.forName(\"controlpoint\");\n+public class ControlPointModule implements MapModule<ControlPointMatchModule> {\n \n+  private static final Collection<MapTag> TAGS =\n+      ImmutableList.of(MapTag.create(\"controlpoint\", \"Control the Point\", true, false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDI1OA==", "bodyText": "In the future, not today.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944258", "createdAt": "2020-01-25T17:07:15Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java", "diffHunk": "@@ -2,81 +2,92 @@\n \n import com.google.common.collect.ImmutableList;\n import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n import java.util.List;\n-import java.util.Set;\n import java.util.logging.Logger;\n import org.jdom2.Document;\n import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.MapTag;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n import tc.oc.pgm.filters.FilterModule;\n import tc.oc.pgm.goals.GoalMatchModule;\n-import tc.oc.pgm.goals.GoalModule;\n-import tc.oc.pgm.map.MapModule;\n-import tc.oc.pgm.map.MapModuleContext;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.module.ModuleDescription;\n import tc.oc.pgm.regions.RegionModule;\n import tc.oc.pgm.teams.TeamModule;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.xml.InvalidXMLException;\n \n-@ModuleDescription(\n-    name = \"Control Points\",\n-    depends = {TeamModule.class, GoalModule.class, RegionModule.class, FilterModule.class})\n-public class ControlPointModule extends MapModule<ControlPointMatchModule> {\n-\n-  private static final MapTag CONTROLPOINT_TAG = MapTag.forName(\"controlpoint\");\n+public class ControlPointModule implements MapModule<ControlPointMatchModule> {\n \n+  private static final Collection<MapTag> TAGS =\n+      ImmutableList.of(MapTag.create(\"controlpoint\", \"Control the Point\", true, false));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDAxMw=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc3MDU1OnYy", "diffSide": "LEFT", "path": "src/main/java/tc/oc/pgm/damage/DisableDamageModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDo1NjoxMFrOFhuzdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNDo1NjoxMFrOFhuzdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDE2NA==", "bodyText": "Why complete removal?", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914164", "createdAt": "2020-01-25T04:56:10Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/damage/DisableDamageModule.java", "diffHunk": "@@ -2,73 +2,63 @@\n \n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.SetMultimap;\n-import java.util.Set;\n import java.util.logging.Logger;\n import org.bukkit.event.entity.EntityDamageEvent.DamageCause;\n import org.jdom2.Document;\n import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n import tc.oc.pgm.api.player.PlayerRelation;\n-import tc.oc.pgm.map.MapModule;\n-import tc.oc.pgm.map.MapModuleContext;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.module.ModuleDescription;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.xml.InvalidXMLException;\n import tc.oc.xml.Node;\n \n-@ModuleDescription(name = \"DisableDamage\")\n-public class DisableDamageModule extends MapModule<DisableDamageMatchModule> {\n-\n-  private static final MapTag NOFALLDAMAGE_TAG = MapTag.forName(\"nofalldamage\");\n-\n+public class DisableDamageModule implements MapModule {\n   protected final SetMultimap<DamageCause, PlayerRelation> causes;\n \n   public DisableDamageModule(SetMultimap<DamageCause, PlayerRelation> causes) {\n     this.causes = causes;\n   }\n \n   @Override\n-  public void loadTags(Set<MapTag> tags) {\n-    if (causes.containsKey(DamageCause.FALL)) tags.add(NOFALLDAMAGE_TAG);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc3MzIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNTowNTozOFrOFhu0zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNTowNTozOFrOFhu0zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDUxMA==", "bodyText": "Fix the * import, please.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914510", "createdAt": "2020-01-25T05:05:38Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java", "diffHunk": "@@ -1,14 +1,13 @@\n package tc.oc.pgm.listeners;\n \n-import static com.google.common.base.Preconditions.*;\n+import static com.google.common.base.Preconditions.checkNotNull;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc3NDMyOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNTowODo1N1rOFhu1Wg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxODowNzoyOFrOFhw0iQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDY1MA==", "bodyText": "This is going to break at least OCC website. The slug is used to locate map icons afaik. Can we leave slug here, please?", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914650", "createdAt": "2020-01-25T05:08:57Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java", "diffHunk": "@@ -101,40 +101,34 @@ private void serializeMatch(Match match, JsonObject jsonObject) {\n   private void appendNextMap(JsonObject jsonObject) {\n     checkNotNull(jsonObject);\n \n-    PGMMapOrder mapOrder = this.matchManager.getMapOrder();\n-    if (mapOrder != null) {\n-      PGMMap nextMap = mapOrder.getNextMap();\n+    MapInfo nextMap = mapOrder.getNextMap();\n \n-      if (nextMap != null) {\n-        JsonObject nextMapObject = new JsonObject();\n-        this.serializeMap(nextMap, nextMapObject);\n-        jsonObject.add(\"next_map\", nextMapObject);\n-      }\n+    if (nextMap != null) {\n+      JsonObject nextMapObject = new JsonObject();\n+      this.serializeMap(nextMap, nextMapObject);\n+      jsonObject.add(\"next_map\", nextMapObject);\n     }\n   }\n \n-  private void serializeMap(PGMMap map, JsonObject jsonObject) {\n+  private void serializeMap(MapInfo map, JsonObject jsonObject) {\n     checkNotNull(map);\n     checkNotNull(jsonObject);\n \n-    MapInfo mapInfo = map.getInfo();\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    jsonObject.addProperty(\"slug\", mapInfo.slug());\n-    jsonObject.addProperty(\"name\", mapInfo.name);\n-    jsonObject.addProperty(\"version\", mapInfo.version.toString());\n-    jsonObject.addProperty(\"objective\", mapInfo.objective);\n+    jsonObject.addProperty(\"id\", map.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NzIwOQ==", "bodyText": "<slug> is becoming <id> so I think we'll have to accept this breaking change.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370947209", "createdAt": "2020-01-25T18:07:28Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java", "diffHunk": "@@ -101,40 +101,34 @@ private void serializeMatch(Match match, JsonObject jsonObject) {\n   private void appendNextMap(JsonObject jsonObject) {\n     checkNotNull(jsonObject);\n \n-    PGMMapOrder mapOrder = this.matchManager.getMapOrder();\n-    if (mapOrder != null) {\n-      PGMMap nextMap = mapOrder.getNextMap();\n+    MapInfo nextMap = mapOrder.getNextMap();\n \n-      if (nextMap != null) {\n-        JsonObject nextMapObject = new JsonObject();\n-        this.serializeMap(nextMap, nextMapObject);\n-        jsonObject.add(\"next_map\", nextMapObject);\n-      }\n+    if (nextMap != null) {\n+      JsonObject nextMapObject = new JsonObject();\n+      this.serializeMap(nextMap, nextMapObject);\n+      jsonObject.add(\"next_map\", nextMapObject);\n     }\n   }\n \n-  private void serializeMap(PGMMap map, JsonObject jsonObject) {\n+  private void serializeMap(MapInfo map, JsonObject jsonObject) {\n     checkNotNull(map);\n     checkNotNull(jsonObject);\n \n-    MapInfo mapInfo = map.getInfo();\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    jsonObject.addProperty(\"slug\", mapInfo.slug());\n-    jsonObject.addProperty(\"name\", mapInfo.name);\n-    jsonObject.addProperty(\"version\", mapInfo.version.toString());\n-    jsonObject.addProperty(\"objective\", mapInfo.objective);\n+    jsonObject.addProperty(\"id\", map.getId());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDY1MA=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc3NTM4OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/map/MapInfoImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNToxMzoyM1rOFhu15w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowNzo1M1rOFhwpGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDc5MQ==", "bodyText": "Why is this an integer instead of a Difficulty?", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914791", "createdAt": "2020-01-25T05:13:23Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/map/MapInfoImpl.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.TreeSet;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.bukkit.Difficulty;\n+import org.jdom2.Element;\n+import tc.oc.component.Component;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.AllTranslations;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapTag;\n+import tc.oc.pgm.map.contrib.PlayerContributor;\n+import tc.oc.pgm.map.contrib.PseudonymContributor;\n+import tc.oc.pgm.util.TranslationUtils;\n+import tc.oc.pgm.util.XMLUtils;\n+import tc.oc.server.NullCommandSender;\n+import tc.oc.util.Version;\n+import tc.oc.xml.InvalidXMLException;\n+import tc.oc.xml.Node;\n+\n+public class MapInfoImpl implements MapInfo {\n+  private static final int DEFAULT_DIFFICULTY = Difficulty.NORMAL.ordinal();\n+\n+  private final String id;\n+  private final Version proto;\n+  private final Version version;\n+  private final String name;\n+  private final String description;\n+  private final Collection<Contributor> authors;\n+  private final Collection<Contributor> contributors;\n+  private final Collection<String> rules;\n+  private final int difficulty;\n+  protected final Collection<MapTag> tags;\n+  protected final Collection<Integer> players;\n+\n+  public MapInfoImpl(\n+      @Nullable String id,\n+      Version proto,\n+      Version version,\n+      String name,\n+      String description,\n+      @Nullable Collection<Contributor> authors,\n+      @Nullable Collection<Contributor> contributors,\n+      @Nullable Collection<String> rules,\n+      @Nullable Integer difficulty,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDI4MQ==", "bodyText": "See other comment.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944281", "createdAt": "2020-01-25T17:07:53Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/map/MapInfoImpl.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.TreeSet;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.bukkit.Difficulty;\n+import org.jdom2.Element;\n+import tc.oc.component.Component;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.AllTranslations;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapTag;\n+import tc.oc.pgm.map.contrib.PlayerContributor;\n+import tc.oc.pgm.map.contrib.PseudonymContributor;\n+import tc.oc.pgm.util.TranslationUtils;\n+import tc.oc.pgm.util.XMLUtils;\n+import tc.oc.server.NullCommandSender;\n+import tc.oc.util.Version;\n+import tc.oc.xml.InvalidXMLException;\n+import tc.oc.xml.Node;\n+\n+public class MapInfoImpl implements MapInfo {\n+  private static final int DEFAULT_DIFFICULTY = Difficulty.NORMAL.ordinal();\n+\n+  private final String id;\n+  private final Version proto;\n+  private final Version version;\n+  private final String name;\n+  private final String description;\n+  private final Collection<Contributor> authors;\n+  private final Collection<Contributor> contributors;\n+  private final Collection<String> rules;\n+  private final int difficulty;\n+  protected final Collection<MapTag> tags;\n+  protected final Collection<Integer> players;\n+\n+  public MapInfoImpl(\n+      @Nullable String id,\n+      Version proto,\n+      Version version,\n+      String name,\n+      String description,\n+      @Nullable Collection<Contributor> authors,\n+      @Nullable Collection<Contributor> contributors,\n+      @Nullable Collection<String> rules,\n+      @Nullable Integer difficulty,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDc5MQ=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc3NTkwOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/map/MapInfoImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNToxNToyOVrOFhu2Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNToxNToyOVrOFhu2Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDg1NQ==", "bodyText": "I think we should make a public static factory method to parse the XML and return a new instance of this class.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914855", "createdAt": "2020-01-25T05:15:29Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/map/MapInfoImpl.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.TreeSet;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.bukkit.Difficulty;\n+import org.jdom2.Element;\n+import tc.oc.component.Component;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.AllTranslations;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapTag;\n+import tc.oc.pgm.map.contrib.PlayerContributor;\n+import tc.oc.pgm.map.contrib.PseudonymContributor;\n+import tc.oc.pgm.util.TranslationUtils;\n+import tc.oc.pgm.util.XMLUtils;\n+import tc.oc.server.NullCommandSender;\n+import tc.oc.util.Version;\n+import tc.oc.xml.InvalidXMLException;\n+import tc.oc.xml.Node;\n+\n+public class MapInfoImpl implements MapInfo {\n+  private static final int DEFAULT_DIFFICULTY = Difficulty.NORMAL.ordinal();\n+\n+  private final String id;\n+  private final Version proto;\n+  private final Version version;\n+  private final String name;\n+  private final String description;\n+  private final Collection<Contributor> authors;\n+  private final Collection<Contributor> contributors;\n+  private final Collection<String> rules;\n+  private final int difficulty;\n+  protected final Collection<MapTag> tags;\n+  protected final Collection<Integer> players;\n+\n+  public MapInfoImpl(\n+      @Nullable String id,\n+      Version proto,\n+      Version version,\n+      String name,\n+      String description,\n+      @Nullable Collection<Contributor> authors,\n+      @Nullable Collection<Contributor> contributors,\n+      @Nullable Collection<String> rules,\n+      @Nullable Integer difficulty,\n+      @Nullable Collection<MapTag> tags,\n+      @Nullable Collection<Integer> players) {\n+    this.name = checkNotNull(name);\n+    this.id = checkNotNull(MapInfo.normalizeName(id == null ? name : id));\n+    this.proto = checkNotNull(proto);\n+    this.version = checkNotNull(version);\n+    this.description = checkNotNull(description);\n+    this.authors = authors == null ? new LinkedList<>() : authors;\n+    this.contributors = contributors == null ? new LinkedList<>() : contributors;\n+    this.rules = rules == null ? new LinkedList<>() : rules;\n+    this.difficulty = difficulty == null ? DEFAULT_DIFFICULTY : difficulty;\n+    this.tags = tags == null ? new TreeSet<>() : tags;\n+    this.players = players == null ? new LinkedList<>() : players;\n+  }\n+\n+  public MapInfoImpl(MapInfo info) {\n+    this(\n+        checkNotNull(info).getId(),\n+        info.getProto(),\n+        info.getVersion(),\n+        info.getName(),\n+        info.getDescription(),\n+        info.getAuthors(),\n+        info.getContributors(),\n+        info.getRules(),\n+        info.getDifficulty(),\n+        info.getTags(),\n+        info.getMaxPlayers());\n+  }\n+\n+  public MapInfoImpl(Element root) throws InvalidXMLException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc3OTYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/map/MapTagImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNToyOToyM1rOFhu39w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNToyOToyM1rOFhu39w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNTMxOQ==", "bodyText": "I called this SYMBOL originally because all these different special characters (mainly on scoreboard) were called SYMBOLs.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370915319", "createdAt": "2020-01-25T05:29:23Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/map/MapTagImpl.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import tc.oc.pgm.api.map.MapTag;\n+\n+public class MapTagImpl implements MapTag {\n+\n+  private static final String HASHTAG = \"#\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc4MDc1OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/map/MapTagImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNTozMjo0MlrOFhu4eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNTozMjo0MlrOFhu4eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNTQ0OA==", "bodyText": "We lost the regex pattern to validate if the maptag was in lower case, between a-z, 0-9, with - or _. This is public and people from outside can create new instances of this class with illegal characters which will potentially lead to bugs.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370915448", "createdAt": "2020-01-25T05:32:42Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/map/MapTagImpl.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import tc.oc.pgm.api.map.MapTag;\n+\n+public class MapTagImpl implements MapTag {\n+\n+  private static final String HASHTAG = \"#\";\n+  private final String id;\n+  private final String name;\n+  private final boolean gamemode;\n+  private final boolean auxiliary;\n+\n+  public MapTagImpl(String id, String name, boolean gamemode, boolean auxiliary) {\n+    this.id = checkNotNull(id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc4MTY5OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/api/map/MapTag.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNTozNjoyNlrOFhu49g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNTozNjoyNlrOFhu49g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNTU3NA==", "bodyText": "getName() and getDescription() maybe?", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370915574", "createdAt": "2020-01-25T05:36:26Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/api/map/MapTag.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package tc.oc.pgm.api.map;\n+\n+import tc.oc.pgm.map.MapTagImpl;\n+\n+/** A \"#hashtag\" that describes a {@link MapInfo} feature. */\n+public interface MapTag extends Comparable<MapTag> {\n+\n+  /**\n+   * Get a short id for the tag.\n+   *\n+   * @return A short, lowercase id without the \"#\".\n+   */\n+  String getId();\n+\n+  /**\n+   * Get a full name for the tag.\n+   *\n+   * @return A full name.\n+   */\n+  String getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjc4MjQzOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/map/MapInfoImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNTozOTowOVrOFhu5TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQwNTozOTowOVrOFhu5TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNTY2MQ==", "bodyText": "Bukkit.getDifficulty()?", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370915661", "createdAt": "2020-01-25T05:39:09Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/map/MapInfoImpl.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.TreeSet;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.bukkit.Difficulty;\n+import org.jdom2.Element;\n+import tc.oc.component.Component;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.AllTranslations;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapTag;\n+import tc.oc.pgm.map.contrib.PlayerContributor;\n+import tc.oc.pgm.map.contrib.PseudonymContributor;\n+import tc.oc.pgm.util.TranslationUtils;\n+import tc.oc.pgm.util.XMLUtils;\n+import tc.oc.server.NullCommandSender;\n+import tc.oc.util.Version;\n+import tc.oc.xml.InvalidXMLException;\n+import tc.oc.xml.Node;\n+\n+public class MapInfoImpl implements MapInfo {\n+  private static final int DEFAULT_DIFFICULTY = Difficulty.NORMAL.ordinal();\n+\n+  private final String id;\n+  private final Version proto;\n+  private final Version version;\n+  private final String name;\n+  private final String description;\n+  private final Collection<Contributor> authors;\n+  private final Collection<Contributor> contributors;\n+  private final Collection<String> rules;\n+  private final int difficulty;\n+  protected final Collection<MapTag> tags;\n+  protected final Collection<Integer> players;\n+\n+  public MapInfoImpl(\n+      @Nullable String id,\n+      Version proto,\n+      Version version,\n+      String name,\n+      String description,\n+      @Nullable Collection<Contributor> authors,\n+      @Nullable Collection<Contributor> contributors,\n+      @Nullable Collection<String> rules,\n+      @Nullable Integer difficulty,\n+      @Nullable Collection<MapTag> tags,\n+      @Nullable Collection<Integer> players) {\n+    this.name = checkNotNull(name);\n+    this.id = checkNotNull(MapInfo.normalizeName(id == null ? name : id));\n+    this.proto = checkNotNull(proto);\n+    this.version = checkNotNull(version);\n+    this.description = checkNotNull(description);\n+    this.authors = authors == null ? new LinkedList<>() : authors;\n+    this.contributors = contributors == null ? new LinkedList<>() : contributors;\n+    this.rules = rules == null ? new LinkedList<>() : rules;\n+    this.difficulty = difficulty == null ? DEFAULT_DIFFICULTY : difficulty;\n+    this.tags = tags == null ? new TreeSet<>() : tags;\n+    this.players = players == null ? new LinkedList<>() : players;\n+  }\n+\n+  public MapInfoImpl(MapInfo info) {\n+    this(\n+        checkNotNull(info).getId(),\n+        info.getProto(),\n+        info.getVersion(),\n+        info.getName(),\n+        info.getDescription(),\n+        info.getAuthors(),\n+        info.getContributors(),\n+        info.getRules(),\n+        info.getDifficulty(),\n+        info.getTags(),\n+        info.getMaxPlayers());\n+  }\n+\n+  public MapInfoImpl(Element root) throws InvalidXMLException {\n+    this(\n+        checkNotNull(root).getChildTextNormalize(\"slug\"),\n+        XMLUtils.parseSemanticVersion(Node.fromRequiredAttr(root, \"proto\")),\n+        XMLUtils.parseSemanticVersion(Node.fromRequiredChildOrAttr(root, \"version\")),\n+        Node.fromRequiredChildOrAttr(root, \"name\").getValueNormalize(),\n+        Node.fromRequiredChildOrAttr(root, \"objective\", \"description\").getValueNormalize(),\n+        parseContributors(root, \"author\"),\n+        parseContributors(root, \"contributor\"),\n+        parseRules(root),\n+        XMLUtils.parseEnum(\n+                Node.fromLastChildOrAttr(root, \"difficulty\"),\n+                Difficulty.class,\n+                \"difficulty\",\n+                Difficulty.NORMAL)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjk5ODQ2OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/match/MatchImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNjo0MTowNVrOFhwjoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowOTowN1rOFhwpXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mjg4MQ==", "bodyText": "I think this should count sum()?", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370942881", "createdAt": "2020-01-25T16:41:05Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/match/MatchImpl.java", "diffHunk": "@@ -131,7 +134,8 @@ protected MatchImpl(String id, PGMMap map, World world) {\n     this.state = new AtomicReference<>(MatchPhase.IDLE);\n     this.start = new AtomicLong(0);\n     this.end = new AtomicLong(0);\n-    this.capacity = new AtomicInteger(map.getPersistentContext().getTotalMaxPlayers());\n+    this.capacity =\n+        new AtomicInteger(map.getMaxPlayers().stream().findFirst().orElse(Bukkit.getMaxPlayers()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDM0OA==", "bodyText": "Ah yes, nice catch.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944348", "createdAt": "2020-01-25T17:09:07Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/match/MatchImpl.java", "diffHunk": "@@ -131,7 +134,8 @@ protected MatchImpl(String id, PGMMap map, World world) {\n     this.state = new AtomicReference<>(MatchPhase.IDLE);\n     this.start = new AtomicLong(0);\n     this.end = new AtomicLong(0);\n-    this.capacity = new AtomicInteger(map.getPersistentContext().getTotalMaxPlayers());\n+    this.capacity =\n+        new AtomicInteger(map.getMaxPlayers().stream().findFirst().orElse(Bukkit.getMaxPlayers()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mjg4MQ=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5Mjk5OTExOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/match/MatchManagerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNjo0MjozN1rOFhwj8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNjo0MjozN1rOFhwj8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mjk2MA==", "bodyText": "If the world is null throw NPE for finding bugs easier?", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370942960", "createdAt": "2020-01-25T16:42:37Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/match/MatchManagerImpl.java", "diffHunk": "@@ -1,433 +1,206 @@\n package tc.oc.pgm.match;\n \n-import com.google.common.cache.*;\n-import com.google.common.collect.ImmutableSet;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.collect.Iterables;\n import java.io.File;\n import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.AtomicLong;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n-import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n-import org.bukkit.*;\n+import org.bukkit.Difficulty;\n+import org.bukkit.Server;\n+import org.bukkit.World;\n+import org.bukkit.WorldCreator;\n import org.bukkit.entity.Player;\n-import tc.oc.pgm.Config;\n+import org.joda.time.Duration;\n+import tc.oc.chunk.NullChunkGenerator;\n import tc.oc.pgm.api.PGM;\n import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.chat.MultiAudience;\n+import tc.oc.pgm.api.map.MapContext;\n+import tc.oc.pgm.api.map.exception.MapMissingException;\n import tc.oc.pgm.api.match.Match;\n import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.match.factory.MatchFactory;\n import tc.oc.pgm.api.player.MatchPlayer;\n-import tc.oc.pgm.map.*;\n-import tc.oc.pgm.module.ModuleLoadException;\n-import tc.oc.pgm.rotation.PGMMapOrder;\n-import tc.oc.pgm.terrain.TerrainModule;\n+import tc.oc.server.Scheduler;\n+import tc.oc.util.ClassLogger;\n import tc.oc.util.FileUtils;\n-import tc.oc.util.logging.ClassLogger;\n-import tc.oc.world.NMSHacks;\n \n-@SuppressWarnings(\"UnstableApiUsage\")\n-public class MatchManagerImpl implements MatchManager, MultiAudience {\n+public class MatchManagerImpl implements MatchFactory, MatchManager {\n+\n+  private static final Duration TIMEOUT = Duration.standardSeconds(30);\n \n   private final Logger logger;\n   private final Server server;\n-  private final MapLibrary library;\n-  private final MapLoader loader;\n-\n-  private final Map<String, Match> matchById = new ConcurrentHashMap<>();\n-  private final Map<String, String> matchIdByWorldName = new HashMap<>();\n-  private final LoadingCache<PGMMap, String> preMatch =\n-      CacheBuilder.newBuilder()\n-          .expireAfterWrite(10, TimeUnit.SECONDS)\n-          // If after 10 secs of writing the match it hasn't been loaded, unload & destroy it\n-          .removalListener(\n-              (RemovalNotification<PGMMap, String> r) -> {\n-                if (!matchById.get(r.getValue()).isLoaded()) unloadMatch(r.getValue());\n-              })\n-          .concurrencyLevel(1)\n-          .build(\n-              new CacheLoader<PGMMap, String>() {\n-                @Override\n-                public String load(@Nonnull PGMMap pgmMap) throws Exception {\n-                  return createPreMatch(pgmMap).getId();\n-                }\n-              });\n-  private final AtomicInteger count;\n-\n-  private PGMMapOrder pgmMapOrder;\n-\n-  public MatchManagerImpl(Server server, MapLibrary library, MapLoader loader)\n-      throws MapNotFoundException {\n-    this.logger = ClassLogger.get(PGM.get().getLogger(), getClass());\n-    this.server = server;\n-    this.library = library;\n-    this.loader = loader;\n-    this.count = new AtomicInteger(0);\n-\n-    loadNewMaps();\n-  }\n-\n-  public void createPreMatchAsync(final PGMMap map) {\n-    logger.fine(\"Creating pre-match for \" + map.getName() + \" async\");\n-    PGM.get()\n-        .getServer()\n-        .getScheduler()\n-        .runTaskAsynchronously(\n-            PGM.get(),\n-            () -> {\n-              try {\n-                preMatch.get(map);\n-                PGM.get()\n-                    .getLogger()\n-                    .fine(\"Done creating pre-match for \" + map.getName() + \" async\");\n-              } catch (Throwable t) {\n-                throw new RuntimeException(t);\n-              }\n-            });\n-  }\n-\n-  /**\n-   * Pre-creates a match, without loading it. Can and should be done async unless a /cycle 0 is\n-   * done.\n-   *\n-   * @param map The map to generate a pre-match for\n-   * @return The created pre-match\n-   * @throws Exception If the match fails to be generated\n-   */\n-  private Match createPreMatch(PGMMap map) throws Exception {\n-    logger.fine(\"Creating pre-match for \" + map.getName());\n-    String id = Integer.toString(count.getAndIncrement());\n-\n-    if (!map.getContext().isPresent()) {\n-      map.reload(true);\n-    }\n-\n-    final TerrainModule terrain = map.getContext().get().needModule(TerrainModule.class);\n-    final File src = terrain.getWorldFolder();\n+  private final Scheduler scheduler;\n \n-    final String worldName = createMatchFolder(id, src);\n-    final World world = createMatchWorld(worldName, map.getInfo(), terrain);\n+  private final AtomicLong matches;\n+  private final Map<String, Match> matchById;\n+  private final Map<String, Match> matchByWorld;\n \n-    final Match match = new MatchImpl(id, map, world);\n-\n-    matchById.put(match.getId(), match);\n-    matchIdByWorldName.put(match.getWorld().getName(), match.getId());\n-\n-    logger.fine(\"Done creating pre-match for \" + map.getName());\n-    return match;\n+  public MatchManagerImpl(Logger logger, Server server) {\n+    this.logger = ClassLogger.get(checkNotNull(logger), getClass());\n+    this.server = checkNotNull(server);\n+    this.scheduler = new Scheduler(PGM.get());\n+    this.matches = new AtomicLong(0);\n+    this.matchById = new ConcurrentHashMap<>();\n+    this.matchByWorld = new ConcurrentHashMap<>();\n   }\n \n   @Override\n-  public Match createMatch(PGMMap map) throws Throwable {\n-    final Match match = matchById.get(preMatch.get(map));\n-\n-    try {\n-      match.load();\n-    } catch (Throwable t) {\n-      unloadMatch(match.getId());\n-      throw t;\n-    } finally {\n-      // Remove all preMatches, since we already loaded one\n-      preMatch.invalidateAll();\n-    }\n-\n-    return match;\n-  }\n-\n-  private String createMatchFolder(String id, File src) throws IOException {\n-    final String worldName = getWorldName(id);\n-    final File dest = new File(server.getWorldContainer(), worldName);\n-\n-    if (dest.exists()) FileUtils.delete(dest);\n-\n-    if (!dest.mkdir()) {\n-      throw new IOException(\"Failed to create temporary world folder \" + dest);\n-    }\n-\n-    FileUtils.copy(new File(src, \"level.dat\"), new File(dest, \"level.dat\"));\n-\n-    File region = new File(src, \"region\");\n-    if (region.isDirectory()) {\n-      FileUtils.copy(region, new File(dest, \"region\"));\n-    }\n-\n-    File data = new File(src, \"data\");\n-    if (data.isDirectory()) {\n-      FileUtils.copy(data, new File(dest, \"data\"));\n-    }\n-\n-    return worldName;\n-  }\n-\n-  private World createMatchWorld(String worldName, MapInfo info, TerrainModule terrain) {\n-    WorldCreator creator = server.detectWorld(worldName);\n-    if (creator == null) creator = new WorldCreator(worldName);\n-    creator\n-        .environment(info.dimension)\n-        .generator(terrain.getChunkGenerator())\n-        .seed(terrain.getSeed());\n-\n-    final World world = createWorld(creator);\n-    if (world == null) {\n-      throw new IllegalStateException(\"Failed to create world, createWorld returned null\");\n-    }\n-\n-    world.setPVP(true);\n-    world.setSpawnFlags(false, false);\n-    world.setAutoSave(false);\n-\n-    if (info.difficulty != null) {\n-      world.setDifficulty(info.difficulty);\n-    } else {\n-      world.setDifficulty(server.getWorlds().get(0).getDifficulty());\n-    }\n-\n-    return world;\n+  public Match getMatch(@Nullable World world) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 230}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzAwMDE0OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/modes/ObjectiveModesModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNjo0NDoyOVrOFhwkbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNjo0NDoyOVrOFhwkbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0MzA4NA==", "bodyText": "I think we should keep the * import?", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943084", "createdAt": "2020-01-25T16:44:29Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/modes/ObjectiveModesModule.java", "diffHunk": "@@ -1,95 +1,102 @@\n package tc.oc.pgm.modes;\n \n-import static tc.oc.pgm.map.ProtoVersions.*;\n+import static tc.oc.pgm.api.map.MapProtos.MODES_IMPLEMENTATION_VERSION;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzAwMDc0OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/modules/EventFilterMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNjo0NTo0OFrOFhwkug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNjo0NTo0OFrOFhwkug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0MzE2Mg==", "bodyText": "Modules should have their own loggers if possible.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943162", "createdAt": "2020-01-25T16:45:48Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/modules/EventFilterMatchModule.java", "diffHunk": "@@ -39,14 +55,16 @@\n  * kept simple.\n  */\n @ListenerScope(MatchScope.LOADED)\n-public class EventFilterMatchModule extends MatchModule implements Listener {\n+public class EventFilterMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n \n   public EventFilterMatchModule(Match match) {\n-    super(match);\n+    this.match = match;\n   }\n \n   boolean cancel(Cancellable event, @Nullable MatchPlayer actor, @Nullable Component message) {\n-    logger.fine(\"Cancel \" + event + \" actor=\" + actor);\n+    match.getLogger().fine(\"Cancel \" + event + \" actor=\" + actor);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzAwNTcyOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/score/ScoreModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNjo1Nzo0M1rOFhwnJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNjo1Nzo0M1rOFhwnJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mzc4Mg==", "bodyText": "Unnecessary newline", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943782", "createdAt": "2020-01-25T16:57:43Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/score/ScoreModule.java", "diffHunk": "@@ -80,69 +71,78 @@ public ScoreConfig getConfig() {\n     return config;\n   }\n \n-  // ---------------------\n-  // ---- XML Parsing ----\n-  // ---------------------\n-\n-  public static ScoreModule parse(MapModuleContext context, Logger logger, Document doc)\n-      throws InvalidXMLException {\n-    SemanticVersion proto = context.getProto();\n+  public static class Factory implements MapModuleFactory<ScoreModule> {\n+    @Override\n+    public Collection<Class<? extends MapModule>> getSoftDependencies() {\n+      return ImmutableList.of(RegionModule.class, FilterModule.class);\n+    }\n \n-    List<Element> scoreElements = doc.getRootElement().getChildren(\"score\");\n-    if (scoreElements.size() == 0) {\n-      return null;\n+    @Override\n+    public Collection<Class<? extends MapModule>> getWeakDependencies() {\n+      return ImmutableList.of(BlitzModule.class);\n     }\n \n-    RegionParser regionParser = context.getRegionParser();\n-    ScoreConfig config = new ScoreConfig();\n-    ImmutableSet.Builder<ScoreBoxFactory> scoreBoxFactories = ImmutableSet.builder();\n-\n-    for (Element scoreEl : scoreElements) {\n-      config.scoreLimit = XMLUtils.parseNumber(scoreEl.getChild(\"limit\"), Integer.class, -1);\n-\n-      // For backwards compatibility, default kill/death points to 1 if proto is old and <king/> tag\n-      // is not present\n-      boolean scoreKillsByDefault =\n-          proto.isOlderThan(ProtoVersions.DEFAULT_SCORES_TO_ZERO)\n-              && scoreEl.getChild(\"king\") == null;\n-      config.deathScore =\n-          XMLUtils.parseNumber(\n-              scoreEl.getChild(\"deaths\"), Integer.class, scoreKillsByDefault ? 1 : 0);\n-      config.killScore =\n-          XMLUtils.parseNumber(\n-              scoreEl.getChild(\"kills\"), Integer.class, scoreKillsByDefault ? 1 : 0);\n-\n-      for (Element scoreBoxEl : scoreEl.getChildren(\"box\")) {\n-        int points =\n+    @Override\n+    public ScoreModule parse(MapFactory factory, Logger logger, Document doc)\n+        throws InvalidXMLException {\n+      Version proto = factory.getProto();\n+\n+      List<Element> scoreElements = doc.getRootElement().getChildren(\"score\");\n+      if (scoreElements.size() == 0) {\n+        return null;\n+      }\n+\n+      RegionParser regionParser = factory.getRegions();\n+      ScoreConfig config = new ScoreConfig();\n+      ImmutableSet.Builder<ScoreBoxFactory> scoreBoxFactories = ImmutableSet.builder();\n+\n+      for (Element scoreEl : scoreElements) {\n+        config.scoreLimit = XMLUtils.parseNumber(scoreEl.getChild(\"limit\"), Integer.class, -1);\n+\n+        // For backwards compatibility, default kill/death points to 1 if proto is old and <king/>\n+        // tag\n+        // is not present", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzAwNjE2OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNjo1ODo0OFrOFhwnWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNjo1ODo0OFrOFhwnWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0MzgzNA==", "bodyText": "Should be translatable.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943834", "createdAt": "2020-01-25T16:58:48Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java", "diffHunk": "@@ -70,6 +88,37 @@\n \n   protected @Nullable BukkitTask renderTask;\n \n+  private static String renderSidebarTitle(Collection<MapTag> tags) {\n+    final List<String> gamemode =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(tag -> !tag.isAuxiliary())\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+    final List<String> auxiliary =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(MapTag::isAuxiliary)\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+\n+    String title = \"\";\n+\n+    if (gamemode.size() == 1) {\n+      title = gamemode.get(0);\n+    } else if (gamemode.size() >= 2) {\n+      title = \"Objectives\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzAwNjQ1OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNjo1OToyNFrOFhwnfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNjo1OToyNFrOFhwnfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mzg3MQ==", "bodyText": "& should also be translatable.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943871", "createdAt": "2020-01-25T16:59:24Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java", "diffHunk": "@@ -70,6 +88,37 @@\n \n   protected @Nullable BukkitTask renderTask;\n \n+  private static String renderSidebarTitle(Collection<MapTag> tags) {\n+    final List<String> gamemode =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(tag -> !tag.isAuxiliary())\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+    final List<String> auxiliary =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(MapTag::isAuxiliary)\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+\n+    String title = \"\";\n+\n+    if (gamemode.size() == 1) {\n+      title = gamemode.get(0);\n+    } else if (gamemode.size() >= 2) {\n+      title = \"Objectives\";\n+    }\n+\n+    if (auxiliary.size() == 1) {\n+      title += (title.isEmpty() ? \"\" : \" & \") + auxiliary.get(0);\n+    } else if (gamemode.isEmpty() && auxiliary.size() == 2) {\n+      title = auxiliary.get(0) + \" & \" + auxiliary.get(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzAwNjUxOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNjo1OTozMVrOFhwnhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNjo1OTozMVrOFhwnhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mzg3Nw==", "bodyText": "This too", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943877", "createdAt": "2020-01-25T16:59:31Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java", "diffHunk": "@@ -70,6 +88,37 @@\n \n   protected @Nullable BukkitTask renderTask;\n \n+  private static String renderSidebarTitle(Collection<MapTag> tags) {\n+    final List<String> gamemode =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(tag -> !tag.isAuxiliary())\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+    final List<String> auxiliary =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(MapTag::isAuxiliary)\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+\n+    String title = \"\";\n+\n+    if (gamemode.size() == 1) {\n+      title = gamemode.get(0);\n+    } else if (gamemode.size() >= 2) {\n+      title = \"Objectives\";\n+    }\n+\n+    if (auxiliary.size() == 1) {\n+      title += (title.isEmpty() ? \"\" : \" & \") + auxiliary.get(0);\n+    } else if (gamemode.isEmpty() && auxiliary.size() == 2) {\n+      title = auxiliary.get(0) + \" & \" + auxiliary.get(1);\n+    }\n+\n+    return title.isEmpty() ? \"Match\" : title;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzAwNzY0OnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/teams/TeamModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowMjo0MVrOFhwoGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowMjo0MVrOFhwoGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDAyNg==", "bodyText": "amount?", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944026", "createdAt": "2020-01-25T17:02:41Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/teams/TeamModule.java", "diffHunk": "@@ -40,15 +39,44 @@ public TeamModule(Set<TeamFactory> teams, @Nullable Boolean requireEven) {\n   }\n \n   @Override\n-  public String toString() {\n-    return getClass().getSimpleName() + \"{teams=[\" + Joiner.on(\", \").join(teams) + \"]}\";\n+  public Collection<MapTag> getTags() {\n+    final int id = teams.size();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzAwODA4OnYy", "diffSide": "LEFT", "path": "src/main/java/tc/oc/pgm/terrain/TerrainModule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowMzo1NlrOFhwoWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowMzo1NlrOFhwoWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDA4OA==", "bodyText": "Why complete removal?", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944088", "createdAt": "2020-01-25T17:03:56Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/terrain/TerrainModule.java", "diffHunk": "@@ -1,40 +1,28 @@\n package tc.oc.pgm.terrain;\n \n-import java.io.File;\n import java.util.Random;\n-import java.util.Set;\n import java.util.logging.Logger;\n import javax.annotation.Nullable;\n import org.bukkit.generator.ChunkGenerator;\n import org.jdom2.Document;\n import org.jdom2.Element;\n import tc.oc.chunk.NullChunkGenerator;\n-import tc.oc.pgm.map.MapModule;\n-import tc.oc.pgm.map.MapModuleContext;\n-import tc.oc.pgm.map.MapModuleFactory;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.match.MatchModule;\n-import tc.oc.pgm.module.ModuleDescription;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.xml.InvalidXMLException;\n-import tc.oc.xml.Node;\n \n-@ModuleDescription(name = \"Terrain\")\n-public class TerrainModule extends MapModule<MatchModule> {\n-\n-  private static final MapTag VANILLAWORLDGEN_TAG = MapTag.forName(\"vanillaworldgen\");\n+public class TerrainModule implements MapModule {\n \n   private final TerrainOptions options;\n \n   public TerrainModule(TerrainOptions options) {\n     this.options = options;\n   }\n \n-  @Override\n-  public void loadTags(Set<MapTag> tags) {\n-    if (options.vanilla) tags.add(VANILLAWORLDGEN_TAG);\n-  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzAwODUwOnYy", "diffSide": "LEFT", "path": "src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowNToxOVrOFhwokQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzo1MjoyNVrOFhwxhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDE0NQ==", "bodyText": "Why complete removal?", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944145", "createdAt": "2020-01-25T17:05:19Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java", "diffHunk": "@@ -1,103 +1,89 @@\n package tc.oc.pgm.timelimit;\n \n-import java.util.Set;\n import java.util.logging.Logger;\n import javax.annotation.Nullable;\n import org.jdom2.Attribute;\n import org.jdom2.Document;\n import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.MapProtos;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n import tc.oc.pgm.api.match.Match;\n-import tc.oc.pgm.bossbar.BossBarModule;\n-import tc.oc.pgm.map.MapModule;\n-import tc.oc.pgm.map.MapModuleContext;\n-import tc.oc.pgm.map.ProtoVersions;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.module.ModuleDescription;\n+import tc.oc.pgm.api.match.MatchModule;\n import tc.oc.pgm.result.VictoryCondition;\n import tc.oc.pgm.result.VictoryConditions;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.util.components.PeriodFormats;\n import tc.oc.xml.InvalidXMLException;\n \n-@ModuleDescription(\n-    name = \"Time Limit\",\n-    requires = {BossBarModule.class})\n-public class TimeLimitModule extends MapModule<TimeLimitMatchModule> {\n-\n-  private static final MapTag TIMELIMIT_TAG = MapTag.forName(\"timelimit\");\n-\n+public class TimeLimitModule implements MapModule {\n   private final @Nullable TimeLimit timeLimit;\n \n   public TimeLimitModule(@Nullable TimeLimit limit) {\n     this.timeLimit = limit;\n   }\n \n   @Override\n-  public void loadTags(Set<MapTag> tags) {\n-    if (timeLimit != null) tags.add(TIMELIMIT_TAG);\n-  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDQ0MQ==", "bodyText": "Too many tags.. you have to keep it simple.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944441", "createdAt": "2020-01-25T17:11:03Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java", "diffHunk": "@@ -1,103 +1,89 @@\n package tc.oc.pgm.timelimit;\n \n-import java.util.Set;\n import java.util.logging.Logger;\n import javax.annotation.Nullable;\n import org.jdom2.Attribute;\n import org.jdom2.Document;\n import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.MapProtos;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n import tc.oc.pgm.api.match.Match;\n-import tc.oc.pgm.bossbar.BossBarModule;\n-import tc.oc.pgm.map.MapModule;\n-import tc.oc.pgm.map.MapModuleContext;\n-import tc.oc.pgm.map.ProtoVersions;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.module.ModuleDescription;\n+import tc.oc.pgm.api.match.MatchModule;\n import tc.oc.pgm.result.VictoryCondition;\n import tc.oc.pgm.result.VictoryConditions;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.util.components.PeriodFormats;\n import tc.oc.xml.InvalidXMLException;\n \n-@ModuleDescription(\n-    name = \"Time Limit\",\n-    requires = {BossBarModule.class})\n-public class TimeLimitModule extends MapModule<TimeLimitMatchModule> {\n-\n-  private static final MapTag TIMELIMIT_TAG = MapTag.forName(\"timelimit\");\n-\n+public class TimeLimitModule implements MapModule {\n   private final @Nullable TimeLimit timeLimit;\n \n   public TimeLimitModule(@Nullable TimeLimit limit) {\n     this.timeLimit = limit;\n   }\n \n   @Override\n-  public void loadTags(Set<MapTag> tags) {\n-    if (timeLimit != null) tags.add(TIMELIMIT_TAG);\n-  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDE0NQ=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NjQzNg==", "bodyText": "You could easily differentiate maps where you have to score n amount of points to win the match and maps where you have to score most points before the time ends. This one was pretty useful.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370946436", "createdAt": "2020-01-25T17:52:25Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java", "diffHunk": "@@ -1,103 +1,89 @@\n package tc.oc.pgm.timelimit;\n \n-import java.util.Set;\n import java.util.logging.Logger;\n import javax.annotation.Nullable;\n import org.jdom2.Attribute;\n import org.jdom2.Document;\n import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.MapProtos;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n import tc.oc.pgm.api.match.Match;\n-import tc.oc.pgm.bossbar.BossBarModule;\n-import tc.oc.pgm.map.MapModule;\n-import tc.oc.pgm.map.MapModuleContext;\n-import tc.oc.pgm.map.ProtoVersions;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.module.ModuleDescription;\n+import tc.oc.pgm.api.match.MatchModule;\n import tc.oc.pgm.result.VictoryCondition;\n import tc.oc.pgm.result.VictoryConditions;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.util.components.PeriodFormats;\n import tc.oc.xml.InvalidXMLException;\n \n-@ModuleDescription(\n-    name = \"Time Limit\",\n-    requires = {BossBarModule.class})\n-public class TimeLimitModule extends MapModule<TimeLimitMatchModule> {\n-\n-  private static final MapTag TIMELIMIT_TAG = MapTag.forName(\"timelimit\");\n-\n+public class TimeLimitModule implements MapModule {\n   private final @Nullable TimeLimit timeLimit;\n \n   public TimeLimitModule(@Nullable TimeLimit limit) {\n     this.timeLimit = limit;\n   }\n \n   @Override\n-  public void loadTags(Set<MapTag> tags) {\n-    if (timeLimit != null) tags.add(TIMELIMIT_TAG);\n-  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDE0NQ=="}, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5MzAwOTc3OnYy", "diffSide": "LEFT", "path": "src/main/java/tc/oc/pgm/worldborder/WorldBorderModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowODoxMFrOFhwpLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNVQxNzowODoxMFrOFhwpLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDMwMw==", "bodyText": "Here too", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944303", "createdAt": "2020-01-25T17:08:10Z", "author": {"login": "TheMolkaPL"}, "path": "src/main/java/tc/oc/pgm/worldborder/WorldBorderModule.java", "diffHunk": "@@ -32,50 +28,48 @@ public WorldBorderModule(List<WorldBorder> borders) {\n   }\n \n   @Override\n-  public void loadTags(Set<MapTag> tags) {\n-    tags.add(WORLDBORDER_TAG);\n-  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NjQ5NjMwOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/listeners/MotdListener.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMDoyMDoyMVrOFiQOnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxOTowMzoxNVrOFiw5UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2MTc5MQ==", "bodyText": "Is this assuming a map if a next map is missing?\nNext map not being defined is completely normal (for example, on voted pools) and shouldn't be avoided or treated like an error.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r371461791", "createdAt": "2020-01-27T20:20:21Z", "author": {"login": "Pablete1234"}, "path": "src/main/java/tc/oc/pgm/listeners/MotdListener.java", "diffHunk": "@@ -31,7 +31,9 @@ public MotdListener() {\n     this.format = Config.Motd.format();\n \n     // Ensure there are always default keys\n-    final MapInfo map = PGM.get().getMapOrder().getNextMap();\n+    MapInfo map = PGM.get().getMapOrder().getNextMap();\n+    if (map == null) map = PGM.get().getMapLibrary().getMaps().next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3d3f979d271a5e4d5d4542cc9e6372615a71717"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkzMjk0Mg==", "bodyText": "If we don't know what the true next map will be, what should the motd say? > PGM < ?", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r371932942", "createdAt": "2020-01-28T17:00:45Z", "author": {"login": "Electroid"}, "path": "src/main/java/tc/oc/pgm/listeners/MotdListener.java", "diffHunk": "@@ -31,7 +31,9 @@ public MotdListener() {\n     this.format = Config.Motd.format();\n \n     // Ensure there are always default keys\n-    final MapInfo map = PGM.get().getMapOrder().getNextMap();\n+    MapInfo map = PGM.get().getMapOrder().getNextMap();\n+    if (map == null) map = PGM.get().getMapLibrary().getMaps().next();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2MTc5MQ=="}, "originalCommit": {"oid": "a3d3f979d271a5e4d5d4542cc9e6372615a71717"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk5NzAwOA==", "bodyText": "Either the current map, or something else like Deciding next map, PGM, or whatever other placeholder", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r371997008", "createdAt": "2020-01-28T19:03:15Z", "author": {"login": "Pablete1234"}, "path": "src/main/java/tc/oc/pgm/listeners/MotdListener.java", "diffHunk": "@@ -31,7 +31,9 @@ public MotdListener() {\n     this.format = Config.Motd.format();\n \n     // Ensure there are always default keys\n-    final MapInfo map = PGM.get().getMapOrder().getNextMap();\n+    MapInfo map = PGM.get().getMapOrder().getNextMap();\n+    if (map == null) map = PGM.get().getMapLibrary().getMaps().next();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2MTc5MQ=="}, "originalCommit": {"oid": "a3d3f979d271a5e4d5d4542cc9e6372615a71717"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NjU5NTYyOnYy", "diffSide": "RIGHT", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMDo1NTo1NVrOFiRLxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QyMDo1NTo1NVrOFiRLxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ3NzQ0NA==", "bodyText": "should probably just use:\n        final Map<Boolean, Set<String>> tagSet = Stream.of(tags.split(\",\"))\n                .map(String::toLowerCase)\n                .map(String::trim)\n                .collect(Collectors.partitioningBy(s -> s.startsWith(\"!\"),\n                        Collectors.mapping(\n                                (String s) ->  s.startsWith(\"!\") ? s.substring(1) : s,\n                                Collectors.toSet())));\n\nthat does both partitioning and removing the first char, that way you avoid the later transformation on the filter.\nAlso, i don't think linked lists are a good fit, should probably just use hash sets.", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r371477444", "createdAt": "2020-01-27T20:55:55Z", "author": {"login": "Pablete1234"}, "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -62,12 +66,19 @@ public static void maplist(\n       throws CommandException {\n     Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n     if (tags != null) {\n-      final Set<String> tagSet =\n+      final Map<Boolean, List<String>> tagSet =\n           Stream.of(tags.split(\",\"))\n               .map(String::toLowerCase)\n               .map(String::trim)\n-              .collect(Collectors.toSet());\n-      search = search.filter(map -> matchesTags(map, tagSet));\n+              .collect(Collectors.partitioningBy(s -> s.startsWith(\"!\")));\n+      search =\n+          search.filter(\n+              map ->\n+                  matchesTags(\n+                      map,\n+                      tagSet.getOrDefault(false, new LinkedList<>()),\n+                      Collections2.transform(\n+                          tagSet.getOrDefault(true, new LinkedList<>()), s -> s.substring(1))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40753435ea04caad64af2fede440d6d4c7f4e4eb"}, "originalPosition": 33}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1107, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}