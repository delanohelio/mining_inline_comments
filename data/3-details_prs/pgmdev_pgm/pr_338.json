{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwODgyODA0", "number": 338, "title": "Match Stats", "bodyText": "Match Stats\nHello!\nThis PR includes a feature of tracking some stats temporarily, and some different ways to display them:\nOn a MatchPlayerDeathEvent the players involved will both get a temporary message pop up over the hotbar:\n\nWith the command /stats these same numbers appear in chat:\n\nAnd at the end of the match, the best stats from all players participating will appear(The stat with the bowshot will only appear if a kill with a bow has been done in the match):\n\nDoes this go into the community module?\nAll feedback appriciated! (Colors, layout, method names..)\n05.03.2020: Updated formatting on end of match stats, and redid the changes into a MatchModule", "createdAt": "2020-02-27T14:25:31Z", "url": "https://github.com/PGMDev/PGM/pull/338", "merged": true, "mergeCommit": {"oid": "4feef237b01753a2f6d1a9fa2ee13fc6b0e94197"}, "closed": true, "closedAt": "2020-03-24T16:35:33Z", "author": {"login": "KingOfSquares"}, "timelineItems": {"totalCount": 45, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIipDCgBqjMwNzk2NjQ0NjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcQ1lswgFqTM4MDQ5MTA5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1d6d3fbf95792dd26383c7fca999c0d390f999d2", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/1d6d3fbf95792dd26383c7fca999c0d390f999d2", "committedDate": "2020-02-27T14:27:15Z", "message": "Remove unneeded abstraction\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}, "afterCommit": {"oid": "94f5e09ac6763ad49f80780f8125dec2cc56da7d", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/94f5e09ac6763ad49f80780f8125dec2cc56da7d", "committedDate": "2020-02-27T20:59:11Z", "message": "Remove unneeded abstraction\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ec983cad3d60b44df89c82933f0d5c349021cb22", "author": {"user": null}, "url": "https://github.com/PGMDev/PGM/commit/ec983cad3d60b44df89c82933f0d5c349021cb22", "committedDate": "2020-03-01T20:52:12Z", "message": "Formatting"}, "afterCommit": {"oid": "6cd5c8972575269d5c170e49c8df6b1f643081d9", "author": {"user": null}, "url": "https://github.com/PGMDev/PGM/commit/6cd5c8972575269d5c170e49c8df6b1f643081d9", "committedDate": "2020-03-01T20:53:51Z", "message": "Formatting\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3Mzg3ODA0", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-367387804", "createdAt": "2020-03-02T17:31:46Z", "commit": {"oid": "ebebc8933429069b766be9196cf0a6b8b24c691e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ebebc8933429069b766be9196cf0a6b8b24c691e", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/ebebc8933429069b766be9196cf0a6b8b24c691e", "committedDate": "2020-03-01T20:57:12Z", "message": "Merge branch 'master' into LocalStats"}, "afterCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/bf2758441dd907ba88439d52dd1ae7e949ec8538", "committedDate": "2020-03-05T19:20:54Z", "message": "Add match stats\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODc5ODU5", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369879859", "createdAt": "2020-03-05T20:11:48Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMTo0OFrOFyiZHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMTo0OFrOFyiZHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjYwNg==", "bodyText": "Why this change?", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388536606", "createdAt": "2020-03-05T20:11:48Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/PGMPlugin.java", "diffHunk": "@@ -40,23 +40,7 @@\n import tc.oc.pgm.api.player.MatchPlayer;\n import tc.oc.pgm.api.setting.SettingKey;\n import tc.oc.pgm.api.setting.SettingValue;\n-import tc.oc.pgm.commands.AdminCommands;\n-import tc.oc.pgm.commands.ClassCommands;\n-import tc.oc.pgm.commands.CycleCommands;\n-import tc.oc.pgm.commands.DestroyableCommands;\n-import tc.oc.pgm.commands.FreeForAllCommands;\n-import tc.oc.pgm.commands.GoalCommands;\n-import tc.oc.pgm.commands.InventoryCommands;\n-import tc.oc.pgm.commands.JoinCommands;\n-import tc.oc.pgm.commands.MapCommands;\n-import tc.oc.pgm.commands.MapPoolCommands;\n-import tc.oc.pgm.commands.MatchCommands;\n-import tc.oc.pgm.commands.ModeCommands;\n-import tc.oc.pgm.commands.ObserverCommands;\n-import tc.oc.pgm.commands.SettingCommands;\n-import tc.oc.pgm.commands.StartCommands;\n-import tc.oc.pgm.commands.TeamCommands;\n-import tc.oc.pgm.commands.TimeLimitCommands;\n+import tc.oc.pgm.commands.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODc5OTY1", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369879965", "createdAt": "2020-03-05T20:12:00Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMjowMFrOFyiZnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMjowMFrOFyiZnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjczNQ==", "bodyText": "Why this change?", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388536735", "createdAt": "2020-03-05T20:12:00Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/api/Modules.java", "diffHunk": "@@ -56,33 +56,7 @@\n import tc.oc.pgm.kits.KitModule;\n import tc.oc.pgm.modes.ObjectiveModesMatchModule;\n import tc.oc.pgm.modes.ObjectiveModesModule;\n-import tc.oc.pgm.modules.ArrowRemovalMatchModule;\n-import tc.oc.pgm.modules.DiscardPotionBottlesMatchModule;\n-import tc.oc.pgm.modules.DiscardPotionBottlesModule;\n-import tc.oc.pgm.modules.EventFilterMatchModule;\n-import tc.oc.pgm.modules.FriendlyFireRefundMatchModule;\n-import tc.oc.pgm.modules.FriendlyFireRefundModule;\n-import tc.oc.pgm.modules.InternalMatchModule;\n-import tc.oc.pgm.modules.InternalModule;\n-import tc.oc.pgm.modules.ItemDestroyMatchModule;\n-import tc.oc.pgm.modules.ItemDestroyModule;\n-import tc.oc.pgm.modules.ItemKeepMatchModule;\n-import tc.oc.pgm.modules.ItemKeepModule;\n-import tc.oc.pgm.modules.LaneMatchModule;\n-import tc.oc.pgm.modules.LaneModule;\n-import tc.oc.pgm.modules.MaxBuildHeightMatchModule;\n-import tc.oc.pgm.modules.MaxBuildHeightModule;\n-import tc.oc.pgm.modules.MobsMatchModule;\n-import tc.oc.pgm.modules.MobsModule;\n-import tc.oc.pgm.modules.ModifyBowProjectileMatchModule;\n-import tc.oc.pgm.modules.ModifyBowProjectileModule;\n-import tc.oc.pgm.modules.MultiTradeMatchModule;\n-import tc.oc.pgm.modules.PlayableRegionMatchModule;\n-import tc.oc.pgm.modules.PlayableRegionModule;\n-import tc.oc.pgm.modules.SoundsMatchModule;\n-import tc.oc.pgm.modules.TimeLockModule;\n-import tc.oc.pgm.modules.ToolRepairMatchModule;\n-import tc.oc.pgm.modules.ToolRepairModule;\n+import tc.oc.pgm.modules.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODgwMTYy", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369880162", "createdAt": "2020-03-05T20:12:20Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMjoyMVrOFyiaOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMjoyMVrOFyiaOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjg5MA==", "bodyText": "Should be placed inside the translations file.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388536890", "createdAt": "2020-03-05T20:12:21Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/commands/StatCommands.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package tc.oc.pgm.commands;\n+\n+import app.ashcon.intake.Command;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.command.CommandSender;\n+import tc.oc.pgm.modules.StatsMatchModule;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+\n+public class StatCommands {\n+\n+  @Command(\n+      aliases = {\"stats\"},\n+      desc = \"Shows your stats for this match\")\n+  public static void checkStats(CommandSender sender) {\n+    sender.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_GREEN + \"Current stats\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODgwMzAz", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369880303", "createdAt": "2020-03-05T20:12:34Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMjozNFrOFyialQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMjozNFrOFyialQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjk4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static class playerStats {\n          \n          \n            \n              public static class PlayerStats {", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388536981", "createdAt": "2020-03-05T20:12:34Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODgwODIx", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369880821", "createdAt": "2020-03-05T20:13:25Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMzoyNVrOFyicjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMzoyNVrOFyicjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNzQ4NQ==", "bodyText": "You don't have to define zeros in each :P Keep it simple :P", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388537485", "createdAt": "2020-03-05T20:13:25Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODgxMTg1", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369881185", "createdAt": "2020-03-05T20:14:04Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxNDowNFrOFyidxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxNDowNFrOFyidxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNzc5Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  String KD;\n          \n          \n            \n                  String kd;", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388537796", "createdAt": "2020-03-05T20:14:04Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODgyMTQ5", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369882149", "createdAt": "2020-03-05T20:15:35Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxNTozNlrOFyigtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxNTozNlrOFyigtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzODU1MA==", "bodyText": "Can we change it to a constant in this class? Also, call it decimalFormat because df is very cryptic.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388538550", "createdAt": "2020-03-05T20:15:36Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODgyNjk1", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369882695", "createdAt": "2020-03-05T20:16:30Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxNjozMFrOFyiihQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxNjozMFrOFyiihQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw==", "bodyText": "Please make it private.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388539013", "createdAt": "2020-03-05T20:16:30Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODgzMjU1", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369883255", "createdAt": "2020-03-05T20:17:25Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxNzoyNVrOFyikPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxNzoyNVrOFyikPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTQ1Mw==", "bodyText": "You shouldn't be catching NPEs :D If something returns null please check it with the if statements", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388539453", "createdAt": "2020-03-05T20:17:25Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 96}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODg0NDkx", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369884491", "createdAt": "2020-03-05T20:19:23Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxOToyNFrOFyipCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxOToyNFrOFyipCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MDY4MA==", "bodyText": "I see your are using murderer.getBukkit().getName() and event.getVictim().getBukkit().getName() in this method. Can you make local variables in this method to make the code cleaner?", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388540680", "createdAt": "2020-03-05T20:19:24Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODg0OTIz", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369884923", "createdAt": "2020-03-05T20:20:08Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoyMDowOFrOFyiqmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoyMDowOFrOFyiqmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MTA4MA==", "bodyText": "You should change the name and display name to local variables here too.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388541080", "createdAt": "2020-03-05T20:20:08Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 159}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODg1NTA1", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369885505", "createdAt": "2020-03-05T20:21:03Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoyMTowM1rOFyiskg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoyMTowM1rOFyiskg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MTU4Ng==", "bodyText": "Missing newline character.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388541586", "createdAt": "2020-03-05T20:21:03Z", "author": {"login": "TheMolkaPL"}, "path": "util-bukkit/src/main/i18n/templates/strings.properties", "diffHunk": "@@ -944,3 +944,13 @@ moderation.reports.hover = Reported by {0}\n # {0} = IP address\n moderation.commands.banIP = The IP address ({0}) has been banned.\n moderation.commands.invalidIP = {0} is not a valid IP address.\n+\n+# {X} = The number of the relevant stat\n+stats.basic = Kills: {0}(Killstreak: {1}), Deaths: {2}, K/D: {3}\n+\n+# {0} = Username\n+# {1} = The number of the relevant stat\n+stats.kills = Kills: {0} : {1}\n+stats.killstreak = Killstreak: {0} : {1}\n+stats.deaths = Deaths: {0} : {1}\n+stats.bowshot = Longest bowshot: {0} : {1} block(s)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5ODg2MTIx", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369886121", "createdAt": "2020-03-05T20:22:00Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoyMjowMVrOFyivfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoyMjowMVrOFyivfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MjMzMw==", "bodyText": "I think we should make a class representing Map.Entry<String, Integer> topResult.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388542333", "createdAt": "2020-03-05T20:22:01Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);\n+    }\n+    Component killMessage = getKillsMessage(sortStats(allKills));\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks));\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths));\n+    Map.Entry<String, Integer> bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW + \"Best stats this match\",\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.getValue()\n+          != 0) { // Prevent this from showing if bows are not used on the map played\n+        viewer.sendMessage(bowshotMessage);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {\n+    Object[] a = map.entrySet().toArray();\n+    Arrays.sort(\n+        a,\n+        (Comparator)\n+            (o1, o2) ->\n+                ((Map.Entry<String, Integer>) o2)\n+                    .getValue()\n+                    .compareTo(((Map.Entry<String, Integer>) o1).getValue()));\n+    return (Map.Entry<String, Integer>) a[0];\n+  }\n+\n+  Component getKillsMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.kills\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getKillstreakMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.killstreak\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getDeathsMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.deaths\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.RED))\n+            .render());\n+  }\n+\n+  Component getBowshotMessage(Map.Entry<String, Integer> topResult) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 225}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTI3ODUy", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369927852", "createdAt": "2020-03-05T21:29:01Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMToyOTowMVrOFyk02g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMToyOTowMVrOFyk02g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NjQ3NA==", "bodyText": "Make this a repeating task, send the message for a second or so or else it fades away too quick", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388576474", "createdAt": "2020-03-05T21:29:01Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTI4NDEw", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369928410", "createdAt": "2020-03-05T21:29:50Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMToyOTo1MVrOFyk2bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMToyOTo1MVrOFyk2bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3Njg3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                HashMap<String, Integer> allKills = new HashMap<>();\n          \n          \n            \n                HashMap<String, Integer> allKillstreaks = new HashMap<>();\n          \n          \n            \n                HashMap<String, Integer> allDeaths = new HashMap<>();\n          \n          \n            \n                HashMap<String, Integer> allBowshots = new HashMap<>();\n          \n          \n            \n                Map<String, Integer> allKills = new HashMap<>();\n          \n          \n            \n                Map<String, Integer> allKillstreaks = new HashMap<>();\n          \n          \n            \n                Map<String, Integer> allDeaths = new HashMap<>();\n          \n          \n            \n                Map<String, Integer> allBowshots = new HashMap<>();", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388576879", "createdAt": "2020-03-05T21:29:51Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 146}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTI4NjI1", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369928625", "createdAt": "2020-03-05T21:30:09Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTozMDowOVrOFyk3KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTozMDowOVrOFyk3KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NzA2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {\n          \n          \n            \n              private Map.Entry<String, Integer> sortStats(Map<String, Integer> map) {", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388577065", "createdAt": "2020-03-05T21:30:09Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);\n+    }\n+    Component killMessage = getKillsMessage(sortStats(allKills));\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks));\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths));\n+    Map.Entry<String, Integer> bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW + \"Best stats this match\",\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.getValue()\n+          != 0) { // Prevent this from showing if bows are not used on the map played\n+        viewer.sendMessage(bowshotMessage);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 186}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTI5NjIw", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-369929620", "createdAt": "2020-03-05T21:31:49Z", "commit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTozMTo0OVrOFyk6Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTozMTo0OVrOFyk6Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3Nzg5NQ==", "bodyText": "Something along the lines of:\nreturn map.entrySet().stream()\n  .max(Comparator.comparingInt(Map.Entry::getValue))\n  .orElse(null);", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388577895", "createdAt": "2020-03-05T21:31:49Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);\n+    }\n+    Component killMessage = getKillsMessage(sortStats(allKills));\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks));\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths));\n+    Map.Entry<String, Integer> bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW + \"Best stats this match\",\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.getValue()\n+          != 0) { // Prevent this from showing if bows are not used on the map played\n+        viewer.sendMessage(bowshotMessage);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {\n+    Object[] a = map.entrySet().toArray();\n+    Arrays.sort(\n+        a,\n+        (Comparator)\n+            (o1, o2) ->\n+                ((Map.Entry<String, Integer>) o2)\n+                    .getValue()\n+                    .compareTo(((Map.Entry<String, Integer>) o1).getValue()));\n+    return (Map.Entry<String, Integer>) a[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 195}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwODcyMzMz", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-370872333", "createdAt": "2020-03-09T00:36:03Z", "commit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMDozNjowM1rOFzYiVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMDozNjoyM1rOFzYibg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQyMzcwMg==", "bodyText": "I\u2019m curious why you chose to call this directly instead of\nfinalMurderer.sendHotbarMessage(finalMurdererStats.getBasicStatsMessage())?\nThe MatchPlayer#sendHotbarMessage method calls NMSHacks anyway, so it may be a little more consistent if you like.\nBesides that, great job! This will be awesome once merged \ud83d\ude04", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389423702", "createdAt": "2020-03-09T00:36:03Z", "author": {"login": "applenick"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    if (event.getKiller() != null) {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    }\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (victimStats == null) {\n+      allPlayerStats.put(victimUUID, new PlayerStats());\n+      victimStats = allPlayerStats.get(victimUUID);\n+    }\n+\n+    victimStats.onDeath();\n+\n+    PlayerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    int victimTaskId =\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  NMSHacks.sendHotbarMessage(\n+                      victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+                })\n+            .getTaskId();\n+\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            70,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(victimTaskId);\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murdererUUID, new PlayerStats());\n+        murdererStats = allPlayerStats.get(murdererUUID);\n+      }\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+\n+        murdererStats.onMurder();\n+\n+        MatchPlayer finalMurderer = murderer;\n+        PlayerStats finalMurdererStats = murdererStats;\n+        int murdererTaskId =\n+            event\n+                .getMatch()\n+                .getScheduler(MatchScope.LOADED)\n+                .runTaskTimer(\n+                    0,\n+                    5,\n+                    () -> {\n+                      NMSHacks.sendHotbarMessage(\n+                          finalMurderer.getBukkit(), finalMurdererStats.getBasicStatsMessage());\n+                    })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQyMzcyNg==", "bodyText": "See other comment about this.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389423726", "createdAt": "2020-03-09T00:36:23Z", "author": {"login": "applenick"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    if (event.getKiller() != null) {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    }\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (victimStats == null) {\n+      allPlayerStats.put(victimUUID, new PlayerStats());\n+      victimStats = allPlayerStats.get(victimUUID);\n+    }\n+\n+    victimStats.onDeath();\n+\n+    PlayerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    int victimTaskId =\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  NMSHacks.sendHotbarMessage(\n+                      victim.getBukkit(), finalVictimStats.getBasicStatsMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwODgyMjI2", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-370882226", "createdAt": "2020-03-09T01:47:45Z", "commit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMTo0Nzo0NVrOFzZEpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMTo0Nzo0NVrOFzZEpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjQ4NA==", "bodyText": "Why are you doing this that complicated way? :P You can cast numbers between datatypes.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389432484", "createdAt": "2020-03-09T01:47:45Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwODgyMjQ3", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-370882247", "createdAt": "2020-03-09T01:47:53Z", "commit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMTo0Nzo1M1rOFzZEtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMTo0Nzo1M1rOFzZEtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjUwMQ==", "bodyText": "Can be final", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389432501", "createdAt": "2020-03-09T01:47:53Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwODgyMzU3", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-370882357", "createdAt": "2020-03-09T01:48:27Z", "commit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMTo0ODoyN1rOFzZE_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMTo0ODoyN1rOFzZE_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjU3NQ==", "bodyText": "This is defining static context from the instance context.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389432575", "createdAt": "2020-03-09T01:48:27Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 91}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwODgyNjg1", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-370882685", "createdAt": "2020-03-09T01:50:19Z", "commit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMTo1MDoxOVrOFzZGKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMTo1MDoxOVrOFzZGKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjg3Mw==", "bodyText": "This method seems to be very long. Could you try to slice it into smaller ones? Would make it easier to read.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389432873", "createdAt": "2020-03-09T01:50:19Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    if (event.getKiller() != null) {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    }\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (victimStats == null) {\n+      allPlayerStats.put(victimUUID, new PlayerStats());\n+      victimStats = allPlayerStats.get(victimUUID);\n+    }\n+\n+    victimStats.onDeath();\n+\n+    PlayerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    int victimTaskId =\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  NMSHacks.sendHotbarMessage(\n+                      victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+                })\n+            .getTaskId();\n+\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            70,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(victimTaskId);\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murdererUUID, new PlayerStats());\n+        murdererStats = allPlayerStats.get(murdererUUID);\n+      }\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+\n+        murdererStats.onMurder();\n+\n+        MatchPlayer finalMurderer = murderer;\n+        PlayerStats finalMurdererStats = murdererStats;\n+        int murdererTaskId =\n+            event\n+                .getMatch()\n+                .getScheduler(MatchScope.LOADED)\n+                .runTaskTimer(\n+                    0,\n+                    5,\n+                    () -> {\n+                      NMSHacks.sendHotbarMessage(\n+                          finalMurderer.getBukkit(), finalMurdererStats.getBasicStatsMessage());\n+                    })\n+                .getTaskId();\n+\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskLater(\n+                70,\n+                () -> {\n+                  Bukkit.getScheduler().cancelTask(murdererTaskId);\n+                });\n+      }\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 181}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwODg0MjQ5", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-370884249", "createdAt": "2020-03-09T01:58:59Z", "commit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMTo1ODo1OVrOFzZLVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMTo1ODo1OVrOFzZLVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzNDE5OQ==", "bodyText": "These methods are actually the same. The only difference seems to be translation keys and colors. To keep this DRY we could try make a generic method with these as parameters, and these methods would call it.\nComponent getBowshotMessage(TopResult topResult, Match match) {\n  return getMessage(\"stats.bowshot\", topResult, match, ChatColor.YELLOW);\n}\n\nComponent getMessage(String messageKey, TopResult topResult, Match match, CharColor color) {\n  return new Component(\n      new PersonalizedTranslatable(\n              messageKey,\n              playerName(match, topResult.uuid),\n              new PersonalizedText(Integer.toString(topResult.stat), color))\n          .render());\n}", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389434199", "createdAt": "2020-03-09T01:58:59Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    if (event.getKiller() != null) {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    }\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (victimStats == null) {\n+      allPlayerStats.put(victimUUID, new PlayerStats());\n+      victimStats = allPlayerStats.get(victimUUID);\n+    }\n+\n+    victimStats.onDeath();\n+\n+    PlayerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    int victimTaskId =\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  NMSHacks.sendHotbarMessage(\n+                      victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+                })\n+            .getTaskId();\n+\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            70,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(victimTaskId);\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murdererUUID, new PlayerStats());\n+        murdererStats = allPlayerStats.get(murdererUUID);\n+      }\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+\n+        murdererStats.onMurder();\n+\n+        MatchPlayer finalMurderer = murderer;\n+        PlayerStats finalMurdererStats = murdererStats;\n+        int murdererTaskId =\n+            event\n+                .getMatch()\n+                .getScheduler(MatchScope.LOADED)\n+                .runTaskTimer(\n+                    0,\n+                    5,\n+                    () -> {\n+                      NMSHacks.sendHotbarMessage(\n+                          finalMurderer.getBukkit(), finalMurdererStats.getBasicStatsMessage());\n+                    })\n+                .getTaskId();\n+\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskLater(\n+                70,\n+                () -> {\n+                  Bukkit.getScheduler().cancelTask(murdererTaskId);\n+                });\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (allPlayerStats.get(playerUUID) == null) {\n+        allPlayerStats.put(playerUUID, new PlayerStats());\n+      }\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getKillsMessage(sortStats(allKills), match);\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks), match);\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths), match);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot, match);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0)\n+        viewer.sendMessage(bowshotMessage); // Prevent from showing if bows are not used\n+    }\n+  }\n+\n+  private static class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }\n+    topResult.uuid = mapEntry.getKey();\n+    topResult.stat = mapEntry.getValue();\n+    return topResult;\n+  }\n+\n+  Component getKillsMessage(TopResult topResult, Match match) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.kills\",\n+                playerName(match, topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getKillstreakMessage(TopResult topResult, Match match) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.killstreak\",\n+                playerName(match, topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getDeathsMessage(TopResult topResult, Match match) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.deaths\",\n+                playerName(match, topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), ChatColor.RED))\n+            .render());\n+  }\n+\n+  Component getBowshotMessage(TopResult topResult, Match match) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.bowshot\",\n+                playerName(match, topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), ChatColor.YELLOW))\n+            .render());\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 282}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0NDk5NjU4", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-374499658", "createdAt": "2020-03-13T17:49:45Z", "commit": {"oid": "604cd9fc475b6aef61c769009ed0e19bb67c35bb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzo0OTo0NVrOF2NFDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzo1NzoyMVrOF2NT5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4MTcxMQ==", "bodyText": "May want to make this private final Match match;", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r392381711", "createdAt": "2020-03-13T17:49:45Z", "author": {"login": "applenick"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -35,10 +34,17 @@\n \n     @Override\n     public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n-      return new StatsMatchModule();\n+      return new StatsMatchModule(match);\n     }\n   }\n \n+  Match match;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "604cd9fc475b6aef61c769009ed0e19bb67c35bb"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4NTUwOQ==", "bodyText": "This should be something along the lines of hasNoStats or at the very least playerStatsDoesNotExist. Gotta remember camel case \ud83d\udc2b", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r392385509", "createdAt": "2020-03-13T17:57:21Z", "author": {"login": "applenick"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  Match match;\n+  private static final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (PlayerStatsDoesNotExist(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (PlayerStatsDoesNotExist(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (PlayerStatsDoesNotExist(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private static class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }\n+\n+    topResult.uuid = mapEntry.getKey();\n+    topResult.stat = mapEntry.getValue();\n+\n+    return topResult;\n+  }\n+\n+  private void sendLongHotbarMessage(MatchPlayer player, Component message) {\n+    int taskId =\n+        match\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  player.sendHotbarMessage(message);\n+                })\n+            .getTaskId();\n+\n+    match\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            20 * 4,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(taskId);\n+            });\n+  }\n+\n+  Component getMessage(String messageKey, TopResult topResult, ChatColor color) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                messageKey,\n+                playerName(topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), color).render())\n+            .render());\n+  }\n+\n+  private PersonalizedText playerName(UUID playerUUID) {\n+    if (Bukkit.getPlayer(playerUUID) == null) {\n+      if (Bukkit.getOfflinePlayer(playerUUID).getName() == null) {\n+        return new PersonalizedText(\"Noone\", ChatColor.MAGIC, ChatColor.BLACK);\n+      }\n+      return new PersonalizedText(\n+          Bukkit.getOfflinePlayer(playerUUID).getName(), ChatColor.DARK_AQUA);\n+    }\n+    return new PersonalizedText(match.getPlayer(playerUUID).getBukkit().getDisplayName());\n+  }\n+\n+  public static boolean PlayerStatsDoesNotExist(UUID player) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "604cd9fc475b6aef61c769009ed0e19bb67c35bb"}, "originalPosition": 237}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c9e15c08eefad2ee6ff3897162a8e237220ae414", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/c9e15c08eefad2ee6ff3897162a8e237220ae414", "committedDate": "2020-03-19T12:04:27Z", "message": "Match is now final, method name fix\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}, "afterCommit": {"oid": "d836d0ac23ea8b041197a3efdf815397bfe9f196", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/d836d0ac23ea8b041197a3efdf815397bfe9f196", "committedDate": "2020-03-19T12:07:57Z", "message": "Match is now final, method name fix\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczNjY2MjY3", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-373666267", "createdAt": "2020-03-12T15:35:33Z", "commit": {"oid": "94883a4d75940b41d27168ac71873438a8396979"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNTozNTozNFrOF1j1XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNjoyMzo0NFrOF5wx8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNTk0OA==", "bodyText": "StatsCommands", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r391705948", "createdAt": "2020-03-12T15:35:34Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/PGMPlugin.java", "diffHunk": "@@ -320,6 +321,7 @@ private void registerCommands() {\n     node.registerCommands(new SettingCommands());\n     node.registerCommands(new ObserverCommands());\n     node.registerCommands(new MapPoolCommands());\n+    node.registerCommands(new StatCommands());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94883a4d75940b41d27168ac71873438a8396979"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNjgyNQ==", "bodyText": "MatchModules should not store player data in static variables. Remove the static.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r391706825", "createdAt": "2020-03-12T15:36:51Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package tc.oc.pgm.modules;\n+\n+import java.math.BigDecimal;\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (new BigDecimal(distance).compareTo(new BigDecimal(longestBowKill)) > 0) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94883a4d75940b41d27168ac71873438a8396979"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNzE1NQ==", "bodyText": "In Java, methods should start with a lower case letter.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r391707155", "createdAt": "2020-03-12T15:37:23Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package tc.oc.pgm.modules;\n+\n+import java.math.BigDecimal;\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (new BigDecimal(distance).compareTo(new BigDecimal(longestBowKill)) > 0) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    Match match = event.getMatch();\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (PlayerStatsDoesNotExist(victimUUID)) victimStats = putNewPlayer(victimUUID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94883a4d75940b41d27168ac71873438a8396979"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTM2NA==", "bodyText": "You don't need this. In Modules.java you can put instead:\nregister(StatsMatchModule.class, StatsMatchModule::new);", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396111364", "createdAt": "2020-03-22T16:15:12Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTYwNQ==", "bodyText": "To avoid the possibility of a 0 bow kill:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    longestBowKill = (int) distance;\n          \n          \n            \n                    longestBowKill = (int) Math.ceil(distance);", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396111605", "createdAt": "2020-03-22T16:17:31Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTg0NQ==", "bodyText": "You don't need this null check, these maps will never be null.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396111845", "createdAt": "2020-03-22T16:19:40Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTkwMA==", "bodyText": "You don't need this class.\nJust use Map.Entry<UUID, Integer>", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396111900", "createdAt": "2020-03-22T16:20:21Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMjE0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            () -> {\n          \n          \n            \n                              player.sendHotbarMessage(message);\n          \n          \n            \n                            })\n          \n          \n            \n                            () -> player.sendHotbarMessage(message));", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396112145", "createdAt": "2020-03-22T16:22:20Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }\n+\n+    topResult.uuid = mapEntry.getKey();\n+    topResult.stat = mapEntry.getValue();\n+\n+    return topResult;\n+  }\n+\n+  private void sendLongHotbarMessage(MatchPlayer player, Component message) {\n+    int taskId =\n+        match\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  player.sendHotbarMessage(message);\n+                })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMjI0Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        () -> {\n          \n          \n            \n                          Bukkit.getScheduler().cancelTask(taskId);\n          \n          \n            \n                        });\n          \n          \n            \n                        () -> Bukkit.getScheduler().cancelTask(taskId));", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396112242", "createdAt": "2020-03-22T16:23:00Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }\n+\n+    topResult.uuid = mapEntry.getKey();\n+    topResult.stat = mapEntry.getValue();\n+\n+    return topResult;\n+  }\n+\n+  private void sendLongHotbarMessage(MatchPlayer player, Component message) {\n+    int taskId =\n+        match\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  player.sendHotbarMessage(message);\n+                })\n+            .getTaskId();\n+\n+    match\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            20 * 4,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(taskId);\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMjM2OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new PersonalizedText(\"Noone\", ChatColor.MAGIC, ChatColor.BLACK);\n          \n          \n            \n                    return new PersonalizedText(\"Unknown\", ChatColor.MAGIC, ChatColor.BLACK);", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396112369", "createdAt": "2020-03-22T16:23:44Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }\n+\n+    topResult.uuid = mapEntry.getKey();\n+    topResult.stat = mapEntry.getValue();\n+\n+    return topResult;\n+  }\n+\n+  private void sendLongHotbarMessage(MatchPlayer player, Component message) {\n+    int taskId =\n+        match\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  player.sendHotbarMessage(message);\n+                })\n+            .getTaskId();\n+\n+    match\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            20 * 4,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(taskId);\n+            });\n+  }\n+\n+  Component getMessage(String messageKey, TopResult topResult, ChatColor color) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                messageKey,\n+                playerName(topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), color).render())\n+            .render());\n+  }\n+\n+  private PersonalizedText playerName(UUID playerUUID) {\n+    if (Bukkit.getPlayer(playerUUID) == null) {\n+      if (Bukkit.getOfflinePlayer(playerUUID).getName() == null) {\n+        return new PersonalizedText(\"Noone\", ChatColor.MAGIC, ChatColor.BLACK);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 229}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f68661aa4a2d1f052fe298a43613427cb037d849", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/f68661aa4a2d1f052fe298a43613427cb037d849", "committedDate": "2020-03-23T17:09:07Z", "message": "Add a toggle for tracking stats.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}, "afterCommit": {"oid": "6265d25fda39abe4ac4b3e601f35f43a5d44dc02", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/6265d25fda39abe4ac4b3e601f35f43a5d44dc02", "committedDate": "2020-03-23T17:11:37Z", "message": "Add a toggle for tracking stats.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6265d25fda39abe4ac4b3e601f35f43a5d44dc02", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/6265d25fda39abe4ac4b3e601f35f43a5d44dc02", "committedDate": "2020-03-23T17:11:37Z", "message": "Add a toggle for tracking stats.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}, "afterCommit": {"oid": "0cbc316af51261e666f21f439048129a5b606b38", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/0cbc316af51261e666f21f439048129a5b606b38", "committedDate": "2020-03-23T19:56:10Z", "message": "Add a toggle for tracking stats.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5OTAzOTU5", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-379903959", "createdAt": "2020-03-23T23:31:15Z", "commit": {"oid": "0cbc316af51261e666f21f439048129a5b606b38"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "724c6cd68d642c21ec088edae06aeb07fb2c24c7", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/724c6cd68d642c21ec088edae06aeb07fb2c24c7", "committedDate": "2020-03-23T23:40:59Z", "message": "Add match stats\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5dd7341a8f552b2c766f7a8396be7d6fc773d1f", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/c5dd7341a8f552b2c766f7a8396be7d6fc773d1f", "committedDate": "2020-03-23T23:40:59Z", "message": "Move all strings into translations, persist UUIDs instead of player names, changed logic so that if an offline player wins there will be no NPE, removed wildcard imports, simplify some definitions, clean up naming of some variables, enchance the sorting, and some more.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17499279dc816c68cf7e1bec9af285b5246ccde4", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/17499279dc816c68cf7e1bec9af285b5246ccde4", "committedDate": "2020-03-23T23:40:59Z", "message": "Now calls sendHotbarMessage directly from the MatchPlayer, changed comparing of doubles to use BigDecimal comparing, sliced up the long onPlayerDeath method into a more readable version, simplified the construction of some stat messages, and some more smaller things.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bc9f2c57616a16716ad011fd47265021022342f", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/2bc9f2c57616a16716ad011fd47265021022342f", "committedDate": "2020-03-23T23:40:59Z", "message": "Revert BigDecimals, clean up refrences to Match, tweaked the bowshot message\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90ffe44f7f06f2c53bc7fec77fda175a2a1fce70", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/90ffe44f7f06f2c53bc7fec77fda175a2a1fce70", "committedDate": "2020-03-23T23:40:59Z", "message": "Match is now final, method name fix\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00542f0d1302ce9f3f282d2c180fb10e47005ba2", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/00542f0d1302ce9f3f282d2c180fb10e47005ba2", "committedDate": "2020-03-23T23:40:59Z", "message": "Remove non needed static defenitions\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19d143d74bf14b534864b1e3ae9364a632f827d6", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/19d143d74bf14b534864b1e3ae9364a632f827d6", "committedDate": "2020-03-23T23:40:59Z", "message": "Clean up formatting, remove unnecessary abstractions and code.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3535c808e480d0e1776bda9eb41cc51bb2fba228", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/3535c808e480d0e1776bda9eb41cc51bb2fba228", "committedDate": "2020-03-23T23:40:59Z", "message": "Remove redundant imports.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f74daa133d7e336f880cca941215e023d284bc85", "author": {"user": {"login": "Electroid", "name": "Ashcon Partovi"}}, "url": "https://github.com/PGMDev/PGM/commit/f74daa133d7e336f880cca941215e023d284bc85", "committedDate": "2020-03-23T23:31:53Z", "message": "Merge branch 'master' into LocalStats"}, "afterCommit": {"oid": "223fee75787b704a1e6cd03c22603bbbe64e1be7", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/223fee75787b704a1e6cd03c22603bbbe64e1be7", "committedDate": "2020-03-23T23:40:59Z", "message": "Add a toggle for tracking stats.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4cf3a52a37f63ac0360dd9a6c17cece529ed654", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/f4cf3a52a37f63ac0360dd9a6c17cece529ed654", "committedDate": "2020-03-24T00:01:53Z", "message": "Add a toggle for tracking stats.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "71493e08254281edac0734d3b3443837b2f7c938", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/71493e08254281edac0734d3b3443837b2f7c938", "committedDate": "2020-03-24T00:00:02Z", "message": "Fix wrong import.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}, "afterCommit": {"oid": "f4cf3a52a37f63ac0360dd9a6c17cece529ed654", "author": {"user": {"login": "KingOfSquares", "name": null}}, "url": "https://github.com/PGMDev/PGM/commit/f4cf3a52a37f63ac0360dd9a6c17cece529ed654", "committedDate": "2020-03-24T00:01:53Z", "message": "Add a toggle for tracking stats.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNDkxMDky", "url": "https://github.com/PGMDev/PGM/pull/338#pullrequestreview-380491092", "createdAt": "2020-03-24T16:35:01Z", "commit": {"oid": "f4cf3a52a37f63ac0360dd9a6c17cece529ed654"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 593, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}