{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwODgyODA0", "number": 338, "reviewThreads": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMTo0OFrODlkXTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNjoyMzo0NFrODqK3Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzE5Njk1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/PGMPlugin.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMTo0OFrOFyiZHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QxODoyNTozN1rOFzRG3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjYwNg==", "bodyText": "Why this change?", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388536606", "createdAt": "2020-03-05T20:11:48Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/PGMPlugin.java", "diffHunk": "@@ -40,23 +40,7 @@\n import tc.oc.pgm.api.player.MatchPlayer;\n import tc.oc.pgm.api.setting.SettingKey;\n import tc.oc.pgm.api.setting.SettingValue;\n-import tc.oc.pgm.commands.AdminCommands;\n-import tc.oc.pgm.commands.ClassCommands;\n-import tc.oc.pgm.commands.CycleCommands;\n-import tc.oc.pgm.commands.DestroyableCommands;\n-import tc.oc.pgm.commands.FreeForAllCommands;\n-import tc.oc.pgm.commands.GoalCommands;\n-import tc.oc.pgm.commands.InventoryCommands;\n-import tc.oc.pgm.commands.JoinCommands;\n-import tc.oc.pgm.commands.MapCommands;\n-import tc.oc.pgm.commands.MapPoolCommands;\n-import tc.oc.pgm.commands.MatchCommands;\n-import tc.oc.pgm.commands.ModeCommands;\n-import tc.oc.pgm.commands.ObserverCommands;\n-import tc.oc.pgm.commands.SettingCommands;\n-import tc.oc.pgm.commands.StartCommands;\n-import tc.oc.pgm.commands.TeamCommands;\n-import tc.oc.pgm.commands.TimeLimitCommands;\n+import tc.oc.pgm.commands.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk3NzA0Ng==", "bodyText": "It was either my IDE or Maven formatting, any issues with doing this?", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388977046", "createdAt": "2020-03-06T15:42:16Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/PGMPlugin.java", "diffHunk": "@@ -40,23 +40,7 @@\n import tc.oc.pgm.api.player.MatchPlayer;\n import tc.oc.pgm.api.setting.SettingKey;\n import tc.oc.pgm.api.setting.SettingValue;\n-import tc.oc.pgm.commands.AdminCommands;\n-import tc.oc.pgm.commands.ClassCommands;\n-import tc.oc.pgm.commands.CycleCommands;\n-import tc.oc.pgm.commands.DestroyableCommands;\n-import tc.oc.pgm.commands.FreeForAllCommands;\n-import tc.oc.pgm.commands.GoalCommands;\n-import tc.oc.pgm.commands.InventoryCommands;\n-import tc.oc.pgm.commands.JoinCommands;\n-import tc.oc.pgm.commands.MapCommands;\n-import tc.oc.pgm.commands.MapPoolCommands;\n-import tc.oc.pgm.commands.MatchCommands;\n-import tc.oc.pgm.commands.ModeCommands;\n-import tc.oc.pgm.commands.ObserverCommands;\n-import tc.oc.pgm.commands.SettingCommands;\n-import tc.oc.pgm.commands.StartCommands;\n-import tc.oc.pgm.commands.TeamCommands;\n-import tc.oc.pgm.commands.TimeLimitCommands;\n+import tc.oc.pgm.commands.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjYwNg=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4NjA4Mw==", "bodyText": "It's just unnecessary :P", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389086083", "createdAt": "2020-03-06T19:03:38Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/PGMPlugin.java", "diffHunk": "@@ -40,23 +40,7 @@\n import tc.oc.pgm.api.player.MatchPlayer;\n import tc.oc.pgm.api.setting.SettingKey;\n import tc.oc.pgm.api.setting.SettingValue;\n-import tc.oc.pgm.commands.AdminCommands;\n-import tc.oc.pgm.commands.ClassCommands;\n-import tc.oc.pgm.commands.CycleCommands;\n-import tc.oc.pgm.commands.DestroyableCommands;\n-import tc.oc.pgm.commands.FreeForAllCommands;\n-import tc.oc.pgm.commands.GoalCommands;\n-import tc.oc.pgm.commands.InventoryCommands;\n-import tc.oc.pgm.commands.JoinCommands;\n-import tc.oc.pgm.commands.MapCommands;\n-import tc.oc.pgm.commands.MapPoolCommands;\n-import tc.oc.pgm.commands.MatchCommands;\n-import tc.oc.pgm.commands.ModeCommands;\n-import tc.oc.pgm.commands.ObserverCommands;\n-import tc.oc.pgm.commands.SettingCommands;\n-import tc.oc.pgm.commands.StartCommands;\n-import tc.oc.pgm.commands.TeamCommands;\n-import tc.oc.pgm.commands.TimeLimitCommands;\n+import tc.oc.pgm.commands.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjYwNg=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExOTQ0OQ==", "bodyText": "It looks nicer? I can undo it", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389119449", "createdAt": "2020-03-06T20:08:40Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/PGMPlugin.java", "diffHunk": "@@ -40,23 +40,7 @@\n import tc.oc.pgm.api.player.MatchPlayer;\n import tc.oc.pgm.api.setting.SettingKey;\n import tc.oc.pgm.api.setting.SettingValue;\n-import tc.oc.pgm.commands.AdminCommands;\n-import tc.oc.pgm.commands.ClassCommands;\n-import tc.oc.pgm.commands.CycleCommands;\n-import tc.oc.pgm.commands.DestroyableCommands;\n-import tc.oc.pgm.commands.FreeForAllCommands;\n-import tc.oc.pgm.commands.GoalCommands;\n-import tc.oc.pgm.commands.InventoryCommands;\n-import tc.oc.pgm.commands.JoinCommands;\n-import tc.oc.pgm.commands.MapCommands;\n-import tc.oc.pgm.commands.MapPoolCommands;\n-import tc.oc.pgm.commands.MatchCommands;\n-import tc.oc.pgm.commands.ModeCommands;\n-import tc.oc.pgm.commands.ObserverCommands;\n-import tc.oc.pgm.commands.SettingCommands;\n-import tc.oc.pgm.commands.StartCommands;\n-import tc.oc.pgm.commands.TeamCommands;\n-import tc.oc.pgm.commands.TimeLimitCommands;\n+import tc.oc.pgm.commands.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjYwNg=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI2MjAyMw==", "bodyText": "Do i really have to? I dont see the point of filling up the import list when you are going to register all commands and match modules anyways :p", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389262023", "createdAt": "2020-03-07T15:27:15Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/PGMPlugin.java", "diffHunk": "@@ -40,23 +40,7 @@\n import tc.oc.pgm.api.player.MatchPlayer;\n import tc.oc.pgm.api.setting.SettingKey;\n import tc.oc.pgm.api.setting.SettingValue;\n-import tc.oc.pgm.commands.AdminCommands;\n-import tc.oc.pgm.commands.ClassCommands;\n-import tc.oc.pgm.commands.CycleCommands;\n-import tc.oc.pgm.commands.DestroyableCommands;\n-import tc.oc.pgm.commands.FreeForAllCommands;\n-import tc.oc.pgm.commands.GoalCommands;\n-import tc.oc.pgm.commands.InventoryCommands;\n-import tc.oc.pgm.commands.JoinCommands;\n-import tc.oc.pgm.commands.MapCommands;\n-import tc.oc.pgm.commands.MapPoolCommands;\n-import tc.oc.pgm.commands.MatchCommands;\n-import tc.oc.pgm.commands.ModeCommands;\n-import tc.oc.pgm.commands.ObserverCommands;\n-import tc.oc.pgm.commands.SettingCommands;\n-import tc.oc.pgm.commands.StartCommands;\n-import tc.oc.pgm.commands.TeamCommands;\n-import tc.oc.pgm.commands.TimeLimitCommands;\n+import tc.oc.pgm.commands.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjYwNg=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI4MjIwNQ==", "bodyText": "You don't have to. I'm always trying to keep local code standards and change only what's necessary. :P", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389282205", "createdAt": "2020-03-07T17:13:45Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/PGMPlugin.java", "diffHunk": "@@ -40,23 +40,7 @@\n import tc.oc.pgm.api.player.MatchPlayer;\n import tc.oc.pgm.api.setting.SettingKey;\n import tc.oc.pgm.api.setting.SettingValue;\n-import tc.oc.pgm.commands.AdminCommands;\n-import tc.oc.pgm.commands.ClassCommands;\n-import tc.oc.pgm.commands.CycleCommands;\n-import tc.oc.pgm.commands.DestroyableCommands;\n-import tc.oc.pgm.commands.FreeForAllCommands;\n-import tc.oc.pgm.commands.GoalCommands;\n-import tc.oc.pgm.commands.InventoryCommands;\n-import tc.oc.pgm.commands.JoinCommands;\n-import tc.oc.pgm.commands.MapCommands;\n-import tc.oc.pgm.commands.MapPoolCommands;\n-import tc.oc.pgm.commands.MatchCommands;\n-import tc.oc.pgm.commands.ModeCommands;\n-import tc.oc.pgm.commands.ObserverCommands;\n-import tc.oc.pgm.commands.SettingCommands;\n-import tc.oc.pgm.commands.StartCommands;\n-import tc.oc.pgm.commands.TeamCommands;\n-import tc.oc.pgm.commands.TimeLimitCommands;\n+import tc.oc.pgm.commands.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjYwNg=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMTk4Mw==", "bodyText": "You should avoid wildcard imports, they're bad", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389301983", "createdAt": "2020-03-07T18:25:37Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/PGMPlugin.java", "diffHunk": "@@ -40,23 +40,7 @@\n import tc.oc.pgm.api.player.MatchPlayer;\n import tc.oc.pgm.api.setting.SettingKey;\n import tc.oc.pgm.api.setting.SettingValue;\n-import tc.oc.pgm.commands.AdminCommands;\n-import tc.oc.pgm.commands.ClassCommands;\n-import tc.oc.pgm.commands.CycleCommands;\n-import tc.oc.pgm.commands.DestroyableCommands;\n-import tc.oc.pgm.commands.FreeForAllCommands;\n-import tc.oc.pgm.commands.GoalCommands;\n-import tc.oc.pgm.commands.InventoryCommands;\n-import tc.oc.pgm.commands.JoinCommands;\n-import tc.oc.pgm.commands.MapCommands;\n-import tc.oc.pgm.commands.MapPoolCommands;\n-import tc.oc.pgm.commands.MatchCommands;\n-import tc.oc.pgm.commands.ModeCommands;\n-import tc.oc.pgm.commands.ObserverCommands;\n-import tc.oc.pgm.commands.SettingCommands;\n-import tc.oc.pgm.commands.StartCommands;\n-import tc.oc.pgm.commands.TeamCommands;\n-import tc.oc.pgm.commands.TimeLimitCommands;\n+import tc.oc.pgm.commands.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjYwNg=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzE5Nzg4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/api/Modules.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMjowMFrOFyiZnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMjowMFrOFyiZnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjczNQ==", "bodyText": "Why this change?", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388536735", "createdAt": "2020-03-05T20:12:00Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/api/Modules.java", "diffHunk": "@@ -56,33 +56,7 @@\n import tc.oc.pgm.kits.KitModule;\n import tc.oc.pgm.modes.ObjectiveModesMatchModule;\n import tc.oc.pgm.modes.ObjectiveModesModule;\n-import tc.oc.pgm.modules.ArrowRemovalMatchModule;\n-import tc.oc.pgm.modules.DiscardPotionBottlesMatchModule;\n-import tc.oc.pgm.modules.DiscardPotionBottlesModule;\n-import tc.oc.pgm.modules.EventFilterMatchModule;\n-import tc.oc.pgm.modules.FriendlyFireRefundMatchModule;\n-import tc.oc.pgm.modules.FriendlyFireRefundModule;\n-import tc.oc.pgm.modules.InternalMatchModule;\n-import tc.oc.pgm.modules.InternalModule;\n-import tc.oc.pgm.modules.ItemDestroyMatchModule;\n-import tc.oc.pgm.modules.ItemDestroyModule;\n-import tc.oc.pgm.modules.ItemKeepMatchModule;\n-import tc.oc.pgm.modules.ItemKeepModule;\n-import tc.oc.pgm.modules.LaneMatchModule;\n-import tc.oc.pgm.modules.LaneModule;\n-import tc.oc.pgm.modules.MaxBuildHeightMatchModule;\n-import tc.oc.pgm.modules.MaxBuildHeightModule;\n-import tc.oc.pgm.modules.MobsMatchModule;\n-import tc.oc.pgm.modules.MobsModule;\n-import tc.oc.pgm.modules.ModifyBowProjectileMatchModule;\n-import tc.oc.pgm.modules.ModifyBowProjectileModule;\n-import tc.oc.pgm.modules.MultiTradeMatchModule;\n-import tc.oc.pgm.modules.PlayableRegionMatchModule;\n-import tc.oc.pgm.modules.PlayableRegionModule;\n-import tc.oc.pgm.modules.SoundsMatchModule;\n-import tc.oc.pgm.modules.TimeLockModule;\n-import tc.oc.pgm.modules.ToolRepairMatchModule;\n-import tc.oc.pgm.modules.ToolRepairModule;\n+import tc.oc.pgm.modules.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzE5ODg4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/commands/StatCommands.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMjoyMVrOFyiaOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNTo0Mjo0M1rOFy9SjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjg5MA==", "bodyText": "Should be placed inside the translations file.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388536890", "createdAt": "2020-03-05T20:12:21Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/commands/StatCommands.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package tc.oc.pgm.commands;\n+\n+import app.ashcon.intake.Command;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.command.CommandSender;\n+import tc.oc.pgm.modules.StatsMatchModule;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+\n+public class StatCommands {\n+\n+  @Command(\n+      aliases = {\"stats\"},\n+      desc = \"Shows your stats for this match\")\n+  public static void checkStats(CommandSender sender) {\n+    sender.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_GREEN + \"Current stats\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk3NzI5Mw==", "bodyText": "Of course! Great catch", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388977293", "createdAt": "2020-03-06T15:42:43Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/commands/StatCommands.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package tc.oc.pgm.commands;\n+\n+import app.ashcon.intake.Command;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.command.CommandSender;\n+import tc.oc.pgm.modules.StatsMatchModule;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+\n+public class StatCommands {\n+\n+  @Command(\n+      aliases = {\"stats\"},\n+      desc = \"Shows your stats for this match\")\n+  public static void checkStats(CommandSender sender) {\n+    sender.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_GREEN + \"Current stats\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjg5MA=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzE5OTQ0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMjozNFrOFyialQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMjozNFrOFyialQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjk4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static class playerStats {\n          \n          \n            \n              public static class PlayerStats {", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388536981", "createdAt": "2020-03-05T20:12:34Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzIwMzIyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMzoyNVrOFyicjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxMzoyNVrOFyicjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNzQ4NQ==", "bodyText": "You don't have to define zeros in each :P Keep it simple :P", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388537485", "createdAt": "2020-03-05T20:13:25Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzIwNTExOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxNDowNFrOFyidxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxNDowNFrOFyidxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNzc5Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  String KD;\n          \n          \n            \n                  String kd;", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388537796", "createdAt": "2020-03-05T20:14:04Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzIwOTkxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxNTozNlrOFyigtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQyMDowNDowNFrOFzF2HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzODU1MA==", "bodyText": "Can we change it to a constant in this class? Also, call it decimalFormat because df is very cryptic.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388538550", "createdAt": "2020-03-05T20:15:36Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3Mjk2MQ==", "bodyText": "when you have df.format(number); it being called df isn't very cryptic tbh", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388572961", "createdAt": "2020-03-05T21:21:59Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzODU1MA=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzOTAyNg==", "bodyText": "Can we change it to a constant in this class? Also, call it decimalFormat because df is very cryptic.\n\nWhat do you mean change it to a constant, the K/D variable?", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389039026", "createdAt": "2020-03-06T17:26:22Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzODU1MA=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4NzUyMA==", "bodyText": "Make DecimalFormat a constant so it is not created each time it is used. Look that this is going to parse your input string (#.##) each time to create a new DecimalFormat instance.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389087520", "createdAt": "2020-03-06T19:06:53Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzODU1MA=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExNzQ2OQ==", "bodyText": "Yes of course!", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389117469", "createdAt": "2020-03-06T20:04:04Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzODU1MA=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzIxMjk4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxNjozMFrOFyiihQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QxODoyNDozNVrOFzRGrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw==", "bodyText": "Please make it private.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388539013", "createdAt": "2020-03-05T20:16:30Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTk4NQ==", "bodyText": "Also, I would persist player UUIDs, not player names since UUIDs are unique by definition.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388539985", "createdAt": "2020-03-05T20:18:07Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0MDQ5Mg==", "bodyText": "But when i enter in player#getBukkit#getDisplayName it keeps the colors and everything when displaying the best, does this also work with UUID? I only see a potential error if players use /nick, but it should be prevented to disguise as someone existing anyways.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389040492", "createdAt": "2020-03-06T17:29:10Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0Nzk4OA==", "bodyText": "And why private? It is accessed by StatCommands", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389047988", "createdAt": "2020-03-06T17:43:15Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4ODk3Ng==", "bodyText": "But when i enter in player#getBukkit#getDisplayName it keeps the colors and everything when displaying the best, does this also work with UUID? I only see a potential error if players use /nick, but it should be prevented to disguise as someone existing anyways.\n\nPlayer names are not unique so you shouldn't use them as a key anywhere.\n\nAnd why private? It is accessed by StatCommands\n\nhttps://dzone.com/articles/following-oop-principles-hermetization-in-java", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389088976", "createdAt": "2020-03-06T19:09:59Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4NTg1NA==", "bodyText": "Will this: match#getPlayer(UUID)#getBukkit()#getDisplayName() return null if the player with the given UUID is offline?", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389185854", "createdAt": "2020-03-06T23:04:06Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMjMwNw==", "bodyText": "Yes", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389212307", "createdAt": "2020-03-07T01:19:16Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI0Nzc4Nw==", "bodyText": "Then how would i get the playername of a player that has the best results but is offline?", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389247787", "createdAt": "2020-03-07T11:23:21Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI1NTQ0OA==", "bodyText": "You need to store that in PlayerStats then.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389255448", "createdAt": "2020-03-07T13:41:03Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI2MTg5OA==", "bodyText": "I got it!!", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389261898", "createdAt": "2020-03-07T15:25:35Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMTkzNA==", "bodyText": "Authors are not online but their name is displayed. The player names can be resolved from their UUID, and should be stored in a cache anyways. It's not stats' responsability to know playernames", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389301934", "createdAt": "2020-03-07T18:24:35Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzIxNTgwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxNzoyNVrOFyikPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxNzoyNVrOFyikPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTQ1Mw==", "bodyText": "You shouldn't be catching NPEs :D If something returns null please check it with the if statements", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388539453", "createdAt": "2020-03-05T20:17:25Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzIyNDc3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxOToyNFrOFyipCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoxOToyNFrOFyipCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MDY4MA==", "bodyText": "I see your are using murderer.getBukkit().getName() and event.getVictim().getBukkit().getName() in this method. Can you make local variables in this method to make the code cleaner?", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388540680", "createdAt": "2020-03-05T20:19:24Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzIyNzU2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoyMDowOFrOFyiqmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoyMDowOFrOFyiqmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MTA4MA==", "bodyText": "You should change the name and display name to local variables here too.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388541080", "createdAt": "2020-03-05T20:20:08Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzIzMDk3OnYy", "diffSide": "RIGHT", "path": "util-bukkit/src/main/i18n/templates/strings.properties", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoyMTowM1rOFyiskg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoyMTowM1rOFyiskg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MTU4Ng==", "bodyText": "Missing newline character.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388541586", "createdAt": "2020-03-05T20:21:03Z", "author": {"login": "TheMolkaPL"}, "path": "util-bukkit/src/main/i18n/templates/strings.properties", "diffHunk": "@@ -944,3 +944,13 @@ moderation.reports.hover = Reported by {0}\n # {0} = IP address\n moderation.commands.banIP = The IP address ({0}) has been banned.\n moderation.commands.invalidIP = {0} is not a valid IP address.\n+\n+# {X} = The number of the relevant stat\n+stats.basic = Kills: {0}(Killstreak: {1}), Deaths: {2}, K/D: {3}\n+\n+# {0} = Username\n+# {1} = The number of the relevant stat\n+stats.kills = Kills: {0} : {1}\n+stats.killstreak = Killstreak: {0} : {1}\n+stats.deaths = Deaths: {0} : {1}\n+stats.bowshot = Longest bowshot: {0} : {1} block(s)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzIzNjc5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMDoyMjowMVrOFyivfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wN1QxNToyNTowN1rOFzOqJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MjMzMw==", "bodyText": "I think we should make a class representing Map.Entry<String, Integer> topResult.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388542333", "createdAt": "2020-03-05T20:22:01Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);\n+    }\n+    Component killMessage = getKillsMessage(sortStats(allKills));\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks));\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths));\n+    Map.Entry<String, Integer> bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW + \"Best stats this match\",\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.getValue()\n+          != 0) { // Prevent this from showing if bows are not used on the map played\n+        viewer.sendMessage(bowshotMessage);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {\n+    Object[] a = map.entrySet().toArray();\n+    Arrays.sort(\n+        a,\n+        (Comparator)\n+            (o1, o2) ->\n+                ((Map.Entry<String, Integer>) o2)\n+                    .getValue()\n+                    .compareTo(((Map.Entry<String, Integer>) o1).getValue()));\n+    return (Map.Entry<String, Integer>) a[0];\n+  }\n+\n+  Component getKillsMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.kills\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getKillstreakMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.killstreak\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getDeathsMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.deaths\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.RED))\n+            .render());\n+  }\n+\n+  Component getBowshotMessage(Map.Entry<String, Integer> topResult) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3ODMwMg==", "bodyText": "A Record here would be amazing, too bad we're on java 8 and not 14 \ud83d\ude22", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388578302", "createdAt": "2020-03-05T21:32:46Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);\n+    }\n+    Component killMessage = getKillsMessage(sortStats(allKills));\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks));\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths));\n+    Map.Entry<String, Integer> bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW + \"Best stats this match\",\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.getValue()\n+          != 0) { // Prevent this from showing if bows are not used on the map played\n+        viewer.sendMessage(bowshotMessage);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {\n+    Object[] a = map.entrySet().toArray();\n+    Arrays.sort(\n+        a,\n+        (Comparator)\n+            (o1, o2) ->\n+                ((Map.Entry<String, Integer>) o2)\n+                    .getValue()\n+                    .compareTo(((Map.Entry<String, Integer>) o1).getValue()));\n+    return (Map.Entry<String, Integer>) a[0];\n+  }\n+\n+  Component getKillsMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.kills\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getKillstreakMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.killstreak\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getDeathsMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.deaths\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.RED))\n+            .render());\n+  }\n+\n+  Component getBowshotMessage(Map.Entry<String, Integer> topResult) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MjMzMw=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExOTAwMg==", "bodyText": "What do you mean Molka? Represent topResult as class in which way?", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389119002", "createdAt": "2020-03-06T20:07:36Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);\n+    }\n+    Component killMessage = getKillsMessage(sortStats(allKills));\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks));\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths));\n+    Map.Entry<String, Integer> bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW + \"Best stats this match\",\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.getValue()\n+          != 0) { // Prevent this from showing if bows are not used on the map played\n+        viewer.sendMessage(bowshotMessage);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {\n+    Object[] a = map.entrySet().toArray();\n+    Arrays.sort(\n+        a,\n+        (Comparator)\n+            (o1, o2) ->\n+                ((Map.Entry<String, Integer>) o2)\n+                    .getValue()\n+                    .compareTo(((Map.Entry<String, Integer>) o1).getValue()));\n+    return (Map.Entry<String, Integer>) a[0];\n+  }\n+\n+  Component getKillsMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.kills\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getKillstreakMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.killstreak\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getDeathsMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.deaths\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.RED))\n+            .render());\n+  }\n+\n+  Component getBowshotMessage(Map.Entry<String, Integer> topResult) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MjMzMw=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMjI2Mw==", "bodyText": "Make a class with two fields, String and int. A dedicated class with named fields is easier to understand than Map.Entry.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389212263", "createdAt": "2020-03-07T01:18:52Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);\n+    }\n+    Component killMessage = getKillsMessage(sortStats(allKills));\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks));\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths));\n+    Map.Entry<String, Integer> bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW + \"Best stats this match\",\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.getValue()\n+          != 0) { // Prevent this from showing if bows are not used on the map played\n+        viewer.sendMessage(bowshotMessage);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {\n+    Object[] a = map.entrySet().toArray();\n+    Arrays.sort(\n+        a,\n+        (Comparator)\n+            (o1, o2) ->\n+                ((Map.Entry<String, Integer>) o2)\n+                    .getValue()\n+                    .compareTo(((Map.Entry<String, Integer>) o1).getValue()));\n+    return (Map.Entry<String, Integer>) a[0];\n+  }\n+\n+  Component getKillsMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.kills\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getKillstreakMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.killstreak\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getDeathsMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.deaths\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.RED))\n+            .render());\n+  }\n+\n+  Component getBowshotMessage(Map.Entry<String, Integer> topResult) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MjMzMw=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI2MTg2Mg==", "bodyText": "This should be resolved in coming update, thanks :)", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389261862", "createdAt": "2020-03-07T15:25:07Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);\n+    }\n+    Component killMessage = getKillsMessage(sortStats(allKills));\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks));\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths));\n+    Map.Entry<String, Integer> bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW + \"Best stats this match\",\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.getValue()\n+          != 0) { // Prevent this from showing if bows are not used on the map played\n+        viewer.sendMessage(bowshotMessage);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {\n+    Object[] a = map.entrySet().toArray();\n+    Arrays.sort(\n+        a,\n+        (Comparator)\n+            (o1, o2) ->\n+                ((Map.Entry<String, Integer>) o2)\n+                    .getValue()\n+                    .compareTo(((Map.Entry<String, Integer>) o1).getValue()));\n+    return (Map.Entry<String, Integer>) a[0];\n+  }\n+\n+  Component getKillsMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.kills\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getKillstreakMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.killstreak\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getDeathsMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.deaths\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.RED))\n+            .render());\n+  }\n+\n+  Component getBowshotMessage(Map.Entry<String, Integer> topResult) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MjMzMw=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 225}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzQ1NzU3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMToyOTowMVrOFyk02g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOFQwOTo1MDo0NFrOFzUOUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NjQ3NA==", "bodyText": "Make this a repeating task, send the message for a second or so or else it fades away too quick", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388576474", "createdAt": "2020-03-05T21:29:01Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NjMzNA==", "bodyText": "How do i make it repeat? I tried #runTaskTimer with a delay of 0 and interval of 5, but that looked like a infinite thing, right?", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389176334", "createdAt": "2020-03-06T22:33:17Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NjQ3NA=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMjA0MA==", "bodyText": "i'm not sure with the scheduler. I know bukkit has it's own runRepeatingTask but idk why the match scheduler would not expose it", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389302040", "createdAt": "2020-03-07T18:26:24Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NjQ3NA=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxMzM3NA==", "bodyText": "Yeah that is exposed with the scheduler through runTaskTimer But that is neverending! How do i stop it o_o", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389313374", "createdAt": "2020-03-07T21:27:53Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NjQ3NA=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyMTc5Mg==", "bodyText": "It returns an int for the task id. you can cancel task by it's id", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389321792", "createdAt": "2020-03-08T00:00:41Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NjQ3NA=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1Mjk4NQ==", "bodyText": "Yeah, but i have to cancel the task through Bukkit#getScheduler#cancelTask\nMatch#getScheduler(MatchScope.LOADED)#cancelTask does not exist.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389352985", "createdAt": "2020-03-08T09:49:57Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NjQ3NA=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1MzA0Mg==", "bodyText": "And the normal runTaskTimer does not return an int, you have to do #getTaskId it seems", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389353042", "createdAt": "2020-03-08T09:50:44Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NjQ3NA=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzQ2MDAwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMToyOTo1MVrOFyk2bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMToyOTo1MVrOFyk2bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3Njg3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                HashMap<String, Integer> allKills = new HashMap<>();\n          \n          \n            \n                HashMap<String, Integer> allKillstreaks = new HashMap<>();\n          \n          \n            \n                HashMap<String, Integer> allDeaths = new HashMap<>();\n          \n          \n            \n                HashMap<String, Integer> allBowshots = new HashMap<>();\n          \n          \n            \n                Map<String, Integer> allKills = new HashMap<>();\n          \n          \n            \n                Map<String, Integer> allKillstreaks = new HashMap<>();\n          \n          \n            \n                Map<String, Integer> allDeaths = new HashMap<>();\n          \n          \n            \n                Map<String, Integer> allBowshots = new HashMap<>();", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388576879", "createdAt": "2020-03-05T21:29:51Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzQ2MTE0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTozMDowOVrOFyk3KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTozMDowOVrOFyk3KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NzA2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {\n          \n          \n            \n              private Map.Entry<String, Integer> sortStats(Map<String, Integer> map) {", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388577065", "createdAt": "2020-03-05T21:30:09Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);\n+    }\n+    Component killMessage = getKillsMessage(sortStats(allKills));\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks));\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths));\n+    Map.Entry<String, Integer> bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW + \"Best stats this match\",\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.getValue()\n+          != 0) { // Prevent this from showing if bows are not used on the map played\n+        viewer.sendMessage(bowshotMessage);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzQ2NjQxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTozMTo0OVrOFyk6Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOFQxMzoxMToyMVrOFzVI-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3Nzg5NQ==", "bodyText": "Something along the lines of:\nreturn map.entrySet().stream()\n  .max(Comparator.comparingInt(Map.Entry::getValue))\n  .orElse(null);", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388577895", "createdAt": "2020-03-05T21:31:49Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);\n+    }\n+    Component killMessage = getKillsMessage(sortStats(allKills));\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks));\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths));\n+    Map.Entry<String, Integer> bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW + \"Best stats this match\",\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.getValue()\n+          != 0) { // Prevent this from showing if bows are not used on the map played\n+        viewer.sendMessage(bowshotMessage);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {\n+    Object[] a = map.entrySet().toArray();\n+    Arrays.sort(\n+        a,\n+        (Comparator)\n+            (o1, o2) ->\n+                ((Map.Entry<String, Integer>) o2)\n+                    .getValue()\n+                    .compareTo(((Map.Entry<String, Integer>) o1).getValue()));\n+    return (Map.Entry<String, Integer>) a[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4MDI1Nw==", "bodyText": "Why this in favour of what i wrote? Is there a standard i'm doing wrong? :)\nOr does it just look prettier (Your does)", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389180257", "createdAt": "2020-03-06T22:45:34Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);\n+    }\n+    Component killMessage = getKillsMessage(sortStats(allKills));\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks));\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths));\n+    Map.Entry<String, Integer> bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW + \"Best stats this match\",\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.getValue()\n+          != 0) { // Prevent this from showing if bows are not used on the map played\n+        viewer.sendMessage(bowshotMessage);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {\n+    Object[] a = map.entrySet().toArray();\n+    Arrays.sort(\n+        a,\n+        (Comparator)\n+            (o1, o2) ->\n+                ((Map.Entry<String, Integer>) o2)\n+                    .getValue()\n+                    .compareTo(((Map.Entry<String, Integer>) o1).getValue()));\n+    return (Map.Entry<String, Integer>) a[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3Nzg5NQ=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMTk4MA==", "bodyText": "It's easier to read ^^", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389211980", "createdAt": "2020-03-07T01:16:39Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);\n+    }\n+    Component killMessage = getKillsMessage(sortStats(allKills));\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks));\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths));\n+    Map.Entry<String, Integer> bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW + \"Best stats this match\",\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.getValue()\n+          != 0) { // Prevent this from showing if bows are not used on the map played\n+        viewer.sendMessage(bowshotMessage);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {\n+    Object[] a = map.entrySet().toArray();\n+    Arrays.sort(\n+        a,\n+        (Comparator)\n+            (o1, o2) ->\n+                ((Map.Entry<String, Integer>) o2)\n+                    .getValue()\n+                    .compareTo(((Map.Entry<String, Integer>) o1).getValue()));\n+    return (Map.Entry<String, Integer>) a[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3Nzg5NQ=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM2ODA1Nw==", "bodyText": "More concise (less code, same outcome)\nBetter readability\nAvoids extra allocation of an object array.\nDoesn't do weird casting from object to entry.\nThe complexity of finding a max or min is O(n) instead of O(n log n) that good sorting algs have\nIsn't painful to read (yes, i'm mentioning readability twice, because it is double as relevant).", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389368057", "createdAt": "2020-03-08T13:11:21Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);\n+    }\n+    Component killMessage = getKillsMessage(sortStats(allKills));\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks));\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths));\n+    Map.Entry<String, Integer> bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW + \"Best stats this match\",\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.getValue()\n+          != 0) { // Prevent this from showing if bows are not used on the map played\n+        viewer.sendMessage(bowshotMessage);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {\n+    Object[] a = map.entrySet().toArray();\n+    Arrays.sort(\n+        a,\n+        (Comparator)\n+            (o1, o2) ->\n+                ((Map.Entry<String, Integer>) o2)\n+                    .getValue()\n+                    .compareTo(((Map.Entry<String, Integer>) o1).getValue()));\n+    return (Map.Entry<String, Integer>) a[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3Nzg5NQ=="}, "originalCommit": {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMzE1MDgxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMDozNjowM1rOFzYiVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNDowMzo1NlrOFzppWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQyMzcwMg==", "bodyText": "I\u2019m curious why you chose to call this directly instead of\nfinalMurderer.sendHotbarMessage(finalMurdererStats.getBasicStatsMessage())?\nThe MatchPlayer#sendHotbarMessage method calls NMSHacks anyway, so it may be a little more consistent if you like.\nBesides that, great job! This will be awesome once merged \ud83d\ude04", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389423702", "createdAt": "2020-03-09T00:36:03Z", "author": {"login": "applenick"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    if (event.getKiller() != null) {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    }\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (victimStats == null) {\n+      allPlayerStats.put(victimUUID, new PlayerStats());\n+      victimStats = allPlayerStats.get(victimUUID);\n+    }\n+\n+    victimStats.onDeath();\n+\n+    PlayerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    int victimTaskId =\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  NMSHacks.sendHotbarMessage(\n+                      victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+                })\n+            .getTaskId();\n+\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            70,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(victimTaskId);\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murdererUUID, new PlayerStats());\n+        murdererStats = allPlayerStats.get(murdererUUID);\n+      }\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+\n+        murdererStats.onMurder();\n+\n+        MatchPlayer finalMurderer = murderer;\n+        PlayerStats finalMurdererStats = murdererStats;\n+        int murdererTaskId =\n+            event\n+                .getMatch()\n+                .getScheduler(MatchScope.LOADED)\n+                .runTaskTimer(\n+                    0,\n+                    5,\n+                    () -> {\n+                      NMSHacks.sendHotbarMessage(\n+                          finalMurderer.getBukkit(), finalMurdererStats.getBasicStatsMessage());\n+                    })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcwNDAyNQ==", "bodyText": "Ah! I never knew that, thanks! :)", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389704025", "createdAt": "2020-03-09T14:03:56Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    if (event.getKiller() != null) {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    }\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (victimStats == null) {\n+      allPlayerStats.put(victimUUID, new PlayerStats());\n+      victimStats = allPlayerStats.get(victimUUID);\n+    }\n+\n+    victimStats.onDeath();\n+\n+    PlayerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    int victimTaskId =\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  NMSHacks.sendHotbarMessage(\n+                      victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+                })\n+            .getTaskId();\n+\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            70,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(victimTaskId);\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murdererUUID, new PlayerStats());\n+        murdererStats = allPlayerStats.get(murdererUUID);\n+      }\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+\n+        murdererStats.onMurder();\n+\n+        MatchPlayer finalMurderer = murderer;\n+        PlayerStats finalMurdererStats = murdererStats;\n+        int murdererTaskId =\n+            event\n+                .getMatch()\n+                .getScheduler(MatchScope.LOADED)\n+                .runTaskTimer(\n+                    0,\n+                    5,\n+                    () -> {\n+                      NMSHacks.sendHotbarMessage(\n+                          finalMurderer.getBukkit(), finalMurdererStats.getBasicStatsMessage());\n+                    })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQyMzcwMg=="}, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMzE1MDk0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMDozNjoyM1rOFzYibg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMDozNjoyM1rOFzYibg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQyMzcyNg==", "bodyText": "See other comment about this.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389423726", "createdAt": "2020-03-09T00:36:23Z", "author": {"login": "applenick"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    if (event.getKiller() != null) {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    }\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (victimStats == null) {\n+      allPlayerStats.put(victimUUID, new PlayerStats());\n+      victimStats = allPlayerStats.get(victimUUID);\n+    }\n+\n+    victimStats.onDeath();\n+\n+    PlayerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    int victimTaskId =\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  NMSHacks.sendHotbarMessage(\n+                      victim.getBukkit(), finalVictimStats.getBasicStatsMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMzIxMTYxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMTo0Nzo0NVrOFzZEpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMDoxODo0MVrOFz9jYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjQ4NA==", "bodyText": "Why are you doing this that complicated way? :P You can cast numbers between datatypes.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389432484", "createdAt": "2020-03-09T01:47:45Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcwNzU1NQ==", "bodyText": "Like this?\n private void setLongestBowKill(double distance) { if (distance > longestBowKill) { longestBowKill = (int) distance; } }", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389707555", "createdAt": "2020-03-09T14:07:06Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjQ4NA=="}, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3NDU3Nw==", "bodyText": "Exactly, but don't compare doubles with < > ==\nhttps://howtodoinjava.com/java/basics/correctly-compare-float-double/", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389874577", "createdAt": "2020-03-09T18:17:28Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjQ4NA=="}, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzMDE3OQ==", "bodyText": "So like this?\nprivate void setLongestBowKill(double distance) { if (new BigDecimal(distance).compareTo(new BigDecimal(longestBowKill)) > 0) { longestBowKill = (int) distance; } }", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r390030179", "createdAt": "2020-03-10T00:18:41Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjQ4NA=="}, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMzIxMTc0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMTo0Nzo1M1rOFzZEtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMTo0Nzo1M1rOFzZEtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjUwMQ==", "bodyText": "Can be final", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389432501", "createdAt": "2020-03-09T01:47:53Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMzIxMjE3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMTo0ODoyN1rOFzZE_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzozMjoyN1rOFz8wxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjU3NQ==", "bodyText": "This is defining static context from the instance context.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389432575", "createdAt": "2020-03-09T01:48:27Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcwODM4MA==", "bodyText": "What does that mean? haha", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389708380", "createdAt": "2020-03-09T14:07:48Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjU3NQ=="}, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3MjY4Mw==", "bodyText": "allPlayerStats is a static variable. This means that the variable is global and not object depended. If you create a new instance of StatsMatchModule the contents of allPlayerStats should still be the same. The problem is that you are modifying static (global) variable from the object (its constructor). You should either make allPlayerStats non-static and make it object depended, or initialize it just once and make it a constant. If so, there will only be one instance of this allPlayerStats map.\nprivate final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\nor\nprivate static final Map<UUID, PlayerStats> ALL_PLAYER_STATS = new HashMap<>();", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389872683", "createdAt": "2020-03-09T18:14:11Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjU3NQ=="}, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNzIyMg==", "bodyText": "What do i even need the constructor for? I only added it because Electroids example has it. The Module does not need to get passed any objects on creation anyways.., i will make i private static final.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r390017222", "createdAt": "2020-03-09T23:32:27Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjU3NQ=="}, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMzIxNDA4OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMTo1MDoxOVrOFzZGKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxNjozNzowNVrOF0_O_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjg3Mw==", "bodyText": "This method seems to be very long. Could you try to slice it into smaller ones? Would make it easier to read.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389432873", "createdAt": "2020-03-09T01:50:19Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    if (event.getKiller() != null) {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    }\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (victimStats == null) {\n+      allPlayerStats.put(victimUUID, new PlayerStats());\n+      victimStats = allPlayerStats.get(victimUUID);\n+    }\n+\n+    victimStats.onDeath();\n+\n+    PlayerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    int victimTaskId =\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  NMSHacks.sendHotbarMessage(\n+                      victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+                })\n+            .getTaskId();\n+\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            70,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(victimTaskId);\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murdererUUID, new PlayerStats());\n+        murdererStats = allPlayerStats.get(murdererUUID);\n+      }\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+\n+        murdererStats.onMurder();\n+\n+        MatchPlayer finalMurderer = murderer;\n+        PlayerStats finalMurdererStats = murdererStats;\n+        int murdererTaskId =\n+            event\n+                .getMatch()\n+                .getScheduler(MatchScope.LOADED)\n+                .runTaskTimer(\n+                    0,\n+                    5,\n+                    () -> {\n+                      NMSHacks.sendHotbarMessage(\n+                          finalMurderer.getBukkit(), finalMurdererStats.getBasicStatsMessage());\n+                    })\n+                .getTaskId();\n+\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskLater(\n+                70,\n+                () -> {\n+                  Bukkit.getScheduler().cancelTask(murdererTaskId);\n+                });\n+      }\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNjMwMA==", "bodyText": "Yeah i'm splitting it up, you will see next commit.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r391106300", "createdAt": "2020-03-11T16:37:05Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    if (event.getKiller() != null) {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    }\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (victimStats == null) {\n+      allPlayerStats.put(victimUUID, new PlayerStats());\n+      victimStats = allPlayerStats.get(victimUUID);\n+    }\n+\n+    victimStats.onDeath();\n+\n+    PlayerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    int victimTaskId =\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  NMSHacks.sendHotbarMessage(\n+                      victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+                })\n+            .getTaskId();\n+\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            70,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(victimTaskId);\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murdererUUID, new PlayerStats());\n+        murdererStats = allPlayerStats.get(murdererUUID);\n+      }\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+\n+        murdererStats.onMurder();\n+\n+        MatchPlayer finalMurderer = murderer;\n+        PlayerStats finalMurdererStats = murdererStats;\n+        int murdererTaskId =\n+            event\n+                .getMatch()\n+                .getScheduler(MatchScope.LOADED)\n+                .runTaskTimer(\n+                    0,\n+                    5,\n+                    () -> {\n+                      NMSHacks.sendHotbarMessage(\n+                          finalMurderer.getBukkit(), finalMurdererStats.getBasicStatsMessage());\n+                    })\n+                .getTaskId();\n+\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskLater(\n+                70,\n+                () -> {\n+                  Bukkit.getScheduler().cancelTask(murdererTaskId);\n+                });\n+      }\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjg3Mw=="}, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxMzIyMjY3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwMTo1ODo1OVrOFzZLVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzowODo1OFrOFz8USQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzNDE5OQ==", "bodyText": "These methods are actually the same. The only difference seems to be translation keys and colors. To keep this DRY we could try make a generic method with these as parameters, and these methods would call it.\nComponent getBowshotMessage(TopResult topResult, Match match) {\n  return getMessage(\"stats.bowshot\", topResult, match, ChatColor.YELLOW);\n}\n\nComponent getMessage(String messageKey, TopResult topResult, Match match, CharColor color) {\n  return new Component(\n      new PersonalizedTranslatable(\n              messageKey,\n              playerName(match, topResult.uuid),\n              new PersonalizedText(Integer.toString(topResult.stat), color))\n          .render());\n}", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389434199", "createdAt": "2020-03-09T01:58:59Z", "author": {"login": "TheMolkaPL"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    if (event.getKiller() != null) {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    }\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (victimStats == null) {\n+      allPlayerStats.put(victimUUID, new PlayerStats());\n+      victimStats = allPlayerStats.get(victimUUID);\n+    }\n+\n+    victimStats.onDeath();\n+\n+    PlayerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    int victimTaskId =\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  NMSHacks.sendHotbarMessage(\n+                      victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+                })\n+            .getTaskId();\n+\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            70,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(victimTaskId);\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murdererUUID, new PlayerStats());\n+        murdererStats = allPlayerStats.get(murdererUUID);\n+      }\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+\n+        murdererStats.onMurder();\n+\n+        MatchPlayer finalMurderer = murderer;\n+        PlayerStats finalMurdererStats = murdererStats;\n+        int murdererTaskId =\n+            event\n+                .getMatch()\n+                .getScheduler(MatchScope.LOADED)\n+                .runTaskTimer(\n+                    0,\n+                    5,\n+                    () -> {\n+                      NMSHacks.sendHotbarMessage(\n+                          finalMurderer.getBukkit(), finalMurdererStats.getBasicStatsMessage());\n+                    })\n+                .getTaskId();\n+\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskLater(\n+                70,\n+                () -> {\n+                  Bukkit.getScheduler().cancelTask(murdererTaskId);\n+                });\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (allPlayerStats.get(playerUUID) == null) {\n+        allPlayerStats.put(playerUUID, new PlayerStats());\n+      }\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getKillsMessage(sortStats(allKills), match);\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks), match);\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths), match);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot, match);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0)\n+        viewer.sendMessage(bowshotMessage); // Prevent from showing if bows are not used\n+    }\n+  }\n+\n+  private static class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }\n+    topResult.uuid = mapEntry.getKey();\n+    topResult.stat = mapEntry.getValue();\n+    return topResult;\n+  }\n+\n+  Component getKillsMessage(TopResult topResult, Match match) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.kills\",\n+                playerName(match, topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getKillstreakMessage(TopResult topResult, Match match) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.killstreak\",\n+                playerName(match, topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getDeathsMessage(TopResult topResult, Match match) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.deaths\",\n+                playerName(match, topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), ChatColor.RED))\n+            .render());\n+  }\n+\n+  Component getBowshotMessage(TopResult topResult, Match match) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.bowshot\",\n+                playerName(match, topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), ChatColor.YELLOW))\n+            .render());\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTkyOQ==", "bodyText": "Do we even need a Component constructor for each message then? Why not just call getMessage from a method directly.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r390009929", "createdAt": "2020-03-09T23:08:58Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    if (event.getKiller() != null) {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    }\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (victimStats == null) {\n+      allPlayerStats.put(victimUUID, new PlayerStats());\n+      victimStats = allPlayerStats.get(victimUUID);\n+    }\n+\n+    victimStats.onDeath();\n+\n+    PlayerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    int victimTaskId =\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  NMSHacks.sendHotbarMessage(\n+                      victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+                })\n+            .getTaskId();\n+\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            70,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(victimTaskId);\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murdererUUID, new PlayerStats());\n+        murdererStats = allPlayerStats.get(murdererUUID);\n+      }\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+\n+        murdererStats.onMurder();\n+\n+        MatchPlayer finalMurderer = murderer;\n+        PlayerStats finalMurdererStats = murdererStats;\n+        int murdererTaskId =\n+            event\n+                .getMatch()\n+                .getScheduler(MatchScope.LOADED)\n+                .runTaskTimer(\n+                    0,\n+                    5,\n+                    () -> {\n+                      NMSHacks.sendHotbarMessage(\n+                          finalMurderer.getBukkit(), finalMurdererStats.getBasicStatsMessage());\n+                    })\n+                .getTaskId();\n+\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskLater(\n+                70,\n+                () -> {\n+                  Bukkit.getScheduler().cancelTask(murdererTaskId);\n+                });\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (allPlayerStats.get(playerUUID) == null) {\n+        allPlayerStats.put(playerUUID, new PlayerStats());\n+      }\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getKillsMessage(sortStats(allKills), match);\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks), match);\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths), match);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot, match);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0)\n+        viewer.sendMessage(bowshotMessage); // Prevent from showing if bows are not used\n+    }\n+  }\n+\n+  private static class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }\n+    topResult.uuid = mapEntry.getKey();\n+    topResult.stat = mapEntry.getValue();\n+    return topResult;\n+  }\n+\n+  Component getKillsMessage(TopResult topResult, Match match) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.kills\",\n+                playerName(match, topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getKillstreakMessage(TopResult topResult, Match match) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.killstreak\",\n+                playerName(match, topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getDeathsMessage(TopResult topResult, Match match) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.deaths\",\n+                playerName(match, topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), ChatColor.RED))\n+            .render());\n+  }\n+\n+  Component getBowshotMessage(TopResult topResult, Match match) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.bowshot\",\n+                playerName(match, topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), ChatColor.YELLOW))\n+            .render());\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzNDE5OQ=="}, "originalCommit": {"oid": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3"}, "originalPosition": 282}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNzYxOTYwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/PGMPlugin.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNTozNTozNFrOF1j1XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNTozNTozNFrOF1j1XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNTk0OA==", "bodyText": "StatsCommands", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r391705948", "createdAt": "2020-03-12T15:35:34Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/PGMPlugin.java", "diffHunk": "@@ -320,6 +321,7 @@ private void registerCommands() {\n     node.registerCommands(new SettingCommands());\n     node.registerCommands(new ObserverCommands());\n     node.registerCommands(new MapPoolCommands());\n+    node.registerCommands(new StatCommands());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94883a4d75940b41d27168ac71873438a8396979"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNzYyNDkxOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNTozNjo1MVrOF1j4yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo1MToxOFrOF5xW3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNjgyNQ==", "bodyText": "MatchModules should not store player data in static variables. Remove the static.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r391706825", "createdAt": "2020-03-12T15:36:51Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package tc.oc.pgm.modules;\n+\n+import java.math.BigDecimal;\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (new BigDecimal(distance).compareTo(new BigDecimal(longestBowKill)) > 0) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94883a4d75940b41d27168ac71873438a8396979"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMTgyMw==", "bodyText": "Already fixed.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396121823", "createdAt": "2020-03-22T17:51:18Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package tc.oc.pgm.modules;\n+\n+import java.math.BigDecimal;\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (new BigDecimal(distance).compareTo(new BigDecimal(longestBowKill)) > 0) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNjgyNQ=="}, "originalCommit": {"oid": "94883a4d75940b41d27168ac71873438a8396979"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNzYyNjg3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNTozNzoyM1rOF1j6Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo1MToyNlrOF5xW6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNzE1NQ==", "bodyText": "In Java, methods should start with a lower case letter.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r391707155", "createdAt": "2020-03-12T15:37:23Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package tc.oc.pgm.modules;\n+\n+import java.math.BigDecimal;\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (new BigDecimal(distance).compareTo(new BigDecimal(longestBowKill)) > 0) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    Match match = event.getMatch();\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (PlayerStatsDoesNotExist(victimUUID)) victimStats = putNewPlayer(victimUUID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94883a4d75940b41d27168ac71873438a8396979"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMTgzNA==", "bodyText": "Already fixed.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396121834", "createdAt": "2020-03-22T17:51:26Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package tc.oc.pgm.modules;\n+\n+import java.math.BigDecimal;\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (new BigDecimal(distance).compareTo(new BigDecimal(longestBowKill)) > 0) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    Match match = event.getMatch();\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (PlayerStatsDoesNotExist(victimUUID)) victimStats = putNewPlayer(victimUUID);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNzE1NQ=="}, "originalCommit": {"oid": "94883a4d75940b41d27168ac71873438a8396979"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMTg4NDI5OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzo0OTo0NVrOF2NFDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzo0OTo0NVrOF2NFDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4MTcxMQ==", "bodyText": "May want to make this private final Match match;", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r392381711", "createdAt": "2020-03-13T17:49:45Z", "author": {"login": "applenick"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -35,10 +34,17 @@\n \n     @Override\n     public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n-      return new StatsMatchModule();\n+      return new StatsMatchModule(match);\n     }\n   }\n \n+  Match match;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "604cd9fc475b6aef61c769009ed0e19bb67c35bb"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzMTkwNjkzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzo1NzoyMVrOF2NT5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QxNzo1NzoyMVrOF2NT5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4NTUwOQ==", "bodyText": "This should be something along the lines of hasNoStats or at the very least playerStatsDoesNotExist. Gotta remember camel case \ud83d\udc2b", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r392385509", "createdAt": "2020-03-13T17:57:21Z", "author": {"login": "applenick"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  Match match;\n+  private static final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (PlayerStatsDoesNotExist(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (PlayerStatsDoesNotExist(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (PlayerStatsDoesNotExist(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private static class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }\n+\n+    topResult.uuid = mapEntry.getKey();\n+    topResult.stat = mapEntry.getValue();\n+\n+    return topResult;\n+  }\n+\n+  private void sendLongHotbarMessage(MatchPlayer player, Component message) {\n+    int taskId =\n+        match\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  player.sendHotbarMessage(message);\n+                })\n+            .getTaskId();\n+\n+    match\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            20 * 4,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(taskId);\n+            });\n+  }\n+\n+  Component getMessage(String messageKey, TopResult topResult, ChatColor color) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                messageKey,\n+                playerName(topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), color).render())\n+            .render());\n+  }\n+\n+  private PersonalizedText playerName(UUID playerUUID) {\n+    if (Bukkit.getPlayer(playerUUID) == null) {\n+      if (Bukkit.getOfflinePlayer(playerUUID).getName() == null) {\n+        return new PersonalizedText(\"Noone\", ChatColor.MAGIC, ChatColor.BLACK);\n+      }\n+      return new PersonalizedText(\n+          Bukkit.getOfflinePlayer(playerUUID).getName(), ChatColor.DARK_AQUA);\n+    }\n+    return new PersonalizedText(match.getPlayer(playerUUID).getBukkit().getDisplayName());\n+  }\n+\n+  public static boolean PlayerStatsDoesNotExist(UUID player) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "604cd9fc475b6aef61c769009ed0e19bb67c35bb"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NTQzOTkwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNjoxNToxMlrOF5wuBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNjoxNToxMlrOF5wuBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTM2NA==", "bodyText": "You don't need this. In Modules.java you can put instead:\nregister(StatsMatchModule.class, StatsMatchModule::new);", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396111364", "createdAt": "2020-03-22T16:15:12Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NTQ0MTY2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNjoxNzozMVrOF5wu9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwMTowNTowOVrOF50cAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTYwNQ==", "bodyText": "To avoid the possibility of a 0 bow kill:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    longestBowKill = (int) distance;\n          \n          \n            \n                    longestBowKill = (int) Math.ceil(distance);", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396111605", "createdAt": "2020-03-22T16:17:31Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMzk5Mw==", "bodyText": "I am not sure why that would be needed, i already prevent any message containing bow kills from showing if they are 0.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396123993", "createdAt": "2020-03-22T18:12:29Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTYwNQ=="}, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE3MjI4OA==", "bodyText": "It's good form.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396172288", "createdAt": "2020-03-23T01:05:09Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTYwNQ=="}, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NTQ0MzI1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNjoxOTo0MFrOF5wv5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo1MjoxMlrOF5xXMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTg0NQ==", "bodyText": "You don't need this null check, these maps will never be null.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396111845", "createdAt": "2020-03-22T16:19:40Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMTkwNQ==", "bodyText": "Ok!", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396121905", "createdAt": "2020-03-22T17:52:12Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTg0NQ=="}, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NTQ0MzYwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNjoyMDoyMVrOF5wwHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxMzoxNDowMFrOF6ExvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTkwMA==", "bodyText": "You don't need this class.\nJust use Map.Entry<UUID, Integer>", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396111900", "createdAt": "2020-03-22T16:20:21Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMjU2MQ==", "bodyText": "That is the way i did it before, that change was done because of @TheMolkaPL s suggestion earlier. You can see his reasoning #338 (comment)\nI can remove it if you still disagree", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396122561", "createdAt": "2020-03-22T17:58:12Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTkwMA=="}, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE3MjI0MA==", "bodyText": "I would remove it.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396172240", "createdAt": "2020-03-23T01:04:45Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTkwMA=="}, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQzOTk5Nw==", "bodyText": "Sure, i've removed it now.", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396439997", "createdAt": "2020-03-23T13:14:00Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTkwMA=="}, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NTQ0NTQzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNjoyMjoyMFrOF5wxEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNjoyMjoyMFrOF5wxEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMjE0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            () -> {\n          \n          \n            \n                              player.sendHotbarMessage(message);\n          \n          \n            \n                            })\n          \n          \n            \n                            () -> player.sendHotbarMessage(message));", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396112145", "createdAt": "2020-03-22T16:22:20Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }\n+\n+    topResult.uuid = mapEntry.getKey();\n+    topResult.stat = mapEntry.getValue();\n+\n+    return topResult;\n+  }\n+\n+  private void sendLongHotbarMessage(MatchPlayer player, Component message) {\n+    int taskId =\n+        match\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  player.sendHotbarMessage(message);\n+                })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 205}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NTQ0NjE3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNjoyMzowMFrOF5wxcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNjoyMzowMFrOF5wxcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMjI0Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        () -> {\n          \n          \n            \n                          Bukkit.getScheduler().cancelTask(taskId);\n          \n          \n            \n                        });\n          \n          \n            \n                        () -> Bukkit.getScheduler().cancelTask(taskId));", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396112242", "createdAt": "2020-03-22T16:23:00Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }\n+\n+    topResult.uuid = mapEntry.getKey();\n+    topResult.stat = mapEntry.getValue();\n+\n+    return topResult;\n+  }\n+\n+  private void sendLongHotbarMessage(MatchPlayer player, Component message) {\n+    int taskId =\n+        match\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  player.sendHotbarMessage(message);\n+                })\n+            .getTaskId();\n+\n+    match\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            20 * 4,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(taskId);\n+            });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NTQ0NzI2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNjoyMzo0NFrOF5wx8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNjoyMzo0NFrOF5wx8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMjM2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new PersonalizedText(\"Noone\", ChatColor.MAGIC, ChatColor.BLACK);\n          \n          \n            \n                    return new PersonalizedText(\"Unknown\", ChatColor.MAGIC, ChatColor.BLACK);", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396112369", "createdAt": "2020-03-22T16:23:44Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }\n+\n+    topResult.uuid = mapEntry.getKey();\n+    topResult.stat = mapEntry.getValue();\n+\n+    return topResult;\n+  }\n+\n+  private void sendLongHotbarMessage(MatchPlayer player, Component message) {\n+    int taskId =\n+        match\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  player.sendHotbarMessage(message);\n+                })\n+            .getTaskId();\n+\n+    match\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            20 * 4,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(taskId);\n+            });\n+  }\n+\n+  Component getMessage(String messageKey, TopResult topResult, ChatColor color) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                messageKey,\n+                playerName(topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), color).render())\n+            .render());\n+  }\n+\n+  private PersonalizedText playerName(UUID playerUUID) {\n+    if (Bukkit.getPlayer(playerUUID) == null) {\n+      if (Bukkit.getOfflinePlayer(playerUUID).getName() == null) {\n+        return new PersonalizedText(\"Noone\", ChatColor.MAGIC, ChatColor.BLACK);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6481e3c922c1f50afc7c782061ceb901886fd55e"}, "originalPosition": 229}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1138, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}