{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk1OTk4NjY4", "number": 665, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNjo0NDo0NFrOEpVduw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNjo0NDo0NFrOEpVduw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNzc4NzQ3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/ProjectileTrailMatchModule.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNjo0NDo0NFrOHa8f2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQyMzo1NDowOFrOHb-LLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAxNjIxOA==", "bodyText": "This would also remove critical effects for people with /toggle effects off? Unsure how to solve, maybe add white trails manually?", "url": "https://github.com/PGMDev/PGM/pull/665#discussion_r498016218", "createdAt": "2020-10-01T06:44:44Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/ProjectileTrailMatchModule.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package tc.oc.pgm.modules;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.bukkit.Color;\n+import org.bukkit.Effect;\n+import org.bukkit.entity.Arrow;\n+import org.bukkit.entity.Projectile;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.ProjectileHitEvent;\n+import org.bukkit.event.entity.ProjectileLaunchEvent;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.setting.SettingKey;\n+import tc.oc.pgm.api.setting.SettingValue;\n+import tc.oc.pgm.events.ListenerScope;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class ProjectileTrailMatchModule implements MatchModule, Listener {\n+\n+  private static final String TRAIL_META = \"projectile_trail_color\";\n+  private static final String CRITICAL_META = \"arrow_is_critical\";\n+\n+  private final Match match;\n+\n+  public ProjectileTrailMatchModule(Match match) {\n+    this.match = match;\n+    match\n+        .getExecutor(MatchScope.RUNNING)\n+        .scheduleAtFixedRate(this::checkMatchProjectiles, 0l, 50, TimeUnit.MILLISECONDS);\n+  }\n+\n+  public void checkMatchProjectiles() {\n+    match.getWorld().getEntitiesByClass(Projectile.class).stream()\n+        .filter(projectile -> projectile.hasMetadata(TRAIL_META))\n+        .forEach(\n+            projectile -> {\n+              if (projectile.isDead() || projectile.isOnGround()) {\n+                projectile.removeMetadata(TRAIL_META, PGM.get());\n+              } else {\n+                final Color color = (Color) projectile.getMetadata(TRAIL_META, PGM.get()).value();\n+\n+                match.getPlayers().stream()\n+                    .filter(\n+                        pl ->\n+                            pl.getSettings().getValue(SettingKey.EFFECTS)\n+                                == SettingValue.EFFECTS_ON)\n+                    .forEach(\n+                        player -> {\n+                          player\n+                              .getBukkit()\n+                              .spigot()\n+                              .playEffect(\n+                                  projectile.getLocation(),\n+                                  Effect.COLOURED_DUST,\n+                                  0,\n+                                  0,\n+                                  rgbToParticle(color.getRed()),\n+                                  rgbToParticle(color.getGreen()),\n+                                  rgbToParticle(color.getBlue()),\n+                                  1,\n+                                  0,\n+                                  50);\n+                        });\n+              }\n+            });\n+  }\n+\n+  private float rgbToParticle(int rgb) {\n+    return Math.max(0.001f, (rgb / 255.0f));\n+  }\n+\n+  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)\n+  public void onProjectileLaunch(ProjectileLaunchEvent event) {\n+    MatchPlayer player = match.getPlayer(event.getActor());\n+    if (player != null) {\n+      final Projectile projectile = event.getEntity();\n+      projectile.setMetadata(\n+          TRAIL_META, new FixedMetadataValue(PGM.get(), player.getParty().getFullColor()));\n+      // Set critical metadata to false in order to remove default particle trail.\n+      // The metadata will be restored just before the arrow hits something.\n+      if (projectile instanceof Arrow) {\n+        final Arrow arrow = (Arrow) projectile;\n+        arrow.setMetadata(CRITICAL_META, new FixedMetadataValue(PGM.get(), arrow.isCritical()));\n+        arrow.setCritical(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8cd056504cafe46a3092cf228fbfc94ff6e57e7"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2NzIxMg==", "bodyText": "Yeah I'm not sure, maybe instead of making it a toggle per player, perhaps it could be a server-wide config value. I'm not sure if a white trail would be the right call, since the point of the toggle is to disable the effects. Uh any suggestions you have would be welcome.", "url": "https://github.com/PGMDev/PGM/pull/665#discussion_r498467212", "createdAt": "2020-10-01T19:26:43Z", "author": {"login": "applenick"}, "path": "core/src/main/java/tc/oc/pgm/modules/ProjectileTrailMatchModule.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package tc.oc.pgm.modules;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.bukkit.Color;\n+import org.bukkit.Effect;\n+import org.bukkit.entity.Arrow;\n+import org.bukkit.entity.Projectile;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.ProjectileHitEvent;\n+import org.bukkit.event.entity.ProjectileLaunchEvent;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.setting.SettingKey;\n+import tc.oc.pgm.api.setting.SettingValue;\n+import tc.oc.pgm.events.ListenerScope;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class ProjectileTrailMatchModule implements MatchModule, Listener {\n+\n+  private static final String TRAIL_META = \"projectile_trail_color\";\n+  private static final String CRITICAL_META = \"arrow_is_critical\";\n+\n+  private final Match match;\n+\n+  public ProjectileTrailMatchModule(Match match) {\n+    this.match = match;\n+    match\n+        .getExecutor(MatchScope.RUNNING)\n+        .scheduleAtFixedRate(this::checkMatchProjectiles, 0l, 50, TimeUnit.MILLISECONDS);\n+  }\n+\n+  public void checkMatchProjectiles() {\n+    match.getWorld().getEntitiesByClass(Projectile.class).stream()\n+        .filter(projectile -> projectile.hasMetadata(TRAIL_META))\n+        .forEach(\n+            projectile -> {\n+              if (projectile.isDead() || projectile.isOnGround()) {\n+                projectile.removeMetadata(TRAIL_META, PGM.get());\n+              } else {\n+                final Color color = (Color) projectile.getMetadata(TRAIL_META, PGM.get()).value();\n+\n+                match.getPlayers().stream()\n+                    .filter(\n+                        pl ->\n+                            pl.getSettings().getValue(SettingKey.EFFECTS)\n+                                == SettingValue.EFFECTS_ON)\n+                    .forEach(\n+                        player -> {\n+                          player\n+                              .getBukkit()\n+                              .spigot()\n+                              .playEffect(\n+                                  projectile.getLocation(),\n+                                  Effect.COLOURED_DUST,\n+                                  0,\n+                                  0,\n+                                  rgbToParticle(color.getRed()),\n+                                  rgbToParticle(color.getGreen()),\n+                                  rgbToParticle(color.getBlue()),\n+                                  1,\n+                                  0,\n+                                  50);\n+                        });\n+              }\n+            });\n+  }\n+\n+  private float rgbToParticle(int rgb) {\n+    return Math.max(0.001f, (rgb / 255.0f));\n+  }\n+\n+  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)\n+  public void onProjectileLaunch(ProjectileLaunchEvent event) {\n+    MatchPlayer player = match.getPlayer(event.getActor());\n+    if (player != null) {\n+      final Projectile projectile = event.getEntity();\n+      projectile.setMetadata(\n+          TRAIL_META, new FixedMetadataValue(PGM.get(), player.getParty().getFullColor()));\n+      // Set critical metadata to false in order to remove default particle trail.\n+      // The metadata will be restored just before the arrow hits something.\n+      if (projectile instanceof Arrow) {\n+        final Arrow arrow = (Arrow) projectile;\n+        arrow.setMetadata(CRITICAL_META, new FixedMetadataValue(PGM.get(), arrow.isCritical()));\n+        arrow.setCritical(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAxNjIxOA=="}, "originalCommit": {"oid": "c8cd056504cafe46a3092cf228fbfc94ff6e57e7"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5ODcyOA==", "bodyText": "I was trying to say you could \"simulate\" a critical effect? Effect.CRIT", "url": "https://github.com/PGMDev/PGM/pull/665#discussion_r498498728", "createdAt": "2020-10-01T20:34:43Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/ProjectileTrailMatchModule.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package tc.oc.pgm.modules;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.bukkit.Color;\n+import org.bukkit.Effect;\n+import org.bukkit.entity.Arrow;\n+import org.bukkit.entity.Projectile;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.ProjectileHitEvent;\n+import org.bukkit.event.entity.ProjectileLaunchEvent;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.setting.SettingKey;\n+import tc.oc.pgm.api.setting.SettingValue;\n+import tc.oc.pgm.events.ListenerScope;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class ProjectileTrailMatchModule implements MatchModule, Listener {\n+\n+  private static final String TRAIL_META = \"projectile_trail_color\";\n+  private static final String CRITICAL_META = \"arrow_is_critical\";\n+\n+  private final Match match;\n+\n+  public ProjectileTrailMatchModule(Match match) {\n+    this.match = match;\n+    match\n+        .getExecutor(MatchScope.RUNNING)\n+        .scheduleAtFixedRate(this::checkMatchProjectiles, 0l, 50, TimeUnit.MILLISECONDS);\n+  }\n+\n+  public void checkMatchProjectiles() {\n+    match.getWorld().getEntitiesByClass(Projectile.class).stream()\n+        .filter(projectile -> projectile.hasMetadata(TRAIL_META))\n+        .forEach(\n+            projectile -> {\n+              if (projectile.isDead() || projectile.isOnGround()) {\n+                projectile.removeMetadata(TRAIL_META, PGM.get());\n+              } else {\n+                final Color color = (Color) projectile.getMetadata(TRAIL_META, PGM.get()).value();\n+\n+                match.getPlayers().stream()\n+                    .filter(\n+                        pl ->\n+                            pl.getSettings().getValue(SettingKey.EFFECTS)\n+                                == SettingValue.EFFECTS_ON)\n+                    .forEach(\n+                        player -> {\n+                          player\n+                              .getBukkit()\n+                              .spigot()\n+                              .playEffect(\n+                                  projectile.getLocation(),\n+                                  Effect.COLOURED_DUST,\n+                                  0,\n+                                  0,\n+                                  rgbToParticle(color.getRed()),\n+                                  rgbToParticle(color.getGreen()),\n+                                  rgbToParticle(color.getBlue()),\n+                                  1,\n+                                  0,\n+                                  50);\n+                        });\n+              }\n+            });\n+  }\n+\n+  private float rgbToParticle(int rgb) {\n+    return Math.max(0.001f, (rgb / 255.0f));\n+  }\n+\n+  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)\n+  public void onProjectileLaunch(ProjectileLaunchEvent event) {\n+    MatchPlayer player = match.getPlayer(event.getActor());\n+    if (player != null) {\n+      final Projectile projectile = event.getEntity();\n+      projectile.setMetadata(\n+          TRAIL_META, new FixedMetadataValue(PGM.get(), player.getParty().getFullColor()));\n+      // Set critical metadata to false in order to remove default particle trail.\n+      // The metadata will be restored just before the arrow hits something.\n+      if (projectile instanceof Arrow) {\n+        final Arrow arrow = (Arrow) projectile;\n+        arrow.setMetadata(CRITICAL_META, new FixedMetadataValue(PGM.get(), arrow.isCritical()));\n+        arrow.setCritical(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAxNjIxOA=="}, "originalCommit": {"oid": "c8cd056504cafe46a3092cf228fbfc94ff6e57e7"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ5OTMxNw==", "bodyText": "I don't think the crits can have colors, so you could just replace Effect.COLORED_DUST with the crit one for players with the setting toggled off?", "url": "https://github.com/PGMDev/PGM/pull/665#discussion_r498499317", "createdAt": "2020-10-01T20:36:05Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/modules/ProjectileTrailMatchModule.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package tc.oc.pgm.modules;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.bukkit.Color;\n+import org.bukkit.Effect;\n+import org.bukkit.entity.Arrow;\n+import org.bukkit.entity.Projectile;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.ProjectileHitEvent;\n+import org.bukkit.event.entity.ProjectileLaunchEvent;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.setting.SettingKey;\n+import tc.oc.pgm.api.setting.SettingValue;\n+import tc.oc.pgm.events.ListenerScope;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class ProjectileTrailMatchModule implements MatchModule, Listener {\n+\n+  private static final String TRAIL_META = \"projectile_trail_color\";\n+  private static final String CRITICAL_META = \"arrow_is_critical\";\n+\n+  private final Match match;\n+\n+  public ProjectileTrailMatchModule(Match match) {\n+    this.match = match;\n+    match\n+        .getExecutor(MatchScope.RUNNING)\n+        .scheduleAtFixedRate(this::checkMatchProjectiles, 0l, 50, TimeUnit.MILLISECONDS);\n+  }\n+\n+  public void checkMatchProjectiles() {\n+    match.getWorld().getEntitiesByClass(Projectile.class).stream()\n+        .filter(projectile -> projectile.hasMetadata(TRAIL_META))\n+        .forEach(\n+            projectile -> {\n+              if (projectile.isDead() || projectile.isOnGround()) {\n+                projectile.removeMetadata(TRAIL_META, PGM.get());\n+              } else {\n+                final Color color = (Color) projectile.getMetadata(TRAIL_META, PGM.get()).value();\n+\n+                match.getPlayers().stream()\n+                    .filter(\n+                        pl ->\n+                            pl.getSettings().getValue(SettingKey.EFFECTS)\n+                                == SettingValue.EFFECTS_ON)\n+                    .forEach(\n+                        player -> {\n+                          player\n+                              .getBukkit()\n+                              .spigot()\n+                              .playEffect(\n+                                  projectile.getLocation(),\n+                                  Effect.COLOURED_DUST,\n+                                  0,\n+                                  0,\n+                                  rgbToParticle(color.getRed()),\n+                                  rgbToParticle(color.getGreen()),\n+                                  rgbToParticle(color.getBlue()),\n+                                  1,\n+                                  0,\n+                                  50);\n+                        });\n+              }\n+            });\n+  }\n+\n+  private float rgbToParticle(int rgb) {\n+    return Math.max(0.001f, (rgb / 255.0f));\n+  }\n+\n+  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)\n+  public void onProjectileLaunch(ProjectileLaunchEvent event) {\n+    MatchPlayer player = match.getPlayer(event.getActor());\n+    if (player != null) {\n+      final Projectile projectile = event.getEntity();\n+      projectile.setMetadata(\n+          TRAIL_META, new FixedMetadataValue(PGM.get(), player.getParty().getFullColor()));\n+      // Set critical metadata to false in order to remove default particle trail.\n+      // The metadata will be restored just before the arrow hits something.\n+      if (projectile instanceof Arrow) {\n+        final Arrow arrow = (Arrow) projectile;\n+        arrow.setMetadata(CRITICAL_META, new FixedMetadataValue(PGM.get(), arrow.isCritical()));\n+        arrow.setCritical(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAxNjIxOA=="}, "originalCommit": {"oid": "c8cd056504cafe46a3092cf228fbfc94ff6e57e7"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUyNDc5OQ==", "bodyText": "How does it look with both the crit and color?\nMaybe simulate the critical effect as king says but to a less extent than vanilla does.", "url": "https://github.com/PGMDev/PGM/pull/665#discussion_r498524799", "createdAt": "2020-10-01T21:34:54Z", "author": {"login": "Pugzy"}, "path": "core/src/main/java/tc/oc/pgm/modules/ProjectileTrailMatchModule.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package tc.oc.pgm.modules;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.bukkit.Color;\n+import org.bukkit.Effect;\n+import org.bukkit.entity.Arrow;\n+import org.bukkit.entity.Projectile;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.ProjectileHitEvent;\n+import org.bukkit.event.entity.ProjectileLaunchEvent;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.setting.SettingKey;\n+import tc.oc.pgm.api.setting.SettingValue;\n+import tc.oc.pgm.events.ListenerScope;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class ProjectileTrailMatchModule implements MatchModule, Listener {\n+\n+  private static final String TRAIL_META = \"projectile_trail_color\";\n+  private static final String CRITICAL_META = \"arrow_is_critical\";\n+\n+  private final Match match;\n+\n+  public ProjectileTrailMatchModule(Match match) {\n+    this.match = match;\n+    match\n+        .getExecutor(MatchScope.RUNNING)\n+        .scheduleAtFixedRate(this::checkMatchProjectiles, 0l, 50, TimeUnit.MILLISECONDS);\n+  }\n+\n+  public void checkMatchProjectiles() {\n+    match.getWorld().getEntitiesByClass(Projectile.class).stream()\n+        .filter(projectile -> projectile.hasMetadata(TRAIL_META))\n+        .forEach(\n+            projectile -> {\n+              if (projectile.isDead() || projectile.isOnGround()) {\n+                projectile.removeMetadata(TRAIL_META, PGM.get());\n+              } else {\n+                final Color color = (Color) projectile.getMetadata(TRAIL_META, PGM.get()).value();\n+\n+                match.getPlayers().stream()\n+                    .filter(\n+                        pl ->\n+                            pl.getSettings().getValue(SettingKey.EFFECTS)\n+                                == SettingValue.EFFECTS_ON)\n+                    .forEach(\n+                        player -> {\n+                          player\n+                              .getBukkit()\n+                              .spigot()\n+                              .playEffect(\n+                                  projectile.getLocation(),\n+                                  Effect.COLOURED_DUST,\n+                                  0,\n+                                  0,\n+                                  rgbToParticle(color.getRed()),\n+                                  rgbToParticle(color.getGreen()),\n+                                  rgbToParticle(color.getBlue()),\n+                                  1,\n+                                  0,\n+                                  50);\n+                        });\n+              }\n+            });\n+  }\n+\n+  private float rgbToParticle(int rgb) {\n+    return Math.max(0.001f, (rgb / 255.0f));\n+  }\n+\n+  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)\n+  public void onProjectileLaunch(ProjectileLaunchEvent event) {\n+    MatchPlayer player = match.getPlayer(event.getActor());\n+    if (player != null) {\n+      final Projectile projectile = event.getEntity();\n+      projectile.setMetadata(\n+          TRAIL_META, new FixedMetadataValue(PGM.get(), player.getParty().getFullColor()));\n+      // Set critical metadata to false in order to remove default particle trail.\n+      // The metadata will be restored just before the arrow hits something.\n+      if (projectile instanceof Arrow) {\n+        final Arrow arrow = (Arrow) projectile;\n+        arrow.setMetadata(CRITICAL_META, new FixedMetadataValue(PGM.get(), arrow.isCritical()));\n+        arrow.setCritical(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAxNjIxOA=="}, "originalCommit": {"oid": "c8cd056504cafe46a3092cf228fbfc94ff6e57e7"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODU4MDEzNg==", "bodyText": "Oh that\u2019s actually a really cool idea. I\u2019ll experiment with that later and let you guys know the results.", "url": "https://github.com/PGMDev/PGM/pull/665#discussion_r498580136", "createdAt": "2020-10-02T01:06:21Z", "author": {"login": "applenick"}, "path": "core/src/main/java/tc/oc/pgm/modules/ProjectileTrailMatchModule.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package tc.oc.pgm.modules;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.bukkit.Color;\n+import org.bukkit.Effect;\n+import org.bukkit.entity.Arrow;\n+import org.bukkit.entity.Projectile;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.ProjectileHitEvent;\n+import org.bukkit.event.entity.ProjectileLaunchEvent;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.setting.SettingKey;\n+import tc.oc.pgm.api.setting.SettingValue;\n+import tc.oc.pgm.events.ListenerScope;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class ProjectileTrailMatchModule implements MatchModule, Listener {\n+\n+  private static final String TRAIL_META = \"projectile_trail_color\";\n+  private static final String CRITICAL_META = \"arrow_is_critical\";\n+\n+  private final Match match;\n+\n+  public ProjectileTrailMatchModule(Match match) {\n+    this.match = match;\n+    match\n+        .getExecutor(MatchScope.RUNNING)\n+        .scheduleAtFixedRate(this::checkMatchProjectiles, 0l, 50, TimeUnit.MILLISECONDS);\n+  }\n+\n+  public void checkMatchProjectiles() {\n+    match.getWorld().getEntitiesByClass(Projectile.class).stream()\n+        .filter(projectile -> projectile.hasMetadata(TRAIL_META))\n+        .forEach(\n+            projectile -> {\n+              if (projectile.isDead() || projectile.isOnGround()) {\n+                projectile.removeMetadata(TRAIL_META, PGM.get());\n+              } else {\n+                final Color color = (Color) projectile.getMetadata(TRAIL_META, PGM.get()).value();\n+\n+                match.getPlayers().stream()\n+                    .filter(\n+                        pl ->\n+                            pl.getSettings().getValue(SettingKey.EFFECTS)\n+                                == SettingValue.EFFECTS_ON)\n+                    .forEach(\n+                        player -> {\n+                          player\n+                              .getBukkit()\n+                              .spigot()\n+                              .playEffect(\n+                                  projectile.getLocation(),\n+                                  Effect.COLOURED_DUST,\n+                                  0,\n+                                  0,\n+                                  rgbToParticle(color.getRed()),\n+                                  rgbToParticle(color.getGreen()),\n+                                  rgbToParticle(color.getBlue()),\n+                                  1,\n+                                  0,\n+                                  50);\n+                        });\n+              }\n+            });\n+  }\n+\n+  private float rgbToParticle(int rgb) {\n+    return Math.max(0.001f, (rgb / 255.0f));\n+  }\n+\n+  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)\n+  public void onProjectileLaunch(ProjectileLaunchEvent event) {\n+    MatchPlayer player = match.getPlayer(event.getActor());\n+    if (player != null) {\n+      final Projectile projectile = event.getEntity();\n+      projectile.setMetadata(\n+          TRAIL_META, new FixedMetadataValue(PGM.get(), player.getParty().getFullColor()));\n+      // Set critical metadata to false in order to remove default particle trail.\n+      // The metadata will be restored just before the arrow hits something.\n+      if (projectile instanceof Arrow) {\n+        final Arrow arrow = (Arrow) projectile;\n+        arrow.setMetadata(CRITICAL_META, new FixedMetadataValue(PGM.get(), arrow.isCritical()));\n+        arrow.setCritical(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAxNjIxOA=="}, "originalCommit": {"oid": "c8cd056504cafe46a3092cf228fbfc94ff6e57e7"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5MjI2OA==", "bodyText": "Thanks again for the suggestion @KingOfSquares & @Pugzy.\nI adjusted it and works flawlessly \ud83d\udc4d Much better alternative to having them not show up at all.", "url": "https://github.com/PGMDev/PGM/pull/665#discussion_r499092268", "createdAt": "2020-10-02T23:54:08Z", "author": {"login": "applenick"}, "path": "core/src/main/java/tc/oc/pgm/modules/ProjectileTrailMatchModule.java", "diffHunk": "@@ -0,0 +1,110 @@\n+package tc.oc.pgm.modules;\n+\n+import java.util.concurrent.TimeUnit;\n+import org.bukkit.Color;\n+import org.bukkit.Effect;\n+import org.bukkit.entity.Arrow;\n+import org.bukkit.entity.Projectile;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.ProjectileHitEvent;\n+import org.bukkit.event.entity.ProjectileLaunchEvent;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.setting.SettingKey;\n+import tc.oc.pgm.api.setting.SettingValue;\n+import tc.oc.pgm.events.ListenerScope;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class ProjectileTrailMatchModule implements MatchModule, Listener {\n+\n+  private static final String TRAIL_META = \"projectile_trail_color\";\n+  private static final String CRITICAL_META = \"arrow_is_critical\";\n+\n+  private final Match match;\n+\n+  public ProjectileTrailMatchModule(Match match) {\n+    this.match = match;\n+    match\n+        .getExecutor(MatchScope.RUNNING)\n+        .scheduleAtFixedRate(this::checkMatchProjectiles, 0l, 50, TimeUnit.MILLISECONDS);\n+  }\n+\n+  public void checkMatchProjectiles() {\n+    match.getWorld().getEntitiesByClass(Projectile.class).stream()\n+        .filter(projectile -> projectile.hasMetadata(TRAIL_META))\n+        .forEach(\n+            projectile -> {\n+              if (projectile.isDead() || projectile.isOnGround()) {\n+                projectile.removeMetadata(TRAIL_META, PGM.get());\n+              } else {\n+                final Color color = (Color) projectile.getMetadata(TRAIL_META, PGM.get()).value();\n+\n+                match.getPlayers().stream()\n+                    .filter(\n+                        pl ->\n+                            pl.getSettings().getValue(SettingKey.EFFECTS)\n+                                == SettingValue.EFFECTS_ON)\n+                    .forEach(\n+                        player -> {\n+                          player\n+                              .getBukkit()\n+                              .spigot()\n+                              .playEffect(\n+                                  projectile.getLocation(),\n+                                  Effect.COLOURED_DUST,\n+                                  0,\n+                                  0,\n+                                  rgbToParticle(color.getRed()),\n+                                  rgbToParticle(color.getGreen()),\n+                                  rgbToParticle(color.getBlue()),\n+                                  1,\n+                                  0,\n+                                  50);\n+                        });\n+              }\n+            });\n+  }\n+\n+  private float rgbToParticle(int rgb) {\n+    return Math.max(0.001f, (rgb / 255.0f));\n+  }\n+\n+  @EventHandler(priority = EventPriority.HIGHEST, ignoreCancelled = true)\n+  public void onProjectileLaunch(ProjectileLaunchEvent event) {\n+    MatchPlayer player = match.getPlayer(event.getActor());\n+    if (player != null) {\n+      final Projectile projectile = event.getEntity();\n+      projectile.setMetadata(\n+          TRAIL_META, new FixedMetadataValue(PGM.get(), player.getParty().getFullColor()));\n+      // Set critical metadata to false in order to remove default particle trail.\n+      // The metadata will be restored just before the arrow hits something.\n+      if (projectile instanceof Arrow) {\n+        final Arrow arrow = (Arrow) projectile;\n+        arrow.setMetadata(CRITICAL_META, new FixedMetadataValue(PGM.get(), arrow.isCritical()));\n+        arrow.setCritical(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAxNjIxOA=="}, "originalCommit": {"oid": "c8cd056504cafe46a3092cf228fbfc94ff6e57e7"}, "originalPosition": 90}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 935, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}