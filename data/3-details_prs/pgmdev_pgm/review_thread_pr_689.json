{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzNjg5Nzgx", "number": 689, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMTozMjoyNFrOE0_Qcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQwNTo0NDoxMVrOFEVvag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzOTk3ODEwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/filters/MatchStateFilter.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMTozMjoyNFrOHtBM7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMDoxNjo1NlrOHuoGAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk2NzY2Mw==", "bodyText": "I don't get the obsession for a predicate here. Just use a Set<MatchPhase>", "url": "https://github.com/PGMDev/PGM/pull/689#discussion_r516967663", "createdAt": "2020-11-03T21:32:24Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/filters/MatchStateFilter.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package tc.oc.pgm.filters;\n+\n+import java.util.function.Predicate;\n+import tc.oc.pgm.api.filter.query.MatchQuery;\n+import tc.oc.pgm.api.match.Match;\n+\n+public class MatchStateFilter extends TypedFilter<MatchQuery> {\n+\n+  private final Predicate<Match> matchPredicate;\n+\n+  public MatchStateFilter(Predicate<Match> matchPredicate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8fe28b830c056e474e342fb30e17665ba641f30"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxOTE2OA==", "bodyText": "See my other comment, this constructor can then be MatchPhaseFilter(MatchPhase)", "url": "https://github.com/PGMDev/PGM/pull/689#discussion_r517419168", "createdAt": "2020-11-04T15:17:10Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/filters/MatchStateFilter.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package tc.oc.pgm.filters;\n+\n+import java.util.function.Predicate;\n+import tc.oc.pgm.api.filter.query.MatchQuery;\n+import tc.oc.pgm.api.match.Match;\n+\n+public class MatchStateFilter extends TypedFilter<MatchQuery> {\n+\n+  private final Predicate<Match> matchPredicate;\n+\n+  public MatchStateFilter(Predicate<Match> matchPredicate) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk2NzY2Mw=="}, "originalCommit": {"oid": "c8fe28b830c056e474e342fb30e17665ba641f30"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODY1MzQ0MQ==", "bodyText": "Yes! Predicate was an old thing before i actually used all MatchPhases (was using method refrences instead like Match::isRunning etc.)", "url": "https://github.com/PGMDev/PGM/pull/689#discussion_r518653441", "createdAt": "2020-11-06T10:16:56Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/filters/MatchStateFilter.java", "diffHunk": "@@ -0,0 +1,24 @@\n+package tc.oc.pgm.filters;\n+\n+import java.util.function.Predicate;\n+import tc.oc.pgm.api.filter.query.MatchQuery;\n+import tc.oc.pgm.api.match.Match;\n+\n+public class MatchStateFilter extends TypedFilter<MatchQuery> {\n+\n+  private final Predicate<Match> matchPredicate;\n+\n+  public MatchStateFilter(Predicate<Match> matchPredicate) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk2NzY2Mw=="}, "originalCommit": {"oid": "c8fe28b830c056e474e342fb30e17665ba641f30"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MjkyOTEzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/filters/FilterParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxNjoyN1rOHtcujw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxNToxNjoyN1rOHtcujw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQxODYzOQ==", "bodyText": "Seems like this should be a private function parseMatchPhase(String) -> MatchPhase", "url": "https://github.com/PGMDev/PGM/pull/689#discussion_r517418639", "createdAt": "2020-11-04T15:16:27Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/filters/FilterParser.java", "diffHunk": "@@ -443,4 +446,52 @@ public StructuralLoadFilter parseStructuralLoad(Element el) throws InvalidXMLExc\n   public TimeFilter parseTimeFilter(Element el) throws InvalidXMLException {\n     return new TimeFilter(XMLUtils.parseDuration(el, null));\n   }\n+\n+  @MethodParser(\"match-state\")\n+  public MatchStateFilter parseMatchState(Element el) throws InvalidXMLException {\n+    return parseMatchStateFilter(el.getValue(), el);\n+  }\n+\n+  @MethodParser(\"match-started\")\n+  public MatchStateFilter parseMatchStarted(Element el) throws InvalidXMLException {\n+    return parseMatchStateFilter(\"started\", el);\n+  }\n+\n+  @MethodParser(\"match-running\")\n+  public MatchStateFilter parseMatchRunning(Element el) throws InvalidXMLException {\n+    return parseMatchStateFilter(\"running\", el);\n+  }\n+\n+  @MethodParser(\"match-finished\")\n+  public MatchStateFilter parseMatchFinished(Element el) throws InvalidXMLException {\n+    return parseMatchStateFilter(\"finished\", el);\n+  }\n+\n+  public MatchStateFilter parseMatchStateFilter(String matchState, Element el)\n+      throws InvalidXMLException {\n+\n+    Predicate<Match> matchPredicate = null;\n+\n+    switch (matchState) {\n+      case \"running\":\n+        matchPredicate = m -> m.getPhase() == MatchPhase.RUNNING;\n+        break;\n+      case \"finished\":\n+        matchPredicate = m -> m.getPhase() == MatchPhase.FINISHED;\n+        break;\n+      case \"starting\":\n+        matchPredicate = m -> m.getPhase() == MatchPhase.STARTING;\n+        break;\n+      case \"before\":\n+        matchPredicate = m -> m.getPhase() == MatchPhase.IDLE;\n+        break;\n+      case \"started\":\n+        matchPredicate =\n+            m -> m.getPhase() == MatchPhase.RUNNING || m.getPhase() == MatchPhase.FINISHED;\n+    }\n+    if (matchPredicate == null)\n+      throw new InvalidXMLException(\"Invalid or no match state found\", el);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c8fe28b830c056e474e342fb30e17665ba641f30"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2OTQ0ODk3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/filters/FilterParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNzoxOTo0NlrOHxWukw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxMDowNDoyN1rOHyoKnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUxNDY0Mw==", "bodyText": "I have an idea to make this easier:\n\nChange the signature of parseMatchPhaseFilter return a generic Filter\nChange MatchPhaseFilter to only accept 1 MatchPhase and not a Set\nFor the \"started\" case, return an OrFilter(MatchPhaseFilter(RUNNING), MatchPhaseFilter(FINISHED))\n\nSee what I'm getting at?", "url": "https://github.com/PGMDev/PGM/pull/689#discussion_r521514643", "createdAt": "2020-11-11T17:19:46Z", "author": {"login": "Electroid"}, "path": "core/src/main/java/tc/oc/pgm/filters/FilterParser.java", "diffHunk": "@@ -443,4 +442,52 @@ public StructuralLoadFilter parseStructuralLoad(Element el) throws InvalidXMLExc\n   public TimeFilter parseTimeFilter(Element el) throws InvalidXMLException {\n     return new TimeFilter(XMLUtils.parseDuration(el, null));\n   }\n+\n+  @MethodParser(\"match-phase\")\n+  public MatchPhaseFilter parseMatchPhase(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(el.getValue(), el);\n+  }\n+\n+  @MethodParser(\"match-started\")\n+  public MatchPhaseFilter parseMatchStarted(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"started\", el);\n+  }\n+\n+  @MethodParser(\"match-running\")\n+  public MatchPhaseFilter parseMatchRunning(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"running\", el);\n+  }\n+\n+  @MethodParser(\"match-finished\")\n+  public MatchPhaseFilter parseMatchFinished(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"finished\", el);\n+  }\n+\n+  private MatchPhaseFilter parseMatchPhaseFilter(String matchState, Element el)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee908b4f1f1b88727c69e937abf73d8544c4490c"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjg0ODkyNA==", "bodyText": "Yes! Great idea \ud83d\udc4d", "url": "https://github.com/PGMDev/PGM/pull/689#discussion_r522848924", "createdAt": "2020-11-13T10:04:27Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/filters/FilterParser.java", "diffHunk": "@@ -443,4 +442,52 @@ public StructuralLoadFilter parseStructuralLoad(Element el) throws InvalidXMLExc\n   public TimeFilter parseTimeFilter(Element el) throws InvalidXMLException {\n     return new TimeFilter(XMLUtils.parseDuration(el, null));\n   }\n+\n+  @MethodParser(\"match-phase\")\n+  public MatchPhaseFilter parseMatchPhase(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(el.getValue(), el);\n+  }\n+\n+  @MethodParser(\"match-started\")\n+  public MatchPhaseFilter parseMatchStarted(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"started\", el);\n+  }\n+\n+  @MethodParser(\"match-running\")\n+  public MatchPhaseFilter parseMatchRunning(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"running\", el);\n+  }\n+\n+  @MethodParser(\"match-finished\")\n+  public MatchPhaseFilter parseMatchFinished(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"finished\", el);\n+  }\n+\n+  private MatchPhaseFilter parseMatchPhaseFilter(String matchState, Element el)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTUxNDY0Mw=="}, "originalCommit": {"oid": "ee908b4f1f1b88727c69e937abf73d8544c4490c"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQwMDk0ODI2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/filters/FilterParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQwNTo0NDoxMVrOIEbEXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMlQwNTo0NDoxMVrOIEbEXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTUwODcwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  case \"running\":\n          \n          \n            \n                    matchPhase = MatchPhase.RUNNING;\n          \n          \n            \n                    break;\n          \n          \n            \n                  case \"finished\":\n          \n          \n            \n                    matchPhase = MatchPhase.FINISHED;\n          \n          \n            \n                    break;\n          \n          \n            \n                  case \"starting\":\n          \n          \n            \n                    matchPhase = MatchPhase.STARTING;\n          \n          \n            \n                    break;\n          \n          \n            \n                  case \"idle\":\n          \n          \n            \n                    matchPhase = MatchPhase.IDLE;\n          \n          \n            \n                    break;\n          \n          \n            \n                  case \"started\":\n          \n          \n            \n                    return AnyFilter.of(\n          \n          \n            \n                        new MatchPhaseFilter(MatchPhase.RUNNING), new MatchPhaseFilter(MatchPhase.FINISHED));\n          \n          \n            \n                  case \"running\": return MatchPhaseFilter.RUNNING;\n          \n          \n            \n                  case \"finished\": return MatchPhaseFilter.FINISHED;\n          \n          \n            \n                // ...\n          \n      \n    \n    \n  \n\nAs suggested in discord you should make static final fields in MatchPhaseFilter and reuse the same instances", "url": "https://github.com/PGMDev/PGM/pull/689#discussion_r541508702", "createdAt": "2020-12-12T05:44:11Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/filters/FilterParser.java", "diffHunk": "@@ -453,4 +454,50 @@ public TimeFilter parseTimeFilter(Element el) throws InvalidXMLException {\n   public ScoreFilter parseScoreFilter(Element el) throws InvalidXMLException {\n     return new ScoreFilter(XMLUtils.parseNumericRange(new Node(el), Integer.class));\n   }\n+\n+  @MethodParser(\"match-phase\")\n+  public Filter parseMatchPhase(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(el.getValue(), el);\n+  }\n+\n+  @MethodParser(\"match-started\")\n+  public Filter parseMatchStarted(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"started\", el);\n+  }\n+\n+  @MethodParser(\"match-running\")\n+  public Filter parseMatchRunning(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"running\", el);\n+  }\n+\n+  @MethodParser(\"match-finished\")\n+  public Filter parseMatchFinished(Element el) throws InvalidXMLException {\n+    return parseMatchPhaseFilter(\"finished\", el);\n+  }\n+\n+  private Filter parseMatchPhaseFilter(String matchState, Element el) throws InvalidXMLException {\n+\n+    MatchPhase matchPhase = null;\n+\n+    switch (matchState) {\n+      case \"running\":\n+        matchPhase = MatchPhase.RUNNING;\n+        break;\n+      case \"finished\":\n+        matchPhase = MatchPhase.FINISHED;\n+        break;\n+      case \"starting\":\n+        matchPhase = MatchPhase.STARTING;\n+        break;\n+      case \"idle\":\n+        matchPhase = MatchPhase.IDLE;\n+        break;\n+      case \"started\":\n+        return AnyFilter.of(\n+            new MatchPhaseFilter(MatchPhase.RUNNING), new MatchPhaseFilter(MatchPhase.FINISHED));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1c4874cf8de3b511926688ba0708fb0e2efe288e"}, "originalPosition": 52}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 946, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}