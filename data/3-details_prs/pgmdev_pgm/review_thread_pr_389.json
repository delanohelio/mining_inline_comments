{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1OTIwNzY5", "number": 389, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjoyNjozMFrODs4F3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwODozOTo1MlrODtASkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MzgyOTQzOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/api/Modules.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjoyNjozMFrOF9-hBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQyMjoyNjozMFrOF9-hBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUzMTcxNw==", "bodyText": "Should be MatchModule and not Module", "url": "https://github.com/PGMDev/PGM/pull/389#discussion_r400531717", "createdAt": "2020-03-30T22:26:30Z", "author": {"login": "KingOfSquares"}, "path": "core/src/main/java/tc/oc/pgm/api/Modules.java", "diffHunk": "@@ -159,6 +160,7 @@ static void registerAll() {\n     register(ObserverToolsMatchModule.class, new ObserverToolsMatchModule.Factory());\n     register(FireworkMatchModule.class, FireworkMatchModule::new);\n     register(StatsMatchModule.class, StatsMatchModule::new);\n+    register(TeamRestrictModule.class, TeamRestrictModule::new);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6241f452023ab46db8a607518c62062b4f77289c"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NTE3MjY0OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/tc/oc/pgm/modules/TeamRestrictMatchModule.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwODozOTo1MlrOF-LL1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QyMzo0NjozOVrOGAsxXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczOTI4NA==", "bodyText": "If you won't return the party unless it's a team, why don't you just store teams to start with?", "url": "https://github.com/PGMDev/PGM/pull/389#discussion_r400739284", "createdAt": "2020-03-31T08:39:52Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/modules/TeamRestrictMatchModule.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package tc.oc.pgm.modules;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.party.Party;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.events.PlayerJoinPartyEvent;\n+import tc.oc.pgm.teams.Team;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class TeamRestrictMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+  private final Map<UUID, Party> playerTeamMap = new HashMap<>();\n+\n+  public TeamRestrictMatchModule(Match match) {\n+    this.match = match;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void addPlayerToMatch(PlayerJoinPartyEvent event) {\n+    UUID playerID = event.getPlayer().getId();\n+    if (playerTeamMap.containsKey(playerID)\n+        && !event\n+            .getNewParty()\n+            .isObserving()) { // If player was previously on team but joins obs, keep previous team\n+      playerTeamMap.replace(playerID, event.getNewParty());\n+\n+    } else if (!playerTeamMap.containsKey(playerID)) {\n+      playerTeamMap.put(playerID, event.getNewParty());\n+    }\n+  }\n+\n+  public Map<UUID, Party> getPlayerTeamMap() {\n+    return playerTeamMap;\n+  }\n+\n+  public Team getLastTeam(UUID id) {\n+    Party lastParty = playerTeamMap.get(id);\n+    if (lastParty instanceof Team) {\n+      return (Team) lastParty;\n+    } else {\n+      return null;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0eaa6500e838cd9c3185aacd19e837b517280fe"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg2MzI3Nw==", "bodyText": "PlayerJoinPartyEvent returns a specific party, plus for FFA matches, you don't want to restrict someone joining. This way, only if its a team based match, will someone be restricted.", "url": "https://github.com/PGMDev/PGM/pull/389#discussion_r400863277", "createdAt": "2020-03-31T12:13:57Z", "author": {"login": "EricZeiberg"}, "path": "core/src/main/java/tc/oc/pgm/modules/TeamRestrictMatchModule.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package tc.oc.pgm.modules;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.party.Party;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.events.PlayerJoinPartyEvent;\n+import tc.oc.pgm.teams.Team;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class TeamRestrictMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+  private final Map<UUID, Party> playerTeamMap = new HashMap<>();\n+\n+  public TeamRestrictMatchModule(Match match) {\n+    this.match = match;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void addPlayerToMatch(PlayerJoinPartyEvent event) {\n+    UUID playerID = event.getPlayer().getId();\n+    if (playerTeamMap.containsKey(playerID)\n+        && !event\n+            .getNewParty()\n+            .isObserving()) { // If player was previously on team but joins obs, keep previous team\n+      playerTeamMap.replace(playerID, event.getNewParty());\n+\n+    } else if (!playerTeamMap.containsKey(playerID)) {\n+      playerTeamMap.put(playerID, event.getNewParty());\n+    }\n+  }\n+\n+  public Map<UUID, Party> getPlayerTeamMap() {\n+    return playerTeamMap;\n+  }\n+\n+  public Team getLastTeam(UUID id) {\n+    Party lastParty = playerTeamMap.get(id);\n+    if (lastParty instanceof Team) {\n+      return (Team) lastParty;\n+    } else {\n+      return null;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczOTI4NA=="}, "originalCommit": {"oid": "c0eaa6500e838cd9c3185aacd19e837b517280fe"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTUyMjA1OA==", "bodyText": "That wasn't my point. The idea is, instead of storing a Map<UUID, Party>, you should just store teams in a Map<UUID, Team> and ignore all of the adding logic if it isn't a team. Instead of testing for the type of party afterwards, test for it beforehand.", "url": "https://github.com/PGMDev/PGM/pull/389#discussion_r401522058", "createdAt": "2020-04-01T10:43:26Z", "author": {"login": "Pablete1234"}, "path": "core/src/main/java/tc/oc/pgm/modules/TeamRestrictMatchModule.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package tc.oc.pgm.modules;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.party.Party;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.events.PlayerJoinPartyEvent;\n+import tc.oc.pgm.teams.Team;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class TeamRestrictMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+  private final Map<UUID, Party> playerTeamMap = new HashMap<>();\n+\n+  public TeamRestrictMatchModule(Match match) {\n+    this.match = match;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void addPlayerToMatch(PlayerJoinPartyEvent event) {\n+    UUID playerID = event.getPlayer().getId();\n+    if (playerTeamMap.containsKey(playerID)\n+        && !event\n+            .getNewParty()\n+            .isObserving()) { // If player was previously on team but joins obs, keep previous team\n+      playerTeamMap.replace(playerID, event.getNewParty());\n+\n+    } else if (!playerTeamMap.containsKey(playerID)) {\n+      playerTeamMap.put(playerID, event.getNewParty());\n+    }\n+  }\n+\n+  public Map<UUID, Party> getPlayerTeamMap() {\n+    return playerTeamMap;\n+  }\n+\n+  public Team getLastTeam(UUID id) {\n+    Party lastParty = playerTeamMap.get(id);\n+    if (lastParty instanceof Team) {\n+      return (Team) lastParty;\n+    } else {\n+      return null;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczOTI4NA=="}, "originalCommit": {"oid": "c0eaa6500e838cd9c3185aacd19e837b517280fe"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM4NjcxNw==", "bodyText": "Fixed, thanks.", "url": "https://github.com/PGMDev/PGM/pull/389#discussion_r403386717", "createdAt": "2020-04-03T23:46:39Z", "author": {"login": "EricZeiberg"}, "path": "core/src/main/java/tc/oc/pgm/modules/TeamRestrictMatchModule.java", "diffHunk": "@@ -0,0 +1,53 @@\n+package tc.oc.pgm.modules;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.party.Party;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.events.PlayerJoinPartyEvent;\n+import tc.oc.pgm.teams.Team;\n+\n+@ListenerScope(MatchScope.LOADED)\n+public class TeamRestrictMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n+  private final Map<UUID, Party> playerTeamMap = new HashMap<>();\n+\n+  public TeamRestrictMatchModule(Match match) {\n+    this.match = match;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void addPlayerToMatch(PlayerJoinPartyEvent event) {\n+    UUID playerID = event.getPlayer().getId();\n+    if (playerTeamMap.containsKey(playerID)\n+        && !event\n+            .getNewParty()\n+            .isObserving()) { // If player was previously on team but joins obs, keep previous team\n+      playerTeamMap.replace(playerID, event.getNewParty());\n+\n+    } else if (!playerTeamMap.containsKey(playerID)) {\n+      playerTeamMap.put(playerID, event.getNewParty());\n+    }\n+  }\n+\n+  public Map<UUID, Party> getPlayerTeamMap() {\n+    return playerTeamMap;\n+  }\n+\n+  public Team getLastTeam(UUID id) {\n+    Party lastParty = playerTeamMap.get(id);\n+    if (lastParty instanceof Team) {\n+      return (Team) lastParty;\n+    } else {\n+      return null;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDczOTI4NA=="}, "originalCommit": {"oid": "c0eaa6500e838cd9c3185aacd19e837b517280fe"}, "originalPosition": 51}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1063, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}