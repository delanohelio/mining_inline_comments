{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NzU3NzYw", "number": 1079, "title": "Add support to detect and self-heal inconsistent topic replication factor", "bodyText": "Addresses the issue #1071 .", "createdAt": "2020-01-27T23:36:24Z", "url": "https://github.com/linkedin/cruise-control/pull/1079", "merged": true, "mergeCommit": {"oid": "ac2140f5a583d1cda24be6e715996293106bb286"}, "closed": true, "closedAt": "2020-02-21T21:58:35Z", "author": {"login": "kidkun"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcA2IR8ABqjMwMDQyNTUwMjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcGj44VAH2gAyMzY3NzU3NzYwOmRmZmQ3ZmYzOTJiOGRmNmUzOTM3OThkODlmMjM4NGY0MzVlYTJiOGY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fff3a788f7e3afc151b89f0fbe173e207827ba0f", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/fff3a788f7e3afc151b89f0fbe173e207827ba0f", "committedDate": "2020-01-27T23:34:49Z", "message": "Add support to detect and self-heal inconsistent topic replication factor."}, "afterCommit": {"oid": "48f8f0f90e56869bc5bed19d04983bea8aba7f24", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/48f8f0f90e56869bc5bed19d04983bea8aba7f24", "committedDate": "2020-02-04T00:07:12Z", "message": "Add support to detect and self-heal inconsistent topic replication factor."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNjYxMzk5", "url": "https://github.com/linkedin/cruise-control/pull/1079#pullrequestreview-352661399", "createdAt": "2020-02-04T00:44:23Z", "commit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMDo0NDoyM1rOFlE4lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMjozODo0OFrOFlGgFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyMTY1NQ==", "bodyText": "Nit: Can we put these *AnomalyDetectionIntervalMs to a map per anomaly type?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374421655", "createdAt": "2020-02-04T00:44:23Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetector.java", "diffHunk": "@@ -60,10 +60,12 @@\n   private final BrokerFailureDetector _brokerFailureDetector;\n   private final MetricAnomalyDetector _metricAnomalyDetector;\n   private final DiskFailureDetector _diskFailureDetector;\n+  private final TopicAnomalyDetector _topicAnomalyDetector;\n   private final ScheduledExecutorService _detectorScheduler;\n   private final long _goalViolationDetectionIntervalMs;\n   private final long _diskFailureDetectionIntervalMs;\n   private final long _metricAnomalyDetectionIntervalMs;\n+  private final long _topicAnomalyDetectionIntervalMs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNjI0NQ==", "bodyText": "Can we be more verbose on what a topic anomaly means?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374426245", "createdAt": "2020-02-04T01:02:13Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomaly.java", "diffHunk": "@@ -0,0 +1,19 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.detector.AnomalyType;\n+\n+import static com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType.TOPIC_ANOMALY;\n+\n+/**\n+ * The interface for a topic anomaly.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNzc0OQ==", "bodyText": "The logic of this function seems to be commonly used by the other anomaly detectors. Is it possible to combine their common logic in a parameterized util function?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374427749", "createdAt": "2020-02-04T01:08:30Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyDetector.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.detector.Anomaly;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Queue;\n+import java.util.Set;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.MAX_METADATA_WAIT_MS;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.shouldSkipAnomalyDetection;\n+\n+/**\n+ * This class will be scheduled to periodically check if {@link TopicAnomalyFinder} identifies a topic anomaly.\n+ * An alert will be triggered if one of the desired topic property is not met.\n+ */\n+public class TopicAnomalyDetector implements Runnable {\n+  private static final Logger LOG = LoggerFactory.getLogger(TopicAnomalyDetector.class);\n+  private final Queue<Anomaly> _anomalies;\n+  private final KafkaCruiseControl _kafkaCruiseControl;\n+  private final List<TopicAnomalyFinder> _topicAnomalyFinders;\n+\n+  TopicAnomalyDetector(Queue<Anomaly> anomalies,\n+                       KafkaCruiseControl kafkaCruiseControl) {\n+    _anomalies = anomalies;\n+    _kafkaCruiseControl = kafkaCruiseControl;\n+    Map<String, Object> configWithCruiseControlObject = Collections.singletonMap(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG,\n+                                                                                 kafkaCruiseControl);\n+    _topicAnomalyFinders = kafkaCruiseControl.config().getConfiguredInstances(AnomalyDetectorConfig.TOPIC_ANOMALY_FINDER_CLASSES_CONFIG,\n+                                                                              TopicAnomalyFinder.class,\n+                                                                              configWithCruiseControlObject);\n+  }\n+\n+  /**\n+   * Skip topic anomaly detection if any of the following is true:\n+   * <ul>\n+   *  <li>There is offline replicas in the cluster, which means there is dead brokers/disks. In this case\n+   * {@link BrokerFailureDetector} or {@link DiskFailureDetector} should take care of the anomaly.</li>\n+   *  <li>{@link AnomalyDetectorUtils#shouldSkipAnomalyDetection(KafkaCruiseControl)} returns true.\n+   * </ul>\n+   *\n+   * @return True to skip topic anomaly detection based on the current state, false otherwise.\n+   */\n+  private boolean shouldSkipMetricAnomalyDetection() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyODgxOQ==", "bodyText": "Why is this a list -- i.e. what is the implied ordering of anomalies? If the ordering does not matter, can we avoid using a list?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374428819", "createdAt": "2020-02-04T01:12:40Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.CruiseControlConfigurable;\n+import java.util.List;\n+import org.apache.yetus.audience.InterfaceStability;\n+\n+\n+/**\n+ * The finder which checks topics against certain desired topic property to identify topic anomaly.\n+ */\n+@InterfaceStability.Evolving\n+public interface  TopicAnomalyFinder extends CruiseControlConfigurable {\n+\n+  /**\n+   * Get a list of topic anomalies for topics which are misconfigured or violate some desired property.\n+   * @return List of topic anomalies.\n+   */\n+  List<TopicAnomaly> topicAnomalies();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMDQwMw==", "bodyText": "Can we add explanation of the configs to the JavaDoc?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374430403", "createdAt": "2020-02-04T01:19:01Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMTM0Mg==", "bodyText": "Should this be a static function in some utils class with a corresponding unit test?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374431342", "createdAt": "2020-02-04T01:22:51Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType;\n+import com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.UpdateTopicConfigurationRunnable;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.regex.Pattern;\n+\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getSelfHealingGoalNames;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.extractKafkaCruiseControlObjectFromConfig;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType.TOPIC_ANOMALY;\n+\n+\n+/**\n+ * Topics which contain at least one partition with replication factor not equal to the config value of\n+ * {@link com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder#SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}\n+ */\n+public class TopicReplicationFactorAnomaly extends TopicAnomaly {\n+  protected Short _targetReplicationFactor;\n+  protected Set<String> _topicsWithBadReplicationFactor;\n+  protected UpdateTopicConfigurationRunnable _updateTopicConfigurationRunnable;\n+\n+  @Override\n+  public boolean fix() throws Exception {\n+    _optimizationResult = _updateTopicConfigurationRunnable.getResult();\n+    boolean hasProposalsToFix = hasProposalsToFix();\n+    // Ensure that only the relevant response is cached to avoid memory pressure.\n+    _optimizationResult.discardIrrelevantAndCacheJsonAndPlaintext();\n+    return hasProposalsToFix;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    super.configure(configs);\n+    KafkaCruiseControl kafkaCruiseControl = extractKafkaCruiseControlObjectFromConfig(configs, KafkaAnomalyType.TOPIC_ANOMALY);\n+    KafkaCruiseControlConfig config = kafkaCruiseControl.config();\n+    _topicsWithBadReplicationFactor = (Set<String>) configs.get(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG);\n+    if (_topicsWithBadReplicationFactor == null || _topicsWithBadReplicationFactor.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\", TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG));\n+    }\n+    _targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    if (_targetReplicationFactor == null) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\",\n+                                                       SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG));\n+    }\n+    boolean allowCapacityEstimation = config.getBoolean(ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG);\n+    boolean excludeRecentlyDemotedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG);\n+    boolean excludeRecentlyRemovedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG);\n+    _updateTopicConfigurationRunnable = new UpdateTopicConfigurationRunnable(kafkaCruiseControl,\n+                                                                             Collections.singletonMap(_targetReplicationFactor,\n+                                                                                                      buildTopicRegex(_topicsWithBadReplicationFactor)),\n+                                                                             getSelfHealingGoalNames(config),\n+                                                                             allowCapacityEstimation,\n+                                                                             excludeRecentlyDemotedBrokers,\n+                                                                             excludeRecentlyRemovedBrokers,\n+                                                                             _anomalyId.toString(),\n+                                                                             String.format(\"Self healing for %s: %s\", TOPIC_ANOMALY, this));\n+\n+  }\n+\n+  private Pattern buildTopicRegex(Set<String> topics) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMzExNw==", "bodyText": "I am curious why we need these parentheses? Aren't they redundant?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374433117", "createdAt": "2020-02-04T01:30:52Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType;\n+import com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.UpdateTopicConfigurationRunnable;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.regex.Pattern;\n+\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getSelfHealingGoalNames;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.extractKafkaCruiseControlObjectFromConfig;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType.TOPIC_ANOMALY;\n+\n+\n+/**\n+ * Topics which contain at least one partition with replication factor not equal to the config value of\n+ * {@link com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder#SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}\n+ */\n+public class TopicReplicationFactorAnomaly extends TopicAnomaly {\n+  protected Short _targetReplicationFactor;\n+  protected Set<String> _topicsWithBadReplicationFactor;\n+  protected UpdateTopicConfigurationRunnable _updateTopicConfigurationRunnable;\n+\n+  @Override\n+  public boolean fix() throws Exception {\n+    _optimizationResult = _updateTopicConfigurationRunnable.getResult();\n+    boolean hasProposalsToFix = hasProposalsToFix();\n+    // Ensure that only the relevant response is cached to avoid memory pressure.\n+    _optimizationResult.discardIrrelevantAndCacheJsonAndPlaintext();\n+    return hasProposalsToFix;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    super.configure(configs);\n+    KafkaCruiseControl kafkaCruiseControl = extractKafkaCruiseControlObjectFromConfig(configs, KafkaAnomalyType.TOPIC_ANOMALY);\n+    KafkaCruiseControlConfig config = kafkaCruiseControl.config();\n+    _topicsWithBadReplicationFactor = (Set<String>) configs.get(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG);\n+    if (_topicsWithBadReplicationFactor == null || _topicsWithBadReplicationFactor.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\", TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG));\n+    }\n+    _targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    if (_targetReplicationFactor == null) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\",\n+                                                       SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG));\n+    }\n+    boolean allowCapacityEstimation = config.getBoolean(ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG);\n+    boolean excludeRecentlyDemotedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG);\n+    boolean excludeRecentlyRemovedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG);\n+    _updateTopicConfigurationRunnable = new UpdateTopicConfigurationRunnable(kafkaCruiseControl,\n+                                                                             Collections.singletonMap(_targetReplicationFactor,\n+                                                                                                      buildTopicRegex(_topicsWithBadReplicationFactor)),\n+                                                                             getSelfHealingGoalNames(config),\n+                                                                             allowCapacityEstimation,\n+                                                                             excludeRecentlyDemotedBrokers,\n+                                                                             excludeRecentlyRemovedBrokers,\n+                                                                             _anomalyId.toString(),\n+                                                                             String.format(\"Self healing for %s: %s\", TOPIC_ANOMALY, this));\n+\n+  }\n+\n+  private Pattern buildTopicRegex(Set<String> topics) {\n+    StringJoiner sj = new StringJoiner(\"|\");\n+    topics.forEach(sj::add);\n+    return Pattern.compile(\"(\" + sj.toString() + \")\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMzUyMw==", "bodyText": "The meaning of the following sentence is not clear: Detected follow topics...", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374433523", "createdAt": "2020-02-04T01:32:45Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType;\n+import com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.UpdateTopicConfigurationRunnable;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.regex.Pattern;\n+\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getSelfHealingGoalNames;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.extractKafkaCruiseControlObjectFromConfig;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType.TOPIC_ANOMALY;\n+\n+\n+/**\n+ * Topics which contain at least one partition with replication factor not equal to the config value of\n+ * {@link com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder#SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}\n+ */\n+public class TopicReplicationFactorAnomaly extends TopicAnomaly {\n+  protected Short _targetReplicationFactor;\n+  protected Set<String> _topicsWithBadReplicationFactor;\n+  protected UpdateTopicConfigurationRunnable _updateTopicConfigurationRunnable;\n+\n+  @Override\n+  public boolean fix() throws Exception {\n+    _optimizationResult = _updateTopicConfigurationRunnable.getResult();\n+    boolean hasProposalsToFix = hasProposalsToFix();\n+    // Ensure that only the relevant response is cached to avoid memory pressure.\n+    _optimizationResult.discardIrrelevantAndCacheJsonAndPlaintext();\n+    return hasProposalsToFix;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    super.configure(configs);\n+    KafkaCruiseControl kafkaCruiseControl = extractKafkaCruiseControlObjectFromConfig(configs, KafkaAnomalyType.TOPIC_ANOMALY);\n+    KafkaCruiseControlConfig config = kafkaCruiseControl.config();\n+    _topicsWithBadReplicationFactor = (Set<String>) configs.get(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG);\n+    if (_topicsWithBadReplicationFactor == null || _topicsWithBadReplicationFactor.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\", TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG));\n+    }\n+    _targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    if (_targetReplicationFactor == null) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\",\n+                                                       SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG));\n+    }\n+    boolean allowCapacityEstimation = config.getBoolean(ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG);\n+    boolean excludeRecentlyDemotedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG);\n+    boolean excludeRecentlyRemovedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG);\n+    _updateTopicConfigurationRunnable = new UpdateTopicConfigurationRunnable(kafkaCruiseControl,\n+                                                                             Collections.singletonMap(_targetReplicationFactor,\n+                                                                                                      buildTopicRegex(_topicsWithBadReplicationFactor)),\n+                                                                             getSelfHealingGoalNames(config),\n+                                                                             allowCapacityEstimation,\n+                                                                             excludeRecentlyDemotedBrokers,\n+                                                                             excludeRecentlyRemovedBrokers,\n+                                                                             _anomalyId.toString(),\n+                                                                             String.format(\"Self healing for %s: %s\", TOPIC_ANOMALY, this));\n+\n+  }\n+\n+  private Pattern buildTopicRegex(Set<String> topics) {\n+    StringJoiner sj = new StringJoiner(\"|\");\n+    topics.forEach(sj::add);\n+    return Pattern.compile(\"(\" + sj.toString() + \")\");\n+  }\n+\n+  @Override\n+  public String toString() {\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(\"{Detected follow topics have at least one partition with replication factor other than \")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNDMwNQ==", "bodyText": "Can we avoid wildcard import?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374434305", "createdAt": "2020-02-04T01:36:01Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNTU3NQ==", "bodyText": "This is a potentially disruptive config -- i.e. if the user forgets setting the value for the target self healing replication factor and enable self healing for all anomaly types, it may cause unintended changes in RF in clusters, where the intended RF != 3.\nTo avoid this scenario, should we make this a required config? -- i.e. we can have a sanity check that fails if the user does not provide a value for this config when this pluggable anomaly finder is used upon configuration time.", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374435575", "createdAt": "2020-02-04T01:41:29Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNjI1MA==", "bodyText": "Can we define what each parameter corresponds to? c and t are not descriptive for a public util function.", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374436250", "createdAt": "2020-02-04T01:44:27Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfigUtils.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.config;\n+\n+import com.linkedin.cruisecontrol.common.CruiseControlConfigurable;\n+import java.util.Map;\n+\n+\n+public class KafkaCruiseControlConfigUtils {\n+\n+  private KafkaCruiseControlConfigUtils() {\n+\n+  }\n+\n+  /**\n+   * @return Configured instance.\n+   */\n+  public static <T> T getConfiguredInstance(Class<?> c, Class<T> t, Map<String, Object> configs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzNzQ4MA==", "bodyText": "Shouldn't the second param be TopicAnomaly.class?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374437480", "createdAt": "2020-02-04T01:49:37Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public List<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singletonList(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                           _targetReplicationFactor));\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {\n+    Map<String, Object> configs = new HashMap<>(4);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, topicsWithBadReplicationFactor);\n+    configs.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, targetReplicationFactor);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicReplicationTopicAnomalyClass, TopicReplicationFactorAnomaly.class, configs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODEwMQ==", "bodyText": "I am curious why we prefer this method over KafkaCruiseControlConfig#getConfiguredInstance?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374438101", "createdAt": "2020-02-04T01:52:37Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public List<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singletonList(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                           _targetReplicationFactor));\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {\n+    Map<String, Object> configs = new HashMap<>(4);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, topicsWithBadReplicationFactor);\n+    configs.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, targetReplicationFactor);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicReplicationTopicAnomalyClass, TopicReplicationFactorAnomaly.class, configs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODI5MA==", "bodyText": "anomaly detector -> anomaly finder?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374438290", "createdAt": "2020-02-04T01:53:31Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public List<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singletonList(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                           _targetReplicationFactor));\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {\n+    Map<String, Object> configs = new HashMap<>(4);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, topicsWithBadReplicationFactor);\n+    configs.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, targetReplicationFactor);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicReplicationTopicAnomalyClass, TopicReplicationFactorAnomaly.class, configs);\n+  }\n+\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    _kafkaCruiseControl = (KafkaCruiseControl) configs.get(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    if (_kafkaCruiseControl == null) {\n+      throw new IllegalArgumentException(\"Topic replication factor anomaly detector is missing \" + KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODg5Nw==", "bodyText": "If we make this configurable, should we have a sanity check to make sure that this is an instance of TopicAnomaly for early failure?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374438897", "createdAt": "2020-02-04T01:56:20Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public List<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singletonList(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                           _targetReplicationFactor));\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {\n+    Map<String, Object> configs = new HashMap<>(4);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, topicsWithBadReplicationFactor);\n+    configs.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, targetReplicationFactor);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicReplicationTopicAnomalyClass, TopicReplicationFactorAnomaly.class, configs);\n+  }\n+\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    _kafkaCruiseControl = (KafkaCruiseControl) configs.get(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    if (_kafkaCruiseControl == null) {\n+      throw new IllegalArgumentException(\"Topic replication factor anomaly detector is missing \" + KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    }\n+    Short targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    _targetReplicationFactor = targetReplicationFactor == null ? DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR\n+                                                               : _targetReplicationFactor;\n+    String topicExcludedFromCheck = (String) configs.get(TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK);\n+    _topicExcludedFromCheck = Pattern.compile(topicExcludedFromCheck == null ? DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK\n+                                                                             : topicExcludedFromCheck);\n+    String topicReplicationTopicAnomalyClass = (String) configs.get(TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG);\n+    if (topicReplicationTopicAnomalyClass == null) {\n+      _topicReplicationTopicAnomalyClass = DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MjEwMg==", "bodyText": "If all parameters are local, can we avoid passing them to the method of the same class (e.g. see RemoveBrokersRunnable#removeBrokers())?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374442102", "createdAt": "2020-02-04T02:11:05Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java", "diffHunk": "@@ -48,38 +57,107 @@\n  */\n public class UpdateTopicConfigurationRunnable extends OperationRunnable {\n   private static final Logger LOG = LoggerFactory.getLogger(UpdateTopicConfigurationRunnable.class);\n-  protected final TopicReplicationFactorChangeParameters _topicReplicationFactorChangeParameters;\n   protected final String _uuid;\n+  protected Map<Short, Pattern> _topicPatternByReplicationFactor;\n+  protected List<String> _goals;\n+  protected boolean _skipRackAwarenessCheck;\n+  protected ModelCompletenessRequirements _requirements;\n+  protected boolean _allowCapacityEstimation;\n+  protected Integer _concurrentInterBrokerPartitionMovements;\n+  protected Integer _concurrentLeaderMovements;\n+  protected Long _executionProgressCheckIntervalMs;\n+  protected boolean _skipHardGoalCheck;\n+  protected ReplicaMovementStrategy _replicaMovementStrategy;\n+  protected Long _replicationThrottle;\n+  protected boolean _excludeRecentlyDemotedBrokers;\n+  protected boolean _excludeRecentlyRemovedBrokers;\n+  protected boolean _dryRun;\n+  protected String _reason;\n+  protected boolean _stopOngoingExecution;\n+  protected boolean _isTriggeredByUserRequest;\n \n   public UpdateTopicConfigurationRunnable(KafkaCruiseControl kafkaCruiseControl,\n                                           OperationFuture future,\n                                           String uuid,\n                                           TopicConfigurationParameters parameters) {\n     super(kafkaCruiseControl, future);\n-    _topicReplicationFactorChangeParameters = parameters.topicReplicationFactorChangeParameters();\n+    TopicReplicationFactorChangeParameters topicReplicationFactorChangeParameters = parameters.topicReplicationFactorChangeParameters();\n+    if (topicReplicationFactorChangeParameters != null) {\n+      _topicPatternByReplicationFactor = topicReplicationFactorChangeParameters.topicPatternByReplicationFactor();\n+      _goals = topicReplicationFactorChangeParameters.goals();\n+      _skipRackAwarenessCheck = topicReplicationFactorChangeParameters.skipRackAwarenessCheck();\n+      _requirements = topicReplicationFactorChangeParameters.modelCompletenessRequirements();\n+      _allowCapacityEstimation = topicReplicationFactorChangeParameters.allowCapacityEstimation();\n+      _concurrentInterBrokerPartitionMovements = topicReplicationFactorChangeParameters.concurrentInterBrokerPartitionMovements();\n+      _concurrentLeaderMovements = topicReplicationFactorChangeParameters.concurrentLeaderMovements();\n+      _executionProgressCheckIntervalMs = topicReplicationFactorChangeParameters.executionProgressCheckIntervalMs();\n+      _skipHardGoalCheck = topicReplicationFactorChangeParameters.skipHardGoalCheck();\n+      _replicaMovementStrategy = topicReplicationFactorChangeParameters.replicaMovementStrategy();\n+      _replicationThrottle = topicReplicationFactorChangeParameters.replicationThrottle();\n+      _excludeRecentlyDemotedBrokers = topicReplicationFactorChangeParameters.excludeRecentlyDemotedBrokers();\n+      _excludeRecentlyRemovedBrokers = topicReplicationFactorChangeParameters.excludeRecentlyRemovedBrokers();\n+      _dryRun = topicReplicationFactorChangeParameters.dryRun();\n+      _reason = topicReplicationFactorChangeParameters.reason();\n+      _stopOngoingExecution = topicReplicationFactorChangeParameters.stopOngoingExecution();\n+      }\n     _uuid = uuid;\n+    _isTriggeredByUserRequest = true;\n   }\n \n+  /**\n+   * Constructor to be used for creating a runnable for self-healing.\n+   */\n+  public UpdateTopicConfigurationRunnable(KafkaCruiseControl kafkaCruiseControl,\n+                                          Map<Short, Pattern> topicPatternByReplicationFactor,\n+                                          List<String> selfHealingGoals,\n+                                          boolean allowCapacityEstimation,\n+                                          boolean excludeRecentlyDemotedBrokers,\n+                                          boolean excludeRecentlyRemovedBrokers,\n+                                          String anomalyId,\n+                                          String reason) {\n+    super(kafkaCruiseControl, new OperationFuture(\"Topic replication factor anomaly self-healing.\"));\n+    _topicPatternByReplicationFactor = topicPatternByReplicationFactor;\n+    _goals = selfHealingGoals;\n+    _skipRackAwarenessCheck = SELF_HEALING_SKIP_RACK_AWARENESS_CHECK;\n+    _requirements = SELF_HEALING_MODEL_COMPLETENESS_REQUIREMENTS;\n+    _allowCapacityEstimation = allowCapacityEstimation;\n+    _concurrentInterBrokerPartitionMovements = SELF_HEALING_CONCURRENT_MOVEMENTS;\n+    _concurrentLeaderMovements = SELF_HEALING_CONCURRENT_MOVEMENTS;\n+    _executionProgressCheckIntervalMs = SELF_HEALING_EXECUTION_PROGRESS_CHECK_INTERVAL_MS;\n+    _skipHardGoalCheck = SELF_HEALING_SKIP_HARD_GOAL_CHECK;\n+    _replicaMovementStrategy = SELF_HEALING_REPLICA_MOVEMENT_STRATEGY;\n+    _replicationThrottle = kafkaCruiseControl.config().getLong(ExecutorConfig.DEFAULT_REPLICATION_THROTTLE_CONFIG);\n+    _excludeRecentlyDemotedBrokers = excludeRecentlyDemotedBrokers;\n+    _excludeRecentlyRemovedBrokers = excludeRecentlyRemovedBrokers;\n+    _dryRun = SELF_HEALING_DRYRUN;\n+    _reason = reason;\n+    _stopOngoingExecution = SELF_HEALING_STOP_ONGOING_EXECUTION;\n+    _uuid = anomalyId;\n+    _isTriggeredByUserRequest = false;\n+  }\n+\n+\n   @Override\n-  protected OptimizationResult getResult() throws Exception {\n-    if (_topicReplicationFactorChangeParameters != null) {\n+  public OptimizationResult getResult() throws Exception {\n+    if (_topicPatternByReplicationFactor != null) {\n       return new OptimizationResult(\n-          updateTopicReplicationFactor(_topicReplicationFactorChangeParameters.topicPatternByReplicationFactor(),\n-                                       _topicReplicationFactorChangeParameters.goals(),\n-                                       _topicReplicationFactorChangeParameters.skipRackAwarenessCheck(),\n-                                       _topicReplicationFactorChangeParameters.modelCompletenessRequirements(),\n-                                       _topicReplicationFactorChangeParameters.allowCapacityEstimation(),\n-                                       _topicReplicationFactorChangeParameters.concurrentInterBrokerPartitionMovements(),\n-                                       _topicReplicationFactorChangeParameters.concurrentLeaderMovements(),\n-                                       _topicReplicationFactorChangeParameters.executionProgressCheckIntervalMs(),\n-                                       _topicReplicationFactorChangeParameters.skipHardGoalCheck(),\n-                                       _topicReplicationFactorChangeParameters.replicaMovementStrategy(),\n-                                       _topicReplicationFactorChangeParameters.replicationThrottle(),\n-                                       _topicReplicationFactorChangeParameters.excludeRecentlyDemotedBrokers(),\n-                                       _topicReplicationFactorChangeParameters.excludeRecentlyRemovedBrokers(),\n-                                       _topicReplicationFactorChangeParameters.dryRun(),\n-                                       _topicReplicationFactorChangeParameters.reason(),\n-                                       _topicReplicationFactorChangeParameters.stopOngoingExecution()),\n+          updateTopicReplicationFactor(_topicPatternByReplicationFactor,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MjI1MA==", "bodyText": "Null check on a random local variable of this runnable is a little confusing. Can we make it more clear?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374442250", "createdAt": "2020-02-04T02:11:56Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java", "diffHunk": "@@ -48,38 +57,107 @@\n  */\n public class UpdateTopicConfigurationRunnable extends OperationRunnable {\n   private static final Logger LOG = LoggerFactory.getLogger(UpdateTopicConfigurationRunnable.class);\n-  protected final TopicReplicationFactorChangeParameters _topicReplicationFactorChangeParameters;\n   protected final String _uuid;\n+  protected Map<Short, Pattern> _topicPatternByReplicationFactor;\n+  protected List<String> _goals;\n+  protected boolean _skipRackAwarenessCheck;\n+  protected ModelCompletenessRequirements _requirements;\n+  protected boolean _allowCapacityEstimation;\n+  protected Integer _concurrentInterBrokerPartitionMovements;\n+  protected Integer _concurrentLeaderMovements;\n+  protected Long _executionProgressCheckIntervalMs;\n+  protected boolean _skipHardGoalCheck;\n+  protected ReplicaMovementStrategy _replicaMovementStrategy;\n+  protected Long _replicationThrottle;\n+  protected boolean _excludeRecentlyDemotedBrokers;\n+  protected boolean _excludeRecentlyRemovedBrokers;\n+  protected boolean _dryRun;\n+  protected String _reason;\n+  protected boolean _stopOngoingExecution;\n+  protected boolean _isTriggeredByUserRequest;\n \n   public UpdateTopicConfigurationRunnable(KafkaCruiseControl kafkaCruiseControl,\n                                           OperationFuture future,\n                                           String uuid,\n                                           TopicConfigurationParameters parameters) {\n     super(kafkaCruiseControl, future);\n-    _topicReplicationFactorChangeParameters = parameters.topicReplicationFactorChangeParameters();\n+    TopicReplicationFactorChangeParameters topicReplicationFactorChangeParameters = parameters.topicReplicationFactorChangeParameters();\n+    if (topicReplicationFactorChangeParameters != null) {\n+      _topicPatternByReplicationFactor = topicReplicationFactorChangeParameters.topicPatternByReplicationFactor();\n+      _goals = topicReplicationFactorChangeParameters.goals();\n+      _skipRackAwarenessCheck = topicReplicationFactorChangeParameters.skipRackAwarenessCheck();\n+      _requirements = topicReplicationFactorChangeParameters.modelCompletenessRequirements();\n+      _allowCapacityEstimation = topicReplicationFactorChangeParameters.allowCapacityEstimation();\n+      _concurrentInterBrokerPartitionMovements = topicReplicationFactorChangeParameters.concurrentInterBrokerPartitionMovements();\n+      _concurrentLeaderMovements = topicReplicationFactorChangeParameters.concurrentLeaderMovements();\n+      _executionProgressCheckIntervalMs = topicReplicationFactorChangeParameters.executionProgressCheckIntervalMs();\n+      _skipHardGoalCheck = topicReplicationFactorChangeParameters.skipHardGoalCheck();\n+      _replicaMovementStrategy = topicReplicationFactorChangeParameters.replicaMovementStrategy();\n+      _replicationThrottle = topicReplicationFactorChangeParameters.replicationThrottle();\n+      _excludeRecentlyDemotedBrokers = topicReplicationFactorChangeParameters.excludeRecentlyDemotedBrokers();\n+      _excludeRecentlyRemovedBrokers = topicReplicationFactorChangeParameters.excludeRecentlyRemovedBrokers();\n+      _dryRun = topicReplicationFactorChangeParameters.dryRun();\n+      _reason = topicReplicationFactorChangeParameters.reason();\n+      _stopOngoingExecution = topicReplicationFactorChangeParameters.stopOngoingExecution();\n+      }\n     _uuid = uuid;\n+    _isTriggeredByUserRequest = true;\n   }\n \n+  /**\n+   * Constructor to be used for creating a runnable for self-healing.\n+   */\n+  public UpdateTopicConfigurationRunnable(KafkaCruiseControl kafkaCruiseControl,\n+                                          Map<Short, Pattern> topicPatternByReplicationFactor,\n+                                          List<String> selfHealingGoals,\n+                                          boolean allowCapacityEstimation,\n+                                          boolean excludeRecentlyDemotedBrokers,\n+                                          boolean excludeRecentlyRemovedBrokers,\n+                                          String anomalyId,\n+                                          String reason) {\n+    super(kafkaCruiseControl, new OperationFuture(\"Topic replication factor anomaly self-healing.\"));\n+    _topicPatternByReplicationFactor = topicPatternByReplicationFactor;\n+    _goals = selfHealingGoals;\n+    _skipRackAwarenessCheck = SELF_HEALING_SKIP_RACK_AWARENESS_CHECK;\n+    _requirements = SELF_HEALING_MODEL_COMPLETENESS_REQUIREMENTS;\n+    _allowCapacityEstimation = allowCapacityEstimation;\n+    _concurrentInterBrokerPartitionMovements = SELF_HEALING_CONCURRENT_MOVEMENTS;\n+    _concurrentLeaderMovements = SELF_HEALING_CONCURRENT_MOVEMENTS;\n+    _executionProgressCheckIntervalMs = SELF_HEALING_EXECUTION_PROGRESS_CHECK_INTERVAL_MS;\n+    _skipHardGoalCheck = SELF_HEALING_SKIP_HARD_GOAL_CHECK;\n+    _replicaMovementStrategy = SELF_HEALING_REPLICA_MOVEMENT_STRATEGY;\n+    _replicationThrottle = kafkaCruiseControl.config().getLong(ExecutorConfig.DEFAULT_REPLICATION_THROTTLE_CONFIG);\n+    _excludeRecentlyDemotedBrokers = excludeRecentlyDemotedBrokers;\n+    _excludeRecentlyRemovedBrokers = excludeRecentlyRemovedBrokers;\n+    _dryRun = SELF_HEALING_DRYRUN;\n+    _reason = reason;\n+    _stopOngoingExecution = SELF_HEALING_STOP_ONGOING_EXECUTION;\n+    _uuid = anomalyId;\n+    _isTriggeredByUserRequest = false;\n+  }\n+\n+\n   @Override\n-  protected OptimizationResult getResult() throws Exception {\n-    if (_topicReplicationFactorChangeParameters != null) {\n+  public OptimizationResult getResult() throws Exception {\n+    if (_topicPatternByReplicationFactor != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0Mzc5Nw==", "bodyText": "Nit: Can we name the CLUSTER_ID to a more specific value?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374443797", "createdAt": "2020-02-04T02:19:09Z", "author": {"login": "efeg"}, "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java", "diffHunk": "@@ -24,6 +29,7 @@\n   public static final String T1 = \"T1\";\n   public static final String T2 = \"T2\";\n   public static final Map<Integer, Integer> RACK_BY_BROKER;\n+  public static final String CLUSTER_ID = \"TEST\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NDIzMA==", "bodyText": "Nit: Can we avoid hard-coding port number?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374444230", "createdAt": "2020-02-04T02:21:08Z", "author": {"login": "efeg"}, "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java", "diffHunk": "@@ -503,4 +509,31 @@ public static ClusterModel getHomogeneousCluster(Map<Integer, Integer> rackByBro\n         (key, value) -> cluster.createBroker(value.toString(), Integer.toString(key), key, commonBrokerCapacityInfo, diskCapacityByLogDir != null));\n     return cluster;\n   }\n+\n+  /**\n+   * Generate the cluster metadata from given cluster model.\n+   * @param clusterModel The cluster model.\n+   * @return The cluster metadata.\n+   */\n+  public static Cluster generateClusterFromClusterModel(ClusterModel clusterModel) {\n+    Map<Integer, Node> nodes = new HashMap<>();\n+    clusterModel.brokers().forEach(b -> nodes.put(b.id(), new Node(b.id(), b.host().toString(), 0, b.rack().id())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NTAwNg==", "bodyText": "Rather than b.host().toString(), maybe it is more preferable to use host().name()?\nFor historical reasons, toString() method is returning XML format -- which is something we should change in this or another patch.", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374445006", "createdAt": "2020-02-04T02:24:31Z", "author": {"login": "efeg"}, "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/common/DeterministicCluster.java", "diffHunk": "@@ -503,4 +509,31 @@ public static ClusterModel getHomogeneousCluster(Map<Integer, Integer> rackByBro\n         (key, value) -> cluster.createBroker(value.toString(), Integer.toString(key), key, commonBrokerCapacityInfo, diskCapacityByLogDir != null));\n     return cluster;\n   }\n+\n+  /**\n+   * Generate the cluster metadata from given cluster model.\n+   * @param clusterModel The cluster model.\n+   * @return The cluster metadata.\n+   */\n+  public static Cluster generateClusterFromClusterModel(ClusterModel clusterModel) {\n+    Map<Integer, Node> nodes = new HashMap<>();\n+    clusterModel.brokers().forEach(b -> nodes.put(b.id(), new Node(b.id(), b.host().toString(), 0, b.rack().id())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NTk4OA==", "bodyText": "Nit (not introduced in this patch): Noticed a typo in static private final long MOCK_ANOMALY_DETECTER_SHUTDOWN_MS = 5000L;", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374445988", "createdAt": "2020-02-04T02:29:02Z", "author": {"login": "efeg"}, "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetectorTest.java", "diffHunk": "@@ -41,6 +41,9 @@\n import org.junit.Test;\n \n import static com.linkedin.kafka.cruisecontrol.common.DeterministicCluster.smallClusterModel;\n+import static com.linkedin.kafka.cruisecontrol.common.DeterministicCluster.unbalanced;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NjU4OA==", "bodyText": "This function seems to be quite verbose -- can we move some of the logic to functions to make what it is testing more clear?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374446588", "createdAt": "2020-02-04T02:31:57Z", "author": {"login": "efeg"}, "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetectorTest.java", "diffHunk": "@@ -255,7 +278,8 @@ private void testFixAnomaly(AnomalyType anomalyType)\n     EasyMock.expect(mockKafkaCruiseControl.getLoadMonitorTaskRunnerState())\n             .andReturn(LoadMonitorTaskRunner.LoadMonitorTaskRunnerState.RUNNING).times(1, 4);\n \n-    startPeriodicDetectors(mockDetectorScheduler, mockGoalViolationDetector, mockMetricAnomalyDetector, mockDiskFailureDetector, executorService);\n+    startPeriodicDetectors(mockDetectorScheduler, mockGoalViolationDetector, mockMetricAnomalyDetector, mockDiskFailureDetector,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NzEzMQ==", "bodyText": "Can we add some notes (e.g. to JavaDoc or inline) on what we are testing?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374447131", "createdAt": "2020-02-04T02:34:31Z", "author": {"login": "efeg"}, "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/notifier/SelfHealingNotifierTest.java", "diffHunk": "@@ -197,6 +203,15 @@ public void testSelfHealingDisabled() {\n     assertEquals(AnomalyNotificationResult.Action.IGNORE, result.action());\n     assertTrue(anomalyNotifier._alertCalled.get(KafkaAnomalyType.DISK_FAILURE));\n     assertFalse(anomalyNotifier._autoFixTriggered.get(KafkaAnomalyType.DISK_FAILURE));\n+\n+    // (5) Topic Anomaly", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0ODE1MA==", "bodyText": "-- We should consider prioritizing #1041.\nSanity checking this file is non-trivial.", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r374448150", "createdAt": "2020-02-04T02:38:48Z", "author": {"login": "efeg"}, "path": "cruise-control/src/yaml/responses/anomalyDetectorState.yaml", "diffHunk": "@@ -160,3 +170,6 @@ MeanTimeBetweenAnomaliesMs:\n     DISK_FAILURE:\n       type: number\n       format: double\n+    TOPIC_ANOMALY:\n+      type: number\n+      format: double", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 51}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0399162122f3962eb05bba6e2099694b92a84d98", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/0399162122f3962eb05bba6e2099694b92a84d98", "committedDate": "2020-02-10T06:31:23Z", "message": "Fix build failure."}, "afterCommit": {"oid": "c694052ddc5f7c393429b187991b2b5b0a70e7f7", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/c694052ddc5f7c393429b187991b2b5b0a70e7f7", "committedDate": "2020-02-10T06:31:55Z", "message": "Fix build failure."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NjM4Mzc2", "url": "https://github.com/linkedin/cruise-control/pull/1079#pullrequestreview-358638376", "createdAt": "2020-02-14T00:07:00Z", "commit": {"oid": "c694052ddc5f7c393429b187991b2b5b0a70e7f7"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMDowNzowMVrOFpn0XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMDoxODoxM1rOFpoAkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4ODMxNg==", "bodyText": "Nit: Can these static variables also be final?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379188316", "createdAt": "2020-02-14T00:07:01Z", "author": {"login": "efeg"}, "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyUtilsTest.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.junit.Test;\n+\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.buildTopicRegex;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+\n+/**\n+ * Unit test class for anomaly utilization methods.\n+ */\n+public class AnomalyUtilsTest {\n+    private static String TOPIC1 = \"abc\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c694052ddc5f7c393429b187991b2b5b0a70e7f7"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MTQ0MQ==", "bodyText": "The corresponding unit test seems to pass without parentheses, as well. Capturing group seems redundant.", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379191441", "createdAt": "2020-02-14T00:18:13Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType;\n+import com.linkedin.kafka.cruisecontrol.servlet.handler.async.runnable.UpdateTopicConfigurationRunnable;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.StringJoiner;\n+import java.util.regex.Pattern;\n+\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getSelfHealingGoalNames;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.extractKafkaCruiseControlObjectFromConfig;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder.TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.notifier.KafkaAnomalyType.TOPIC_ANOMALY;\n+\n+\n+/**\n+ * Topics which contain at least one partition with replication factor not equal to the config value of\n+ * {@link com.linkedin.kafka.cruisecontrol.detector.TopicReplicationFactorAnomalyFinder#SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}\n+ */\n+public class TopicReplicationFactorAnomaly extends TopicAnomaly {\n+  protected Short _targetReplicationFactor;\n+  protected Set<String> _topicsWithBadReplicationFactor;\n+  protected UpdateTopicConfigurationRunnable _updateTopicConfigurationRunnable;\n+\n+  @Override\n+  public boolean fix() throws Exception {\n+    _optimizationResult = _updateTopicConfigurationRunnable.getResult();\n+    boolean hasProposalsToFix = hasProposalsToFix();\n+    // Ensure that only the relevant response is cached to avoid memory pressure.\n+    _optimizationResult.discardIrrelevantAndCacheJsonAndPlaintext();\n+    return hasProposalsToFix;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    super.configure(configs);\n+    KafkaCruiseControl kafkaCruiseControl = extractKafkaCruiseControlObjectFromConfig(configs, KafkaAnomalyType.TOPIC_ANOMALY);\n+    KafkaCruiseControlConfig config = kafkaCruiseControl.config();\n+    _topicsWithBadReplicationFactor = (Set<String>) configs.get(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG);\n+    if (_topicsWithBadReplicationFactor == null || _topicsWithBadReplicationFactor.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\", TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG));\n+    }\n+    _targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    if (_targetReplicationFactor == null) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s for topic replication factor anomaly.\",\n+                                                       SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG));\n+    }\n+    boolean allowCapacityEstimation = config.getBoolean(ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG);\n+    boolean excludeRecentlyDemotedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG);\n+    boolean excludeRecentlyRemovedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG);\n+    _updateTopicConfigurationRunnable = new UpdateTopicConfigurationRunnable(kafkaCruiseControl,\n+                                                                             Collections.singletonMap(_targetReplicationFactor,\n+                                                                                                      buildTopicRegex(_topicsWithBadReplicationFactor)),\n+                                                                             getSelfHealingGoalNames(config),\n+                                                                             allowCapacityEstimation,\n+                                                                             excludeRecentlyDemotedBrokers,\n+                                                                             excludeRecentlyRemovedBrokers,\n+                                                                             _anomalyId.toString(),\n+                                                                             String.format(\"Self healing for %s: %s\", TOPIC_ANOMALY, this));\n+\n+  }\n+\n+  private Pattern buildTopicRegex(Set<String> topics) {\n+    StringJoiner sj = new StringJoiner(\"|\");\n+    topics.forEach(sj::add);\n+    return Pattern.compile(\"(\" + sj.toString() + \")\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzMzExNw=="}, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 78}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NjQyMjA1", "url": "https://github.com/linkedin/cruise-control/pull/1079#pullrequestreview-358642205", "createdAt": "2020-02-14T00:18:19Z", "commit": {"oid": "c694052ddc5f7c393429b187991b2b5b0a70e7f7"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMDoxODoxOVrOFpoAtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMDo0OToyMFrOFpogPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MTQ3OQ==", "bodyText": "The corresponding unit test seems to pass without parentheses, as well. Capturing group seems redundant.", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379191479", "createdAt": "2020-02-14T00:18:19Z", "author": {"login": "efeg"}, "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyUtilsTest.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.junit.Test;\n+\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyUtils.buildTopicRegex;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+\n+/**\n+ * Unit test class for anomaly utilization methods.\n+ */\n+public class AnomalyUtilsTest {\n+    private static String TOPIC1 = \"abc\";\n+    private static String TOPIC2 = \"def\";\n+    private static String TOPIC3 = \"ghi\";\n+\n+    @Test\n+    public void testBuildTopicRegex() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c694052ddc5f7c393429b187991b2b5b0a70e7f7"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MjkxNA==", "bodyText": "Nit: Can we make it KafkaAnomalyType.cachedValues().size() + 1 and add a comment to clarify why we have a + 1?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379192914", "createdAt": "2020-02-14T00:24:07Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/AnomalyDetector.java", "diffHunk": "@@ -48,7 +50,7 @@\n   static final String METRIC_REGISTRY_NAME = \"AnomalyDetector\";\n   private static final int INIT_JITTER_BOUND = 10000;\n   private static final long SCHEDULER_SHUTDOWN_TIMEOUT_MS = 5000L;\n-  private static final int NUM_ANOMALY_DETECTION_THREADS = 5;\n+  private static final int NUM_ANOMALY_DETECTION_THREADS = 6;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c694052ddc5f7c393429b187991b2b5b0a70e7f7"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5NDk4OA==", "bodyText": "Nit: Would it be more clear to say violation of user-defined topic properties rather than certain desired topic property?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379194988", "createdAt": "2020-02-14T00:31:55Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.CruiseControlConfigurable;\n+import java.util.Set;\n+import org.apache.yetus.audience.InterfaceStability;\n+\n+\n+/**\n+ * The finder which checks topics against certain desired topic property to identify topic anomaly.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c694052ddc5f7c393429b187991b2b5b0a70e7f7"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5OTU1MQ==", "bodyText": "Shouldn't the *AnomalyFinder of a particular Anomaly Detector always generate the same type of anomalies?\n-- i.e. Shouldn't the generated anomaly type have an API to support any anomaly finders? If the anomaly type is missing certain functionalities, I think we should evolve its API. Note that in case of metric anomalies, we have SlowBrokers extending KafkaMetricAnomaly. Hence, the metric anomaly detector always returns an instance of KafkaMetricAnomaly as expected.", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379199551", "createdAt": "2020-02-14T00:49:20Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.*;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.*;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final short DEFAULT_SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR = 3;\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public List<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singletonList(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                           _targetReplicationFactor));\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {\n+    Map<String, Object> configs = new HashMap<>(4);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, topicsWithBadReplicationFactor);\n+    configs.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, targetReplicationFactor);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicReplicationTopicAnomalyClass, TopicReplicationFactorAnomaly.class, configs);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQzODEwMQ=="}, "originalCommit": {"oid": "cf8bb3f2bb1b41072e1ef9bd1c81fbfc08612502"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NjU0NzAx", "url": "https://github.com/linkedin/cruise-control/pull/1079#pullrequestreview-358654701", "createdAt": "2020-02-14T00:58:09Z", "commit": {"oid": "c694052ddc5f7c393429b187991b2b5b0a70e7f7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMDo1ODowOVrOFpoptg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQwMToxNDoyM1rOFpo7dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwMTk3NA==", "bodyText": "Can we make all variables final?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379201974", "createdAt": "2020-02-14T00:58:09Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/servlet/handler/async/runnable/UpdateTopicConfigurationRunnable.java", "diffHunk": "@@ -48,39 +57,90 @@\n  */\n public class UpdateTopicConfigurationRunnable extends OperationRunnable {\n   private static final Logger LOG = LoggerFactory.getLogger(UpdateTopicConfigurationRunnable.class);\n-  protected final TopicReplicationFactorChangeParameters _topicReplicationFactorChangeParameters;\n   protected final String _uuid;\n+  protected Map<Short, Pattern> _topicPatternByReplicationFactor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c694052ddc5f7c393429b187991b2b5b0a70e7f7"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwMzQyMA==", "bodyText": "Nit: Let's avoid hardcoding test constants.", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379203420", "createdAt": "2020-02-14T01:03:11Z", "author": {"login": "efeg"}, "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/detector/notifier/SelfHealingNotifierTest.java", "diffHunk": "@@ -162,6 +166,8 @@ public void testSelfHealingDisabled() {\n                                  Collections.singletonMap(brokerWithMetricAnomaly, anomalyDetectionTime));\n     parameterConfigOverrides.put(FAILED_DISKS_OBJECT_CONFIG,\n                                  Collections.singletonMap(1, Collections.singletonMap(\"logdir1\", failureTime1)));\n+    parameterConfigOverrides.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, (short) 3);\n+    parameterConfigOverrides.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, Collections.singleton(\"topic1\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c694052ddc5f7c393429b187991b2b5b0a70e7f7"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwNDc1NQ==", "bodyText": "Nit: bad indentation", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379204755", "createdAt": "2020-02-14T01:07:39Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.CLASS;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.getConfiguredInstance;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}: The config for the target replication factor of topics.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}.\n+ *   <li>{@link #TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS}.\n+ * </ul>\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public Set<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                       _targetReplicationFactor));\n+    }\n+    return Collections.emptySet();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c694052ddc5f7c393429b187991b2b5b0a70e7f7"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTIwNjUxNg==", "bodyText": "(Not introduced in this patch) We are missing similar sanity checks for pluggable SlowBrokerFinder for AnomalyDetectorConfig.METRIC_ANOMALY_CLASS_CONFIG .", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r379206516", "createdAt": "2020-02-14T01:14:23Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.config.ConfigDef;\n+import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.apache.kafka.common.Cluster;\n+import org.apache.kafka.common.PartitionInfo;\n+\n+import static com.linkedin.cruisecontrol.common.config.ConfigDef.Type.CLASS;\n+import static com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfigUtils.getConfiguredInstance;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n+import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG;\n+\n+\n+/**\n+ * The class will check whether there are topics having partition(s) with replication factor different than the desired value.\n+ * Required configurations for this class.\n+ * <ul>\n+ *   <li>{@link #SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG}: The config for the target replication factor of topics.\n+ *   <li>{@link #TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}: The config to specify topics excluded from the anomaly checking.\n+ *   The value is treated as a regular expression, default value is set to\n+ *   {@link #DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK}.\n+ *   <li>{@link #TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG}: The config for the topic anomaly class name,\n+ *   default value is set to {@link #DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS}.\n+ * </ul>\n+ */\n+public class TopicReplicationFactorAnomalyFinder implements TopicAnomalyFinder {\n+  public static final String SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG = \"self.healing.target.topic.replication.factor\";\n+  public static final String TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"topic.excluded.from.replication.factor.check\";\n+  public static final String DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK = \"\";\n+  public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n+  public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n+  public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG = \"topics.with.bad.replication.factor\";\n+  private KafkaCruiseControl _kafkaCruiseControl;\n+  private int _targetReplicationFactor;\n+  private Pattern _topicExcludedFromCheck;\n+  private Class<?> _topicReplicationTopicAnomalyClass;\n+\n+  @Override\n+  public Set<TopicAnomaly> topicAnomalies() {\n+    Cluster cluster = _kafkaCruiseControl.kafkaCluster();\n+    Set<String> topicsWithBadReplicationFactor = new HashSet<>();\n+    for (String topic : cluster.topics()) {\n+      if (_topicExcludedFromCheck.matcher(topic).matches()) {\n+        continue;\n+      }\n+      for (PartitionInfo partition : cluster.partitionsForTopic(topic)) {\n+        if (partition.replicas().length != _targetReplicationFactor) {\n+          topicsWithBadReplicationFactor.add(topic);\n+          break;\n+        }\n+      }\n+    }\n+    if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+                                                                       _targetReplicationFactor));\n+    }\n+    return Collections.emptySet();\n+  }\n+\n+  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n+                                                          int targetReplicationFactor) {\n+    Map<String, Object> configs = new HashMap<>(4);\n+    configs.put(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG, _kafkaCruiseControl);\n+    configs.put(TOPICS_WITH_BAD_REPLICATION_FACTOR_CONFIG, topicsWithBadReplicationFactor);\n+    configs.put(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG, targetReplicationFactor);\n+    configs.put(ANOMALY_DETECTION_TIME_MS_OBJECT_CONFIG, _kafkaCruiseControl.timeMs());\n+    return getConfiguredInstance(_topicReplicationTopicAnomalyClass, TopicAnomaly.class, configs);\n+  }\n+\n+  @Override\n+  public void configure(Map<String, ?> configs) {\n+    _kafkaCruiseControl = (KafkaCruiseControl) configs.get(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    if (_kafkaCruiseControl == null) {\n+      throw new IllegalArgumentException(\"Topic replication factor anomaly finder is missing \" + KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n+    }\n+    Short targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    if (targetReplicationFactor == null) {\n+      throw new IllegalArgumentException(\"Topic replication factor anomaly finder is missing \" + SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    }\n+    _targetReplicationFactor = targetReplicationFactor;\n+    String topicExcludedFromCheck = (String) configs.get(TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK);\n+    _topicExcludedFromCheck = Pattern.compile(topicExcludedFromCheck == null ? DEFAULT_TOPIC_EXCLUDED_FROM_REPLICATION_FACTOR_CHECK\n+                                                                             : topicExcludedFromCheck);\n+    String topicReplicationTopicAnomalyClass = (String) configs.get(TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG);\n+    if (topicReplicationTopicAnomalyClass == null) {\n+      _topicReplicationTopicAnomalyClass = DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS;\n+    } else {\n+      _topicReplicationTopicAnomalyClass = (Class<?>) ConfigDef.parseType(TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG,\n+                                                                          topicReplicationTopicAnomalyClass,\n+                                                                          CLASS);\n+      if (_topicReplicationTopicAnomalyClass == null || !TopicAnomaly.class.isAssignableFrom(_topicReplicationTopicAnomalyClass)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c694052ddc5f7c393429b187991b2b5b0a70e7f7"}, "originalPosition": 101}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNzUyMTA0", "url": "https://github.com/linkedin/cruise-control/pull/1079#pullrequestreview-360752104", "createdAt": "2020-02-18T23:39:22Z", "commit": {"oid": "797824af986a59c9fcf7e469ca7fdbeee18721ed"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMzozOToyMlrOFrWY_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQyMDoyMToxNlrOFsh3PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk5OTkzNQ==", "bodyText": "I assume this file has been added unintentionally -- can we remove it?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r380999935", "createdAt": "2020-02-18T23:39:22Z", "author": {"login": "efeg"}, "path": "cruise-control/access.log", "diffHunk": "@@ -0,0 +1,7 @@\n+127.0.0.1 - test [15/Feb/2020:06:23:35 +0000] \"GET /kafkacruisecontrol/STATE HTTP/1.1\" 200 1023  71\n+127.0.0.1 - ccTestUser [15/Feb/2020:06:23:35 +0000] \"POST /kafkacruisecontrol/STOP_PROPOSAL_EXECUTION HTTP/1.1\" 403 541  9\n+127.0.0.1 - ccTestUser [15/Feb/2020:06:23:35 +0000] \"GET /kafkacruisecontrol/STATE HTTP/1.1\" 200 1023  72\n+127.0.0.1 - - [15/Feb/2020:06:23:37 +0000] \"GET /kafkacruisecontrol/state HTTP/1.1\" 200 1023  54\n+127.0.0.1 - - [15/Feb/2020:06:23:41 +0000] \"GET /kafkacruisecontrol/STATE HTTP/1.1\" 401 544  7\n+127.0.0.1 - ccTestAdmin [15/Feb/2020:06:23:44 +0000] \"GET /kafkacruisecontrol/STATE HTTP/1.1\" 200 1052  4\n+127.0.0.1 - ccTestAdmin [15/Feb/2020:06:23:44 +0000] \"POST /kafkacruisecontrol/STOP_PROPOSAL_EXECUTION HTTP/1.1\" 200 27  5", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "797824af986a59c9fcf7e469ca7fdbeee18721ed"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzMjc5Mw==", "bodyText": "Nit: Can we move the default to a static variable?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r382232793", "createdAt": "2020-02-20T20:13:16Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java", "diffHunk": "@@ -269,6 +286,16 @@ public static ConfigDef define(ConfigDef configDef) {\n                             ConfigDef.Type.BOOLEAN,\n                             DEFAULT_ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG,\n                             ConfigDef.Importance.LOW,\n-                            ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_DOC);\n+                            ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_DOC)\n+                    .define(TOPIC_ANOMALY_FINDER_CLASSES_CONFIG,\n+                            ConfigDef.Type.LIST,\n+                            DEFAULT_TOPIC_ANOMALY_FINDER_CLASS,\n+                            ConfigDef.Importance.MEDIUM,\n+                            TOPIC_ANOMALY_FINDER_CLASSES_DOC)\n+                    .define(TOPIC_ANOMALY_DETECTION_INTERVAL_MS_CONFIG,\n+                            ConfigDef.Type.LONG,\n+                            null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c600aa16a95127bb01db28f130c479a913ea9ce"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzNTkxNQ==", "bodyText": "If we make this the default topic anomaly finder, even if the user does not want to use the topic anomaly finder, s/he will receive an IllegalXXX exception upon configuration time due to missing default replication factor. Should we:\n\nMake the NoopTopic Anomaly Finder as the default here, and\nAdd a documentation under the wiki on what needs to be done to use TopicReplicationFactorAnomalyFinder?\nAlso add documentation on configurations section of wiki to add the new configs?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r382235915", "createdAt": "2020-02-20T20:20:03Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java", "diffHunk": "@@ -172,6 +173,22 @@ private AnomalyDetectorConfig() {\n   public static final String ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_DOC = \"The flag to indicate whether anomaly \"\n       + \"detection threads allow capacity estimation in the generated cluster model they use.\";\n \n+  /**\n+   * <code>topic.anomaly.detection.interval.ms</code>\n+   */\n+  public static final String TOPIC_ANOMALY_DETECTION_INTERVAL_MS_CONFIG = \"topic.anomaly.detection.interval.ms\";\n+  public static final String TOPIC_ANOMALY_DETECTION_INTERVAL_MS_DOC = \"The interval in millisecond that topic anomaly \"\n+      + \"detector will run to detect topic anomalies. If this interval time is not specified, topic anomaly detector \"\n+      + \"will run with interval specified in \" + ANOMALY_DETECTION_INTERVAL_MS_CONFIG + \".\";\n+\n+  /**\n+   * <code>topic.anomaly.finder.class</code>\n+   */\n+  public static final String TOPIC_ANOMALY_FINDER_CLASSES_CONFIG = \"topic.anomaly.finder.class\";\n+  public static final String DEFAULT_TOPIC_ANOMALY_FINDER_CLASS = TopicReplicationFactorAnomalyFinder.class.getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c600aa16a95127bb01db28f130c479a913ea9ce"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIzNjQ3Nw==", "bodyText": "Is this import intentional? Shouldn't we use org.apache.kafka.common.annotation.InterfaceStability;?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r382236477", "createdAt": "2020-02-20T20:21:16Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.detector;\n+\n+import com.linkedin.cruisecontrol.common.CruiseControlConfigurable;\n+import java.util.Set;\n+import org.apache.yetus.audience.InterfaceStability;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c600aa16a95127bb01db28f130c479a913ea9ce"}, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ef939f4f523ff7e90f2669da3be46fdc847f260", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/0ef939f4f523ff7e90f2669da3be46fdc847f260", "committedDate": "2020-02-20T22:45:44Z", "message": "Add support to detect and self-heal inconsistent topic replication factor."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac1c3b1ed8ec53ba2662ce503dde083e92dea69f", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/ac1c3b1ed8ec53ba2662ce503dde083e92dea69f", "committedDate": "2020-02-20T22:45:44Z", "message": "Fix build failure."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f73b230eccfcbff9ca89991cb9ad0a09e88e6aa", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/7f73b230eccfcbff9ca89991cb9ad0a09e88e6aa", "committedDate": "2020-02-20T22:45:44Z", "message": "Remove access.log"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a31b96c336a80462028dbfa40a891d1c3d9e90db", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/a31b96c336a80462028dbfa40a891d1c3d9e90db", "committedDate": "2020-02-20T22:46:35Z", "message": "Address the feedback."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "529138d2635fbe86947ce6b2556eff615b31bd50", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/529138d2635fbe86947ce6b2556eff615b31bd50", "committedDate": "2020-02-20T22:46:35Z", "message": "Fix build failure."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee8771f3ab11ffe5671e0753b5f1af7f65506632", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/ee8771f3ab11ffe5671e0753b5f1af7f65506632", "committedDate": "2020-02-20T22:46:35Z", "message": "Address the feedback."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cbfa344156a644b0d80e28f01deb2cc6279e18b", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/3cbfa344156a644b0d80e28f01deb2cc6279e18b", "committedDate": "2020-02-20T22:46:35Z", "message": "remove access log."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97033a2e74eb2fea158a67d3e114cb41173ace0e", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/97033a2e74eb2fea158a67d3e114cb41173ace0e", "committedDate": "2020-02-20T22:52:54Z", "message": "Address the feedback."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7c600aa16a95127bb01db28f130c479a913ea9ce", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/7c600aa16a95127bb01db28f130c479a913ea9ce", "committedDate": "2020-02-19T00:40:38Z", "message": "Address the feedback."}, "afterCommit": {"oid": "97033a2e74eb2fea158a67d3e114cb41173ace0e", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/97033a2e74eb2fea158a67d3e114cb41173ace0e", "committedDate": "2020-02-20T22:52:54Z", "message": "Address the feedback."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05cfe1c9757e0c3f4b40144e79c08c357d381f80", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/05cfe1c9757e0c3f4b40144e79c08c357d381f80", "committedDate": "2020-02-20T23:17:26Z", "message": "Fix build failure and udpate wiki."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMzYwMzY3", "url": "https://github.com/linkedin/cruise-control/pull/1079#pullrequestreview-362360367", "createdAt": "2020-02-21T02:08:28Z", "commit": {"oid": "05cfe1c9757e0c3f4b40144e79c08c357d381f80"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMjowODoyOVrOFsphUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQwMjoyNDoyM1rOFspvQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2MTkzNg==", "bodyText": "Duplicate title.", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r382361936", "createdAt": "2020-02-21T02:08:29Z", "author": {"login": "efeg"}, "path": "docs/wiki/Overview.md", "diffHunk": "@@ -1,4 +1,5 @@\n ## Architecture\n+## Architecture", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05cfe1c9757e0c3f4b40144e79c08c357d381f80"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2MjcwNQ==", "bodyText": "Can we use NoopTopicAnomalyFinder.class.getName() and use in topic anomaly unit test?", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r382362705", "createdAt": "2020-02-21T02:11:43Z", "author": {"login": "efeg"}, "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/KafkaCruiseControlUnitTestUtils.java", "diffHunk": "@@ -60,6 +60,7 @@ public static Properties getKafkaCruiseControlProperties() {\n                       Boolean.toString(AnomalyDetectorConfig.DEFAULT_SELF_HEALING_EXCLUDE_RECENT_BROKERS_CONFIG));\n     props.setProperty(AnomalyDetectorConfig.SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG,\n                       Boolean.toString(AnomalyDetectorConfig.DEFAULT_SELF_HEALING_EXCLUDE_RECENT_BROKERS_CONFIG));\n+    props.setProperty(AnomalyDetectorConfig.TOPIC_ANOMALY_FINDER_CLASSES_CONFIG, \"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05cfe1c9757e0c3f4b40144e79c08c357d381f80"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM2NTUwNA==", "bodyText": "Nit: missing space before parenthesis -- properties(e.g.  -> properties (e.g.", "url": "https://github.com/linkedin/cruise-control/pull/1079#discussion_r382365504", "createdAt": "2020-02-21T02:24:23Z", "author": {"login": "efeg"}, "path": "docs/wiki/Overview.md", "diffHunk": "@@ -74,6 +75,8 @@ The anomaly detector identifies four types of anomalies:\n * Goal violations - i.e. an optimization goal is violated. When this happens, Cruise Control will send a notification out and if self-healing for this anomaly type is enabled, Cruise Control will proactively attempt to address the goal violation by automatically analyzing the workload, and executing optimization proposals. \n * Disk failure - i.e. one of the non-empty disk dies, note this is only related with Kafka broker running on JBOD disk. When this happens, Cruise Control will send a notification out and if self-healing for this anomaly type is enabled, Cruise Control will trigger an operation to move all the offline replicas to other healthy brokers in the cluster. \n * Metric anomaly - i.e. one of the metrics Cruise Control collected observes anomaly in value(e.g. a sudden rise in log flush time metrics). When this happens, Cruise Control will send a notification out. Currently there is no standardized self-healing operation defined for metric anomaly since different different metric anomalies expect different remediations. User can define their own anomaly and remediation operation by implementing their own [MetricAnomaly](https://github.com/linkedin/cruise-control/blob/master/cruise-control-core/src/main/java/com/linkedin/cruisecontrol/detector/metricanomaly/MetricAnomaly.java) and [MetricAnomalyFinder](https://github.com/linkedin/cruise-control/blob/master/cruise-control-core/src/main/java/com/linkedin/cruisecontrol/detector/metricanomaly/MetricAnomalyFinder.java).\n+* Topic anomaly - i.e. one or more topics in cluster violates user-defined properties(e.g. some partitions are too large in disk). When this happens, Cruise Control will send a notification out. Currently there is no standardized self-healing operation defined for topic anomaly since different different topic anomalies expect different remediations. User can define their own anomaly and remediation operation by implementing their own [TopicAnomaly](https://github.com/linkedin/cruise-control/blob/master/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomaly.java) and [TopicAnomalyFinder](https://github.com/linkedin/cruise-control/blob/master/cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicAnomalyFinder.java).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "05cfe1c9757e0c3f4b40144e79c08c357d381f80"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dffd7ff392b8df6e393798d89f2384f435ea2b8f", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/dffd7ff392b8df6e393798d89f2384f435ea2b8f", "committedDate": "2020-02-21T18:18:26Z", "message": "Address the feedback."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 148, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}