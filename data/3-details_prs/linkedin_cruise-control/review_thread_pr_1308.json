{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0OTMyODAx", "number": 1308, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjo1NDoxNlrOEXCPbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjo1NDo1NFrOEXCP3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTg5NDIyOnYy", "diffSide": "RIGHT", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjo1NDoxNlrOG-mlWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxOTowNToxNFrOG_FcPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5NzA0OQ==", "bodyText": "Is this comment correct? I thought CC no longer deletes the znode and moves controller in order to stop the execution.", "url": "https://github.com/linkedin/cruise-control/pull/1308#discussion_r468297049", "createdAt": "2020-08-11T02:54:16Z", "author": {"login": "hzxa21"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -1416,6 +1416,120 @@ private int moveLeadershipInBatch() throws InterruptedException, ExecutionExcept\n       return finishedTasks;\n     }\n \n+    private void handleProgressWithTopicDeletion(ExecutionTask task, List<ExecutionTask> finishedTasks, Set<Long> deletedTaskIds) {\n+      // Handle topic deletion during the execution.\n+      LOG.debug(\"Task {} is marked as finished because the topic has been deleted.\", task);\n+      finishedTasks.add(task);\n+      deletedTaskIds.add(task.executionId());\n+      _executionTaskManager.markTaskAborting(task);\n+      _executionTaskManager.markTaskDone(task);\n+    }\n+\n+    private void handleProgressWithCompletion(ExecutionTask task, List<ExecutionTask> finishedTasks) {\n+      // Check to see if the task is done.\n+      finishedTasks.add(task);\n+      _executionTaskManager.markTaskDone(task);\n+    }\n+\n+    /**\n+     * Periodically checks the metadata to see if leadership reassignment has finished or not.\n+     */\n+    private void waitForLeadershipTasksToFinish() {\n+      List<ExecutionTask> finishedTasks = new ArrayList<>();\n+      Set<Long> stoppedTaskIds = new HashSet<>();\n+      Set<Long> deletedTaskIds = new HashSet<>();\n+      Set<Long> deadTaskIds = new HashSet<>();\n+      do {\n+        // If there is no finished tasks, we need to check if anything is blocked.\n+        maybeReexecuteLeadershipTasks();\n+        Cluster cluster = getClusterForExecutionProgressCheck();\n+\n+        List<ExecutionTask> slowTasksToReport = new ArrayList<>();\n+        boolean shouldReportSlowTasks = _time.milliseconds() - _lastSlowTaskReportingTimeMs > SLOW_TASK_ALERTING_BACKOFF_TIME_MS;\n+        for (ExecutionTask task : inExecutionTasks()) {\n+          TopicPartition tp = task.proposal().topicPartition();\n+          if (_stopSignal.get() == FORCE_STOP_EXECUTION) {\n+            // If the execution is force-stopped, the executor will mark all in progress tasks as dead, cleanup the\n+            // relevant reassignment zNodes, and then bounce the controller (see ExecutionUtils#deleteZNodesToStopExecution).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b91e7fc8f24b67b6c82e39c9ae875b48d4d202f2"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgwMjYyMg==", "bodyText": "Yes, I believe it is correct.\nLeadership reassignments in Kafka use PreferredReplicaElection znode; hence, potentially stuck leadership movements may require a force-stop. Though in practice, a stuck / time-consuming leadership movement is not common.\nNote that KIP-455 was about a new API for inter-broker replica reassignment tasks. Thus, its impact is limited to changes in starting, stopping, and listing them.\nI cleaned up the force-stop logic to ensure that it only applies to leadership movements along with a deprecation message for replica reassignments  -- i.e. with KIP-455 inter-broker replica reassignments no longer need force stop and intra-broker replica reassignments were already not using zNodes.\nOne side-effect of this change would be the loss of ability to bounce controller upon force-stopping inter/intra broker replica reassignments, which would have helped in case the controller itself is stuck for some reason. We can address that in a future PR by moving intentional controller bounce functionality to admin endpoint of cruise control.", "url": "https://github.com/linkedin/cruise-control/pull/1308#discussion_r468802622", "createdAt": "2020-08-11T19:05:14Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -1416,6 +1416,120 @@ private int moveLeadershipInBatch() throws InterruptedException, ExecutionExcept\n       return finishedTasks;\n     }\n \n+    private void handleProgressWithTopicDeletion(ExecutionTask task, List<ExecutionTask> finishedTasks, Set<Long> deletedTaskIds) {\n+      // Handle topic deletion during the execution.\n+      LOG.debug(\"Task {} is marked as finished because the topic has been deleted.\", task);\n+      finishedTasks.add(task);\n+      deletedTaskIds.add(task.executionId());\n+      _executionTaskManager.markTaskAborting(task);\n+      _executionTaskManager.markTaskDone(task);\n+    }\n+\n+    private void handleProgressWithCompletion(ExecutionTask task, List<ExecutionTask> finishedTasks) {\n+      // Check to see if the task is done.\n+      finishedTasks.add(task);\n+      _executionTaskManager.markTaskDone(task);\n+    }\n+\n+    /**\n+     * Periodically checks the metadata to see if leadership reassignment has finished or not.\n+     */\n+    private void waitForLeadershipTasksToFinish() {\n+      List<ExecutionTask> finishedTasks = new ArrayList<>();\n+      Set<Long> stoppedTaskIds = new HashSet<>();\n+      Set<Long> deletedTaskIds = new HashSet<>();\n+      Set<Long> deadTaskIds = new HashSet<>();\n+      do {\n+        // If there is no finished tasks, we need to check if anything is blocked.\n+        maybeReexecuteLeadershipTasks();\n+        Cluster cluster = getClusterForExecutionProgressCheck();\n+\n+        List<ExecutionTask> slowTasksToReport = new ArrayList<>();\n+        boolean shouldReportSlowTasks = _time.milliseconds() - _lastSlowTaskReportingTimeMs > SLOW_TASK_ALERTING_BACKOFF_TIME_MS;\n+        for (ExecutionTask task : inExecutionTasks()) {\n+          TopicPartition tp = task.proposal().topicPartition();\n+          if (_stopSignal.get() == FORCE_STOP_EXECUTION) {\n+            // If the execution is force-stopped, the executor will mark all in progress tasks as dead, cleanup the\n+            // relevant reassignment zNodes, and then bounce the controller (see ExecutionUtils#deleteZNodesToStopExecution).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5NzA0OQ=="}, "originalCommit": {"oid": "b91e7fc8f24b67b6c82e39c9ae875b48d4d202f2"}, "originalPosition": 271}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNTg5NTMzOnYy", "diffSide": "RIGHT", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjo1NDo1NFrOG-ml-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxOTowNToxM1rOG_FcNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5NzIwOQ==", "bodyText": "Is this comment correct? I thought CC no longer deletes the znode and moves controller in order to stop the execution.", "url": "https://github.com/linkedin/cruise-control/pull/1308#discussion_r468297209", "createdAt": "2020-08-11T02:54:54Z", "author": {"login": "hzxa21"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -1416,6 +1416,120 @@ private int moveLeadershipInBatch() throws InterruptedException, ExecutionExcept\n       return finishedTasks;\n     }\n \n+    private void handleProgressWithTopicDeletion(ExecutionTask task, List<ExecutionTask> finishedTasks, Set<Long> deletedTaskIds) {\n+      // Handle topic deletion during the execution.\n+      LOG.debug(\"Task {} is marked as finished because the topic has been deleted.\", task);\n+      finishedTasks.add(task);\n+      deletedTaskIds.add(task.executionId());\n+      _executionTaskManager.markTaskAborting(task);\n+      _executionTaskManager.markTaskDone(task);\n+    }\n+\n+    private void handleProgressWithCompletion(ExecutionTask task, List<ExecutionTask> finishedTasks) {\n+      // Check to see if the task is done.\n+      finishedTasks.add(task);\n+      _executionTaskManager.markTaskDone(task);\n+    }\n+\n+    /**\n+     * Periodically checks the metadata to see if leadership reassignment has finished or not.\n+     */\n+    private void waitForLeadershipTasksToFinish() {\n+      List<ExecutionTask> finishedTasks = new ArrayList<>();\n+      Set<Long> stoppedTaskIds = new HashSet<>();\n+      Set<Long> deletedTaskIds = new HashSet<>();\n+      Set<Long> deadTaskIds = new HashSet<>();\n+      do {\n+        // If there is no finished tasks, we need to check if anything is blocked.\n+        maybeReexecuteLeadershipTasks();\n+        Cluster cluster = getClusterForExecutionProgressCheck();\n+\n+        List<ExecutionTask> slowTasksToReport = new ArrayList<>();\n+        boolean shouldReportSlowTasks = _time.milliseconds() - _lastSlowTaskReportingTimeMs > SLOW_TASK_ALERTING_BACKOFF_TIME_MS;\n+        for (ExecutionTask task : inExecutionTasks()) {\n+          TopicPartition tp = task.proposal().topicPartition();\n+          if (_stopSignal.get() == FORCE_STOP_EXECUTION) {\n+            // If the execution is force-stopped, the executor will mark all in progress tasks as dead, cleanup the\n+            // relevant reassignment zNodes, and then bounce the controller (see ExecutionUtils#deleteZNodesToStopExecution).\n+            LOG.debug(\"Task {} is marked as dead to force-stop the execution with a controller bounce.\", task);\n+            finishedTasks.add(task);\n+            stoppedTaskIds.add(task.executionId());\n+            _executionTaskManager.markTaskDead(task);\n+          } else if (cluster.partition(tp) == null) {\n+            handleProgressWithTopicDeletion(task, finishedTasks, deletedTaskIds);\n+          } else if (ExecutionUtils.isLeadershipMovementDone(cluster, task)) {\n+            handleProgressWithCompletion(task, finishedTasks);\n+          } else {\n+            if (shouldReportSlowTasks) {\n+              task.maybeReportExecutionTooSlow(_time.milliseconds(), slowTasksToReport);\n+            }\n+            if (maybeMarkTaskAsDead(cluster, null, task, null)) {\n+              deadTaskIds.add(task.executionId());\n+              finishedTasks.add(task);\n+            }\n+          }\n+        }\n+        sendSlowExecutionAlert(slowTasksToReport);\n+        updateOngoingExecutionState();\n+      } while (!inExecutionTasks().isEmpty() && finishedTasks.isEmpty());\n+\n+      LOG.info(\"Finished tasks: {}.{}{}{}\", finishedTasks,\n+               stoppedTaskIds.isEmpty() ? \"\" : String.format(\". [Force-Stopped: %s]\", stoppedTaskIds),\n+               deletedTaskIds.isEmpty() ? \"\" : String.format(\". [Deleted: %s]\", deletedTaskIds),\n+               deadTaskIds.isEmpty() ? \"\" : String.format(\". [Dead: %s]\", deadTaskIds));\n+    }\n+\n+    /**\n+     * Periodically checks the metadata to see if intra-broker replica reassignment has finished or not.\n+     */\n+    private void waitForIntraBrokerReplicaTasksToFinish() {\n+      List<ExecutionTask> finishedTasks = new ArrayList<>();\n+      Set<Long> stoppedTaskIds = new HashSet<>();\n+      Set<Long> deletedTaskIds = new HashSet<>();\n+      Set<Long> deadTaskIds = new HashSet<>();\n+      do {\n+        // If there is no finished tasks, we need to check if anything is blocked.\n+        maybeReexecuteIntraBrokerReplicaTasks();\n+        Cluster cluster = getClusterForExecutionProgressCheck();\n+        Map<ExecutionTask, ReplicaLogDirInfo> logDirInfoByTask = getLogdirInfoForExecutionTask(\n+            _executionTaskManager.inExecutionTasks(Collections.singleton(INTRA_BROKER_REPLICA_ACTION)),\n+            _adminClient, _config);\n+\n+        List<ExecutionTask> slowTasksToReport = new ArrayList<>();\n+        boolean shouldReportSlowTasks = _time.milliseconds() - _lastSlowTaskReportingTimeMs > SLOW_TASK_ALERTING_BACKOFF_TIME_MS;\n+        for (ExecutionTask task : inExecutionTasks()) {\n+          TopicPartition tp = task.proposal().topicPartition();\n+          if (_stopSignal.get() == FORCE_STOP_EXECUTION) {\n+            // If the execution is force-stopped, the executor will mark all in progress tasks as dead, cleanup the\n+            // relevant reassignment zNodes, and then bounce the controller (see ExecutionUtils#deleteZNodesToStopExecution).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b91e7fc8f24b67b6c82e39c9ae875b48d4d202f2"}, "originalPosition": 322}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODgwMjYxMw==", "bodyText": "Please see the response to the other comment above.", "url": "https://github.com/linkedin/cruise-control/pull/1308#discussion_r468802613", "createdAt": "2020-08-11T19:05:13Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -1416,6 +1416,120 @@ private int moveLeadershipInBatch() throws InterruptedException, ExecutionExcept\n       return finishedTasks;\n     }\n \n+    private void handleProgressWithTopicDeletion(ExecutionTask task, List<ExecutionTask> finishedTasks, Set<Long> deletedTaskIds) {\n+      // Handle topic deletion during the execution.\n+      LOG.debug(\"Task {} is marked as finished because the topic has been deleted.\", task);\n+      finishedTasks.add(task);\n+      deletedTaskIds.add(task.executionId());\n+      _executionTaskManager.markTaskAborting(task);\n+      _executionTaskManager.markTaskDone(task);\n+    }\n+\n+    private void handleProgressWithCompletion(ExecutionTask task, List<ExecutionTask> finishedTasks) {\n+      // Check to see if the task is done.\n+      finishedTasks.add(task);\n+      _executionTaskManager.markTaskDone(task);\n+    }\n+\n+    /**\n+     * Periodically checks the metadata to see if leadership reassignment has finished or not.\n+     */\n+    private void waitForLeadershipTasksToFinish() {\n+      List<ExecutionTask> finishedTasks = new ArrayList<>();\n+      Set<Long> stoppedTaskIds = new HashSet<>();\n+      Set<Long> deletedTaskIds = new HashSet<>();\n+      Set<Long> deadTaskIds = new HashSet<>();\n+      do {\n+        // If there is no finished tasks, we need to check if anything is blocked.\n+        maybeReexecuteLeadershipTasks();\n+        Cluster cluster = getClusterForExecutionProgressCheck();\n+\n+        List<ExecutionTask> slowTasksToReport = new ArrayList<>();\n+        boolean shouldReportSlowTasks = _time.milliseconds() - _lastSlowTaskReportingTimeMs > SLOW_TASK_ALERTING_BACKOFF_TIME_MS;\n+        for (ExecutionTask task : inExecutionTasks()) {\n+          TopicPartition tp = task.proposal().topicPartition();\n+          if (_stopSignal.get() == FORCE_STOP_EXECUTION) {\n+            // If the execution is force-stopped, the executor will mark all in progress tasks as dead, cleanup the\n+            // relevant reassignment zNodes, and then bounce the controller (see ExecutionUtils#deleteZNodesToStopExecution).\n+            LOG.debug(\"Task {} is marked as dead to force-stop the execution with a controller bounce.\", task);\n+            finishedTasks.add(task);\n+            stoppedTaskIds.add(task.executionId());\n+            _executionTaskManager.markTaskDead(task);\n+          } else if (cluster.partition(tp) == null) {\n+            handleProgressWithTopicDeletion(task, finishedTasks, deletedTaskIds);\n+          } else if (ExecutionUtils.isLeadershipMovementDone(cluster, task)) {\n+            handleProgressWithCompletion(task, finishedTasks);\n+          } else {\n+            if (shouldReportSlowTasks) {\n+              task.maybeReportExecutionTooSlow(_time.milliseconds(), slowTasksToReport);\n+            }\n+            if (maybeMarkTaskAsDead(cluster, null, task, null)) {\n+              deadTaskIds.add(task.executionId());\n+              finishedTasks.add(task);\n+            }\n+          }\n+        }\n+        sendSlowExecutionAlert(slowTasksToReport);\n+        updateOngoingExecutionState();\n+      } while (!inExecutionTasks().isEmpty() && finishedTasks.isEmpty());\n+\n+      LOG.info(\"Finished tasks: {}.{}{}{}\", finishedTasks,\n+               stoppedTaskIds.isEmpty() ? \"\" : String.format(\". [Force-Stopped: %s]\", stoppedTaskIds),\n+               deletedTaskIds.isEmpty() ? \"\" : String.format(\". [Deleted: %s]\", deletedTaskIds),\n+               deadTaskIds.isEmpty() ? \"\" : String.format(\". [Dead: %s]\", deadTaskIds));\n+    }\n+\n+    /**\n+     * Periodically checks the metadata to see if intra-broker replica reassignment has finished or not.\n+     */\n+    private void waitForIntraBrokerReplicaTasksToFinish() {\n+      List<ExecutionTask> finishedTasks = new ArrayList<>();\n+      Set<Long> stoppedTaskIds = new HashSet<>();\n+      Set<Long> deletedTaskIds = new HashSet<>();\n+      Set<Long> deadTaskIds = new HashSet<>();\n+      do {\n+        // If there is no finished tasks, we need to check if anything is blocked.\n+        maybeReexecuteIntraBrokerReplicaTasks();\n+        Cluster cluster = getClusterForExecutionProgressCheck();\n+        Map<ExecutionTask, ReplicaLogDirInfo> logDirInfoByTask = getLogdirInfoForExecutionTask(\n+            _executionTaskManager.inExecutionTasks(Collections.singleton(INTRA_BROKER_REPLICA_ACTION)),\n+            _adminClient, _config);\n+\n+        List<ExecutionTask> slowTasksToReport = new ArrayList<>();\n+        boolean shouldReportSlowTasks = _time.milliseconds() - _lastSlowTaskReportingTimeMs > SLOW_TASK_ALERTING_BACKOFF_TIME_MS;\n+        for (ExecutionTask task : inExecutionTasks()) {\n+          TopicPartition tp = task.proposal().topicPartition();\n+          if (_stopSignal.get() == FORCE_STOP_EXECUTION) {\n+            // If the execution is force-stopped, the executor will mark all in progress tasks as dead, cleanup the\n+            // relevant reassignment zNodes, and then bounce the controller (see ExecutionUtils#deleteZNodesToStopExecution).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5NzIwOQ=="}, "originalCommit": {"oid": "b91e7fc8f24b67b6c82e39c9ae875b48d4d202f2"}, "originalPosition": 322}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 682, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}