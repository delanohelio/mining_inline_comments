{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzMjE1ODQ0", "number": 1368, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwODowMDoxNVrOE0sSEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwODoyMjowOFrOE0ssiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjg2OTMxOnYy", "diffSide": "RIGHT", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwODowMDoxNVrOHsjWog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwODowMDoxNVrOHsjWog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3ODYyNg==", "bodyText": "Nit: I would use String.format to construct the exception messages to improve readability since these variable names are long. It applies to all ConfigException in this section.", "url": "https://github.com/linkedin/cruise-control/pull/1368#discussion_r516478626", "createdAt": "2020-11-03T08:00:15Z", "author": {"login": "Lincong"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java", "diffHunk": "@@ -244,6 +252,33 @@ private void sanityCheckConcurrency() {\n                                 + \"] cannot be greater than the maximum number of allowed movements in cluster [\"\n                                 + maxClusterPartitionMovementConcurrency + \"].\");\n     }\n+\n+    int concurrencyAdjusterMinPartitionMovementsPerBroker = getInt(ExecutorConfig.CONCURRENCY_ADJUSTER_MIN_PARTITION_MOVEMENTS_PER_BROKER_CONFIG);\n+    if (interBrokerPartitionMovementConcurrency < concurrencyAdjusterMinPartitionMovementsPerBroker) {\n+      throw new ConfigException(\"Inter-broker partition movement concurrency [\" + interBrokerPartitionMovementConcurrency", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b430b16c7f04cbd51631e2fc4daa524ccfa28c"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjkxODc3OnYy", "diffSide": "RIGHT", "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwODoxNjoyNVrOHsj0Aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMDoxNToyNVrOHs-8Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ4NjE0Nw==", "bodyText": "Nit: I think this statement (353 and 354) and the next line (355) can be swapped. Same case for line 365, 366 and 367", "url": "https://github.com/linkedin/cruise-control/pull/1368#discussion_r516486147", "createdAt": "2020-11-03T08:16:25Z", "author": {"login": "Lincong"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -298,54 +305,80 @@ public void run() {\n   }\n \n   /**\n-   * A runnable class to auto-adjust the allowed inter-broker partition reassignment concurrency for ongoing executions\n+   * A runnable class to auto-adjust the allowed reassignment concurrency for ongoing executions\n    * using selected broker metrics and based on additive-increase/multiplicative-decrease (AIMD) feedback control algorithm.\n    * Skips concurrency adjustment for demote operations.\n    */\n   private class ConcurrencyAdjuster implements Runnable {\n-    private final int _maxPartitionMovementsPerBroker;\n     private LoadMonitor _loadMonitor;\n \n     public ConcurrencyAdjuster() {\n-      _maxPartitionMovementsPerBroker = _config.getInt(ExecutorConfig.CONCURRENCY_ADJUSTER_MAX_PARTITION_MOVEMENTS_PER_BROKER_CONFIG);\n       _loadMonitor = null;\n     }\n \n     /**\n-     * Initialize the inter-broker partition reassignment concurrency adjustment with the load monitor and the initially\n-     * requested inter-broker partition reassignment concurrency.\n+     * Initialize the reassignment concurrency adjustment with the load monitor and the initially requested reassignment concurrency.\n      *\n      * @param loadMonitor Load monitor.\n      * @param requestedInterBrokerPartitionMovementConcurrency The maximum number of concurrent inter-broker partition movements\n      *                                                         per broker(if null, use num.concurrent.partition.movements.per.broker).\n+     * @param requestedLeadershipMovementConcurrency The maximum number of concurrent leader movements\n+     *                                               (if null, use num.concurrent.leader.movements).\n      */\n-    public synchronized void initAdjustment(LoadMonitor loadMonitor, Integer requestedInterBrokerPartitionMovementConcurrency) {\n+    public synchronized void initAdjustment(LoadMonitor loadMonitor,\n+                                            Integer requestedInterBrokerPartitionMovementConcurrency,\n+                                            Integer requestedLeadershipMovementConcurrency) {\n       _loadMonitor = loadMonitor;\n       setRequestedInterBrokerPartitionMovementConcurrency(requestedInterBrokerPartitionMovementConcurrency);\n+      setRequestedLeadershipMovementConcurrency(requestedLeadershipMovementConcurrency);\n     }\n \n-    private boolean canRefreshConcurrency() {\n-      return _concurrencyAdjusterEnabled && _executorState.state() == ExecutorState.State.INTER_BROKER_REPLICA_MOVEMENT_TASK_IN_PROGRESS\n-             && !_skipAutoRefreshingConcurrency && _loadMonitor != null;\n+    private boolean canRefreshConcurrency(ConcurrencyType concurrencyType) {\n+      if (!_concurrencyAdjusterEnabled.get(concurrencyType) || _loadMonitor == null) {\n+        return false;\n+      }\n+      switch (concurrencyType) {\n+        case LEADERSHIP:\n+          return _executorState.state() == LEADER_MOVEMENT_TASK_IN_PROGRESS;\n+        case INTER_BROKER_REPLICA:\n+          return _executorState.state() == ExecutorState.State.INTER_BROKER_REPLICA_MOVEMENT_TASK_IN_PROGRESS\n+                 && !_skipInterBrokerReplicaConcurrencyAdjustment;\n+        default:\n+          throw new IllegalArgumentException(\"Unsupported concurrency type \" + concurrencyType + \" is provided.\");\n+      }\n     }\n \n-    private synchronized void refreshConcurrency() {\n-      if (canRefreshConcurrency()) {\n-        Integer recommendedConcurrency = ExecutionUtils.recommendedConcurrency(_loadMonitor.currentBrokerMetricValues(),\n-                                                                               _executionTaskManager.interBrokerPartitionMovementConcurrency(),\n-                                                                               _maxPartitionMovementsPerBroker);\n+    private synchronized void refreshInterBrokerReplicaConcurrency() {\n+      if (canRefreshConcurrency(ConcurrencyType.INTER_BROKER_REPLICA)) {\n+        Integer recommendedConcurrency", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b430b16c7f04cbd51631e2fc4daa524ccfa28c"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5ODQwMg==", "bodyText": "Not sure I follow the recommendation here -- do you mean shift the RHS of assignment up to the same line as its LHS?", "url": "https://github.com/linkedin/cruise-control/pull/1368#discussion_r516898402", "createdAt": "2020-11-03T19:15:02Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -298,54 +305,80 @@ public void run() {\n   }\n \n   /**\n-   * A runnable class to auto-adjust the allowed inter-broker partition reassignment concurrency for ongoing executions\n+   * A runnable class to auto-adjust the allowed reassignment concurrency for ongoing executions\n    * using selected broker metrics and based on additive-increase/multiplicative-decrease (AIMD) feedback control algorithm.\n    * Skips concurrency adjustment for demote operations.\n    */\n   private class ConcurrencyAdjuster implements Runnable {\n-    private final int _maxPartitionMovementsPerBroker;\n     private LoadMonitor _loadMonitor;\n \n     public ConcurrencyAdjuster() {\n-      _maxPartitionMovementsPerBroker = _config.getInt(ExecutorConfig.CONCURRENCY_ADJUSTER_MAX_PARTITION_MOVEMENTS_PER_BROKER_CONFIG);\n       _loadMonitor = null;\n     }\n \n     /**\n-     * Initialize the inter-broker partition reassignment concurrency adjustment with the load monitor and the initially\n-     * requested inter-broker partition reassignment concurrency.\n+     * Initialize the reassignment concurrency adjustment with the load monitor and the initially requested reassignment concurrency.\n      *\n      * @param loadMonitor Load monitor.\n      * @param requestedInterBrokerPartitionMovementConcurrency The maximum number of concurrent inter-broker partition movements\n      *                                                         per broker(if null, use num.concurrent.partition.movements.per.broker).\n+     * @param requestedLeadershipMovementConcurrency The maximum number of concurrent leader movements\n+     *                                               (if null, use num.concurrent.leader.movements).\n      */\n-    public synchronized void initAdjustment(LoadMonitor loadMonitor, Integer requestedInterBrokerPartitionMovementConcurrency) {\n+    public synchronized void initAdjustment(LoadMonitor loadMonitor,\n+                                            Integer requestedInterBrokerPartitionMovementConcurrency,\n+                                            Integer requestedLeadershipMovementConcurrency) {\n       _loadMonitor = loadMonitor;\n       setRequestedInterBrokerPartitionMovementConcurrency(requestedInterBrokerPartitionMovementConcurrency);\n+      setRequestedLeadershipMovementConcurrency(requestedLeadershipMovementConcurrency);\n     }\n \n-    private boolean canRefreshConcurrency() {\n-      return _concurrencyAdjusterEnabled && _executorState.state() == ExecutorState.State.INTER_BROKER_REPLICA_MOVEMENT_TASK_IN_PROGRESS\n-             && !_skipAutoRefreshingConcurrency && _loadMonitor != null;\n+    private boolean canRefreshConcurrency(ConcurrencyType concurrencyType) {\n+      if (!_concurrencyAdjusterEnabled.get(concurrencyType) || _loadMonitor == null) {\n+        return false;\n+      }\n+      switch (concurrencyType) {\n+        case LEADERSHIP:\n+          return _executorState.state() == LEADER_MOVEMENT_TASK_IN_PROGRESS;\n+        case INTER_BROKER_REPLICA:\n+          return _executorState.state() == ExecutorState.State.INTER_BROKER_REPLICA_MOVEMENT_TASK_IN_PROGRESS\n+                 && !_skipInterBrokerReplicaConcurrencyAdjustment;\n+        default:\n+          throw new IllegalArgumentException(\"Unsupported concurrency type \" + concurrencyType + \" is provided.\");\n+      }\n     }\n \n-    private synchronized void refreshConcurrency() {\n-      if (canRefreshConcurrency()) {\n-        Integer recommendedConcurrency = ExecutionUtils.recommendedConcurrency(_loadMonitor.currentBrokerMetricValues(),\n-                                                                               _executionTaskManager.interBrokerPartitionMovementConcurrency(),\n-                                                                               _maxPartitionMovementsPerBroker);\n+    private synchronized void refreshInterBrokerReplicaConcurrency() {\n+      if (canRefreshConcurrency(ConcurrencyType.INTER_BROKER_REPLICA)) {\n+        Integer recommendedConcurrency", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ4NjE0Nw=="}, "originalCommit": {"oid": "92b430b16c7f04cbd51631e2fc4daa524ccfa28c"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkzMDYzMA==", "bodyText": "I see. Nvm. I did not notice that the result of _executionTaskManager.interBrokerPartitionMovementConcurrency() is one of the input parameters passed to the recommendedConcurrency  method. Sorry for the confusion.", "url": "https://github.com/linkedin/cruise-control/pull/1368#discussion_r516930630", "createdAt": "2020-11-03T20:15:25Z", "author": {"login": "Lincong"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -298,54 +305,80 @@ public void run() {\n   }\n \n   /**\n-   * A runnable class to auto-adjust the allowed inter-broker partition reassignment concurrency for ongoing executions\n+   * A runnable class to auto-adjust the allowed reassignment concurrency for ongoing executions\n    * using selected broker metrics and based on additive-increase/multiplicative-decrease (AIMD) feedback control algorithm.\n    * Skips concurrency adjustment for demote operations.\n    */\n   private class ConcurrencyAdjuster implements Runnable {\n-    private final int _maxPartitionMovementsPerBroker;\n     private LoadMonitor _loadMonitor;\n \n     public ConcurrencyAdjuster() {\n-      _maxPartitionMovementsPerBroker = _config.getInt(ExecutorConfig.CONCURRENCY_ADJUSTER_MAX_PARTITION_MOVEMENTS_PER_BROKER_CONFIG);\n       _loadMonitor = null;\n     }\n \n     /**\n-     * Initialize the inter-broker partition reassignment concurrency adjustment with the load monitor and the initially\n-     * requested inter-broker partition reassignment concurrency.\n+     * Initialize the reassignment concurrency adjustment with the load monitor and the initially requested reassignment concurrency.\n      *\n      * @param loadMonitor Load monitor.\n      * @param requestedInterBrokerPartitionMovementConcurrency The maximum number of concurrent inter-broker partition movements\n      *                                                         per broker(if null, use num.concurrent.partition.movements.per.broker).\n+     * @param requestedLeadershipMovementConcurrency The maximum number of concurrent leader movements\n+     *                                               (if null, use num.concurrent.leader.movements).\n      */\n-    public synchronized void initAdjustment(LoadMonitor loadMonitor, Integer requestedInterBrokerPartitionMovementConcurrency) {\n+    public synchronized void initAdjustment(LoadMonitor loadMonitor,\n+                                            Integer requestedInterBrokerPartitionMovementConcurrency,\n+                                            Integer requestedLeadershipMovementConcurrency) {\n       _loadMonitor = loadMonitor;\n       setRequestedInterBrokerPartitionMovementConcurrency(requestedInterBrokerPartitionMovementConcurrency);\n+      setRequestedLeadershipMovementConcurrency(requestedLeadershipMovementConcurrency);\n     }\n \n-    private boolean canRefreshConcurrency() {\n-      return _concurrencyAdjusterEnabled && _executorState.state() == ExecutorState.State.INTER_BROKER_REPLICA_MOVEMENT_TASK_IN_PROGRESS\n-             && !_skipAutoRefreshingConcurrency && _loadMonitor != null;\n+    private boolean canRefreshConcurrency(ConcurrencyType concurrencyType) {\n+      if (!_concurrencyAdjusterEnabled.get(concurrencyType) || _loadMonitor == null) {\n+        return false;\n+      }\n+      switch (concurrencyType) {\n+        case LEADERSHIP:\n+          return _executorState.state() == LEADER_MOVEMENT_TASK_IN_PROGRESS;\n+        case INTER_BROKER_REPLICA:\n+          return _executorState.state() == ExecutorState.State.INTER_BROKER_REPLICA_MOVEMENT_TASK_IN_PROGRESS\n+                 && !_skipInterBrokerReplicaConcurrencyAdjustment;\n+        default:\n+          throw new IllegalArgumentException(\"Unsupported concurrency type \" + concurrencyType + \" is provided.\");\n+      }\n     }\n \n-    private synchronized void refreshConcurrency() {\n-      if (canRefreshConcurrency()) {\n-        Integer recommendedConcurrency = ExecutionUtils.recommendedConcurrency(_loadMonitor.currentBrokerMetricValues(),\n-                                                                               _executionTaskManager.interBrokerPartitionMovementConcurrency(),\n-                                                                               _maxPartitionMovementsPerBroker);\n+    private synchronized void refreshInterBrokerReplicaConcurrency() {\n+      if (canRefreshConcurrency(ConcurrencyType.INTER_BROKER_REPLICA)) {\n+        Integer recommendedConcurrency", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ4NjE0Nw=="}, "originalCommit": {"oid": "92b430b16c7f04cbd51631e2fc4daa524ccfa28c"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzNjkzNzA1OnYy", "diffSide": "RIGHT", "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/ConcurrencyConfigTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwODoyMjowOFrOHsj_GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxOToxNTowMFrOHs8-Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ4ODk4NQ==", "bodyText": "2 nits:\n\nConsider using import com.linkedin.kafka.cruisecontrol.config.constants.ExecutorConfig.*; \nConsider creating a private static final String GET_INT_METHOD = \"getInt\"", "url": "https://github.com/linkedin/cruise-control/pull/1368#discussion_r516488985", "createdAt": "2020-11-03T08:22:08Z", "author": {"login": "Lincong"}, "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/ConcurrencyConfigTest.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.config;\n+\n+import com.linkedin.kafka.cruisecontrol.config.constants.ExecutorConfig;\n+import org.apache.kafka.common.config.ConfigException;\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertThrows;\n+\n+\n+public class ConcurrencyConfigTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b430b16c7f04cbd51631e2fc4daa524ccfa28c"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjg5ODM4Mw==", "bodyText": "I typically refrain from using wildcard imports unless all static variables are used in the importing class.\nMakes sense!", "url": "https://github.com/linkedin/cruise-control/pull/1368#discussion_r516898383", "createdAt": "2020-11-03T19:15:00Z", "author": {"login": "efeg"}, "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/ConcurrencyConfigTest.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.config;\n+\n+import com.linkedin.kafka.cruisecontrol.config.constants.ExecutorConfig;\n+import org.apache.kafka.common.config.ConfigException;\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertThrows;\n+\n+\n+public class ConcurrencyConfigTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ4ODk4NQ=="}, "originalCommit": {"oid": "92b430b16c7f04cbd51631e2fc4daa524ccfa28c"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 716, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}