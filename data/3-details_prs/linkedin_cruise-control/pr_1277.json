{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0NzgyMDU3", "number": 1277, "title": "Add config option for accurate CPU estimation on Kubernetes", "bodyText": "This PR resolves #1242\nUntil the methods of com.sun.management.OperatingSystemMXBean[1] are patched to be aware of container boundaries for OpenJDK versions 8 and above, methods like getProcessCpuLoad() will cause the Cruise Control Metric reporter to underestimate the CPU utilization of brokers while running on Kubernetes.\n[1] https://bugs.openjdk.java.net/browse/JDK-8226575", "createdAt": "2020-07-21T22:37:09Z", "url": "https://github.com/linkedin/cruise-control/pull/1277", "merged": true, "mergeCommit": {"oid": "910ba8c06f9ca1361f1593c3aaf33488a25ccccc"}, "closed": true, "closedAt": "2020-07-30T02:51:07Z", "author": {"login": "kyguy"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3MsGmgH2gAyNDU0NzgyMDU3OjhhOWIzZmI0N2Y0YzFjYmI5OGQ1Nzc0MGVkMzNlMDQ0NjZlY2Q0Mzk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc52SC8gFqTQ1ODAzMTMwNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/linkedin/cruise-control/commit/8a9b3fb47f4c1cbb98d57740ed33e04466ecd439", "committedDate": "2020-07-21T20:58:57Z", "message": "Add config option for accurate CPU estimation on Kubernetes\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNzAzODky", "url": "https://github.com/linkedin/cruise-control/pull/1277#pullrequestreview-453703892", "createdAt": "2020-07-22T21:37:48Z", "commit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMTozNzo0OFrOG11JlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQyMzozMzo1OFrOG13xQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA5ODUxNw==", "bodyText": "Nits:\n(1) extra space before metrics,\n(2) missing dot at the end of doc, and\n(3) inconsistent indentation (i.e. starts with more than 4 spaces).", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459098517", "createdAt": "2020-07-22T21:37:48Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/CruiseControlMetricsReporterConfig.java", "diffHunk": "@@ -50,6 +50,9 @@\n   public static final String CRUISE_CONTROL_METRICS_REPORTER_BATCH_SIZE_CONFIG = PREFIX + \"batch.size\";\n   private static final String CRUISE_CONTROL_METRICS_REPORTER_BATCH_SIZE_DOC = \"The batch.size configuration of KafkaProducer used in Cruise \"\n       + \"Control metrics reporter. Set this config and cruise.control.metrics.reporter.linger.ms to a large number to have better batching.\";\n+  public static final String CRUISE_CONTROL_METRICS_REPORTER_KUBERNETES_MODE_CONFIG = PREFIX + \"kubernetes.mode\";\n+  public static final String CRUISE_CONTROL_METRICS_REPORTER_KUBERNETES_MODE_DOC = \"Cruise Control metrics reporter will report \" +\n+          \" metrics using methods that are aware of container boundaries\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA5OTk2Nw==", "bodyText": "Nit: Missing javadoc for kubernetesMode parameter.", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459099967", "createdAt": "2020-07-22T21:40:43Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/MetricsUtils.java", "diffHunk": "@@ -164,8 +163,14 @@ public static CruiseControlMetric toCruiseControlMetric(long now,\n    * @param brokerId Broker Id.\n    * @return the \"recent CPU usage\" for the JVM process as a double in [0.0,1.0].\n    */\n-  public static BrokerMetric getCpuMetric(long now, int brokerId) {\n+  public static BrokerMetric getCpuMetric(long now, int brokerId, boolean kubernetesMode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExNjk0Mw==", "bodyText": "Did we avoid making the utils class final along with a private constructor and all static functions to be able to mock selected methods in ContainerMetricUtilsTest using EasyMock? If so, should we consider using the PowerMock to make this utils class cleaner?", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459116943", "createdAt": "2020-07-22T22:21:49Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExODEwMQ==", "bodyText": "Nit: 2017 -> 2020", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459118101", "createdAt": "2020-07-22T22:24:49Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTExODE1Nw==", "bodyText": "Nit: 2017 -> 2020", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459118157", "createdAt": "2020-07-22T22:24:55Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/test/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtilsTest.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNDA0Mg==", "bodyText": "Does -1.0 indicate no quota? Can we move the hardcoded value to a static variable to make this clear?", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459124042", "createdAt": "2020-07-22T22:41:06Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/test/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtilsTest.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+\n+import static org.easymock.EasyMock.partialMockBuilder;\n+import static org.junit.Assert.assertEquals;\n+\n+public class ContainerMetricUtilsTest {\n+\n+    private static final double DELTA = 0.01;\n+\n+    private void mockGetContainerProcessCpuLoad(int processors, double cpuQuota, double cpuPeriod, double cpuUtil, double expectedLoad) {\n+        ContainerMetricUtils cmu = partialMockBuilder(ContainerMetricUtils.class)\n+                .addMockedMethod(\"getAvailableProcessors\")\n+                .addMockedMethod(\"getCpuPeriod\")\n+                .addMockedMethod(\"getCpuQuota\")\n+                .createMock();\n+\n+        EasyMock.expect(cmu.getAvailableProcessors()).andReturn(processors);\n+        EasyMock.expect(cmu.getCpuPeriod()).andReturn(cpuPeriod);\n+        EasyMock.expect(cmu.getCpuQuota()).andReturn(cpuQuota);\n+\n+        EasyMock.replay(cmu);\n+\n+        assertEquals(expectedLoad, cmu.getContainerProcessCpuLoad(cpuUtil), DELTA);\n+    }\n+\n+    @Test\n+    public void testGetContainerProcessCpuLoad() {\n+        /*\n+         *  expectedContainerProcessCpuLoad = (cpuUtil * processors) / (cpuQuota / cpuPeriod)\n+         */\n+        mockGetContainerProcessCpuLoad(1, 100000.0, 100000.0, 1.0, 1.0);\n+        mockGetContainerProcessCpuLoad(1, 100000.0, 100000.0, 0.5, 0.5);\n+        mockGetContainerProcessCpuLoad(1, 50000.0, 100000.0, 0.5, 1.0);\n+        mockGetContainerProcessCpuLoad(1, 75000.0, 100000.0, 0.5, 0.66);\n+\n+        mockGetContainerProcessCpuLoad(2, 100000.0, 100000.0, 0.5, 1.0);\n+        mockGetContainerProcessCpuLoad(2, 200000.0, 100000.0, 1.0, 1.0);\n+        mockGetContainerProcessCpuLoad(2, 25000.0, 100000.0, 0.125, 1.0);\n+        mockGetContainerProcessCpuLoad(2, 2500.0, 100000.0, 0.0125, 1.0);\n+\n+        mockGetContainerProcessCpuLoad(2, -1.0, 100000.0, 0.125, 0.125);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNzI2OA==", "bodyText": "Nit: Can we move the hardcoded pathnames to static variables?", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459127268", "createdAt": "2020-07-22T22:50:02Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {\n+\n+    public double getCpuPeriod() {\n+        return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+    }\n+\n+    public double getCpuQuota() {\n+        return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+    }\n+\n+    /**\n+     * Gets the the number of logical cores available to the node.\n+     *\n+     * We can get this value while running in a container by using the \"nproc\" command.\n+     * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+     * Runtime.getRuntime().availableProcessors() would require disabling container\n+     * support (-XX:-UseContainerSupport) since these methods are aware of container\n+     * boundaries\n+     *\n+     * @return Number of logical processors on node\n+     */\n+    public int getAvailableProcessors() {\n+        int proc = 1;\n+        try {\n+            InputStream in = Runtime.getRuntime().exec(\"nproc\").getInputStream();\n+            proc = Integer.parseInt(readStringValue(in));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return proc;\n+    }\n+\n+    private static String readFile(String path) {\n+        String s = null;\n+        try {\n+            s = readStringValue(new FileInputStream(path));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return s;\n+    }\n+\n+    private static String readStringValue(InputStream in) {\n+        try {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                return line;\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get the \"recent CPU usage\" for the JVM process running inside of a container.\n+     *\n+     * At this time, the methods of OperatingSystemMXBean used for retrieving recent CPU usage are not\n+     * container aware and calculate CPU usage with respect to the physical host instead of the operating\n+     * environment from which they are called from. There have been efforts to make these methods container\n+     * aware but the changes have not been backported to Java versions less than version 14.\n+     *\n+     * Once these changes get backported, https://bugs.openjdk.java.net/browse/JDK-8226575, we can use\n+     * \"getSystemCpuLoad()\" for retrieving the CPU usage values when running in a container environment.\n+     *\n+     * @param cpuUtil The \"recent CPU usage\" for a JVM process with respect to node\n+     * @return the \"recent CPU usage\" for a JVM process with respect to operating environment\n+     *         as a double in [0.0,1.0].\n+     */\n+    public double getContainerProcessCpuLoad(double cpuUtil) {\n+        int logicalProcessorsOfNode = getAvailableProcessors();\n+        double cpuQuota = getCpuQuota();\n+        if (cpuQuota == -1) {\n+            /* A CPU quota value of -1 indicates that the cgroup does not adhere to any CPU time restrictions so we\n+             * will use the original container agnostic CPU usage value.\n+             */\n+            return cpuUtil;\n+        }\n+\n+        // Get the number of CPUs of a node that can be used by the operating environment\n+        double cpuLimit = (cpuQuota / getCpuPeriod());\n+\n+        // Get the minimal number of CPUs needed to achieve the reported CPU utilization\n+        double cpus = cpuUtil * logicalProcessorsOfNode;\n+\n+        /* Calculate the CPU utilization of a JVM process with respect to the operating environment.\n+         * Since the operating environment will only use the CPU resources allocated by CGroups,\n+         * it will always be that: cpuLimit >= cpus and the result is in the [0.0,1.0] interval.\n+         */\n+        return cpus / cpuLimit;\n+    }\n+\n+    public enum CgroupFiles {\n+\n+        QUOTA_PATH(\"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\"),\n+        PERIOD_PATH(\"/sys/fs/cgroup/cpu/cpu.cfs_period_us\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEyNzk2OQ==", "bodyText": "Can this value be final?", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459127969", "createdAt": "2020-07-22T22:52:05Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {\n+\n+    public double getCpuPeriod() {\n+        return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+    }\n+\n+    public double getCpuQuota() {\n+        return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+    }\n+\n+    /**\n+     * Gets the the number of logical cores available to the node.\n+     *\n+     * We can get this value while running in a container by using the \"nproc\" command.\n+     * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+     * Runtime.getRuntime().availableProcessors() would require disabling container\n+     * support (-XX:-UseContainerSupport) since these methods are aware of container\n+     * boundaries\n+     *\n+     * @return Number of logical processors on node\n+     */\n+    public int getAvailableProcessors() {\n+        int proc = 1;\n+        try {\n+            InputStream in = Runtime.getRuntime().exec(\"nproc\").getInputStream();\n+            proc = Integer.parseInt(readStringValue(in));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return proc;\n+    }\n+\n+    private static String readFile(String path) {\n+        String s = null;\n+        try {\n+            s = readStringValue(new FileInputStream(path));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return s;\n+    }\n+\n+    private static String readStringValue(InputStream in) {\n+        try {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                return line;\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get the \"recent CPU usage\" for the JVM process running inside of a container.\n+     *\n+     * At this time, the methods of OperatingSystemMXBean used for retrieving recent CPU usage are not\n+     * container aware and calculate CPU usage with respect to the physical host instead of the operating\n+     * environment from which they are called from. There have been efforts to make these methods container\n+     * aware but the changes have not been backported to Java versions less than version 14.\n+     *\n+     * Once these changes get backported, https://bugs.openjdk.java.net/browse/JDK-8226575, we can use\n+     * \"getSystemCpuLoad()\" for retrieving the CPU usage values when running in a container environment.\n+     *\n+     * @param cpuUtil The \"recent CPU usage\" for a JVM process with respect to node\n+     * @return the \"recent CPU usage\" for a JVM process with respect to operating environment\n+     *         as a double in [0.0,1.0].\n+     */\n+    public double getContainerProcessCpuLoad(double cpuUtil) {\n+        int logicalProcessorsOfNode = getAvailableProcessors();\n+        double cpuQuota = getCpuQuota();\n+        if (cpuQuota == -1) {\n+            /* A CPU quota value of -1 indicates that the cgroup does not adhere to any CPU time restrictions so we\n+             * will use the original container agnostic CPU usage value.\n+             */\n+            return cpuUtil;\n+        }\n+\n+        // Get the number of CPUs of a node that can be used by the operating environment\n+        double cpuLimit = (cpuQuota / getCpuPeriod());\n+\n+        // Get the minimal number of CPUs needed to achieve the reported CPU utilization\n+        double cpus = cpuUtil * logicalProcessorsOfNode;\n+\n+        /* Calculate the CPU utilization of a JVM process with respect to the operating environment.\n+         * Since the operating environment will only use the CPU resources allocated by CGroups,\n+         * it will always be that: cpuLimit >= cpus and the result is in the [0.0,1.0] interval.\n+         */\n+        return cpus / cpuLimit;\n+    }\n+\n+    public enum CgroupFiles {\n+\n+        QUOTA_PATH(\"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\"),\n+        PERIOD_PATH(\"/sys/fs/cgroup/cpu/cpu.cfs_period_us\");\n+\n+        private String _value;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzMDE0NA==", "bodyText": "Can we move nproc to a static variable?", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459130144", "createdAt": "2020-07-22T22:58:13Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {\n+\n+    public double getCpuPeriod() {\n+        return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+    }\n+\n+    public double getCpuQuota() {\n+        return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+    }\n+\n+    /**\n+     * Gets the the number of logical cores available to the node.\n+     *\n+     * We can get this value while running in a container by using the \"nproc\" command.\n+     * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+     * Runtime.getRuntime().availableProcessors() would require disabling container\n+     * support (-XX:-UseContainerSupport) since these methods are aware of container\n+     * boundaries\n+     *\n+     * @return Number of logical processors on node\n+     */\n+    public int getAvailableProcessors() {\n+        int proc = 1;\n+        try {\n+            InputStream in = Runtime.getRuntime().exec(\"nproc\").getInputStream();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNzY0NQ==", "bodyText": "Do we need a while statement here -- i.e. does it ever loop?\nThis function seems to just return the first line from the given input stream. If the stream is empty, it returns null. Can we drop the loop and rename the function to reflect what it does?\n-- also is it ever acceptable for this function to return null? Should we handle the null case either at this function or in its returned context?", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459137645", "createdAt": "2020-07-22T23:21:39Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {\n+\n+    public double getCpuPeriod() {\n+        return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+    }\n+\n+    public double getCpuQuota() {\n+        return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+    }\n+\n+    /**\n+     * Gets the the number of logical cores available to the node.\n+     *\n+     * We can get this value while running in a container by using the \"nproc\" command.\n+     * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+     * Runtime.getRuntime().availableProcessors() would require disabling container\n+     * support (-XX:-UseContainerSupport) since these methods are aware of container\n+     * boundaries\n+     *\n+     * @return Number of logical processors on node\n+     */\n+    public int getAvailableProcessors() {\n+        int proc = 1;\n+        try {\n+            InputStream in = Runtime.getRuntime().exec(\"nproc\").getInputStream();\n+            proc = Integer.parseInt(readStringValue(in));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return proc;\n+    }\n+\n+    private static String readFile(String path) {\n+        String s = null;\n+        try {\n+            s = readStringValue(new FileInputStream(path));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return s;\n+    }\n+\n+    private static String readStringValue(InputStream in) {\n+        try {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+            String line;\n+            while ((line = br.readLine()) != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzOTE1MA==", "bodyText": "Can we update Configurations.md to document these new configs?", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459139150", "createdAt": "2020-07-22T23:26:29Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/CruiseControlMetricsReporterConfig.java", "diffHunk": "@@ -50,6 +50,9 @@\n   public static final String CRUISE_CONTROL_METRICS_REPORTER_BATCH_SIZE_CONFIG = PREFIX + \"batch.size\";\n   private static final String CRUISE_CONTROL_METRICS_REPORTER_BATCH_SIZE_DOC = \"The batch.size configuration of KafkaProducer used in Cruise \"\n       + \"Control metrics reporter. Set this config and cruise.control.metrics.reporter.linger.ms to a large number to have better batching.\";\n+  public static final String CRUISE_CONTROL_METRICS_REPORTER_KUBERNETES_MODE_CONFIG = PREFIX + \"kubernetes.mode\";\n+  public static final String CRUISE_CONTROL_METRICS_REPORTER_KUBERNETES_MODE_DOC = \"Cruise Control metrics reporter will report \" +\n+          \" metrics using methods that are aware of container boundaries\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MDQ4MQ==", "bodyText": "Can we move the hardcoded -1 to a static variable (and also move the documentation to there)?", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459140481", "createdAt": "2020-07-22T23:30:38Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {\n+\n+    public double getCpuPeriod() {\n+        return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+    }\n+\n+    public double getCpuQuota() {\n+        return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+    }\n+\n+    /**\n+     * Gets the the number of logical cores available to the node.\n+     *\n+     * We can get this value while running in a container by using the \"nproc\" command.\n+     * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+     * Runtime.getRuntime().availableProcessors() would require disabling container\n+     * support (-XX:-UseContainerSupport) since these methods are aware of container\n+     * boundaries\n+     *\n+     * @return Number of logical processors on node\n+     */\n+    public int getAvailableProcessors() {\n+        int proc = 1;\n+        try {\n+            InputStream in = Runtime.getRuntime().exec(\"nproc\").getInputStream();\n+            proc = Integer.parseInt(readStringValue(in));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return proc;\n+    }\n+\n+    private static String readFile(String path) {\n+        String s = null;\n+        try {\n+            s = readStringValue(new FileInputStream(path));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return s;\n+    }\n+\n+    private static String readStringValue(InputStream in) {\n+        try {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                return line;\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get the \"recent CPU usage\" for the JVM process running inside of a container.\n+     *\n+     * At this time, the methods of OperatingSystemMXBean used for retrieving recent CPU usage are not\n+     * container aware and calculate CPU usage with respect to the physical host instead of the operating\n+     * environment from which they are called from. There have been efforts to make these methods container\n+     * aware but the changes have not been backported to Java versions less than version 14.\n+     *\n+     * Once these changes get backported, https://bugs.openjdk.java.net/browse/JDK-8226575, we can use\n+     * \"getSystemCpuLoad()\" for retrieving the CPU usage values when running in a container environment.\n+     *\n+     * @param cpuUtil The \"recent CPU usage\" for a JVM process with respect to node\n+     * @return the \"recent CPU usage\" for a JVM process with respect to operating environment\n+     *         as a double in [0.0,1.0].\n+     */\n+    public double getContainerProcessCpuLoad(double cpuUtil) {\n+        int logicalProcessorsOfNode = getAvailableProcessors();\n+        double cpuQuota = getCpuQuota();\n+        if (cpuQuota == -1) {\n+            /* A CPU quota value of -1 indicates that the cgroup does not adhere to any CPU time restrictions so we\n+             * will use the original container agnostic CPU usage value.\n+             */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MDgzNg==", "bodyText": "Nit: redundant parentheses.", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459140836", "createdAt": "2020-07-22T23:31:51Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {\n+\n+    public double getCpuPeriod() {\n+        return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+    }\n+\n+    public double getCpuQuota() {\n+        return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+    }\n+\n+    /**\n+     * Gets the the number of logical cores available to the node.\n+     *\n+     * We can get this value while running in a container by using the \"nproc\" command.\n+     * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+     * Runtime.getRuntime().availableProcessors() would require disabling container\n+     * support (-XX:-UseContainerSupport) since these methods are aware of container\n+     * boundaries\n+     *\n+     * @return Number of logical processors on node\n+     */\n+    public int getAvailableProcessors() {\n+        int proc = 1;\n+        try {\n+            InputStream in = Runtime.getRuntime().exec(\"nproc\").getInputStream();\n+            proc = Integer.parseInt(readStringValue(in));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return proc;\n+    }\n+\n+    private static String readFile(String path) {\n+        String s = null;\n+        try {\n+            s = readStringValue(new FileInputStream(path));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return s;\n+    }\n+\n+    private static String readStringValue(InputStream in) {\n+        try {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                return line;\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get the \"recent CPU usage\" for the JVM process running inside of a container.\n+     *\n+     * At this time, the methods of OperatingSystemMXBean used for retrieving recent CPU usage are not\n+     * container aware and calculate CPU usage with respect to the physical host instead of the operating\n+     * environment from which they are called from. There have been efforts to make these methods container\n+     * aware but the changes have not been backported to Java versions less than version 14.\n+     *\n+     * Once these changes get backported, https://bugs.openjdk.java.net/browse/JDK-8226575, we can use\n+     * \"getSystemCpuLoad()\" for retrieving the CPU usage values when running in a container environment.\n+     *\n+     * @param cpuUtil The \"recent CPU usage\" for a JVM process with respect to node\n+     * @return the \"recent CPU usage\" for a JVM process with respect to operating environment\n+     *         as a double in [0.0,1.0].\n+     */\n+    public double getContainerProcessCpuLoad(double cpuUtil) {\n+        int logicalProcessorsOfNode = getAvailableProcessors();\n+        double cpuQuota = getCpuQuota();\n+        if (cpuQuota == -1) {\n+            /* A CPU quota value of -1 indicates that the cgroup does not adhere to any CPU time restrictions so we\n+             * will use the original container agnostic CPU usage value.\n+             */\n+            return cpuUtil;\n+        }\n+\n+        // Get the number of CPUs of a node that can be used by the operating environment\n+        double cpuLimit = (cpuQuota / getCpuPeriod());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MTEyNQ==", "bodyText": "Should we handle if getCpuPeriod() returns 0?", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459141125", "createdAt": "2020-07-22T23:32:53Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {\n+\n+    public double getCpuPeriod() {\n+        return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+    }\n+\n+    public double getCpuQuota() {\n+        return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+    }\n+\n+    /**\n+     * Gets the the number of logical cores available to the node.\n+     *\n+     * We can get this value while running in a container by using the \"nproc\" command.\n+     * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+     * Runtime.getRuntime().availableProcessors() would require disabling container\n+     * support (-XX:-UseContainerSupport) since these methods are aware of container\n+     * boundaries\n+     *\n+     * @return Number of logical processors on node\n+     */\n+    public int getAvailableProcessors() {\n+        int proc = 1;\n+        try {\n+            InputStream in = Runtime.getRuntime().exec(\"nproc\").getInputStream();\n+            proc = Integer.parseInt(readStringValue(in));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return proc;\n+    }\n+\n+    private static String readFile(String path) {\n+        String s = null;\n+        try {\n+            s = readStringValue(new FileInputStream(path));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return s;\n+    }\n+\n+    private static String readStringValue(InputStream in) {\n+        try {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                return line;\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get the \"recent CPU usage\" for the JVM process running inside of a container.\n+     *\n+     * At this time, the methods of OperatingSystemMXBean used for retrieving recent CPU usage are not\n+     * container aware and calculate CPU usage with respect to the physical host instead of the operating\n+     * environment from which they are called from. There have been efforts to make these methods container\n+     * aware but the changes have not been backported to Java versions less than version 14.\n+     *\n+     * Once these changes get backported, https://bugs.openjdk.java.net/browse/JDK-8226575, we can use\n+     * \"getSystemCpuLoad()\" for retrieving the CPU usage values when running in a container environment.\n+     *\n+     * @param cpuUtil The \"recent CPU usage\" for a JVM process with respect to node\n+     * @return the \"recent CPU usage\" for a JVM process with respect to operating environment\n+     *         as a double in [0.0,1.0].\n+     */\n+    public double getContainerProcessCpuLoad(double cpuUtil) {\n+        int logicalProcessorsOfNode = getAvailableProcessors();\n+        double cpuQuota = getCpuQuota();\n+        if (cpuQuota == -1) {\n+            /* A CPU quota value of -1 indicates that the cgroup does not adhere to any CPU time restrictions so we\n+             * will use the original container agnostic CPU usage value.\n+             */\n+            return cpuUtil;\n+        }\n+\n+        // Get the number of CPUs of a node that can be used by the operating environment\n+        double cpuLimit = (cpuQuota / getCpuPeriod());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE0MTQ0Mg==", "bodyText": "Should we handle getCpuQuota() being 0?", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r459141442", "createdAt": "2020-07-22T23:33:58Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/*\n+ * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public class ContainerMetricUtils {\n+\n+    public double getCpuPeriod() {\n+        return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+    }\n+\n+    public double getCpuQuota() {\n+        return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+    }\n+\n+    /**\n+     * Gets the the number of logical cores available to the node.\n+     *\n+     * We can get this value while running in a container by using the \"nproc\" command.\n+     * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+     * Runtime.getRuntime().availableProcessors() would require disabling container\n+     * support (-XX:-UseContainerSupport) since these methods are aware of container\n+     * boundaries\n+     *\n+     * @return Number of logical processors on node\n+     */\n+    public int getAvailableProcessors() {\n+        int proc = 1;\n+        try {\n+            InputStream in = Runtime.getRuntime().exec(\"nproc\").getInputStream();\n+            proc = Integer.parseInt(readStringValue(in));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return proc;\n+    }\n+\n+    private static String readFile(String path) {\n+        String s = null;\n+        try {\n+            s = readStringValue(new FileInputStream(path));\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return s;\n+    }\n+\n+    private static String readStringValue(InputStream in) {\n+        try {\n+            BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                return line;\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Get the \"recent CPU usage\" for the JVM process running inside of a container.\n+     *\n+     * At this time, the methods of OperatingSystemMXBean used for retrieving recent CPU usage are not\n+     * container aware and calculate CPU usage with respect to the physical host instead of the operating\n+     * environment from which they are called from. There have been efforts to make these methods container\n+     * aware but the changes have not been backported to Java versions less than version 14.\n+     *\n+     * Once these changes get backported, https://bugs.openjdk.java.net/browse/JDK-8226575, we can use\n+     * \"getSystemCpuLoad()\" for retrieving the CPU usage values when running in a container environment.\n+     *\n+     * @param cpuUtil The \"recent CPU usage\" for a JVM process with respect to node\n+     * @return the \"recent CPU usage\" for a JVM process with respect to operating environment\n+     *         as a double in [0.0,1.0].\n+     */\n+    public double getContainerProcessCpuLoad(double cpuUtil) {\n+        int logicalProcessorsOfNode = getAvailableProcessors();\n+        double cpuQuota = getCpuQuota();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a9b3fb47f4c1cbb98d57740ed33e04466ecd439"}, "originalPosition": 86}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a23ccc73abbc743603c65c621857a1346d5dd9b", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/linkedin/cruise-control/commit/9a23ccc73abbc743603c65c621857a1346d5dd9b", "committedDate": "2020-07-27T23:24:11Z", "message": "Addressing comments\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1d4274c8eec99443539595bc22808f6d5720910", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/linkedin/cruise-control/commit/c1d4274c8eec99443539595bc22808f6d5720910", "committedDate": "2020-07-27T23:32:40Z", "message": "Fix indentation to from 4 to 2 spaces for consistency with project\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f29e3d682eadf34e8c90afeff74f41a1d9d049b1", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/linkedin/cruise-control/commit/f29e3d682eadf34e8c90afeff74f41a1d9d049b1", "committedDate": "2020-07-27T23:35:49Z", "message": "Remove extra lines added to build.gradle file\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MjQ5ODI5", "url": "https://github.com/linkedin/cruise-control/pull/1277#pullrequestreview-456249829", "createdAt": "2020-07-28T01:56:45Z", "commit": {"oid": "f29e3d682eadf34e8c90afeff74f41a1d9d049b1"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwMTo1Njo0NVrOG35wug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwMjo0MDo0OFrOG36f1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI3MTIyNg==", "bodyText": "Nit: Redundant semicolon.", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r461271226", "createdAt": "2020-07-28T01:56:45Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public final class ContainerMetricUtils {\n+  // Paths used to get cgroup information\n+  private static final String QUOTA_PATH = \"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\";\n+  private static final String PERIOD_PATH = \"/sys/fs/cgroup/cpu/cpu.cfs_period_us\";\n+  // Unix command to execute inside a Linux container to get the number of logical processors available to the node\n+  private static final String NPROC = \"nproc\";\n+  // A CPU quota value of -1 indicates that the cgroup does not adhere to any CPU time restrictions\n+  public static final int NO_CPU_QUOTA = -1;\n+\n+  private ContainerMetricUtils() { };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f29e3d682eadf34e8c90afeff74f41a1d9d049b1"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI3MTg5NA==", "bodyText": "If the stream is empty (or similarly if there is an IOException), the function prints the relevant stack trace and returns a null. This later causes exceptions such as a NullPointerException (e.g. https://github.com/linkedin/cruise-control/pull/1277/files#diff-9c19ccfff1709f545e3cf0352470a21bR42) and NumberFormatException (see https://github.com/linkedin/cruise-control/pull/1277/files#diff-9c19ccfff1709f545e3cf0352470a21bR60). If any of these unexpected conditions occur, presumably, they indicate a broken/unexpected environment setup. In those cases, I wonder if just throwing the relevant exceptions would suffice? We know that eventually, all such exceptions are going to be handled/caught by https://github.com/linkedin/cruise-control/pull/1277/files#diff-8f6babccb3903b0056ad0c2c2e6d7adeR284.", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r461271894", "createdAt": "2020-07-28T01:59:19Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public final class ContainerMetricUtils {\n+  // Paths used to get cgroup information\n+  private static final String QUOTA_PATH = \"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\";\n+  private static final String PERIOD_PATH = \"/sys/fs/cgroup/cpu/cpu.cfs_period_us\";\n+  // Unix command to execute inside a Linux container to get the number of logical processors available to the node\n+  private static final String NPROC = \"nproc\";\n+  // A CPU quota value of -1 indicates that the cgroup does not adhere to any CPU time restrictions\n+  public static final int NO_CPU_QUOTA = -1;\n+\n+  private ContainerMetricUtils() { };\n+\n+  /**\n+   * Reads Cgroups CPU period from Cgroups file. Value has a lowerbound of 1 millisecond and  an upperbound of 1 second\n+   * according to https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt\n+   *\n+   * @return Cgroups CPU period in microseconds as a double.\n+   */\n+  private static double getCpuPeriod() {\n+    return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+  }\n+\n+  /**\n+   * Reads Cgroups CPU quota from Cgroups file. The value has lowerbound of 1 millisecond\n+   * according to https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt\n+   *\n+   * @return Cgroups CPU quota in microseconds as a double.\n+   */\n+  private static double getCpuQuota() {\n+    return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+  }\n+\n+  /**\n+   * Gets the the number of logical cores available to the node.\n+   * <p>\n+   * We can get this value while running in a container by using the \"nproc\" command.\n+   * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+   * Runtime.getRuntime().availableProcessors() would require disabling container\n+   * support (-XX:-UseContainerSupport) since these methods are aware of container\n+   * boundaries\n+   *\n+   * @return Number of logical processors on node\n+   */\n+  private static int getAvailableProcessors() {\n+    int proc = 1;\n+    try {\n+      InputStream in = Runtime.getRuntime().exec(NPROC).getInputStream();\n+      proc = Integer.parseInt(readInputStream(in));\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+    }\n+    return proc;\n+  }\n+\n+  private static String readFile(String path) {\n+    try {\n+      return readInputStream(new FileInputStream(path));\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+    }\n+    return null;\n+  }\n+\n+  private static String readInputStream(InputStream in) {\n+    try {\n+      BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+      String stream = br.readLine();\n+      if (stream != null) {\n+        return stream;\n+      } else {\n+        throw new EmptyInputStreamException(\"Nothing was read from stream \" + in);\n+      }\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+    } catch (EmptyInputStreamException e) {\n+      e.printStackTrace();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f29e3d682eadf34e8c90afeff74f41a1d9d049b1"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI4MzI4Nw==", "bodyText": "Should we avoid introducing a new exception type by throwing an IllegalArgumentException here?", "url": "https://github.com/linkedin/cruise-control/pull/1277#discussion_r461283287", "createdAt": "2020-07-28T02:40:48Z", "author": {"login": "efeg"}, "path": "cruise-control-metrics-reporter/src/main/java/com/linkedin/kafka/cruisecontrol/metricsreporter/metric/ContainerMetricUtils.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.metricsreporter.metric;\n+\n+import java.io.BufferedReader;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.nio.charset.StandardCharsets;\n+\n+public final class ContainerMetricUtils {\n+  // Paths used to get cgroup information\n+  private static final String QUOTA_PATH = \"/sys/fs/cgroup/cpu/cpu.cfs_quota_us\";\n+  private static final String PERIOD_PATH = \"/sys/fs/cgroup/cpu/cpu.cfs_period_us\";\n+  // Unix command to execute inside a Linux container to get the number of logical processors available to the node\n+  private static final String NPROC = \"nproc\";\n+  // A CPU quota value of -1 indicates that the cgroup does not adhere to any CPU time restrictions\n+  public static final int NO_CPU_QUOTA = -1;\n+\n+  private ContainerMetricUtils() { };\n+\n+  /**\n+   * Reads Cgroups CPU period from Cgroups file. Value has a lowerbound of 1 millisecond and  an upperbound of 1 second\n+   * according to https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt\n+   *\n+   * @return Cgroups CPU period in microseconds as a double.\n+   */\n+  private static double getCpuPeriod() {\n+    return Double.parseDouble(readFile(CgroupFiles.PERIOD_PATH.getValue()));\n+  }\n+\n+  /**\n+   * Reads Cgroups CPU quota from Cgroups file. The value has lowerbound of 1 millisecond\n+   * according to https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt\n+   *\n+   * @return Cgroups CPU quota in microseconds as a double.\n+   */\n+  private static double getCpuQuota() {\n+    return Double.parseDouble(readFile(CgroupFiles.QUOTA_PATH.getValue()));\n+  }\n+\n+  /**\n+   * Gets the the number of logical cores available to the node.\n+   * <p>\n+   * We can get this value while running in a container by using the \"nproc\" command.\n+   * Using other methods like OperatingSystemMXBean.getAvailableProcessors() and\n+   * Runtime.getRuntime().availableProcessors() would require disabling container\n+   * support (-XX:-UseContainerSupport) since these methods are aware of container\n+   * boundaries\n+   *\n+   * @return Number of logical processors on node\n+   */\n+  private static int getAvailableProcessors() {\n+    int proc = 1;\n+    try {\n+      InputStream in = Runtime.getRuntime().exec(NPROC).getInputStream();\n+      proc = Integer.parseInt(readInputStream(in));\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+    }\n+    return proc;\n+  }\n+\n+  private static String readFile(String path) {\n+    try {\n+      return readInputStream(new FileInputStream(path));\n+    } catch (IOException e) {\n+      e.printStackTrace();\n+    }\n+    return null;\n+  }\n+\n+  private static String readInputStream(InputStream in) {\n+    try {\n+      BufferedReader br = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));\n+      String stream = br.readLine();\n+      if (stream != null) {\n+        return stream;\n+      } else {\n+        throw new EmptyInputStreamException(\"Nothing was read from stream \" + in);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f29e3d682eadf34e8c90afeff74f41a1d9d049b1"}, "originalPosition": 83}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d91096e34b6ff7c647007b9a98e1036b778aab88", "author": {"user": {"login": "kyguy", "name": "Kyle Liberti"}}, "url": "https://github.com/linkedin/cruise-control/commit/d91096e34b6ff7c647007b9a98e1036b778aab88", "committedDate": "2020-07-28T21:29:06Z", "message": "Fix typos and exception handling\n\nSigned-off-by: Kyle Liberti <kliberti@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MDMxMzA3", "url": "https://github.com/linkedin/cruise-control/pull/1277#pullrequestreview-458031307", "createdAt": "2020-07-30T02:34:21Z", "commit": {"oid": "d91096e34b6ff7c647007b9a98e1036b778aab88"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 262, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}