{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxNTkwNzIz", "number": 1124, "title": "Skip replication factor self-healing if topic's minISR is larger than target replication factor.", "bodyText": "Addresses the issue #1112 .", "createdAt": "2020-02-28T20:54:38Z", "url": "https://github.com/linkedin/cruise-control/pull/1124", "merged": true, "mergeCommit": {"oid": "45f442b9089e71d0e34f853e307556e090ab18e9"}, "closed": true, "closedAt": "2020-03-03T04:28:01Z", "author": {"login": "kidkun"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcI3hbXABqjMwODM3MTUzMTU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcJ5PQNgFqTM2NzY3MjMyOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7a66b7abb006e1f4bf08e04d0a00be9f2eb725c0", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/7a66b7abb006e1f4bf08e04d0a00be9f2eb725c0", "committedDate": "2020-02-28T20:51:18Z", "message": "Skip replication factor self-healing if topic's minISR is larger than target replication factor."}, "afterCommit": {"oid": "dd835bc64f153e56b280453b54236fc33435a0ff", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/dd835bc64f153e56b280453b54236fc33435a0ff", "committedDate": "2020-02-28T22:16:07Z", "message": "Skip replication factor self-healing if topic's minISR is larger than target replication factor."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NzY5OTcx", "url": "https://github.com/linkedin/cruise-control/pull/1124#pullrequestreview-366769971", "createdAt": "2020-02-29T02:24:34Z", "commit": {"oid": "dd835bc64f153e56b280453b54236fc33435a0ff"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwMjoyNDozNFrOFwHIgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwMjozODowNFrOFwHL_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MjgzNQ==", "bodyText": "Nit: The name _badTopicsByFixability is not clear -- can we rename it to represent what bad means?", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r385992835", "createdAt": "2020-02-29T02:24:34Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java", "diffHunk": "@@ -31,11 +31,14 @@\n  */\n public class TopicReplicationFactorAnomaly extends TopicAnomaly {\n   protected Short _targetReplicationFactor;\n-  protected Set<String> _topicsWithBadReplicationFactor;\n+  protected Map<Boolean, Set<String>> _badTopicsByFixability;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd835bc64f153e56b280453b54236fc33435a0ff"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MzA0NA==", "bodyText": "When is this expected to happen? Should we instead throw illegal state exception here?", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r385993044", "createdAt": "2020-02-29T02:27:27Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java", "diffHunk": "@@ -31,11 +31,14 @@\n  */\n public class TopicReplicationFactorAnomaly extends TopicAnomaly {\n   protected Short _targetReplicationFactor;\n-  protected Set<String> _topicsWithBadReplicationFactor;\n+  protected Map<Boolean, Set<String>> _badTopicsByFixability;\n   protected UpdateTopicConfigurationRunnable _updateTopicConfigurationRunnable;\n \n   @Override\n   public boolean fix() throws Exception {\n+    if (_updateTopicConfigurationRunnable == null) {\n+      return false;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd835bc64f153e56b280453b54236fc33435a0ff"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MzMxMA==", "bodyText": "Nit: -> Short.parseShort(entry.getValue().get().get(TopicConfig.MIN_IN_SYNC_REPLICAS_CONFIG).value());", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r385993310", "createdAt": "2020-02-29T02:31:31Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -61,17 +76,35 @@\n       }\n     }\n     if (!topicsWithBadReplicationFactor.isEmpty()) {\n-      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+      Map<Boolean, Set<String>> topicsByFixability = new HashMap<>(2);\n+      List<ConfigResource> topicResourcesToCheck = new ArrayList<>(topicsWithBadReplicationFactor.size());\n+      topicsWithBadReplicationFactor.forEach(t -> topicResourcesToCheck.add(new ConfigResource(ConfigResource.Type.TOPIC, t)));\n+      for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry: _adminClient.describeConfigs(topicResourcesToCheck).values().entrySet()) {\n+        try {\n+          short topicMinISR = Short.valueOf(entry.getValue().get().get(TopicConfig.MIN_IN_SYNC_REPLICAS_CONFIG).value());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd835bc64f153e56b280453b54236fc33435a0ff"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MzQ3OQ==", "bodyText": "Can we move this logic to a smaller function for ease of readiblity?", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r385993479", "createdAt": "2020-02-29T02:33:47Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -61,17 +76,35 @@\n       }\n     }\n     if (!topicsWithBadReplicationFactor.isEmpty()) {\n-      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+      Map<Boolean, Set<String>> topicsByFixability = new HashMap<>(2);\n+      List<ConfigResource> topicResourcesToCheck = new ArrayList<>(topicsWithBadReplicationFactor.size());\n+      topicsWithBadReplicationFactor.forEach(t -> topicResourcesToCheck.add(new ConfigResource(ConfigResource.Type.TOPIC, t)));\n+      for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry: _adminClient.describeConfigs(topicResourcesToCheck).values().entrySet()) {\n+        try {\n+          short topicMinISR = Short.valueOf(entry.getValue().get().get(TopicConfig.MIN_IN_SYNC_REPLICAS_CONFIG).value());\n+          if (topicMinISR > _targetReplicationFactor) {\n+            topicsByFixability.putIfAbsent(false, new HashSet<>());\n+            topicsByFixability.get(false).add(entry.getKey().name());\n+          } else {\n+            topicsByFixability.putIfAbsent(true, new HashSet<>());\n+            topicsByFixability.get(true).add(entry.getKey().name());\n+          }\n+        } catch (InterruptedException | ExecutionException e) {\n+          LOG.warn(\"Skip attempt to fix topic {}'s replication factor due to unable to retrieve its minISR config.\",\n+                   entry.getKey().name());\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd835bc64f153e56b280453b54236fc33435a0ff"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MzY3Mw==", "bodyText": "Ideally, we should adopt a solution that avoids calling describeConfigs every time.\nCan we cache this once, and call again only when needed? -- e.g. when new topics are added, if the cache is invalidated after a predefined timeout, or if the user explicitly invalidates the cache via admin endpoint maybe?", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r385993673", "createdAt": "2020-02-29T02:36:56Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -61,17 +76,35 @@\n       }\n     }\n     if (!topicsWithBadReplicationFactor.isEmpty()) {\n-      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+      Map<Boolean, Set<String>> topicsByFixability = new HashMap<>(2);\n+      List<ConfigResource> topicResourcesToCheck = new ArrayList<>(topicsWithBadReplicationFactor.size());\n+      topicsWithBadReplicationFactor.forEach(t -> topicResourcesToCheck.add(new ConfigResource(ConfigResource.Type.TOPIC, t)));\n+      for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry: _adminClient.describeConfigs(topicResourcesToCheck).values().entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd835bc64f153e56b280453b54236fc33435a0ff"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk5MzcyNw==", "bodyText": "This get() on future should have a timeout to avoid blocking.", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r385993727", "createdAt": "2020-02-29T02:38:04Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -61,17 +76,35 @@\n       }\n     }\n     if (!topicsWithBadReplicationFactor.isEmpty()) {\n-      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+      Map<Boolean, Set<String>> topicsByFixability = new HashMap<>(2);\n+      List<ConfigResource> topicResourcesToCheck = new ArrayList<>(topicsWithBadReplicationFactor.size());\n+      topicsWithBadReplicationFactor.forEach(t -> topicResourcesToCheck.add(new ConfigResource(ConfigResource.Type.TOPIC, t)));\n+      for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry: _adminClient.describeConfigs(topicResourcesToCheck).values().entrySet()) {\n+        try {\n+          short topicMinISR = Short.valueOf(entry.getValue().get().get(TopicConfig.MIN_IN_SYNC_REPLICAS_CONFIG).value());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dd835bc64f153e56b280453b54236fc33435a0ff"}, "originalPosition": 62}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NDgxMzgx", "url": "https://github.com/linkedin/cruise-control/pull/1124#pullrequestreview-367481381", "createdAt": "2020-03-02T19:52:15Z", "commit": {"oid": "b886ed40bb66c3188861c38c481c937c4b17b66c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxOTo1MjoxNVrOFwtDPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMDozNjoxMlrOFw0cSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYxNDA3OQ==", "bodyText": "Nit: Not sure if we should call it METADATA_FETCH_TIMEOUT_MS. Doesn't this timeout correspond to describe config retrieval -- i.e. not metadata?", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386614079", "createdAt": "2020-03-02T19:52:15Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -53,11 +62,19 @@\n   public static final String TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG = \"topic.replication.topic.anomaly.class\";\n   public static final Class<?> DEFAULT_TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS = TopicReplicationFactorAnomaly.class;\n   public static final String TOPICS_WITH_BAD_REPLICATION_FACTOR_BY_FIXABILITY_CONFIG = \"topics.with.bad.replication.factor.by.fixability\";\n+  public static final String TOPIC_REPLICATION_FACTOR_MARGIN_CONFIG = \"topic.replication.factor.margin\";\n+  public static final short DEFAULT_TOPIC_REPLICATION_FACTOR_MARGIN = 1;\n+  public static final String TOPIC_MIN_ISR_RECORD_RETENTION_TIME_MS_CONFIG = \"topic.min.isr.record.retention.time.ms\";\n+  public static final long DEFAULT_TOPIC_MIN_ISR_RECORD_RETENTION_TIME_MS = 12 * 60 * 60 * 1000;\n+  private static final long METADATA_FETCH_TIMEOUT_MS = 100000L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b886ed40bb66c3188861c38c481c937c4b17b66c"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyODMyMA==", "bodyText": "(Applies to similar usage above) Can we avoid this extra checks and the following length-pruning by (1) ensuring that  _topicsWithBadReplicationFactorByFixability is created with an empty collection in case no unfixable / fixable topics exist and (2) using StringJoiner joiner = new StringJoiner(\",\"); as we do in GoalViolations#toString()?", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386728320", "createdAt": "2020-03-03T00:13:31Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomaly.java", "diffHunk": "@@ -90,13 +90,13 @@ public String toString() {\n     sb.append(\"{Detected following topics which have at least one partition with replication factor other than \")\n       .append(_targetReplicationFactor)\n       .append(\" : {fixable : [\");\n-    if (_badTopicsByFixability.get(true) != null && !_badTopicsByFixability.get(true).isEmpty()) {\n-      _badTopicsByFixability.get(true).forEach(t -> sb.append(t).append(\", \"));\n+    if (_topicsWithBadReplicationFactorByFixability.get(true) != null && !_topicsWithBadReplicationFactorByFixability.get(true).isEmpty()) {\n+      _topicsWithBadReplicationFactorByFixability.get(true).forEach(t -> sb.append(t).append(\", \"));\n       sb.setLength(sb.length() - 2);\n     }\n     sb.append(\"], unfixable : [\");\n-    if (_badTopicsByFixability.get(false) != null && !_badTopicsByFixability.get(false).isEmpty()) {\n-      _badTopicsByFixability.get(false).forEach(t -> sb.append(t).append(\", \"));\n+    if (_topicsWithBadReplicationFactorByFixability.get(false) != null && !_topicsWithBadReplicationFactorByFixability.get(false).isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b886ed40bb66c3188861c38c481c937c4b17b66c"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyOTQ1OQ==", "bodyText": "Can we move this to a function? -- It seems to have a specific role of checking for minIsr.", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386729459", "createdAt": "2020-03-03T00:17:18Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -75,23 +92,20 @@\n         }\n       }\n     }\n+    refreshTopicMinISRCache();\n     if (!topicsWithBadReplicationFactor.isEmpty()) {\n+      maybeRetrieveAndCacheTopicMinISR(topicsWithBadReplicationFactor);\n       Map<Boolean, Set<String>> topicsByFixability = new HashMap<>(2);\n-      List<ConfigResource> topicResourcesToCheck = new ArrayList<>(topicsWithBadReplicationFactor.size());\n-      topicsWithBadReplicationFactor.forEach(t -> topicResourcesToCheck.add(new ConfigResource(ConfigResource.Type.TOPIC, t)));\n-      for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry: _adminClient.describeConfigs(topicResourcesToCheck).values().entrySet()) {\n-        try {\n-          short topicMinISR = Short.valueOf(entry.getValue().get().get(TopicConfig.MIN_IN_SYNC_REPLICAS_CONFIG).value());\n-          if (topicMinISR > _targetReplicationFactor) {\n+      for (String topic : topicsWithBadReplicationFactor) {\n+        if (_cachedTopicMinISR.containsKey(topic)) {\n+          short topicMinISR = _cachedTopicMinISR.get(topic).minISR();\n+          if (_targetReplicationFactor < topicMinISR + _topicReplicationFactorMargin) {\n             topicsByFixability.putIfAbsent(false, new HashSet<>());\n-            topicsByFixability.get(false).add(entry.getKey().name());\n+            topicsByFixability.get(false).add(topic);\n           } else {\n             topicsByFixability.putIfAbsent(true, new HashSet<>());\n-            topicsByFixability.get(true).add(entry.getKey().name());\n+            topicsByFixability.get(true).add(topic);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b886ed40bb66c3188861c38c481c937c4b17b66c"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjcyOTc2OA==", "bodyText": "Nit: I am curious whether List is necessary here -- i.e. do we need ordering?", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386729768", "createdAt": "2020-03-03T00:18:19Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -100,6 +114,42 @@\n     return Collections.emptySet();\n   }\n \n+  /**\n+   * Retrieve topic minISR config information if it is not cached locally.\n+   * @param topicsToCheck Set of topics to check.\n+   */\n+  private void maybeRetrieveAndCacheTopicMinISR(Set<String> topicsToCheck) {\n+    List<ConfigResource> topicResourcesToCheck = new ArrayList<>(topicsToCheck.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b886ed40bb66c3188861c38c481c937c4b17b66c"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczMDU1Nw==", "bodyText": "Nit (just personal style note -- please feel free to ignore): I usually prefer the format X of Y rather than Y's X, which makes it easier to parse logs and JavaDoc.", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386730557", "createdAt": "2020-03-03T00:20:52Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -100,6 +114,42 @@\n     return Collections.emptySet();\n   }\n \n+  /**\n+   * Retrieve topic minISR config information if it is not cached locally.\n+   * @param topicsToCheck Set of topics to check.\n+   */\n+  private void maybeRetrieveAndCacheTopicMinISR(Set<String> topicsToCheck) {\n+    List<ConfigResource> topicResourcesToCheck = new ArrayList<>(topicsToCheck.size());\n+    topicsToCheck.stream().filter(t -> !_cachedTopicMinISR.containsKey(t))\n+                          .forEach(t -> topicResourcesToCheck.add(new ConfigResource(ConfigResource.Type.TOPIC, t)));\n+    for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry : _adminClient.describeConfigs(topicResourcesToCheck).values().entrySet()) {\n+      try {\n+        short topicMinISR = Short.parseShort(entry.getValue().get(METADATA_FETCH_TIMEOUT_MS, TimeUnit.MILLISECONDS)\n+                                                  .get(TopicConfig.MIN_IN_SYNC_REPLICAS_CONFIG).value());\n+        _cachedTopicMinISR.put(entry.getKey().name(), new TopicMinISREntry(topicMinISR, System.currentTimeMillis()));\n+      } catch (TimeoutException | InterruptedException | ExecutionException e) {\n+        LOG.warn(\"Skip attempt to fix topic {}'s replication factor due to unable to retrieve its minISR config.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b886ed40bb66c3188861c38c481c937c4b17b66c"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNDI0Nw==", "bodyText": "Nit: Missing space before is", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386734247", "createdAt": "2020-03-03T00:33:07Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -83,11 +166,12 @@ public void configure(Map<String, ?> configs) {\n     if (_kafkaCruiseControl == null) {\n       throw new IllegalArgumentException(\"Topic replication factor anomaly finder is missing \" + KAFKA_CRUISE_CONTROL_OBJECT_CONFIG);\n     }\n-    Short targetReplicationFactor = (Short) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n-    if (targetReplicationFactor == null) {\n-      throw new IllegalArgumentException(\"Topic replication factor anomaly finder is missing \" + SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG);\n+    try {\n+      _targetReplicationFactor = Short.parseShort((String) configs.get(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG));\n+    } catch (NumberFormatException e) {\n+      throw new IllegalArgumentException(SELF_HEALING_TARGET_TOPIC_REPLICATION_FACTOR_CONFIG +\n+                                         \"is missing or misconfigured for topic replication factor anomaly finder.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b886ed40bb66c3188861c38c481c937c4b17b66c"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNDUwNA==", "bodyText": "Should we have a sanity check here regarding the acceptable range of values in the MARGIN?", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386734504", "createdAt": "2020-03-03T00:34:01Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -103,5 +187,40 @@ public void configure(Map<String, ?> configs) {\n               TOPIC_REPLICATION_FACTOR_ANOMALY_CLASS_CONFIG, _topicReplicationTopicAnomalyClass));\n       }\n     }\n+    try {\n+      _topicReplicationFactorMargin = Short.parseShort((String) configs.get(TOPIC_REPLICATION_FACTOR_MARGIN_CONFIG));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b886ed40bb66c3188861c38c481c937c4b17b66c"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjczNTE3Ng==", "bodyText": "What if topicResourcesToCheck is empty -- do we need a call to adminClient in this case?", "url": "https://github.com/linkedin/cruise-control/pull/1124#discussion_r386735176", "createdAt": "2020-03-03T00:36:12Z", "author": {"login": "efeg"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/TopicReplicationFactorAnomalyFinder.java", "diffHunk": "@@ -60,18 +92,69 @@\n         }\n       }\n     }\n+    refreshTopicMinISRCache();\n     if (!topicsWithBadReplicationFactor.isEmpty()) {\n-      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsWithBadReplicationFactor,\n+      maybeRetrieveAndCacheTopicMinISR(topicsWithBadReplicationFactor);\n+      Map<Boolean, Set<String>> topicsByFixability = new HashMap<>(2);\n+      for (String topic : topicsWithBadReplicationFactor) {\n+        if (_cachedTopicMinISR.containsKey(topic)) {\n+          short topicMinISR = _cachedTopicMinISR.get(topic).minISR();\n+          if (_targetReplicationFactor < topicMinISR + _topicReplicationFactorMargin) {\n+            topicsByFixability.putIfAbsent(false, new HashSet<>());\n+            topicsByFixability.get(false).add(topic);\n+          } else {\n+            topicsByFixability.putIfAbsent(true, new HashSet<>());\n+            topicsByFixability.get(true).add(topic);\n+          }\n+        }\n+      }\n+      return Collections.singleton(createTopicReplicationFactorAnomaly(topicsByFixability,\n                                                                        _targetReplicationFactor));\n     }\n     return Collections.emptySet();\n   }\n \n-  private TopicAnomaly createTopicReplicationFactorAnomaly(Set<String> topicsWithBadReplicationFactor,\n-                                                           int targetReplicationFactor) {\n+  /**\n+   * Retrieve topic minISR config information if it is not cached locally.\n+   * @param topicsToCheck Set of topics to check.\n+   */\n+  private void maybeRetrieveAndCacheTopicMinISR(Set<String> topicsToCheck) {\n+    List<ConfigResource> topicResourcesToCheck = new ArrayList<>(topicsToCheck.size());\n+    topicsToCheck.stream().filter(t -> !_cachedTopicMinISR.containsKey(t))\n+                          .forEach(t -> topicResourcesToCheck.add(new ConfigResource(ConfigResource.Type.TOPIC, t)));\n+    for (Map.Entry<ConfigResource, KafkaFuture<Config>> entry : _adminClient.describeConfigs(topicResourcesToCheck).values().entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b886ed40bb66c3188861c38c481c937c4b17b66c"}, "originalPosition": 109}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b9923a6f2369096405997206c685d2589ad6359", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/2b9923a6f2369096405997206c685d2589ad6359", "committedDate": "2020-03-03T01:21:41Z", "message": "Skip replication factor self-healing if topic's minISR is larger than target replication factor."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99b0383d3f92d3282d9130edf10d0c9a21baee49", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/99b0383d3f92d3282d9130edf10d0c9a21baee49", "committedDate": "2020-03-03T01:21:41Z", "message": "Address the feedback."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e69997b7ccae097ac425860975c2c5756aa7135f", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/e69997b7ccae097ac425860975c2c5756aa7135f", "committedDate": "2020-03-03T01:21:41Z", "message": "Address the feedback."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b886ed40bb66c3188861c38c481c937c4b17b66c", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/b886ed40bb66c3188861c38c481c937c4b17b66c", "committedDate": "2020-03-02T19:28:09Z", "message": "Address the feedback."}, "afterCommit": {"oid": "e69997b7ccae097ac425860975c2c5756aa7135f", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/e69997b7ccae097ac425860975c2c5756aa7135f", "committedDate": "2020-03-03T01:21:41Z", "message": "Address the feedback."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NjcyMzI5", "url": "https://github.com/linkedin/cruise-control/pull/1124#pullrequestreview-367672329", "createdAt": "2020-03-03T02:52:39Z", "commit": {"oid": "e69997b7ccae097ac425860975c2c5756aa7135f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 177, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}