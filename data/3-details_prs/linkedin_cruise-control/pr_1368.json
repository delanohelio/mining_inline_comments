{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzMjE1ODQ0", "number": 1368, "title": "Automate leadership concurrency adjustment based on broker metrics", "bodyText": "This PR resolves #1298.\n--\nWe verified that the existing metrics already exhibit strong positive correlation with high concurrency leadership movements. In particular, high concurrency may lead to significant increase in request queue size, produce local time, and log flush time. Going forward, we intend to enrich the metrics tracked for concurrency adjustment. This PR makes use of existing metrics for the concurrency adjustment of leadership movements. It continues excluding replica reordering of partitions during demote, PLE, and replication factor change operations.", "createdAt": "2020-10-30T18:48:48Z", "url": "https://github.com/linkedin/cruise-control/pull/1368", "merged": true, "mergeCommit": {"oid": "2b36e33108d9f0d4950f4e20b6f163125b63ad8f"}, "closed": true, "closedAt": "2020-11-03T21:46:15Z", "author": {"login": "efeg"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdXrLDWgH2gAyNTEzMjE1ODQ0OjkyYjQzMGIxNmM3ZjA0Y2JkNTE2MzFlMmZjNGRhYTUyNGNjZmEyOGM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdY_AVSAFqTUyMjg0MjcyNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "92b430b16c7f04cbd51631e2fc4daa524ccfa28c", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/92b430b16c7f04cbd51631e2fc4daa524ccfa28c", "committedDate": "2020-10-30T18:35:29Z", "message": "Automate leadership concurrency adjustment based on broker metrics"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyMjUxNTU1", "url": "https://github.com/linkedin/cruise-control/pull/1368#pullrequestreview-522251555", "createdAt": "2020-11-03T08:00:15Z", "commit": {"oid": "92b430b16c7f04cbd51631e2fc4daa524ccfa28c"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwODowMDoxNVrOHsjWog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QwODoyMjowOFrOHsj_GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ3ODYyNg==", "bodyText": "Nit: I would use String.format to construct the exception messages to improve readability since these variable names are long. It applies to all ConfigException in this section.", "url": "https://github.com/linkedin/cruise-control/pull/1368#discussion_r516478626", "createdAt": "2020-11-03T08:00:15Z", "author": {"login": "Lincong"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/KafkaCruiseControlConfig.java", "diffHunk": "@@ -244,6 +252,33 @@ private void sanityCheckConcurrency() {\n                                 + \"] cannot be greater than the maximum number of allowed movements in cluster [\"\n                                 + maxClusterPartitionMovementConcurrency + \"].\");\n     }\n+\n+    int concurrencyAdjusterMinPartitionMovementsPerBroker = getInt(ExecutorConfig.CONCURRENCY_ADJUSTER_MIN_PARTITION_MOVEMENTS_PER_BROKER_CONFIG);\n+    if (interBrokerPartitionMovementConcurrency < concurrencyAdjusterMinPartitionMovementsPerBroker) {\n+      throw new ConfigException(\"Inter-broker partition movement concurrency [\" + interBrokerPartitionMovementConcurrency", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b430b16c7f04cbd51631e2fc4daa524ccfa28c"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ4NjE0Nw==", "bodyText": "Nit: I think this statement (353 and 354) and the next line (355) can be swapped. Same case for line 365, 366 and 367", "url": "https://github.com/linkedin/cruise-control/pull/1368#discussion_r516486147", "createdAt": "2020-11-03T08:16:25Z", "author": {"login": "Lincong"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -298,54 +305,80 @@ public void run() {\n   }\n \n   /**\n-   * A runnable class to auto-adjust the allowed inter-broker partition reassignment concurrency for ongoing executions\n+   * A runnable class to auto-adjust the allowed reassignment concurrency for ongoing executions\n    * using selected broker metrics and based on additive-increase/multiplicative-decrease (AIMD) feedback control algorithm.\n    * Skips concurrency adjustment for demote operations.\n    */\n   private class ConcurrencyAdjuster implements Runnable {\n-    private final int _maxPartitionMovementsPerBroker;\n     private LoadMonitor _loadMonitor;\n \n     public ConcurrencyAdjuster() {\n-      _maxPartitionMovementsPerBroker = _config.getInt(ExecutorConfig.CONCURRENCY_ADJUSTER_MAX_PARTITION_MOVEMENTS_PER_BROKER_CONFIG);\n       _loadMonitor = null;\n     }\n \n     /**\n-     * Initialize the inter-broker partition reassignment concurrency adjustment with the load monitor and the initially\n-     * requested inter-broker partition reassignment concurrency.\n+     * Initialize the reassignment concurrency adjustment with the load monitor and the initially requested reassignment concurrency.\n      *\n      * @param loadMonitor Load monitor.\n      * @param requestedInterBrokerPartitionMovementConcurrency The maximum number of concurrent inter-broker partition movements\n      *                                                         per broker(if null, use num.concurrent.partition.movements.per.broker).\n+     * @param requestedLeadershipMovementConcurrency The maximum number of concurrent leader movements\n+     *                                               (if null, use num.concurrent.leader.movements).\n      */\n-    public synchronized void initAdjustment(LoadMonitor loadMonitor, Integer requestedInterBrokerPartitionMovementConcurrency) {\n+    public synchronized void initAdjustment(LoadMonitor loadMonitor,\n+                                            Integer requestedInterBrokerPartitionMovementConcurrency,\n+                                            Integer requestedLeadershipMovementConcurrency) {\n       _loadMonitor = loadMonitor;\n       setRequestedInterBrokerPartitionMovementConcurrency(requestedInterBrokerPartitionMovementConcurrency);\n+      setRequestedLeadershipMovementConcurrency(requestedLeadershipMovementConcurrency);\n     }\n \n-    private boolean canRefreshConcurrency() {\n-      return _concurrencyAdjusterEnabled && _executorState.state() == ExecutorState.State.INTER_BROKER_REPLICA_MOVEMENT_TASK_IN_PROGRESS\n-             && !_skipAutoRefreshingConcurrency && _loadMonitor != null;\n+    private boolean canRefreshConcurrency(ConcurrencyType concurrencyType) {\n+      if (!_concurrencyAdjusterEnabled.get(concurrencyType) || _loadMonitor == null) {\n+        return false;\n+      }\n+      switch (concurrencyType) {\n+        case LEADERSHIP:\n+          return _executorState.state() == LEADER_MOVEMENT_TASK_IN_PROGRESS;\n+        case INTER_BROKER_REPLICA:\n+          return _executorState.state() == ExecutorState.State.INTER_BROKER_REPLICA_MOVEMENT_TASK_IN_PROGRESS\n+                 && !_skipInterBrokerReplicaConcurrencyAdjustment;\n+        default:\n+          throw new IllegalArgumentException(\"Unsupported concurrency type \" + concurrencyType + \" is provided.\");\n+      }\n     }\n \n-    private synchronized void refreshConcurrency() {\n-      if (canRefreshConcurrency()) {\n-        Integer recommendedConcurrency = ExecutionUtils.recommendedConcurrency(_loadMonitor.currentBrokerMetricValues(),\n-                                                                               _executionTaskManager.interBrokerPartitionMovementConcurrency(),\n-                                                                               _maxPartitionMovementsPerBroker);\n+    private synchronized void refreshInterBrokerReplicaConcurrency() {\n+      if (canRefreshConcurrency(ConcurrencyType.INTER_BROKER_REPLICA)) {\n+        Integer recommendedConcurrency", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b430b16c7f04cbd51631e2fc4daa524ccfa28c"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ4ODk4NQ==", "bodyText": "2 nits:\n\nConsider using import com.linkedin.kafka.cruisecontrol.config.constants.ExecutorConfig.*; \nConsider creating a private static final String GET_INT_METHOD = \"getInt\"", "url": "https://github.com/linkedin/cruise-control/pull/1368#discussion_r516488985", "createdAt": "2020-11-03T08:22:08Z", "author": {"login": "Lincong"}, "path": "cruise-control/src/test/java/com/linkedin/kafka/cruisecontrol/config/ConcurrencyConfigTest.java", "diffHunk": "@@ -0,0 +1,290 @@\n+/*\n+ * Copyright 2020 LinkedIn Corp. Licensed under the BSD 2-Clause License (the \"License\"). See License in the project root for license information.\n+ */\n+\n+package com.linkedin.kafka.cruisecontrol.config;\n+\n+import com.linkedin.kafka.cruisecontrol.config.constants.ExecutorConfig;\n+import org.apache.kafka.common.config.ConfigException;\n+import org.easymock.EasyMock;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertThrows;\n+\n+\n+public class ConcurrencyConfigTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92b430b16c7f04cbd51631e2fc4daa524ccfa28c"}, "originalPosition": 15}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffa1668a9f9a2b19b057c641e998d03eeabd0164", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/ffa1668a9f9a2b19b057c641e998d03eeabd0164", "committedDate": "2020-11-03T19:14:53Z", "message": "Address the feedback."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyODQyNzI2", "url": "https://github.com/linkedin/cruise-control/pull/1368#pullrequestreview-522842726", "createdAt": "2020-11-03T20:15:25Z", "commit": {"oid": "92b430b16c7f04cbd51631e2fc4daa524ccfa28c"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMDoxNToyNVrOHs-8Rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QyMDoxNToyNVrOHs-8Rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkzMDYzMA==", "bodyText": "I see. Nvm. I did not notice that the result of _executionTaskManager.interBrokerPartitionMovementConcurrency() is one of the input parameters passed to the recommendedConcurrency  method. Sorry for the confusion.", "url": "https://github.com/linkedin/cruise-control/pull/1368#discussion_r516930630", "createdAt": "2020-11-03T20:15:25Z", "author": {"login": "Lincong"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -298,54 +305,80 @@ public void run() {\n   }\n \n   /**\n-   * A runnable class to auto-adjust the allowed inter-broker partition reassignment concurrency for ongoing executions\n+   * A runnable class to auto-adjust the allowed reassignment concurrency for ongoing executions\n    * using selected broker metrics and based on additive-increase/multiplicative-decrease (AIMD) feedback control algorithm.\n    * Skips concurrency adjustment for demote operations.\n    */\n   private class ConcurrencyAdjuster implements Runnable {\n-    private final int _maxPartitionMovementsPerBroker;\n     private LoadMonitor _loadMonitor;\n \n     public ConcurrencyAdjuster() {\n-      _maxPartitionMovementsPerBroker = _config.getInt(ExecutorConfig.CONCURRENCY_ADJUSTER_MAX_PARTITION_MOVEMENTS_PER_BROKER_CONFIG);\n       _loadMonitor = null;\n     }\n \n     /**\n-     * Initialize the inter-broker partition reassignment concurrency adjustment with the load monitor and the initially\n-     * requested inter-broker partition reassignment concurrency.\n+     * Initialize the reassignment concurrency adjustment with the load monitor and the initially requested reassignment concurrency.\n      *\n      * @param loadMonitor Load monitor.\n      * @param requestedInterBrokerPartitionMovementConcurrency The maximum number of concurrent inter-broker partition movements\n      *                                                         per broker(if null, use num.concurrent.partition.movements.per.broker).\n+     * @param requestedLeadershipMovementConcurrency The maximum number of concurrent leader movements\n+     *                                               (if null, use num.concurrent.leader.movements).\n      */\n-    public synchronized void initAdjustment(LoadMonitor loadMonitor, Integer requestedInterBrokerPartitionMovementConcurrency) {\n+    public synchronized void initAdjustment(LoadMonitor loadMonitor,\n+                                            Integer requestedInterBrokerPartitionMovementConcurrency,\n+                                            Integer requestedLeadershipMovementConcurrency) {\n       _loadMonitor = loadMonitor;\n       setRequestedInterBrokerPartitionMovementConcurrency(requestedInterBrokerPartitionMovementConcurrency);\n+      setRequestedLeadershipMovementConcurrency(requestedLeadershipMovementConcurrency);\n     }\n \n-    private boolean canRefreshConcurrency() {\n-      return _concurrencyAdjusterEnabled && _executorState.state() == ExecutorState.State.INTER_BROKER_REPLICA_MOVEMENT_TASK_IN_PROGRESS\n-             && !_skipAutoRefreshingConcurrency && _loadMonitor != null;\n+    private boolean canRefreshConcurrency(ConcurrencyType concurrencyType) {\n+      if (!_concurrencyAdjusterEnabled.get(concurrencyType) || _loadMonitor == null) {\n+        return false;\n+      }\n+      switch (concurrencyType) {\n+        case LEADERSHIP:\n+          return _executorState.state() == LEADER_MOVEMENT_TASK_IN_PROGRESS;\n+        case INTER_BROKER_REPLICA:\n+          return _executorState.state() == ExecutorState.State.INTER_BROKER_REPLICA_MOVEMENT_TASK_IN_PROGRESS\n+                 && !_skipInterBrokerReplicaConcurrencyAdjustment;\n+        default:\n+          throw new IllegalArgumentException(\"Unsupported concurrency type \" + concurrencyType + \" is provided.\");\n+      }\n     }\n \n-    private synchronized void refreshConcurrency() {\n-      if (canRefreshConcurrency()) {\n-        Integer recommendedConcurrency = ExecutionUtils.recommendedConcurrency(_loadMonitor.currentBrokerMetricValues(),\n-                                                                               _executionTaskManager.interBrokerPartitionMovementConcurrency(),\n-                                                                               _maxPartitionMovementsPerBroker);\n+    private synchronized void refreshInterBrokerReplicaConcurrency() {\n+      if (canRefreshConcurrency(ConcurrencyType.INTER_BROKER_REPLICA)) {\n+        Integer recommendedConcurrency", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjQ4NjE0Nw=="}, "originalCommit": {"oid": "92b430b16c7f04cbd51631e2fc4daa524ccfa28c"}, "originalPosition": 106}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 94, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}