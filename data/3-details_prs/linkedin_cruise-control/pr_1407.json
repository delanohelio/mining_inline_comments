{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxNDE4MDk1", "number": 1407, "title": "Provide idempotency support to handle duplicate maintenance events", "bodyText": "This PR resolves #1347.", "createdAt": "2020-12-03T02:50:59Z", "url": "https://github.com/linkedin/cruise-control/pull/1407", "merged": true, "mergeCommit": {"oid": "81f99cc879a0710e5d4d9859e85ec909ab1de69d"}, "closed": true, "closedAt": "2020-12-04T03:42:08Z", "author": {"login": "efeg"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdinwRYgFqTU0NDI1NDAxMg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdivGMlAFqTU0NDYyOTkwMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0MjU0MDEy", "url": "https://github.com/linkedin/cruise-control/pull/1407#pullrequestreview-544254012", "createdAt": "2020-12-03T18:25:22Z", "commit": {"oid": "92ab5730fed792b750e7ceb91018dabfabe69c5d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODoyNToyMlrOH-q_QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODo0MTo1OFrOH-rnwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ3ODA4MA==", "bodyText": "Just curious: in what situation(s) CC needs to use a non-daemon thread?", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535478080", "createdAt": "2020-12-03T18:25:22Z", "author": {"login": "Lincong"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/common/KafkaCruiseControlThreadFactory.java", "diffHunk": "@@ -17,9 +17,11 @@\n   private final AtomicInteger _id = new AtomicInteger(0);\n   private final Logger _logger;\n \n-  public KafkaCruiseControlThreadFactory(String name,\n-                                         boolean daemon,\n-                                         Logger logger) {\n+  public KafkaCruiseControlThreadFactory(String name) {\n+    this(name, true, null);\n+  }\n+\n+  public KafkaCruiseControlThreadFactory(String name, boolean daemon, Logger logger) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92ab5730fed792b750e7ceb91018dabfabe69c5d"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ3OTg1MA==", "bodyText": "Is it reasonable to think about creating another static class MaintenanceEventConfig for all configs related to maintenance event?", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535479850", "createdAt": "2020-12-03T18:27:58Z", "author": {"login": "Lincong"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java", "diffHunk": "@@ -227,6 +228,31 @@ private AnomalyDetectorConfig() {\n   public static final String DEFAULT_MAINTENANCE_EVENT_CLASS = MaintenanceEvent.class.getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92ab5730fed792b750e7ceb91018dabfabe69c5d"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4MDg4Nw==", "bodyText": "Even though 25 as default is probably good enough. But why not make the mac cache size larger (e.g. 1000)? I assume the cache entry is not too big in size.", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535480887", "createdAt": "2020-12-03T18:29:40Z", "author": {"login": "Lincong"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/config/constants/AnomalyDetectorConfig.java", "diffHunk": "@@ -227,6 +228,31 @@ private AnomalyDetectorConfig() {\n   public static final String DEFAULT_MAINTENANCE_EVENT_CLASS = MaintenanceEvent.class.getName();\n   public static final String MAINTENANCE_EVENT_CLASS_DOC = \"The name of class that extends maintenance event.\";\n \n+  /**\n+   * <code>maintenance.event.enable.idempotence</code>\n+   */\n+  public static final String MAINTENANCE_EVENT_ENABLE_IDEMPOTENCE_CONFIG = \"maintenance.event.enable.idempotence\";\n+  public static final boolean DEFAULT_MAINTENANCE_EVENT_ENABLE_IDEMPOTENCE = true;\n+  public static final String MAINTENANCE_EVENT_ENABLE_IDEMPOTENCE_DOC = \"The flag to indicate whether maintenance event detector will drop \"\n+      + \"the duplicate maintenance events detected within the configured retention period.\";\n+\n+  /**\n+   * <code>maintenance.event.idempotence.retention.ms</code>\n+   */\n+  public static final String MAINTENANCE_EVENT_IDEMPOTENCE_RETENTION_MS_CONFIG = \"maintenance.event.idempotence.retention.ms\";\n+  public static final long DEFAULT_MAINTENANCE_EVENT_IDEMPOTENCE_RETENTION_MS = TimeUnit.MINUTES.toMillis(3);\n+  public static final String MAINTENANCE_EVENT_IDEMPOTENCE_RETENTION_MS_DOC = \"The maximum time in ms to store events retrieved from the\"\n+      + \" MaintenanceEventReader. Relevant only if idempotency is enabled (see \" + MAINTENANCE_EVENT_ENABLE_IDEMPOTENCE_CONFIG + \").\";\n+\n+  /**\n+   * <code>maintenance.event.max.idempotence.cache.size</code>\n+   */\n+  public static final String MAINTENANCE_EVENT_MAX_IDEMPOTENCE_CACHE_SIZE_CONFIG = \"maintenance.event.max.idempotence.cache.size\";\n+  public static final int DEFAULT_MAINTENANCE_EVENT_MAX_IDEMPOTENCE_CACHE_SIZE = 25;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92ab5730fed792b750e7ceb91018dabfabe69c5d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4MzQyNA==", "bodyText": "Nit: I usually prefer to put a shorter branch first. For example, in this case:\nif (! _idempotenceEnabled) {\n    _maintenanceEventByTime = null;\n    _idempotenceCacheCleaner = null;\n} else{\n    ...\n}", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535483424", "createdAt": "2020-12-03T18:33:49Z", "author": {"login": "Lincong"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/MaintenanceEventDetector.java", "diffHunk": "@@ -6,42 +6,112 @@\n \n import com.linkedin.cruisecontrol.detector.Anomaly;\n import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.common.KafkaCruiseControlThreadFactory;\n import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig;\n import java.time.Duration;\n import java.util.Collections;\n+import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.MAINTENANCE_EVENT_READER_CLASS_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getAnomalyDetectionStatus;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n \n \n public class MaintenanceEventDetector extends AbstractAnomalyDetector implements Runnable {\n   private static final Logger LOG = LoggerFactory.getLogger(MaintenanceEventDetector.class);\n   public static final long DETECTION_NOT_READY_BACKOFF_MS = TimeUnit.SECONDS.toMillis(10);\n+  public static final long IDEMPOTENCE_CACHE_CLEANER_PERIOD_SECONDS = 5;\n+  public static final long IDEMPOTENCE_CACHE_CLEANER_INITIAL_DELAY_SECONDS = 0;\n   // TODO: Make this configurable.\n   public static final Duration READ_EVENTS_TIMEOUT = Duration.ofSeconds(5);\n   private volatile boolean _shutdown;\n   private final MaintenanceEventReader _maintenanceEventReader;\n+  private final boolean _idempotenceEnabled;\n+  private final Duration _idempotenceRetention;\n+  private final ScheduledExecutorService _idempotenceCacheCleaner;\n+  private final Map<Long, MaintenanceEvent> _maintenanceEventByTime;\n \n   public MaintenanceEventDetector(Queue<Anomaly> anomalies, KafkaCruiseControl kafkaCruiseControl) {\n     super(anomalies, kafkaCruiseControl);\n     KafkaCruiseControlConfig config = _kafkaCruiseControl.config();\n     _shutdown = false;\n     Map<String, Object> configWithCruiseControlObject = Collections.singletonMap(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG,\n                                                                                  kafkaCruiseControl);\n-    _maintenanceEventReader = config.getConfiguredInstance(MAINTENANCE_EVENT_READER_CLASS_CONFIG,\n+    _maintenanceEventReader = config.getConfiguredInstance(AnomalyDetectorConfig.MAINTENANCE_EVENT_READER_CLASS_CONFIG,\n                                                            MaintenanceEventReader.class,\n                                                            configWithCruiseControlObject);\n+    _idempotenceEnabled = config.getBoolean(AnomalyDetectorConfig.MAINTENANCE_EVENT_ENABLE_IDEMPOTENCE_CONFIG);\n+    _idempotenceRetention = Duration.ofMillis(config.getLong(AnomalyDetectorConfig.MAINTENANCE_EVENT_IDEMPOTENCE_RETENTION_MS_CONFIG));\n+    if (_idempotenceEnabled) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92ab5730fed792b750e7ceb91018dabfabe69c5d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ4ODQ0OQ==", "bodyText": "Maybe we should log something after we remove some entries and include the number of entries we have removed in this method", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535488449", "createdAt": "2020-12-03T18:41:58Z", "author": {"login": "Lincong"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/MaintenanceEventDetector.java", "diffHunk": "@@ -6,42 +6,112 @@\n \n import com.linkedin.cruisecontrol.detector.Anomaly;\n import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.common.KafkaCruiseControlThreadFactory;\n import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig;\n import java.time.Duration;\n import java.util.Collections;\n+import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.MAINTENANCE_EVENT_READER_CLASS_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getAnomalyDetectionStatus;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n \n \n public class MaintenanceEventDetector extends AbstractAnomalyDetector implements Runnable {\n   private static final Logger LOG = LoggerFactory.getLogger(MaintenanceEventDetector.class);\n   public static final long DETECTION_NOT_READY_BACKOFF_MS = TimeUnit.SECONDS.toMillis(10);\n+  public static final long IDEMPOTENCE_CACHE_CLEANER_PERIOD_SECONDS = 5;\n+  public static final long IDEMPOTENCE_CACHE_CLEANER_INITIAL_DELAY_SECONDS = 0;\n   // TODO: Make this configurable.\n   public static final Duration READ_EVENTS_TIMEOUT = Duration.ofSeconds(5);\n   private volatile boolean _shutdown;\n   private final MaintenanceEventReader _maintenanceEventReader;\n+  private final boolean _idempotenceEnabled;\n+  private final Duration _idempotenceRetention;\n+  private final ScheduledExecutorService _idempotenceCacheCleaner;\n+  private final Map<Long, MaintenanceEvent> _maintenanceEventByTime;\n \n   public MaintenanceEventDetector(Queue<Anomaly> anomalies, KafkaCruiseControl kafkaCruiseControl) {\n     super(anomalies, kafkaCruiseControl);\n     KafkaCruiseControlConfig config = _kafkaCruiseControl.config();\n     _shutdown = false;\n     Map<String, Object> configWithCruiseControlObject = Collections.singletonMap(KAFKA_CRUISE_CONTROL_OBJECT_CONFIG,\n                                                                                  kafkaCruiseControl);\n-    _maintenanceEventReader = config.getConfiguredInstance(MAINTENANCE_EVENT_READER_CLASS_CONFIG,\n+    _maintenanceEventReader = config.getConfiguredInstance(AnomalyDetectorConfig.MAINTENANCE_EVENT_READER_CLASS_CONFIG,\n                                                            MaintenanceEventReader.class,\n                                                            configWithCruiseControlObject);\n+    _idempotenceEnabled = config.getBoolean(AnomalyDetectorConfig.MAINTENANCE_EVENT_ENABLE_IDEMPOTENCE_CONFIG);\n+    _idempotenceRetention = Duration.ofMillis(config.getLong(AnomalyDetectorConfig.MAINTENANCE_EVENT_IDEMPOTENCE_RETENTION_MS_CONFIG));\n+    if (_idempotenceEnabled) {\n+      int maxIdempotenceCacheSize = config.getInt(AnomalyDetectorConfig.MAINTENANCE_EVENT_MAX_IDEMPOTENCE_CACHE_SIZE_CONFIG);\n+      _maintenanceEventByTime = new LinkedHashMap<Long, MaintenanceEvent>() {\n+        @Override\n+        protected boolean removeEldestEntry(Map.Entry<Long, MaintenanceEvent> eldest) {\n+          return this.size() > maxIdempotenceCacheSize;\n+        }\n+      };\n+      _idempotenceCacheCleaner = Executors.newSingleThreadScheduledExecutor(new KafkaCruiseControlThreadFactory(\"IdempotenceCacheCleaner\"));\n+      _idempotenceCacheCleaner.scheduleAtFixedRate(new IdempotenceCacheCleaner(),\n+                                                   IDEMPOTENCE_CACHE_CLEANER_INITIAL_DELAY_SECONDS,\n+                                                   IDEMPOTENCE_CACHE_CLEANER_PERIOD_SECONDS,\n+                                                   TimeUnit.SECONDS);\n+    } else {\n+      _maintenanceEventByTime = null;\n+      _idempotenceCacheCleaner = null;\n+    }\n+  }\n+\n+  private synchronized void removeOldEventsFromIdempotenceCache() {\n+    LOG.debug(\"Remove old events from idempotence cache.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92ab5730fed792b750e7ceb91018dabfabe69c5d"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0Mjc4NzY0", "url": "https://github.com/linkedin/cruise-control/pull/1407#pullrequestreview-544278764", "createdAt": "2020-12-03T18:56:14Z", "commit": {"oid": "92ab5730fed792b750e7ceb91018dabfabe69c5d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODo1NjoxNVrOH-sKgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODo1NjoxNVrOH-sKgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ5NzM0NA==", "bodyText": "Instead of storing reference of MaintenanceEvent as values in the map, can we just add hashCode() and equals() methods to the MaintenanceEvent class and store hash code of MaintenanceEvent object in this map? I think we can save memory and increase the max cache size by a lot", "url": "https://github.com/linkedin/cruise-control/pull/1407#discussion_r535497344", "createdAt": "2020-12-03T18:56:15Z", "author": {"login": "Lincong"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/MaintenanceEventDetector.java", "diffHunk": "@@ -6,42 +6,112 @@\n \n import com.linkedin.cruisecontrol.detector.Anomaly;\n import com.linkedin.kafka.cruisecontrol.KafkaCruiseControl;\n+import com.linkedin.kafka.cruisecontrol.common.KafkaCruiseControlThreadFactory;\n import com.linkedin.kafka.cruisecontrol.config.KafkaCruiseControlConfig;\n+import com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig;\n import java.time.Duration;\n import java.util.Collections;\n+import java.util.LinkedHashMap;\n import java.util.Map;\n import java.util.Queue;\n import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n import java.util.concurrent.TimeUnit;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import static com.linkedin.kafka.cruisecontrol.config.constants.AnomalyDetectorConfig.MAINTENANCE_EVENT_READER_CLASS_CONFIG;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.getAnomalyDetectionStatus;\n import static com.linkedin.kafka.cruisecontrol.detector.AnomalyDetectorUtils.KAFKA_CRUISE_CONTROL_OBJECT_CONFIG;\n \n \n public class MaintenanceEventDetector extends AbstractAnomalyDetector implements Runnable {\n   private static final Logger LOG = LoggerFactory.getLogger(MaintenanceEventDetector.class);\n   public static final long DETECTION_NOT_READY_BACKOFF_MS = TimeUnit.SECONDS.toMillis(10);\n+  public static final long IDEMPOTENCE_CACHE_CLEANER_PERIOD_SECONDS = 5;\n+  public static final long IDEMPOTENCE_CACHE_CLEANER_INITIAL_DELAY_SECONDS = 0;\n   // TODO: Make this configurable.\n   public static final Duration READ_EVENTS_TIMEOUT = Duration.ofSeconds(5);\n   private volatile boolean _shutdown;\n   private final MaintenanceEventReader _maintenanceEventReader;\n+  private final boolean _idempotenceEnabled;\n+  private final Duration _idempotenceRetention;\n+  private final ScheduledExecutorService _idempotenceCacheCleaner;\n+  private final Map<Long, MaintenanceEvent> _maintenanceEventByTime;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "92ab5730fed792b750e7ceb91018dabfabe69c5d"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00112ecf74d2f247adb11e2919a6a7d10725ca1c", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/00112ecf74d2f247adb11e2919a6a7d10725ca1c", "committedDate": "2020-12-03T22:18:15Z", "message": "Provide idempotency support to handle duplicate maintenance events"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ef70aeac1de5dfe78f8315221cb980686a46e6b", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/0ef70aeac1de5dfe78f8315221cb980686a46e6b", "committedDate": "2020-12-04T03:12:07Z", "message": "Address the feedback."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "92ab5730fed792b750e7ceb91018dabfabe69c5d", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/92ab5730fed792b750e7ceb91018dabfabe69c5d", "committedDate": "2020-12-03T02:49:26Z", "message": "Provide idempotency support to handle duplicate maintenance events"}, "afterCommit": {"oid": "0ef70aeac1de5dfe78f8315221cb980686a46e6b", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/0ef70aeac1de5dfe78f8315221cb980686a46e6b", "committedDate": "2020-12-04T03:12:07Z", "message": "Address the feedback."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NjI5OTAz", "url": "https://github.com/linkedin/cruise-control/pull/1407#pullrequestreview-544629903", "createdAt": "2020-12-04T03:22:58Z", "commit": {"oid": "0ef70aeac1de5dfe78f8315221cb980686a46e6b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 122, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}