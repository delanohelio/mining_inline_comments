{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0OTMyODAx", "number": 1308, "title": "Eliminate inefficiencies in execution process.", "bodyText": "This PR resolves #1307.\n-- The correctness of execution has also been verified on a Kafka 2.4 cluster with and w/o stop_proposal_execution.", "createdAt": "2020-08-08T02:20:56Z", "url": "https://github.com/linkedin/cruise-control/pull/1308", "merged": true, "mergeCommit": {"oid": "2b0712cef7f3151745d2618b98be675f3b73876f"}, "closed": true, "closedAt": "2020-08-14T01:15:10Z", "author": {"login": "efeg"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc8u-KQAH2gAyNDY0OTMyODAxOmI5MWU3ZmM4ZjI0YjY3YjZjODJlMzljOWFlODc1YjQ4ZDRkMjAyZjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-qHnVgFqTQ2NzI0OTc5NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b91e7fc8f24b67b6c82e39c9ae875b48d4d202f2", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/b91e7fc8f24b67b6c82e39c9ae875b48d4d202f2", "committedDate": "2020-08-08T01:45:04Z", "message": "Eliminate inefficiencies in execution process."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NzE0NjU0", "url": "https://github.com/linkedin/cruise-control/pull/1308#pullrequestreview-464714654", "createdAt": "2020-08-11T02:54:16Z", "commit": {"oid": "b91e7fc8f24b67b6c82e39c9ae875b48d4d202f2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjo1NDoxNlrOG-mlWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQwMjo1NDo1NFrOG-ml-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5NzA0OQ==", "bodyText": "Is this comment correct? I thought CC no longer deletes the znode and moves controller in order to stop the execution.", "url": "https://github.com/linkedin/cruise-control/pull/1308#discussion_r468297049", "createdAt": "2020-08-11T02:54:16Z", "author": {"login": "hzxa21"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -1416,6 +1416,120 @@ private int moveLeadershipInBatch() throws InterruptedException, ExecutionExcept\n       return finishedTasks;\n     }\n \n+    private void handleProgressWithTopicDeletion(ExecutionTask task, List<ExecutionTask> finishedTasks, Set<Long> deletedTaskIds) {\n+      // Handle topic deletion during the execution.\n+      LOG.debug(\"Task {} is marked as finished because the topic has been deleted.\", task);\n+      finishedTasks.add(task);\n+      deletedTaskIds.add(task.executionId());\n+      _executionTaskManager.markTaskAborting(task);\n+      _executionTaskManager.markTaskDone(task);\n+    }\n+\n+    private void handleProgressWithCompletion(ExecutionTask task, List<ExecutionTask> finishedTasks) {\n+      // Check to see if the task is done.\n+      finishedTasks.add(task);\n+      _executionTaskManager.markTaskDone(task);\n+    }\n+\n+    /**\n+     * Periodically checks the metadata to see if leadership reassignment has finished or not.\n+     */\n+    private void waitForLeadershipTasksToFinish() {\n+      List<ExecutionTask> finishedTasks = new ArrayList<>();\n+      Set<Long> stoppedTaskIds = new HashSet<>();\n+      Set<Long> deletedTaskIds = new HashSet<>();\n+      Set<Long> deadTaskIds = new HashSet<>();\n+      do {\n+        // If there is no finished tasks, we need to check if anything is blocked.\n+        maybeReexecuteLeadershipTasks();\n+        Cluster cluster = getClusterForExecutionProgressCheck();\n+\n+        List<ExecutionTask> slowTasksToReport = new ArrayList<>();\n+        boolean shouldReportSlowTasks = _time.milliseconds() - _lastSlowTaskReportingTimeMs > SLOW_TASK_ALERTING_BACKOFF_TIME_MS;\n+        for (ExecutionTask task : inExecutionTasks()) {\n+          TopicPartition tp = task.proposal().topicPartition();\n+          if (_stopSignal.get() == FORCE_STOP_EXECUTION) {\n+            // If the execution is force-stopped, the executor will mark all in progress tasks as dead, cleanup the\n+            // relevant reassignment zNodes, and then bounce the controller (see ExecutionUtils#deleteZNodesToStopExecution).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b91e7fc8f24b67b6c82e39c9ae875b48d4d202f2"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODI5NzIwOQ==", "bodyText": "Is this comment correct? I thought CC no longer deletes the znode and moves controller in order to stop the execution.", "url": "https://github.com/linkedin/cruise-control/pull/1308#discussion_r468297209", "createdAt": "2020-08-11T02:54:54Z", "author": {"login": "hzxa21"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -1416,6 +1416,120 @@ private int moveLeadershipInBatch() throws InterruptedException, ExecutionExcept\n       return finishedTasks;\n     }\n \n+    private void handleProgressWithTopicDeletion(ExecutionTask task, List<ExecutionTask> finishedTasks, Set<Long> deletedTaskIds) {\n+      // Handle topic deletion during the execution.\n+      LOG.debug(\"Task {} is marked as finished because the topic has been deleted.\", task);\n+      finishedTasks.add(task);\n+      deletedTaskIds.add(task.executionId());\n+      _executionTaskManager.markTaskAborting(task);\n+      _executionTaskManager.markTaskDone(task);\n+    }\n+\n+    private void handleProgressWithCompletion(ExecutionTask task, List<ExecutionTask> finishedTasks) {\n+      // Check to see if the task is done.\n+      finishedTasks.add(task);\n+      _executionTaskManager.markTaskDone(task);\n+    }\n+\n+    /**\n+     * Periodically checks the metadata to see if leadership reassignment has finished or not.\n+     */\n+    private void waitForLeadershipTasksToFinish() {\n+      List<ExecutionTask> finishedTasks = new ArrayList<>();\n+      Set<Long> stoppedTaskIds = new HashSet<>();\n+      Set<Long> deletedTaskIds = new HashSet<>();\n+      Set<Long> deadTaskIds = new HashSet<>();\n+      do {\n+        // If there is no finished tasks, we need to check if anything is blocked.\n+        maybeReexecuteLeadershipTasks();\n+        Cluster cluster = getClusterForExecutionProgressCheck();\n+\n+        List<ExecutionTask> slowTasksToReport = new ArrayList<>();\n+        boolean shouldReportSlowTasks = _time.milliseconds() - _lastSlowTaskReportingTimeMs > SLOW_TASK_ALERTING_BACKOFF_TIME_MS;\n+        for (ExecutionTask task : inExecutionTasks()) {\n+          TopicPartition tp = task.proposal().topicPartition();\n+          if (_stopSignal.get() == FORCE_STOP_EXECUTION) {\n+            // If the execution is force-stopped, the executor will mark all in progress tasks as dead, cleanup the\n+            // relevant reassignment zNodes, and then bounce the controller (see ExecutionUtils#deleteZNodesToStopExecution).\n+            LOG.debug(\"Task {} is marked as dead to force-stop the execution with a controller bounce.\", task);\n+            finishedTasks.add(task);\n+            stoppedTaskIds.add(task.executionId());\n+            _executionTaskManager.markTaskDead(task);\n+          } else if (cluster.partition(tp) == null) {\n+            handleProgressWithTopicDeletion(task, finishedTasks, deletedTaskIds);\n+          } else if (ExecutionUtils.isLeadershipMovementDone(cluster, task)) {\n+            handleProgressWithCompletion(task, finishedTasks);\n+          } else {\n+            if (shouldReportSlowTasks) {\n+              task.maybeReportExecutionTooSlow(_time.milliseconds(), slowTasksToReport);\n+            }\n+            if (maybeMarkTaskAsDead(cluster, null, task, null)) {\n+              deadTaskIds.add(task.executionId());\n+              finishedTasks.add(task);\n+            }\n+          }\n+        }\n+        sendSlowExecutionAlert(slowTasksToReport);\n+        updateOngoingExecutionState();\n+      } while (!inExecutionTasks().isEmpty() && finishedTasks.isEmpty());\n+\n+      LOG.info(\"Finished tasks: {}.{}{}{}\", finishedTasks,\n+               stoppedTaskIds.isEmpty() ? \"\" : String.format(\". [Force-Stopped: %s]\", stoppedTaskIds),\n+               deletedTaskIds.isEmpty() ? \"\" : String.format(\". [Deleted: %s]\", deletedTaskIds),\n+               deadTaskIds.isEmpty() ? \"\" : String.format(\". [Dead: %s]\", deadTaskIds));\n+    }\n+\n+    /**\n+     * Periodically checks the metadata to see if intra-broker replica reassignment has finished or not.\n+     */\n+    private void waitForIntraBrokerReplicaTasksToFinish() {\n+      List<ExecutionTask> finishedTasks = new ArrayList<>();\n+      Set<Long> stoppedTaskIds = new HashSet<>();\n+      Set<Long> deletedTaskIds = new HashSet<>();\n+      Set<Long> deadTaskIds = new HashSet<>();\n+      do {\n+        // If there is no finished tasks, we need to check if anything is blocked.\n+        maybeReexecuteIntraBrokerReplicaTasks();\n+        Cluster cluster = getClusterForExecutionProgressCheck();\n+        Map<ExecutionTask, ReplicaLogDirInfo> logDirInfoByTask = getLogdirInfoForExecutionTask(\n+            _executionTaskManager.inExecutionTasks(Collections.singleton(INTRA_BROKER_REPLICA_ACTION)),\n+            _adminClient, _config);\n+\n+        List<ExecutionTask> slowTasksToReport = new ArrayList<>();\n+        boolean shouldReportSlowTasks = _time.milliseconds() - _lastSlowTaskReportingTimeMs > SLOW_TASK_ALERTING_BACKOFF_TIME_MS;\n+        for (ExecutionTask task : inExecutionTasks()) {\n+          TopicPartition tp = task.proposal().topicPartition();\n+          if (_stopSignal.get() == FORCE_STOP_EXECUTION) {\n+            // If the execution is force-stopped, the executor will mark all in progress tasks as dead, cleanup the\n+            // relevant reassignment zNodes, and then bounce the controller (see ExecutionUtils#deleteZNodesToStopExecution).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b91e7fc8f24b67b6c82e39c9ae875b48d4d202f2"}, "originalPosition": 322}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "706c29fb88b3f16f64ba126d3068f6f1064ee17d", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/706c29fb88b3f16f64ba126d3068f6f1064ee17d", "committedDate": "2020-08-11T18:53:38Z", "message": "Address the feedback."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MjQ5Nzk0", "url": "https://github.com/linkedin/cruise-control/pull/1308#pullrequestreview-467249794", "createdAt": "2020-08-14T01:13:43Z", "commit": {"oid": "706c29fb88b3f16f64ba126d3068f6f1064ee17d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 57, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}