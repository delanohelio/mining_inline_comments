{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgzMzEwNTQ5", "number": 1324, "title": "Add support for goal-based operations via maintenance events.", "bodyText": "This PR adds support for goal-based operations via maintenance events required for #1248.\nThe next PR will add a topic-based implementation of MaintenanceEventReader to replace NoopMaintenanceEventReader.", "createdAt": "2020-09-10T03:02:54Z", "url": "https://github.com/linkedin/cruise-control/pull/1324", "merged": true, "mergeCommit": {"oid": "4659982c60b26f099824323666a912b5be5c5262"}, "closed": true, "closedAt": "2020-09-11T02:17:16Z", "author": {"login": "efeg"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdHXy5hgH2gAyNDgzMzEwNTQ5OjExNWUxYzVhNGE5ZGFhODBiNWY5NzI5MzQ3N2Q1OWJlZDhkYjhhMGI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHo6ngAFqTQ4NjM2NTEwMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "115e1c5a4a9daa80b5f97293477d59bed8db8a0b", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/115e1c5a4a9daa80b5f97293477d59bed8db8a0b", "committedDate": "2020-09-10T02:58:07Z", "message": "Add support for goal-based operations via maintenance events."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2Mjg2NDIz", "url": "https://github.com/linkedin/cruise-control/pull/1324#pullrequestreview-486286423", "createdAt": "2020-09-10T20:29:13Z", "commit": {"oid": "115e1c5a4a9daa80b5f97293477d59bed8db8a0b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDoyOToxM1rOHQEm2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDoyOToxM1rOHQEm2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNDc0Nw==", "bodyText": "I am a little bit confused about using a config to determine the event type. Is the config per-set when cruise control is deployed or is it set in runtime? From #1248, I thought the point of having the maintenance event is to read the event from some store (i.e. a topic) and trigger actions based on the event type so I guess the next PR for the event reader will introduce the implementation to read form a topic and set this config to trigger the goal-based operation, is it correct?", "url": "https://github.com/linkedin/cruise-control/pull/1324#discussion_r486614747", "createdAt": "2020-09-10T20:29:13Z", "author": {"login": "hzxa21"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/detector/MaintenanceEvent.java", "diffHunk": "@@ -24,20 +68,128 @@ public AnomalyType anomalyType() {\n   }\n \n   @Override\n-  public boolean fix() {\n-    // TODO: Start the relevant fix for the maintenance event.\n-    return false;\n+  public boolean fix() throws KafkaCruiseControlException {\n+    // Start the relevant fix for the maintenance event.\n+    _optimizationResult = new OptimizationResult(_goalBasedOperationRunnable.computeResult(), null);\n+    boolean hasProposalsToFix = hasProposalsToFix();\n+    // Ensure that only the relevant response is cached to avoid memory pressure.\n+    _optimizationResult.discardIrrelevantAndCacheJsonAndPlaintext();\n+    return hasProposalsToFix;\n   }\n \n   @Override\n   public String toString() {\n-    // TODO: Add details on maintenance event.\n-    return super.toString();\n+    // Add details on maintenance event.\n+    StringBuilder sb = new StringBuilder();\n+    sb.append(String.format(\"{Handling %s\", _maintenanceEventType));\n+    if (_topicsWithRFUpdate != null) {\n+      // Add summary for TOPIC_REPLICATION_FACTOR\n+      sb.append(String.format(\" by desired RF: [%s]\", _topicsWithRFUpdate));\n+    } else if (_brokers != null) {\n+      // Add summary for ADD_BROKER / REMOVE_BROKER / DEMOTE_BROKER\n+      sb.append(String.format(\" for brokers: [%s]\", _brokers));\n+    }\n+    sb.append(\"}\");\n+    return sb.toString();\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected void initBrokers(Map<String, ?> configs) {\n+    _brokers = (Set<Integer>) configs.get(BROKERS_OBJECT_CONFIG);\n+    if (_brokers == null || _brokers.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Missing brokers for maintenance event of type %s.\", _maintenanceEventType));\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected void initTopicsWithRFUpdate(Map<String, ?> configs) {\n+    _topicsWithRFUpdate = (Map<Short, Set<String>>) configs.get(TOPICS_WITH_RF_UPDATE_CONFIG);\n+    if (_topicsWithRFUpdate == null || _topicsWithRFUpdate.isEmpty()) {\n+      throw new IllegalArgumentException(String.format(\"Missing %s to identify topics for replication factor update.\",\n+                                                       TOPICS_WITH_RF_UPDATE_CONFIG));\n+    }\n+  }\n+\n+  protected Map<Short, Pattern> topicPatternByReplicationFactor(Map<String, ?> configs) {\n+    initTopicsWithRFUpdate(configs);\n+    Map<Short, Pattern> topicPatternByReplicationFactor = new HashMap<>(_topicsWithRFUpdate.size());\n+    _topicsWithRFUpdate.forEach((key, value) -> topicPatternByReplicationFactor.put(key, buildTopicRegex(value)));\n+    return topicPatternByReplicationFactor;\n   }\n \n   @Override\n   public void configure(Map<String, ?> configs) {\n     super.configure(configs);\n-    // TODO: Add configs for maintenance event.\n+    KafkaCruiseControl kafkaCruiseControl = extractKafkaCruiseControlObjectFromConfig(configs, MAINTENANCE_EVENT);\n+    KafkaCruiseControlConfig config = kafkaCruiseControl.config();\n+    boolean allowCapacityEstimation = config.getBoolean(ANOMALY_DETECTION_ALLOW_CAPACITY_ESTIMATION_CONFIG);\n+    boolean excludeRecentlyDemotedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_DEMOTED_BROKERS_CONFIG);\n+    boolean excludeRecentlyRemovedBrokers = config.getBoolean(SELF_HEALING_EXCLUDE_RECENTLY_REMOVED_BROKERS_CONFIG);\n+    _optimizationResult = null;\n+    _maintenanceEventType = (MaintenanceEventType) configs.get(MAINTENANCE_EVENT_TYPE_CONFIG);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "115e1c5a4a9daa80b5f97293477d59bed8db8a0b"}, "originalPosition": 126}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MzY1MTAx", "url": "https://github.com/linkedin/cruise-control/pull/1324#pullrequestreview-486365101", "createdAt": "2020-09-10T22:54:56Z", "commit": {"oid": "115e1c5a4a9daa80b5f97293477d59bed8db8a0b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 61, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}