{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU4Njc4MDQ2", "number": 1289, "title": "Automate replica reassignment concurrency adjustment based on broker metrics", "bodyText": "This PR resolves #1288.\n-- Selected default values for CONCURRENCY_ADJUSTER_LIMIT_* are based on observations from a production cluster with ongoing maintenance operation.", "createdAt": "2020-07-29T20:35:31Z", "url": "https://github.com/linkedin/cruise-control/pull/1289", "merged": true, "mergeCommit": {"oid": "8895cd983437fb7ba7a0086fd5178b2634ca692f"}, "closed": true, "closedAt": "2020-07-31T16:33:58Z", "author": {"login": "efeg"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc5ypRfAFqTQ1NzkyODk3Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc6Mk1ZgFqTQ1ODkwOTkzOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3OTI4OTcy", "url": "https://github.com/linkedin/cruise-control/pull/1289#pullrequestreview-457928972", "createdAt": "2020-07-29T22:01:00Z", "commit": {"oid": "b6c27d990e37bca8e99bcc19b0caa2f1d1d4b16c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMjowMTowMFrOG5LyVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMjoyMDowMVrOG5MRgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxNTEyNA==", "bodyText": "I don't see a lock or other synchronization mechanisms in these functions. But since they are accessing the some shared members, will there by any race condition?", "url": "https://github.com/linkedin/cruise-control/pull/1289#discussion_r462615124", "createdAt": "2020-07-29T22:01:00Z", "author": {"login": "hzxa21"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -288,6 +295,50 @@ public void run() {\n     }\n   }\n \n+  /**\n+   * A runnable class to auto-adjust the allowed inter-broker partition reassignment concurrency for ongoing executions\n+   * using selected broker metrics and based on additive-increase/multiplicative-decrease (AIMD) feedback control algorithm.\n+   * Skips concurrency adjustment for demote operations.\n+   */\n+  private class ConcurrencyAdjuster implements Runnable {\n+    private final int _maxPartitionMovementsPerBroker;\n+    private LoadMonitor _loadMonitor;\n+\n+    public ConcurrencyAdjuster() {\n+      _maxPartitionMovementsPerBroker = _config.getInt(ExecutorConfig.CONCURRENCY_ADJUSTER_MAX_PARTITION_MOVEMENTS_PER_BROKER_CONFIG);\n+      _loadMonitor = null;\n+    }\n+\n+    public void setLoadMonitor(LoadMonitor loadMonitor) {\n+      _loadMonitor = loadMonitor;\n+    }\n+\n+    private boolean canRefreshConcurrency() {\n+      return _concurrencyAdjusterEnabled && _executorState.state() == ExecutorState.State.INTER_BROKER_REPLICA_MOVEMENT_TASK_IN_PROGRESS\n+             && !_isLatestExecutionDemote && _loadMonitor != null;\n+    }\n+\n+    private void refreshConcurrency() {\n+      if (canRefreshConcurrency()) {\n+        Integer recommendedConcurrency = ExecutionUtils.recommendedConcurrency(_loadMonitor.currentBrokerMetricValues(),\n+                                                                               _executionTaskManager.interBrokerPartitionMovementConcurrency(),\n+                                                                               _maxPartitionMovementsPerBroker);\n+        if (recommendedConcurrency != null) {\n+          setRequestedInterBrokerPartitionMovementConcurrency(recommendedConcurrency);\n+        }\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6c27d990e37bca8e99bcc19b0caa2f1d1d4b16c"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYyMzEwNg==", "bodyText": "I noticed that the metrics used by the adjuster are all broker-side metrics related to consumption and production. It may not reflect problems related to delayed leadership changes. For example, there can be a long queue of LeaderAndIsrRequest or UpdateMetadataRequest causing some partitions to become leaderless while the fetch/produce local time metrics still look good because there is less I/O if partitions are leaderless.\nHave you considered also looking at the controller metrics as well? The ones I am thinking about are:\n\nController to per broker request queue time: https://github.com/linkedin/kafka/blob/2.3-li-1/core/src/main/scala/kafka/controller/ControllerChannelManager.scala#L184\nController to per broker request queue size: https://github.com/linkedin/kafka/blob/2.3-li-1/core/src/main/scala/kafka/controller/ControllerChannelManager.scala#L192\n\nThis patch is already a big step forward and I don't think we should address this comment in this patch but it is something worth thinking.", "url": "https://github.com/linkedin/cruise-control/pull/1289#discussion_r462623106", "createdAt": "2020-07-29T22:20:01Z", "author": {"login": "hzxa21"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/ExecutionUtils.java", "diffHunk": "@@ -30,10 +42,119 @@\n   public static final String GAUGE_EXECUTION_STOPPED_BY_USER = EXECUTION_STOPPED + \"-by-user\";\n   public static final String GAUGE_EXECUTION_STARTED_IN_KAFKA_ASSIGNER_MODE = EXECUTION_STARTED + \"-\" + KAFKA_ASSIGNER_MODE;\n   public static final String GAUGE_EXECUTION_STARTED_IN_NON_KAFKA_ASSIGNER_MODE = EXECUTION_STARTED + \"-non-\" + KAFKA_ASSIGNER_MODE;\n+  public static final long EXECUTION_HISTORY_SCANNER_PERIOD_SECONDS = 5;\n+  public static final long EXECUTION_HISTORY_SCANNER_INITIAL_DELAY_SECONDS = 0;\n+  public static final int ADDITIVE_INCREASE_PARAM = 1;\n+  public static final int MULTIPLICATIVE_DECREASE_PARAM = 2;\n+  static final Map<String, Double> CONCURRENCY_ADJUSTER_LIMIT_BY_METRIC_NAME = new HashMap<>(4);\n \n \n   private ExecutionUtils() { }\n \n+  /**\n+   * Initialize the concurrency adjuster limits.\n+   *\n+   * @param config The configurations for Cruise Control.\n+   */\n+  static void init(KafkaCruiseControlConfig config) {\n+    CONCURRENCY_ADJUSTER_LIMIT_BY_METRIC_NAME.put(BROKER_LOG_FLUSH_TIME_MS_999TH.name(),\n+                                                  config.getDouble(ExecutorConfig.CONCURRENCY_ADJUSTER_LIMIT_LOG_FLUSH_TIME_MS_CONFIG));\n+    CONCURRENCY_ADJUSTER_LIMIT_BY_METRIC_NAME.put(BROKER_FOLLOWER_FETCH_LOCAL_TIME_MS_999TH.name(),\n+                                                  config.getDouble(ExecutorConfig.CONCURRENCY_ADJUSTER_LIMIT_FOLLOWER_FETCH_LOCAL_TIME_MS_CONFIG));\n+    CONCURRENCY_ADJUSTER_LIMIT_BY_METRIC_NAME.put(BROKER_PRODUCE_LOCAL_TIME_MS_999TH.name(),\n+                                                  config.getDouble(ExecutorConfig.CONCURRENCY_ADJUSTER_LIMIT_PRODUCE_LOCAL_TIME_MS_CONFIG));\n+    CONCURRENCY_ADJUSTER_LIMIT_BY_METRIC_NAME.put(BROKER_CONSUMER_FETCH_LOCAL_TIME_MS_999TH.name(),\n+                                                  config.getDouble(ExecutorConfig.CONCURRENCY_ADJUSTER_LIMIT_CONSUMER_FETCH_LOCAL_TIME_MS_CONFIG));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6c27d990e37bca8e99bcc19b0caa2f1d1d4b16c"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MDUyNjc2", "url": "https://github.com/linkedin/cruise-control/pull/1289#pullrequestreview-458052676", "createdAt": "2020-07-30T03:51:16Z", "commit": {"oid": "eeafad8d1e8eca5cd47febe98e8cde151bb47bbc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMzo1MToxNlrOG5SFuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMzo1MToxNlrOG5SFuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxODM5NQ==", "bodyText": "setRequestedInterBrokerPartitionMovementConcurrency is a public method in the Executor class. Can it be called elsewhere? My concern is that we only synchronize the methods in ConcurrencyAdjuster but they are calling methods in the outer class. If the outer class method is invoked without going through ConcurrencyAdjuster, there still can be a race condition.", "url": "https://github.com/linkedin/cruise-control/pull/1289#discussion_r462718395", "createdAt": "2020-07-30T03:51:16Z", "author": {"login": "hzxa21"}, "path": "cruise-control/src/main/java/com/linkedin/kafka/cruisecontrol/executor/Executor.java", "diffHunk": "@@ -288,6 +295,59 @@ public void run() {\n     }\n   }\n \n+  /**\n+   * A runnable class to auto-adjust the allowed inter-broker partition reassignment concurrency for ongoing executions\n+   * using selected broker metrics and based on additive-increase/multiplicative-decrease (AIMD) feedback control algorithm.\n+   * Skips concurrency adjustment for demote operations.\n+   */\n+  private class ConcurrencyAdjuster implements Runnable {\n+    private final int _maxPartitionMovementsPerBroker;\n+    private LoadMonitor _loadMonitor;\n+\n+    public ConcurrencyAdjuster() {\n+      _maxPartitionMovementsPerBroker = _config.getInt(ExecutorConfig.CONCURRENCY_ADJUSTER_MAX_PARTITION_MOVEMENTS_PER_BROKER_CONFIG);\n+      _loadMonitor = null;\n+    }\n+\n+    /**\n+     * Initialize the inter-broker partition reassignment concurrency adjustment with the load monitor and the initially\n+     * requested inter-broker partition reassignment concurrency.\n+     *\n+     * @param loadMonitor Load monitor.\n+     * @param requestedInterBrokerPartitionMovementConcurrency The maximum number of concurrent inter-broker partition movements\n+     *                                                         per broker(if null, use num.concurrent.partition.movements.per.broker).\n+     */\n+    public synchronized void initAdjustment(LoadMonitor loadMonitor, Integer requestedInterBrokerPartitionMovementConcurrency) {\n+      _loadMonitor = loadMonitor;\n+      setRequestedInterBrokerPartitionMovementConcurrency(requestedInterBrokerPartitionMovementConcurrency);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eeafad8d1e8eca5cd47febe98e8cde151bb47bbc"}, "originalPosition": 119}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e466cfbcb615ddeabfde63fef2be1e76d6f3f7b0", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/e466cfbcb615ddeabfde63fef2be1e76d6f3f7b0", "committedDate": "2020-07-30T18:13:50Z", "message": "Automate replica reassignment concurrency adjustment based on broker metrics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9c75d86276099bb1a2c600c6552bc312f9c5f26", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/c9c75d86276099bb1a2c600c6552bc312f9c5f26", "committedDate": "2020-07-30T18:13:50Z", "message": "Address the feedback."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce9c98cff81771ae3aff986ccc4592ab4d1ec777", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/ce9c98cff81771ae3aff986ccc4592ab4d1ec777", "committedDate": "2020-07-30T18:55:21Z", "message": "Skip auto refresh concurrency for replication factor changes."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eeafad8d1e8eca5cd47febe98e8cde151bb47bbc", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/eeafad8d1e8eca5cd47febe98e8cde151bb47bbc", "committedDate": "2020-07-30T02:23:32Z", "message": "Address the feedback."}, "afterCommit": {"oid": "ce9c98cff81771ae3aff986ccc4592ab4d1ec777", "author": {"user": null}, "url": "https://github.com/linkedin/cruise-control/commit/ce9c98cff81771ae3aff986ccc4592ab4d1ec777", "committedDate": "2020-07-30T18:55:21Z", "message": "Skip auto refresh concurrency for replication factor changes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4OTA5OTM5", "url": "https://github.com/linkedin/cruise-control/pull/1289#pullrequestreview-458909939", "createdAt": "2020-07-31T04:32:47Z", "commit": {"oid": "ce9c98cff81771ae3aff986ccc4592ab4d1ec777"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 53, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}