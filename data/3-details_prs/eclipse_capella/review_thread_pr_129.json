{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2MjQwNjE3", "number": 129, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODo0Nzo0M1rODooQYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODo1NDo1MVrODooZ7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTI5MTg0OnYy", "diffSide": "RIGHT", "path": "core/plugins/org.polarsys.capella.core.projection.scenario/src/org/polarsys/capella/core/projection/scenario/topdown/TopDownExt.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODo0Nzo0NFrOF3SqIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODo0Nzo0NFrOF3SqIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyMTY5Ng==", "bodyText": "To propagate SequenceMessage with ExchangeItemAllocation as operation, its here. We lookup for Components implementing/using the interface in the target Architecture", "url": "https://github.com/eclipse/capella/pull/129#discussion_r393521696", "createdAt": "2020-03-17T08:47:44Z", "author": {"login": "pdulth"}, "path": "core/plugins/org.polarsys.capella.core.projection.scenario/src/org/polarsys/capella/core/projection/scenario/topdown/TopDownExt.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*******************************************************************************\n+ * Copyright (c) 2006, 2019 THALES GLOBAL SERVICES.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *  \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.projection.scenario.topdown;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.osgi.util.NLS;\n+import org.polarsys.capella.common.helpers.EObjectLabelProviderHelper;\n+import org.polarsys.capella.core.data.cs.BlockArchitecture;\n+import org.polarsys.capella.core.data.cs.Component;\n+import org.polarsys.capella.core.data.cs.CsPackage;\n+import org.polarsys.capella.core.data.cs.ExchangeItemAllocation;\n+import org.polarsys.capella.core.data.cs.Interface;\n+import org.polarsys.capella.core.data.cs.Part;\n+import org.polarsys.capella.core.data.epbs.ConfigurationItem;\n+import org.polarsys.capella.core.data.epbs.EPBSArchitecture;\n+import org.polarsys.capella.core.data.fa.AbstractFunction;\n+import org.polarsys.capella.core.data.fa.ComponentExchange;\n+import org.polarsys.capella.core.data.fa.FunctionalExchange;\n+import org.polarsys.capella.core.data.information.AbstractEventOperation;\n+import org.polarsys.capella.core.data.information.AbstractInstance;\n+import org.polarsys.capella.core.data.information.ExchangeItemInstance;\n+import org.polarsys.capella.core.data.information.InformationPackage;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.Event;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.oa.OperationalActivity;\n+import org.polarsys.capella.core.data.oa.Role;\n+import org.polarsys.capella.core.data.pa.PhysicalComponent;\n+import org.polarsys.capella.core.model.helpers.AbstractFunctionExt;\n+import org.polarsys.capella.core.model.helpers.BlockArchitectureExt;\n+import org.polarsys.capella.core.model.helpers.ComponentExchangeExt;\n+import org.polarsys.capella.core.model.helpers.ComponentExt;\n+import org.polarsys.capella.core.model.helpers.FunctionalExchangeExt;\n+import org.polarsys.capella.core.model.helpers.RefinementLinkExt;\n+import org.polarsys.capella.core.model.utils.ListExt;\n+import org.polarsys.capella.core.projection.common.TransitionHelper;\n+import org.polarsys.capella.core.projection.common.resolver.ResolverFinalizer;\n+import org.polarsys.capella.core.projection.scenario.Messages;\n+import org.polarsys.capella.core.projection.scenario.ScenarioTransfo;\n+import org.polarsys.capella.core.projection.scenario.helpers.ScenarioExt;\n+import org.polarsys.capella.core.projection.scenario.helpers.UnwantedObjects;\n+import org.polarsys.capella.core.tiger.IResolver;\n+import org.polarsys.capella.core.tiger.ITransfo;\n+import org.polarsys.capella.core.tiger.helpers.Query;\n+import org.polarsys.capella.core.tiger.impl.TransfoEngine;\n+\n+/**\n+ */\n+public class TopDownExt {\n+\n+  /**\n+   * Retrieve related instances which will be used in the transitioned scenario of the given scenario\n+   */\n+  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+  public static List<AbstractInstance> getTargetInstances(Scenario scenario, ITransfo transfo_p) {\n+    List<AbstractInstance> partBounds = new ArrayList<AbstractInstance>();\n+\n+    for (InteractionFragment fragment : scenario.getOwnedInteractionFragments()) {\n+      if (fragment instanceof AbstractEnd) {\n+        AbstractEnd end = (AbstractEnd) fragment;\n+        AbstractEventOperation transitionedOperation = getTransitionedOperation(end, transfo_p);\n+        boolean isSource = ScenarioExt.isSource(end);\n+        AbstractInstance instance = getRelatedInstance(isSource, end, transitionedOperation, transfo_p);\n+        if (instance != null) {\n+          partBounds.add(instance);\n+        }\n+      }\n+    }\n+\n+    partBounds = (List) ListExt.removeDuplicates((List) partBounds);\n+\n+    return partBounds;\n+  }\n+\n+  /**\n+   * Retrieve related instances which will be used in the transitioned instance role of the given instance role\n+   */\n+  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+  public static List<AbstractInstance> getTargetInstances(InstanceRole role, ITransfo transfo_p) {\n+    List<AbstractInstance> partBounds = new ArrayList<AbstractInstance>();\n+\n+    for (AbstractEnd end : role.getAbstractEnds()) {\n+      AbstractEventOperation transitionedOperation = getTransitionedOperation(end, transfo_p);\n+      boolean isSource = ScenarioExt.isSource(end);\n+      AbstractInstance instance = getRelatedInstance(isSource, end, transitionedOperation, transfo_p);\n+      if (instance != null) {\n+        partBounds.add(instance);\n+      } else {\n+        UnwantedObjects.add(end.getEvent(), transfo_p);\n+      }\n+    }\n+\n+    if ((partBounds.size() == 0) && (role.getRepresentedInstance() != null)) {\n+      String messageTxxt = Messages.Scenario_MultipleTransitionedElements;\n+      List<? extends EObject> availables = Query.retrieveTransformedElements(role.getRepresentedInstance(), transfo_p,\n+          InformationPackage.Literals.ABSTRACT_INSTANCE);\n+      if ((availables.size() == 0) && (role.getRepresentedInstance() instanceof Part)) {\n+        for (Component element : (List<Component>) Query.retrieveTransformedElements(\n+            role.getRepresentedInstance().getAbstractType(), transfo_p, CsPackage.Literals.COMPONENT)) {\n+          availables.addAll((List) element.getRepresentingParts());\n+        }\n+      }\n+\n+      if (availables.size() <= 1) {\n+        partBounds.addAll((List) availables);\n+      } else {\n+        IResolver resolver = ResolverFinalizer.getResolver(transfo_p);\n+        if (resolver != null) {\n+          List<EObject> res = resolver.resolve(role.getRepresentedInstance(), (List) availables,\n+              ScenarioTransfo.getTitle(transfo_p), messageTxxt, false, transfo_p,\n+              new EObject[] { role.getRepresentedInstance() });\n+          if ((res != null) && (res.size() > 0)) {\n+            partBounds.add((AbstractInstance) res.get(0));\n+          }\n+        }\n+      }\n+    }\n+\n+    partBounds = (List) ListExt.removeDuplicates((List) partBounds);\n+\n+    return partBounds;\n+  }\n+\n+  /**\n+   * Retrieve an instance for the given end and given operation_p. sourceEnd is used to restrict\n+   */\n+  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+  public static AbstractInstance getRelatedInstance(boolean isSource, AbstractEnd sourceEnd,\n+      AbstractEventOperation targetOperation, ITransfo transfo_p) {\n+    List<AbstractInstance> partBounds = new ArrayList<AbstractInstance>();\n+\n+    if (sourceEnd != null) {\n+\n+      if (!ScenarioExt.isExchangeItemInstanceRole(sourceEnd)) {\n+        Collection<AbstractInstance> relatedParts = getRelatedInstances(isSource, targetOperation, transfo_p);\n+\n+        // Restrict to components or parent components.\n+        boolean isLinked = false;\n+        for (AbstractInstance relatedPart : relatedParts) {\n+          for (AbstractInstance parent : getRelatedPartAndAncestors(relatedPart)) {\n+            for (InstanceRole relatedRole : sourceEnd.getCoveredInstanceRoles()) {\n+              if (RefinementLinkExt.isLinkedTo(parent, relatedRole.getRepresentedInstance())) {\n+                isLinked = true;\n+                partBounds.add(relatedPart);\n+              }\n+            }\n+          }\n+        }\n+\n+        if (!isLinked) {\n+          partBounds.addAll(relatedParts);\n+        }\n+\n+      } else {\n+        ExchangeItemInstance instance = (ExchangeItemInstance) ScenarioExt.getExchangeItemInstanceRole(sourceEnd);\n+        if (targetOperation instanceof ExchangeItemAllocation) {\n+          if (RefinementLinkExt.isLinkedTo(((ExchangeItemAllocation)targetOperation).getAllocatedItem(), instance.getType())) {\n+            List<?> instances = Query.retrieveTransformedElements(instance, transfo_p,\n+                InformationPackage.Literals.ABSTRACT_INSTANCE);\n+            partBounds.addAll((List) instances);\n+            \n+          } else if (((ExchangeItemAllocation)targetOperation).getAllocatedItem().equals(instance.getType()) ){\n+            partBounds.add(instance);\n+          }\n+        }\n+      }\n+\n+    }\n+\n+    partBounds = (List) ListExt.removeDuplicates((List) partBounds);\n+\n+    if (partBounds.size() == 0) {\n+      return null;\n+    } else if (partBounds.size() == 1) {\n+      return partBounds.get(0);\n+    }\n+\n+    IResolver resolver = ResolverFinalizer.getResolver(transfo_p);\n+    if (resolver == null) {\n+      return partBounds.get(0);\n+    }\n+\n+    SequenceMessage message = ScenarioExt.getRelatedSequenceMessage(sourceEnd);\n+    String messageTxt = NLS.bind((isSource ? Messages.Scenario_SourceMessage : Messages.Scenario_TargetMessage),\n+        new Object[] { getPosition(message), EObjectLabelProviderHelper.getText(message),\n+            EObjectLabelProviderHelper.getText(targetOperation),\n+            EObjectLabelProviderHelper.getMetaclassLabel(targetOperation, true) });\n+\n+    EObject context = (isSource ? message.getSendingEnd() : message.getReceivingEnd());\n+    return (AbstractInstance) resolver.resolve(targetOperation, (List) partBounds, ScenarioTransfo.getTitle(transfo_p),\n+        messageTxt, false, transfo_p, new EObject[] { message, targetOperation, context }).get(0);\n+  }\n+\n+  /**\n+   * Retrieve for an instance, all instances which can be considered to be the instance\n+   */\n+  private static Collection<AbstractInstance> getRelatedPartAndAncestors(AbstractInstance relatedPart_p) {\n+\n+    List<AbstractInstance> parents = new ArrayList<AbstractInstance>();\n+    parents.add(relatedPart_p);\n+\n+    if (relatedPart_p instanceof Part) {\n+      parents.addAll(ComponentExt.getPartAncestors((Part) relatedPart_p, true));\n+    }\n+    return parents;\n+  }\n+\n+  /**\n+   * @param message_p\n+   * @return\n+   */\n+  private static String getPosition(SequenceMessage message_p) {\n+    EObject container = message_p.eContainer();\n+    EStructuralFeature reference = message_p.eContainingFeature();\n+    Object value = null;\n+    int position = 1;\n+\n+    if ((container != null) && (reference != null) && reference.isMany()) {\n+      value = container.eGet(reference);\n+      if (value instanceof List<?>) {\n+        position = ((List<?>) value).indexOf(message_p) + 1;\n+      }\n+    }\n+\n+    switch (position % 10) {\n+    case 1:\n+      return position + Messages.Scenario_First;\n+    case 2:\n+      return position + Messages.Scenario_Second;\n+    case 3:\n+      return position + Messages.Scenario_Third;\n+    default:\n+      return position + Messages.Scenario_Nth;\n+    }\n+  }\n+\n+  /**\n+   * Retrieve for an abstract end and a related operation, instances which are related to the bound of the operation\n+   * according to the end of the message For a bound of a ce, returns related parts For a bound of a fe, returns related\n+   * functions, or part according to scenario kind\n+   */\n+  public static Collection<AbstractInstance> getRelatedInstances(boolean isSource, EObject operation,\n+      ITransfo transfo_p) {\n+\n+    Scenario scenario = (Scenario) transfo_p.get(TransfoEngine.TRANSFO_SOURCE);\n+    // On functional scenario, we return directly related function, otherwise, allocating parts\n+    boolean shouldRetrieveAllocating = !TransitionHelper.getService().isFunctionalScenario(scenario);\n+\n+    Collection<Component> componentBounds = new LinkedHashSet<Component>();\n+    Collection<AbstractInstance> instances = new LinkedHashSet<AbstractInstance>();\n+\n+    if (operation instanceof ComponentExchange) {\n+      // Retrieve related parts for a bound of a connection\n+      // (the connected part or any representing parts of the connected type)\n+      ComponentExchange exchange = (ComponentExchange) operation;\n+      if (isSource || !exchange.isOriented()) {\n+        instances.addAll(ComponentExchangeExt.getSourceParts(exchange));\n+      }\n+      if (!isSource || !exchange.isOriented()) {\n+        instances.addAll(ComponentExchangeExt.getTargetParts(exchange));\n+      }\n+\n+    } else if (operation instanceof FunctionalExchange) {\n+      // Retrieve related parts for a bound of a functional exchange\n+      // (any representing parts of components allocating the function)\n+      FunctionalExchange exchange = (FunctionalExchange) operation;\n+      AbstractFunction function = isSource ? FunctionalExchangeExt.getSourceFunction(exchange)\n+          : FunctionalExchangeExt.getTargetFunction(exchange);\n+\n+      if (function != null) {\n+        if (shouldRetrieveAllocating) {\n+          componentBounds.addAll(AbstractFunctionExt.getAllocatingComponents(function));\n+\n+          if (function instanceof OperationalActivity) {\n+            for (Role role : ((OperationalActivity) function).getAllocatingRoles()) {\n+              componentBounds.addAll(role.getAllocatingEntities());\n+            }\n+          }\n+\n+        } else {\n+          instances.add(function);\n+        }\n+      }\n+    } else if (operation instanceof ExchangeItemAllocation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1485a996708e89ffc44a293f1d4d8bd7d5e57811"}, "originalPosition": 303}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzOTMxNjI4OnYy", "diffSide": "RIGHT", "path": "core/plugins/org.polarsys.capella.core.projection.scenario/src/org/polarsys/capella/core/projection/scenario/topdown/TopDownExt.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODo1NDo1MVrOF3S5qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwODo1NDo1MVrOF3S5qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzUyNTY3Mg==", "bodyText": "To make ExchangeItem as instance role work, its here.\ntargetOperation is the ExchangeItemAllocation to use (the one from targetArchitecture if it exist, or the original one if not transitioned according to preferences)\nWe lookup the original ExchangeItemInstance of the message end. If targetOperation is transitioned, then we lookup for the transitioned ExchangeItemInstance. Otherwise, we use the ExchangeItemInstance if it match with targetOperation", "url": "https://github.com/eclipse/capella/pull/129#discussion_r393525672", "createdAt": "2020-03-17T08:54:51Z", "author": {"login": "pdulth"}, "path": "core/plugins/org.polarsys.capella.core.projection.scenario/src/org/polarsys/capella/core/projection/scenario/topdown/TopDownExt.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*******************************************************************************\n+ * Copyright (c) 2006, 2019 THALES GLOBAL SERVICES.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * which accompanies this distribution, and is available at\n+ * http://www.eclipse.org/legal/epl-v10.html\n+ *  \n+ * Contributors:\n+ *    Thales - initial API and implementation\n+ *******************************************************************************/\n+package org.polarsys.capella.core.projection.scenario.topdown;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.osgi.util.NLS;\n+import org.polarsys.capella.common.helpers.EObjectLabelProviderHelper;\n+import org.polarsys.capella.core.data.cs.BlockArchitecture;\n+import org.polarsys.capella.core.data.cs.Component;\n+import org.polarsys.capella.core.data.cs.CsPackage;\n+import org.polarsys.capella.core.data.cs.ExchangeItemAllocation;\n+import org.polarsys.capella.core.data.cs.Interface;\n+import org.polarsys.capella.core.data.cs.Part;\n+import org.polarsys.capella.core.data.epbs.ConfigurationItem;\n+import org.polarsys.capella.core.data.epbs.EPBSArchitecture;\n+import org.polarsys.capella.core.data.fa.AbstractFunction;\n+import org.polarsys.capella.core.data.fa.ComponentExchange;\n+import org.polarsys.capella.core.data.fa.FunctionalExchange;\n+import org.polarsys.capella.core.data.information.AbstractEventOperation;\n+import org.polarsys.capella.core.data.information.AbstractInstance;\n+import org.polarsys.capella.core.data.information.ExchangeItemInstance;\n+import org.polarsys.capella.core.data.information.InformationPackage;\n+import org.polarsys.capella.core.data.interaction.AbstractEnd;\n+import org.polarsys.capella.core.data.interaction.Event;\n+import org.polarsys.capella.core.data.interaction.ExecutionEnd;\n+import org.polarsys.capella.core.data.interaction.InstanceRole;\n+import org.polarsys.capella.core.data.interaction.InteractionFragment;\n+import org.polarsys.capella.core.data.interaction.Scenario;\n+import org.polarsys.capella.core.data.interaction.SequenceMessage;\n+import org.polarsys.capella.core.data.oa.OperationalActivity;\n+import org.polarsys.capella.core.data.oa.Role;\n+import org.polarsys.capella.core.data.pa.PhysicalComponent;\n+import org.polarsys.capella.core.model.helpers.AbstractFunctionExt;\n+import org.polarsys.capella.core.model.helpers.BlockArchitectureExt;\n+import org.polarsys.capella.core.model.helpers.ComponentExchangeExt;\n+import org.polarsys.capella.core.model.helpers.ComponentExt;\n+import org.polarsys.capella.core.model.helpers.FunctionalExchangeExt;\n+import org.polarsys.capella.core.model.helpers.RefinementLinkExt;\n+import org.polarsys.capella.core.model.utils.ListExt;\n+import org.polarsys.capella.core.projection.common.TransitionHelper;\n+import org.polarsys.capella.core.projection.common.resolver.ResolverFinalizer;\n+import org.polarsys.capella.core.projection.scenario.Messages;\n+import org.polarsys.capella.core.projection.scenario.ScenarioTransfo;\n+import org.polarsys.capella.core.projection.scenario.helpers.ScenarioExt;\n+import org.polarsys.capella.core.projection.scenario.helpers.UnwantedObjects;\n+import org.polarsys.capella.core.tiger.IResolver;\n+import org.polarsys.capella.core.tiger.ITransfo;\n+import org.polarsys.capella.core.tiger.helpers.Query;\n+import org.polarsys.capella.core.tiger.impl.TransfoEngine;\n+\n+/**\n+ */\n+public class TopDownExt {\n+\n+  /**\n+   * Retrieve related instances which will be used in the transitioned scenario of the given scenario\n+   */\n+  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+  public static List<AbstractInstance> getTargetInstances(Scenario scenario, ITransfo transfo_p) {\n+    List<AbstractInstance> partBounds = new ArrayList<AbstractInstance>();\n+\n+    for (InteractionFragment fragment : scenario.getOwnedInteractionFragments()) {\n+      if (fragment instanceof AbstractEnd) {\n+        AbstractEnd end = (AbstractEnd) fragment;\n+        AbstractEventOperation transitionedOperation = getTransitionedOperation(end, transfo_p);\n+        boolean isSource = ScenarioExt.isSource(end);\n+        AbstractInstance instance = getRelatedInstance(isSource, end, transitionedOperation, transfo_p);\n+        if (instance != null) {\n+          partBounds.add(instance);\n+        }\n+      }\n+    }\n+\n+    partBounds = (List) ListExt.removeDuplicates((List) partBounds);\n+\n+    return partBounds;\n+  }\n+\n+  /**\n+   * Retrieve related instances which will be used in the transitioned instance role of the given instance role\n+   */\n+  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+  public static List<AbstractInstance> getTargetInstances(InstanceRole role, ITransfo transfo_p) {\n+    List<AbstractInstance> partBounds = new ArrayList<AbstractInstance>();\n+\n+    for (AbstractEnd end : role.getAbstractEnds()) {\n+      AbstractEventOperation transitionedOperation = getTransitionedOperation(end, transfo_p);\n+      boolean isSource = ScenarioExt.isSource(end);\n+      AbstractInstance instance = getRelatedInstance(isSource, end, transitionedOperation, transfo_p);\n+      if (instance != null) {\n+        partBounds.add(instance);\n+      } else {\n+        UnwantedObjects.add(end.getEvent(), transfo_p);\n+      }\n+    }\n+\n+    if ((partBounds.size() == 0) && (role.getRepresentedInstance() != null)) {\n+      String messageTxxt = Messages.Scenario_MultipleTransitionedElements;\n+      List<? extends EObject> availables = Query.retrieveTransformedElements(role.getRepresentedInstance(), transfo_p,\n+          InformationPackage.Literals.ABSTRACT_INSTANCE);\n+      if ((availables.size() == 0) && (role.getRepresentedInstance() instanceof Part)) {\n+        for (Component element : (List<Component>) Query.retrieveTransformedElements(\n+            role.getRepresentedInstance().getAbstractType(), transfo_p, CsPackage.Literals.COMPONENT)) {\n+          availables.addAll((List) element.getRepresentingParts());\n+        }\n+      }\n+\n+      if (availables.size() <= 1) {\n+        partBounds.addAll((List) availables);\n+      } else {\n+        IResolver resolver = ResolverFinalizer.getResolver(transfo_p);\n+        if (resolver != null) {\n+          List<EObject> res = resolver.resolve(role.getRepresentedInstance(), (List) availables,\n+              ScenarioTransfo.getTitle(transfo_p), messageTxxt, false, transfo_p,\n+              new EObject[] { role.getRepresentedInstance() });\n+          if ((res != null) && (res.size() > 0)) {\n+            partBounds.add((AbstractInstance) res.get(0));\n+          }\n+        }\n+      }\n+    }\n+\n+    partBounds = (List) ListExt.removeDuplicates((List) partBounds);\n+\n+    return partBounds;\n+  }\n+\n+  /**\n+   * Retrieve an instance for the given end and given operation_p. sourceEnd is used to restrict\n+   */\n+  @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+  public static AbstractInstance getRelatedInstance(boolean isSource, AbstractEnd sourceEnd,\n+      AbstractEventOperation targetOperation, ITransfo transfo_p) {\n+    List<AbstractInstance> partBounds = new ArrayList<AbstractInstance>();\n+\n+    if (sourceEnd != null) {\n+\n+      if (!ScenarioExt.isExchangeItemInstanceRole(sourceEnd)) {\n+        Collection<AbstractInstance> relatedParts = getRelatedInstances(isSource, targetOperation, transfo_p);\n+\n+        // Restrict to components or parent components.\n+        boolean isLinked = false;\n+        for (AbstractInstance relatedPart : relatedParts) {\n+          for (AbstractInstance parent : getRelatedPartAndAncestors(relatedPart)) {\n+            for (InstanceRole relatedRole : sourceEnd.getCoveredInstanceRoles()) {\n+              if (RefinementLinkExt.isLinkedTo(parent, relatedRole.getRepresentedInstance())) {\n+                isLinked = true;\n+                partBounds.add(relatedPart);\n+              }\n+            }\n+          }\n+        }\n+\n+        if (!isLinked) {\n+          partBounds.addAll(relatedParts);\n+        }\n+\n+      } else {\n+        ExchangeItemInstance instance = (ExchangeItemInstance) ScenarioExt.getExchangeItemInstanceRole(sourceEnd);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1485a996708e89ffc44a293f1d4d8bd7d5e57811"}, "originalPosition": 174}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4315, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}