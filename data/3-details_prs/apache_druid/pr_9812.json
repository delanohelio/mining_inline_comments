{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyNTI3NDY5", "number": 9812, "title": "Fix filtering on boolean values in transformation", "bodyText": "Description\n#9484 introduced a bug that a filter treats all boolean values as nulls in transformation. For example, the below transformSpec filters out all rows.\n      \"transformSpec\": {\n        \"filter\": {\n          \"type\": \"selector\",\n          \"dimension\": \"booleanDimension\",\n          \"value\": \"false\"\n        }\nThis PR fixes it by falling back to the previous behavior when rowValue has a complex type.\nAnother bug with strlen() on multi-valued columns is fixed in this PR as well. The strlen() function should allow only single-valued columns. On the query side, the caller should be able to automatically apply strlen() to each element in the multi-valued column, which is already implemented. On the ingestion side, however, it doesn't explode multi-valued column automatically, and strlen() on multi-valued columns should fail.\n\nThis PR has:\n\n been self-reviewed.\n\n using the concurrency checklist (Remove this item if the PR doesn't have any relation to concurrency.)\n\n\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added or updated version, license, or notice information in licenses.yaml\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths.\n added integration tests.\n been tested in a test Druid cluster.", "createdAt": "2020-05-03T00:25:07Z", "url": "https://github.com/apache/druid/pull/9812", "merged": true, "mergeCommit": {"oid": "c6caae9a24ed0363380d2a6b1b12f5f8af9bd425"}, "closed": true, "closedAt": "2020-05-05T01:47:11Z", "author": {"login": "jihoonson"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcdfd5gAH2gAyNDEyNTI3NDY5OjhiNTNmMGJkMjFhMWQ2ZjEzZmU3YWU1ZThkYmM0MWFlNjJkNTZkNzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABceKC46gFqTQwNTQ1MjkwNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8b53f0bd21a1d6f13fe7ae5e8dbc41ae62d56d74", "author": {"user": {"login": "jihoonson", "name": "Jihoon Son"}}, "url": "https://github.com/apache/druid/commit/8b53f0bd21a1d6f13fe7ae5e8dbc41ae62d56d74", "committedDate": "2020-05-03T00:09:36Z", "message": "Fix filter on boolean value in Transform"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6747ea78865d72153cd0f4eb35e4bd8c5709edf2", "author": {"user": {"login": "jihoonson", "name": "Jihoon Son"}}, "url": "https://github.com/apache/druid/commit/6747ea78865d72153cd0f4eb35e4bd8c5709edf2", "committedDate": "2020-05-03T01:45:06Z", "message": "assert"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjQ1OTA0", "url": "https://github.com/apache/druid/pull/9812#pullrequestreview-404645904", "createdAt": "2020-05-03T18:40:49Z", "commit": {"oid": "6747ea78865d72153cd0f4eb35e4bd8c5709edf2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QxODo0MDo0OVrOGPubdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QxODo0MDo0OVrOGPubdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE0MjUxOA==", "bodyText": "It's not obvious where dmFy comes from. What do you think about adding comment about base64 or adding a variable with a descriptive name?", "url": "https://github.com/apache/druid/pull/9812#discussion_r419142518", "createdAt": "2020-05-03T18:40:49Z", "author": {"login": "ccaominh"}, "path": "processing/src/test/java/org/apache/druid/segment/filter/PredicateValueMatcherFactoryTest.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.filter;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.java.util.common.DateTimes;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.filter.SelectorPredicateFactory;\n+import org.apache.druid.query.filter.ValueMatcher;\n+import org.apache.druid.segment.DimensionSelector;\n+import org.apache.druid.segment.SimpleAscendingOffset;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.data.GenericIndexed;\n+import org.apache.druid.segment.data.VSizeColumnarInts;\n+import org.apache.druid.segment.data.VSizeColumnarMultiInts;\n+import org.apache.druid.segment.selector.TestColumnValueSelector;\n+import org.apache.druid.segment.serde.DictionaryEncodedColumnSupplier;\n+import org.apache.druid.testing.InitializedNullHandlingTest;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+\n+public class PredicateValueMatcherFactoryTest extends InitializedNullHandlingTest\n+{\n+  @Test\n+  public void testDefaultType()\n+  {\n+    Assert.assertEquals(ValueType.COMPLEX, forSelector(null).defaultType());\n+  }\n+\n+  @Test\n+  public void testDimensionProcessorSingleValuedDimensionMatchingValue()\n+  {\n+    final ValueMatcher matcher = forSelector(\"0\").makeDimensionProcessor(DimensionSelector.constant(\"0\"), false);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testDimensionProcessorSingleValuedDimensionNotMatchingValue()\n+  {\n+    final ValueMatcher matcher = forSelector(\"1\").makeDimensionProcessor(DimensionSelector.constant(\"0\"), false);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testDimensionProcessorMultiValuedDimensionMatchingValue()\n+  {\n+    // Emulate multi-valued dimension\n+    final DictionaryEncodedColumnSupplier columnSupplier = new DictionaryEncodedColumnSupplier(\n+        GenericIndexed.fromIterable(ImmutableList.of(\"v1\", \"v2\", \"v3\"), GenericIndexed.STRING_STRATEGY),\n+        null,\n+        () -> VSizeColumnarMultiInts.fromIterable(ImmutableList.of(VSizeColumnarInts.fromArray(new int[]{1}))),\n+        0\n+    );\n+    final ValueMatcher matcher = forSelector(\"v2\")\n+        .makeDimensionProcessor(columnSupplier.get().makeDimensionSelector(new SimpleAscendingOffset(1), null), true);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testDimensionProcessorMultiValuedDimensionNotMatchingValue()\n+  {\n+    // Emulate multi-valued dimension\n+    final DictionaryEncodedColumnSupplier columnSupplier = new DictionaryEncodedColumnSupplier(\n+        GenericIndexed.fromIterable(ImmutableList.of(\"v1\", \"v2\", \"v3\"), GenericIndexed.STRING_STRATEGY),\n+        null,\n+        () -> VSizeColumnarMultiInts.fromIterable(ImmutableList.of(VSizeColumnarInts.fromArray(new int[]{1}))),\n+        0\n+    );\n+    final ValueMatcher matcher = forSelector(\"v3\")\n+        .makeDimensionProcessor(columnSupplier.get().makeDimensionSelector(new SimpleAscendingOffset(1), null), true);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testFloatProcessorMatchingValue()\n+  {\n+    final TestColumnValueSelector<Float> columnValueSelector = TestColumnValueSelector.of(\n+        Float.class,\n+        ImmutableList.of(2.f),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"2.f\").makeFloatProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testFloatProcessorNotMatchingValue()\n+  {\n+    final TestColumnValueSelector<Float> columnValueSelector = TestColumnValueSelector.of(\n+        Float.class,\n+        ImmutableList.of(2.f),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"5.f\").makeFloatProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testDoubleProcessorMatchingValue()\n+  {\n+    final TestColumnValueSelector<Double> columnValueSelector = TestColumnValueSelector.of(\n+        Double.class,\n+        ImmutableList.of(2.),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"2.\").makeDoubleProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testDoubleProcessorNotMatchingValue()\n+  {\n+    final TestColumnValueSelector<Double> columnValueSelector = TestColumnValueSelector.of(\n+        Double.class,\n+        ImmutableList.of(2.),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"5.\").makeDoubleProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testLongProcessorMatchingValue()\n+  {\n+    final TestColumnValueSelector<Long> columnValueSelector = TestColumnValueSelector.of(\n+        Long.class,\n+        ImmutableList.of(2L),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"2\").makeLongProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testLongProcessorNotMatchingValue()\n+  {\n+    final TestColumnValueSelector<Long> columnValueSelector = TestColumnValueSelector.of(\n+        Long.class,\n+        ImmutableList.of(2L),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"5\").makeLongProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingNull()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        Arrays.asList(null, \"v\"),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(null).makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorEmptyString()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        Arrays.asList(\"\", \"v\"),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(null).makeComplexProcessor(columnValueSelector);\n+    if (NullHandling.sqlCompatible()) {\n+      Assert.assertFalse(matcher.matches());\n+    } else {\n+      Assert.assertTrue(matcher.matches());\n+    }\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingInteger()\n+  {\n+    final TestColumnValueSelector<Integer> columnValueSelector = TestColumnValueSelector.of(\n+        Integer.class,\n+        ImmutableList.of(11),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"11\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorNotMatchingInteger()\n+  {\n+    final TestColumnValueSelector<Integer> columnValueSelector = TestColumnValueSelector.of(\n+        Integer.class,\n+        ImmutableList.of(15),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"11\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingLong()\n+  {\n+    final TestColumnValueSelector<Long> columnValueSelector = TestColumnValueSelector.of(\n+        Long.class,\n+        ImmutableList.of(11L),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"11\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorNotMatchingLong()\n+  {\n+    final TestColumnValueSelector<Long> columnValueSelector = TestColumnValueSelector.of(\n+        Long.class,\n+        ImmutableList.of(15L),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"11\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingFloat()\n+  {\n+    final TestColumnValueSelector<Float> columnValueSelector = TestColumnValueSelector.of(\n+        Float.class,\n+        ImmutableList.of(11.f),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"11.f\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorNotMatchingFloat()\n+  {\n+    final TestColumnValueSelector<Float> columnValueSelector = TestColumnValueSelector.of(\n+        Float.class,\n+        ImmutableList.of(15.f),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"11.f\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingDouble()\n+  {\n+    final TestColumnValueSelector<Double> columnValueSelector = TestColumnValueSelector.of(\n+        Double.class,\n+        ImmutableList.of(11.d),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"11.d\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorNotMatchingDouble()\n+  {\n+    final TestColumnValueSelector<Double> columnValueSelector = TestColumnValueSelector.of(\n+        Double.class,\n+        ImmutableList.of(15.d),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"11.d\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingString()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        ImmutableList.of(\"val\"),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"val\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorNotMatchingString()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        ImmutableList.of(\"bar\"),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"val\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingStringList()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        ImmutableList.of(ImmutableList.of(\"val\")),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"val\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorNotMatchingStringList()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        ImmutableList.of(ImmutableList.of(\"bar\")),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"val\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingEmptyList()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        ImmutableList.of(ImmutableList.of()),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(null).makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingBoolean()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        ImmutableList.of(false),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"false\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertTrue(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorNotMatchingBoolean()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        ImmutableList.of(true),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"false\").makeComplexProcessor(columnValueSelector);\n+    Assert.assertFalse(matcher.matches());\n+  }\n+\n+  @Test\n+  public void testComplexProcessorMatchingByteArray()\n+  {\n+    final TestColumnValueSelector<String> columnValueSelector = TestColumnValueSelector.of(\n+        String.class,\n+        ImmutableList.of(StringUtils.toUtf8(\"var\")),\n+        DateTimes.nowUtc()\n+    );\n+    columnValueSelector.advance();\n+    final ValueMatcher matcher = forSelector(\"dmFy\").makeComplexProcessor(columnValueSelector);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6747ea78865d72153cd0f4eb35e4bd8c5709edf2"}, "originalPosition": 407}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "abe6a6bb03fa21ee07819c01d9edb62180c06d10", "author": {"user": {"login": "jihoonson", "name": "Jihoon Son"}}, "url": "https://github.com/apache/druid/commit/abe6a6bb03fa21ee07819c01d9edb62180c06d10", "committedDate": "2020-05-03T20:37:52Z", "message": "more descriptive test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NjU2MzI5", "url": "https://github.com/apache/druid/pull/9812#pullrequestreview-404656329", "createdAt": "2020-05-03T20:52:25Z", "commit": {"oid": "abe6a6bb03fa21ee07819c01d9edb62180c06d10"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MzMzNTE2", "url": "https://github.com/apache/druid/pull/9812#pullrequestreview-405333516", "createdAt": "2020-05-04T20:45:25Z", "commit": {"oid": "abe6a6bb03fa21ee07819c01d9edb62180c06d10"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMDo0NToyNVrOGQRgGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMDo1MDo1MlrOGQRrHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxNzE0Ng==", "bodyText": "For anti-bug safety, it'd be good to have a Preconditions.checkState(stringValueValid) here.", "url": "https://github.com/apache/druid/pull/9812#discussion_r419717146", "createdAt": "2020-05-04T20:45:25Z", "author": {"login": "gianm"}, "path": "core/src/main/java/org/apache/druid/math/expr/ExprEval.java", "diffHunk": "@@ -137,6 +137,23 @@ public T value()\n     return value;\n   }\n \n+  void setStringValue(@Nullable String value)\n+  {\n+    stringValue = value;\n+    stringValueValid = true;\n+  }\n+\n+  @Nullable\n+  String getStringValue()\n+  {\n+    return stringValue;\n+  }\n+\n+  boolean isStringValueValid()\n+  {\n+    return stringValueValid;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe6a6bb03fa21ee07819c01d9edb62180c06d10"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTcxOTk2Nw==", "bodyText": "If I'm reading this right, eval really could be an array at runtime, so an assert isn't the right thing to do here. They are disabled by default outside of unit tests. So they're mostly useful for checking things that cannot possibly be false unless there is some bug in the software logic itself.\nBesides that, since this error could happen due to legitimate user input, it should have a nicer error message.\nAlso, is there a reason to only adjust strlen in this patch? Lots of other functions have similar issues. I'm wondering if we should split this part off into a separate patch, and make sure we address it systematically.", "url": "https://github.com/apache/druid/pull/9812#discussion_r419719967", "createdAt": "2020-05-04T20:50:52Z", "author": {"login": "gianm"}, "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -1490,7 +1491,9 @@ public String name()\n     @Override\n     public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n     {\n-      final String arg = args.get(0).eval(bindings).asString();\n+      final ExprEval eval = args.get(0).eval(bindings);\n+      assert !(eval instanceof ArrayExprEval);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe6a6bb03fa21ee07819c01d9edb62180c06d10"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c55cbce7e7b8a71726105c8b8b28c0583382d2b9", "author": {"user": {"login": "jihoonson", "name": "Jihoon Son"}}, "url": "https://github.com/apache/druid/commit/c55cbce7e7b8a71726105c8b8b28c0583382d2b9", "committedDate": "2020-05-04T22:55:08Z", "message": "remove assert"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDE2MTY1", "url": "https://github.com/apache/druid/pull/9812#pullrequestreview-405416165", "createdAt": "2020-05-04T23:32:31Z", "commit": {"oid": "c55cbce7e7b8a71726105c8b8b28c0583382d2b9"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMzozMjozMVrOGQV1fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMzozMjozMVrOGQV1fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4ODE1Nw==", "bodyText": "This line might get flagged as an unused import.", "url": "https://github.com/apache/druid/pull/9812#discussion_r419788157", "createdAt": "2020-05-04T23:32:31Z", "author": {"login": "gianm"}, "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -25,6 +25,7 @@\n import org.apache.druid.java.util.common.IAE;\n import org.apache.druid.java.util.common.RE;\n import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.ExprEval.ArrayExprEval;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c55cbce7e7b8a71726105c8b8b28c0583382d2b9"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDIzNzA3", "url": "https://github.com/apache/druid/pull/9812#pullrequestreview-405423707", "createdAt": "2020-05-04T23:55:50Z", "commit": {"oid": "c55cbce7e7b8a71726105c8b8b28c0583382d2b9"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMzo1NTo1MVrOGQWQnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMzo1NTo1OFrOGQWQvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5NTEwMQ==", "bodyText": "This test should be adjusted since you removed the strlen change.", "url": "https://github.com/apache/druid/pull/9812#discussion_r419795101", "createdAt": "2020-05-04T23:55:51Z", "author": {"login": "gianm"}, "path": "processing/src/test/java/org/apache/druid/segment/transform/TransformerTest.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.transform;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.druid.data.input.InputRow;\n+import org.apache.druid.data.input.InputRowListPlusRawValues;\n+import org.apache.druid.data.input.MapBasedInputRow;\n+import org.apache.druid.java.util.common.DateTimes;\n+import org.apache.druid.query.expression.TestExprMacroTable;\n+import org.apache.druid.query.filter.SelectorDimFilter;\n+import org.apache.druid.testing.InitializedNullHandlingTest;\n+import org.joda.time.DateTime;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+public class TransformerTest extends InitializedNullHandlingTest\n+{\n+  @Rule\n+  public ExpectedException expectedException = ExpectedException.none();\n+\n+  @Test\n+  public void testTransformNullRowReturnNull()\n+  {\n+    final Transformer transformer = new Transformer(new TransformSpec(null, null));\n+    Assert.assertNull(transformer.transform((InputRow) null));\n+    Assert.assertNull(transformer.transform((InputRowListPlusRawValues) null));\n+  }\n+\n+  @Test\n+  public void testTransformTimeColumn()\n+  {\n+    final Transformer transformer = new Transformer(\n+        new TransformSpec(\n+            null,\n+            ImmutableList.of(\n+                new ExpressionTransform(\"__time\", \"timestamp_shift(__time, 'P1D', -2)\", TestExprMacroTable.INSTANCE)\n+            )\n+        )\n+    );\n+    final DateTime now = DateTimes.nowUtc();\n+    final InputRow row = new MapBasedInputRow(\n+        now,\n+        ImmutableList.of(\"dim\"),\n+        ImmutableMap.of(\"__time\", now, \"dim\", false)\n+    );\n+    final InputRow actual = transformer.transform(row);\n+    Assert.assertNotNull(actual);\n+    Assert.assertEquals(now.minusDays(2), actual.getTimestamp());\n+  }\n+\n+  @Test\n+  public void testTransformWithStringTransformOnBooleanColumnTransformAfterCasting()\n+  {\n+    final Transformer transformer = new Transformer(\n+        new TransformSpec(\n+            null,\n+            ImmutableList.of(new ExpressionTransform(\"dim\", \"strlen(dim)\", TestExprMacroTable.INSTANCE))\n+        )\n+    );\n+    final InputRow row = new MapBasedInputRow(\n+        DateTimes.nowUtc(),\n+        ImmutableList.of(\"dim\"),\n+        ImmutableMap.of(\"dim\", false)\n+    );\n+    final InputRow actual = transformer.transform(row);\n+    Assert.assertNotNull(actual);\n+    Assert.assertEquals(ImmutableList.of(\"dim\"), actual.getDimensions());\n+    Assert.assertEquals(5L, actual.getRaw(\"dim\"));\n+    Assert.assertEquals(row.getTimestamp(), actual.getTimestamp());\n+  }\n+\n+  @Test\n+  public void testTransformWithStringTransformOnLongColumnTransformAfterCasting()\n+  {\n+    final Transformer transformer = new Transformer(\n+        new TransformSpec(\n+            null,\n+            ImmutableList.of(new ExpressionTransform(\"dim\", \"strlen(dim)\", TestExprMacroTable.INSTANCE))\n+        )\n+    );\n+    final InputRow row = new MapBasedInputRow(\n+        DateTimes.nowUtc(),\n+        ImmutableList.of(\"dim\"),\n+        ImmutableMap.of(\"dim\", 10L)\n+    );\n+    final InputRow actual = transformer.transform(row);\n+    Assert.assertNotNull(actual);\n+    Assert.assertEquals(ImmutableList.of(\"dim\"), actual.getDimensions());\n+    Assert.assertEquals(2L, actual.getRaw(\"dim\"));\n+    Assert.assertEquals(row.getTimestamp(), actual.getTimestamp());\n+  }\n+\n+  @Test\n+  public void testTransformWithStringTransformOnDoubleColumnTransformAfterCasting()\n+  {\n+    final Transformer transformer = new Transformer(\n+        new TransformSpec(\n+            null,\n+            ImmutableList.of(new ExpressionTransform(\"dim\", \"strlen(dim)\", TestExprMacroTable.INSTANCE))\n+        )\n+    );\n+    final InputRow row = new MapBasedInputRow(\n+        DateTimes.nowUtc(),\n+        ImmutableList.of(\"dim\"),\n+        ImmutableMap.of(\"dim\", 200.5d)\n+    );\n+    final InputRow actual = transformer.transform(row);\n+    Assert.assertNotNull(actual);\n+    Assert.assertEquals(ImmutableList.of(\"dim\"), actual.getDimensions());\n+    Assert.assertEquals(5L, actual.getRaw(\"dim\"));\n+    Assert.assertEquals(row.getTimestamp(), actual.getTimestamp());\n+  }\n+\n+  @Test\n+  public void testTransformWithStringTransformOnListColumnThrowingException()\n+  {\n+    final Transformer transformer = new Transformer(\n+        new TransformSpec(\n+            null,\n+            ImmutableList.of(new ExpressionTransform(\"dim\", \"strlen(dim)\", TestExprMacroTable.INSTANCE))\n+        )\n+    );\n+    final InputRow row = new MapBasedInputRow(\n+        DateTimes.nowUtc(),\n+        ImmutableList.of(\"dim\"),\n+        ImmutableMap.of(\"dim\", ImmutableList.of(10, 20, 100))\n+    );\n+    final InputRow actual = transformer.transform(row);\n+    Assert.assertNotNull(actual);\n+    Assert.assertEquals(ImmutableList.of(\"dim\"), actual.getDimensions());\n+    // Unlike for querying, Druid doesn't explode multi-valued columns automatically for ingestion.\n+    expectedException.expect(AssertionError.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c55cbce7e7b8a71726105c8b8b28c0583382d2b9"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc5NTEzNA==", "bodyText": "This test should be adjusted since you removed the strlen change.", "url": "https://github.com/apache/druid/pull/9812#discussion_r419795134", "createdAt": "2020-05-04T23:55:58Z", "author": {"login": "gianm"}, "path": "core/src/test/java/org/apache/druid/math/expr/FunctionTest.java", "diffHunk": "@@ -100,6 +105,7 @@ public void testStrlen()\n   {\n     assertExpr(\"strlen(x)\", 3L);\n     assertExpr(\"strlen(nonexistent)\", NullHandling.defaultLongValue());\n+    assertExprFail(\"strlen(a)\", AssertionError.class, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c55cbce7e7b8a71726105c8b8b28c0583382d2b9"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1eb51e7ff06d5621a76036b71d5ed3b96149451", "author": {"user": {"login": "jihoonson", "name": "Jihoon Son"}}, "url": "https://github.com/apache/druid/commit/a1eb51e7ff06d5621a76036b71d5ed3b96149451", "committedDate": "2020-05-05T00:15:21Z", "message": "add assert for cached string; disable tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2309381fedf3966bfd557199a5d779bb58320358", "author": {"user": {"login": "jihoonson", "name": "Jihoon Son"}}, "url": "https://github.com/apache/druid/commit/2309381fedf3966bfd557199a5d779bb58320358", "committedDate": "2020-05-05T00:18:12Z", "message": "typo"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1NDUyOTA3", "url": "https://github.com/apache/druid/pull/9812#pullrequestreview-405452907", "createdAt": "2020-05-05T01:46:01Z", "commit": {"oid": "2309381fedf3966bfd557199a5d779bb58320358"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2281, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}