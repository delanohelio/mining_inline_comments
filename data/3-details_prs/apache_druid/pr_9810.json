{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyNDUzNDQw", "number": 9810, "title": "Add segment pruning for hash based shard spec", "bodyText": "Fixes #9809.\nDescription\nCurrently segment pruning uses the time interval. For further filtering on secondary partitions, only single dimension ShardSpec is supported (done in #2982). For hash based partitioning (HashBasedNumberedShardSpec), we can also apply pruning by rehash the partitionDimensions in the query filter to locate segments.\nThis PR addresses this by rehashing the partitionDimensions values in HashBasedNumberedShardSpec from the query filter using the same hashing mechanism used during ingestion, and use the hashed value mod partitions to determine if it equals partitionNum of a segment. We only attempt pruning if 1) all partitionDimensions present in the query filter and 2) the values of partitionDimensions are discrete values not range values because we can't hash range values and 3) during ingestion time, partitionDimensions are explicitly set because otherwise the hash during ingestion is based on all dimensions plus the truncated input timestamp according to QueryGranularity instead of just partitionDimensions and we don't record timestamp in shard spec. Then we enumerate all combinations of the values of the dimensions in partitionDimensions drawn from the filter and check if the hashed value mod partitions matches the partitionNum of a segment. E.g., if the query contains filter \"dim1 = v1 and dim2 in (v2, v3, v4)\", then the hash values we will check are: hash(v1, v2), hash(v1, v3), hash(v1, v4).\nUpdated Jun 30:\nTo accommodate latest changes in master branch, replace partitionNum with bucketId and partitions with numBuckets in the hashing logic if they present, otherwise the logic is the same as what's in above description.\nThis PR has:\n\n been self-reviewed.\n\n using the concurrency checklist (Remove this item if the PR doesn't have any relation to concurrency.)\n\n\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added or updated version, license, or notice information in licenses.yaml\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths.\n added integration tests.\n been tested in a test Druid cluster.", "createdAt": "2020-05-02T13:42:06Z", "url": "https://github.com/apache/druid/pull/9810", "merged": true, "mergeCommit": {"oid": "271f90f2052ad4288e4981e12fea8c5d0786a601"}, "closed": true, "closedAt": "2020-07-31T01:44:27Z", "author": {"login": "wjhypo"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcdWmsuAFqTQwNDUzMDA0OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc51ZpkgFqTQ1ODAxMjQ3OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTMwMDQ4", "url": "https://github.com/apache/druid/pull/9810#pullrequestreview-404530048", "createdAt": "2020-05-02T13:50:03Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMzo1MDowNFrOGPjYJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMzo1MDowNFrOGPjYJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk2MTQ0Ng==", "bodyText": "Query time hashing should yield the same value as that produced during ingestion time. This should be a bug. Before this change, no one is using this api so no issue pops up before. During indexing, which segment to put a record into is by calling getLookup function below, in which the 32 bit hashed value is forced to stay as a positive integer by applying Math.abs. While here, it was casting the 32 bit hashed value to a long to force it stay as a positive integer. If the hashed value is 0xff_ff_ff_ff, Math.abs(0xff_ff_ff_ff) is different from (long)(0xff_ff_ff_ff). It's better to make the change here than in getLookup for backward compatibility otherwise users who have already used hash based partitioning can't leverage the pruning and pruning will be wrong unless they redo the ingestion to update segments.", "url": "https://github.com/apache/druid/pull/9810#discussion_r418961446", "createdAt": "2020-05-02T13:50:04Z", "author": {"login": "wjhypo"}, "path": "core/src/main/java/org/apache/druid/timeline/partition/HashBasedNumberedShardSpec.java", "diffHunk": "@@ -73,7 +81,7 @@ public boolean isCompatible(Class<? extends ShardSpec> other)\n   @Override\n   public boolean isInChunk(long timestamp, InputRow inputRow)\n   {\n-    return (((long) hash(timestamp, inputRow)) - getPartitionNum()) % getPartitions() == 0;\n+    return (Math.abs(hash(timestamp, inputRow)) - getPartitionNum()) % getPartitions() == 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MTkzODM1", "url": "https://github.com/apache/druid/pull/9810#pullrequestreview-457193835", "createdAt": "2020-07-29T04:56:19Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwNDo1NjoxOVrOG4okJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwNTowMzo0N1rOG4or3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAzODA1Mw==", "bodyText": "Hmm, did you mean queryGranularity instead of timestamp? Druid does store timestamp, but it's not possible to get the query granularity after ingestion.", "url": "https://github.com/apache/druid/pull/9810#discussion_r462038053", "createdAt": "2020-07-29T04:56:19Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/timeline/partition/HashBasedNumberedShardSpec.java", "diffHunk": "@@ -192,4 +229,71 @@ public String toString()\n            \", partitionDimensions=\" + partitionDimensions +\n            '}';\n   }\n+\n+  @Override\n+  public boolean possibleInDomain(Map<String, RangeSet<String>> domain)\n+  {\n+    // If no partitionDimensions are specified during ingestion, hash is based on all dimensions plus the truncated\n+    // input timestamp according to QueryGranularity instead of just partitionDimensions. Since we don't store the\n+    // timestamp after ingestion, bypass this case", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA0MDAyOQ==", "bodyText": "Can we extract Math.abs(hash % numBuckets) == bucketId % numBuckets as a common method so that we can avoid a mistake that you have fixed in the future?", "url": "https://github.com/apache/druid/pull/9810#discussion_r462040029", "createdAt": "2020-07-29T05:03:47Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/timeline/partition/HashBasedNumberedShardSpec.java", "diffHunk": "@@ -90,10 +98,39 @@ public int getNumBuckets()\n     return partitionDimensions;\n   }\n \n+  @Override\n+  public List<String> getDomainDimensions()\n+  {\n+    return partitionDimensions;\n+  }\n+\n   @Override\n   public boolean isInChunk(long timestamp, InputRow inputRow)\n   {\n-    return (((long) hash(timestamp, inputRow)) - bucketId) % numBuckets == 0;\n+    return Math.abs(hash(timestamp, inputRow) % numBuckets) == bucketId % numBuckets;\n+  }\n+\n+  /**\n+   * Check if the current segment possibly holds records if the values of dimensions in {@link #partitionDimensions}\n+   * are of {@code partitionDimensionsValues}\n+   *\n+   * @param partitionDimensionsValues An instance of values of dimensions in {@link #partitionDimensions}\n+   *\n+   * @return Whether the current segment possibly holds records for the given values of partition dimensions\n+   */\n+  private boolean isInChunk(Map<String, String> partitionDimensionsValues)\n+  {\n+    assert !partitionDimensions.isEmpty();\n+    List<Object> groupKey = Lists.transform(\n+        partitionDimensions,\n+        o -> Collections.singletonList(partitionDimensionsValues.get(o))\n+    );\n+    try {\n+      return Math.abs(hash(jsonMapper, groupKey) % numBuckets) == bucketId % numBuckets;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 58}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6928b6368d48791f2670ddeedd69d08003e9e28c", "author": {"user": {"login": "wjhypo", "name": "Jian Wang"}}, "url": "https://github.com/apache/druid/commit/6928b6368d48791f2670ddeedd69d08003e9e28c", "committedDate": "2020-07-29T19:50:47Z", "message": "Add segment pruning for hash based partitioning"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d4b76f1072a8175bdfb28d9007c32dfc8370c86", "author": {"user": {"login": "wjhypo", "name": "Jian Wang"}}, "url": "https://github.com/apache/druid/commit/9d4b76f1072a8175bdfb28d9007c32dfc8370c86", "committedDate": "2020-07-29T19:50:47Z", "message": "Update doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1743ff0364074e676ec4713b15c27fce9230d8f", "author": {"user": null}, "url": "https://github.com/apache/druid/commit/d1743ff0364074e676ec4713b15c27fce9230d8f", "committedDate": "2020-07-29T19:50:47Z", "message": "Add additional test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df48ebba967a1f2324fb62f7b08deab6f70c9acd", "author": {"user": null}, "url": "https://github.com/apache/druid/commit/df48ebba967a1f2324fb62f7b08deab6f70c9acd", "committedDate": "2020-07-29T19:50:47Z", "message": "Address comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "df48ebba967a1f2324fb62f7b08deab6f70c9acd", "author": {"user": null}, "url": "https://github.com/apache/druid/commit/df48ebba967a1f2324fb62f7b08deab6f70c9acd", "committedDate": "2020-07-29T19:50:47Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3OTA3NDg5", "url": "https://github.com/apache/druid/pull/9810#pullrequestreview-457907489", "createdAt": "2020-07-29T21:22:09Z", "commit": {"oid": "df48ebba967a1f2324fb62f7b08deab6f70c9acd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMToyMjowOVrOG5KrsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMToyMjowOVrOG5KrsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NzA0MA==", "bodyText": "You can fix the ci failure by adding .randomQueryId() here.", "url": "https://github.com/apache/druid/pull/9810#discussion_r462597040", "createdAt": "2020-07-29T21:22:09Z", "author": {"login": "jihoonson"}, "path": "server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java", "diffHunk": "@@ -1541,6 +1543,135 @@ public void testSingleDimensionPruning()\n     Assert.assertEquals(expected, ((TimeseriesQuery) capture.getValue().getQuery()).getQuerySegmentSpec());\n   }\n \n+  @Test\n+  public void testHashBasedPruning()\n+  {\n+    DimFilter filter = new AndDimFilter(\n+        new SelectorDimFilter(\"dim1\", \"a\", null),\n+        new BoundDimFilter(\"dim2\", \"e\", \"zzz\", true, true, false, null, StringComparators.LEXICOGRAPHIC),\n+        // Equivalent filter of dim3 below is InDimFilter(\"dim3\", Arrays.asList(\"c\"), null)\n+        new AndDimFilter(\n+            new InDimFilter(\"dim3\", Arrays.asList(\"a\", \"c\", \"e\", \"g\"), null),\n+            new BoundDimFilter(\"dim3\", \"aaa\", \"ddd\", false, false, false, null, StringComparators.LEXICOGRAPHIC)\n+        )\n+    );\n+\n+    final Druids.TimeseriesQueryBuilder builder = Druids.newTimeseriesQueryBuilder()\n+                                                        .dataSource(DATA_SOURCE)\n+                                                        .filters(filter)\n+                                                        .granularity(GRANULARITY)\n+                                                        .intervals(SEG_SPEC)\n+                                                        .context(CONTEXT)\n+                                                        .intervals(\"2011-01-05/2011-01-10\")\n+                                                        .aggregators(RENAMED_AGGS)\n+                                                        .postAggregators(RENAMED_POST_AGGS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df48ebba967a1f2324fb62f7b08deab6f70c9acd"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5384f981f9a7bd66a122d5570e3bd4f83aed8ce5", "author": {"user": null}, "url": "https://github.com/apache/druid/commit/5384f981f9a7bd66a122d5570e3bd4f83aed8ce5", "committedDate": "2020-07-29T21:56:10Z", "message": "Fix unit test failure"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4MDEyNDc4", "url": "https://github.com/apache/druid/pull/9810#pullrequestreview-458012478", "createdAt": "2020-07-30T01:32:45Z", "commit": {"oid": "5384f981f9a7bd66a122d5570e3bd4f83aed8ce5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2277, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}