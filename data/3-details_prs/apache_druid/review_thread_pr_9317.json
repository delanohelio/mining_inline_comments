{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxNjM1MTk1", "number": 9317, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzowNjo1NlrODeLT-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDowOTo1N1rODfHiNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTY5MjA5OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzowNjo1NlrOFnM1rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMDoyMTo1OVrOFod7BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0OTEzNQ==", "bodyText": "I think from like a .. user satisfaction perspective, it might still be nice to prefer non-null values since it is still legitimate.", "url": "https://github.com/apache/druid/pull/9317#discussion_r376649135", "createdAt": "2020-02-07T23:06:56Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -19,103 +19,214 @@\n \n package org.apache.druid.query.aggregation.any;\n \n-import com.fasterxml.jackson.annotation.JacksonInject;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-import org.apache.druid.math.expr.ExprMacroTable;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.UOE;\n+import org.apache.druid.query.aggregation.AggregateCombiner;\n import org.apache.druid.query.aggregation.Aggregator;\n import org.apache.druid.query.aggregation.AggregatorFactory;\n import org.apache.druid.query.aggregation.AggregatorUtil;\n import org.apache.druid.query.aggregation.BufferAggregator;\n-import org.apache.druid.query.aggregation.SimpleDoubleAggregatorFactory;\n+import org.apache.druid.query.aggregation.DoubleSumAggregator;\n import org.apache.druid.query.cache.CacheKeyBuilder;\n import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.NilColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n \n import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n import java.util.Collections;\n+import java.util.Comparator;\n import java.util.List;\n+import java.util.Objects;\n \n-public class DoubleAnyAggregatorFactory extends SimpleDoubleAggregatorFactory\n+public class DoubleAnyAggregatorFactory extends AggregatorFactory\n {\n+  private static final Comparator<Double> VALUE_COMPARATOR = Comparator.nullsFirst(Double::compare);\n+\n+  private static final Aggregator NIL_AGGREGATOR = new DoubleAnyAggregator(\n+      NilColumnValueSelector.instance()\n+  )\n+  {\n+    @Override\n+    public void aggregate()\n+    {\n+      // no-op\n+    }\n+  };\n+\n+  private static final BufferAggregator NIL_BUFFER_AGGREGATOR = new DoubleAnyBufferAggregator(\n+      NilColumnValueSelector.instance()\n+  )\n+  {\n+    @Override\n+    public void aggregate(ByteBuffer buf, int position)\n+    {\n+      // no-op\n+    }\n+  };\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n   @JsonCreator\n   public DoubleAnyAggregatorFactory(\n       @JsonProperty(\"name\") String name,\n-      @JsonProperty(\"fieldName\") final String fieldName,\n-      @JsonProperty(\"expression\") @Nullable String expression,\n-      @JacksonInject ExprMacroTable macroTable\n+      @JsonProperty(\"fieldName\") final String fieldName\n   )\n   {\n-    super(macroTable, name, fieldName, expression);\n-  }\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n \n-  public DoubleAnyAggregatorFactory(String name, String fieldName)\n-  {\n-    this(name, fieldName, null, ExprMacroTable.nil());\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n   }\n \n   @Override\n-  protected double nullValue()\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n   {\n-    return Double.NaN;\n+    final BaseDoubleColumnValueSelector valueSelector = metricFactory.makeColumnValueSelector(fieldName);\n+    if (valueSelector instanceof NilColumnValueSelector) {\n+      return NIL_AGGREGATOR;\n+    } else {\n+      return new DoubleAnyAggregator(\n+          valueSelector\n+      );\n+    }\n   }\n \n   @Override\n-  protected Aggregator buildAggregator(BaseDoubleColumnValueSelector selector)\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n   {\n-    return new DoubleAnyAggregator(selector);\n+    final BaseDoubleColumnValueSelector valueSelector = metricFactory.makeColumnValueSelector(fieldName);\n+    if (valueSelector instanceof NilColumnValueSelector) {\n+      return NIL_BUFFER_AGGREGATOR;\n+    } else {\n+      return new DoubleAnyBufferAggregator(\n+          valueSelector\n+      );\n+    }\n   }\n \n   @Override\n-  protected BufferAggregator buildBufferAggregator(BaseDoubleColumnValueSelector selector)\n+  public Comparator getComparator()\n   {\n-    return new DoubleAnyBufferAggregator(selector);\n+    return VALUE_COMPARATOR;\n   }\n \n   @Override\n   @Nullable\n   public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n   {\n-    if (lhs != null) {\n-      return lhs;\n-    } else {\n-      return rhs;\n-    }\n+    return lhs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk3NzYwNA==", "bodyText": "to be consistent with the new policy of not discriminating null values #equality\nDecided not to make assumption in preferring non-null value.", "url": "https://github.com/apache/druid/pull/9317#discussion_r377977604", "createdAt": "2020-02-12T00:21:59Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -19,103 +19,214 @@\n \n package org.apache.druid.query.aggregation.any;\n \n-import com.fasterxml.jackson.annotation.JacksonInject;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-import org.apache.druid.math.expr.ExprMacroTable;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.UOE;\n+import org.apache.druid.query.aggregation.AggregateCombiner;\n import org.apache.druid.query.aggregation.Aggregator;\n import org.apache.druid.query.aggregation.AggregatorFactory;\n import org.apache.druid.query.aggregation.AggregatorUtil;\n import org.apache.druid.query.aggregation.BufferAggregator;\n-import org.apache.druid.query.aggregation.SimpleDoubleAggregatorFactory;\n+import org.apache.druid.query.aggregation.DoubleSumAggregator;\n import org.apache.druid.query.cache.CacheKeyBuilder;\n import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.NilColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n \n import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n import java.util.Collections;\n+import java.util.Comparator;\n import java.util.List;\n+import java.util.Objects;\n \n-public class DoubleAnyAggregatorFactory extends SimpleDoubleAggregatorFactory\n+public class DoubleAnyAggregatorFactory extends AggregatorFactory\n {\n+  private static final Comparator<Double> VALUE_COMPARATOR = Comparator.nullsFirst(Double::compare);\n+\n+  private static final Aggregator NIL_AGGREGATOR = new DoubleAnyAggregator(\n+      NilColumnValueSelector.instance()\n+  )\n+  {\n+    @Override\n+    public void aggregate()\n+    {\n+      // no-op\n+    }\n+  };\n+\n+  private static final BufferAggregator NIL_BUFFER_AGGREGATOR = new DoubleAnyBufferAggregator(\n+      NilColumnValueSelector.instance()\n+  )\n+  {\n+    @Override\n+    public void aggregate(ByteBuffer buf, int position)\n+    {\n+      // no-op\n+    }\n+  };\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n   @JsonCreator\n   public DoubleAnyAggregatorFactory(\n       @JsonProperty(\"name\") String name,\n-      @JsonProperty(\"fieldName\") final String fieldName,\n-      @JsonProperty(\"expression\") @Nullable String expression,\n-      @JacksonInject ExprMacroTable macroTable\n+      @JsonProperty(\"fieldName\") final String fieldName\n   )\n   {\n-    super(macroTable, name, fieldName, expression);\n-  }\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n \n-  public DoubleAnyAggregatorFactory(String name, String fieldName)\n-  {\n-    this(name, fieldName, null, ExprMacroTable.nil());\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n   }\n \n   @Override\n-  protected double nullValue()\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n   {\n-    return Double.NaN;\n+    final BaseDoubleColumnValueSelector valueSelector = metricFactory.makeColumnValueSelector(fieldName);\n+    if (valueSelector instanceof NilColumnValueSelector) {\n+      return NIL_AGGREGATOR;\n+    } else {\n+      return new DoubleAnyAggregator(\n+          valueSelector\n+      );\n+    }\n   }\n \n   @Override\n-  protected Aggregator buildAggregator(BaseDoubleColumnValueSelector selector)\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n   {\n-    return new DoubleAnyAggregator(selector);\n+    final BaseDoubleColumnValueSelector valueSelector = metricFactory.makeColumnValueSelector(fieldName);\n+    if (valueSelector instanceof NilColumnValueSelector) {\n+      return NIL_BUFFER_AGGREGATOR;\n+    } else {\n+      return new DoubleAnyBufferAggregator(\n+          valueSelector\n+      );\n+    }\n   }\n \n   @Override\n-  protected BufferAggregator buildBufferAggregator(BaseDoubleColumnValueSelector selector)\n+  public Comparator getComparator()\n   {\n-    return new DoubleAnyBufferAggregator(selector);\n+    return VALUE_COMPARATOR;\n   }\n \n   @Override\n   @Nullable\n   public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n   {\n-    if (lhs != null) {\n-      return lhs;\n-    } else {\n-      return rhs;\n-    }\n+    return lhs;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0OTEzNQ=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTcxODA1OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzoyMzoxOFrOFnNFuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMTozMzozNlrOFofGGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1MzI0MA==", "bodyText": "this comment seems not applicable since it is a primitive", "url": "https://github.com/apache/druid/pull/9317#discussion_r376653240", "createdAt": "2020-02-07T23:23:18Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -19,103 +19,214 @@\n \n package org.apache.druid.query.aggregation.any;\n \n-import com.fasterxml.jackson.annotation.JacksonInject;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-import org.apache.druid.math.expr.ExprMacroTable;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.UOE;\n+import org.apache.druid.query.aggregation.AggregateCombiner;\n import org.apache.druid.query.aggregation.Aggregator;\n import org.apache.druid.query.aggregation.AggregatorFactory;\n import org.apache.druid.query.aggregation.AggregatorUtil;\n import org.apache.druid.query.aggregation.BufferAggregator;\n-import org.apache.druid.query.aggregation.SimpleDoubleAggregatorFactory;\n+import org.apache.druid.query.aggregation.DoubleSumAggregator;\n import org.apache.druid.query.cache.CacheKeyBuilder;\n import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.NilColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n \n import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n import java.util.Collections;\n+import java.util.Comparator;\n import java.util.List;\n+import java.util.Objects;\n \n-public class DoubleAnyAggregatorFactory extends SimpleDoubleAggregatorFactory\n+public class DoubleAnyAggregatorFactory extends AggregatorFactory\n {\n+  private static final Comparator<Double> VALUE_COMPARATOR = Comparator.nullsFirst(Double::compare);\n+\n+  private static final Aggregator NIL_AGGREGATOR = new DoubleAnyAggregator(\n+      NilColumnValueSelector.instance()\n+  )\n+  {\n+    @Override\n+    public void aggregate()\n+    {\n+      // no-op\n+    }\n+  };\n+\n+  private static final BufferAggregator NIL_BUFFER_AGGREGATOR = new DoubleAnyBufferAggregator(\n+      NilColumnValueSelector.instance()\n+  )\n+  {\n+    @Override\n+    public void aggregate(ByteBuffer buf, int position)\n+    {\n+      // no-op\n+    }\n+  };\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n   @JsonCreator\n   public DoubleAnyAggregatorFactory(\n       @JsonProperty(\"name\") String name,\n-      @JsonProperty(\"fieldName\") final String fieldName,\n-      @JsonProperty(\"expression\") @Nullable String expression,\n-      @JacksonInject ExprMacroTable macroTable\n+      @JsonProperty(\"fieldName\") final String fieldName\n   )\n   {\n-    super(macroTable, name, fieldName, expression);\n-  }\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n \n-  public DoubleAnyAggregatorFactory(String name, String fieldName)\n-  {\n-    this(name, fieldName, null, ExprMacroTable.nil());\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n   }\n \n   @Override\n-  protected double nullValue()\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n   {\n-    return Double.NaN;\n+    final BaseDoubleColumnValueSelector valueSelector = metricFactory.makeColumnValueSelector(fieldName);\n+    if (valueSelector instanceof NilColumnValueSelector) {\n+      return NIL_AGGREGATOR;\n+    } else {\n+      return new DoubleAnyAggregator(\n+          valueSelector\n+      );\n+    }\n   }\n \n   @Override\n-  protected Aggregator buildAggregator(BaseDoubleColumnValueSelector selector)\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n   {\n-    return new DoubleAnyAggregator(selector);\n+    final BaseDoubleColumnValueSelector valueSelector = metricFactory.makeColumnValueSelector(fieldName);\n+    if (valueSelector instanceof NilColumnValueSelector) {\n+      return NIL_BUFFER_AGGREGATOR;\n+    } else {\n+      return new DoubleAnyBufferAggregator(\n+          valueSelector\n+      );\n+    }\n   }\n \n   @Override\n-  protected BufferAggregator buildBufferAggregator(BaseDoubleColumnValueSelector selector)\n+  public Comparator getComparator()\n   {\n-    return new DoubleAnyBufferAggregator(selector);\n+    return VALUE_COMPARATOR;\n   }\n \n   @Override\n   @Nullable\n   public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n   {\n-    if (lhs != null) {\n-      return lhs;\n-    } else {\n-      return rhs;\n-    }\n+    return lhs;\n+  }\n+\n+  @Override\n+  public AggregateCombiner makeAggregateCombiner()\n+  {\n+    throw new UOE(\"DoubleAnyAggregatorFactory is not supported during ingestion for rollup\");\n   }\n \n   @Override\n   public AggregatorFactory getCombiningFactory()\n   {\n-    return new DoubleAnyAggregatorFactory(name, name, null, macroTable);\n+    return new DoubleAnyAggregatorFactory(name, name);\n   }\n \n   @Override\n   public List<AggregatorFactory> getRequiredColumns()\n   {\n-    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName, expression, macroTable));\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    // handle \"NaN\" / \"Infinity\" values serialized as strings in JSON\n+    if (object instanceof String) {\n+      return Double.parseDouble((String) object);\n+    }\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Collections.singletonList(fieldName);\n   }\n \n   @Override\n   public byte[] getCacheKey()\n   {\n     return new CacheKeyBuilder(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n         .appendString(fieldName)\n-        .appendString(expression)\n         .build();\n   }\n \n+  @Override\n+  public String getTypeName()\n+  {\n+    // if we don't pretend to be a primitive, group by v1 gets sad and doesn't work because no complex type serde", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5NjgyNg==", "bodyText": "removed.", "url": "https://github.com/apache/druid/pull/9317#discussion_r377996826", "createdAt": "2020-02-12T01:33:36Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -19,103 +19,214 @@\n \n package org.apache.druid.query.aggregation.any;\n \n-import com.fasterxml.jackson.annotation.JacksonInject;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-import org.apache.druid.math.expr.ExprMacroTable;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.UOE;\n+import org.apache.druid.query.aggregation.AggregateCombiner;\n import org.apache.druid.query.aggregation.Aggregator;\n import org.apache.druid.query.aggregation.AggregatorFactory;\n import org.apache.druid.query.aggregation.AggregatorUtil;\n import org.apache.druid.query.aggregation.BufferAggregator;\n-import org.apache.druid.query.aggregation.SimpleDoubleAggregatorFactory;\n+import org.apache.druid.query.aggregation.DoubleSumAggregator;\n import org.apache.druid.query.cache.CacheKeyBuilder;\n import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.NilColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n \n import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n import java.util.Collections;\n+import java.util.Comparator;\n import java.util.List;\n+import java.util.Objects;\n \n-public class DoubleAnyAggregatorFactory extends SimpleDoubleAggregatorFactory\n+public class DoubleAnyAggregatorFactory extends AggregatorFactory\n {\n+  private static final Comparator<Double> VALUE_COMPARATOR = Comparator.nullsFirst(Double::compare);\n+\n+  private static final Aggregator NIL_AGGREGATOR = new DoubleAnyAggregator(\n+      NilColumnValueSelector.instance()\n+  )\n+  {\n+    @Override\n+    public void aggregate()\n+    {\n+      // no-op\n+    }\n+  };\n+\n+  private static final BufferAggregator NIL_BUFFER_AGGREGATOR = new DoubleAnyBufferAggregator(\n+      NilColumnValueSelector.instance()\n+  )\n+  {\n+    @Override\n+    public void aggregate(ByteBuffer buf, int position)\n+    {\n+      // no-op\n+    }\n+  };\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n   @JsonCreator\n   public DoubleAnyAggregatorFactory(\n       @JsonProperty(\"name\") String name,\n-      @JsonProperty(\"fieldName\") final String fieldName,\n-      @JsonProperty(\"expression\") @Nullable String expression,\n-      @JacksonInject ExprMacroTable macroTable\n+      @JsonProperty(\"fieldName\") final String fieldName\n   )\n   {\n-    super(macroTable, name, fieldName, expression);\n-  }\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n \n-  public DoubleAnyAggregatorFactory(String name, String fieldName)\n-  {\n-    this(name, fieldName, null, ExprMacroTable.nil());\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n   }\n \n   @Override\n-  protected double nullValue()\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n   {\n-    return Double.NaN;\n+    final BaseDoubleColumnValueSelector valueSelector = metricFactory.makeColumnValueSelector(fieldName);\n+    if (valueSelector instanceof NilColumnValueSelector) {\n+      return NIL_AGGREGATOR;\n+    } else {\n+      return new DoubleAnyAggregator(\n+          valueSelector\n+      );\n+    }\n   }\n \n   @Override\n-  protected Aggregator buildAggregator(BaseDoubleColumnValueSelector selector)\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n   {\n-    return new DoubleAnyAggregator(selector);\n+    final BaseDoubleColumnValueSelector valueSelector = metricFactory.makeColumnValueSelector(fieldName);\n+    if (valueSelector instanceof NilColumnValueSelector) {\n+      return NIL_BUFFER_AGGREGATOR;\n+    } else {\n+      return new DoubleAnyBufferAggregator(\n+          valueSelector\n+      );\n+    }\n   }\n \n   @Override\n-  protected BufferAggregator buildBufferAggregator(BaseDoubleColumnValueSelector selector)\n+  public Comparator getComparator()\n   {\n-    return new DoubleAnyBufferAggregator(selector);\n+    return VALUE_COMPARATOR;\n   }\n \n   @Override\n   @Nullable\n   public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n   {\n-    if (lhs != null) {\n-      return lhs;\n-    } else {\n-      return rhs;\n-    }\n+    return lhs;\n+  }\n+\n+  @Override\n+  public AggregateCombiner makeAggregateCombiner()\n+  {\n+    throw new UOE(\"DoubleAnyAggregatorFactory is not supported during ingestion for rollup\");\n   }\n \n   @Override\n   public AggregatorFactory getCombiningFactory()\n   {\n-    return new DoubleAnyAggregatorFactory(name, name, null, macroTable);\n+    return new DoubleAnyAggregatorFactory(name, name);\n   }\n \n   @Override\n   public List<AggregatorFactory> getRequiredColumns()\n   {\n-    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName, expression, macroTable));\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    // handle \"NaN\" / \"Infinity\" values serialized as strings in JSON\n+    if (object instanceof String) {\n+      return Double.parseDouble((String) object);\n+    }\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Collections.singletonList(fieldName);\n   }\n \n   @Override\n   public byte[] getCacheKey()\n   {\n     return new CacheKeyBuilder(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n         .appendString(fieldName)\n-        .appendString(expression)\n         .build();\n   }\n \n+  @Override\n+  public String getTypeName()\n+  {\n+    // if we don't pretend to be a primitive, group by v1 gets sad and doesn't work because no complex type serde", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1MzI0MA=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzE0MTY2OnYy", "diffSide": "RIGHT", "path": "docs/querying/aggregations.md", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzowNzo1OVrOFoRdzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMzo0Mjo0MFrOFodLbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3MzUxNw==", "bodyText": "I think we should re-write this to explain why someone would use this aggregator similar to how it's explained in the snowflake docs - https://docs.snowflake.net/manuals/sql-reference/functions/any_value.html\nI'm not sure where the correct place in the docs is to explain this - since technically this is the spec for the native query and we have another page with a spec for sql.\nHere's my suggestion for the why:\nANY aggregator can be used to simplify and optimize the performance of GROUP BY statements. A common problem for many queries is that the result of a query with a GROUP BY clause can only contain expressions used in the GROUP BY clause itself, or results of aggregate functions\n\nselect customer.id , customer.name , sum(orders.value)\n    from customer\n    join orders on customer.id = orders.customer_id\n    group by customer.id , customer.name;\n\nSince we know that each customer.id can have only one name, this can be optimized as\n\nselect customer.id , ANY(customer.name) , sum(orders.value)\n    from customer\n    join orders on customer.id = orders.customer_id\n    group by customer.id ;\n\nI should also point out, with the current implementation of aggregators, there is no advantage to using an ANY aggregator vs a min aggregator, but maybe that will change in the future \ud83e\udd37\u200d\u2642", "url": "https://github.com/apache/druid/pull/9317#discussion_r377773517", "createdAt": "2020-02-11T17:07:59Z", "author": {"login": "suneet-s"}, "path": "docs/querying/aggregations.md", "diffHunk": "@@ -238,7 +238,7 @@ Note that queries with first/last aggregators on a segment created with rollup e\n \n (Double/Float/Long/String) ANY aggregator cannot be used in ingestion spec, and should only be specified as part of queries.\n \n-If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any non-null value.\n+If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any value including null.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzY2NA==", "bodyText": "Suggested re-wording to explain how null handling works\nThis aggregator will return any value for the provided expression. It does not prefer non-null values over null values. If `druid.generic.useDefaultValueForNull` is set to true, this will not return null, but instead return the default value. Otherwise this aggregator may return null", "url": "https://github.com/apache/druid/pull/9317#discussion_r377777664", "createdAt": "2020-02-11T17:14:58Z", "author": {"login": "suneet-s"}, "path": "docs/querying/aggregations.md", "diffHunk": "@@ -238,7 +238,7 @@ Note that queries with first/last aggregators on a segment created with rollup e\n \n (Double/Float/Long/String) ANY aggregator cannot be used in ingestion spec, and should only be specified as part of queries.\n \n-If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any non-null value.\n+If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any value including null.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3MzUxNw=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgwMjQ2MQ==", "bodyText": "EDIT: @maytasm3 pointed out this benchmark - https://static.imply.io/gianm/vb.html which shows the performance gain of not having to read a value. Since ANY only reads the first value, this will be faster than min, even thought the aggregator has to loop over all values.\nI should have known that... \ud83e\udd26\u200d\u2642", "url": "https://github.com/apache/druid/pull/9317#discussion_r377802461", "createdAt": "2020-02-11T18:00:14Z", "author": {"login": "suneet-s"}, "path": "docs/querying/aggregations.md", "diffHunk": "@@ -238,7 +238,7 @@ Note that queries with first/last aggregators on a segment created with rollup e\n \n (Double/Float/Long/String) ANY aggregator cannot be used in ingestion spec, and should only be specified as part of queries.\n \n-If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any non-null value.\n+If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any value including null.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3MzUxNw=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMzk1OQ==", "bodyText": "+1 to Suneet's rewording. Agreed as well that we should add the \"why\".", "url": "https://github.com/apache/druid/pull/9317#discussion_r377813959", "createdAt": "2020-02-11T18:22:42Z", "author": {"login": "sthetland"}, "path": "docs/querying/aggregations.md", "diffHunk": "@@ -238,7 +238,7 @@ Note that queries with first/last aggregators on a segment created with rollup e\n \n (Double/Float/Long/String) ANY aggregator cannot be used in ingestion spec, and should only be specified as part of queries.\n \n-If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any non-null value.\n+If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any value including null.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3MzUxNw=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2NTQyMQ==", "bodyText": "Added the why (short version of what Suneet wrote)", "url": "https://github.com/apache/druid/pull/9317#discussion_r377965421", "createdAt": "2020-02-11T23:42:40Z", "author": {"login": "maytasm"}, "path": "docs/querying/aggregations.md", "diffHunk": "@@ -238,7 +238,7 @@ Note that queries with first/last aggregators on a segment created with rollup e\n \n (Double/Float/Long/String) ANY aggregator cannot be used in ingestion spec, and should only be specified as part of queries.\n \n-If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any non-null value.\n+If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any value including null.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3MzUxNw=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNzM5ODAzOnYy", "diffSide": "RIGHT", "path": "docs/querying/sql.md", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMzo1OVrOFoT-lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMDowMDo1NFrOFodjeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxNDY3Nw==", "bodyText": "nit, adding a comma: \"If druid.generic.useDefaultValueForNull=true, this can return...\"", "url": "https://github.com/apache/druid/pull/9317#discussion_r377814677", "createdAt": "2020-02-11T18:23:59Z", "author": {"login": "sthetland"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -205,7 +205,7 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n-|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can return the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will return any non-null value of `expr`|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can return the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will return any value of `expr` including null|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyOTg5Ng==", "bodyText": "I sort of think this should just be simplified so it is less confusing, maybe something like:\n\nReturns any value of expr, including null.\n\nAlso, expr does not need to be numeric since you implemented a string any aggregator in the previous PR.", "url": "https://github.com/apache/druid/pull/9317#discussion_r377929896", "createdAt": "2020-02-11T22:10:11Z", "author": {"login": "clintropolis"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -205,7 +205,7 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n-|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can return the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will return any non-null value of `expr`|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can return the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will return any value of `expr` including null|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxNDY3Nw=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk3MTU3Nw==", "bodyText": "simplified as suggested.\nexpr needs to be null for ANY_VALUE(expr)\nString column have to be ANY_VALUE(expr, maxBytesPerString)", "url": "https://github.com/apache/druid/pull/9317#discussion_r377971577", "createdAt": "2020-02-12T00:00:54Z", "author": {"login": "maytasm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -205,7 +205,7 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n-|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can return the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will return any non-null value of `expr`|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can return the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will return any value of `expr` including null|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxNDY3Nw=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODEyMDg4OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoxMzo1NVrOFobG5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMTozNTozN1rOFofH4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMTQ5Mg==", "bodyText": "I'm not sure this is really worth mentioning. This is the standard case for aggregator implementations, since it is less common for an agg implementation to have magic null handling wrapped around it than just handling the nulls itself.", "url": "https://github.com/apache/druid/pull/9317#discussion_r377931492", "createdAt": "2020-02-11T22:13:55Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -19,44 +19,35 @@\n \n package org.apache.druid.query.aggregation.any;\n \n-import org.apache.druid.query.aggregation.Aggregator;\n-import org.apache.druid.query.aggregation.NullableNumericAggregator;\n-import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which extends from\n- * {@link NullableNumericAggregatorFactory}. If null needs to be handle, then {@link NullableNumericAggregatorFactory}\n- * will wrap this aggregator in {@link NullableNumericAggregator} and can handle all null in that class.\n- * Hence, no null will ever be pass into this aggregator from the valueSelector.\n+ * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which has no special null handling logic.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk5NzI4Mg==", "bodyText": "Removed", "url": "https://github.com/apache/druid/pull/9317#discussion_r377997282", "createdAt": "2020-02-12T01:35:37Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -19,44 +19,35 @@\n \n package org.apache.druid.query.aggregation.any;\n \n-import org.apache.druid.query.aggregation.Aggregator;\n-import org.apache.druid.query.aggregation.NullableNumericAggregator;\n-import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which extends from\n- * {@link NullableNumericAggregatorFactory}. If null needs to be handle, then {@link NullableNumericAggregatorFactory}\n- * will wrap this aggregator in {@link NullableNumericAggregator} and can handle all null in that class.\n- * Hence, no null will ever be pass into this aggregator from the valueSelector.\n+ * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which has no special null handling logic.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMTQ5Mg=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODEzNzgxOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoxOTo1NVrOFobQ-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMTo1Nzo1MFrOFofdig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNDA3NQ==", "bodyText": "nit: I think this 0 offset variable makes the put and get operations more complicated than they need to be, suggest just dropping this and not adding or removing anything.", "url": "https://github.com/apache/druid/pull/9317#discussion_r377934075", "createdAt": "2020-02-11T22:19:55Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseNullableColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Base type for buffer based 'any' aggregator for primitive numeric column selectors\n+ */\n+public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n+    implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final int IS_FOUND_FLAG_OFFSET_POSITION = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0NDAwNw==", "bodyText": "Further, since is null is only going to be either 0 or 1, you save a byte per agg result and could use any of the high bits of this null byte to set whether or not you have found a value. Instead of an offset for null flag, you define a bit mask and your found check becomes something like buf.get(position) & FOUND_MASK == FOUND_MASK or whatever.", "url": "https://github.com/apache/druid/pull/9317#discussion_r377944007", "createdAt": "2020-02-11T22:43:00Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseNullableColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Base type for buffer based 'any' aggregator for primitive numeric column selectors\n+ */\n+public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n+    implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final int IS_FOUND_FLAG_OFFSET_POSITION = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNDA3NQ=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAwMjgyNg==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/9317#discussion_r378002826", "createdAt": "2020-02-12T01:57:50Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseNullableColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Base type for buffer based 'any' aggregator for primitive numeric column selectors\n+ */\n+public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n+    implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final int IS_FOUND_FLAG_OFFSET_POSITION = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNDA3NQ=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODE0NDA5OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoyMjowMFrOFobUwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMTo1Nzo1NlrOFofdrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNTA0MA==", "bodyText": "Please use NullHandling.IS_NULL_BYTE and NullHandling.IS_NOT_NULL_BYTE to be consistent with other aggregators, at least for the 'is null' byte.", "url": "https://github.com/apache/druid/pull/9317#discussion_r377935040", "createdAt": "2020-02-11T22:22:00Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseNullableColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Base type for buffer based 'any' aggregator for primitive numeric column selectors\n+ */\n+public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n+    implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAwMjg2Mg==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/9317#discussion_r378002862", "createdAt": "2020-02-12T01:57:56Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseNullableColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Base type for buffer based 'any' aggregator for primitive numeric column selectors\n+ */\n+public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n+    implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNTA0MA=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODE2NDQ2OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjoyOToyMFrOFobhLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMTo1ODozM1rOFofePw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzODIyMA==", "bodyText": "nit: suggest just making this package private and having subclasses use this directly in their putValue implementations instead of getFoundValueStoredPosition function call, and maybe just calling it VALUE_OFFSET or FOUND_VALUE_OFFSET since the position seems redundant.", "url": "https://github.com/apache/druid/pull/9317#discussion_r377938220", "createdAt": "2020-02-11T22:29:20Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseNullableColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Base type for buffer based 'any' aggregator for primitive numeric column selectors\n+ */\n+public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n+    implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final int IS_FOUND_FLAG_OFFSET_POSITION = 0;\n+  private static final int IS_NULL_FLAG_OFFSET_POSITION = IS_FOUND_FLAG_OFFSET_POSITION + Byte.BYTES;\n+  private static final int FOUND_VALUE_OFFSET_POSITION = IS_NULL_FLAG_OFFSET_POSITION + Byte.BYTES;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAwMzAwNw==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/9317#discussion_r378003007", "createdAt": "2020-02-12T01:58:33Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseNullableColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Base type for buffer based 'any' aggregator for primitive numeric column selectors\n+ */\n+public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n+    implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final int IS_FOUND_FLAG_OFFSET_POSITION = 0;\n+  private static final int IS_NULL_FLAG_OFFSET_POSITION = IS_FOUND_FLAG_OFFSET_POSITION + Byte.BYTES;\n+  private static final int FOUND_VALUE_OFFSET_POSITION = IS_NULL_FLAG_OFFSET_POSITION + Byte.BYTES;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzODIyMA=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODE4OTc5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/druid/server/QueryLifecycle.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjozODozMVrOFobwYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMjowNjo1NFrOFofmbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0MjExNQ==", "bodyText": "Why this change? I don't think it is correct, since this stuff should only be set if it was a QueryInterruptedException", "url": "https://github.com/apache/druid/pull/9317#discussion_r377942115", "createdAt": "2020-02-11T22:38:31Z", "author": {"login": "clintropolis"}, "path": "server/src/main/java/org/apache/druid/server/QueryLifecycle.java", "diffHunk": "@@ -318,14 +318,12 @@ public void emitLogsAndMetrics(\n \n       if (e != null) {\n         statsMap.put(\"exception\", e.toString());\n-\n-        if (e instanceof QueryInterruptedException) {\n-          // Mimic behavior from QueryResource, where this code was originally taken from.\n-          log.noStackTrace().warn(e, \"Exception while processing queryId [%s]\", baseQuery.getId());\n-          statsMap.put(\"interrupted\", true);\n-          statsMap.put(\"reason\", e.toString());\n-        }\n+        // Mimic behavior from QueryResource, where this code was originally taken from.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAwNDk5OQ==", "bodyText": "Changed to just moving the logging out of the if check", "url": "https://github.com/apache/druid/pull/9317#discussion_r378004999", "createdAt": "2020-02-12T02:06:26Z", "author": {"login": "maytasm"}, "path": "server/src/main/java/org/apache/druid/server/QueryLifecycle.java", "diffHunk": "@@ -318,14 +318,12 @@ public void emitLogsAndMetrics(\n \n       if (e != null) {\n         statsMap.put(\"exception\", e.toString());\n-\n-        if (e instanceof QueryInterruptedException) {\n-          // Mimic behavior from QueryResource, where this code was originally taken from.\n-          log.noStackTrace().warn(e, \"Exception while processing queryId [%s]\", baseQuery.getId());\n-          statsMap.put(\"interrupted\", true);\n-          statsMap.put(\"reason\", e.toString());\n-        }\n+        // Mimic behavior from QueryResource, where this code was originally taken from.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0MjExNQ=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAwNTEwMg==", "bodyText": "The change is so that we can see the exception (and possibly stacktrace) for exceptions other than QueryInterruptedException too", "url": "https://github.com/apache/druid/pull/9317#discussion_r378005102", "createdAt": "2020-02-12T02:06:54Z", "author": {"login": "maytasm"}, "path": "server/src/main/java/org/apache/druid/server/QueryLifecycle.java", "diffHunk": "@@ -318,14 +318,12 @@ public void emitLogsAndMetrics(\n \n       if (e != null) {\n         statsMap.put(\"exception\", e.toString());\n-\n-        if (e instanceof QueryInterruptedException) {\n-          // Mimic behavior from QueryResource, where this code was originally taken from.\n-          log.noStackTrace().warn(e, \"Exception while processing queryId [%s]\", baseQuery.getId());\n-          statsMap.put(\"interrupted\", true);\n-          statsMap.put(\"reason\", e.toString());\n-        }\n+        // Mimic behavior from QueryResource, where this code was originally taken from.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0MjExNQ=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzOTU0MjkzOnYy", "diffSide": "RIGHT", "path": "docs/querying/aggregations.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDowNTowMlrOFoodzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODoxNjo1M1rOFo5W4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1MDM0OA==", "bodyText": "typo 'encoutnered' is causing CI failure", "url": "https://github.com/apache/druid/pull/9317#discussion_r378150348", "createdAt": "2020-02-12T10:05:02Z", "author": {"login": "clintropolis"}, "path": "docs/querying/aggregations.md", "diffHunk": "@@ -238,7 +238,7 @@ Note that queries with first/last aggregators on a segment created with rollup e\n \n (Double/Float/Long/String) ANY aggregator cannot be used in ingestion spec, and should only be specified as part of queries.\n \n-If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any value including null.\n+Returns any value including null. This aggregator simplify and optimize the performance by returning the first encoutnered value (including null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9ef751385492faca5d57fbf05d0c7a71a1ff7e6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQyNzEwNg==", "bodyText": "oops done.", "url": "https://github.com/apache/druid/pull/9317#discussion_r378427106", "createdAt": "2020-02-12T18:16:53Z", "author": {"login": "maytasm"}, "path": "docs/querying/aggregations.md", "diffHunk": "@@ -238,7 +238,7 @@ Note that queries with first/last aggregators on a segment created with rollup e\n \n (Double/Float/Long/String) ANY aggregator cannot be used in ingestion spec, and should only be specified as part of queries.\n \n-If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any value including null.\n+Returns any value including null. This aggregator simplify and optimize the performance by returning the first encoutnered value (including null)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1MDM0OA=="}, "originalCommit": {"oid": "b9ef751385492faca5d57fbf05d0c7a71a1ff7e6"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzOTU0Nzg4OnYy", "diffSide": "RIGHT", "path": "docs/querying/sql.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDowNjoyOFrOFoog3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODoxODozOVrOFo5adA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1MTEzNQ==", "bodyText": "nit: should be 'This aggregator can simplify..'\nShould this note also be added to the description of string any value?", "url": "https://github.com/apache/druid/pull/9317#discussion_r378151135", "createdAt": "2020-02-12T10:06:28Z", "author": {"login": "clintropolis"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -205,7 +205,7 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n-|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can return the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will return any value of `expr` including null|\n+|`ANY_VALUE(expr)`|Returns any value of `expr` including null. `expr` must be numeric. This aggregator simplify and optimize the performance by returning the first encoutnered value (including null)|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9ef751385492faca5d57fbf05d0c7a71a1ff7e6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQyODAyMA==", "bodyText": "Added 'can'. The string any indicates \"Like ANY_VALUE(expr)\" which implies that whatever is mentioned for the ANY_VALUE(expr) also applies to the string any.", "url": "https://github.com/apache/druid/pull/9317#discussion_r378428020", "createdAt": "2020-02-12T18:18:39Z", "author": {"login": "maytasm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -205,7 +205,7 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n-|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can return the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will return any value of `expr` including null|\n+|`ANY_VALUE(expr)`|Returns any value of `expr` including null. `expr` must be numeric. This aggregator simplify and optimize the performance by returning the first encoutnered value (including null)|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1MTEzNQ=="}, "originalCommit": {"oid": "b9ef751385492faca5d57fbf05d0c7a71a1ff7e6"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzOTU1ODk1OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDowOTo1N1rOFoon6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODoxOToyMlrOFo5b7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1MjkzOQ==", "bodyText": "super super nit, but can you use hex? (0x02 and 0x01 for BYTE_FLAG_NULL_MASK)", "url": "https://github.com/apache/druid/pull/9317#discussion_r378152939", "createdAt": "2020-02-12T10:09:57Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -32,11 +32,11 @@\n public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n     implements BufferAggregator\n {\n-  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n-  private static final byte BYTE_FLAG_IS_SET = 1;\n-  private static final int IS_FOUND_FLAG_OFFSET_POSITION = 0;\n-  private static final int IS_NULL_FLAG_OFFSET_POSITION = IS_FOUND_FLAG_OFFSET_POSITION + Byte.BYTES;\n-  private static final int FOUND_VALUE_OFFSET_POSITION = IS_NULL_FLAG_OFFSET_POSITION + Byte.BYTES;\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  private static final byte BYTE_FLAG_FOUND_MASK = 0b0010;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9ef751385492faca5d57fbf05d0c7a71a1ff7e6"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQyODM5OA==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/9317#discussion_r378428398", "createdAt": "2020-02-12T18:19:22Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -32,11 +32,11 @@\n public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n     implements BufferAggregator\n {\n-  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n-  private static final byte BYTE_FLAG_IS_SET = 1;\n-  private static final int IS_FOUND_FLAG_OFFSET_POSITION = 0;\n-  private static final int IS_NULL_FLAG_OFFSET_POSITION = IS_FOUND_FLAG_OFFSET_POSITION + Byte.BYTES;\n-  private static final int FOUND_VALUE_OFFSET_POSITION = IS_NULL_FLAG_OFFSET_POSITION + Byte.BYTES;\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  private static final byte BYTE_FLAG_FOUND_MASK = 0b0010;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1MjkzOQ=="}, "originalCommit": {"oid": "b9ef751385492faca5d57fbf05d0c7a71a1ff7e6"}, "originalPosition": 11}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2740, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}