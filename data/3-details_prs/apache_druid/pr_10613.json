{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI4ODE4OTE4", "number": 10613, "title": "expression filter support for vectorized query engines", "bodyText": "Description\nThis PR adds support for ExpressionFilter in vectorized query engines, and expands vectorization support for conditional expressions to support string typed columns.\nThe signature of the Filter interface method which checks if a matcher can be vectorized has been updated to accept a ColumnInspector, so that the ExpressionVirtualColumn.canVectorize method can do its thing to determine if the underlying expression can be vectorized:\n  default boolean canVectorizeMatcher(ColumnInspector inspector)\n  {\n    return false;\n  }\nExpression filters on string typed expressions use a new ObjectVectorValueMatcher (since string expressions most naturally use a VectorObjectSelector instead of the dictionary encoded vector dimension selectors), and DruidPredicateFactory has been updated to include a method to make an object matching predicate to work with that.\n  default Predicate<Object> makeObjectPredicate()\n  {\n    // default to try to use string predicate;\n    final Predicate<String> stringPredicate = makeStringPredicate();\n    return o -> stringPredicate.apply((String) o);\n  }\nSimilarly, VectorColumnProcessorFactory has been expanded with a new method to allow constructing these VectorObjectSelector based matchers:\n  T makeObjectProcessor(ColumnCapabilities capabilities, VectorObjectSelector selector);\nI imagine that this potentially opens the door to someday having filters that could support any of the complex typed columns we support as inputs as well using the predicate factory pattern, though I haven't really spent time thinking of any use cases for this yet.\nFinally, this PR fixes a bug when using a vectorizable string typed expression virtual column as an input to a filter, where the virtual column would report itself as vectorizable, but then not have implemented a single value dictionary selector. Instead, these non-dictionary string columns will now use the string object selector and should work correctly now. I've added additional virtual column inputs to filter tests to cover this case as well.\n\nThis PR has:\n\n been self-reviewed.\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths, ensuring the threshold for code coverage is met.\n added integration tests.\n been tested in a test Druid cluster.\n\n\nKey changed/added classes in this PR\n\nFilter\nExpressionFilter\nVectorComparisonProcessors\nBivariateFunctionVectorObjectProcessor \nVectorValueMatcherFactory\nObjectVectorValueMatcher", "createdAt": "2020-11-28T00:20:24Z", "url": "https://github.com/apache/druid/pull/10613", "merged": true, "mergeCommit": {"oid": "4cd4a22f87616ad6b4a722a8a47bad9ce25fa790"}, "closed": true, "closedAt": "2021-03-16T18:46:50Z", "author": {"login": "clintropolis"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdgjO5xAH2gAyNTI4ODE4OTE4OmJkZWUwN2QyMDFkNzEzZDdiNDU0M2VjN2NlMmJmMDdhYzlmMTI3NjM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABeDxckjgFqTYxMzYwOTI2Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "bdee07d201d713d7b4543ec7ce2bf07ac9f12763", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/bdee07d201d713d7b4543ec7ce2bf07ac9f12763", "committedDate": "2020-11-27T08:25:46Z", "message": "expression filter support for vectorized query engines"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b53ae6e944cff8c846d9b509f7825adc0f76bd19", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/b53ae6e944cff8c846d9b509f7825adc0f76bd19", "committedDate": "2020-11-28T04:01:45Z", "message": "remove unused codes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14c83dba61f8f705c503fea712bdc94899921170", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/14c83dba61f8f705c503fea712bdc94899921170", "committedDate": "2020-11-29T07:18:49Z", "message": "more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3737851bdd1674c30a16aa3c1e75bc3b6ff2ba83", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/3737851bdd1674c30a16aa3c1e75bc3b6ff2ba83", "committedDate": "2020-11-30T11:02:37Z", "message": "refactor, more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6cbe3fb4832d945737063f959a45525ed323622", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/c6cbe3fb4832d945737063f959a45525ed323622", "committedDate": "2020-12-01T07:15:03Z", "message": "suppress"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0MDUxMTU2", "url": "https://github.com/apache/druid/pull/10613#pullrequestreview-564051156", "createdAt": "2021-01-08T07:28:35Z", "commit": {"oid": "c6cbe3fb4832d945737063f959a45525ed323622"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwNzoyODozNVrOIQINvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQwODoyMTowMFrOIQJX4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4MjcxOQ==", "bodyText": "This opens not just STRING but also LONG_ARRAY and DOUBLE_ARRAY. Is that intentional (will numeric arrays work)?", "url": "https://github.com/apache/druid/pull/10613#discussion_r553782719", "createdAt": "2021-01-08T07:28:35Z", "author": {"login": "gianm"}, "path": "core/src/main/java/org/apache/druid/math/expr/BinaryLogicalOperatorExpr.java", "diffHunk": "@@ -74,7 +74,7 @@ public ExprType getOutputType(InputBindingInspector inspector)\n   @Override\n   public boolean canVectorize(InputBindingInspector inspector)\n   {\n-    return inspector.areNumeric(left, right) && inspector.canVectorize(left, right);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6cbe3fb4832d945737063f959a45525ed323622"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4Mzg2NA==", "bodyText": "This method deserves a javadoc.", "url": "https://github.com/apache/druid/pull/10613#discussion_r553783864", "createdAt": "2021-01-08T07:32:04Z", "author": {"login": "gianm"}, "path": "core/src/main/java/org/apache/druid/math/expr/ExprTypeConversion.java", "diffHunk": "@@ -20,24 +20,29 @@\n package org.apache.druid.math.expr;\n \n import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.Pair;\n \n import javax.annotation.Nullable;\n import java.util.List;\n \n public class ExprTypeConversion\n {\n+  public static Pair<ExprType, ExprType> coerceNull(Expr.InputBindingInspector inspector, Expr left, Expr right)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6cbe3fb4832d945737063f959a45525ed323622"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NTA4Mg==", "bodyText": "What guarantees that the objects in the vector are Strings?", "url": "https://github.com/apache/druid/pull/10613#discussion_r553785082", "createdAt": "2021-01-08T07:35:42Z", "author": {"login": "gianm"}, "path": "core/src/main/java/org/apache/druid/math/expr/IdentifierExpr.java", "diffHunk": "@@ -149,13 +150,14 @@ public boolean canVectorize(InputBindingInspector inspector)\n     ExprType inputType = inspector.getType(binding);\n \n     if (inputType == null) {\n-      // nil column, we can be anything, why not be a double\n-      return new IdentifierVectorProcessor<double[]>(ExprType.DOUBLE)\n+      // nil column, we can be anything, so be a string because it's the most flexible\n+      // (numbers will be populated with default values in default mode and non-null)\n+      return new IdentifierVectorProcessor<String[]>(ExprType.STRING)\n       {\n         @Override\n-        public ExprEvalVector<double[]> evalVector(VectorInputBinding bindings)\n+        public ExprEvalVector<String[]> evalVector(VectorInputBinding bindings)\n         {\n-          return new ExprEvalDoubleVector(bindings.getDoubleVector(binding), bindings.getNullVector(binding));\n+          return new ExprEvalStringVector(Arrays.stream(bindings.getObjectVector(binding)).map(x -> (String) x).toArray(String[]::new));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6cbe3fb4832d945737063f959a45525ed323622"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NjQ1Ng==", "bodyText": "This method should have a javadoc. The others should too, and they don't, but don't let that prevent you from adding one here \ud83d\ude42\nAs I type this, it's not clear to me what this method does, but hopefully it becomes clear elsewhere in the patch.", "url": "https://github.com/apache/druid/pull/10613#discussion_r553786456", "createdAt": "2021-01-08T07:39:34Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/dimension/DimensionSpec.java", "diffHunk": "@@ -70,6 +71,11 @@ default MultiValueDimensionVectorSelector decorate(MultiValueDimensionVectorSele\n     throw new UOE(\"DimensionSpec[%s] cannot vectorize\", getClass().getName());\n   }\n \n+  default VectorObjectSelector decorate(VectorObjectSelector selector)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6cbe3fb4832d945737063f959a45525ed323622"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NjgyMg==", "bodyText": "\"try\" makes it sound like this could potentially not work out. Why might it not work out? What bad stuff will happen if it doesn't work out?", "url": "https://github.com/apache/druid/pull/10613#discussion_r553786822", "createdAt": "2021-01-08T07:40:34Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java", "diffHunk": "@@ -27,6 +27,13 @@\n {\n   Predicate<String> makeStringPredicate();\n \n+  default Predicate<Object> makeObjectPredicate()\n+  {\n+    // default to try to use string predicate;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6cbe3fb4832d945737063f959a45525ed323622"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4Njg5MQ==", "bodyText": "What guarantees that o is a String?", "url": "https://github.com/apache/druid/pull/10613#discussion_r553786891", "createdAt": "2021-01-08T07:40:47Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java", "diffHunk": "@@ -27,6 +27,13 @@\n {\n   Predicate<String> makeStringPredicate();\n \n+  default Predicate<Object> makeObjectPredicate()\n+  {\n+    // default to try to use string predicate;\n+    final Predicate<String> stringPredicate = makeStringPredicate();\n+    return o -> stringPredicate.apply((String) o);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6cbe3fb4832d945737063f959a45525ed323622"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4NzU2Ng==", "bodyText": "\"yet\"? Will they ever be?", "url": "https://github.com/apache/druid/pull/10613#discussion_r553787566", "createdAt": "2021-01-08T07:42:45Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/vector/GroupByVectorColumnProcessorFactory.java", "diffHunk": "@@ -64,7 +65,16 @@ public GroupByVectorColumnSelector makeMultiValueDimensionProcessor(\n         ValueType.STRING == capabilities.getType(),\n         \"groupBy dimension processors must be STRING typed\"\n     );\n-    throw new UnsupportedOperationException(\"Multi-value dimensions not yet implemented for vectorized groupBys\");\n+    throw new UnsupportedOperationException(\"Multi-value dimensions are not yet implemented for vectorized groupBys\");\n+  }\n+\n+  @Override\n+  public GroupByVectorColumnSelector makeObjectProcessor(\n+      ColumnCapabilities capabilities,\n+      VectorObjectSelector selector\n+  )\n+  {\n+    throw new UnsupportedOperationException(\"Object columns are not yet implemented for vectorized groupBys\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6cbe3fb4832d945737063f959a45525ed323622"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc4ODYwOQ==", "bodyText": "Why does it matter if the dictionary values are unique? (Even if they're not, can't we still use a regular string selector?)", "url": "https://github.com/apache/druid/pull/10613#discussion_r553788609", "createdAt": "2021-01-08T07:45:34Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/DimensionHandlerUtils.java", "diffHunk": "@@ -305,17 +305,29 @@ private static ColumnCapabilities getEffectiveCapabilities(\n         originalCapabilities == null || ValueType.COMPLEX.equals(originalCapabilities.getType());\n \n     if (type == ValueType.STRING) {\n-      if (!forceSingleValue && effectiveCapabilites.hasMultipleValues().isMaybeTrue()) {\n-        return strategyFactory.makeMultiValueDimensionProcessor(\n-            effectiveCapabilites,\n-            selectorFactory.makeMultiValueDimensionSelector(dimensionSpec)\n-        );\n-      } else {\n-        return strategyFactory.makeSingleValueDimensionProcessor(\n-            effectiveCapabilites,\n-            selectorFactory.makeSingleValueDimensionSelector(dimensionSpec)\n-        );\n+      if (!forceSingleValue) {\n+        // if column is not dictionary encoded (and not non-existent or complex), use object selector\n+        if (effectiveCapabilites.isDictionaryEncoded().isFalse() ||\n+            effectiveCapabilites.areDictionaryValuesUnique().isFalse()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6cbe3fb4832d945737063f959a45525ed323622"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc5NjA1Ng==", "bodyText": "Interesting. It sounds like a bug that DruidPredicateFactory is annotated with @SubclassesMustOverrideEqualsAndHashCodeTest but yet its toString method is used for equality checks. Is that right? If so, perhaps a good fix would be:\n\nKeep the annotation on DimensionPredicateFilter\nSwitch the equality checks in DimensionPredicateFilter to use DruidPredicateFactory equals rather than toString\n\nIf we do that, IMO it'd be good to do it separately from this patch and also separately from #8256.\n\nDruidPredicateFactory doesn't really need equals or hashcode\n\nHow else would DimensionPredicateFilter's equals be implemented?", "url": "https://github.com/apache/druid/pull/10613#discussion_r553796056", "createdAt": "2021-01-08T08:06:36Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java", "diffHunk": "@@ -55,6 +69,105 @@ public ExpressionFilter(final Supplier<Expr> expr, final FilterTuning filterTuni\n     this.filterTuning = filterTuning;\n   }\n \n+  @Override\n+  public boolean canVectorizeMatcher(ColumnInspector inspector)\n+  {\n+    return expr.get().canVectorize(inspector);\n+  }\n+\n+  @Override\n+  public VectorValueMatcher makeVectorMatcher(VectorColumnSelectorFactory factory)\n+  {\n+    final Expr theExpr = expr.get();\n+\n+    DruidPredicateFactory predicateFactory = new DruidPredicateFactory()\n+    {\n+      @Override\n+      public Predicate<String> makeStringPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidLongPredicate makeLongPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidFloatPredicate makeFloatPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidDoublePredicate makeDoublePredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      // The hashcode and equals are to make SubclassesMustOverrideEqualsAndHashCodeTest stop complaining..\n+      // DruidPredicateFactory doesn't really need equals or hashcode, in fact only the 'toString' method is called", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6cbe3fb4832d945737063f959a45525ed323622"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzc5NjY2OA==", "bodyText": "Love the comment but the patch shouldn't go live like this \ud83d\ude42\nCan you come up with a scenario where we'll actually hit this case and add some tests for it? Maybe in the process of doing that, a better way to behave or a better way to describe the behavior will come up.", "url": "https://github.com/apache/druid/pull/10613#discussion_r553796668", "createdAt": "2021-01-08T08:08:15Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java", "diffHunk": "@@ -55,6 +69,105 @@ public ExpressionFilter(final Supplier<Expr> expr, final FilterTuning filterTuni\n     this.filterTuning = filterTuning;\n   }\n \n+  @Override\n+  public boolean canVectorizeMatcher(ColumnInspector inspector)\n+  {\n+    return expr.get().canVectorize(inspector);\n+  }\n+\n+  @Override\n+  public VectorValueMatcher makeVectorMatcher(VectorColumnSelectorFactory factory)\n+  {\n+    final Expr theExpr = expr.get();\n+\n+    DruidPredicateFactory predicateFactory = new DruidPredicateFactory()\n+    {\n+      @Override\n+      public Predicate<String> makeStringPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidLongPredicate makeLongPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidFloatPredicate makeFloatPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidDoublePredicate makeDoublePredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      // The hashcode and equals are to make SubclassesMustOverrideEqualsAndHashCodeTest stop complaining..\n+      // DruidPredicateFactory doesn't really need equals or hashcode, in fact only the 'toString' method is called\n+      // when testing equality of DimensionPredicateFilter, so it's the truly required method, but even that seems\n+      // strange at best.\n+      // Rather than tackle removing the annotation and reworking equality tests for now, will leave this to refactor\n+      // as part of https://github.com/apache/druid/issues/8256 which suggests combining Filter and DimFilter\n+      // implementations, which should clean up some of this mess.\n+      @Override\n+      public int hashCode()\n+      {\n+        return super.hashCode();\n+      }\n+\n+      @Override\n+      public boolean equals(Object obj)\n+      {\n+        return super.equals(obj);\n+      }\n+    };\n+\n+\n+    final ExprType outputType = theExpr.getOutputType(factory);\n+\n+    if (outputType == null) {\n+      // if an expression is vectorizable, but the output type is null, the result will be null (or the default\n+      // value in default mode) because expression is either all null constants or missing columns\n+\n+      // in sql compatible mode, this means no matches ever, so just use the false matcher:\n+      if (NullHandling.sqlCompatible()) {\n+        return new FalseVectorMatcher(factory.getVectorSizeInspector());\n+      }\n+      // in default mode, just fallback to using a long matcher since nearly all boolean-ish expressions\n+      // output a long value so it is probably a safe bet? idk, ending up here by using all null-ish things\n+      // in default mode is dancing on the edge of insanity anyway...", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6cbe3fb4832d945737063f959a45525ed323622"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgwMDAyNQ==", "bodyText": "createSimpleNumericColumnCapabilities is a weird method to call with type STRING. Is this a mistake? Or is the method just named poorly?", "url": "https://github.com/apache/druid/pull/10613#discussion_r553800025", "createdAt": "2021-01-08T08:16:41Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/filter/ExpressionFilter.java", "diffHunk": "@@ -55,6 +69,105 @@ public ExpressionFilter(final Supplier<Expr> expr, final FilterTuning filterTuni\n     this.filterTuning = filterTuning;\n   }\n \n+  @Override\n+  public boolean canVectorizeMatcher(ColumnInspector inspector)\n+  {\n+    return expr.get().canVectorize(inspector);\n+  }\n+\n+  @Override\n+  public VectorValueMatcher makeVectorMatcher(VectorColumnSelectorFactory factory)\n+  {\n+    final Expr theExpr = expr.get();\n+\n+    DruidPredicateFactory predicateFactory = new DruidPredicateFactory()\n+    {\n+      @Override\n+      public Predicate<String> makeStringPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidLongPredicate makeLongPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidFloatPredicate makeFloatPredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      @Override\n+      public DruidDoublePredicate makeDoublePredicate()\n+      {\n+        return Evals::asBoolean;\n+      }\n+\n+      // The hashcode and equals are to make SubclassesMustOverrideEqualsAndHashCodeTest stop complaining..\n+      // DruidPredicateFactory doesn't really need equals or hashcode, in fact only the 'toString' method is called\n+      // when testing equality of DimensionPredicateFilter, so it's the truly required method, but even that seems\n+      // strange at best.\n+      // Rather than tackle removing the annotation and reworking equality tests for now, will leave this to refactor\n+      // as part of https://github.com/apache/druid/issues/8256 which suggests combining Filter and DimFilter\n+      // implementations, which should clean up some of this mess.\n+      @Override\n+      public int hashCode()\n+      {\n+        return super.hashCode();\n+      }\n+\n+      @Override\n+      public boolean equals(Object obj)\n+      {\n+        return super.equals(obj);\n+      }\n+    };\n+\n+\n+    final ExprType outputType = theExpr.getOutputType(factory);\n+\n+    if (outputType == null) {\n+      // if an expression is vectorizable, but the output type is null, the result will be null (or the default\n+      // value in default mode) because expression is either all null constants or missing columns\n+\n+      // in sql compatible mode, this means no matches ever, so just use the false matcher:\n+      if (NullHandling.sqlCompatible()) {\n+        return new FalseVectorMatcher(factory.getVectorSizeInspector());\n+      }\n+      // in default mode, just fallback to using a long matcher since nearly all boolean-ish expressions\n+      // output a long value so it is probably a safe bet? idk, ending up here by using all null-ish things\n+      // in default mode is dancing on the edge of insanity anyway...\n+      return VectorValueMatcherColumnProcessorFactory.instance().makeLongProcessor(\n+          ColumnCapabilitiesImpl.createSimpleNumericColumnCapabilities(ValueType.LONG),\n+          ExpressionVectorSelectors.makeVectorValueSelector(factory, theExpr)\n+      ).makeMatcher(predicateFactory);\n+    }\n+\n+    switch (outputType) {\n+      case LONG:\n+        return VectorValueMatcherColumnProcessorFactory.instance().makeLongProcessor(\n+            ColumnCapabilitiesImpl.createSimpleNumericColumnCapabilities(ValueType.LONG),\n+            ExpressionVectorSelectors.makeVectorValueSelector(factory, theExpr)\n+        ).makeMatcher(predicateFactory);\n+      case DOUBLE:\n+        return VectorValueMatcherColumnProcessorFactory.instance().makeDoubleProcessor(\n+            ColumnCapabilitiesImpl.createSimpleNumericColumnCapabilities(ValueType.DOUBLE),\n+            ExpressionVectorSelectors.makeVectorValueSelector(factory, theExpr)\n+        ).makeMatcher(predicateFactory);\n+      case STRING:\n+        return VectorValueMatcherColumnProcessorFactory.instance().makeObjectProcessor(\n+            // using 'numeric' capabilities creator so we are configured to NOT be dictionary encoded, etc\n+            ColumnCapabilitiesImpl.createSimpleNumericColumnCapabilities(ValueType.STRING),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6cbe3fb4832d945737063f959a45525ed323622"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzgwMTY5Nw==", "bodyText": "What does it do when called on a non-string column? Cast the stuff to strings? Return null? Something else?", "url": "https://github.com/apache/druid/pull/10613#discussion_r553801697", "createdAt": "2021-01-08T08:21:00Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java", "diffHunk": "@@ -57,6 +57,15 @@ default int getMaxVectorSize()\n    */\n   MultiValueDimensionVectorSelector makeMultiValueDimensionSelector(DimensionSpec dimensionSpec);\n \n+  /**\n+   * Returns an object selector for string columns, useful for non-dictionary encoded strings, or when", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6cbe3fb4832d945737063f959a45525ed323622"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3736bed61e604004a77caea166ac7d72f62b103f", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/3736bed61e604004a77caea166ac7d72f62b103f", "committedDate": "2021-02-08T03:36:56Z", "message": "Merge remote-tracking branch 'upstream/master' into vector-expr-filter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5903fab18b8cfa5ebed434843021e1156a1c8857", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/5903fab18b8cfa5ebed434843021e1156a1c8857", "committedDate": "2021-02-10T10:21:36Z", "message": "more"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "711a6b5d06450afbc809d6174a2919207d59cec1", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/711a6b5d06450afbc809d6174a2919207d59cec1", "committedDate": "2021-02-11T08:24:52Z", "message": "more"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95bcf60b04d5f0b1ac04022e80dfeb4751a4381c", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/95bcf60b04d5f0b1ac04022e80dfeb4751a4381c", "committedDate": "2021-02-19T08:17:06Z", "message": "more"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d29fd6e2050ace4b2e19ba56f538a50bd64d321", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/8d29fd6e2050ace4b2e19ba56f538a50bd64d321", "committedDate": "2021-02-19T08:22:21Z", "message": "Merge remote-tracking branch 'upstream/master' into vector-expr-filter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3e5c915b7f13e701e3c6f2767a90e853aaefca9", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/a3e5c915b7f13e701e3c6f2767a90e853aaefca9", "committedDate": "2021-02-19T08:30:32Z", "message": "oops, i was wrong"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "406a0fafdc2c7a9bad92c2e8f90c6f1fb103bf83", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/406a0fafdc2c7a9bad92c2e8f90c6f1fb103bf83", "committedDate": "2021-02-19T08:53:24Z", "message": "comment"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk4NzQ5Nzg5", "url": "https://github.com/apache/druid/pull/10613#pullrequestreview-598749789", "createdAt": "2021-02-25T16:20:18Z", "commit": {"oid": "406a0fafdc2c7a9bad92c2e8f90c6f1fb103bf83"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNVQxNjoyMDoxOFrOIr9xLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yNVQxNjo0MTozMVrOIr-10A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk3MTY5Mw==", "bodyText": "Based on #10613 (comment) it seems like the intent of this method is that it will only be called for complex types (or maybe nonexistent columns too). If that's the case, please add some javadoc explaining that this method will only be called for complex types. It's analogous to \"makeObjectProcessor\" in \"VectorColumnProcessorFactory\". (You could even @see to that method in the javadocs if you want.)", "url": "https://github.com/apache/druid/pull/10613#discussion_r582971693", "createdAt": "2021-02-25T16:20:18Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/filter/DruidPredicateFactory.java", "diffHunk": "@@ -32,4 +32,15 @@\n   DruidFloatPredicate makeFloatPredicate();\n \n   DruidDoublePredicate makeDoublePredicate();\n+\n+  /**\n+   * Object predicate is currently only used by vectorized matchers for non-string object selectors. To preserve\n+   * behavior with non-vectorized matchers which use a string predicate with null inputs for these 'nil' matchers,\n+   * do the same thing here...\n+   */\n+  default Predicate<Object> makeObjectPredicate()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "406a0fafdc2c7a9bad92c2e8f90c6f1fb103bf83"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk4NTM0Mg==", "bodyText": "These javadocs should explicitly constrain the type of Object that may show up in the returned VectorObjectSelector. Is it always going to be a String or a null? Might it be String[], if the underlying column is multi-value?", "url": "https://github.com/apache/druid/pull/10613#discussion_r582985342", "createdAt": "2021-02-25T16:36:49Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java", "diffHunk": "@@ -62,16 +66,29 @@ default int getMaxVectorSize()\n   SingleValueDimensionVectorSelector makeSingleValueDimensionSelector(DimensionSpec dimensionSpec);\n \n   /**\n-   * Returns a string-typed, multi-value-per-row column selector. Should only be called on columns where\n-   * {@link #getColumnCapabilities} indicates they return STRING. Unlike {@link #makeSingleValueDimensionSelector},\n-   * this should not be called on nonexistent columns.\n+   * Returns a dictionary encoded, string-typed, multi-value-per-row column selector. Should only be called on columns\n+   * where {@link #getColumnCapabilities} indicates they return STRING. Unlike\n+   * {@link #makeSingleValueDimensionSelector}, this should not be called on nonexistent columns.\n    *\n    * If you need to write code that adapts to different input types, you should write a\n    * {@link org.apache.druid.segment.VectorColumnProcessorFactory} and use one of the\n    * {@link org.apache.druid.segment.ColumnProcessors#makeVectorProcessor} functions instead of using this method.\n    */\n   MultiValueDimensionVectorSelector makeMultiValueDimensionSelector(DimensionSpec dimensionSpec);\n \n+  /**\n+   * Returns a dimension object selector. Useful for non-dictionary encoded strings, or when using the dictionary\n+   * isn't useful. Right now, this should probably only be called on single valued STRING inputs (multi-value STRING\n+   * vector object selector is not yet implemented), but perhaps a world can be imagined where this could work with\n+   * COMPLEX too perhaps if it were useful for them to interact with {@link DimensionSpec} in some manner? May be called\n+   * for non-existent columns.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "406a0fafdc2c7a9bad92c2e8f90c6f1fb103bf83"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk4NTk1Mg==", "bodyText": "Get rid of the \"probably\" \ud83d\ude42\nEither it will work or it won't. If it doesn't work, say firmly not to do it, and ideally describe what will happen if you do it accidentally (the method will throw an error? the method will return a selector with undefined behavior? etc). If it does work, but might be a bad idea for some reason, spell that out.", "url": "https://github.com/apache/druid/pull/10613#discussion_r582985952", "createdAt": "2021-02-25T16:37:33Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/vector/VectorColumnSelectorFactory.java", "diffHunk": "@@ -62,16 +66,29 @@ default int getMaxVectorSize()\n   SingleValueDimensionVectorSelector makeSingleValueDimensionSelector(DimensionSpec dimensionSpec);\n \n   /**\n-   * Returns a string-typed, multi-value-per-row column selector. Should only be called on columns where\n-   * {@link #getColumnCapabilities} indicates they return STRING. Unlike {@link #makeSingleValueDimensionSelector},\n-   * this should not be called on nonexistent columns.\n+   * Returns a dictionary encoded, string-typed, multi-value-per-row column selector. Should only be called on columns\n+   * where {@link #getColumnCapabilities} indicates they return STRING. Unlike\n+   * {@link #makeSingleValueDimensionSelector}, this should not be called on nonexistent columns.\n    *\n    * If you need to write code that adapts to different input types, you should write a\n    * {@link org.apache.druid.segment.VectorColumnProcessorFactory} and use one of the\n    * {@link org.apache.druid.segment.ColumnProcessors#makeVectorProcessor} functions instead of using this method.\n    */\n   MultiValueDimensionVectorSelector makeMultiValueDimensionSelector(DimensionSpec dimensionSpec);\n \n+  /**\n+   * Returns a dimension object selector. Useful for non-dictionary encoded strings, or when using the dictionary\n+   * isn't useful. Right now, this should probably only be called on single valued STRING inputs (multi-value STRING", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "406a0fafdc2c7a9bad92c2e8f90c6f1fb103bf83"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4Mjk4OTI2NA==", "bodyText": "Is it ok that hasMultipleValues is false here? That seems like the potentially-sketchiest of the behaviors, since someone might use this method for a multi-value string accidentally. How about naming it createSimpleSingleValueStringColumnCapabilities?\nMethod names: the longer the better. Go, Java.", "url": "https://github.com/apache/druid/pull/10613#discussion_r582989264", "createdAt": "2021-02-25T16:41:31Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/column/ColumnCapabilitiesImpl.java", "diffHunk": "@@ -177,6 +177,21 @@ public static ColumnCapabilitiesImpl createSimpleNumericColumnCapabilities(Value\n     return builder;\n   }\n \n+  /**\n+   * Simple, non dictionary encoded string without bitmap index or anything fancy\n+   */\n+  public static ColumnCapabilitiesImpl createSimpleStringColumnCapabilities()\n+  {\n+    return new ColumnCapabilitiesImpl().setType(ValueType.STRING)\n+                                       .setHasMultipleValues(false)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "406a0fafdc2c7a9bad92c2e8f90c6f1fb103bf83"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3b0a948b128461470c562d4681b4e1af21a9ded", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/e3b0a948b128461470c562d4681b4e1af21a9ded", "committedDate": "2021-03-04T12:26:02Z", "message": "remove decorate, object dimension selector, more javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "347752463fab8f2f57b58c84a28b2b58d26fcb43", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/347752463fab8f2f57b58c84a28b2b58d26fcb43", "committedDate": "2021-03-05T06:58:49Z", "message": "style"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEzNjA5MjYz", "url": "https://github.com/apache/druid/pull/10613#pullrequestreview-613609263", "createdAt": "2021-03-16T18:46:43Z", "commit": {"oid": "347752463fab8f2f57b58c84a28b2b58d26fcb43"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3105, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}