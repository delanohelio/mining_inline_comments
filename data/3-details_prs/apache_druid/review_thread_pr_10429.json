{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyMDY4MDUy", "number": 10429, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMToyNjozMlrOEnOarg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMzoxNTo0OVrOEnQDwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTY2MTI2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/druid/math/expr/ExprType.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMToyNjozMlrOHXtNtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwMToyOTo0MlrOHXx4vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMDA4Nw==", "bodyText": "The return value is not nullable.", "url": "https://github.com/apache/druid/pull/10429#discussion_r494620087", "createdAt": "2020-09-24T21:26:32Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/math/expr/ExprType.java", "diffHunk": "@@ -216,11 +226,44 @@ public static ExprType functionAutoTypeConversion(@Nullable ExprType type, @Null\n       return STRING;\n     }\n \n-    return numericAutoTypeConversion(type, other);\n+    return doubleNumericAutoTypeConversion(type, other);\n   }\n \n+  /**\n+   * Given 2 'input' types, choose the most appropriate combined type, if possible\n+   *\n+   * arrays must be the same type\n+   * if either type is {@link #STRING}, the output type will be preserved as string\n+   * any number will be coerced to {@link #LONG}\n+   */\n+  @Nullable\n+  public static ExprType integerMathFunctionAutoTypeConversion(@Nullable ExprType type, @Nullable ExprType other)\n+  {\n+    if (type == null || other == null) {\n+      // cannot auto conversion unknown types\n+      return null;\n+    }\n+    // arrays cannot be auto converted\n+    if (isArray(type) || isArray(other)) {\n+      if (!type.equals(other)) {\n+        throw new IAE(\"Cannot implicitly cast %s to %s\", type, other);\n+      }\n+      return type;\n+    }\n+    // if either argument is a string, type becomes a string\n+    if (STRING.equals(type) || STRING.equals(other)) {\n+      return STRING;\n+    }\n+\n+    // any number is long\n+    return LONG;\n+  }\n+\n+  /**\n+   * If both types are {@link #LONG}, returns {@link #LONG}, else {@link #DOUBLE}\n+   */\n   @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f132d71b1e26ce3a2089b27b2f2f8dcaee68166c"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5NjYzNg==", "bodyText": "oops, will fix (this whole area in general needs some improvement, but I think maybe will save for a future PR)", "url": "https://github.com/apache/druid/pull/10429#discussion_r494696636", "createdAt": "2020-09-25T01:29:42Z", "author": {"login": "clintropolis"}, "path": "core/src/main/java/org/apache/druid/math/expr/ExprType.java", "diffHunk": "@@ -216,11 +226,44 @@ public static ExprType functionAutoTypeConversion(@Nullable ExprType type, @Null\n       return STRING;\n     }\n \n-    return numericAutoTypeConversion(type, other);\n+    return doubleNumericAutoTypeConversion(type, other);\n   }\n \n+  /**\n+   * Given 2 'input' types, choose the most appropriate combined type, if possible\n+   *\n+   * arrays must be the same type\n+   * if either type is {@link #STRING}, the output type will be preserved as string\n+   * any number will be coerced to {@link #LONG}\n+   */\n+  @Nullable\n+  public static ExprType integerMathFunctionAutoTypeConversion(@Nullable ExprType type, @Nullable ExprType other)\n+  {\n+    if (type == null || other == null) {\n+      // cannot auto conversion unknown types\n+      return null;\n+    }\n+    // arrays cannot be auto converted\n+    if (isArray(type) || isArray(other)) {\n+      if (!type.equals(other)) {\n+        throw new IAE(\"Cannot implicitly cast %s to %s\", type, other);\n+      }\n+      return type;\n+    }\n+    // if either argument is a string, type becomes a string\n+    if (STRING.equals(type) || STRING.equals(other)) {\n+      return STRING;\n+    }\n+\n+    // any number is long\n+    return LONG;\n+  }\n+\n+  /**\n+   * If both types are {@link #LONG}, returns {@link #LONG}, else {@link #DOUBLE}\n+   */\n   @Nullable", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMDA4Nw=="}, "originalCommit": {"oid": "f132d71b1e26ce3a2089b27b2f2f8dcaee68166c"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5NTkzMDI2OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/druid/math/expr/vector/VectorMathProcessors.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMzoxNTo0OVrOHXvsZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQwNzowMjo1MlrOHX3dWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MDcwOQ==", "bodyText": "Hmm, do we need a sanity check after a casting if the right value is still valid?", "url": "https://github.com/apache/druid/pull/10429#discussion_r494660709", "createdAt": "2020-09-24T23:15:49Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/math/expr/vector/VectorMathProcessors.java", "diffHunk": "@@ -632,170 +793,812 @@ public double apply(double left, double right)\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> atan(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> atan2(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.atan(input);\n+            return Math.atan2(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.atan(input);\n+            return Math.atan2(left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> cos(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(double left, long right)\n           {\n-            return Math.cos(input);\n+            return Math.atan2(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(double left, double right)\n           {\n-            return Math.cos(input);\n+            return Math.atan2(left, right);\n           }\n         }\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> cosh(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> copySign(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.cosh(input);\n+            return Math.copySign((double) left, (double) right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.cosh(input);\n+            return Math.copySign((double) left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> cot(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(double left, long right)\n           {\n-            return Math.cos(input) / Math.sin(input);\n+            return Math.copySign(left, (double) right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(double left, double right)\n           {\n-            return Math.cos(input) / Math.sin(input);\n+            return Math.copySign(left, right);\n           }\n         }\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> sin(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> hypot(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.sin(input);\n+            return Math.hypot(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.sin(input);\n+            return Math.hypot(left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> sinh(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n-            inputTypes.getMaxVectorSize()\n-        )\n-        {\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.hypot(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.hypot(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> remainder(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, double right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> nextAfter(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.nextAfter((double) left, (double) right);\n+          }\n+        },\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, double right)\n+          {\n+            return Math.nextAfter((double) left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.nextAfter(left, (double) right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.nextAfter(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> scalb(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.scalb((double) left, (int) right);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f132d71b1e26ce3a2089b27b2f2f8dcaee68166c"}, "originalPosition": 564}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MTMzNg==", "bodyText": "Same comment for other places where it does narrowing casting.", "url": "https://github.com/apache/druid/pull/10429#discussion_r494661336", "createdAt": "2020-09-24T23:17:40Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/math/expr/vector/VectorMathProcessors.java", "diffHunk": "@@ -632,170 +793,812 @@ public double apply(double left, double right)\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> atan(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> atan2(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.atan(input);\n+            return Math.atan2(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.atan(input);\n+            return Math.atan2(left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> cos(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(double left, long right)\n           {\n-            return Math.cos(input);\n+            return Math.atan2(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(double left, double right)\n           {\n-            return Math.cos(input);\n+            return Math.atan2(left, right);\n           }\n         }\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> cosh(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> copySign(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.cosh(input);\n+            return Math.copySign((double) left, (double) right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.cosh(input);\n+            return Math.copySign((double) left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> cot(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(double left, long right)\n           {\n-            return Math.cos(input) / Math.sin(input);\n+            return Math.copySign(left, (double) right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(double left, double right)\n           {\n-            return Math.cos(input) / Math.sin(input);\n+            return Math.copySign(left, right);\n           }\n         }\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> sin(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> hypot(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.sin(input);\n+            return Math.hypot(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.sin(input);\n+            return Math.hypot(left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> sinh(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n-            inputTypes.getMaxVectorSize()\n-        )\n-        {\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.hypot(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.hypot(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> remainder(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, double right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> nextAfter(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.nextAfter((double) left, (double) right);\n+          }\n+        },\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, double right)\n+          {\n+            return Math.nextAfter((double) left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.nextAfter(left, (double) right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.nextAfter(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> scalb(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.scalb((double) left, (int) right);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MDcwOQ=="}, "originalCommit": {"oid": "f132d71b1e26ce3a2089b27b2f2f8dcaee68166c"}, "originalPosition": 564}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY5NjUyMQ==", "bodyText": "Ah, we probably should? Although the non-vectorized expressions are just using Number.intValue() and the like, which just do a straight cast afaict.", "url": "https://github.com/apache/druid/pull/10429#discussion_r494696521", "createdAt": "2020-09-25T01:29:16Z", "author": {"login": "clintropolis"}, "path": "core/src/main/java/org/apache/druid/math/expr/vector/VectorMathProcessors.java", "diffHunk": "@@ -632,170 +793,812 @@ public double apply(double left, double right)\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> atan(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> atan2(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.atan(input);\n+            return Math.atan2(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.atan(input);\n+            return Math.atan2(left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> cos(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(double left, long right)\n           {\n-            return Math.cos(input);\n+            return Math.atan2(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(double left, double right)\n           {\n-            return Math.cos(input);\n+            return Math.atan2(left, right);\n           }\n         }\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> cosh(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> copySign(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.cosh(input);\n+            return Math.copySign((double) left, (double) right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.cosh(input);\n+            return Math.copySign((double) left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> cot(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(double left, long right)\n           {\n-            return Math.cos(input) / Math.sin(input);\n+            return Math.copySign(left, (double) right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(double left, double right)\n           {\n-            return Math.cos(input) / Math.sin(input);\n+            return Math.copySign(left, right);\n           }\n         }\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> sin(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> hypot(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.sin(input);\n+            return Math.hypot(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.sin(input);\n+            return Math.hypot(left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> sinh(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n-            inputTypes.getMaxVectorSize()\n-        )\n-        {\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.hypot(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.hypot(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> remainder(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, double right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> nextAfter(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.nextAfter((double) left, (double) right);\n+          }\n+        },\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, double right)\n+          {\n+            return Math.nextAfter((double) left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.nextAfter(left, (double) right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.nextAfter(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> scalb(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.scalb((double) left, (int) right);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MDcwOQ=="}, "originalCommit": {"oid": "f132d71b1e26ce3a2089b27b2f2f8dcaee68166c"}, "originalPosition": 564}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc4NzkzMA==", "bodyText": "Heh, we should clean up this later.", "url": "https://github.com/apache/druid/pull/10429#discussion_r494787930", "createdAt": "2020-09-25T07:02:52Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/math/expr/vector/VectorMathProcessors.java", "diffHunk": "@@ -632,170 +793,812 @@ public double apply(double left, double right)\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> atan(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> atan2(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.atan(input);\n+            return Math.atan2(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.atan(input);\n+            return Math.atan2(left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> cos(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(double left, long right)\n           {\n-            return Math.cos(input);\n+            return Math.atan2(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(double left, double right)\n           {\n-            return Math.cos(input);\n+            return Math.atan2(left, right);\n           }\n         }\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> cosh(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> copySign(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.cosh(input);\n+            return Math.copySign((double) left, (double) right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.cosh(input);\n+            return Math.copySign((double) left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> cot(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(double left, long right)\n           {\n-            return Math.cos(input) / Math.sin(input);\n+            return Math.copySign(left, (double) right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(double left, double right)\n           {\n-            return Math.cos(input) / Math.sin(input);\n+            return Math.copySign(left, right);\n           }\n         }\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> sin(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> hypot(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.sin(input);\n+            return Math.hypot(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.sin(input);\n+            return Math.hypot(left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> sinh(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n-            inputTypes.getMaxVectorSize()\n-        )\n-        {\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.hypot(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.hypot(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> remainder(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, double right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> nextAfter(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.nextAfter((double) left, (double) right);\n+          }\n+        },\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, double right)\n+          {\n+            return Math.nextAfter((double) left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.nextAfter(left, (double) right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.nextAfter(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> scalb(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.scalb((double) left, (int) right);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MDcwOQ=="}, "originalCommit": {"oid": "f132d71b1e26ce3a2089b27b2f2f8dcaee68166c"}, "originalPosition": 564}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2968, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}