{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyNDUzNDQw", "number": 9810, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMzo1MDowNFrOD4qM4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMToyMjowOVrOETbqDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNzM4MjczOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/druid/timeline/partition/HashBasedNumberedShardSpec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMzo1MDowNFrOGPjYJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMzo1MDowNFrOGPjYJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk2MTQ0Ng==", "bodyText": "Query time hashing should yield the same value as that produced during ingestion time. This should be a bug. Before this change, no one is using this api so no issue pops up before. During indexing, which segment to put a record into is by calling getLookup function below, in which the 32 bit hashed value is forced to stay as a positive integer by applying Math.abs. While here, it was casting the 32 bit hashed value to a long to force it stay as a positive integer. If the hashed value is 0xff_ff_ff_ff, Math.abs(0xff_ff_ff_ff) is different from (long)(0xff_ff_ff_ff). It's better to make the change here than in getLookup for backward compatibility otherwise users who have already used hash based partitioning can't leverage the pruning and pruning will be wrong unless they redo the ingestion to update segments.", "url": "https://github.com/apache/druid/pull/9810#discussion_r418961446", "createdAt": "2020-05-02T13:50:04Z", "author": {"login": "wjhypo"}, "path": "core/src/main/java/org/apache/druid/timeline/partition/HashBasedNumberedShardSpec.java", "diffHunk": "@@ -73,7 +81,7 @@ public boolean isCompatible(Class<? extends ShardSpec> other)\n   @Override\n   public boolean isInChunk(long timestamp, InputRow inputRow)\n   {\n-    return (((long) hash(timestamp, inputRow)) - getPartitionNum()) % getPartitions() == 0;\n+    return (Math.abs(hash(timestamp, inputRow)) - getPartitionNum()) % getPartitions() == 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NDU2ODgwOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/druid/timeline/partition/HashBasedNumberedShardSpec.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwNDo1NjoxOVrOG4okJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMToyNTozOVrOG5KydA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAzODA1Mw==", "bodyText": "Hmm, did you mean queryGranularity instead of timestamp? Druid does store timestamp, but it's not possible to get the query granularity after ingestion.", "url": "https://github.com/apache/druid/pull/9810#discussion_r462038053", "createdAt": "2020-07-29T04:56:19Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/timeline/partition/HashBasedNumberedShardSpec.java", "diffHunk": "@@ -192,4 +229,71 @@ public String toString()\n            \", partitionDimensions=\" + partitionDimensions +\n            '}';\n   }\n+\n+  @Override\n+  public boolean possibleInDomain(Map<String, RangeSet<String>> domain)\n+  {\n+    // If no partitionDimensions are specified during ingestion, hash is based on all dimensions plus the truncated\n+    // input timestamp according to QueryGranularity instead of just partitionDimensions. Since we don't store the\n+    // timestamp after ingestion, bypass this case", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA4NTc0Mg==", "bodyText": "Oh, I mean in the shard spec, we don't store truncated timestamps of the events that fall into the shard. I've rephrased it. Let me know if it makes sense or needs more clarification.", "url": "https://github.com/apache/druid/pull/9810#discussion_r462085742", "createdAt": "2020-07-29T07:11:07Z", "author": {"login": "wjhypo"}, "path": "core/src/main/java/org/apache/druid/timeline/partition/HashBasedNumberedShardSpec.java", "diffHunk": "@@ -192,4 +229,71 @@ public String toString()\n            \", partitionDimensions=\" + partitionDimensions +\n            '}';\n   }\n+\n+  @Override\n+  public boolean possibleInDomain(Map<String, RangeSet<String>> domain)\n+  {\n+    // If no partitionDimensions are specified during ingestion, hash is based on all dimensions plus the truncated\n+    // input timestamp according to QueryGranularity instead of just partitionDimensions. Since we don't store the\n+    // timestamp after ingestion, bypass this case", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAzODA1Mw=="}, "originalCommit": null, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5ODc3Mg==", "bodyText": "Thanks for making it more clear!", "url": "https://github.com/apache/druid/pull/9810#discussion_r462598772", "createdAt": "2020-07-29T21:25:39Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/timeline/partition/HashBasedNumberedShardSpec.java", "diffHunk": "@@ -192,4 +229,71 @@ public String toString()\n            \", partitionDimensions=\" + partitionDimensions +\n            '}';\n   }\n+\n+  @Override\n+  public boolean possibleInDomain(Map<String, RangeSet<String>> domain)\n+  {\n+    // If no partitionDimensions are specified during ingestion, hash is based on all dimensions plus the truncated\n+    // input timestamp according to QueryGranularity instead of just partitionDimensions. Since we don't store the\n+    // timestamp after ingestion, bypass this case", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAzODA1Mw=="}, "originalCommit": null, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NDU4MTM1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/druid/timeline/partition/HashBasedNumberedShardSpec.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQwNTowMzo0N1rOG4or3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMToyNTo0MVrOG5KyiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA0MDAyOQ==", "bodyText": "Can we extract Math.abs(hash % numBuckets) == bucketId % numBuckets as a common method so that we can avoid a mistake that you have fixed in the future?", "url": "https://github.com/apache/druid/pull/9810#discussion_r462040029", "createdAt": "2020-07-29T05:03:47Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/timeline/partition/HashBasedNumberedShardSpec.java", "diffHunk": "@@ -90,10 +98,39 @@ public int getNumBuckets()\n     return partitionDimensions;\n   }\n \n+  @Override\n+  public List<String> getDomainDimensions()\n+  {\n+    return partitionDimensions;\n+  }\n+\n   @Override\n   public boolean isInChunk(long timestamp, InputRow inputRow)\n   {\n-    return (((long) hash(timestamp, inputRow)) - bucketId) % numBuckets == 0;\n+    return Math.abs(hash(timestamp, inputRow) % numBuckets) == bucketId % numBuckets;\n+  }\n+\n+  /**\n+   * Check if the current segment possibly holds records if the values of dimensions in {@link #partitionDimensions}\n+   * are of {@code partitionDimensionsValues}\n+   *\n+   * @param partitionDimensionsValues An instance of values of dimensions in {@link #partitionDimensions}\n+   *\n+   * @return Whether the current segment possibly holds records for the given values of partition dimensions\n+   */\n+  private boolean isInChunk(Map<String, String> partitionDimensionsValues)\n+  {\n+    assert !partitionDimensions.isEmpty();\n+    List<Object> groupKey = Lists.transform(\n+        partitionDimensions,\n+        o -> Collections.singletonList(partitionDimensionsValues.get(o))\n+    );\n+    try {\n+      return Math.abs(hash(jsonMapper, groupKey) % numBuckets) == bucketId % numBuckets;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA4NTQ3MQ==", "bodyText": "Good call! Changed. Actually I have to extract only Math.abs(hash % numBuckets) because in the function used by ingestion static ShardSpecLookup createHashLookup only needs Math.abs(hash % numBuckets) instead of the whole statement you mentioned.", "url": "https://github.com/apache/druid/pull/9810#discussion_r462085471", "createdAt": "2020-07-29T07:10:35Z", "author": {"login": "wjhypo"}, "path": "core/src/main/java/org/apache/druid/timeline/partition/HashBasedNumberedShardSpec.java", "diffHunk": "@@ -90,10 +98,39 @@ public int getNumBuckets()\n     return partitionDimensions;\n   }\n \n+  @Override\n+  public List<String> getDomainDimensions()\n+  {\n+    return partitionDimensions;\n+  }\n+\n   @Override\n   public boolean isInChunk(long timestamp, InputRow inputRow)\n   {\n-    return (((long) hash(timestamp, inputRow)) - bucketId) % numBuckets == 0;\n+    return Math.abs(hash(timestamp, inputRow) % numBuckets) == bucketId % numBuckets;\n+  }\n+\n+  /**\n+   * Check if the current segment possibly holds records if the values of dimensions in {@link #partitionDimensions}\n+   * are of {@code partitionDimensionsValues}\n+   *\n+   * @param partitionDimensionsValues An instance of values of dimensions in {@link #partitionDimensions}\n+   *\n+   * @return Whether the current segment possibly holds records for the given values of partition dimensions\n+   */\n+  private boolean isInChunk(Map<String, String> partitionDimensionsValues)\n+  {\n+    assert !partitionDimensions.isEmpty();\n+    List<Object> groupKey = Lists.transform(\n+        partitionDimensions,\n+        o -> Collections.singletonList(partitionDimensionsValues.get(o))\n+    );\n+    try {\n+      return Math.abs(hash(jsonMapper, groupKey) % numBuckets) == bucketId % numBuckets;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA0MDAyOQ=="}, "originalCommit": null, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5ODc5Mg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/apache/druid/pull/9810#discussion_r462598792", "createdAt": "2020-07-29T21:25:41Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/timeline/partition/HashBasedNumberedShardSpec.java", "diffHunk": "@@ -90,10 +98,39 @@ public int getNumBuckets()\n     return partitionDimensions;\n   }\n \n+  @Override\n+  public List<String> getDomainDimensions()\n+  {\n+    return partitionDimensions;\n+  }\n+\n   @Override\n   public boolean isInChunk(long timestamp, InputRow inputRow)\n   {\n-    return (((long) hash(timestamp, inputRow)) - bucketId) % numBuckets == 0;\n+    return Math.abs(hash(timestamp, inputRow) % numBuckets) == bucketId % numBuckets;\n+  }\n+\n+  /**\n+   * Check if the current segment possibly holds records if the values of dimensions in {@link #partitionDimensions}\n+   * are of {@code partitionDimensionsValues}\n+   *\n+   * @param partitionDimensionsValues An instance of values of dimensions in {@link #partitionDimensions}\n+   *\n+   * @return Whether the current segment possibly holds records for the given values of partition dimensions\n+   */\n+  private boolean isInChunk(Map<String, String> partitionDimensionsValues)\n+  {\n+    assert !partitionDimensions.isEmpty();\n+    List<Object> groupKey = Lists.transform(\n+        partitionDimensions,\n+        o -> Collections.singletonList(partitionDimensionsValues.get(o))\n+    );\n+    try {\n+      return Math.abs(hash(jsonMapper, groupKey) % numBuckets) == bucketId % numBuckets;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjA0MDAyOQ=="}, "originalCommit": null, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODExNTM0OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMToyMjowOVrOG5KrsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMjowMDoxMVrOG5Lw_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NzA0MA==", "bodyText": "You can fix the ci failure by adding .randomQueryId() here.", "url": "https://github.com/apache/druid/pull/9810#discussion_r462597040", "createdAt": "2020-07-29T21:22:09Z", "author": {"login": "jihoonson"}, "path": "server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java", "diffHunk": "@@ -1541,6 +1543,135 @@ public void testSingleDimensionPruning()\n     Assert.assertEquals(expected, ((TimeseriesQuery) capture.getValue().getQuery()).getQuerySegmentSpec());\n   }\n \n+  @Test\n+  public void testHashBasedPruning()\n+  {\n+    DimFilter filter = new AndDimFilter(\n+        new SelectorDimFilter(\"dim1\", \"a\", null),\n+        new BoundDimFilter(\"dim2\", \"e\", \"zzz\", true, true, false, null, StringComparators.LEXICOGRAPHIC),\n+        // Equivalent filter of dim3 below is InDimFilter(\"dim3\", Arrays.asList(\"c\"), null)\n+        new AndDimFilter(\n+            new InDimFilter(\"dim3\", Arrays.asList(\"a\", \"c\", \"e\", \"g\"), null),\n+            new BoundDimFilter(\"dim3\", \"aaa\", \"ddd\", false, false, false, null, StringComparators.LEXICOGRAPHIC)\n+        )\n+    );\n+\n+    final Druids.TimeseriesQueryBuilder builder = Druids.newTimeseriesQueryBuilder()\n+                                                        .dataSource(DATA_SOURCE)\n+                                                        .filters(filter)\n+                                                        .granularity(GRANULARITY)\n+                                                        .intervals(SEG_SPEC)\n+                                                        .context(CONTEXT)\n+                                                        .intervals(\"2011-01-05/2011-01-10\")\n+                                                        .aggregators(RENAMED_AGGS)\n+                                                        .postAggregators(RENAMED_POST_AGGS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df48ebba967a1f2324fb62f7b08deab6f70c9acd"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjYxNDc4Mw==", "bodyText": "\ud83d\udc4d Pushed a fix. Also thanks for the wiki, I will avoid force pushes in the future.", "url": "https://github.com/apache/druid/pull/9810#discussion_r462614783", "createdAt": "2020-07-29T22:00:11Z", "author": {"login": "wjhypo"}, "path": "server/src/test/java/org/apache/druid/client/CachingClusteredClientTest.java", "diffHunk": "@@ -1541,6 +1543,135 @@ public void testSingleDimensionPruning()\n     Assert.assertEquals(expected, ((TimeseriesQuery) capture.getValue().getQuery()).getQuerySegmentSpec());\n   }\n \n+  @Test\n+  public void testHashBasedPruning()\n+  {\n+    DimFilter filter = new AndDimFilter(\n+        new SelectorDimFilter(\"dim1\", \"a\", null),\n+        new BoundDimFilter(\"dim2\", \"e\", \"zzz\", true, true, false, null, StringComparators.LEXICOGRAPHIC),\n+        // Equivalent filter of dim3 below is InDimFilter(\"dim3\", Arrays.asList(\"c\"), null)\n+        new AndDimFilter(\n+            new InDimFilter(\"dim3\", Arrays.asList(\"a\", \"c\", \"e\", \"g\"), null),\n+            new BoundDimFilter(\"dim3\", \"aaa\", \"ddd\", false, false, false, null, StringComparators.LEXICOGRAPHIC)\n+        )\n+    );\n+\n+    final Druids.TimeseriesQueryBuilder builder = Druids.newTimeseriesQueryBuilder()\n+                                                        .dataSource(DATA_SOURCE)\n+                                                        .filters(filter)\n+                                                        .granularity(GRANULARITY)\n+                                                        .intervals(SEG_SPEC)\n+                                                        .context(CONTEXT)\n+                                                        .intervals(\"2011-01-05/2011-01-10\")\n+                                                        .aggregators(RENAMED_AGGS)\n+                                                        .postAggregators(RENAMED_POST_AGGS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU5NzA0MA=="}, "originalCommit": {"oid": "df48ebba967a1f2324fb62f7b08deab6f70c9acd"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2410, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}