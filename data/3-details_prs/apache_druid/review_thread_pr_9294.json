{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5MzI3NTMz", "number": 9294, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMzoxMDo0NFrODcFzIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQxODozNjowNlrODce1vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNzgxNzI4OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMFQyMzoxMDo0NFrOFj8-dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMTo1Nzo0NFrOFj_iXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI0MzUxMA==", "bodyText": "excluduing -> excluding", "url": "https://github.com/apache/druid/pull/9294#discussion_r373243510", "createdAt": "2020-01-30T23:10:44Z", "author": {"login": "jon-wei"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rel;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.Pair;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.DataSource;\n+import org.apache.druid.query.JoinDataSource;\n+import org.apache.druid.query.QueryDataSource;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.join.JoinType;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.Expressions;\n+import org.apache.druid.sql.calcite.planner.Calcites;\n+import org.apache.druid.sql.calcite.table.RowSignature;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * DruidRel that uses a {@link JoinDataSource}.\n+ */\n+public class DruidJoinQueryRel extends DruidRel<DruidJoinQueryRel>\n+{\n+  private static final TableDataSource DUMMY_DATA_SOURCE = new TableDataSource(\"__join__\");\n+  private static final double COST_FACTOR = 100.0;\n+\n+  private final PartialDruidQuery partialQuery;\n+  private final Join joinRel;\n+  private RelNode left;\n+  private RelNode right;\n+\n+  private DruidJoinQueryRel(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      Join joinRel,\n+      PartialDruidQuery partialQuery,\n+      QueryMaker queryMaker\n+  )\n+  {\n+    super(cluster, traitSet, queryMaker);\n+    this.joinRel = joinRel;\n+    this.left = joinRel.getLeft();\n+    this.right = joinRel.getRight();\n+    this.partialQuery = partialQuery;\n+  }\n+\n+  public static DruidJoinQueryRel create(final Join joinRel, final QueryMaker queryMaker)\n+  {\n+    return new DruidJoinQueryRel(\n+        joinRel.getCluster(),\n+        joinRel.getTraitSet(),\n+        joinRel,\n+        PartialDruidQuery.create(joinRel),\n+        queryMaker\n+    );\n+  }\n+\n+  @Override\n+  public PartialDruidQuery getPartialDruidQuery()\n+  {\n+    return partialQuery;\n+  }\n+\n+  @Override\n+  public Sequence<Object[]> runQuery()\n+  {\n+    // runQuery doesn't need to finalize aggregations, because the fact that runQuery is happening suggests this\n+    // is the outermost query and it will actually get run as a native query. Druid's native query layer will\n+    // finalize aggregations for the outermost query even if we don't explicitly ask it to.\n+\n+    final DruidQuery query = toDruidQuery(false);\n+    return getQueryMaker().runQuery(query);\n+  }\n+\n+  @Override\n+  public DruidJoinQueryRel withPartialQuery(final PartialDruidQuery newQueryBuilder)\n+  {\n+    return new DruidJoinQueryRel(\n+        getCluster(),\n+        getTraitSet().plusAll(newQueryBuilder.getRelTraits()),\n+        joinRel,\n+        newQueryBuilder,\n+        getQueryMaker()\n+    );\n+  }\n+\n+  @Override\n+  public int getQueryCount()\n+  {\n+    return ((DruidRel<?>) left).getQueryCount() + ((DruidRel<?>) right).getQueryCount();\n+  }\n+\n+  @Override\n+  public DruidQuery toDruidQuery(final boolean finalizeAggregations)\n+  {\n+    final DruidRel<?> leftDruidRel = (DruidRel<?>) left;\n+    final DruidQuery leftQuery = Preconditions.checkNotNull((leftDruidRel).toDruidQuery(false), \"leftQuery\");\n+    final RowSignature leftSignature = leftQuery.getOutputRowSignature();\n+    final DataSource leftDataSource;\n+\n+    final DruidRel<?> rightDruidRel = (DruidRel<?>) right;\n+    final DruidQuery rightQuery = Preconditions.checkNotNull(rightDruidRel.toDruidQuery(false), \"rightQuery\");\n+    final RowSignature rightSignature = rightQuery.getOutputRowSignature();\n+    final DataSource rightDataSource;\n+\n+    // Left rel: allow direct embedding of scans/mappings including those of joins.\n+    if (DruidRels.isScanOrMapping(leftDruidRel, true)) {\n+      leftDataSource = leftQuery.getDataSource();\n+    } else {\n+      leftDataSource = new QueryDataSource(leftQuery.getQuery());\n+    }\n+\n+    // Right rel: allow direct embedding of scans/mappings, excluduing joins (those must be done as subqueries).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb714014f7ac3bb9947850375e51f002c81010c7"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4NTQ2OA==", "bodyText": "Oops, I'll fix it.", "url": "https://github.com/apache/druid/pull/9294#discussion_r373285468", "createdAt": "2020-01-31T01:57:44Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rel;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.Pair;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.DataSource;\n+import org.apache.druid.query.JoinDataSource;\n+import org.apache.druid.query.QueryDataSource;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.join.JoinType;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.Expressions;\n+import org.apache.druid.sql.calcite.planner.Calcites;\n+import org.apache.druid.sql.calcite.table.RowSignature;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * DruidRel that uses a {@link JoinDataSource}.\n+ */\n+public class DruidJoinQueryRel extends DruidRel<DruidJoinQueryRel>\n+{\n+  private static final TableDataSource DUMMY_DATA_SOURCE = new TableDataSource(\"__join__\");\n+  private static final double COST_FACTOR = 100.0;\n+\n+  private final PartialDruidQuery partialQuery;\n+  private final Join joinRel;\n+  private RelNode left;\n+  private RelNode right;\n+\n+  private DruidJoinQueryRel(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      Join joinRel,\n+      PartialDruidQuery partialQuery,\n+      QueryMaker queryMaker\n+  )\n+  {\n+    super(cluster, traitSet, queryMaker);\n+    this.joinRel = joinRel;\n+    this.left = joinRel.getLeft();\n+    this.right = joinRel.getRight();\n+    this.partialQuery = partialQuery;\n+  }\n+\n+  public static DruidJoinQueryRel create(final Join joinRel, final QueryMaker queryMaker)\n+  {\n+    return new DruidJoinQueryRel(\n+        joinRel.getCluster(),\n+        joinRel.getTraitSet(),\n+        joinRel,\n+        PartialDruidQuery.create(joinRel),\n+        queryMaker\n+    );\n+  }\n+\n+  @Override\n+  public PartialDruidQuery getPartialDruidQuery()\n+  {\n+    return partialQuery;\n+  }\n+\n+  @Override\n+  public Sequence<Object[]> runQuery()\n+  {\n+    // runQuery doesn't need to finalize aggregations, because the fact that runQuery is happening suggests this\n+    // is the outermost query and it will actually get run as a native query. Druid's native query layer will\n+    // finalize aggregations for the outermost query even if we don't explicitly ask it to.\n+\n+    final DruidQuery query = toDruidQuery(false);\n+    return getQueryMaker().runQuery(query);\n+  }\n+\n+  @Override\n+  public DruidJoinQueryRel withPartialQuery(final PartialDruidQuery newQueryBuilder)\n+  {\n+    return new DruidJoinQueryRel(\n+        getCluster(),\n+        getTraitSet().plusAll(newQueryBuilder.getRelTraits()),\n+        joinRel,\n+        newQueryBuilder,\n+        getQueryMaker()\n+    );\n+  }\n+\n+  @Override\n+  public int getQueryCount()\n+  {\n+    return ((DruidRel<?>) left).getQueryCount() + ((DruidRel<?>) right).getQueryCount();\n+  }\n+\n+  @Override\n+  public DruidQuery toDruidQuery(final boolean finalizeAggregations)\n+  {\n+    final DruidRel<?> leftDruidRel = (DruidRel<?>) left;\n+    final DruidQuery leftQuery = Preconditions.checkNotNull((leftDruidRel).toDruidQuery(false), \"leftQuery\");\n+    final RowSignature leftSignature = leftQuery.getOutputRowSignature();\n+    final DataSource leftDataSource;\n+\n+    final DruidRel<?> rightDruidRel = (DruidRel<?>) right;\n+    final DruidQuery rightQuery = Preconditions.checkNotNull(rightDruidRel.toDruidQuery(false), \"rightQuery\");\n+    final RowSignature rightSignature = rightQuery.getOutputRowSignature();\n+    final DataSource rightDataSource;\n+\n+    // Left rel: allow direct embedding of scans/mappings including those of joins.\n+    if (DruidRels.isScanOrMapping(leftDruidRel, true)) {\n+      leftDataSource = leftQuery.getDataSource();\n+    } else {\n+      leftDataSource = new QueryDataSource(leftQuery.getQuery());\n+    }\n+\n+    // Right rel: allow direct embedding of scans/mappings, excluduing joins (those must be done as subqueries).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI0MzUxMA=="}, "originalCommit": {"oid": "bb714014f7ac3bb9947850375e51f002c81010c7"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwNzk5NzE2OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/planner/Rules.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMDo1NTozN1rOFj-r7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwMTo1NzozOVrOFj_iSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3MTUzMw==", "bodyText": "What's the effect of replacing INSTANCE with SWAP_OUTER here?", "url": "https://github.com/apache/druid/pull/9294#discussion_r373271533", "createdAt": "2020-01-31T00:55:37Z", "author": {"login": "jon-wei"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/planner/Rules.java", "diffHunk": "@@ -101,7 +101,7 @@\n           JoinPushExpressionsRule.INSTANCE,\n           FilterAggregateTransposeRule.INSTANCE,\n           ProjectWindowTransposeRule.INSTANCE,\n-          JoinCommuteRule.INSTANCE,\n+          JoinCommuteRule.SWAP_OUTER,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18cc3767d57ca36d54f50ae55254121993f67c1e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI4NTQ1MQ==", "bodyText": "It is needed for the behavior tested by CalciteQueryTest's testFilterAndGroupByLookupUsingJoinOperatorBackwards.", "url": "https://github.com/apache/druid/pull/9294#discussion_r373285451", "createdAt": "2020-01-31T01:57:39Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/planner/Rules.java", "diffHunk": "@@ -101,7 +101,7 @@\n           JoinPushExpressionsRule.INSTANCE,\n           FilterAggregateTransposeRule.INSTANCE,\n           ProjectWindowTransposeRule.INSTANCE,\n-          JoinCommuteRule.INSTANCE,\n+          JoinCommuteRule.SWAP_OUTER,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI3MTUzMw=="}, "originalCommit": {"oid": "18cc3767d57ca36d54f50ae55254121993f67c1e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMTU5NjQ0OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/join/MapJoinableFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQwNjoyNjozMVrOFkgU6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQwNjoyNjozMVrOFkgU6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMjY5Nw==", "bodyText": "does this need to be public?", "url": "https://github.com/apache/druid/pull/9294#discussion_r373822697", "createdAt": "2020-02-02T06:26:31Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/segment/join/MapJoinableFactory.java", "diffHunk": "@@ -36,7 +36,7 @@\n   private final Map<Class<? extends DataSource>, JoinableFactory> joinableFactories;\n \n   @Inject\n-  MapJoinableFactory(Map<Class<? extends DataSource>, JoinableFactory> joinableFactories)\n+  public MapJoinableFactory(Map<Class<? extends DataSource>, JoinableFactory> joinableFactories)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86e16c2da1d99705e32abe726382753bee3cf7a3"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMTU5Njg1OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/druid/server/ClientQuerySegmentWalker.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQwNjoyNzo1MVrOFkgVJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQwNjoyNzo1MVrOFkgVJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMjc1OQ==", "bodyText": "two constructors that are very similar are confusing. Can we combine?", "url": "https://github.com/apache/druid/pull/9294#discussion_r373822759", "createdAt": "2020-02-02T06:27:51Z", "author": {"login": "suneet-s"}, "path": "server/src/main/java/org/apache/druid/server/ClientQuerySegmentWalker.java", "diffHunk": "@@ -48,18 +48,17 @@\n public class ClientQuerySegmentWalker implements QuerySegmentWalker\n {\n   private final ServiceEmitter emitter;\n-  private final CachingClusteredClient baseClient;\n+  private final QuerySegmentWalker baseClient;\n   private final QueryToolChestWarehouse warehouse;\n   private final RetryQueryRunnerConfig retryConfig;\n   private final ObjectMapper objectMapper;\n   private final ServerConfig serverConfig;\n   private final Cache cache;\n   private final CacheConfig cacheConfig;\n \n-  @Inject\n   public ClientQuerySegmentWalker(\n       ServiceEmitter emitter,\n-      CachingClusteredClient baseClient,\n+      QuerySegmentWalker baseClient,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86e16c2da1d99705e32abe726382753bee3cf7a3"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMTU5NzgzOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/planner/Rules.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQwNjozMDozM1rOFkgVpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQwNjozMDozM1rOFkgVpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMjg4Nw==", "bodyText": "todo: need a test for this", "url": "https://github.com/apache/druid/pull/9294#discussion_r373822887", "createdAt": "2020-02-02T06:30:33Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/planner/Rules.java", "diffHunk": "@@ -130,13 +130,13 @@\n           AggregateValuesRule.INSTANCE\n       );\n \n-  // Rules from VolcanoPlanner's registerAbstractRelationalRules.\n+  // Rules from VolcanoPlanner's registerAbstractRelationalRules, minus JoinCommuteRule since it's already\n+  // in DEFAULT_RULES.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86e16c2da1d99705e32abe726382753bee3cf7a3"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMTU5ODgzOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQwNjozMzozOFrOFkgWOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQwNjozMzozOFrOFkgWOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgyMzAzMw==", "bodyText": "can left and right be defined as DruidRel<?>", "url": "https://github.com/apache/druid/pull/9294#discussion_r373823033", "createdAt": "2020-02-02T06:33:38Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rel;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableList;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.Pair;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.DataSource;\n+import org.apache.druid.query.JoinDataSource;\n+import org.apache.druid.query.QueryDataSource;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.join.JoinType;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.Expressions;\n+import org.apache.druid.sql.calcite.planner.Calcites;\n+import org.apache.druid.sql.calcite.table.RowSignature;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * DruidRel that uses a {@link JoinDataSource}.\n+ */\n+public class DruidJoinQueryRel extends DruidRel<DruidJoinQueryRel>\n+{\n+  private static final TableDataSource DUMMY_DATA_SOURCE = new TableDataSource(\"__join__\");\n+  private static final double COST_FACTOR = 100.0;\n+\n+  private final PartialDruidQuery partialQuery;\n+  private final Join joinRel;\n+  private RelNode left;\n+  private RelNode right;\n+\n+  private DruidJoinQueryRel(\n+      RelOptCluster cluster,\n+      RelTraitSet traitSet,\n+      Join joinRel,\n+      PartialDruidQuery partialQuery,\n+      QueryMaker queryMaker\n+  )\n+  {\n+    super(cluster, traitSet, queryMaker);\n+    this.joinRel = joinRel;\n+    this.left = joinRel.getLeft();\n+    this.right = joinRel.getRight();\n+    this.partialQuery = partialQuery;\n+  }\n+\n+  public static DruidJoinQueryRel create(final Join joinRel, final QueryMaker queryMaker)\n+  {\n+    return new DruidJoinQueryRel(\n+        joinRel.getCluster(),\n+        joinRel.getTraitSet(),\n+        joinRel,\n+        PartialDruidQuery.create(joinRel),\n+        queryMaker\n+    );\n+  }\n+\n+  @Override\n+  public PartialDruidQuery getPartialDruidQuery()\n+  {\n+    return partialQuery;\n+  }\n+\n+  @Override\n+  public Sequence<Object[]> runQuery()\n+  {\n+    // runQuery doesn't need to finalize aggregations, because the fact that runQuery is happening suggests this\n+    // is the outermost query and it will actually get run as a native query. Druid's native query layer will\n+    // finalize aggregations for the outermost query even if we don't explicitly ask it to.\n+\n+    final DruidQuery query = toDruidQuery(false);\n+    return getQueryMaker().runQuery(query);\n+  }\n+\n+  @Override\n+  public DruidJoinQueryRel withPartialQuery(final PartialDruidQuery newQueryBuilder)\n+  {\n+    return new DruidJoinQueryRel(\n+        getCluster(),\n+        getTraitSet().plusAll(newQueryBuilder.getRelTraits()),\n+        joinRel,\n+        newQueryBuilder,\n+        getQueryMaker()\n+    );\n+  }\n+\n+  @Override\n+  public int getQueryCount()\n+  {\n+    return ((DruidRel<?>) left).getQueryCount() + ((DruidRel<?>) right).getQueryCount();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86e16c2da1d99705e32abe726382753bee3cf7a3"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMTkxOTQwOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQuery.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQxODozNTowOFrOFki9JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQxODozNTowOFrOFki9JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg2NTc2NA==", "bodyText": "Maybe add a description here since the pre-condition is on a computed value.\nSimilar comments in the rest of this file", "url": "https://github.com/apache/druid/pull/9294#discussion_r373865764", "createdAt": "2020-02-02T18:35:08Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQuery.java", "diffHunk": "@@ -126,15 +151,17 @@ public DruidQuery(\n       final boolean finalizeAggregations\n   )\n   {\n-    this.dataSource = dataSource;\n-    this.outputRowType = partialQuery.leafRel().getRowType();\n-    this.sourceRowSignature = sourceRowSignature;\n-    this.virtualColumnRegistry = VirtualColumnRegistry.create(sourceRowSignature);\n-    this.plannerContext = plannerContext;\n+    final RelDataType outputRowType = partialQuery.leafRel().getRowType();\n+    final VirtualColumnRegistry virtualColumnRegistry = VirtualColumnRegistry.create(sourceRowSignature);\n \n     // Now the fun begins.\n+    final DimFilter filter;\n+    final Projection selectProjection;\n+    final Grouping grouping;\n+    final Sorting sorting;\n+\n     if (partialQuery.getWhereFilter() != null) {\n-      this.filter = Preconditions.checkNotNull(\n+      filter = Preconditions.checkNotNull(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86e16c2da1d99705e32abe726382753bee3cf7a3"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMTkxOTk2OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQuery.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQxODozNjowNlrOFki9bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMlQxODozNjowNlrOFki9bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzg2NTgzNw==", "bodyText": "Why not checkNotNull", "url": "https://github.com/apache/druid/pull/9294#discussion_r373865837", "createdAt": "2020-02-02T18:36:06Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQuery.java", "diffHunk": "@@ -525,6 +561,29 @@ private static Sorting computeSorting(\n     return Sorting.create(orderBys, limit, projection);\n   }\n \n+  /**\n+   * Return the {@link RowSignature} corresponding to the output of a query with the given parameters.\n+   */\n+  private static RowSignature computeOutputRowSignature(\n+      final RowSignature sourceRowSignature,\n+      @Nullable final Projection selectProjection,\n+      @Nullable final Grouping grouping,\n+      @Nullable final Sorting sorting\n+  )\n+  {\n+    if (sorting != null && sorting.getProjection() != null) {\n+      return sorting.getProjection().getOutputRowSignature();\n+    } else if (grouping != null) {\n+      // Sanity check: cannot have both \"grouping\" and \"selectProjection\".\n+      Preconditions.checkState(selectProjection == null, \"Cannot have both 'grouping' and 'selectProjection'\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86e16c2da1d99705e32abe726382753bee3cf7a3"}, "originalPosition": 171}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2848, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}