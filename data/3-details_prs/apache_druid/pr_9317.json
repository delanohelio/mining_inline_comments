{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxNjM1MTk1", "number": 9317, "title": "ANY Aggregator should not skip null values implementation", "bodyText": "Modify ANY aggregator to not skip null values\nDescription\nModify ANY aggregator to not skip null values and hence return null values if that is the first value the aggregator encountered.\n\nDoubleAnyAggregatorFactory, FloatAnyAggregatorFactory, LongAnyAggregatorFactory instead of extending from SimpleDoubleAggregatorFactory (which skip null values) will instead extend AggregatorFactory and will handles null values by in it's AnyAggregator.\nAnyAggregator will have additional flag to mark if null value is found. If null value is found, all subsequent values will be skipped.\nAnyAggregator can return null value if null value is he first value the aggregator encountered.\n\nThis PR has:\n\n been self-reviewed.\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added or updated version, license, or notice information in licenses.yaml\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths.\n added integration tests.\n been tested in a test Druid cluster.", "createdAt": "2020-02-05T23:24:23Z", "url": "https://github.com/apache/druid/pull/9317", "merged": true, "mergeCommit": {"oid": "c30579e47b2df3c8c86b782a015a5a989102f0fb"}, "closed": true, "closedAt": "2020-02-12T22:01:42Z", "author": {"login": "maytasm"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBeq4oAH2gAyMzcxNjM1MTk1OjU5NDg4ZTBjZTZiMzg3NzA2NzNlYTc4NmQzOWU3MGQ4ZWQ5Y2U2M2I=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcDtrwzgFqTM1NzgyMDI0OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "59488e0ce6b38770673ea786d39e70d8ed9ce63b", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/59488e0ce6b38770673ea786d39e70d8ed9ce63b", "committedDate": "2020-02-05T23:24:00Z", "message": "ANY Aggregator should not skip null values implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4344b4a6020f7f0c9e5416a32e6cb31ee8d5feb4", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/4344b4a6020f7f0c9e5416a32e6cb31ee8d5feb4", "committedDate": "2020-02-06T21:23:13Z", "message": "add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "68ac8de271d290f798b073e699a9d08aea1dee1b", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/68ac8de271d290f798b073e699a9d08aea1dee1b", "committedDate": "2020-02-07T00:35:30Z", "message": "add more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e68e9ee9b3ee94ba3ff746c0c2c8d994b49110c4", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/e68e9ee9b3ee94ba3ff746c0c2c8d994b49110c4", "committedDate": "2020-02-07T00:51:19Z", "message": "Update documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/e224eedf9ab1b385447d677b38d39c5f58eafe73", "committedDate": "2020-02-07T01:38:36Z", "message": "add more tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODM2MDE1", "url": "https://github.com/apache/druid/pull/9317#pullrequestreview-356836015", "createdAt": "2020-02-11T17:07:59Z", "commit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzowNzo1OVrOFoRdzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNzowNzo1OVrOFoRdzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3MzUxNw==", "bodyText": "I think we should re-write this to explain why someone would use this aggregator similar to how it's explained in the snowflake docs - https://docs.snowflake.net/manuals/sql-reference/functions/any_value.html\nI'm not sure where the correct place in the docs is to explain this - since technically this is the spec for the native query and we have another page with a spec for sql.\nHere's my suggestion for the why:\nANY aggregator can be used to simplify and optimize the performance of GROUP BY statements. A common problem for many queries is that the result of a query with a GROUP BY clause can only contain expressions used in the GROUP BY clause itself, or results of aggregate functions\n\nselect customer.id , customer.name , sum(orders.value)\n    from customer\n    join orders on customer.id = orders.customer_id\n    group by customer.id , customer.name;\n\nSince we know that each customer.id can have only one name, this can be optimized as\n\nselect customer.id , ANY(customer.name) , sum(orders.value)\n    from customer\n    join orders on customer.id = orders.customer_id\n    group by customer.id ;\n\nI should also point out, with the current implementation of aggregators, there is no advantage to using an ANY aggregator vs a min aggregator, but maybe that will change in the future \ud83e\udd37\u200d\u2642", "url": "https://github.com/apache/druid/pull/9317#discussion_r377773517", "createdAt": "2020-02-11T17:07:59Z", "author": {"login": "suneet-s"}, "path": "docs/querying/aggregations.md", "diffHunk": "@@ -238,7 +238,7 @@ Note that queries with first/last aggregators on a segment created with rollup e\n \n (Double/Float/Long/String) ANY aggregator cannot be used in ingestion spec, and should only be specified as part of queries.\n \n-If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any non-null value.\n+If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any value including null.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU2ODg3MzE5", "url": "https://github.com/apache/druid/pull/9317#pullrequestreview-356887319", "createdAt": "2020-02-11T18:22:42Z", "commit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMjo0MlrOFoT7xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxODoyMzo1OVrOFoT-lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxMzk1OQ==", "bodyText": "+1 to Suneet's rewording. Agreed as well that we should add the \"why\".", "url": "https://github.com/apache/druid/pull/9317#discussion_r377813959", "createdAt": "2020-02-11T18:22:42Z", "author": {"login": "sthetland"}, "path": "docs/querying/aggregations.md", "diffHunk": "@@ -238,7 +238,7 @@ Note that queries with first/last aggregators on a segment created with rollup e\n \n (Double/Float/Long/String) ANY aggregator cannot be used in ingestion spec, and should only be specified as part of queries.\n \n-If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any non-null value.\n+If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any value including null.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3MzUxNw=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxNDY3Nw==", "bodyText": "nit, adding a comma: \"If druid.generic.useDefaultValueForNull=true, this can return...\"", "url": "https://github.com/apache/druid/pull/9317#discussion_r377814677", "createdAt": "2020-02-11T18:23:59Z", "author": {"login": "sthetland"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -205,7 +205,7 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n-|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can return the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will return any non-null value of `expr`|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can return the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will return any value of `expr` including null|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NDY2MjM3", "url": "https://github.com/apache/druid/pull/9317#pullrequestreview-355466237", "createdAt": "2020-02-07T22:08:28Z", "commit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzowNjo1NlrOFnM1rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQyMjo0MzowMFrOFob3xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0OTEzNQ==", "bodyText": "I think from like a .. user satisfaction perspective, it might still be nice to prefer non-null values since it is still legitimate.", "url": "https://github.com/apache/druid/pull/9317#discussion_r376649135", "createdAt": "2020-02-07T23:06:56Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -19,103 +19,214 @@\n \n package org.apache.druid.query.aggregation.any;\n \n-import com.fasterxml.jackson.annotation.JacksonInject;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-import org.apache.druid.math.expr.ExprMacroTable;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.UOE;\n+import org.apache.druid.query.aggregation.AggregateCombiner;\n import org.apache.druid.query.aggregation.Aggregator;\n import org.apache.druid.query.aggregation.AggregatorFactory;\n import org.apache.druid.query.aggregation.AggregatorUtil;\n import org.apache.druid.query.aggregation.BufferAggregator;\n-import org.apache.druid.query.aggregation.SimpleDoubleAggregatorFactory;\n+import org.apache.druid.query.aggregation.DoubleSumAggregator;\n import org.apache.druid.query.cache.CacheKeyBuilder;\n import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.NilColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n \n import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n import java.util.Collections;\n+import java.util.Comparator;\n import java.util.List;\n+import java.util.Objects;\n \n-public class DoubleAnyAggregatorFactory extends SimpleDoubleAggregatorFactory\n+public class DoubleAnyAggregatorFactory extends AggregatorFactory\n {\n+  private static final Comparator<Double> VALUE_COMPARATOR = Comparator.nullsFirst(Double::compare);\n+\n+  private static final Aggregator NIL_AGGREGATOR = new DoubleAnyAggregator(\n+      NilColumnValueSelector.instance()\n+  )\n+  {\n+    @Override\n+    public void aggregate()\n+    {\n+      // no-op\n+    }\n+  };\n+\n+  private static final BufferAggregator NIL_BUFFER_AGGREGATOR = new DoubleAnyBufferAggregator(\n+      NilColumnValueSelector.instance()\n+  )\n+  {\n+    @Override\n+    public void aggregate(ByteBuffer buf, int position)\n+    {\n+      // no-op\n+    }\n+  };\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n   @JsonCreator\n   public DoubleAnyAggregatorFactory(\n       @JsonProperty(\"name\") String name,\n-      @JsonProperty(\"fieldName\") final String fieldName,\n-      @JsonProperty(\"expression\") @Nullable String expression,\n-      @JacksonInject ExprMacroTable macroTable\n+      @JsonProperty(\"fieldName\") final String fieldName\n   )\n   {\n-    super(macroTable, name, fieldName, expression);\n-  }\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n \n-  public DoubleAnyAggregatorFactory(String name, String fieldName)\n-  {\n-    this(name, fieldName, null, ExprMacroTable.nil());\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n   }\n \n   @Override\n-  protected double nullValue()\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n   {\n-    return Double.NaN;\n+    final BaseDoubleColumnValueSelector valueSelector = metricFactory.makeColumnValueSelector(fieldName);\n+    if (valueSelector instanceof NilColumnValueSelector) {\n+      return NIL_AGGREGATOR;\n+    } else {\n+      return new DoubleAnyAggregator(\n+          valueSelector\n+      );\n+    }\n   }\n \n   @Override\n-  protected Aggregator buildAggregator(BaseDoubleColumnValueSelector selector)\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n   {\n-    return new DoubleAnyAggregator(selector);\n+    final BaseDoubleColumnValueSelector valueSelector = metricFactory.makeColumnValueSelector(fieldName);\n+    if (valueSelector instanceof NilColumnValueSelector) {\n+      return NIL_BUFFER_AGGREGATOR;\n+    } else {\n+      return new DoubleAnyBufferAggregator(\n+          valueSelector\n+      );\n+    }\n   }\n \n   @Override\n-  protected BufferAggregator buildBufferAggregator(BaseDoubleColumnValueSelector selector)\n+  public Comparator getComparator()\n   {\n-    return new DoubleAnyBufferAggregator(selector);\n+    return VALUE_COMPARATOR;\n   }\n \n   @Override\n   @Nullable\n   public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n   {\n-    if (lhs != null) {\n-      return lhs;\n-    } else {\n-      return rhs;\n-    }\n+    return lhs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1MzI0MA==", "bodyText": "this comment seems not applicable since it is a primitive", "url": "https://github.com/apache/druid/pull/9317#discussion_r376653240", "createdAt": "2020-02-07T23:23:18Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -19,103 +19,214 @@\n \n package org.apache.druid.query.aggregation.any;\n \n-import com.fasterxml.jackson.annotation.JacksonInject;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n-import org.apache.druid.math.expr.ExprMacroTable;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.UOE;\n+import org.apache.druid.query.aggregation.AggregateCombiner;\n import org.apache.druid.query.aggregation.Aggregator;\n import org.apache.druid.query.aggregation.AggregatorFactory;\n import org.apache.druid.query.aggregation.AggregatorUtil;\n import org.apache.druid.query.aggregation.BufferAggregator;\n-import org.apache.druid.query.aggregation.SimpleDoubleAggregatorFactory;\n+import org.apache.druid.query.aggregation.DoubleSumAggregator;\n import org.apache.druid.query.cache.CacheKeyBuilder;\n import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.NilColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n \n import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n import java.util.Collections;\n+import java.util.Comparator;\n import java.util.List;\n+import java.util.Objects;\n \n-public class DoubleAnyAggregatorFactory extends SimpleDoubleAggregatorFactory\n+public class DoubleAnyAggregatorFactory extends AggregatorFactory\n {\n+  private static final Comparator<Double> VALUE_COMPARATOR = Comparator.nullsFirst(Double::compare);\n+\n+  private static final Aggregator NIL_AGGREGATOR = new DoubleAnyAggregator(\n+      NilColumnValueSelector.instance()\n+  )\n+  {\n+    @Override\n+    public void aggregate()\n+    {\n+      // no-op\n+    }\n+  };\n+\n+  private static final BufferAggregator NIL_BUFFER_AGGREGATOR = new DoubleAnyBufferAggregator(\n+      NilColumnValueSelector.instance()\n+  )\n+  {\n+    @Override\n+    public void aggregate(ByteBuffer buf, int position)\n+    {\n+      // no-op\n+    }\n+  };\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n   @JsonCreator\n   public DoubleAnyAggregatorFactory(\n       @JsonProperty(\"name\") String name,\n-      @JsonProperty(\"fieldName\") final String fieldName,\n-      @JsonProperty(\"expression\") @Nullable String expression,\n-      @JacksonInject ExprMacroTable macroTable\n+      @JsonProperty(\"fieldName\") final String fieldName\n   )\n   {\n-    super(macroTable, name, fieldName, expression);\n-  }\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n \n-  public DoubleAnyAggregatorFactory(String name, String fieldName)\n-  {\n-    this(name, fieldName, null, ExprMacroTable.nil());\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n   }\n \n   @Override\n-  protected double nullValue()\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n   {\n-    return Double.NaN;\n+    final BaseDoubleColumnValueSelector valueSelector = metricFactory.makeColumnValueSelector(fieldName);\n+    if (valueSelector instanceof NilColumnValueSelector) {\n+      return NIL_AGGREGATOR;\n+    } else {\n+      return new DoubleAnyAggregator(\n+          valueSelector\n+      );\n+    }\n   }\n \n   @Override\n-  protected Aggregator buildAggregator(BaseDoubleColumnValueSelector selector)\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n   {\n-    return new DoubleAnyAggregator(selector);\n+    final BaseDoubleColumnValueSelector valueSelector = metricFactory.makeColumnValueSelector(fieldName);\n+    if (valueSelector instanceof NilColumnValueSelector) {\n+      return NIL_BUFFER_AGGREGATOR;\n+    } else {\n+      return new DoubleAnyBufferAggregator(\n+          valueSelector\n+      );\n+    }\n   }\n \n   @Override\n-  protected BufferAggregator buildBufferAggregator(BaseDoubleColumnValueSelector selector)\n+  public Comparator getComparator()\n   {\n-    return new DoubleAnyBufferAggregator(selector);\n+    return VALUE_COMPARATOR;\n   }\n \n   @Override\n   @Nullable\n   public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n   {\n-    if (lhs != null) {\n-      return lhs;\n-    } else {\n-      return rhs;\n-    }\n+    return lhs;\n+  }\n+\n+  @Override\n+  public AggregateCombiner makeAggregateCombiner()\n+  {\n+    throw new UOE(\"DoubleAnyAggregatorFactory is not supported during ingestion for rollup\");\n   }\n \n   @Override\n   public AggregatorFactory getCombiningFactory()\n   {\n-    return new DoubleAnyAggregatorFactory(name, name, null, macroTable);\n+    return new DoubleAnyAggregatorFactory(name, name);\n   }\n \n   @Override\n   public List<AggregatorFactory> getRequiredColumns()\n   {\n-    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName, expression, macroTable));\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    // handle \"NaN\" / \"Infinity\" values serialized as strings in JSON\n+    if (object instanceof String) {\n+      return Double.parseDouble((String) object);\n+    }\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Collections.singletonList(fieldName);\n   }\n \n   @Override\n   public byte[] getCacheKey()\n   {\n     return new CacheKeyBuilder(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n         .appendString(fieldName)\n-        .appendString(expression)\n         .build();\n   }\n \n+  @Override\n+  public String getTypeName()\n+  {\n+    // if we don't pretend to be a primitive, group by v1 gets sad and doesn't work because no complex type serde", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkyOTg5Ng==", "bodyText": "I sort of think this should just be simplified so it is less confusing, maybe something like:\n\nReturns any value of expr, including null.\n\nAlso, expr does not need to be numeric since you implemented a string any aggregator in the previous PR.", "url": "https://github.com/apache/druid/pull/9317#discussion_r377929896", "createdAt": "2020-02-11T22:10:11Z", "author": {"login": "clintropolis"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -205,7 +205,7 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n-|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can return the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will return any non-null value of `expr`|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can return the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will return any value of `expr` including null|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzgxNDY3Nw=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzMTQ5Mg==", "bodyText": "I'm not sure this is really worth mentioning. This is the standard case for aggregator implementations, since it is less common for an agg implementation to have magic null handling wrapped around it than just handling the nulls itself.", "url": "https://github.com/apache/druid/pull/9317#discussion_r377931492", "createdAt": "2020-02-11T22:13:55Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -19,44 +19,35 @@\n \n package org.apache.druid.query.aggregation.any;\n \n-import org.apache.druid.query.aggregation.Aggregator;\n-import org.apache.druid.query.aggregation.NullableNumericAggregator;\n-import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n \n+import javax.annotation.Nullable;\n+\n /**\n- * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which extends from\n- * {@link NullableNumericAggregatorFactory}. If null needs to be handle, then {@link NullableNumericAggregatorFactory}\n- * will wrap this aggregator in {@link NullableNumericAggregator} and can handle all null in that class.\n- * Hence, no null will ever be pass into this aggregator from the valueSelector.\n+ * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which has no special null handling logic.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNDA3NQ==", "bodyText": "nit: I think this 0 offset variable makes the put and get operations more complicated than they need to be, suggest just dropping this and not adding or removing anything.", "url": "https://github.com/apache/druid/pull/9317#discussion_r377934075", "createdAt": "2020-02-11T22:19:55Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseNullableColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Base type for buffer based 'any' aggregator for primitive numeric column selectors\n+ */\n+public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n+    implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final int IS_FOUND_FLAG_OFFSET_POSITION = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNTA0MA==", "bodyText": "Please use NullHandling.IS_NULL_BYTE and NullHandling.IS_NOT_NULL_BYTE to be consistent with other aggregators, at least for the 'is null' byte.", "url": "https://github.com/apache/druid/pull/9317#discussion_r377935040", "createdAt": "2020-02-11T22:22:00Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseNullableColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Base type for buffer based 'any' aggregator for primitive numeric column selectors\n+ */\n+public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n+    implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzODIyMA==", "bodyText": "nit: suggest just making this package private and having subclasses use this directly in their putValue implementations instead of getFoundValueStoredPosition function call, and maybe just calling it VALUE_OFFSET or FOUND_VALUE_OFFSET since the position seems redundant.", "url": "https://github.com/apache/druid/pull/9317#discussion_r377938220", "createdAt": "2020-02-11T22:29:20Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseNullableColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Base type for buffer based 'any' aggregator for primitive numeric column selectors\n+ */\n+public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n+    implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final int IS_FOUND_FLAG_OFFSET_POSITION = 0;\n+  private static final int IS_NULL_FLAG_OFFSET_POSITION = IS_FOUND_FLAG_OFFSET_POSITION + Byte.BYTES;\n+  private static final int FOUND_VALUE_OFFSET_POSITION = IS_NULL_FLAG_OFFSET_POSITION + Byte.BYTES;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0MjExNQ==", "bodyText": "Why this change? I don't think it is correct, since this stuff should only be set if it was a QueryInterruptedException", "url": "https://github.com/apache/druid/pull/9317#discussion_r377942115", "createdAt": "2020-02-11T22:38:31Z", "author": {"login": "clintropolis"}, "path": "server/src/main/java/org/apache/druid/server/QueryLifecycle.java", "diffHunk": "@@ -318,14 +318,12 @@ public void emitLogsAndMetrics(\n \n       if (e != null) {\n         statsMap.put(\"exception\", e.toString());\n-\n-        if (e instanceof QueryInterruptedException) {\n-          // Mimic behavior from QueryResource, where this code was originally taken from.\n-          log.noStackTrace().warn(e, \"Exception while processing queryId [%s]\", baseQuery.getId());\n-          statsMap.put(\"interrupted\", true);\n-          statsMap.put(\"reason\", e.toString());\n-        }\n+        // Mimic behavior from QueryResource, where this code was originally taken from.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk0NDAwNw==", "bodyText": "Further, since is null is only going to be either 0 or 1, you save a byte per agg result and could use any of the high bits of this null byte to set whether or not you have found a value. Instead of an offset for null flag, you define a bit mask and your found check becomes something like buf.get(position) & FOUND_MASK == FOUND_MASK or whatever.", "url": "https://github.com/apache/druid/pull/9317#discussion_r377944007", "createdAt": "2020-02-11T22:43:00Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseNullableColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Base type for buffer based 'any' aggregator for primitive numeric column selectors\n+ */\n+public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n+    implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final int IS_FOUND_FLAG_OFFSET_POSITION = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzkzNDA3NQ=="}, "originalCommit": {"oid": "e224eedf9ab1b385447d677b38d39c5f58eafe73"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "511d33da8e22482073ae49ca1d965548f110b391", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/511d33da8e22482073ae49ca1d965548f110b391", "committedDate": "2020-02-11T23:27:38Z", "message": "Merge remote-tracking branch 'upstream/master' into IMPLY-1889"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "094425a6605b2646c1ac87d03130009ddac05cec", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/094425a6605b2646c1ac87d03130009ddac05cec", "committedDate": "2020-02-12T02:08:32Z", "message": "address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00eb20ed80c3041d688818468cd0c15d3ba91663", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/00eb20ed80c3041d688818468cd0c15d3ba91663", "committedDate": "2020-02-12T02:21:16Z", "message": "optimize StringAnyBufferAggregator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9ef751385492faca5d57fbf05d0c7a71a1ff7e6", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/b9ef751385492faca5d57fbf05d0c7a71a1ff7e6", "committedDate": "2020-02-12T08:14:24Z", "message": "fix failing tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MzI0ODQ0", "url": "https://github.com/apache/druid/pull/9317#pullrequestreview-357324844", "createdAt": "2020-02-12T10:05:02Z", "commit": {"oid": "b9ef751385492faca5d57fbf05d0c7a71a1ff7e6"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDowNTowMlrOFoodzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxMDowOTo1N1rOFoon6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1MDM0OA==", "bodyText": "typo 'encoutnered' is causing CI failure", "url": "https://github.com/apache/druid/pull/9317#discussion_r378150348", "createdAt": "2020-02-12T10:05:02Z", "author": {"login": "clintropolis"}, "path": "docs/querying/aggregations.md", "diffHunk": "@@ -238,7 +238,7 @@ Note that queries with first/last aggregators on a segment created with rollup e\n \n (Double/Float/Long/String) ANY aggregator cannot be used in ingestion spec, and should only be specified as part of queries.\n \n-If `druid.generic.useDefaultValueForNull=true` aggregation can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then aggregation will returns any value including null.\n+Returns any value including null. This aggregator simplify and optimize the performance by returning the first encoutnered value (including null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9ef751385492faca5d57fbf05d0c7a71a1ff7e6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1MTEzNQ==", "bodyText": "nit: should be 'This aggregator can simplify..'\nShould this note also be added to the description of string any value?", "url": "https://github.com/apache/druid/pull/9317#discussion_r378151135", "createdAt": "2020-02-12T10:06:28Z", "author": {"login": "clintropolis"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -205,7 +205,7 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n-|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can return the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will return any value of `expr` including null|\n+|`ANY_VALUE(expr)`|Returns any value of `expr` including null. `expr` must be numeric. This aggregator simplify and optimize the performance by returning the first encoutnered value (including null)|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9ef751385492faca5d57fbf05d0c7a71a1ff7e6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODE1MjkzOQ==", "bodyText": "super super nit, but can you use hex? (0x02 and 0x01 for BYTE_FLAG_NULL_MASK)", "url": "https://github.com/apache/druid/pull/9317#discussion_r378152939", "createdAt": "2020-02-12T10:09:57Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyBufferAggregator.java", "diffHunk": "@@ -32,11 +32,11 @@\n public abstract class NumericAnyBufferAggregator<TSelector extends BaseNullableColumnValueSelector>\n     implements BufferAggregator\n {\n-  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n-  private static final byte BYTE_FLAG_IS_SET = 1;\n-  private static final int IS_FOUND_FLAG_OFFSET_POSITION = 0;\n-  private static final int IS_NULL_FLAG_OFFSET_POSITION = IS_FOUND_FLAG_OFFSET_POSITION + Byte.BYTES;\n-  private static final int FOUND_VALUE_OFFSET_POSITION = IS_NULL_FLAG_OFFSET_POSITION + Byte.BYTES;\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  private static final byte BYTE_FLAG_FOUND_MASK = 0b0010;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9ef751385492faca5d57fbf05d0c7a71a1ff7e6"}, "originalPosition": 11}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3e645c75948c58a48767fd3e3904d784c1c7222", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/c3e645c75948c58a48767fd3e3904d784c1c7222", "committedDate": "2020-02-12T18:20:10Z", "message": "address pr comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3ODIwMjQ5", "url": "https://github.com/apache/druid/pull/9317#pullrequestreview-357820249", "createdAt": "2020-02-12T22:01:23Z", "commit": {"oid": "c3e645c75948c58a48767fd3e3904d784c1c7222"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2859, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}