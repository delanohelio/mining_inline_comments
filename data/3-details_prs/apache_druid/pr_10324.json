{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0MjMwMzYw", "number": 10324, "title": "SQL support for union datasources.", "bodyText": "Exposed via the \"UNION ALL\" operator. This means that there are now two\ndifferent implementations of UNION ALL: one at the top level of a query\nthat works by concatenating subquery results, and one at the table level\nthat works by creating a UnionDataSource.\nThe SQL documentation is updated to discuss these two use cases and how\nthey behave.\nFuture work could unify these by building support for a native datasource\nthat represents the union of multiple subqueries. (Today, UnionDataSource\ncan only represent the union of tables, not subqueries.)", "createdAt": "2020-08-26T22:16:38Z", "url": "https://github.com/apache/druid/pull/10324", "merged": true, "mergeCommit": {"oid": "5cd7610fb61405108820de4b2173e690b8df3011"}, "closed": true, "closedAt": "2020-08-28T14:57:06Z", "author": {"login": "gianm"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdCzbr8gH2gAyNDc0MjMwMzYwOjgwNTAyMjE3ZTRlYWYzMmNlYWYzNjBkZjJkYjFhNTFjM2ViNjZjMTQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdyj2QHgFqTU3NDAwMjQ4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "80502217e4eaf32ceaf360df2db1a51c3eb66c14", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/80502217e4eaf32ceaf360df2db1a51c3eb66c14", "committedDate": "2020-08-26T22:20:29Z", "message": "SQL support for union datasources.\n\nExposed via the \"UNION ALL\" operator. This means that there are now two\ndifferent implementations of UNION ALL: one at the top level of a query\nthat works by concatenating subquery results, and one at the table level\nthat works by creating a UnionDataSource.\n\nThe SQL documentation is updated to discuss these two use cases and how\nthey behave.\n\nFuture work could unify these by building support for a native datasource\nthat represents the union of multiple subqueries. (Today, UnionDataSource\ncan only represent the union of tables, not subqueries.)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "80502217e4eaf32ceaf360df2db1a51c3eb66c14", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/80502217e4eaf32ceaf360df2db1a51c3eb66c14", "committedDate": "2020-08-26T22:20:29Z", "message": "SQL support for union datasources.\n\nExposed via the \"UNION ALL\" operator. This means that there are now two\ndifferent implementations of UNION ALL: one at the top level of a query\nthat works by concatenating subquery results, and one at the table level\nthat works by creating a UnionDataSource.\n\nThe SQL documentation is updated to discuss these two use cases and how\nthey behave.\n\nFuture work could unify these by building support for a native datasource\nthat represents the union of multiple subqueries. (Today, UnionDataSource\ncan only represent the union of tables, not subqueries.)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2NTAzMDEx", "url": "https://github.com/apache/druid/pull/10324#pullrequestreview-476503011", "createdAt": "2020-08-27T08:35:20Z", "commit": {"oid": "80502217e4eaf32ceaf360df2db1a51c3eb66c14"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwODozNToyMFrOHIGHTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwODozNToyMFrOHIGHTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1MDgzMQ==", "bodyText": "nit: adding an error message will be helpful.", "url": "https://github.com/apache/druid/pull/10324#discussion_r478250831", "createdAt": "2020-08-27T08:35:20Z", "author": {"login": "abhishekagarwal87"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      Preconditions.checkState(firstDruidRel instanceof DruidQueryRel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80502217e4eaf32ceaf360df2db1a51c3eb66c14"}, "originalPosition": 100}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f57e18d6ca7b4e03affa41c1e62080cb600ea880", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/f57e18d6ca7b4e03affa41c1e62080cb600ea880", "committedDate": "2020-08-27T15:28:44Z", "message": "Fixes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87a01867a002df369bacbb1f3cf27ddbb80072a8", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/87a01867a002df369bacbb1f3cf27ddbb80072a8", "committedDate": "2020-08-27T15:29:33Z", "message": "Error message for sanity check."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6c8c9bc45ac239f8543203ee73984026509196a", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/a6c8c9bc45ac239f8543203ee73984026509196a", "committedDate": "2020-08-27T15:40:54Z", "message": "Additional test fixes."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2OTA3NDgz", "url": "https://github.com/apache/druid/pull/10324#pullrequestreview-476907483", "createdAt": "2020-08-27T16:51:25Z", "commit": {"oid": "a6c8c9bc45ac239f8543203ee73984026509196a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjo1MToyNVrOHIY-hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjo1MToyNVrOHIY-hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU1OTg3OA==", "bodyText": "if this ever happens, an exception containing the actual stage name will be useful in debugging.", "url": "https://github.com/apache/druid/pull/10324#discussion_r478559878", "createdAt": "2020-08-27T16:51:25Z", "author": {"login": "abhishekagarwal87"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      Preconditions.checkState(firstDruidRel instanceof DruidQueryRel, \"Expected first rel to be a DruidQueryRel\");\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              unionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    }\n+  }\n+\n+  private static boolean isUnionCompatible(final DruidRel<?> first, final DruidRel<?> second)\n+  {\n+    final Optional<List<String>> columnNames = getColumnNamesIfTableOrUnion(first);\n+    return columnNames.isPresent() && columnNames.equals(getColumnNamesIfTableOrUnion(second));\n+  }\n+\n+  static Optional<List<String>> getColumnNamesIfTableOrUnion(final DruidRel<?> druidRel)\n+  {\n+    final PartialDruidQuery partialQuery = druidRel.getPartialDruidQuery();\n+\n+    final Optional<DruidTable> druidTable =\n+        DruidRels.druidTableIfLeafRel(druidRel)\n+                 .filter(table -> table.getDataSource() instanceof TableDataSource);\n+\n+    if (druidTable.isPresent() && DruidRels.isScanOrMapping(druidRel, false)) {\n+      // This rel is a table scan or mapping.\n+\n+      if (partialQuery.stage() == PartialDruidQuery.Stage.SCAN) {\n+        return Optional.of(druidTable.get().getRowSignature().getColumnNames());\n+      } else {\n+        // Sanity check. Expected to be true due to the \"scan or mapping\" check.\n+        Preconditions.checkState(partialQuery.stage() == PartialDruidQuery.Stage.SELECT_PROJECT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6c8c9bc45ac239f8543203ee73984026509196a"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2OTA3NjE5", "url": "https://github.com/apache/druid/pull/10324#pullrequestreview-476907619", "createdAt": "2020-08-27T16:51:36Z", "commit": {"oid": "a6c8c9bc45ac239f8543203ee73984026509196a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjo1MTozNlrOHIY-5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjo1MTozNlrOHIY-5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU1OTk3Mg==", "bodyText": "same comment here. will be useful to know both the table signature size as well as source count.", "url": "https://github.com/apache/druid/pull/10324#discussion_r478559972", "createdAt": "2020-08-27T16:51:36Z", "author": {"login": "abhishekagarwal87"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      Preconditions.checkState(firstDruidRel instanceof DruidQueryRel, \"Expected first rel to be a DruidQueryRel\");\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              unionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    }\n+  }\n+\n+  private static boolean isUnionCompatible(final DruidRel<?> first, final DruidRel<?> second)\n+  {\n+    final Optional<List<String>> columnNames = getColumnNamesIfTableOrUnion(first);\n+    return columnNames.isPresent() && columnNames.equals(getColumnNamesIfTableOrUnion(second));\n+  }\n+\n+  static Optional<List<String>> getColumnNamesIfTableOrUnion(final DruidRel<?> druidRel)\n+  {\n+    final PartialDruidQuery partialQuery = druidRel.getPartialDruidQuery();\n+\n+    final Optional<DruidTable> druidTable =\n+        DruidRels.druidTableIfLeafRel(druidRel)\n+                 .filter(table -> table.getDataSource() instanceof TableDataSource);\n+\n+    if (druidTable.isPresent() && DruidRels.isScanOrMapping(druidRel, false)) {\n+      // This rel is a table scan or mapping.\n+\n+      if (partialQuery.stage() == PartialDruidQuery.Stage.SCAN) {\n+        return Optional.of(druidTable.get().getRowSignature().getColumnNames());\n+      } else {\n+        // Sanity check. Expected to be true due to the \"scan or mapping\" check.\n+        Preconditions.checkState(partialQuery.stage() == PartialDruidQuery.Stage.SELECT_PROJECT);\n+\n+        // Apply the mapping (with additional sanity checks).\n+        final RowSignature tableSignature = druidTable.get().getRowSignature();\n+        final Mappings.TargetMapping mapping = partialQuery.getSelectProject().getMapping();\n+        Preconditions.checkState(mapping.getSourceCount() == tableSignature.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6c8c9bc45ac239f8543203ee73984026509196a"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc2OTA4MTM1", "url": "https://github.com/apache/druid/pull/10324#pullrequestreview-476908135", "createdAt": "2020-08-27T16:52:17Z", "commit": {"oid": "a6c8c9bc45ac239f8543203ee73984026509196a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjo1MjoxN1rOHIZAag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjo1MjoxN1rOHIZAag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU2MDM2Mg==", "bodyText": "maybe add the class name of firstDruidRel in exception message?", "url": "https://github.com/apache/druid/pull/10324#discussion_r478560362", "createdAt": "2020-08-27T16:52:17Z", "author": {"login": "abhishekagarwal87"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      Preconditions.checkState(firstDruidRel instanceof DruidQueryRel, \"Expected first rel to be a DruidQueryRel\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6c8c9bc45ac239f8543203ee73984026509196a"}, "originalPosition": 100}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9226a449b9cdafadc583bab883f094bdbe182ed6", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/9226a449b9cdafadc583bab883f094bdbe182ed6", "committedDate": "2020-08-27T22:13:46Z", "message": "Add some error messages."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTM1ODQw", "url": "https://github.com/apache/druid/pull/10324#pullrequestreview-477135840", "createdAt": "2020-08-27T22:51:05Z", "commit": {"oid": "9226a449b9cdafadc583bab883f094bdbe182ed6"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjo1MTowNlrOHIj2JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMzoxMjoxNFrOHIkRxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODczNzk1Ng==", "bodyText": "nit: this could be an else if of the previous if that assigns signature if it was previously null", "url": "https://github.com/apache/druid/pull/10324#discussion_r478737956", "createdAt": "2020-08-27T22:51:06Z", "author": {"login": "clintropolis"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidUnionDataSourceRel.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rel;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.DataSource;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.query.UnionDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.table.RowSignatures;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Represents a query on top of a {@link UnionDataSource}. This is used to represent a \"UNION ALL\" of regular table\n+ * datasources.\n+ *\n+ * See {@link DruidUnionRel} for a version that can union any set of queries together (not just regular tables),\n+ * but also must be the outermost rel of a query plan. In the future we expect that {@link UnionDataSource} will gain\n+ * the ability to union query datasources together, and then this class could replace {@link DruidUnionRel}.\n+ */\n+public class DruidUnionDataSourceRel extends DruidRel<DruidUnionDataSourceRel>\n+{\n+  private static final TableDataSource DUMMY_DATA_SOURCE = new TableDataSource(\"__union__\");\n+\n+  private final Union unionRel;\n+  private final List<String> unionColumnNames;\n+  private final PartialDruidQuery partialQuery;\n+\n+  private DruidUnionDataSourceRel(\n+      final RelOptCluster cluster,\n+      final RelTraitSet traitSet,\n+      final Union unionRel,\n+      final List<String> unionColumnNames,\n+      final PartialDruidQuery partialQuery,\n+      final QueryMaker queryMaker\n+  )\n+  {\n+    super(cluster, traitSet, queryMaker);\n+    this.unionRel = unionRel;\n+    this.unionColumnNames = unionColumnNames;\n+    this.partialQuery = partialQuery;\n+  }\n+\n+  public static DruidUnionDataSourceRel create(\n+      final Union unionRel,\n+      final List<String> unionColumnNames,\n+      final QueryMaker queryMaker\n+  )\n+  {\n+    return new DruidUnionDataSourceRel(\n+        unionRel.getCluster(),\n+        unionRel.getTraitSet(),\n+        unionRel,\n+        unionColumnNames,\n+        PartialDruidQuery.create(unionRel),\n+        queryMaker\n+    );\n+  }\n+\n+  public List<String> getUnionColumnNames()\n+  {\n+    return unionColumnNames;\n+  }\n+\n+  @Override\n+  public PartialDruidQuery getPartialDruidQuery()\n+  {\n+    return partialQuery;\n+  }\n+\n+  @Override\n+  public DruidUnionDataSourceRel withPartialQuery(final PartialDruidQuery newQueryBuilder)\n+  {\n+    return new DruidUnionDataSourceRel(\n+        getCluster(),\n+        getTraitSet().plusAll(newQueryBuilder.getRelTraits()),\n+        unionRel,\n+        unionColumnNames,\n+        newQueryBuilder,\n+        getQueryMaker()\n+    );\n+  }\n+\n+  @Override\n+  public Sequence<Object[]> runQuery()\n+  {\n+    // runQuery doesn't need to finalize aggregations, because the fact that runQuery is happening suggests this\n+    // is the outermost query and it will actually get run as a native query. Druid's native query layer will\n+    // finalize aggregations for the outermost query even if we don't explicitly ask it to.\n+\n+    return getQueryMaker().runQuery(toDruidQuery(false));\n+  }\n+\n+  @Override\n+  public DruidQuery toDruidQuery(final boolean finalizeAggregations)\n+  {\n+    final List<TableDataSource> dataSources = new ArrayList<>();\n+    RowSignature signature = null;\n+\n+    for (final RelNode relNode : unionRel.getInputs()) {\n+      final DruidRel<?> druidRel = (DruidRel<?>) relNode;\n+      if (!DruidRels.isScanOrMapping(druidRel, false)) {\n+        throw new CannotBuildQueryException(druidRel);\n+      }\n+\n+      final DruidQuery query = druidRel.toDruidQuery(false);\n+      final DataSource dataSource = query.getDataSource();\n+      if (!(dataSource instanceof TableDataSource)) {\n+        throw new CannotBuildQueryException(druidRel);\n+      }\n+\n+      if (signature == null) {\n+        signature = query.getOutputRowSignature();\n+      }\n+\n+      if (signature.getColumnNames().equals(query.getOutputRowSignature().getColumnNames())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9226a449b9cdafadc583bab883f094bdbe182ed6"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MDM1MA==", "bodyText": "nit: would the signatures themselves rather than the count be more useful?", "url": "https://github.com/apache/druid/pull/10324#discussion_r478740350", "createdAt": "2020-08-27T22:58:09Z", "author": {"login": "clintropolis"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.java.util.common.ISE;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      if (!(firstDruidRel instanceof DruidQueryRel)) {\n+        throw new ISE(\"Expected first rel to be a DruidQueryRel, but it was %s\", firstDruidRel.getClass().getName());\n+      }\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              unionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    }\n+  }\n+\n+  private static boolean isUnionCompatible(final DruidRel<?> first, final DruidRel<?> second)\n+  {\n+    final Optional<List<String>> columnNames = getColumnNamesIfTableOrUnion(first);\n+    return columnNames.isPresent() && columnNames.equals(getColumnNamesIfTableOrUnion(second));\n+  }\n+\n+  static Optional<List<String>> getColumnNamesIfTableOrUnion(final DruidRel<?> druidRel)\n+  {\n+    final PartialDruidQuery partialQuery = druidRel.getPartialDruidQuery();\n+\n+    final Optional<DruidTable> druidTable =\n+        DruidRels.druidTableIfLeafRel(druidRel)\n+                 .filter(table -> table.getDataSource() instanceof TableDataSource);\n+\n+    if (druidTable.isPresent() && DruidRels.isScanOrMapping(druidRel, false)) {\n+      // This rel is a table scan or mapping.\n+\n+      if (partialQuery.stage() == PartialDruidQuery.Stage.SCAN) {\n+        return Optional.of(druidTable.get().getRowSignature().getColumnNames());\n+      } else {\n+        // Sanity check. Expected to be true due to the \"scan or mapping\" check.\n+        if (partialQuery.stage() != PartialDruidQuery.Stage.SELECT_PROJECT) {\n+          throw new ISE(\"Expected stage %s but got %s\", PartialDruidQuery.Stage.SELECT_PROJECT, partialQuery.stage());\n+        }\n+\n+        // Apply the mapping (with additional sanity checks).\n+        final RowSignature tableSignature = druidTable.get().getRowSignature();\n+        final Mappings.TargetMapping mapping = partialQuery.getSelectProject().getMapping();\n+\n+        if (mapping.getSourceCount() != tableSignature.size()) {\n+          throw new ISE(\n+              \"Expected mapping with %d columns but got %d columns\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9226a449b9cdafadc583bab883f094bdbe182ed6"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0NTAzMA==", "bodyText": "nit: I wonder if the instanceof checks here are something that should be pushed into a couple of methods on DruidRel (one to check if is scan/projection one to check if is 'external' (or is there a better word?) scan/projection for join/union)", "url": "https://github.com/apache/druid/pull/10324#discussion_r478745030", "createdAt": "2020-08-27T23:12:14Z", "author": {"login": "clintropolis"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidRels.java", "diffHunk": "@@ -59,12 +59,14 @@ public static boolean isScanOrMapping(final DruidRel<?> druidRel, final boolean\n   /**\n    * Check if a druidRel is a simple table scan or a scan + projection.\n    *\n-   * @param druidRel  the rel to check\n-   * @param canBeJoin consider a 'join' that doesn't do anything fancy to be a scan-or-mapping too.\n+   * @param druidRel         the rel to check\n+   * @param canBeJoinOrUnion consider a {@link DruidJoinQueryRel} or {@link DruidUnionDataSourceRel} as possible\n+   *                         scans-and-mappings too.\n    */\n-  private static boolean isScanOrProject(final DruidRel<?> druidRel, final boolean canBeJoin)\n+  private static boolean isScanOrProject(final DruidRel<?> druidRel, final boolean canBeJoinOrUnion)\n   {\n-    if (druidRel instanceof DruidQueryRel || (canBeJoin && druidRel instanceof DruidJoinQueryRel)) {\n+    if (druidRel instanceof DruidQueryRel || (canBeJoinOrUnion && (druidRel instanceof DruidJoinQueryRel", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9226a449b9cdafadc583bab883f094bdbe182ed6"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc0MDAyNDg3", "url": "https://github.com/apache/druid/pull/10324#pullrequestreview-574002487", "createdAt": "2021-01-22T07:19:07Z", "commit": {"oid": "9226a449b9cdafadc583bab883f094bdbe182ed6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwNzoxOTowOFrOIYYHnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwNzoxOTowOFrOIYYHnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQzMTkwMw==", "bodyText": "Hi, is there a particular reason firstDruidRel is of DruidRel<?> but secondDruidRel is DruidQueryRel?\nHaving it DruidQueryRel creates issues with top level UNION ALL when the second rel contains a subquery.\nOn the same PR, matches(RelOptRuleCall call) in DruidJoinRule.java has both parts typed as DruidRel<?>\nI don't know if it's appropriate to discuss findings in closed PR, but as my issue is completely confined with changes specified here, I took the liberty to discuss them.", "url": "https://github.com/apache/druid/pull/10324#discussion_r562431903", "createdAt": "2021-01-22T07:19:08Z", "author": {"login": "laserscout"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.java.util.common.ISE;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9226a449b9cdafadc583bab883f094bdbe182ed6"}, "originalPosition": 74}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3497, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}