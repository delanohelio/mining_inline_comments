{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc4ODk4Njkx", "number": 10350, "title": "Support SearchQueryDimFilter in sql via new methods", "bodyText": "Description\nNative druid query has SearchQueryDimFilter that is faster and supports case-insensitive search. This patch adds the SearchQueryDimFilter via two new functions - contains_str and icontains_str\nI have not chosen contains/icontains name as the function names since contains is a standard operator in calcite similar to like. However, in calcite, contains only support periods/date as an input . To avoid conflicts with contains on strings, I have chosen different names altogether.\nFrom org.apache.calcite.sql.SqlKind\n/**\n   * The \"CONTAINS\" operator for periods.\n   */\n  CONTAINS,\n\nThe method name for case insensitive search is different as it is more in line with standard SQL (like and ilike). The other reason is that we can in the future add more arguments to support extra functionality. E.g. to support fragment search, one can do something as follows\ncontains_str(expr, string1, string2, string3,..)\nicontains_str(expr, string1, string2, string3,..)\nIt seems cleaner to carve out a different function for case insensitive search so that the method signature is cleaner and easier to understand.\nI didn't add the support for multi-string input right away as I could not find a way to specify a type checker as follows\n.operandTypeChecker(OperandTypes.sequence(\"expr, string\", OperandTypes.repeat(\n           SqlOperandCountRanges.from(1),\n           OperandTypes.and(OperandTypes.LITERAL, OperandTypes.STRING)\n       )))\n\nAbove is not a valid syntax as OperandTypes.sequence takes SqlSingleOperandTypeChecker as input while OperandTypes.repeat returns CompositeOperandTypeChecker.\n\nThis PR has:\n\n been self-reviewed.\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added or updated version, license, or notice information in licenses.yaml\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths, ensuring the threshold for code coverage is met.\n added integration tests.\n been tested in a test Druid cluster.\n\n\nKey added classes in this PR\n\nContainsOperatorConversion", "createdAt": "2020-09-03T20:07:11Z", "url": "https://github.com/apache/druid/pull/10350", "merged": true, "mergeCommit": {"oid": "f5e2645bbb92254dfd2de8696d85acc2be71e68d"}, "closed": true, "closedAt": "2020-09-14T16:57:54Z", "author": {"login": "abhishekagarwal87"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdFWN7hgH2gAyNDc4ODk4NjkxOjY2NDhlNjdkOGM5NTY4ZDU5MzZmODJiNDk1Y2MyNGRlYTU1MTA3NjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdI2MR9gFqTQ4Nzk2OTU4Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6648e67d8c9568d5936f82b495cc24dea5510762", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/6648e67d8c9568d5936f82b495cc24dea5510762", "committedDate": "2020-09-03T19:59:59Z", "message": "Support SearchQueryDimFilter in sql via new methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e86280ad4b9e006fb58bc54e818cd89f4fe1bae", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/6e86280ad4b9e006fb58bc54e818cd89f4fe1bae", "committedDate": "2020-09-04T12:49:45Z", "message": "Contains is a reserved word"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "176d71272f6629fed5b0924b54c4f78ecef94e3f", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/176d71272f6629fed5b0924b54c4f78ecef94e3f", "committedDate": "2020-09-04T12:51:16Z", "message": "revert unnecessary change"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NTg1MjMw", "url": "https://github.com/apache/druid/pull/10350#pullrequestreview-485585230", "createdAt": "2020-09-10T05:07:24Z", "commit": {"oid": "176d71272f6629fed5b0924b54c4f78ecef94e3f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNTowNzoyNVrOHPjLHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNTowNzoyNVrOHPjLHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2Njk3Mw==", "bodyText": "The PR description says the functions are called contains and icontains, but it looks like this patch uses the names with _str appended. Was there any reason you chose these names instead of others?\nI couldn't find an equivalent query in postgresql, and when I googled for a contains operator: Oracle and SQL server appear to have one - https://docs.oracle.com/cd/B28359_01/text.111/b28303/query.htm#g1016054 and https://docs.microsoft.com/en-us/sql/t-sql/queries/contains-transact-sql?view=sql-server-2017.\nAlso, was there any reasoning behind having 2 functions instead of 1 with a parameter to ignore the case? I don't think I have a strong preference either way yet, just curious", "url": "https://github.com/apache/druid/pull/10350#discussion_r486066973", "createdAt": "2020-09-10T05:07:25Z", "author": {"login": "suneet-s"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -561,6 +561,8 @@ The [DataSketches extension](../development/extensions-core/datasketches-extensi\n |`COALESCE(value1, value2, ...)`|Returns the first value that is neither NULL nor empty string.|\n |`NVL(expr,expr-for-null)`|Returns 'expr-for-null' if 'expr' is null (or empty string for string type).|\n |`BLOOM_FILTER_TEST(<expr>, <serialized-filter>)`|Returns true if the value is contained in a Base64-serialized bloom filter. See the [Bloom filter extension](../development/extensions-core/bloom-filter.html) documentation for additional details.|\n+|`CONTAINS_STR(<expr>, str)`|Returns true if the `str` is a substring of `expr`.|\n+|`ICONTAINS_STR(<expr>, str)`|Returns true if the `str` is a substring of `expr`. The match is case-insensitive.|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "176d71272f6629fed5b0924b54c4f78ecef94e3f"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NTg1NTE5", "url": "https://github.com/apache/druid/pull/10350#pullrequestreview-485585519", "createdAt": "2020-09-10T05:08:18Z", "commit": {"oid": "176d71272f6629fed5b0924b54c4f78ecef94e3f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNTowODoxOFrOHPjNSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNTowODoxOFrOHPjNSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2NzUzMA==", "bodyText": "nit: javadocs please", "url": "https://github.com/apache/druid/pull/10350#discussion_r486067530", "createdAt": "2020-09-10T05:08:18Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/ContainsOperatorConversion.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.filter.DimFilter;\n+import org.apache.druid.query.filter.SearchQueryDimFilter;\n+import org.apache.druid.query.search.ContainsSearchQuerySpec;\n+import org.apache.druid.query.search.SearchQuerySpec;\n+import org.apache.druid.segment.VirtualColumn;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.expression.DirectOperatorConversion;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.Expressions;\n+import org.apache.druid.sql.calcite.expression.OperatorConversions;\n+import org.apache.druid.sql.calcite.expression.SqlOperatorConversion;\n+import org.apache.druid.sql.calcite.planner.PlannerContext;\n+import org.apache.druid.sql.calcite.rel.VirtualColumnRegistry;\n+\n+import javax.annotation.Nullable;\n+import java.util.List;\n+\n+public class ContainsOperatorConversion extends DirectOperatorConversion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "176d71272f6629fed5b0924b54c4f78ecef94e3f"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NTg4NjQw", "url": "https://github.com/apache/druid/pull/10350#pullrequestreview-485588640", "createdAt": "2020-09-10T05:17:46Z", "commit": {"oid": "176d71272f6629fed5b0924b54c4f78ecef94e3f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNToxNzo0NlrOHPjaaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNToxNzo0NlrOHPjaaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA3MDg4OA==", "bodyText": "Can you also add some tests similar to the ones in FunctionTest to test that we can correctly parse the expression similar to testLpad", "url": "https://github.com/apache/druid/pull/10350#discussion_r486070888", "createdAt": "2020-09-10T05:17:46Z", "author": {"login": "suneet-s"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/expression/ExpressionsTest.java", "diffHunk": "@@ -1072,6 +1075,108 @@ public void testPad()\n     );\n   }\n \n+  @Test\n+  public void testContains()\n+  {\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(true).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"there\")\n+        ),\n+        Collections.emptyList(),\n+        new SearchQueryDimFilter(\"spacey\", new ContainsSearchQuerySpec(\"there\", true), null),\n+        true\n+    );\n+\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(true).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"There\")\n+        ),\n+        Collections.emptyList(),\n+        new SearchQueryDimFilter(\"spacey\", new ContainsSearchQuerySpec(\"There\", true), null),\n+        false\n+    );\n+\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(false).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"There\")\n+        ),\n+        Collections.emptyList(),\n+        new SearchQueryDimFilter(\"spacey\", new ContainsSearchQuerySpec(\"There\", false), null),\n+        true\n+    );\n+\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(true).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"what\")\n+        ),\n+        ImmutableList.of(\n+            new ExpressionVirtualColumn(\n+                \"v0\",\n+                \"concat('what is',\\\"spacey\\\")\",\n+                ValueType.STRING,\n+                TestExprMacroTable.INSTANCE\n+            )\n+        ),\n+        new SearchQueryDimFilter(\"v0\", new ContainsSearchQuerySpec(\"what\", true), null),\n+        true\n+    );\n+\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(true).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"there\")\n+        ),\n+        ImmutableList.of(\n+            new ExpressionVirtualColumn(\n+                \"v0\",\n+                \"concat('what is',\\\"spacey\\\")\",\n+                ValueType.STRING,\n+                TestExprMacroTable.INSTANCE\n+            )\n+        ),\n+        new SearchQueryDimFilter(\"v0\", new ContainsSearchQuerySpec(\"there\", true), null),\n+        true\n+    );\n+\n+    testHelper.testFilter(\n+        ContainsOperatorConversion.createOperatorConversion(false).calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"What\")\n+        ),\n+        ImmutableList.of(\n+            new ExpressionVirtualColumn(\n+                \"v0\",\n+                \"concat('what is',\\\"spacey\\\")\",\n+                ValueType.STRING,\n+                TestExprMacroTable.INSTANCE\n+            )\n+        ),\n+        new SearchQueryDimFilter(\"v0\", new ContainsSearchQuerySpec(\"What\", false), null),\n+        true\n+    );\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "176d71272f6629fed5b0924b54c4f78ecef94e3f"}, "originalPosition": 118}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NTg2NDA2", "url": "https://github.com/apache/druid/pull/10350#pullrequestreview-485586406", "createdAt": "2020-09-10T05:10:48Z", "commit": {"oid": "176d71272f6629fed5b0924b54c4f78ecef94e3f"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNToxMDo0OFrOHPjS7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNTozMDo1NVrOHPjpSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2ODk3NQ==", "bodyText": "I don't see native functions named \"contains_str\" and \"icontains_str\", do they exist? (DirectOperatorConversion assumes there is a native function with the functionName you pass in here.)", "url": "https://github.com/apache/druid/pull/10350#discussion_r486068975", "createdAt": "2020-09-10T05:10:48Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/ContainsOperatorConversion.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.filter.DimFilter;\n+import org.apache.druid.query.filter.SearchQueryDimFilter;\n+import org.apache.druid.query.search.ContainsSearchQuerySpec;\n+import org.apache.druid.query.search.SearchQuerySpec;\n+import org.apache.druid.segment.VirtualColumn;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.expression.DirectOperatorConversion;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.Expressions;\n+import org.apache.druid.sql.calcite.expression.OperatorConversions;\n+import org.apache.druid.sql.calcite.expression.SqlOperatorConversion;\n+import org.apache.druid.sql.calcite.planner.PlannerContext;\n+import org.apache.druid.sql.calcite.rel.VirtualColumnRegistry;\n+\n+import javax.annotation.Nullable;\n+import java.util.List;\n+\n+public class ContainsOperatorConversion extends DirectOperatorConversion\n+{\n+  private static final String CASE_SENSITIVE_FN_NAME = \"contains_str\";\n+  private static final String CASE_INSENSITIVE_FN_NAME = \"icontains_str\";\n+  private final boolean caseSensitive;\n+\n+  public ContainsOperatorConversion(\n+      final SqlFunction sqlFunction,\n+      final String functionName,\n+      final boolean caseSensitive\n+  )\n+  {\n+    super(sqlFunction, functionName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "176d71272f6629fed5b0924b54c4f78ecef94e3f"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2OTE3NQ==", "bodyText": "Might be more readable to give these methods nice names, like caseInsensitive() and caseSensitive(). Small nit though.", "url": "https://github.com/apache/druid/pull/10350#discussion_r486069175", "createdAt": "2020-09-10T05:11:32Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/planner/DruidOperatorTable.java", "diffHunk": "@@ -181,6 +182,8 @@\n           .add(new AliasedOperatorConversion(new TruncateOperatorConversion(), \"TRUNC\"))\n           .add(new LPadOperatorConversion())\n           .add(new RPadOperatorConversion())\n+          .add(ContainsOperatorConversion.createOperatorConversion(true))\n+          .add(ContainsOperatorConversion.createOperatorConversion(false))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "176d71272f6629fed5b0924b54c4f78ecef94e3f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2OTYwNw==", "bodyText": "You should include tests here using testHelper.testExpression too. It'll test that toDruidExpression works properly, which will be used if someone uses this operator outside of a leaf filter.", "url": "https://github.com/apache/druid/pull/10350#discussion_r486069607", "createdAt": "2020-09-10T05:13:10Z", "author": {"login": "gianm"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/expression/ExpressionsTest.java", "diffHunk": "@@ -1072,6 +1075,108 @@ public void testPad()\n     );\n   }\n \n+  @Test\n+  public void testContains()\n+  {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "176d71272f6629fed5b0924b54c4f78ecef94e3f"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA3NDY5OA==", "bodyText": "These should be in the \"String functions\" section.\nI don't have an opinion on the names right now, but to form an opinion I like to do the following.\n\nCheck Calcite's SqlStdOperatorTable, which contains standard operators. If there's something matching there, we should use that.\nIf there isn't a standard operator, survey some other databases. I like to check the golden oldies: MySQL, PostgreSQL, Oracle, SQL Server, as well as some of the newer ones like Presto, Snowflake, BigQuery. If a few of them seem to agree on a name and behavior it's good to go with that.\nIf there doesn't seem to be any agreement, or if you don't want to implement what they seem to agree on for some reason, then make up a new operator.", "url": "https://github.com/apache/druid/pull/10350#discussion_r486074698", "createdAt": "2020-09-10T05:30:55Z", "author": {"login": "gianm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -561,6 +561,8 @@ The [DataSketches extension](../development/extensions-core/datasketches-extensi\n |`COALESCE(value1, value2, ...)`|Returns the first value that is neither NULL nor empty string.|\n |`NVL(expr,expr-for-null)`|Returns 'expr-for-null' if 'expr' is null (or empty string for string type).|\n |`BLOOM_FILTER_TEST(<expr>, <serialized-filter>)`|Returns true if the value is contained in a Base64-serialized bloom filter. See the [Bloom filter extension](../development/extensions-core/bloom-filter.html) documentation for additional details.|\n+|`CONTAINS_STR(<expr>, str)`|Returns true if the `str` is a substring of `expr`.|\n+|`ICONTAINS_STR(<expr>, str)`|Returns true if the `str` is a substring of `expr`. The match is case-insensitive.|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2Njk3Mw=="}, "originalCommit": {"oid": "176d71272f6629fed5b0924b54c4f78ecef94e3f"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5a841a4a04a301daf8a839b15a03926e570d5da", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/d5a841a4a04a301daf8a839b15a03926e570d5da", "committedDate": "2020-09-10T09:30:16Z", "message": "Fix toDruidExpression method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7d3cef69b128a5dde2b83cbfe502c671ddda06f", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/b7d3cef69b128a5dde2b83cbfe502c671ddda06f", "committedDate": "2020-09-10T11:04:32Z", "message": "rename methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bbfe4cbfb39747c0c60960fae452c4cd6be354a6", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/bbfe4cbfb39747c0c60960fae452c4cd6be354a6", "committedDate": "2020-09-10T11:20:33Z", "message": "java docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e7125d36acde6c70ef1e7b4a86b805e5199d7e3", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/7e7125d36acde6c70ef1e7b4a86b805e5199d7e3", "committedDate": "2020-09-10T17:08:38Z", "message": "Add native functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38306ecc759b2c35cb1aa515f787ac14ce738613", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/38306ecc759b2c35cb1aa515f787ac14ce738613", "committedDate": "2020-09-10T17:16:36Z", "message": "revert change in dockerfile"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "549971029d0f2659b9a4734711ea8147ede726c5", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/549971029d0f2659b9a4734711ea8147ede726c5", "committedDate": "2020-09-10T17:19:35Z", "message": "remove changes from dockerfile"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2NDAxNDQx", "url": "https://github.com/apache/druid/pull/10350#pullrequestreview-486401441", "createdAt": "2020-09-11T00:45:04Z", "commit": {"oid": "549971029d0f2659b9a4734711ea8147ede726c5"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMDo0NTowNVrOHQKYDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMDo1Nzo0MFrOHQKlLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcwOTI2Mw==", "bodyText": "Since ContainsExpr always expects this to be a literal value, should this class just accept a String instead?", "url": "https://github.com/apache/druid/pull/10350#discussion_r486709263", "createdAt": "2020-09-11T00:45:05Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/expression/ContainsExpr.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.Expr;\n+import org.apache.druid.math.expr.ExprEval;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.math.expr.ExprType;\n+\n+import javax.annotation.Nonnull;\n+import java.util.function.Function;\n+\n+/**\n+ * {@link Expr} class returned by {@link ContainsExprMacro} and {@link CaseInsensitiveContainsExprMacro} for\n+ * evaluating the expression.\n+ */\n+class ContainsExpr extends ExprMacroTable.BaseScalarUnivariateMacroFunctionExpr\n+{\n+  private final Function<String, Boolean> searchFunction;\n+  private final Expr searchStrExpr;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "549971029d0f2659b9a4734711ea8147ede726c5"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcwOTc2OA==", "bodyText": "Thanks for the awesome javadocs \ud83e\udd18", "url": "https://github.com/apache/druid/pull/10350#discussion_r486709768", "createdAt": "2020-09-11T00:47:11Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/expression/ContainsExprMacro.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.math.expr.Expr;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+\n+import java.util.List;\n+\n+/**\n+ * This class implements a function that checks if one string contains another string. It is required that second\n+ * string be a literal. This expression is case-sensitive.\n+ * signature:\n+ * long contains_string(string, string)\n+ * <p>\n+ * Examples:\n+ * - {@code contains_string(\"foobar\", \"bar\") - 1 }\n+ * - {@code contains_string(\"foobar\", \"car\") - 0 }\n+ * - {@code contains_string(\"foobar\", \"Bar\") - 0 }\n+ * <p>\n+ * See {@link CaseInsensitiveContainsExprMacro} for the case-insensitive version.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "549971029d0f2659b9a4734711ea8147ede726c5"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMDMyNg==", "bodyText": "super nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public ContainsOperatorConversion(\n          \n          \n            \n              private ContainsOperatorConversion(", "url": "https://github.com/apache/druid/pull/10350#discussion_r486710326", "createdAt": "2020-09-11T00:49:15Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/ContainsOperatorConversion.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexLiteral;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.SqlTypeFamily;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.expression.CaseInsensitiveContainsExprMacro;\n+import org.apache.druid.query.expression.ContainsExprMacro;\n+import org.apache.druid.query.filter.DimFilter;\n+import org.apache.druid.query.filter.SearchQueryDimFilter;\n+import org.apache.druid.query.search.ContainsSearchQuerySpec;\n+import org.apache.druid.query.search.SearchQuerySpec;\n+import org.apache.druid.segment.VirtualColumn;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.Expressions;\n+import org.apache.druid.sql.calcite.expression.OperatorConversions;\n+import org.apache.druid.sql.calcite.expression.SqlOperatorConversion;\n+import org.apache.druid.sql.calcite.planner.PlannerContext;\n+import org.apache.druid.sql.calcite.rel.VirtualColumnRegistry;\n+\n+import javax.annotation.Nullable;\n+import java.util.List;\n+\n+/**\n+ * Register {@code contains_string} and {@code icontains_string} functions with calcite that internally\n+ * translate these functions into {@link SearchQueryDimFilter} with {@link ContainsSearchQuerySpec} as\n+ * search query spec.\n+ */\n+public class ContainsOperatorConversion implements SqlOperatorConversion\n+{\n+  private final SqlOperator operator;\n+  private final boolean caseSensitive;\n+\n+  public ContainsOperatorConversion(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "549971029d0f2659b9a4734711ea8147ede726c5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMjYyMA==", "bodyText": "Can you add some tests for how the function deals with nulls and empty strings - these tend to surface some issues because we need to support 2 modes - default mode and sql compatible mode, and sometimes the behavior of these functions may be slightly different than we expect. I remember finding issues when I changed the behavior of lpad / rpad functions - https://github.com/apache/druid/pull/10006/files#diff-fd48c48432e4977332aa9806d2d308faR150-R151", "url": "https://github.com/apache/druid/pull/10350#discussion_r486712620", "createdAt": "2020-09-11T00:57:40Z", "author": {"login": "suneet-s"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/expression/ExpressionsTest.java", "diffHunk": "@@ -1072,6 +1075,221 @@ public void testPad()\n     );\n   }\n \n+  @Test\n+  public void testContains()\n+  {\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseSensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"there\")\n+        ),\n+        DruidExpression.fromExpression(\"contains_string(\\\"spacey\\\",'there')\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseSensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"There\")\n+        ),\n+        DruidExpression.fromExpression(\"contains_string(\\\"spacey\\\",'There')\"),\n+        0L\n+    );\n+\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseInsensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeInputRef(\"spacey\"),\n+            testHelper.makeLiteral(\"There\")\n+        ),\n+        DruidExpression.fromExpression(\"icontains_string(\\\"spacey\\\",'There')\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseSensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"what\")\n+        ),\n+        DruidExpression.fromExpression(\"contains_string(concat('what is',\\\"spacey\\\"),'what')\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseSensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"there\")\n+        ),\n+        DruidExpression.fromExpression(\"contains_string(concat('what is',\\\"spacey\\\"),'there')\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        ContainsOperatorConversion.caseInsensitive().calciteOperator(),\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.CONCAT,\n+                testHelper.makeLiteral(\"what is\"),\n+                testHelper.makeInputRef(\"spacey\")\n+            ),\n+            testHelper.makeLiteral(\"There\")\n+        ),\n+        DruidExpression.fromExpression(\"icontains_string(concat('what is',\\\"spacey\\\"),'There')\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        SqlStdOperatorTable.AND,\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                ContainsOperatorConversion.caseSensitive().calciteOperator(),\n+                testHelper.makeInputRef(\"spacey\"),\n+                testHelper.makeLiteral(\"there\")\n+            ),\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.EQUALS,\n+                testHelper.makeLiteral(\"yes\"),\n+                testHelper.makeLiteral(\"yes\")\n+            )\n+        ),\n+        DruidExpression.fromExpression(\"(contains_string(\\\"spacey\\\",'there') && ('yes' == 'yes'))\"),\n+        1L\n+    );\n+\n+    testHelper.testExpression(\n+        SqlStdOperatorTable.AND,\n+        ImmutableList.of(\n+            testHelper.makeCall(\n+                ContainsOperatorConversion.caseInsensitive().calciteOperator(),\n+                testHelper.makeInputRef(\"spacey\"),\n+                testHelper.makeLiteral(\"There\")\n+            ),\n+            testHelper.makeCall(\n+                SqlStdOperatorTable.EQUALS,\n+                testHelper.makeLiteral(\"yes\"),\n+                testHelper.makeLiteral(\"yes\")\n+            )\n+        ),\n+        DruidExpression.fromExpression(\"(icontains_string(\\\"spacey\\\",'There') && ('yes' == 'yes'))\"),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "549971029d0f2659b9a4734711ea8147ede726c5"}, "originalPosition": 124}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f408a72d73e5dd8fd60e03269eecae0e68f2c71", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/1f408a72d73e5dd8fd60e03269eecae0e68f2c71", "committedDate": "2020-09-11T11:34:58Z", "message": "More tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfd26bdaaf9e9768e734d1e460b38e57bd44921d", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/cfd26bdaaf9e9768e734d1e460b38e57bd44921d", "committedDate": "2020-09-11T13:50:35Z", "message": "travis fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8ae16920d494aaafc1d6f454a644fbd096fc044", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/a8ae16920d494aaafc1d6f454a644fbd096fc044", "committedDate": "2020-09-11T15:31:23Z", "message": "Handle null values better"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MTYzMDcy", "url": "https://github.com/apache/druid/pull/10350#pullrequestreview-487163072", "createdAt": "2020-09-11T22:48:10Z", "commit": {"oid": "a8ae16920d494aaafc1d6f454a644fbd096fc044"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMjo0ODoxMFrOHQv0QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQyMzoxODoxNFrOHQwO-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyMjY4OA==", "bodyText": "nit\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // same behavior as regexp_like.\n          \n          \n            \n                  // same behavior as ContainsSearchQuerySpec#accept\n          \n      \n    \n    \n  \n\nLuckily the behavior is the same as regexp_like\n    if (dimVal == null || value == null) {\n      return false;\n    }", "url": "https://github.com/apache/druid/pull/10350#discussion_r487322688", "createdAt": "2020-09-11T22:48:10Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/expression/ContainsExpr.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.Expr;\n+import org.apache.druid.math.expr.ExprEval;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.math.expr.ExprType;\n+\n+import javax.annotation.Nonnull;\n+import java.util.function.Function;\n+\n+/**\n+ * {@link Expr} class returned by {@link ContainsExprMacro} and {@link CaseInsensitiveContainsExprMacro} for\n+ * evaluating the expression.\n+ */\n+class ContainsExpr extends ExprMacroTable.BaseScalarUnivariateMacroFunctionExpr\n+{\n+  private final Function<String, Boolean> searchFunction;\n+  private final Expr searchStrExpr;\n+\n+  ContainsExpr(String functioName, Expr arg, Expr searchStrExpr, boolean caseSensitive)\n+  {\n+    super(functioName, arg);\n+    this.searchStrExpr = validateSearchExpr(searchStrExpr, functioName);\n+    // Creates the function eagerly to avoid branching in eval.\n+    this.searchFunction = createFunction(searchStrExpr, caseSensitive);\n+  }\n+\n+  private ContainsExpr(String functioName, Expr arg, Expr searchStrExpr, Function<String, Boolean> searchFunction)\n+  {\n+    super(functioName, arg);\n+    this.searchFunction = searchFunction;\n+    this.searchStrExpr = validateSearchExpr(searchStrExpr, functioName);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public ExprEval eval(final Expr.ObjectBinding bindings)\n+  {\n+    final String s = NullHandling.nullToEmptyIfNeeded(arg.eval(bindings).asString());\n+\n+    if (s == null) {\n+      // same behavior as regexp_like.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8ae16920d494aaafc1d6f454a644fbd096fc044"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyMzYzMA==", "bodyText": "nit: It would be good to link to the DimFilter whose behavior we are trying to mimic here ContainsSearchQuerySpec\nsince we want the logic between these 2 classes to stay the same. I wonder if we can future proof this so they stay in sync if someone makes an update to ContainsSearchQuerySpec", "url": "https://github.com/apache/druid/pull/10350#discussion_r487323630", "createdAt": "2020-09-11T22:52:01Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/expression/ContainsExpr.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.Expr;\n+import org.apache.druid.math.expr.ExprEval;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.math.expr.ExprType;\n+\n+import javax.annotation.Nonnull;\n+import java.util.function.Function;\n+\n+/**\n+ * {@link Expr} class returned by {@link ContainsExprMacro} and {@link CaseInsensitiveContainsExprMacro} for\n+ * evaluating the expression.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8ae16920d494aaafc1d6f454a644fbd096fc044"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzMyOTUzMQ==", "bodyText": "According to ContainsSearchQuerySpec#accept searching for anything on null should be false\n    if (dimVal == null || value == null) {\n      return false;\n    }", "url": "https://github.com/apache/druid/pull/10350#discussion_r487329531", "createdAt": "2020-09-11T23:18:14Z", "author": {"login": "suneet-s"}, "path": "processing/src/test/java/org/apache/druid/query/expression/ContainsExprMacroTest.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.expression;\n+\n+import com.google.common.collect.ImmutableMap;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.math.expr.ExprEval;\n+import org.apache.druid.math.expr.ExprType;\n+import org.apache.druid.math.expr.Parser;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class ContainsExprMacroTest extends MacroTestBase\n+{\n+  public ContainsExprMacroTest()\n+  {\n+    super(new ContainsExprMacro());\n+  }\n+\n+  @Test\n+  public void testErrorZeroArguments()\n+  {\n+    expectException(IllegalArgumentException.class, \"Function[contains_string] must have 2 arguments\");\n+    eval(\"contains_string()\", Parser.withMap(ImmutableMap.of()));\n+  }\n+\n+  @Test\n+  public void testErrorThreeArguments()\n+  {\n+    expectException(IllegalArgumentException.class, \"Function[contains_string] must have 2 arguments\");\n+    eval(\"contains_string('a', 'b', 'c')\", Parser.withMap(ImmutableMap.of()));\n+  }\n+\n+  @Test\n+  public void testMatch()\n+  {\n+    final ExprEval<?> result = eval(\"contains_string(a, 'oba')\", Parser.withMap(ImmutableMap.of(\"a\", \"foobar\")));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testNoMatch()\n+  {\n+    final ExprEval<?> result = eval(\"contains_string(a, 'bar')\", Parser.withMap(ImmutableMap.of(\"a\", \"foo\")));\n+    Assert.assertEquals(\n+        ExprEval.of(false, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testNullSearch()\n+  {\n+    if (NullHandling.sqlCompatible()) {\n+      expectException(IllegalArgumentException.class, \"Function[contains_string] substring must be a string literal\");\n+    }\n+\n+    final ExprEval<?> result = eval(\"contains_string(a, null)\", Parser.withMap(ImmutableMap.of(\"a\", \"foo\")));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testEmptyStringSearch()\n+  {\n+    final ExprEval<?> result = eval(\"contains_string(a, '')\", Parser.withMap(ImmutableMap.of(\"a\", \"foo\")));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testNullSearchOnEmptyString()\n+  {\n+    if (NullHandling.sqlCompatible()) {\n+      expectException(IllegalArgumentException.class, \"Function[contains_string] substring must be a string literal\");\n+    }\n+\n+    final ExprEval<?> result = eval(\"contains_string(a, null)\", Parser.withMap(ImmutableMap.of(\"a\", \"\")));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testEmptyStringSearchOnEmptyString()\n+  {\n+    final ExprEval<?> result = eval(\"contains_string(a, '')\", Parser.withMap(ImmutableMap.of(\"a\", \"\")));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),\n+        result.value()\n+    );\n+  }\n+\n+  @Test\n+  public void testNullSearchOnNull()\n+  {\n+    if (NullHandling.sqlCompatible()) {\n+      expectException(IllegalArgumentException.class, \"Function[contains_string] substring must be a string literal\");\n+    }\n+\n+    final ExprEval<?> result = eval(\"contains_string(a, null)\", Parser.withSuppliers(ImmutableMap.of(\"a\", () -> null)));\n+    Assert.assertEquals(\n+        ExprEval.of(true, ExprType.LONG).value(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8ae16920d494aaafc1d6f454a644fbd096fc044"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3OTY5NTgy", "url": "https://github.com/apache/druid/pull/10350#pullrequestreview-487969582", "createdAt": "2020-09-14T16:56:55Z", "commit": {"oid": "a8ae16920d494aaafc1d6f454a644fbd096fc044"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3548, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}