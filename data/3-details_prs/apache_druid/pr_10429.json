{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkyMDY4MDUy", "number": 10429, "title": "vectorize remaining math expressions", "bodyText": "Description\nFollow up to #10401, this PR adds all the remaining math functions\n\nabs,acos,asin, cbrt, ceil, exp, expm1, floor, getExponent, log, log10, log1p, nextUp, rint, signum, sqrt, toDegrees, toRadians, ulp\natan2,copySign, div, hypot, remainder, nextAfter, scalb\n\nThis PR fixes a bug with scalb for SQL compatible null handling mode, including for non-vectorized queries.\nAdditionally, this PR fixes another bug by disabling vectorized group by engine whenever it encounters grouping on numeric null values, which the engine doesn't currently handle.\n\nThis PR has:\n\n been self-reviewed.\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths, ensuring the threshold for code coverage is met.\n added integration tests.\n been tested in a test Druid cluster.", "createdAt": "2020-09-23T22:13:39Z", "url": "https://github.com/apache/druid/pull/10429", "merged": true, "mergeCommit": {"oid": "3d700a5e31eaea131f1152e90b6c78a572edd7fc"}, "closed": true, "closedAt": "2020-09-27T06:30:15Z", "author": {"login": "clintropolis"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdL0AiPgH2gAyNDkyMDY4MDUyOjUzZTIzZDY0OTk2ZDQ2MjQxZTAwZjcxMmNkMzNmN2Y2YzI3NWI2NGQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdMQSp5gFqTQ5NjE1OTAyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "53e23d64996d46241e00f712cd33f7f6c275b64d", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/53e23d64996d46241e00f712cd33f7f6c275b64d", "committedDate": "2020-09-23T22:06:03Z", "message": "vectorize remaining math expressions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b27fca67d6bc793aaec438138b4d7e6eb2382e83", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/b27fca67d6bc793aaec438138b4d7e6eb2382e83", "committedDate": "2020-09-24T11:59:01Z", "message": "fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f132d71b1e26ce3a2089b27b2f2f8dcaee68166c", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/f132d71b1e26ce3a2089b27b2f2f8dcaee68166c", "committedDate": "2020-09-24T18:45:33Z", "message": "remove cannotVectorize() where no longer true"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk1OTYyNzQ4", "url": "https://github.com/apache/druid/pull/10429#pullrequestreview-495962748", "createdAt": "2020-09-24T21:26:32Z", "commit": {"oid": "f132d71b1e26ce3a2089b27b2f2f8dcaee68166c"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMToyNjozMlrOHXtNtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNFQyMzoxNzo0MFrOHXvu2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDYyMDA4Nw==", "bodyText": "The return value is not nullable.", "url": "https://github.com/apache/druid/pull/10429#discussion_r494620087", "createdAt": "2020-09-24T21:26:32Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/math/expr/ExprType.java", "diffHunk": "@@ -216,11 +226,44 @@ public static ExprType functionAutoTypeConversion(@Nullable ExprType type, @Null\n       return STRING;\n     }\n \n-    return numericAutoTypeConversion(type, other);\n+    return doubleNumericAutoTypeConversion(type, other);\n   }\n \n+  /**\n+   * Given 2 'input' types, choose the most appropriate combined type, if possible\n+   *\n+   * arrays must be the same type\n+   * if either type is {@link #STRING}, the output type will be preserved as string\n+   * any number will be coerced to {@link #LONG}\n+   */\n+  @Nullable\n+  public static ExprType integerMathFunctionAutoTypeConversion(@Nullable ExprType type, @Nullable ExprType other)\n+  {\n+    if (type == null || other == null) {\n+      // cannot auto conversion unknown types\n+      return null;\n+    }\n+    // arrays cannot be auto converted\n+    if (isArray(type) || isArray(other)) {\n+      if (!type.equals(other)) {\n+        throw new IAE(\"Cannot implicitly cast %s to %s\", type, other);\n+      }\n+      return type;\n+    }\n+    // if either argument is a string, type becomes a string\n+    if (STRING.equals(type) || STRING.equals(other)) {\n+      return STRING;\n+    }\n+\n+    // any number is long\n+    return LONG;\n+  }\n+\n+  /**\n+   * If both types are {@link #LONG}, returns {@link #LONG}, else {@link #DOUBLE}\n+   */\n   @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f132d71b1e26ce3a2089b27b2f2f8dcaee68166c"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MDcwOQ==", "bodyText": "Hmm, do we need a sanity check after a casting if the right value is still valid?", "url": "https://github.com/apache/druid/pull/10429#discussion_r494660709", "createdAt": "2020-09-24T23:15:49Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/math/expr/vector/VectorMathProcessors.java", "diffHunk": "@@ -632,170 +793,812 @@ public double apply(double left, double right)\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> atan(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> atan2(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.atan(input);\n+            return Math.atan2(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.atan(input);\n+            return Math.atan2(left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> cos(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(double left, long right)\n           {\n-            return Math.cos(input);\n+            return Math.atan2(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(double left, double right)\n           {\n-            return Math.cos(input);\n+            return Math.atan2(left, right);\n           }\n         }\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> cosh(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> copySign(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.cosh(input);\n+            return Math.copySign((double) left, (double) right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.cosh(input);\n+            return Math.copySign((double) left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> cot(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(double left, long right)\n           {\n-            return Math.cos(input) / Math.sin(input);\n+            return Math.copySign(left, (double) right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(double left, double right)\n           {\n-            return Math.cos(input) / Math.sin(input);\n+            return Math.copySign(left, right);\n           }\n         }\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> sin(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> hypot(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.sin(input);\n+            return Math.hypot(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.sin(input);\n+            return Math.hypot(left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> sinh(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n-            inputTypes.getMaxVectorSize()\n-        )\n-        {\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.hypot(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.hypot(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> remainder(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, double right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> nextAfter(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.nextAfter((double) left, (double) right);\n+          }\n+        },\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, double right)\n+          {\n+            return Math.nextAfter((double) left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.nextAfter(left, (double) right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.nextAfter(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> scalb(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.scalb((double) left, (int) right);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f132d71b1e26ce3a2089b27b2f2f8dcaee68166c"}, "originalPosition": 564}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MTMzNg==", "bodyText": "Same comment for other places where it does narrowing casting.", "url": "https://github.com/apache/druid/pull/10429#discussion_r494661336", "createdAt": "2020-09-24T23:17:40Z", "author": {"login": "jihoonson"}, "path": "core/src/main/java/org/apache/druid/math/expr/vector/VectorMathProcessors.java", "diffHunk": "@@ -632,170 +793,812 @@ public double apply(double left, double right)\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> atan(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> atan2(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.atan(input);\n+            return Math.atan2(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.atan(input);\n+            return Math.atan2(left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> cos(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(double left, long right)\n           {\n-            return Math.cos(input);\n+            return Math.atan2(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(double left, double right)\n           {\n-            return Math.cos(input);\n+            return Math.atan2(left, right);\n           }\n         }\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> cosh(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> copySign(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.cosh(input);\n+            return Math.copySign((double) left, (double) right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.cosh(input);\n+            return Math.copySign((double) left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> cot(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(double left, long right)\n           {\n-            return Math.cos(input) / Math.sin(input);\n+            return Math.copySign(left, (double) right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(double left, double right)\n           {\n-            return Math.cos(input) / Math.sin(input);\n+            return Math.copySign(left, right);\n           }\n         }\n     );\n   }\n \n-  public static <T> ExprVectorProcessor<T> sin(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n+  public static <T> ExprVectorProcessor<T> hypot(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n   {\n     return makeDoubleMathProcessor(\n         inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(long input)\n+          public double apply(long left, long right)\n           {\n-            return Math.sin(input);\n+            return Math.hypot(left, right);\n           }\n         },\n-        () -> new DoubleOutDoubleInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n             inputTypes.getMaxVectorSize()\n         )\n         {\n           @Override\n-          public double apply(double input)\n+          public double apply(long left, double right)\n           {\n-            return Math.sin(input);\n+            return Math.hypot(left, right);\n           }\n-        }\n-    );\n-  }\n-\n-  public static <T> ExprVectorProcessor<T> sinh(Expr.VectorInputBindingTypes inputTypes, Expr arg)\n-  {\n-    return makeDoubleMathProcessor(\n-        inputTypes,\n-        arg,\n-        () -> new DoubleOutLongInFunctionVectorProcessor(\n-            arg.buildVectorized(inputTypes),\n-            inputTypes.getMaxVectorSize()\n-        )\n-        {\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.hypot(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.hypot(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> remainder(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, double right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.IEEEremainder(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> nextAfter(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.nextAfter((double) left, (double) right);\n+          }\n+        },\n+        () -> new DoubleOutLongDoubleInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, double right)\n+          {\n+            return Math.nextAfter((double) left, right);\n+          }\n+        },\n+        () -> new DoubleOutDoubleLongInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, long right)\n+          {\n+            return Math.nextAfter(left, (double) right);\n+          }\n+        },\n+        () -> new DoubleOutDoublesInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(double left, double right)\n+          {\n+            return Math.nextAfter(left, right);\n+          }\n+        }\n+    );\n+  }\n+\n+  public static <T> ExprVectorProcessor<T> scalb(Expr.VectorInputBindingTypes inputTypes, Expr left, Expr right)\n+  {\n+    return makeDoubleMathProcessor(\n+        inputTypes,\n+        left,\n+        right,\n+        () -> new DoubleOutLongsInFunctionVectorProcessor(\n+            left.buildVectorized(inputTypes),\n+            right.buildVectorized(inputTypes),\n+            inputTypes.getMaxVectorSize()\n+        )\n+        {\n+          @Override\n+          public double apply(long left, long right)\n+          {\n+            return Math.scalb((double) left, (int) right);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDY2MDcwOQ=="}, "originalCommit": {"oid": "f132d71b1e26ce3a2089b27b2f2f8dcaee68166c"}, "originalPosition": 564}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d6a279977c90a4057e3b48340812f16bef3dc97", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/3d6a279977c90a4057e3b48340812f16bef3dc97", "committedDate": "2020-09-25T01:48:00Z", "message": "disable vectorized groupby for numeric columns with nulls"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fc940bd69f8cd97c81297aabdc999a314f936ec", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/2fc940bd69f8cd97c81297aabdc999a314f936ec", "committedDate": "2020-09-25T05:07:50Z", "message": "fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk2MTU5MDI3", "url": "https://github.com/apache/druid/pull/10429#pullrequestreview-496159027", "createdAt": "2020-09-25T07:03:11Z", "commit": {"oid": "2fc940bd69f8cd97c81297aabdc999a314f936ec"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3278, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}