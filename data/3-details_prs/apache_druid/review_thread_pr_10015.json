{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMzAxMDQz", "number": 10015, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODo0MjowM1rOEG3pmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODo0MjowM1rOEG3pmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjM4NjgyOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/join/filter/rewrite/JoinFilterPreAnalysisGroup.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODo0MjowM1rOGl7ttw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMDozNjoyMlrOGl_Urw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyODg1NQ==", "bodyText": "Seems that clauses is always fixed. The clauses used to compute the preanalysisGroup is passed to HashJoinSegmentStorageAdapter to find the analysis. I think we can remove it for faster hash computation.", "url": "https://github.com/apache/druid/pull/10015#discussion_r442428855", "createdAt": "2020-06-18T18:42:03Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/segment/join/filter/rewrite/JoinFilterPreAnalysisGroup.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.join.filter.rewrite;\n+\n+import org.apache.druid.query.filter.Filter;\n+import org.apache.druid.segment.VirtualColumns;\n+import org.apache.druid.segment.join.JoinableClause;\n+import org.apache.druid.segment.join.filter.JoinFilterAnalyzer;\n+import org.apache.druid.segment.join.filter.JoinFilterPreAnalysis;\n+import org.apache.druid.segment.join.filter.JoinableClauses;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A JoinFilterPreAnalysisGroup holds all of the JoinFilterPreAnalysis objects for a given query and\n+ * also stores the per-query parameters that control the filter rewrite operations (from the query context).\n+ *\n+ * The analyses map is keyed by (Filter, JoinableClause list, VirtualColumns): each Filter in the map belongs to a\n+ * separate level of query (e.g. outer query, subquery level 1, etc.)\n+ *\n+ * If there is only a single Filter, then this class does not use the analyses map, instead of using a single reference\n+ * for efficiency reasons.\n+ */\n+public class JoinFilterPreAnalysisGroup\n+{\n+  private final JoinFilterRewriteConfig joinFilterRewriteConfig;\n+  private final Map<JoinFilterPreAnalysisGroupKey, JoinFilterPreAnalysis> analyses;\n+  private final boolean isSingleLevelMode;\n+\n+  /**\n+   * Hashing and comparing filters can be expensive for large filters, so if we're only dealing with\n+   * a single level of join query, then we can be more efficient by using a single reference instead of a map.\n+   */\n+  private JoinFilterPreAnalysis preAnalysisForSingleLevelMode;\n+\n+  public JoinFilterPreAnalysisGroup(\n+      JoinFilterRewriteConfig joinFilterRewriteConfig,\n+      boolean isSingleLevelMode\n+  )\n+  {\n+    this.joinFilterRewriteConfig = joinFilterRewriteConfig;\n+    this.analyses = new HashMap<>();\n+    this.isSingleLevelMode = isSingleLevelMode;\n+  }\n+\n+  public boolean isSingleLevelMode()\n+  {\n+    return isSingleLevelMode;\n+  }\n+\n+  public JoinFilterPreAnalysis computeJoinFilterPreAnalysisIfAbsent(\n+      Filter filter,\n+      List<JoinableClause> clauses,\n+      VirtualColumns virtualColumns\n+  )\n+  {\n+    if (isSingleLevelMode) {\n+      preAnalysisForSingleLevelMode = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n+          JoinableClauses.fromList(clauses),\n+          virtualColumns,\n+          filter,\n+          joinFilterRewriteConfig\n+      );\n+      return preAnalysisForSingleLevelMode;\n+    }\n+\n+    JoinFilterPreAnalysisGroupKey key = new JoinFilterPreAnalysisGroupKey(filter, clauses, virtualColumns);\n+    return analyses.computeIfAbsent(\n+        key,\n+        (groupKey) -> {\n+          return JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n+              JoinableClauses.fromList(clauses),\n+              virtualColumns,\n+              filter,\n+              joinFilterRewriteConfig\n+          );\n+        }\n+    );\n+  }\n+\n+  public JoinFilterPreAnalysis getAnalysis(\n+      Filter filter,\n+      List<JoinableClause> clauses,\n+      VirtualColumns virtualColumns\n+  )\n+  {\n+    JoinFilterPreAnalysisGroupKey key = new JoinFilterPreAnalysisGroupKey(filter, clauses, virtualColumns);\n+    return analyses.get(key);\n+  }\n+\n+  public JoinFilterPreAnalysis getPreAnalysisForSingleLevelMode()\n+  {\n+    return preAnalysisForSingleLevelMode;\n+  }\n+\n+  public static class JoinFilterPreAnalysisGroupKey\n+  {\n+    private final Filter filter;\n+    private final List<JoinableClause> clauses;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a43777e43c572d5e9b9a20184a6d092840d8e684"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ4Nzk4Mw==", "bodyText": "Good point, removed the clauses", "url": "https://github.com/apache/druid/pull/10015#discussion_r442487983", "createdAt": "2020-06-18T20:36:22Z", "author": {"login": "jon-wei"}, "path": "processing/src/main/java/org/apache/druid/segment/join/filter/rewrite/JoinFilterPreAnalysisGroup.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.join.filter.rewrite;\n+\n+import org.apache.druid.query.filter.Filter;\n+import org.apache.druid.segment.VirtualColumns;\n+import org.apache.druid.segment.join.JoinableClause;\n+import org.apache.druid.segment.join.filter.JoinFilterAnalyzer;\n+import org.apache.druid.segment.join.filter.JoinFilterPreAnalysis;\n+import org.apache.druid.segment.join.filter.JoinableClauses;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+/**\n+ * A JoinFilterPreAnalysisGroup holds all of the JoinFilterPreAnalysis objects for a given query and\n+ * also stores the per-query parameters that control the filter rewrite operations (from the query context).\n+ *\n+ * The analyses map is keyed by (Filter, JoinableClause list, VirtualColumns): each Filter in the map belongs to a\n+ * separate level of query (e.g. outer query, subquery level 1, etc.)\n+ *\n+ * If there is only a single Filter, then this class does not use the analyses map, instead of using a single reference\n+ * for efficiency reasons.\n+ */\n+public class JoinFilterPreAnalysisGroup\n+{\n+  private final JoinFilterRewriteConfig joinFilterRewriteConfig;\n+  private final Map<JoinFilterPreAnalysisGroupKey, JoinFilterPreAnalysis> analyses;\n+  private final boolean isSingleLevelMode;\n+\n+  /**\n+   * Hashing and comparing filters can be expensive for large filters, so if we're only dealing with\n+   * a single level of join query, then we can be more efficient by using a single reference instead of a map.\n+   */\n+  private JoinFilterPreAnalysis preAnalysisForSingleLevelMode;\n+\n+  public JoinFilterPreAnalysisGroup(\n+      JoinFilterRewriteConfig joinFilterRewriteConfig,\n+      boolean isSingleLevelMode\n+  )\n+  {\n+    this.joinFilterRewriteConfig = joinFilterRewriteConfig;\n+    this.analyses = new HashMap<>();\n+    this.isSingleLevelMode = isSingleLevelMode;\n+  }\n+\n+  public boolean isSingleLevelMode()\n+  {\n+    return isSingleLevelMode;\n+  }\n+\n+  public JoinFilterPreAnalysis computeJoinFilterPreAnalysisIfAbsent(\n+      Filter filter,\n+      List<JoinableClause> clauses,\n+      VirtualColumns virtualColumns\n+  )\n+  {\n+    if (isSingleLevelMode) {\n+      preAnalysisForSingleLevelMode = JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n+          JoinableClauses.fromList(clauses),\n+          virtualColumns,\n+          filter,\n+          joinFilterRewriteConfig\n+      );\n+      return preAnalysisForSingleLevelMode;\n+    }\n+\n+    JoinFilterPreAnalysisGroupKey key = new JoinFilterPreAnalysisGroupKey(filter, clauses, virtualColumns);\n+    return analyses.computeIfAbsent(\n+        key,\n+        (groupKey) -> {\n+          return JoinFilterAnalyzer.computeJoinFilterPreAnalysis(\n+              JoinableClauses.fromList(clauses),\n+              virtualColumns,\n+              filter,\n+              joinFilterRewriteConfig\n+          );\n+        }\n+    );\n+  }\n+\n+  public JoinFilterPreAnalysis getAnalysis(\n+      Filter filter,\n+      List<JoinableClause> clauses,\n+      VirtualColumns virtualColumns\n+  )\n+  {\n+    JoinFilterPreAnalysisGroupKey key = new JoinFilterPreAnalysisGroupKey(filter, clauses, virtualColumns);\n+    return analyses.get(key);\n+  }\n+\n+  public JoinFilterPreAnalysis getPreAnalysisForSingleLevelMode()\n+  {\n+    return preAnalysisForSingleLevelMode;\n+  }\n+\n+  public static class JoinFilterPreAnalysisGroupKey\n+  {\n+    private final Filter filter;\n+    private final List<JoinableClause> clauses;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyODg1NQ=="}, "originalCommit": {"oid": "a43777e43c572d5e9b9a20184a6d092840d8e684"}, "originalPosition": 119}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2318, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}