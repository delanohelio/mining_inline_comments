{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1OTAzMDAy", "number": 10518, "title": "Add grouping_id function", "bodyText": "Description\nThis PR adds grouping_id function  in both SQL and native query layer. The function is modeled as an aggregate function, similar to how it is done in Calcite. Unlike regular aggregate functions, this one takes the grouping dimensions as arguments.\nThere were different ways, the aggregator result could have materialized for a particular subtotal spec. I initially tried putting the logic in the merge function inside GroupByBinaryFnV2.  That didn't work though since many input rows do not need merging if the grouping key is seen only once. So I have now added the logic as and when we iterate through base rows, modifying the dimensions and grouping aggregator at the same time.\n\nThis PR has:\n\n been self-reviewed.\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths, ensuring the threshold for code coverage is met.\n\n\n\nKey changed/added classes in this PR\n\nRowBasedGrouperHelper\nGroupingSqlAggregator\nGroupingAggregatorFactory", "createdAt": "2020-10-19T11:41:25Z", "url": "https://github.com/apache/druid/pull/10518", "merged": true, "mergeCommit": {"oid": "26d74b358093697a2bd791b50767bd2b1342f272"}, "closed": true, "closedAt": "2020-12-07T19:46:30Z", "author": {"login": "abhishekagarwal87"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdTZmKBAH2gAyNTA1OTAzMDAyOjllNDk0YTE5MmRlNGY0ZWEzZTUyZTQ1MzY3YjNlYmUwZWJiZTU3MDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkNFGrgFqTU0NzQyODk2OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9e494a192de4f4ea3e52e45367b3ebe0ebbe5704", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/9e494a192de4f4ea3e52e45367b3ebe0ebbe5704", "committedDate": "2020-10-17T11:51:06Z", "message": "First draft of grouping_id function"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/60f1041472a1b14cfd98359fcddca27e07bd9da0", "committedDate": "2020-10-19T11:41:37Z", "message": "Add more tests and documentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIwNDc4MDc5", "url": "https://github.com/apache/druid/pull/10518#pullrequestreview-520478079", "createdAt": "2020-10-30T09:00:11Z", "commit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOTowMDoxMVrOHrGR7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMTo1Mjo0MVrOHrL0Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk1MzcwOA==", "bodyText": "It probably doesn't matter, but since this is a relatively hot path of the code, it might be worth measuring if this if statement here has any performance impact on group by queries which do not having a grouping aggregator. If it is actually visible, it might be worth pulling out a separate code path to handle the grouping sets case so that this does not negatively impact performance.", "url": "https://github.com/apache/druid/pull/10518#discussion_r514953708", "createdAt": "2020-10-30T09:00:11Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/RowBasedGrouperHelper.java", "diffHunk": "@@ -576,7 +594,12 @@ private static ValueExtractFunction makeValueExtractFunction(\n           // Add aggregations.\n           final int resultRowAggregatorStart = query.getResultRowAggregatorStart();\n           for (int i = 0; i < entry.getValues().length; i++) {\n-            resultRow.set(resultRowAggregatorStart + i, entry.getValues()[i]);\n+            if (dimsToInclude != null && groupingAggregatorsBitSet.get(i)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyOTE4Mg==", "bodyText": "I think when other databases have differences in functionality so that there doesn't seem to be a consistent behavior, we typically follow the PostgreSQL behavior instead of others (#7950 (comment), #9337, #9488 (comment), #10006, etc), which seems to be the opposite of this where 0 means membership of the grouping set and 1 is not.\nI think we should be consistent with the PostgreSQL behavior here as well.", "url": "https://github.com/apache/druid/pull/10518#discussion_r515029182", "createdAt": "2020-10-30T11:23:53Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.annotations.EverythingIsNonnullByDefault;\n+import org.apache.druid.query.aggregation.constant.LongConstantAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantBufferAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantVectorAggregator;\n+import org.apache.druid.query.cache.CacheKeyBuilder;\n+import org.apache.druid.segment.ColumnInspector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.vector.VectorColumnSelectorFactory;\n+import org.apache.druid.utils.CollectionUtils;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@EverythingIsNonnullByDefault\n+public class GroupingAggregatorFactory extends AggregatorFactory\n+{\n+  private static final Comparator<Long> VALUE_COMPARATOR = Long::compare;\n+  private final String name;\n+  private final List<String> groupings;\n+  private final long value;\n+  @Nullable\n+  private final Set<String> keyDimensions;\n+\n+  @JsonCreator\n+  public GroupingAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"groupings\") List<String> groupings\n+  )\n+  {\n+    this(name, groupings, null);\n+  }\n+\n+  @VisibleForTesting\n+  GroupingAggregatorFactory(\n+      String name,\n+      List<String> groupings,\n+      @Nullable Set<String> keyDimensions\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    this.name = name;\n+    this.groupings = groupings;\n+    this.keyDimensions = keyDimensions;\n+    value = groupingId(groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantAggregator(value);\n+  }\n+\n+  @Override\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantBufferAggregator(value);\n+  }\n+\n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+    return new LongConstantVectorAggregator(value);\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    return true;\n+  }\n+\n+  /**\n+   * Replace the param {@code keyDimensions} with the new set of key dimensions\n+   */\n+  public GroupingAggregatorFactory withKeyDimensions(Set<String> newKeyDimensions)\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, newKeyDimensions);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return VALUE_COMPARATOR;\n+  }\n+\n+  @JsonProperty\n+  public List<String> getGroupings()\n+  {\n+    return groupings;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  public long getValue()\n+  {\n+    return value;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (null == lhs) {\n+      return rhs;\n+    }\n+    return lhs;\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new GroupingAggregatorFactory(name, groupings, keyDimensions));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    // The aggregator doesn't need to read any fields.\n+    return Collections.emptyList();\n+  }\n+\n+  @Override\n+  public ValueType getType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public ValueType getFinalizedType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Long.BYTES;\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    CacheKeyBuilder keyBuilder = new CacheKeyBuilder(AggregatorUtil.GROUPING_CACHE_TYPE_ID)\n+        .appendStrings(groupings);\n+    if (null != keyDimensions) {\n+      keyBuilder.appendStrings(keyDimensions);\n+    }\n+    return keyBuilder.build();\n+  }\n+\n+  /**\n+   * Gives the list of grouping dimensions, return a long value where each bit at position X in the returned value\n+   * corresponds to the dimension in groupings at same position X. X is the position relative to the right end. if\n+   * keyDimensions contain the grouping dimension at position X, the bit is set to 1 at position X, otherwise it is\n+   * set to 0. An example adapted from Microsoft SQL documentation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA0NDQ1NA==", "bodyText": "It might be worth making it so these constant aggregators use the no-op aggregators as base classes, so that only the get methods need to be overridden, to let these implementations be a bit more concise.", "url": "https://github.com/apache/druid/pull/10518#discussion_r515044454", "createdAt": "2020-10-30T11:52:41Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/constant/LongConstantAggregator.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.constant;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+\n+public class LongConstantAggregator implements Aggregator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b36161f92c3651c028294f3ab96b9153bb9747be", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/b36161f92c3651c028294f3ab96b9153bb9747be", "committedDate": "2020-11-17T08:02:29Z", "message": "Add calcite tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18ec231dc043f845b884ebb7f7d4948bf08b0f37", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/18ec231dc043f845b884ebb7f7d4948bf08b0f37", "committedDate": "2020-11-19T07:18:33Z", "message": "Fix travis failures"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1ODUzMzE1", "url": "https://github.com/apache/druid/pull/10518#pullrequestreview-535853315", "createdAt": "2020-11-21T00:12:53Z", "commit": {"oid": "18ec231dc043f845b884ebb7f7d4948bf08b0f37"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDoxMjo1NFrOH3kqGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMjo0NDoxMFrOH8Qz7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAzNDMzMQ==", "bodyText": "typo: though -> thought", "url": "https://github.com/apache/druid/pull/10518#discussion_r528034331", "createdAt": "2020-11-21T00:12:54Z", "author": {"login": "jihoonson"}, "path": "docs/querying/aggregations.md", "diffHunk": "@@ -426,3 +426,25 @@ This makes it possible to compute the results of a filtered and an unfiltered ag\n   \"aggregator\" : <aggregation>\n }\n ```\n+\n+### Grouping Aggregator\n+\n+A grouping aggregator can only be used as part of GroupBy queries which have a subtotal spec. It returns a number for\n+each output row that lets you infer whether a particular dimension is included in the sub-grouping used for that row. You can pass\n+a *non-empty* list of dimensions to this aggregator which *must* be a subset of dimensions that you are grouping on. \n+E.g if the aggregator has `[\"dim1\", \"dim2\"]` as input dimensions and `[[\"dim1\", \"dim2\"], [\"dim1\"], [\"dim2\"], []]` as subtotals, \n+following can be the possible output of the aggregator\n+\n+| subtotal used in query | Output | (bits representation) |\n+|------------------------|--------|-----------------------|\n+| `[\"dim1\", \"dim2\"]`       | 3      | (11)                  |\n+| `[\"dim1\"]`               | 2      | (10)                  |\n+| `[\"dim2\"]`               | 1      | (01)                  |\n+| `[]`                     | 0      | (00)                  |  \n+\n+As illustrated in above example, output number can be though of as an unsigned n bit number where n is the number of dimensions passed to the aggregator. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18ec231dc043f845b884ebb7f7d4948bf08b0f37"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk0MTIxNg==", "bodyText": "I think this if clause is probably fine. However, if I'm reading code correctly, the new aggregators seem to do nothing and even their result is not in use but those aggregators are still involved in hash aggregation. I'm more worrying about this because it involves serializing/deserializing the aggregator values to/from off-heap memory which is pretty expensive. Because GroupingAggregatorFactory is a special aggregator type which cannot be computed by regular aggregation, can we rewrite the query to not compute them in hash aggregation but add the aggregation results as what you do now?\n\nRight. This is one change I am a bit anxious about. is there any existing benchmark I could use?\n\nGroupByBenchmark will be the easiest place for such benchmarks, but it's not probably the best place because it benchmarks the query performance of historicals. I would like to suggest to add a new one for broker performance, but this comment is not a blocker. I'm OK with adding a new benchmark in GroupByBenchmark for now.", "url": "https://github.com/apache/druid/pull/10518#discussion_r532941216", "createdAt": "2020-11-30T22:20:31Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/RowBasedGrouperHelper.java", "diffHunk": "@@ -576,7 +594,12 @@ private static ValueExtractFunction makeValueExtractFunction(\n           // Add aggregations.\n           final int resultRowAggregatorStart = query.getResultRowAggregatorStart();\n           for (int i = 0; i < entry.getValues().length; i++) {\n-            resultRow.set(resultRowAggregatorStart + i, entry.getValues()[i]);\n+            if (dimsToInclude != null && groupingAggregatorsBitSet.get(i)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk1MzcwOA=="}, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1MTAwMQ==", "bodyText": "MySQL and Postgres do seem to take more than one expressions. Check out the docs of postgres and mysql. Their behaviour seems consistent across popular database systems such as oracle and sql server. One exception is that sql server supports both grouping() and grouping_id() which behaves in an opposite way to each other. Calcite's behaviour is also consistent. Perhaps you were looking at an old version of the comment. I think Druid's behaviour should also match to most of other database systems.", "url": "https://github.com/apache/druid/pull/10518#discussion_r532951001", "createdAt": "2020-11-30T22:41:47Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.annotations.EverythingIsNonnullByDefault;\n+import org.apache.druid.query.aggregation.constant.LongConstantAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantBufferAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantVectorAggregator;\n+import org.apache.druid.query.cache.CacheKeyBuilder;\n+import org.apache.druid.segment.ColumnInspector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.vector.VectorColumnSelectorFactory;\n+import org.apache.druid.utils.CollectionUtils;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@EverythingIsNonnullByDefault\n+public class GroupingAggregatorFactory extends AggregatorFactory\n+{\n+  private static final Comparator<Long> VALUE_COMPARATOR = Long::compare;\n+  private final String name;\n+  private final List<String> groupings;\n+  private final long value;\n+  @Nullable\n+  private final Set<String> keyDimensions;\n+\n+  @JsonCreator\n+  public GroupingAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"groupings\") List<String> groupings\n+  )\n+  {\n+    this(name, groupings, null);\n+  }\n+\n+  @VisibleForTesting\n+  GroupingAggregatorFactory(\n+      String name,\n+      List<String> groupings,\n+      @Nullable Set<String> keyDimensions\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    this.name = name;\n+    this.groupings = groupings;\n+    this.keyDimensions = keyDimensions;\n+    value = groupingId(groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantAggregator(value);\n+  }\n+\n+  @Override\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantBufferAggregator(value);\n+  }\n+\n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+    return new LongConstantVectorAggregator(value);\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    return true;\n+  }\n+\n+  /**\n+   * Replace the param {@code keyDimensions} with the new set of key dimensions\n+   */\n+  public GroupingAggregatorFactory withKeyDimensions(Set<String> newKeyDimensions)\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, newKeyDimensions);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return VALUE_COMPARATOR;\n+  }\n+\n+  @JsonProperty\n+  public List<String> getGroupings()\n+  {\n+    return groupings;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  public long getValue()\n+  {\n+    return value;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (null == lhs) {\n+      return rhs;\n+    }\n+    return lhs;\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new GroupingAggregatorFactory(name, groupings, keyDimensions));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    // The aggregator doesn't need to read any fields.\n+    return Collections.emptyList();\n+  }\n+\n+  @Override\n+  public ValueType getType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public ValueType getFinalizedType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Long.BYTES;\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    CacheKeyBuilder keyBuilder = new CacheKeyBuilder(AggregatorUtil.GROUPING_CACHE_TYPE_ID)\n+        .appendStrings(groupings);\n+    if (null != keyDimensions) {\n+      keyBuilder.appendStrings(keyDimensions);\n+    }\n+    return keyBuilder.build();\n+  }\n+\n+  /**\n+   * Gives the list of grouping dimensions, return a long value where each bit at position X in the returned value\n+   * corresponds to the dimension in groupings at same position X. X is the position relative to the right end. if\n+   * keyDimensions contain the grouping dimension at position X, the bit is set to 1 at position X, otherwise it is\n+   * set to 0. An example adapted from Microsoft SQL documentation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyOTE4Mg=="}, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1MjA0Nw==", "bodyText": "If we rewrite the query to not include GroupingAggregatorFactory as I commented below, these aggregators won't be no longer in use.  GroupingAggregatorFactory can throw an exception instead when factorize() is called.", "url": "https://github.com/apache/druid/pull/10518#discussion_r532952047", "createdAt": "2020-11-30T22:44:10Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/constant/LongConstantAggregator.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.constant;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+\n+public class LongConstantAggregator implements Aggregator", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA0NDQ1NA=="}, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ae99fc38e42da00853fd9343b777f95e793df89", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/1ae99fc38e42da00853fd9343b777f95e793df89", "committedDate": "2020-12-01T07:53:47Z", "message": "bit of a change"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NTI2MTUw", "url": "https://github.com/apache/druid/pull/10518#pullrequestreview-544526150", "createdAt": "2020-12-03T22:47:26Z", "commit": {"oid": "1ae99fc38e42da00853fd9343b777f95e793df89"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMjo0NzoyNlrOH-4kwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMzoyNDo0N1rOH-5wyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcwMDY3Mg==", "bodyText": "Please add some javadoc. It would be nice to include but not necessarily limited to the followings.\n\nThis factory is for computing grouping function.\nThis factory can create LongConstant*Aggregators. Unlike other aggregators, these LongConstant*Aggregators created by this factory does nothing with computing grouping function. Instead, they are used just to hold the positions of grouping results in the ResultRow.\nThe actual computation of grouping function is done before processing each subtotal. The result of LongConstant*Aggregators is not used but replaced with the precomputed result when iterating the result of subtotal computation. See RowBasedGrouperHelper.makeGrouperIterator() for more details.\nThere could be some different approach to implement the same functionality. We chose this approach because it seems more stable and less complex than others. See #10518 (comment) for more details.", "url": "https://github.com/apache/druid/pull/10518#discussion_r535700672", "createdAt": "2020-12-03T22:47:26Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.annotations.EverythingIsNonnullByDefault;\n+import org.apache.druid.query.aggregation.constant.LongConstantAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantBufferAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantVectorAggregator;\n+import org.apache.druid.query.cache.CacheKeyBuilder;\n+import org.apache.druid.segment.ColumnInspector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.vector.VectorColumnSelectorFactory;\n+import org.apache.druid.utils.CollectionUtils;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@EverythingIsNonnullByDefault\n+public class GroupingAggregatorFactory extends AggregatorFactory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ae99fc38e42da00853fd9343b777f95e793df89"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxODA0MA==", "bodyText": "I talked to @abhishekagarwal87 offline. My biggest concern is that the special handling for GroupingAggregatorFactory seems pretty magical because the behaviour of the factory and its aggregators is different from others. What I suggested above is making it more special but less magical, because I think it's less confusing. @abhishekagarwal87's concern is mostly around the complexity of query rewriting which requires adjusting result row signature (because the result of grouping function will be missing at certain points during a query after rewrite). I think we can still handle this but maybe it could be fragile because we don't have a systemic way to handle result row signature changes during a query and thus the logic to handle them will be ad-hoc. I agree with this view, so the current structure seems reasonable even though I still think, ideally, we should not involve GroupingAggregatorFactory in hash aggregation. Maybe we can do in the future once we have some better way to handle query writing and result row signature changes.", "url": "https://github.com/apache/druid/pull/10518#discussion_r535718040", "createdAt": "2020-12-03T23:19:48Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/RowBasedGrouperHelper.java", "diffHunk": "@@ -576,7 +594,12 @@ private static ValueExtractFunction makeValueExtractFunction(\n           // Add aggregations.\n           final int resultRowAggregatorStart = query.getResultRowAggregatorStart();\n           for (int i = 0; i < entry.getValues().length; i++) {\n-            resultRow.set(resultRowAggregatorStart + i, entry.getValues()[i]);\n+            if (dimsToInclude != null && groupingAggregatorsBitSet.get(i)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk1MzcwOA=="}, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxOTIwNg==", "bodyText": "I think we can just drop the last statement here. It's opposite to what their documentation says anyway.", "url": "https://github.com/apache/druid/pull/10518#discussion_r535719206", "createdAt": "2020-12-03T23:22:33Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.annotations.EverythingIsNonnullByDefault;\n+import org.apache.druid.query.aggregation.constant.LongConstantAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantBufferAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantVectorAggregator;\n+import org.apache.druid.query.cache.CacheKeyBuilder;\n+import org.apache.druid.segment.ColumnInspector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.vector.VectorColumnSelectorFactory;\n+import org.apache.druid.utils.CollectionUtils;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@EverythingIsNonnullByDefault\n+public class GroupingAggregatorFactory extends AggregatorFactory\n+{\n+  private static final Comparator<Long> VALUE_COMPARATOR = Long::compare;\n+  private final String name;\n+  private final List<String> groupings;\n+  private final long value;\n+  @Nullable\n+  private final Set<String> keyDimensions;\n+\n+  @JsonCreator\n+  public GroupingAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"groupings\") List<String> groupings\n+  )\n+  {\n+    this(name, groupings, null);\n+  }\n+\n+  @VisibleForTesting\n+  GroupingAggregatorFactory(\n+      String name,\n+      List<String> groupings,\n+      @Nullable Set<String> keyDimensions\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    this.name = name;\n+    this.groupings = groupings;\n+    this.keyDimensions = keyDimensions;\n+    value = groupingId(groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantAggregator(value);\n+  }\n+\n+  @Override\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantBufferAggregator(value);\n+  }\n+\n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+    return new LongConstantVectorAggregator(value);\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    return true;\n+  }\n+\n+  /**\n+   * Replace the param {@code keyDimensions} with the new set of key dimensions\n+   */\n+  public GroupingAggregatorFactory withKeyDimensions(Set<String> newKeyDimensions)\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, newKeyDimensions);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return VALUE_COMPARATOR;\n+  }\n+\n+  @JsonProperty\n+  public List<String> getGroupings()\n+  {\n+    return groupings;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  public long getValue()\n+  {\n+    return value;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (null == lhs) {\n+      return rhs;\n+    }\n+    return lhs;\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new GroupingAggregatorFactory(name, groupings, keyDimensions));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    // The aggregator doesn't need to read any fields.\n+    return Collections.emptyList();\n+  }\n+\n+  @Override\n+  public ValueType getType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public ValueType getFinalizedType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Long.BYTES;\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    CacheKeyBuilder keyBuilder = new CacheKeyBuilder(AggregatorUtil.GROUPING_CACHE_TYPE_ID)\n+        .appendStrings(groupings);\n+    if (null != keyDimensions) {\n+      keyBuilder.appendStrings(keyDimensions);\n+    }\n+    return keyBuilder.build();\n+  }\n+\n+  /**\n+   * Given the list of grouping dimensions, returns a long value where each bit at position X in the returned value\n+   * corresponds to the dimension in groupings at same position X. X is the position relative to the right end. if\n+   * keyDimensions contain the grouping dimension at position X, the bit is set to 0 at position X, otherwise it is\n+   * set to 1. An example adapted from Microsoft SQL documentation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ae99fc38e42da00853fd9343b777f95e793df89"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcyMDEzOQ==", "bodyText": "Please add some comment about what is happening here.", "url": "https://github.com/apache/druid/pull/10518#discussion_r535720139", "createdAt": "2020-12-03T23:24:47Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/RowBasedGrouperHelper.java", "diffHunk": "@@ -576,7 +594,12 @@ private static ValueExtractFunction makeValueExtractFunction(\n           // Add aggregations.\n           final int resultRowAggregatorStart = query.getResultRowAggregatorStart();\n           for (int i = 0; i < entry.getValues().length; i++) {\n-            resultRow.set(resultRowAggregatorStart + i, entry.getValues()[i]);\n+            if (dimsToInclude != null && groupingAggregatorsBitSet.get(i)) {\n+              resultRow.set(resultRowAggregatorStart + i, groupingAggregatorValues[i]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ae99fc38e42da00853fd9343b777f95e793df89"}, "originalPosition": 63}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6dd363203dd13d21657ebf38af0a837df96218e4", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/6dd363203dd13d21657ebf38af0a837df96218e4", "committedDate": "2020-12-04T11:33:09Z", "message": "Add documentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1MzcwMjA1", "url": "https://github.com/apache/druid/pull/10518#pullrequestreview-545370205", "createdAt": "2020-12-04T23:57:32Z", "commit": {"oid": "6dd363203dd13d21657ebf38af0a837df96218e4"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzo1NzozMlrOH_maUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzo1ODoyNFrOH_mbIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ1MTY2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *                             {@code groupings0}. This argument cannot be passed by the user. It is set by druid engine\n          \n          \n            \n             *                             {@code groupings}. This argument cannot be passed by the user. It is set by druid engine", "url": "https://github.com/apache/druid/pull/10518#discussion_r536451667", "createdAt": "2020-12-04T23:57:32Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "diffHunk": "@@ -41,6 +41,40 @@\n import java.util.Objects;\n import java.util.Set;\n \n+/**\n+ * This class implements {@code grouping_id} function to determine the grouping that a row is part of. Different rows\n+ * in same result could have different grouping columns when subtotals are used.\n+ *\n+ * It takes following arguments\n+ *  - {@code name} - Name of aggregators\n+ *  - {code groupings} - List of dimensions that user is interested in tracking\n+ *  - {@code keyDimensions} - The list of grouping dimensions being included in the result row. This list is a subset of\n+ *                             {@code groupings0}. This argument cannot be passed by the user. It is set by druid engine", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6dd363203dd13d21657ebf38af0a837df96218e4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ1MTg3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *  - {code groupings} - List of dimensions that user is interested in tracking\n          \n          \n            \n             *  - {@code groupings} - List of dimensions that user is interested in tracking", "url": "https://github.com/apache/druid/pull/10518#discussion_r536451874", "createdAt": "2020-12-04T23:58:24Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "diffHunk": "@@ -41,6 +41,40 @@\n import java.util.Objects;\n import java.util.Set;\n \n+/**\n+ * This class implements {@code grouping_id} function to determine the grouping that a row is part of. Different rows\n+ * in same result could have different grouping columns when subtotals are used.\n+ *\n+ * It takes following arguments\n+ *  - {@code name} - Name of aggregators\n+ *  - {code groupings} - List of dimensions that user is interested in tracking", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6dd363203dd13d21657ebf38af0a837df96218e4"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1Mzc1MTU0", "url": "https://github.com/apache/druid/pull/10518#pullrequestreview-545375154", "createdAt": "2020-12-05T00:18:38Z", "commit": {"oid": "6dd363203dd13d21657ebf38af0a837df96218e4"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMDoxODozOFrOH_mwOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMDoxODozOFrOH_mwOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ1NzI3NA==", "bodyText": "nit: javadoc comment format on inline comment", "url": "https://github.com/apache/druid/pull/10518#discussion_r536457274", "createdAt": "2020-12-05T00:18:38Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/RowBasedGrouperHelper.java", "diffHunk": "@@ -534,21 +536,45 @@ private static ValueExtractFunction makeValueExtractFunction(\n   public static CloseableGrouperIterator<RowBasedKey, ResultRow> makeGrouperIterator(\n       final Grouper<RowBasedKey> grouper,\n       final GroupByQuery query,\n-      @Nullable final List<String> dimsToInclude,\n+      @Nullable final List<DimensionSpec> dimsToInclude,\n       final Closeable closeable\n   )\n   {\n     final boolean includeTimestamp = query.getResultRowHasTimestamp();\n     final BitSet dimsToIncludeBitSet = new BitSet(query.getDimensions().size());\n     final int resultRowDimensionStart = query.getResultRowDimensionStart();\n+    final BitSet groupingAggregatorsBitSet = new BitSet(query.getAggregatorSpecs().size());\n+    final Object[] groupingAggregatorValues = new Long[query.getAggregatorSpecs().size()];\n \n     if (dimsToInclude != null) {\n-      for (String dimension : dimsToInclude) {\n-        final int dimIndex = query.getResultRowSignature().indexOf(dimension);\n+      for (DimensionSpec dimensionSpec : dimsToInclude) {\n+        String outputName = dimensionSpec.getOutputName();\n+        final int dimIndex = query.getResultRowSignature().indexOf(outputName);\n         if (dimIndex >= 0) {\n           dimsToIncludeBitSet.set(dimIndex - resultRowDimensionStart);\n         }\n       }\n+\n+      /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6dd363203dd13d21657ebf38af0a837df96218e4"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fc9a1b5f093baf75eecb4c46d5d24dc5b657bf6", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/5fc9a1b5f093baf75eecb4c46d5d24dc5b657bf6", "committedDate": "2020-12-06T10:09:41Z", "message": "Fix typos"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8678c78d770bce2dda47a4dc15589ead42243bc4", "author": {"user": {"login": "abhishekagarwal87", "name": "Abhishek Agarwal"}}, "url": "https://github.com/apache/druid/commit/8678c78d770bce2dda47a4dc15589ead42243bc4", "committedDate": "2020-12-07T10:48:47Z", "message": "typo fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NDI4Mzc2", "url": "https://github.com/apache/druid/pull/10518#pullrequestreview-547428376", "createdAt": "2020-12-08T16:52:14Z", "commit": {"oid": "8678c78d770bce2dda47a4dc15589ead42243bc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjo1MjoxNFrOIBpLfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjo1MjoxNFrOIBpLfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU5NDE3NA==", "bodyText": "@abhishekagarwal87 I don't think this anchor will work (our doc generators don't include spaces in anchors). Could you please double-check it?", "url": "https://github.com/apache/druid/pull/10518#discussion_r538594174", "createdAt": "2020-12-08T16:52:14Z", "author": {"login": "gianm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -337,6 +338,7 @@ Only the COUNT aggregation can accept DISTINCT.\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`ANY_VALUE(expr)`|Returns any value of `expr` including null. `expr` must be numeric. This aggregator can simplify and optimize the performance by returning the first encountered value (including null)|\n |`ANY_VALUE(expr, maxBytesPerString)`|Like `ANY_VALUE(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n+|`GROUPING(expr, expr...)`|Returns a number to indicate which groupBy dimension is included in a row, when using `GROUPING SETS`. Refer to [additional documentation](aggregations.md#Grouping Aggregator) on how to infer this number.|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8678c78d770bce2dda47a4dc15589ead42243bc4"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NDI4OTY5", "url": "https://github.com/apache/druid/pull/10518#pullrequestreview-547428969", "createdAt": "2020-12-08T16:52:50Z", "commit": {"oid": "8678c78d770bce2dda47a4dc15589ead42243bc4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjo1Mjo1MFrOIBpOZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjo1Mjo1MFrOIBpOZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU5NDkxNw==", "bodyText": "@abhishekagarwal87 Extraneous whitespace before the , might interfere with rendering. (I'm not sure, but it looks suspicious.)", "url": "https://github.com/apache/druid/pull/10518#discussion_r538594917", "createdAt": "2020-12-08T16:52:50Z", "author": {"login": "gianm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -99,7 +99,8 @@ total. Finally, GROUP BY CUBE computes a grouping set for each combination of gr\n `GROUP BY CUBE (country, city)` is equivalent to `GROUP BY GROUPING SETS ( (country, city), (country), (city), () )`.\n Grouping columns that do not apply to a particular row will contain `NULL`. For example, when computing\n `GROUP BY GROUPING SETS ( (country, city), () )`, the grand total row corresponding to `()` will have `NULL` for the\n-\"country\" and \"city\" columns.\n+\"country\" and \"city\" columns. Column may also be `NULL` if it was `NULL` in the data itself. To differentiate such rows\n+, you can use `GROUPING` aggregation. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8678c78d770bce2dda47a4dc15589ead42243bc4"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3385, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}