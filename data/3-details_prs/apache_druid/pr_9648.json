{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNzk2NjE3", "number": 9648, "title": "SQL: More straightforward handling of join planning.", "bodyText": "Two changes that simplify how joins are planned:\n\n\nStop using JoinProjectTransposeRule as a way of guiding subquery\nremoval. Instead, add logic to DruidJoinRule that identifies removable\nsubqueries and removes them at the point of creating a DruidJoinQueryRel.\nThis approach reduces the size of the planning space and allows the\nplanner to complete quickly.\n\n\nRemove rules that reorder joins. Not because of an impact on the\nplanning time (it seems minimal), but because the decisions that the\nplanner was making in the new tests were sometimes worse than the\nuser-provided order. I think we'll need to go with the user-provided\norder for now, and revisit reordering when we can add more smarts to\nthe cost estimator.\n\n\nA third change updates numeric ExprEval classes to store their\nvalue as a boxed type that corresponds to what it is supposed to be.\nThis is useful because it affects the behavior of \"asString\", and\nis included in this patch because it is needed for the new test\n\"testInnerJoinTwoLookupsToTableUsingNumericColumnInReverse\". This\ntest relies on CAST('6', 'DOUBLE') stringifying to \"6.0\" like an\nactual double would.\nFixes #9646.", "createdAt": "2020-04-08T11:40:39Z", "url": "https://github.com/apache/druid/pull/9648", "merged": true, "mergeCommit": {"oid": "75c543b50f40d7b6739ff0d6e10a81315be29736"}, "closed": true, "closedAt": "2020-04-09T23:21:44Z", "author": {"login": "gianm"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcVmZjsAH2gAyNDAwNzk2NjE3OmIzNWZjODlhMmIzNjNkNTJiZjA4YjUzODRiMjBhNTRiNDFmODE1ZjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcWD_HMAFqTM5MTE2NTgzNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b35fc89a2b363d52bf08b5384b20a54b41f815f2", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/b35fc89a2b363d52bf08b5384b20a54b41f815f2", "committedDate": "2020-04-08T11:42:48Z", "message": "SQL: More straightforward handling of join planning.\n\nTwo changes that simplify how joins are planned:\n\n1) Stop using JoinProjectTransposeRule as a way of guiding subquery\nremoval. Instead, add logic to DruidJoinRule that identifies removable\nsubqueries and removes them at the point of creating a DruidJoinQueryRel.\nThis approach reduces the size of the planning space and allows the\nplanner to complete quickly.\n\n2) Remove rules that reorder joins. Not because of an impact on the\nplanning time (it seems minimal), but because the decisions that the\nplanner was making in the new tests were sometimes worse than the\nuser-provided order. I think we'll need to go with the user-provided\norder for now, and revisit reordering when we can add more smarts to\nthe cost estimator.\n\nA third change updates numeric ExprEval classes to store their\nvalue as a boxed type that corresponds to what it is supposed to be.\nThis is useful because it affects the behavior of \"asString\", and\nis included in this patch because it is needed for the new test\n\"testInnerJoinTwoLookupsToTableUsingNumericColumnInReverse\". This\ntest relies on CAST('6', 'DOUBLE') stringifying to \"6.0\" like an\nactual double would.\n\nFixes #9646."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "b35fc89a2b363d52bf08b5384b20a54b41f815f2", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/b35fc89a2b363d52bf08b5384b20a54b41f815f2", "committedDate": "2020-04-08T11:42:48Z", "message": "SQL: More straightforward handling of join planning.\n\nTwo changes that simplify how joins are planned:\n\n1) Stop using JoinProjectTransposeRule as a way of guiding subquery\nremoval. Instead, add logic to DruidJoinRule that identifies removable\nsubqueries and removes them at the point of creating a DruidJoinQueryRel.\nThis approach reduces the size of the planning space and allows the\nplanner to complete quickly.\n\n2) Remove rules that reorder joins. Not because of an impact on the\nplanning time (it seems minimal), but because the decisions that the\nplanner was making in the new tests were sometimes worse than the\nuser-provided order. I think we'll need to go with the user-provided\norder for now, and revisit reordering when we can add more smarts to\nthe cost estimator.\n\nA third change updates numeric ExprEval classes to store their\nvalue as a boxed type that corresponds to what it is supposed to be.\nThis is useful because it affects the behavior of \"asString\", and\nis included in this patch because it is needed for the new test\n\"testInnerJoinTwoLookupsToTableUsingNumericColumnInReverse\". This\ntest relies on CAST('6', 'DOUBLE') stringifying to \"6.0\" like an\nactual double would.\n\nFixes #9646."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37bdd608922c4d6447fd7d406801e9b8a5f06572", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/37bdd608922c4d6447fd7d406801e9b8a5f06572", "committedDate": "2020-04-08T11:56:34Z", "message": "Fix comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "915c324b7ad37fd7dfb398a54ff70385900ff2dc", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/915c324b7ad37fd7dfb398a54ff70385900ff2dc", "committedDate": "2020-04-08T21:30:45Z", "message": "Fix tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNjY2NjYw", "url": "https://github.com/apache/druid/pull/9648#pullrequestreview-390666660", "createdAt": "2020-04-09T10:16:35Z", "commit": {"oid": "915c324b7ad37fd7dfb398a54ff70385900ff2dc"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDoxNjozNlrOGDSlsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQxMDoyNzoxOFrOGDS7nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwMzQ3NQ==", "bodyText": "nit: javadocs might make these a bit friendlier (comments and javadoc are very nice up to this point)", "url": "https://github.com/apache/druid/pull/9648#discussion_r406103475", "createdAt": "2020-04-09T10:16:36Z", "author": {"login": "clintropolis"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java", "diffHunk": "@@ -148,4 +246,148 @@ static boolean canHandleCondition(final RexNode condition, final RelDataType lef\n \n     return retVal;\n   }\n+\n+  private static boolean isLeftExpression(final RexNode rexNode, final int numLeftFields)\n+  {\n+    return ImmutableBitSet.range(numLeftFields).contains(RelOptUtil.InputFinder.bits(rexNode));\n+  }\n+\n+  private static boolean isRightInputRef(final RexNode rexNode, final int numLeftFields)\n+  {\n+    return rexNode.isA(SqlKind.INPUT_REF) && ((RexInputRef) rexNode).getIndex() >= numLeftFields;\n+  }\n+\n+  @VisibleForTesting\n+  static class ConditionAnalysis\n+  {\n+    /**\n+     * Number of fields on the left-hand side. Useful for identifying if a particular field is from on the left\n+     * or right side of a join.\n+     */\n+    private final int numLeftFields;\n+\n+    /**\n+     * Each equality subcondition is an equality of the form f(LeftRel) = g(RightRel).\n+     */\n+    private final List<Pair<RexNode, RexInputRef>> equalitySubConditions;\n+\n+    /**\n+     * Each literal subcondition is... a literal.\n+     */\n+    private final List<RexLiteral> literalSubConditions;\n+\n+    ConditionAnalysis(\n+        int numLeftFields,\n+        List<Pair<RexNode, RexInputRef>> equalitySubConditions,\n+        List<RexLiteral> literalSubConditions\n+    )\n+    {\n+      this.numLeftFields = numLeftFields;\n+      this.equalitySubConditions = equalitySubConditions;\n+      this.literalSubConditions = literalSubConditions;\n+    }\n+\n+    public ConditionAnalysis pushThroughLeftProject(final Project leftProject)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "915c324b7ad37fd7dfb398a54ff70385900ff2dc"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwNzI2Mg==", "bodyText": "I can't think of any specific examples off the top of my head, but I know we've seen a handful of performance issues using .stream(); I don't think anything needs to change right now, just commenting to increase the chances I'll remember this area as much as anything else as a potential area to look at to make small gains in planning time in the future.\nI don't imagine these collections will be so large, so maybe isn't a very big deal, but then again could maybe add up depending how planning goes and how many times this stuff gets evaluated.", "url": "https://github.com/apache/druid/pull/9648#discussion_r406107262", "createdAt": "2020-04-09T10:23:51Z", "author": {"login": "clintropolis"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java", "diffHunk": "@@ -148,4 +246,148 @@ static boolean canHandleCondition(final RexNode condition, final RelDataType lef\n \n     return retVal;\n   }\n+\n+  private static boolean isLeftExpression(final RexNode rexNode, final int numLeftFields)\n+  {\n+    return ImmutableBitSet.range(numLeftFields).contains(RelOptUtil.InputFinder.bits(rexNode));\n+  }\n+\n+  private static boolean isRightInputRef(final RexNode rexNode, final int numLeftFields)\n+  {\n+    return rexNode.isA(SqlKind.INPUT_REF) && ((RexInputRef) rexNode).getIndex() >= numLeftFields;\n+  }\n+\n+  @VisibleForTesting\n+  static class ConditionAnalysis\n+  {\n+    /**\n+     * Number of fields on the left-hand side. Useful for identifying if a particular field is from on the left\n+     * or right side of a join.\n+     */\n+    private final int numLeftFields;\n+\n+    /**\n+     * Each equality subcondition is an equality of the form f(LeftRel) = g(RightRel).\n+     */\n+    private final List<Pair<RexNode, RexInputRef>> equalitySubConditions;\n+\n+    /**\n+     * Each literal subcondition is... a literal.\n+     */\n+    private final List<RexLiteral> literalSubConditions;\n+\n+    ConditionAnalysis(\n+        int numLeftFields,\n+        List<Pair<RexNode, RexInputRef>> equalitySubConditions,\n+        List<RexLiteral> literalSubConditions\n+    )\n+    {\n+      this.numLeftFields = numLeftFields;\n+      this.equalitySubConditions = equalitySubConditions;\n+      this.literalSubConditions = literalSubConditions;\n+    }\n+\n+    public ConditionAnalysis pushThroughLeftProject(final Project leftProject)\n+    {\n+      // Pushing through the project will shift right-hand field references by this amount.\n+      final int rhsShift =\n+          leftProject.getInput().getRowType().getFieldCount() - leftProject.getRowType().getFieldCount();\n+\n+      return new ConditionAnalysis(\n+          leftProject.getInput().getRowType().getFieldCount(),\n+          equalitySubConditions\n+              .stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "915c324b7ad37fd7dfb398a54ff70385900ff2dc"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjEwOTA4NQ==", "bodyText": "Out of curiosity where did these numbers come from? Experiments I guess?", "url": "https://github.com/apache/druid/pull/9648#discussion_r406109085", "createdAt": "2020-04-09T10:27:18Z", "author": {"login": "clintropolis"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/CostEstimates.java", "diffHunk": "@@ -74,13 +74,19 @@\n    * Multiplier to apply to an outer query via {@link DruidOuterQueryRel}. Encourages pushing down time-saving\n    * operations to the lowest level of the query stack, because they'll have bigger impact there.\n    */\n-  static final double MULTIPLIER_OUTER_QUERY = 0.1;\n+  static final double MULTIPLIER_OUTER_QUERY = .1;\n \n   /**\n-   * Multiplier to apply to a join when the left-hand side is a subquery. Encourages avoiding subqueries. Subqueries\n-   * inside joins must be inlined, which incurs substantial reduction in scalability, so this high number is justified.\n+   * Cost to add to a join when either side is a subquery. Strongly encourages avoiding subqueries, since they must be\n+   * inlined and then the join must run on the Broker.\n    */\n-  static final double MULTIPLIER_JOIN_SUBQUERY = 1000000000;\n+  static final double COST_JOIN_SUBQUERY = 1e5;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "915c324b7ad37fd7dfb398a54ff70385900ff2dc"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwNTAyNjk5", "url": "https://github.com/apache/druid/pull/9648#pullrequestreview-390502699", "createdAt": "2020-04-09T05:38:21Z", "commit": {"oid": "915c324b7ad37fd7dfb398a54ff70385900ff2dc"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwNTozODoyMVrOGDKPew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQwNTo1MDozNlrOGDKc8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk2NjcxNQ==", "bodyText": "should we add a branch to set the cost to 0 if the joinCondition is a literal and is always false?\nsince a false join condition means nothing will match therefore you don't need to do work for either the left or the right hand side?", "url": "https://github.com/apache/druid/pull/9648#discussion_r405966715", "createdAt": "2020-04-09T05:38:21Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -336,10 +293,23 @@ protected RelDataType deriveRowType()\n   @Override\n   public RelOptCost computeSelfCost(final RelOptPlanner planner, final RelMetadataQuery mq)\n   {\n-    return planner.getCostFactory()\n-                  .makeCost(partialQuery.estimateCost(), 0, 0)\n-                  .multiplyBy(leftRequiresSubquery ? CostEstimates.MULTIPLIER_JOIN_SUBQUERY : 1)\n-                  .multiplyBy(rightRequiresSubquery ? CostEstimates.MULTIPLIER_JOIN_SUBQUERY : 1);\n+    double cost;\n+\n+    if (computeLeftRequiresSubquery(getSomeDruidChild(left))) {\n+      cost = CostEstimates.COST_JOIN_SUBQUERY;\n+    } else {\n+      cost = partialQuery.estimateCost();\n+    }\n+\n+    if (computeRightRequiresSubquery(getSomeDruidChild(right))) {\n+      cost += CostEstimates.COST_JOIN_SUBQUERY;\n+    }\n+\n+    if (joinRel.getCondition().isA(SqlKind.LITERAL) && !joinRel.getCondition().isAlwaysFalse()) {\n+      cost += CostEstimates.COST_JOIN_CROSS;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "915c324b7ad37fd7dfb398a54ff70385900ff2dc"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk3MDE2MQ==", "bodyText": "how do we know this will be a RelSubset? I couldn't trace that path down here", "url": "https://github.com/apache/druid/pull/9648#discussion_r405970161", "createdAt": "2020-04-09T05:50:36Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -395,4 +365,14 @@ private static boolean computeRightRequiresSubquery(final DruidRel<?> right)\n \n     return Pair.of(rightPrefix, signatureBuilder.build());\n   }\n+\n+  private static DruidRel<?> getSomeDruidChild(final RelNode child)\n+  {\n+    if (child instanceof DruidRel) {\n+      return (DruidRel<?>) child;\n+    } else {\n+      final RelSubset subset = (RelSubset) child;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "915c324b7ad37fd7dfb398a54ff70385900ff2dc"}, "originalPosition": 196}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMDg3NTM1", "url": "https://github.com/apache/druid/pull/9648#pullrequestreview-391087535", "createdAt": "2020-04-09T19:53:20Z", "commit": {"oid": "915c324b7ad37fd7dfb398a54ff70385900ff2dc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTQzNDQ4", "url": "https://github.com/apache/druid/pull/9648#pullrequestreview-391143448", "createdAt": "2020-04-09T21:26:05Z", "commit": {"oid": "915c324b7ad37fd7dfb398a54ff70385900ff2dc"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMToyNjowNVrOGDp_Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOVQyMToyNzo1MlrOGDqCFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NjgyMw==", "bodyText": "ah makes sense", "url": "https://github.com/apache/druid/pull/9648#discussion_r406486823", "createdAt": "2020-04-09T21:26:05Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -336,10 +293,23 @@ protected RelDataType deriveRowType()\n   @Override\n   public RelOptCost computeSelfCost(final RelOptPlanner planner, final RelMetadataQuery mq)\n   {\n-    return planner.getCostFactory()\n-                  .makeCost(partialQuery.estimateCost(), 0, 0)\n-                  .multiplyBy(leftRequiresSubquery ? CostEstimates.MULTIPLIER_JOIN_SUBQUERY : 1)\n-                  .multiplyBy(rightRequiresSubquery ? CostEstimates.MULTIPLIER_JOIN_SUBQUERY : 1);\n+    double cost;\n+\n+    if (computeLeftRequiresSubquery(getSomeDruidChild(left))) {\n+      cost = CostEstimates.COST_JOIN_SUBQUERY;\n+    } else {\n+      cost = partialQuery.estimateCost();\n+    }\n+\n+    if (computeRightRequiresSubquery(getSomeDruidChild(right))) {\n+      cost += CostEstimates.COST_JOIN_SUBQUERY;\n+    }\n+\n+    if (joinRel.getCondition().isA(SqlKind.LITERAL) && !joinRel.getCondition().isAlwaysFalse()) {\n+      cost += CostEstimates.COST_JOIN_CROSS;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk2NjcxNQ=="}, "originalCommit": {"oid": "915c324b7ad37fd7dfb398a54ff70385900ff2dc"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ4NzU3NQ==", "bodyText": "when I wrote this, I was wondering whether bindable parameters would change the node here somehow. The calcite query tests are pretty comprehensive around different types of JOINs and nested queries, that I feel pretty confident to agree with your understanding. Any chance you can test this with parameterized sql.", "url": "https://github.com/apache/druid/pull/9648#discussion_r406487575", "createdAt": "2020-04-09T21:27:52Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -395,4 +365,14 @@ private static boolean computeRightRequiresSubquery(final DruidRel<?> right)\n \n     return Pair.of(rightPrefix, signatureBuilder.build());\n   }\n+\n+  private static DruidRel<?> getSomeDruidChild(final RelNode child)\n+  {\n+    if (child instanceof DruidRel) {\n+      return (DruidRel<?>) child;\n+    } else {\n+      final RelSubset subset = (RelSubset) child;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTk3MDE2MQ=="}, "originalCommit": {"oid": "915c324b7ad37fd7dfb398a54ff70385900ff2dc"}, "originalPosition": 196}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMTY1ODM1", "url": "https://github.com/apache/druid/pull/9648#pullrequestreview-391165835", "createdAt": "2020-04-09T22:11:04Z", "commit": {"oid": "915c324b7ad37fd7dfb398a54ff70385900ff2dc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2473, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}