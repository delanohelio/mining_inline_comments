{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkwNzI2NTgx", "number": 10417, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMToyNzo1N1rOEmRWCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMjoyOTowM1rOEmSWGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTY1NTEyOnYy", "diffSide": "RIGHT", "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMToyNzo1N1rOHWNBEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMToyNzo1N1rOHWNBEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA0Mzk4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    dimension. For best-effort rollup, you should use dynamic.\n          \n          \n            \n                    dimension). For best-effort rollup, you should use <Code>dynamic</Code>.", "url": "https://github.com/apache/druid/pull/10417#discussion_r493043987", "createdAt": "2020-09-22T21:27:57Z", "author": {"login": "ccaominh"}, "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "diffHunk": "@@ -16,101 +16,242 @@\n  * limitations under the License.\n  */\n \n-import { Button, Classes, Dialog, Intent } from '@blueprintjs/core';\n+import { Button, ButtonGroup, Classes, Code, Dialog, FormGroup, Intent } from '@blueprintjs/core';\n import React, { useState } from 'react';\n \n-import { AutoForm, ExternalLink, Field } from '../../components';\n-import { getLink } from '../../links';\n+import { AutoForm, Field, JsonInput } from '../../components';\n+import { deepGet, deepSet } from '../../utils/object-change';\n \n import './compaction-dialog.scss';\n \n export const DEFAULT_MAX_ROWS_PER_SEGMENT = 5000000;\n \n-const COMPACTION_CONFIG_FIELDS: Field<Record<string, any>>[] = [\n+type Tabs = 'form' | 'json';\n+\n+type CompactionConfig = Record<string, any>;\n+\n+const COMPACTION_CONFIG_FIELDS: Field<CompactionConfig>[] = [\n   {\n-    name: 'inputSegmentSizeBytes',\n-    type: 'number',\n-    defaultValue: 419430400,\n+    name: 'skipOffsetFromLatest',\n+    type: 'string',\n+    defaultValue: 'P1D',\n     info: (\n       <p>\n-        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n-        be processed in its entirety, if the segments for a particular time chunk have a total size\n-        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n-        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n-        result in compaction tasks taking an excessive amount of time.\n+        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n+        dataSources.\n       </p>\n     ),\n   },\n   {\n-    name: 'skipOffsetFromLatest',\n+    name: 'tuningConfig.partitionsSpec.type',\n+    label: 'Partitioning type',\n     type: 'string',\n-    defaultValue: 'P1D',\n+    suggestions: ['dynamic', 'hashed', 'single_dim'],\n     info: (\n       <p>\n-        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n-        dataSources.\n+        For perfect rollup, you should use either <Code>hashed</Code> (partitioning based on the\n+        hash of dimensions in each row) or <Code>single_dim</Code> (based on ranges of a single\n+        dimension. For best-effort rollup, you should use dynamic.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58cc07f4b1e7e8a68a82d567bcf1a8a03ef58c1c"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTY5ODAwOnYy", "diffSide": "RIGHT", "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMTo0MjoyOVrOHWNacA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMjozNTo0MVrOHWUO4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA1MDQ4MA==", "bodyText": "For reference, #10419 will make this optional", "url": "https://github.com/apache/druid/pull/10417#discussion_r493050480", "createdAt": "2020-09-22T21:42:29Z", "author": {"login": "ccaominh"}, "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "diffHunk": "@@ -16,101 +16,242 @@\n  * limitations under the License.\n  */\n \n-import { Button, Classes, Dialog, Intent } from '@blueprintjs/core';\n+import { Button, ButtonGroup, Classes, Code, Dialog, FormGroup, Intent } from '@blueprintjs/core';\n import React, { useState } from 'react';\n \n-import { AutoForm, ExternalLink, Field } from '../../components';\n-import { getLink } from '../../links';\n+import { AutoForm, Field, JsonInput } from '../../components';\n+import { deepGet, deepSet } from '../../utils/object-change';\n \n import './compaction-dialog.scss';\n \n export const DEFAULT_MAX_ROWS_PER_SEGMENT = 5000000;\n \n-const COMPACTION_CONFIG_FIELDS: Field<Record<string, any>>[] = [\n+type Tabs = 'form' | 'json';\n+\n+type CompactionConfig = Record<string, any>;\n+\n+const COMPACTION_CONFIG_FIELDS: Field<CompactionConfig>[] = [\n   {\n-    name: 'inputSegmentSizeBytes',\n-    type: 'number',\n-    defaultValue: 419430400,\n+    name: 'skipOffsetFromLatest',\n+    type: 'string',\n+    defaultValue: 'P1D',\n     info: (\n       <p>\n-        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n-        be processed in its entirety, if the segments for a particular time chunk have a total size\n-        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n-        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n-        result in compaction tasks taking an excessive amount of time.\n+        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n+        dataSources.\n       </p>\n     ),\n   },\n   {\n-    name: 'skipOffsetFromLatest',\n+    name: 'tuningConfig.partitionsSpec.type',\n+    label: 'Partitioning type',\n     type: 'string',\n-    defaultValue: 'P1D',\n+    suggestions: ['dynamic', 'hashed', 'single_dim'],\n     info: (\n       <p>\n-        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n-        dataSources.\n+        For perfect rollup, you should use either <Code>hashed</Code> (partitioning based on the\n+        hash of dimensions in each row) or <Code>single_dim</Code> (based on ranges of a single\n+        dimension. For best-effort rollup, you should use dynamic.\n       </p>\n     ),\n   },\n+  // partitionsSpec type: dynamic\n   {\n-    name: 'maxRowsPerSegment',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: DEFAULT_MAX_ROWS_PER_SEGMENT,\n-    info: <p>Determines how many rows are in each segment.</p>,\n+    defaultValue: 5000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Determines how many rows are in each segment.</>,\n   },\n   {\n-    name: 'taskContext',\n-    type: 'json',\n+    name: 'tuningConfig.partitionsSpec.maxTotalRows',\n+    label: 'Max total rows',\n+    type: 'number',\n+    defaultValue: 20000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Total number of rows in segments waiting for being pushed.</>,\n+  },\n+  // partitionsSpec type: hashed\n+  {\n+    name: 'tuningConfig.partitionsSpec.numShards',\n+    label: 'Num shards',\n+    type: 'number',\n+    required: true, // ToDo: this will no longer be required soon", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58cc07f4b1e7e8a68a82d567bcf1a8a03ef58c1c"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2MjIxMQ==", "bodyText": "will note", "url": "https://github.com/apache/druid/pull/10417#discussion_r493162211", "createdAt": "2020-09-23T02:35:41Z", "author": {"login": "vogievetsky"}, "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "diffHunk": "@@ -16,101 +16,242 @@\n  * limitations under the License.\n  */\n \n-import { Button, Classes, Dialog, Intent } from '@blueprintjs/core';\n+import { Button, ButtonGroup, Classes, Code, Dialog, FormGroup, Intent } from '@blueprintjs/core';\n import React, { useState } from 'react';\n \n-import { AutoForm, ExternalLink, Field } from '../../components';\n-import { getLink } from '../../links';\n+import { AutoForm, Field, JsonInput } from '../../components';\n+import { deepGet, deepSet } from '../../utils/object-change';\n \n import './compaction-dialog.scss';\n \n export const DEFAULT_MAX_ROWS_PER_SEGMENT = 5000000;\n \n-const COMPACTION_CONFIG_FIELDS: Field<Record<string, any>>[] = [\n+type Tabs = 'form' | 'json';\n+\n+type CompactionConfig = Record<string, any>;\n+\n+const COMPACTION_CONFIG_FIELDS: Field<CompactionConfig>[] = [\n   {\n-    name: 'inputSegmentSizeBytes',\n-    type: 'number',\n-    defaultValue: 419430400,\n+    name: 'skipOffsetFromLatest',\n+    type: 'string',\n+    defaultValue: 'P1D',\n     info: (\n       <p>\n-        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n-        be processed in its entirety, if the segments for a particular time chunk have a total size\n-        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n-        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n-        result in compaction tasks taking an excessive amount of time.\n+        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n+        dataSources.\n       </p>\n     ),\n   },\n   {\n-    name: 'skipOffsetFromLatest',\n+    name: 'tuningConfig.partitionsSpec.type',\n+    label: 'Partitioning type',\n     type: 'string',\n-    defaultValue: 'P1D',\n+    suggestions: ['dynamic', 'hashed', 'single_dim'],\n     info: (\n       <p>\n-        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n-        dataSources.\n+        For perfect rollup, you should use either <Code>hashed</Code> (partitioning based on the\n+        hash of dimensions in each row) or <Code>single_dim</Code> (based on ranges of a single\n+        dimension. For best-effort rollup, you should use dynamic.\n       </p>\n     ),\n   },\n+  // partitionsSpec type: dynamic\n   {\n-    name: 'maxRowsPerSegment',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: DEFAULT_MAX_ROWS_PER_SEGMENT,\n-    info: <p>Determines how many rows are in each segment.</p>,\n+    defaultValue: 5000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Determines how many rows are in each segment.</>,\n   },\n   {\n-    name: 'taskContext',\n-    type: 'json',\n+    name: 'tuningConfig.partitionsSpec.maxTotalRows',\n+    label: 'Max total rows',\n+    type: 'number',\n+    defaultValue: 20000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Total number of rows in segments waiting for being pushed.</>,\n+  },\n+  // partitionsSpec type: hashed\n+  {\n+    name: 'tuningConfig.partitionsSpec.numShards',\n+    label: 'Num shards',\n+    type: 'number',\n+    required: true, // ToDo: this will no longer be required soon", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA1MDQ4MA=="}, "originalCommit": {"oid": "58cc07f4b1e7e8a68a82d567bcf1a8a03ef58c1c"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTY5ODM1OnYy", "diffSide": "RIGHT", "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMTo0MjozNlrOHWNapw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNToyMzo0NVrOHW0BZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA1MDUzNQ==", "bodyText": "The sentence \"numShards cannot be specified if maxRowsPerSegment is set\" can be removed since numShards is required.", "url": "https://github.com/apache/druid/pull/10417#discussion_r493050535", "createdAt": "2020-09-22T21:42:36Z", "author": {"login": "ccaominh"}, "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "diffHunk": "@@ -16,101 +16,242 @@\n  * limitations under the License.\n  */\n \n-import { Button, Classes, Dialog, Intent } from '@blueprintjs/core';\n+import { Button, ButtonGroup, Classes, Code, Dialog, FormGroup, Intent } from '@blueprintjs/core';\n import React, { useState } from 'react';\n \n-import { AutoForm, ExternalLink, Field } from '../../components';\n-import { getLink } from '../../links';\n+import { AutoForm, Field, JsonInput } from '../../components';\n+import { deepGet, deepSet } from '../../utils/object-change';\n \n import './compaction-dialog.scss';\n \n export const DEFAULT_MAX_ROWS_PER_SEGMENT = 5000000;\n \n-const COMPACTION_CONFIG_FIELDS: Field<Record<string, any>>[] = [\n+type Tabs = 'form' | 'json';\n+\n+type CompactionConfig = Record<string, any>;\n+\n+const COMPACTION_CONFIG_FIELDS: Field<CompactionConfig>[] = [\n   {\n-    name: 'inputSegmentSizeBytes',\n-    type: 'number',\n-    defaultValue: 419430400,\n+    name: 'skipOffsetFromLatest',\n+    type: 'string',\n+    defaultValue: 'P1D',\n     info: (\n       <p>\n-        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n-        be processed in its entirety, if the segments for a particular time chunk have a total size\n-        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n-        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n-        result in compaction tasks taking an excessive amount of time.\n+        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n+        dataSources.\n       </p>\n     ),\n   },\n   {\n-    name: 'skipOffsetFromLatest',\n+    name: 'tuningConfig.partitionsSpec.type',\n+    label: 'Partitioning type',\n     type: 'string',\n-    defaultValue: 'P1D',\n+    suggestions: ['dynamic', 'hashed', 'single_dim'],\n     info: (\n       <p>\n-        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n-        dataSources.\n+        For perfect rollup, you should use either <Code>hashed</Code> (partitioning based on the\n+        hash of dimensions in each row) or <Code>single_dim</Code> (based on ranges of a single\n+        dimension. For best-effort rollup, you should use dynamic.\n       </p>\n     ),\n   },\n+  // partitionsSpec type: dynamic\n   {\n-    name: 'maxRowsPerSegment',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: DEFAULT_MAX_ROWS_PER_SEGMENT,\n-    info: <p>Determines how many rows are in each segment.</p>,\n+    defaultValue: 5000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Determines how many rows are in each segment.</>,\n   },\n   {\n-    name: 'taskContext',\n-    type: 'json',\n+    name: 'tuningConfig.partitionsSpec.maxTotalRows',\n+    label: 'Max total rows',\n+    type: 'number',\n+    defaultValue: 20000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Total number of rows in segments waiting for being pushed.</>,\n+  },\n+  // partitionsSpec type: hashed\n+  {\n+    name: 'tuningConfig.partitionsSpec.numShards',\n+    label: 'Num shards',\n+    type: 'number',\n+    required: true, // ToDo: this will no longer be required soon\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'hashed',\n+    info: (\n+      <>\n+        Directly specify the number of shards to create. If this is specified and 'intervals' is\n+        specified in the granularitySpec, the index task can skip the determine intervals/partitions\n+        pass through the data. numShards cannot be specified if maxRowsPerSegment is set.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58cc07f4b1e7e8a68a82d567bcf1a8a03ef58c1c"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2MjYyNA==", "bodyText": "FWIW that was (originally) copy pasted from https://druid.apache.org/docs/latest/ingestion/native-batch.html - should that be updated also?", "url": "https://github.com/apache/druid/pull/10417#discussion_r493162624", "createdAt": "2020-09-23T02:37:19Z", "author": {"login": "vogievetsky"}, "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "diffHunk": "@@ -16,101 +16,242 @@\n  * limitations under the License.\n  */\n \n-import { Button, Classes, Dialog, Intent } from '@blueprintjs/core';\n+import { Button, ButtonGroup, Classes, Code, Dialog, FormGroup, Intent } from '@blueprintjs/core';\n import React, { useState } from 'react';\n \n-import { AutoForm, ExternalLink, Field } from '../../components';\n-import { getLink } from '../../links';\n+import { AutoForm, Field, JsonInput } from '../../components';\n+import { deepGet, deepSet } from '../../utils/object-change';\n \n import './compaction-dialog.scss';\n \n export const DEFAULT_MAX_ROWS_PER_SEGMENT = 5000000;\n \n-const COMPACTION_CONFIG_FIELDS: Field<Record<string, any>>[] = [\n+type Tabs = 'form' | 'json';\n+\n+type CompactionConfig = Record<string, any>;\n+\n+const COMPACTION_CONFIG_FIELDS: Field<CompactionConfig>[] = [\n   {\n-    name: 'inputSegmentSizeBytes',\n-    type: 'number',\n-    defaultValue: 419430400,\n+    name: 'skipOffsetFromLatest',\n+    type: 'string',\n+    defaultValue: 'P1D',\n     info: (\n       <p>\n-        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n-        be processed in its entirety, if the segments for a particular time chunk have a total size\n-        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n-        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n-        result in compaction tasks taking an excessive amount of time.\n+        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n+        dataSources.\n       </p>\n     ),\n   },\n   {\n-    name: 'skipOffsetFromLatest',\n+    name: 'tuningConfig.partitionsSpec.type',\n+    label: 'Partitioning type',\n     type: 'string',\n-    defaultValue: 'P1D',\n+    suggestions: ['dynamic', 'hashed', 'single_dim'],\n     info: (\n       <p>\n-        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n-        dataSources.\n+        For perfect rollup, you should use either <Code>hashed</Code> (partitioning based on the\n+        hash of dimensions in each row) or <Code>single_dim</Code> (based on ranges of a single\n+        dimension. For best-effort rollup, you should use dynamic.\n       </p>\n     ),\n   },\n+  // partitionsSpec type: dynamic\n   {\n-    name: 'maxRowsPerSegment',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: DEFAULT_MAX_ROWS_PER_SEGMENT,\n-    info: <p>Determines how many rows are in each segment.</p>,\n+    defaultValue: 5000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Determines how many rows are in each segment.</>,\n   },\n   {\n-    name: 'taskContext',\n-    type: 'json',\n+    name: 'tuningConfig.partitionsSpec.maxTotalRows',\n+    label: 'Max total rows',\n+    type: 'number',\n+    defaultValue: 20000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Total number of rows in segments waiting for being pushed.</>,\n+  },\n+  // partitionsSpec type: hashed\n+  {\n+    name: 'tuningConfig.partitionsSpec.numShards',\n+    label: 'Num shards',\n+    type: 'number',\n+    required: true, // ToDo: this will no longer be required soon\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'hashed',\n+    info: (\n+      <>\n+        Directly specify the number of shards to create. If this is specified and 'intervals' is\n+        specified in the granularitySpec, the index task can skip the determine intervals/partitions\n+        pass through the data. numShards cannot be specified if maxRowsPerSegment is set.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA1MDUzNQ=="}, "originalCommit": {"oid": "58cc07f4b1e7e8a68a82d567bcf1a8a03ef58c1c"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY4MzA0Nw==", "bodyText": "Yeah, there's some inconsistency in the docs because on that page the numShards description in the tuningConfig section has that sentence, but later in the partitionsSpec section, the sentence is missing.", "url": "https://github.com/apache/druid/pull/10417#discussion_r493683047", "createdAt": "2020-09-23T15:23:45Z", "author": {"login": "ccaominh"}, "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "diffHunk": "@@ -16,101 +16,242 @@\n  * limitations under the License.\n  */\n \n-import { Button, Classes, Dialog, Intent } from '@blueprintjs/core';\n+import { Button, ButtonGroup, Classes, Code, Dialog, FormGroup, Intent } from '@blueprintjs/core';\n import React, { useState } from 'react';\n \n-import { AutoForm, ExternalLink, Field } from '../../components';\n-import { getLink } from '../../links';\n+import { AutoForm, Field, JsonInput } from '../../components';\n+import { deepGet, deepSet } from '../../utils/object-change';\n \n import './compaction-dialog.scss';\n \n export const DEFAULT_MAX_ROWS_PER_SEGMENT = 5000000;\n \n-const COMPACTION_CONFIG_FIELDS: Field<Record<string, any>>[] = [\n+type Tabs = 'form' | 'json';\n+\n+type CompactionConfig = Record<string, any>;\n+\n+const COMPACTION_CONFIG_FIELDS: Field<CompactionConfig>[] = [\n   {\n-    name: 'inputSegmentSizeBytes',\n-    type: 'number',\n-    defaultValue: 419430400,\n+    name: 'skipOffsetFromLatest',\n+    type: 'string',\n+    defaultValue: 'P1D',\n     info: (\n       <p>\n-        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n-        be processed in its entirety, if the segments for a particular time chunk have a total size\n-        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n-        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n-        result in compaction tasks taking an excessive amount of time.\n+        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n+        dataSources.\n       </p>\n     ),\n   },\n   {\n-    name: 'skipOffsetFromLatest',\n+    name: 'tuningConfig.partitionsSpec.type',\n+    label: 'Partitioning type',\n     type: 'string',\n-    defaultValue: 'P1D',\n+    suggestions: ['dynamic', 'hashed', 'single_dim'],\n     info: (\n       <p>\n-        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n-        dataSources.\n+        For perfect rollup, you should use either <Code>hashed</Code> (partitioning based on the\n+        hash of dimensions in each row) or <Code>single_dim</Code> (based on ranges of a single\n+        dimension. For best-effort rollup, you should use dynamic.\n       </p>\n     ),\n   },\n+  // partitionsSpec type: dynamic\n   {\n-    name: 'maxRowsPerSegment',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: DEFAULT_MAX_ROWS_PER_SEGMENT,\n-    info: <p>Determines how many rows are in each segment.</p>,\n+    defaultValue: 5000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Determines how many rows are in each segment.</>,\n   },\n   {\n-    name: 'taskContext',\n-    type: 'json',\n+    name: 'tuningConfig.partitionsSpec.maxTotalRows',\n+    label: 'Max total rows',\n+    type: 'number',\n+    defaultValue: 20000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Total number of rows in segments waiting for being pushed.</>,\n+  },\n+  // partitionsSpec type: hashed\n+  {\n+    name: 'tuningConfig.partitionsSpec.numShards',\n+    label: 'Num shards',\n+    type: 'number',\n+    required: true, // ToDo: this will no longer be required soon\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'hashed',\n+    info: (\n+      <>\n+        Directly specify the number of shards to create. If this is specified and 'intervals' is\n+        specified in the granularitySpec, the index task can skip the determine intervals/partitions\n+        pass through the data. numShards cannot be specified if maxRowsPerSegment is set.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA1MDUzNQ=="}, "originalCommit": {"oid": "58cc07f4b1e7e8a68a82d567bcf1a8a03ef58c1c"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTcwMDIwOnYy", "diffSide": "RIGHT", "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMTo0MzoxOFrOHWNb1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMTo0MzoxOFrOHWNb1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA1MDgzNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    pass through the data. numShards cannot be specified if maxRowsPerSegment is set.\n          \n          \n            \n                    pass through the data.", "url": "https://github.com/apache/druid/pull/10417#discussion_r493050837", "createdAt": "2020-09-22T21:43:18Z", "author": {"login": "ccaominh"}, "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "diffHunk": "@@ -16,101 +16,242 @@\n  * limitations under the License.\n  */\n \n-import { Button, Classes, Dialog, Intent } from '@blueprintjs/core';\n+import { Button, ButtonGroup, Classes, Code, Dialog, FormGroup, Intent } from '@blueprintjs/core';\n import React, { useState } from 'react';\n \n-import { AutoForm, ExternalLink, Field } from '../../components';\n-import { getLink } from '../../links';\n+import { AutoForm, Field, JsonInput } from '../../components';\n+import { deepGet, deepSet } from '../../utils/object-change';\n \n import './compaction-dialog.scss';\n \n export const DEFAULT_MAX_ROWS_PER_SEGMENT = 5000000;\n \n-const COMPACTION_CONFIG_FIELDS: Field<Record<string, any>>[] = [\n+type Tabs = 'form' | 'json';\n+\n+type CompactionConfig = Record<string, any>;\n+\n+const COMPACTION_CONFIG_FIELDS: Field<CompactionConfig>[] = [\n   {\n-    name: 'inputSegmentSizeBytes',\n-    type: 'number',\n-    defaultValue: 419430400,\n+    name: 'skipOffsetFromLatest',\n+    type: 'string',\n+    defaultValue: 'P1D',\n     info: (\n       <p>\n-        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n-        be processed in its entirety, if the segments for a particular time chunk have a total size\n-        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n-        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n-        result in compaction tasks taking an excessive amount of time.\n+        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n+        dataSources.\n       </p>\n     ),\n   },\n   {\n-    name: 'skipOffsetFromLatest',\n+    name: 'tuningConfig.partitionsSpec.type',\n+    label: 'Partitioning type',\n     type: 'string',\n-    defaultValue: 'P1D',\n+    suggestions: ['dynamic', 'hashed', 'single_dim'],\n     info: (\n       <p>\n-        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n-        dataSources.\n+        For perfect rollup, you should use either <Code>hashed</Code> (partitioning based on the\n+        hash of dimensions in each row) or <Code>single_dim</Code> (based on ranges of a single\n+        dimension. For best-effort rollup, you should use dynamic.\n       </p>\n     ),\n   },\n+  // partitionsSpec type: dynamic\n   {\n-    name: 'maxRowsPerSegment',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: DEFAULT_MAX_ROWS_PER_SEGMENT,\n-    info: <p>Determines how many rows are in each segment.</p>,\n+    defaultValue: 5000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Determines how many rows are in each segment.</>,\n   },\n   {\n-    name: 'taskContext',\n-    type: 'json',\n+    name: 'tuningConfig.partitionsSpec.maxTotalRows',\n+    label: 'Max total rows',\n+    type: 'number',\n+    defaultValue: 20000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Total number of rows in segments waiting for being pushed.</>,\n+  },\n+  // partitionsSpec type: hashed\n+  {\n+    name: 'tuningConfig.partitionsSpec.numShards',\n+    label: 'Num shards',\n+    type: 'number',\n+    required: true, // ToDo: this will no longer be required soon\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'hashed',\n+    info: (\n+      <>\n+        Directly specify the number of shards to create. If this is specified and 'intervals' is\n+        specified in the granularitySpec, the index task can skip the determine intervals/partitions\n+        pass through the data. numShards cannot be specified if maxRowsPerSegment is set.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58cc07f4b1e7e8a68a82d567bcf1a8a03ef58c1c"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTc1MTUyOnYy", "diffSide": "RIGHT", "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.spec.tsx", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMjowMToyNVrOHWN6gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QwMjozNzozNlrOHWUQuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA1ODY4OQ==", "bodyText": "What do you think about having 3 variants of this test: dynamic, hashed, and single_dim partitions. For example, the snapshot would verify that the \"Max num merge tasks\" field should only show up for hashed and single_dim. Also, for single_dim we could have a test to verify that the spec is valid (see the comment I left on validCompactionConfig()).", "url": "https://github.com/apache/druid/pull/10417#discussion_r493058689", "createdAt": "2020-09-22T22:01:25Z", "author": {"login": "ccaominh"}, "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.spec.tsx", "diffHunk": "@@ -21,15 +21,28 @@ import React from 'react';\n \n import { CompactionDialog } from './compaction-dialog';\n \n-describe('compaction dialog', () => {\n-  it('matches snapshot', () => {\n+describe('CompactionDialog', () => {\n+  it('matches snapshot without compactionConfig', () => {\n     const compactionDialog = shallow(\n       <CompactionDialog\n         onClose={() => {}}\n         onSave={() => {}}\n         onDelete={() => {}}\n-        datasource={'test'}\n-        compactionConfig={{}}\n+        datasource={'test1'}\n+        compactionConfig={undefined}\n+      />,\n+    );\n+    expect(compactionDialog).toMatchSnapshot();\n+  });\n+\n+  it('matches snapshot with compactionConfig', () => {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58cc07f4b1e7e8a68a82d567bcf1a8a03ef58c1c"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2MjY4MA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/apache/druid/pull/10417#discussion_r493162680", "createdAt": "2020-09-23T02:37:36Z", "author": {"login": "vogievetsky"}, "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.spec.tsx", "diffHunk": "@@ -21,15 +21,28 @@ import React from 'react';\n \n import { CompactionDialog } from './compaction-dialog';\n \n-describe('compaction dialog', () => {\n-  it('matches snapshot', () => {\n+describe('CompactionDialog', () => {\n+  it('matches snapshot without compactionConfig', () => {\n     const compactionDialog = shallow(\n       <CompactionDialog\n         onClose={() => {}}\n         onSave={() => {}}\n         onDelete={() => {}}\n-        datasource={'test'}\n-        compactionConfig={{}}\n+        datasource={'test1'}\n+        compactionConfig={undefined}\n+      />,\n+    );\n+    expect(compactionDialog).toMatchSnapshot();\n+  });\n+\n+  it('matches snapshot with compactionConfig', () => {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA1ODY4OQ=="}, "originalCommit": {"oid": "58cc07f4b1e7e8a68a82d567bcf1a8a03ef58c1c"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTgwNDA3OnYy", "diffSide": "RIGHT", "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMjoyMjozNFrOHWOZ4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNToyNDoxMFrOHW0CfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NjcyMA==", "bodyText": "I noticed when I tried single_dim with partitionDimension, targetRowsPerSegment and maxRowsPerSegment all set, that the Submit button was not disabled even though it's an invalid partitionsSpec (and results in an error response from the server). The logic here should be changed to return false if exactly one of targetRowsPerSegment or maxRowsPerSegment is not set.", "url": "https://github.com/apache/druid/pull/10417#discussion_r493066720", "createdAt": "2020-09-22T22:22:34Z", "author": {"login": "ccaominh"}, "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "diffHunk": "@@ -16,101 +16,242 @@\n  * limitations under the License.\n  */\n \n-import { Button, Classes, Dialog, Intent } from '@blueprintjs/core';\n+import { Button, ButtonGroup, Classes, Code, Dialog, FormGroup, Intent } from '@blueprintjs/core';\n import React, { useState } from 'react';\n \n-import { AutoForm, ExternalLink, Field } from '../../components';\n-import { getLink } from '../../links';\n+import { AutoForm, Field, JsonInput } from '../../components';\n+import { deepGet, deepSet } from '../../utils/object-change';\n \n import './compaction-dialog.scss';\n \n export const DEFAULT_MAX_ROWS_PER_SEGMENT = 5000000;\n \n-const COMPACTION_CONFIG_FIELDS: Field<Record<string, any>>[] = [\n+type Tabs = 'form' | 'json';\n+\n+type CompactionConfig = Record<string, any>;\n+\n+const COMPACTION_CONFIG_FIELDS: Field<CompactionConfig>[] = [\n   {\n-    name: 'inputSegmentSizeBytes',\n-    type: 'number',\n-    defaultValue: 419430400,\n+    name: 'skipOffsetFromLatest',\n+    type: 'string',\n+    defaultValue: 'P1D',\n     info: (\n       <p>\n-        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n-        be processed in its entirety, if the segments for a particular time chunk have a total size\n-        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n-        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n-        result in compaction tasks taking an excessive amount of time.\n+        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n+        dataSources.\n       </p>\n     ),\n   },\n   {\n-    name: 'skipOffsetFromLatest',\n+    name: 'tuningConfig.partitionsSpec.type',\n+    label: 'Partitioning type',\n     type: 'string',\n-    defaultValue: 'P1D',\n+    suggestions: ['dynamic', 'hashed', 'single_dim'],\n     info: (\n       <p>\n-        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n-        dataSources.\n+        For perfect rollup, you should use either <Code>hashed</Code> (partitioning based on the\n+        hash of dimensions in each row) or <Code>single_dim</Code> (based on ranges of a single\n+        dimension. For best-effort rollup, you should use dynamic.\n       </p>\n     ),\n   },\n+  // partitionsSpec type: dynamic\n   {\n-    name: 'maxRowsPerSegment',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: DEFAULT_MAX_ROWS_PER_SEGMENT,\n-    info: <p>Determines how many rows are in each segment.</p>,\n+    defaultValue: 5000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Determines how many rows are in each segment.</>,\n   },\n   {\n-    name: 'taskContext',\n-    type: 'json',\n+    name: 'tuningConfig.partitionsSpec.maxTotalRows',\n+    label: 'Max total rows',\n+    type: 'number',\n+    defaultValue: 20000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Total number of rows in segments waiting for being pushed.</>,\n+  },\n+  // partitionsSpec type: hashed\n+  {\n+    name: 'tuningConfig.partitionsSpec.numShards',\n+    label: 'Num shards',\n+    type: 'number',\n+    required: true, // ToDo: this will no longer be required soon\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'hashed',\n+    info: (\n+      <>\n+        Directly specify the number of shards to create. If this is specified and 'intervals' is\n+        specified in the granularitySpec, the index task can skip the determine intervals/partitions\n+        pass through the data. numShards cannot be specified if maxRowsPerSegment is set.\n+      </>\n+    ),\n+  },\n+  {\n+    name: 'tuningConfig.partitionsSpec.partitionDimensions',\n+    label: 'Partition dimensions',\n+    type: 'string-array',\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'hashed',\n+    info: <p>The dimensions to partition on. Leave blank to select all dimensions.</p>,\n+  },\n+  // partitionsSpec type: single_dim\n+  {\n+    name: 'tuningConfig.partitionsSpec.partitionDimension',\n+    label: 'Partition dimension',\n+    type: 'string',\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: true,\n+    info: <p>The dimension to partition on.</p>,\n+  },\n+  {\n+    name: 'tuningConfig.partitionsSpec.targetRowsPerSegment',\n+    label: 'Target rows per segment',\n+    type: 'number',\n+    zeroMeansUndefined: true,\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: (t: CompactionConfig) =>\n+      !deepGet(t, 'tuningConfig.partitionsSpec.targetRowsPerSegment') &&\n+      !deepGet(t, 'tuningConfig.partitionsSpec.maxRowsPerSegment'),\n     info: (\n       <p>\n-        <ExternalLink href={`${getLink('DOCS')}/ingestion/tasks.html#task-context`}>\n-          Task context\n-        </ExternalLink>{' '}\n-        for compaction tasks.\n+        Target number of rows to include in a partition, should be a number that targets segments of\n+        500MB~1GB.\n       </p>\n     ),\n   },\n   {\n-    name: 'taskPriority',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: 25,\n-    info: <p>Priority of the compaction task.</p>,\n+    zeroMeansUndefined: true,\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: (t: CompactionConfig) =>\n+      !deepGet(t, 'tuningConfig.partitionsSpec.targetRowsPerSegment') &&\n+      !deepGet(t, 'tuningConfig.partitionsSpec.maxRowsPerSegment'),\n+    info: <p>Maximum number of rows to include in a partition.</p>,\n   },\n   {\n-    name: 'tuningConfig',\n-    type: 'json',\n+    name: 'tuningConfig.partitionsSpec.assumeGrouped',\n+    label: 'Assume grouped',\n+    type: 'boolean',\n+    defaultValue: false,\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n     info: (\n       <p>\n-        <ExternalLink\n-          href={`${getLink('DOCS')}/configuration/index.html#compact-task-tuningconfig`}\n-        >\n-          Tuning config\n-        </ExternalLink>{' '}\n-        for compaction tasks.\n+        Assume that input data has already been grouped on time and dimensions. Ingestion will run\n+        faster, but may choose sub-optimal partitions if this assumption is violated.\n       </p>\n     ),\n   },\n+  {\n+    name: 'tuningConfig.maxNumConcurrentSubTasks',\n+    label: 'Max num concurrent sub tasks',\n+    type: 'number',\n+    defaultValue: 1,\n+    min: 1,\n+    info: (\n+      <>\n+        Maximum number of tasks which can be run at the same time. The supervisor task would spawn\n+        worker tasks up to maxNumConcurrentSubTasks regardless of the available task slots. If this\n+        value is set to 1, the supervisor task processes data ingestion on its own instead of\n+        spawning worker tasks. If this value is set to too large, too many worker tasks can be\n+        created which might block other ingestion.\n+      </>\n+    ),\n+  },\n+  {\n+    name: 'inputSegmentSizeBytes',\n+    type: 'number',\n+    defaultValue: 419430400,\n+    info: (\n+      <p>\n+        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n+        be processed in its entirety, if the segments for a particular time chunk have a total size\n+        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n+        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n+        result in compaction tasks taking an excessive amount of time.\n+      </p>\n+    ),\n+  },\n+  {\n+    name: 'tuningConfig.maxNumMergeTasks',\n+    label: 'Max num merge tasks',\n+    type: 'number',\n+    defaultValue: 1,\n+    min: 1,\n+    defined: (t: CompactionConfig) =>\n+      ['hashed', 'single_dim'].includes(deepGet(t, 'tuningConfig.partitionsSpec.type')),\n+    info: <>Maximum number of merge tasks which can be run at the same time.</>,\n+  },\n+  {\n+    name: 'tuningConfig.splitHintSpec.maxInputSegmentBytesPerTask',\n+    label: 'Max input segment bytes per task',\n+    type: 'number',\n+    defaultValue: 500000000,\n+    min: 1000000,\n+    adjustment: (t: CompactionConfig) => deepSet(t, 'tuningConfig.splitHintSpec.type', 'segments'),\n+    info: (\n+      <>\n+        Maximum number of bytes of input segments to process in a single task. If a single segment\n+        is larger than this number, it will be processed by itself in a single task (input segments\n+        are never split across tasks).\n+      </>\n+    ),\n+  },\n ];\n \n+function validCompactionConfig(compactionConfig: CompactionConfig): boolean {\n+  const partitionsSpecType =\n+    deepGet(compactionConfig, 'tuningConfig.partitionsSpec.type') || 'dynamic';\n+  switch (partitionsSpecType) {\n+    // case 'dynamic': // Nothing to check for dynamic\n+    case 'hashed':\n+      if (!deepGet(compactionConfig, 'tuningConfig.partitionsSpec.numShards')) {\n+        return false;\n+      }\n+      break;\n+\n+    case 'single_dim':\n+      if (!deepGet(compactionConfig, 'tuningConfig.partitionsSpec.partitionDimension')) {\n+        return false;\n+      }\n+      if (\n+        !deepGet(compactionConfig, 'tuningConfig.partitionsSpec.targetRowsPerSegment') &&\n+        !deepGet(compactionConfig, 'tuningConfig.partitionsSpec.maxRowsPerSegment')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58cc07f4b1e7e8a68a82d567bcf1a8a03ef58c1c"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE1MjA5NQ==", "bodyText": "gotcha... I did not understand that at first. Thank you for clarifying", "url": "https://github.com/apache/druid/pull/10417#discussion_r493152095", "createdAt": "2020-09-23T02:11:44Z", "author": {"login": "vogievetsky"}, "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "diffHunk": "@@ -16,101 +16,242 @@\n  * limitations under the License.\n  */\n \n-import { Button, Classes, Dialog, Intent } from '@blueprintjs/core';\n+import { Button, ButtonGroup, Classes, Code, Dialog, FormGroup, Intent } from '@blueprintjs/core';\n import React, { useState } from 'react';\n \n-import { AutoForm, ExternalLink, Field } from '../../components';\n-import { getLink } from '../../links';\n+import { AutoForm, Field, JsonInput } from '../../components';\n+import { deepGet, deepSet } from '../../utils/object-change';\n \n import './compaction-dialog.scss';\n \n export const DEFAULT_MAX_ROWS_PER_SEGMENT = 5000000;\n \n-const COMPACTION_CONFIG_FIELDS: Field<Record<string, any>>[] = [\n+type Tabs = 'form' | 'json';\n+\n+type CompactionConfig = Record<string, any>;\n+\n+const COMPACTION_CONFIG_FIELDS: Field<CompactionConfig>[] = [\n   {\n-    name: 'inputSegmentSizeBytes',\n-    type: 'number',\n-    defaultValue: 419430400,\n+    name: 'skipOffsetFromLatest',\n+    type: 'string',\n+    defaultValue: 'P1D',\n     info: (\n       <p>\n-        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n-        be processed in its entirety, if the segments for a particular time chunk have a total size\n-        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n-        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n-        result in compaction tasks taking an excessive amount of time.\n+        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n+        dataSources.\n       </p>\n     ),\n   },\n   {\n-    name: 'skipOffsetFromLatest',\n+    name: 'tuningConfig.partitionsSpec.type',\n+    label: 'Partitioning type',\n     type: 'string',\n-    defaultValue: 'P1D',\n+    suggestions: ['dynamic', 'hashed', 'single_dim'],\n     info: (\n       <p>\n-        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n-        dataSources.\n+        For perfect rollup, you should use either <Code>hashed</Code> (partitioning based on the\n+        hash of dimensions in each row) or <Code>single_dim</Code> (based on ranges of a single\n+        dimension. For best-effort rollup, you should use dynamic.\n       </p>\n     ),\n   },\n+  // partitionsSpec type: dynamic\n   {\n-    name: 'maxRowsPerSegment',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: DEFAULT_MAX_ROWS_PER_SEGMENT,\n-    info: <p>Determines how many rows are in each segment.</p>,\n+    defaultValue: 5000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Determines how many rows are in each segment.</>,\n   },\n   {\n-    name: 'taskContext',\n-    type: 'json',\n+    name: 'tuningConfig.partitionsSpec.maxTotalRows',\n+    label: 'Max total rows',\n+    type: 'number',\n+    defaultValue: 20000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Total number of rows in segments waiting for being pushed.</>,\n+  },\n+  // partitionsSpec type: hashed\n+  {\n+    name: 'tuningConfig.partitionsSpec.numShards',\n+    label: 'Num shards',\n+    type: 'number',\n+    required: true, // ToDo: this will no longer be required soon\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'hashed',\n+    info: (\n+      <>\n+        Directly specify the number of shards to create. If this is specified and 'intervals' is\n+        specified in the granularitySpec, the index task can skip the determine intervals/partitions\n+        pass through the data. numShards cannot be specified if maxRowsPerSegment is set.\n+      </>\n+    ),\n+  },\n+  {\n+    name: 'tuningConfig.partitionsSpec.partitionDimensions',\n+    label: 'Partition dimensions',\n+    type: 'string-array',\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'hashed',\n+    info: <p>The dimensions to partition on. Leave blank to select all dimensions.</p>,\n+  },\n+  // partitionsSpec type: single_dim\n+  {\n+    name: 'tuningConfig.partitionsSpec.partitionDimension',\n+    label: 'Partition dimension',\n+    type: 'string',\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: true,\n+    info: <p>The dimension to partition on.</p>,\n+  },\n+  {\n+    name: 'tuningConfig.partitionsSpec.targetRowsPerSegment',\n+    label: 'Target rows per segment',\n+    type: 'number',\n+    zeroMeansUndefined: true,\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: (t: CompactionConfig) =>\n+      !deepGet(t, 'tuningConfig.partitionsSpec.targetRowsPerSegment') &&\n+      !deepGet(t, 'tuningConfig.partitionsSpec.maxRowsPerSegment'),\n     info: (\n       <p>\n-        <ExternalLink href={`${getLink('DOCS')}/ingestion/tasks.html#task-context`}>\n-          Task context\n-        </ExternalLink>{' '}\n-        for compaction tasks.\n+        Target number of rows to include in a partition, should be a number that targets segments of\n+        500MB~1GB.\n       </p>\n     ),\n   },\n   {\n-    name: 'taskPriority',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: 25,\n-    info: <p>Priority of the compaction task.</p>,\n+    zeroMeansUndefined: true,\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: (t: CompactionConfig) =>\n+      !deepGet(t, 'tuningConfig.partitionsSpec.targetRowsPerSegment') &&\n+      !deepGet(t, 'tuningConfig.partitionsSpec.maxRowsPerSegment'),\n+    info: <p>Maximum number of rows to include in a partition.</p>,\n   },\n   {\n-    name: 'tuningConfig',\n-    type: 'json',\n+    name: 'tuningConfig.partitionsSpec.assumeGrouped',\n+    label: 'Assume grouped',\n+    type: 'boolean',\n+    defaultValue: false,\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n     info: (\n       <p>\n-        <ExternalLink\n-          href={`${getLink('DOCS')}/configuration/index.html#compact-task-tuningconfig`}\n-        >\n-          Tuning config\n-        </ExternalLink>{' '}\n-        for compaction tasks.\n+        Assume that input data has already been grouped on time and dimensions. Ingestion will run\n+        faster, but may choose sub-optimal partitions if this assumption is violated.\n       </p>\n     ),\n   },\n+  {\n+    name: 'tuningConfig.maxNumConcurrentSubTasks',\n+    label: 'Max num concurrent sub tasks',\n+    type: 'number',\n+    defaultValue: 1,\n+    min: 1,\n+    info: (\n+      <>\n+        Maximum number of tasks which can be run at the same time. The supervisor task would spawn\n+        worker tasks up to maxNumConcurrentSubTasks regardless of the available task slots. If this\n+        value is set to 1, the supervisor task processes data ingestion on its own instead of\n+        spawning worker tasks. If this value is set to too large, too many worker tasks can be\n+        created which might block other ingestion.\n+      </>\n+    ),\n+  },\n+  {\n+    name: 'inputSegmentSizeBytes',\n+    type: 'number',\n+    defaultValue: 419430400,\n+    info: (\n+      <p>\n+        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n+        be processed in its entirety, if the segments for a particular time chunk have a total size\n+        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n+        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n+        result in compaction tasks taking an excessive amount of time.\n+      </p>\n+    ),\n+  },\n+  {\n+    name: 'tuningConfig.maxNumMergeTasks',\n+    label: 'Max num merge tasks',\n+    type: 'number',\n+    defaultValue: 1,\n+    min: 1,\n+    defined: (t: CompactionConfig) =>\n+      ['hashed', 'single_dim'].includes(deepGet(t, 'tuningConfig.partitionsSpec.type')),\n+    info: <>Maximum number of merge tasks which can be run at the same time.</>,\n+  },\n+  {\n+    name: 'tuningConfig.splitHintSpec.maxInputSegmentBytesPerTask',\n+    label: 'Max input segment bytes per task',\n+    type: 'number',\n+    defaultValue: 500000000,\n+    min: 1000000,\n+    adjustment: (t: CompactionConfig) => deepSet(t, 'tuningConfig.splitHintSpec.type', 'segments'),\n+    info: (\n+      <>\n+        Maximum number of bytes of input segments to process in a single task. If a single segment\n+        is larger than this number, it will be processed by itself in a single task (input segments\n+        are never split across tasks).\n+      </>\n+    ),\n+  },\n ];\n \n+function validCompactionConfig(compactionConfig: CompactionConfig): boolean {\n+  const partitionsSpecType =\n+    deepGet(compactionConfig, 'tuningConfig.partitionsSpec.type') || 'dynamic';\n+  switch (partitionsSpecType) {\n+    // case 'dynamic': // Nothing to check for dynamic\n+    case 'hashed':\n+      if (!deepGet(compactionConfig, 'tuningConfig.partitionsSpec.numShards')) {\n+        return false;\n+      }\n+      break;\n+\n+    case 'single_dim':\n+      if (!deepGet(compactionConfig, 'tuningConfig.partitionsSpec.partitionDimension')) {\n+        return false;\n+      }\n+      if (\n+        !deepGet(compactionConfig, 'tuningConfig.partitionsSpec.targetRowsPerSegment') &&\n+        !deepGet(compactionConfig, 'tuningConfig.partitionsSpec.maxRowsPerSegment')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NjcyMA=="}, "originalCommit": {"oid": "58cc07f4b1e7e8a68a82d567bcf1a8a03ef58c1c"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzE2NDQ1OA==", "bodyText": "The UI should be adjusted to disappear the other box if one is set. I assume the same applies for the partition spec form un the data loader", "url": "https://github.com/apache/druid/pull/10417#discussion_r493164458", "createdAt": "2020-09-23T02:44:44Z", "author": {"login": "vogievetsky"}, "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "diffHunk": "@@ -16,101 +16,242 @@\n  * limitations under the License.\n  */\n \n-import { Button, Classes, Dialog, Intent } from '@blueprintjs/core';\n+import { Button, ButtonGroup, Classes, Code, Dialog, FormGroup, Intent } from '@blueprintjs/core';\n import React, { useState } from 'react';\n \n-import { AutoForm, ExternalLink, Field } from '../../components';\n-import { getLink } from '../../links';\n+import { AutoForm, Field, JsonInput } from '../../components';\n+import { deepGet, deepSet } from '../../utils/object-change';\n \n import './compaction-dialog.scss';\n \n export const DEFAULT_MAX_ROWS_PER_SEGMENT = 5000000;\n \n-const COMPACTION_CONFIG_FIELDS: Field<Record<string, any>>[] = [\n+type Tabs = 'form' | 'json';\n+\n+type CompactionConfig = Record<string, any>;\n+\n+const COMPACTION_CONFIG_FIELDS: Field<CompactionConfig>[] = [\n   {\n-    name: 'inputSegmentSizeBytes',\n-    type: 'number',\n-    defaultValue: 419430400,\n+    name: 'skipOffsetFromLatest',\n+    type: 'string',\n+    defaultValue: 'P1D',\n     info: (\n       <p>\n-        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n-        be processed in its entirety, if the segments for a particular time chunk have a total size\n-        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n-        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n-        result in compaction tasks taking an excessive amount of time.\n+        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n+        dataSources.\n       </p>\n     ),\n   },\n   {\n-    name: 'skipOffsetFromLatest',\n+    name: 'tuningConfig.partitionsSpec.type',\n+    label: 'Partitioning type',\n     type: 'string',\n-    defaultValue: 'P1D',\n+    suggestions: ['dynamic', 'hashed', 'single_dim'],\n     info: (\n       <p>\n-        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n-        dataSources.\n+        For perfect rollup, you should use either <Code>hashed</Code> (partitioning based on the\n+        hash of dimensions in each row) or <Code>single_dim</Code> (based on ranges of a single\n+        dimension. For best-effort rollup, you should use dynamic.\n       </p>\n     ),\n   },\n+  // partitionsSpec type: dynamic\n   {\n-    name: 'maxRowsPerSegment',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: DEFAULT_MAX_ROWS_PER_SEGMENT,\n-    info: <p>Determines how many rows are in each segment.</p>,\n+    defaultValue: 5000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Determines how many rows are in each segment.</>,\n   },\n   {\n-    name: 'taskContext',\n-    type: 'json',\n+    name: 'tuningConfig.partitionsSpec.maxTotalRows',\n+    label: 'Max total rows',\n+    type: 'number',\n+    defaultValue: 20000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Total number of rows in segments waiting for being pushed.</>,\n+  },\n+  // partitionsSpec type: hashed\n+  {\n+    name: 'tuningConfig.partitionsSpec.numShards',\n+    label: 'Num shards',\n+    type: 'number',\n+    required: true, // ToDo: this will no longer be required soon\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'hashed',\n+    info: (\n+      <>\n+        Directly specify the number of shards to create. If this is specified and 'intervals' is\n+        specified in the granularitySpec, the index task can skip the determine intervals/partitions\n+        pass through the data. numShards cannot be specified if maxRowsPerSegment is set.\n+      </>\n+    ),\n+  },\n+  {\n+    name: 'tuningConfig.partitionsSpec.partitionDimensions',\n+    label: 'Partition dimensions',\n+    type: 'string-array',\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'hashed',\n+    info: <p>The dimensions to partition on. Leave blank to select all dimensions.</p>,\n+  },\n+  // partitionsSpec type: single_dim\n+  {\n+    name: 'tuningConfig.partitionsSpec.partitionDimension',\n+    label: 'Partition dimension',\n+    type: 'string',\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: true,\n+    info: <p>The dimension to partition on.</p>,\n+  },\n+  {\n+    name: 'tuningConfig.partitionsSpec.targetRowsPerSegment',\n+    label: 'Target rows per segment',\n+    type: 'number',\n+    zeroMeansUndefined: true,\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: (t: CompactionConfig) =>\n+      !deepGet(t, 'tuningConfig.partitionsSpec.targetRowsPerSegment') &&\n+      !deepGet(t, 'tuningConfig.partitionsSpec.maxRowsPerSegment'),\n     info: (\n       <p>\n-        <ExternalLink href={`${getLink('DOCS')}/ingestion/tasks.html#task-context`}>\n-          Task context\n-        </ExternalLink>{' '}\n-        for compaction tasks.\n+        Target number of rows to include in a partition, should be a number that targets segments of\n+        500MB~1GB.\n       </p>\n     ),\n   },\n   {\n-    name: 'taskPriority',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: 25,\n-    info: <p>Priority of the compaction task.</p>,\n+    zeroMeansUndefined: true,\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: (t: CompactionConfig) =>\n+      !deepGet(t, 'tuningConfig.partitionsSpec.targetRowsPerSegment') &&\n+      !deepGet(t, 'tuningConfig.partitionsSpec.maxRowsPerSegment'),\n+    info: <p>Maximum number of rows to include in a partition.</p>,\n   },\n   {\n-    name: 'tuningConfig',\n-    type: 'json',\n+    name: 'tuningConfig.partitionsSpec.assumeGrouped',\n+    label: 'Assume grouped',\n+    type: 'boolean',\n+    defaultValue: false,\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n     info: (\n       <p>\n-        <ExternalLink\n-          href={`${getLink('DOCS')}/configuration/index.html#compact-task-tuningconfig`}\n-        >\n-          Tuning config\n-        </ExternalLink>{' '}\n-        for compaction tasks.\n+        Assume that input data has already been grouped on time and dimensions. Ingestion will run\n+        faster, but may choose sub-optimal partitions if this assumption is violated.\n       </p>\n     ),\n   },\n+  {\n+    name: 'tuningConfig.maxNumConcurrentSubTasks',\n+    label: 'Max num concurrent sub tasks',\n+    type: 'number',\n+    defaultValue: 1,\n+    min: 1,\n+    info: (\n+      <>\n+        Maximum number of tasks which can be run at the same time. The supervisor task would spawn\n+        worker tasks up to maxNumConcurrentSubTasks regardless of the available task slots. If this\n+        value is set to 1, the supervisor task processes data ingestion on its own instead of\n+        spawning worker tasks. If this value is set to too large, too many worker tasks can be\n+        created which might block other ingestion.\n+      </>\n+    ),\n+  },\n+  {\n+    name: 'inputSegmentSizeBytes',\n+    type: 'number',\n+    defaultValue: 419430400,\n+    info: (\n+      <p>\n+        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n+        be processed in its entirety, if the segments for a particular time chunk have a total size\n+        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n+        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n+        result in compaction tasks taking an excessive amount of time.\n+      </p>\n+    ),\n+  },\n+  {\n+    name: 'tuningConfig.maxNumMergeTasks',\n+    label: 'Max num merge tasks',\n+    type: 'number',\n+    defaultValue: 1,\n+    min: 1,\n+    defined: (t: CompactionConfig) =>\n+      ['hashed', 'single_dim'].includes(deepGet(t, 'tuningConfig.partitionsSpec.type')),\n+    info: <>Maximum number of merge tasks which can be run at the same time.</>,\n+  },\n+  {\n+    name: 'tuningConfig.splitHintSpec.maxInputSegmentBytesPerTask',\n+    label: 'Max input segment bytes per task',\n+    type: 'number',\n+    defaultValue: 500000000,\n+    min: 1000000,\n+    adjustment: (t: CompactionConfig) => deepSet(t, 'tuningConfig.splitHintSpec.type', 'segments'),\n+    info: (\n+      <>\n+        Maximum number of bytes of input segments to process in a single task. If a single segment\n+        is larger than this number, it will be processed by itself in a single task (input segments\n+        are never split across tasks).\n+      </>\n+    ),\n+  },\n ];\n \n+function validCompactionConfig(compactionConfig: CompactionConfig): boolean {\n+  const partitionsSpecType =\n+    deepGet(compactionConfig, 'tuningConfig.partitionsSpec.type') || 'dynamic';\n+  switch (partitionsSpecType) {\n+    // case 'dynamic': // Nothing to check for dynamic\n+    case 'hashed':\n+      if (!deepGet(compactionConfig, 'tuningConfig.partitionsSpec.numShards')) {\n+        return false;\n+      }\n+      break;\n+\n+    case 'single_dim':\n+      if (!deepGet(compactionConfig, 'tuningConfig.partitionsSpec.partitionDimension')) {\n+        return false;\n+      }\n+      if (\n+        !deepGet(compactionConfig, 'tuningConfig.partitionsSpec.targetRowsPerSegment') &&\n+        !deepGet(compactionConfig, 'tuningConfig.partitionsSpec.maxRowsPerSegment')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NjcyMA=="}, "originalCommit": {"oid": "58cc07f4b1e7e8a68a82d567bcf1a8a03ef58c1c"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY4MzMyNQ==", "bodyText": "Yeah, the same applies to the data loader.", "url": "https://github.com/apache/druid/pull/10417#discussion_r493683325", "createdAt": "2020-09-23T15:24:10Z", "author": {"login": "ccaominh"}, "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "diffHunk": "@@ -16,101 +16,242 @@\n  * limitations under the License.\n  */\n \n-import { Button, Classes, Dialog, Intent } from '@blueprintjs/core';\n+import { Button, ButtonGroup, Classes, Code, Dialog, FormGroup, Intent } from '@blueprintjs/core';\n import React, { useState } from 'react';\n \n-import { AutoForm, ExternalLink, Field } from '../../components';\n-import { getLink } from '../../links';\n+import { AutoForm, Field, JsonInput } from '../../components';\n+import { deepGet, deepSet } from '../../utils/object-change';\n \n import './compaction-dialog.scss';\n \n export const DEFAULT_MAX_ROWS_PER_SEGMENT = 5000000;\n \n-const COMPACTION_CONFIG_FIELDS: Field<Record<string, any>>[] = [\n+type Tabs = 'form' | 'json';\n+\n+type CompactionConfig = Record<string, any>;\n+\n+const COMPACTION_CONFIG_FIELDS: Field<CompactionConfig>[] = [\n   {\n-    name: 'inputSegmentSizeBytes',\n-    type: 'number',\n-    defaultValue: 419430400,\n+    name: 'skipOffsetFromLatest',\n+    type: 'string',\n+    defaultValue: 'P1D',\n     info: (\n       <p>\n-        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n-        be processed in its entirety, if the segments for a particular time chunk have a total size\n-        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n-        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n-        result in compaction tasks taking an excessive amount of time.\n+        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n+        dataSources.\n       </p>\n     ),\n   },\n   {\n-    name: 'skipOffsetFromLatest',\n+    name: 'tuningConfig.partitionsSpec.type',\n+    label: 'Partitioning type',\n     type: 'string',\n-    defaultValue: 'P1D',\n+    suggestions: ['dynamic', 'hashed', 'single_dim'],\n     info: (\n       <p>\n-        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n-        dataSources.\n+        For perfect rollup, you should use either <Code>hashed</Code> (partitioning based on the\n+        hash of dimensions in each row) or <Code>single_dim</Code> (based on ranges of a single\n+        dimension. For best-effort rollup, you should use dynamic.\n       </p>\n     ),\n   },\n+  // partitionsSpec type: dynamic\n   {\n-    name: 'maxRowsPerSegment',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: DEFAULT_MAX_ROWS_PER_SEGMENT,\n-    info: <p>Determines how many rows are in each segment.</p>,\n+    defaultValue: 5000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Determines how many rows are in each segment.</>,\n   },\n   {\n-    name: 'taskContext',\n-    type: 'json',\n+    name: 'tuningConfig.partitionsSpec.maxTotalRows',\n+    label: 'Max total rows',\n+    type: 'number',\n+    defaultValue: 20000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Total number of rows in segments waiting for being pushed.</>,\n+  },\n+  // partitionsSpec type: hashed\n+  {\n+    name: 'tuningConfig.partitionsSpec.numShards',\n+    label: 'Num shards',\n+    type: 'number',\n+    required: true, // ToDo: this will no longer be required soon\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'hashed',\n+    info: (\n+      <>\n+        Directly specify the number of shards to create. If this is specified and 'intervals' is\n+        specified in the granularitySpec, the index task can skip the determine intervals/partitions\n+        pass through the data. numShards cannot be specified if maxRowsPerSegment is set.\n+      </>\n+    ),\n+  },\n+  {\n+    name: 'tuningConfig.partitionsSpec.partitionDimensions',\n+    label: 'Partition dimensions',\n+    type: 'string-array',\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'hashed',\n+    info: <p>The dimensions to partition on. Leave blank to select all dimensions.</p>,\n+  },\n+  // partitionsSpec type: single_dim\n+  {\n+    name: 'tuningConfig.partitionsSpec.partitionDimension',\n+    label: 'Partition dimension',\n+    type: 'string',\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: true,\n+    info: <p>The dimension to partition on.</p>,\n+  },\n+  {\n+    name: 'tuningConfig.partitionsSpec.targetRowsPerSegment',\n+    label: 'Target rows per segment',\n+    type: 'number',\n+    zeroMeansUndefined: true,\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: (t: CompactionConfig) =>\n+      !deepGet(t, 'tuningConfig.partitionsSpec.targetRowsPerSegment') &&\n+      !deepGet(t, 'tuningConfig.partitionsSpec.maxRowsPerSegment'),\n     info: (\n       <p>\n-        <ExternalLink href={`${getLink('DOCS')}/ingestion/tasks.html#task-context`}>\n-          Task context\n-        </ExternalLink>{' '}\n-        for compaction tasks.\n+        Target number of rows to include in a partition, should be a number that targets segments of\n+        500MB~1GB.\n       </p>\n     ),\n   },\n   {\n-    name: 'taskPriority',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: 25,\n-    info: <p>Priority of the compaction task.</p>,\n+    zeroMeansUndefined: true,\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: (t: CompactionConfig) =>\n+      !deepGet(t, 'tuningConfig.partitionsSpec.targetRowsPerSegment') &&\n+      !deepGet(t, 'tuningConfig.partitionsSpec.maxRowsPerSegment'),\n+    info: <p>Maximum number of rows to include in a partition.</p>,\n   },\n   {\n-    name: 'tuningConfig',\n-    type: 'json',\n+    name: 'tuningConfig.partitionsSpec.assumeGrouped',\n+    label: 'Assume grouped',\n+    type: 'boolean',\n+    defaultValue: false,\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n     info: (\n       <p>\n-        <ExternalLink\n-          href={`${getLink('DOCS')}/configuration/index.html#compact-task-tuningconfig`}\n-        >\n-          Tuning config\n-        </ExternalLink>{' '}\n-        for compaction tasks.\n+        Assume that input data has already been grouped on time and dimensions. Ingestion will run\n+        faster, but may choose sub-optimal partitions if this assumption is violated.\n       </p>\n     ),\n   },\n+  {\n+    name: 'tuningConfig.maxNumConcurrentSubTasks',\n+    label: 'Max num concurrent sub tasks',\n+    type: 'number',\n+    defaultValue: 1,\n+    min: 1,\n+    info: (\n+      <>\n+        Maximum number of tasks which can be run at the same time. The supervisor task would spawn\n+        worker tasks up to maxNumConcurrentSubTasks regardless of the available task slots. If this\n+        value is set to 1, the supervisor task processes data ingestion on its own instead of\n+        spawning worker tasks. If this value is set to too large, too many worker tasks can be\n+        created which might block other ingestion.\n+      </>\n+    ),\n+  },\n+  {\n+    name: 'inputSegmentSizeBytes',\n+    type: 'number',\n+    defaultValue: 419430400,\n+    info: (\n+      <p>\n+        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n+        be processed in its entirety, if the segments for a particular time chunk have a total size\n+        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n+        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n+        result in compaction tasks taking an excessive amount of time.\n+      </p>\n+    ),\n+  },\n+  {\n+    name: 'tuningConfig.maxNumMergeTasks',\n+    label: 'Max num merge tasks',\n+    type: 'number',\n+    defaultValue: 1,\n+    min: 1,\n+    defined: (t: CompactionConfig) =>\n+      ['hashed', 'single_dim'].includes(deepGet(t, 'tuningConfig.partitionsSpec.type')),\n+    info: <>Maximum number of merge tasks which can be run at the same time.</>,\n+  },\n+  {\n+    name: 'tuningConfig.splitHintSpec.maxInputSegmentBytesPerTask',\n+    label: 'Max input segment bytes per task',\n+    type: 'number',\n+    defaultValue: 500000000,\n+    min: 1000000,\n+    adjustment: (t: CompactionConfig) => deepSet(t, 'tuningConfig.splitHintSpec.type', 'segments'),\n+    info: (\n+      <>\n+        Maximum number of bytes of input segments to process in a single task. If a single segment\n+        is larger than this number, it will be processed by itself in a single task (input segments\n+        are never split across tasks).\n+      </>\n+    ),\n+  },\n ];\n \n+function validCompactionConfig(compactionConfig: CompactionConfig): boolean {\n+  const partitionsSpecType =\n+    deepGet(compactionConfig, 'tuningConfig.partitionsSpec.type') || 'dynamic';\n+  switch (partitionsSpecType) {\n+    // case 'dynamic': // Nothing to check for dynamic\n+    case 'hashed':\n+      if (!deepGet(compactionConfig, 'tuningConfig.partitionsSpec.numShards')) {\n+        return false;\n+      }\n+      break;\n+\n+    case 'single_dim':\n+      if (!deepGet(compactionConfig, 'tuningConfig.partitionsSpec.partitionDimension')) {\n+        return false;\n+      }\n+      if (\n+        !deepGet(compactionConfig, 'tuningConfig.partitionsSpec.targetRowsPerSegment') &&\n+        !deepGet(compactionConfig, 'tuningConfig.partitionsSpec.maxRowsPerSegment')", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NjcyMA=="}, "originalCommit": {"oid": "58cc07f4b1e7e8a68a82d567bcf1a8a03ef58c1c"}, "originalPosition": 245}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTgxMTk5OnYy", "diffSide": "RIGHT", "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMjoyNjowNVrOHWOe2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMjoyNjowNVrOHWOe2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2Nzk5NA==", "bodyText": "See the comment I left on validCompactionConfig().", "url": "https://github.com/apache/druid/pull/10417#discussion_r493067994", "createdAt": "2020-09-22T22:26:05Z", "author": {"login": "ccaominh"}, "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "diffHunk": "@@ -16,101 +16,242 @@\n  * limitations under the License.\n  */\n \n-import { Button, Classes, Dialog, Intent } from '@blueprintjs/core';\n+import { Button, ButtonGroup, Classes, Code, Dialog, FormGroup, Intent } from '@blueprintjs/core';\n import React, { useState } from 'react';\n \n-import { AutoForm, ExternalLink, Field } from '../../components';\n-import { getLink } from '../../links';\n+import { AutoForm, Field, JsonInput } from '../../components';\n+import { deepGet, deepSet } from '../../utils/object-change';\n \n import './compaction-dialog.scss';\n \n export const DEFAULT_MAX_ROWS_PER_SEGMENT = 5000000;\n \n-const COMPACTION_CONFIG_FIELDS: Field<Record<string, any>>[] = [\n+type Tabs = 'form' | 'json';\n+\n+type CompactionConfig = Record<string, any>;\n+\n+const COMPACTION_CONFIG_FIELDS: Field<CompactionConfig>[] = [\n   {\n-    name: 'inputSegmentSizeBytes',\n-    type: 'number',\n-    defaultValue: 419430400,\n+    name: 'skipOffsetFromLatest',\n+    type: 'string',\n+    defaultValue: 'P1D',\n     info: (\n       <p>\n-        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n-        be processed in its entirety, if the segments for a particular time chunk have a total size\n-        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n-        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n-        result in compaction tasks taking an excessive amount of time.\n+        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n+        dataSources.\n       </p>\n     ),\n   },\n   {\n-    name: 'skipOffsetFromLatest',\n+    name: 'tuningConfig.partitionsSpec.type',\n+    label: 'Partitioning type',\n     type: 'string',\n-    defaultValue: 'P1D',\n+    suggestions: ['dynamic', 'hashed', 'single_dim'],\n     info: (\n       <p>\n-        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n-        dataSources.\n+        For perfect rollup, you should use either <Code>hashed</Code> (partitioning based on the\n+        hash of dimensions in each row) or <Code>single_dim</Code> (based on ranges of a single\n+        dimension. For best-effort rollup, you should use dynamic.\n       </p>\n     ),\n   },\n+  // partitionsSpec type: dynamic\n   {\n-    name: 'maxRowsPerSegment',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: DEFAULT_MAX_ROWS_PER_SEGMENT,\n-    info: <p>Determines how many rows are in each segment.</p>,\n+    defaultValue: 5000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Determines how many rows are in each segment.</>,\n   },\n   {\n-    name: 'taskContext',\n-    type: 'json',\n+    name: 'tuningConfig.partitionsSpec.maxTotalRows',\n+    label: 'Max total rows',\n+    type: 'number',\n+    defaultValue: 20000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Total number of rows in segments waiting for being pushed.</>,\n+  },\n+  // partitionsSpec type: hashed\n+  {\n+    name: 'tuningConfig.partitionsSpec.numShards',\n+    label: 'Num shards',\n+    type: 'number',\n+    required: true, // ToDo: this will no longer be required soon\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'hashed',\n+    info: (\n+      <>\n+        Directly specify the number of shards to create. If this is specified and 'intervals' is\n+        specified in the granularitySpec, the index task can skip the determine intervals/partitions\n+        pass through the data. numShards cannot be specified if maxRowsPerSegment is set.\n+      </>\n+    ),\n+  },\n+  {\n+    name: 'tuningConfig.partitionsSpec.partitionDimensions',\n+    label: 'Partition dimensions',\n+    type: 'string-array',\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'hashed',\n+    info: <p>The dimensions to partition on. Leave blank to select all dimensions.</p>,\n+  },\n+  // partitionsSpec type: single_dim\n+  {\n+    name: 'tuningConfig.partitionsSpec.partitionDimension',\n+    label: 'Partition dimension',\n+    type: 'string',\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: true,\n+    info: <p>The dimension to partition on.</p>,\n+  },\n+  {\n+    name: 'tuningConfig.partitionsSpec.targetRowsPerSegment',\n+    label: 'Target rows per segment',\n+    type: 'number',\n+    zeroMeansUndefined: true,\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: (t: CompactionConfig) =>\n+      !deepGet(t, 'tuningConfig.partitionsSpec.targetRowsPerSegment') &&\n+      !deepGet(t, 'tuningConfig.partitionsSpec.maxRowsPerSegment'),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58cc07f4b1e7e8a68a82d567bcf1a8a03ef58c1c"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTgxMjI5OnYy", "diffSide": "RIGHT", "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMjoyNjoxNFrOHWOfCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMjoyNjoxNFrOHWOfCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2ODA0Mg==", "bodyText": "See the comment I left on validCompactionConfig().", "url": "https://github.com/apache/druid/pull/10417#discussion_r493068042", "createdAt": "2020-09-22T22:26:14Z", "author": {"login": "ccaominh"}, "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "diffHunk": "@@ -16,101 +16,242 @@\n  * limitations under the License.\n  */\n \n-import { Button, Classes, Dialog, Intent } from '@blueprintjs/core';\n+import { Button, ButtonGroup, Classes, Code, Dialog, FormGroup, Intent } from '@blueprintjs/core';\n import React, { useState } from 'react';\n \n-import { AutoForm, ExternalLink, Field } from '../../components';\n-import { getLink } from '../../links';\n+import { AutoForm, Field, JsonInput } from '../../components';\n+import { deepGet, deepSet } from '../../utils/object-change';\n \n import './compaction-dialog.scss';\n \n export const DEFAULT_MAX_ROWS_PER_SEGMENT = 5000000;\n \n-const COMPACTION_CONFIG_FIELDS: Field<Record<string, any>>[] = [\n+type Tabs = 'form' | 'json';\n+\n+type CompactionConfig = Record<string, any>;\n+\n+const COMPACTION_CONFIG_FIELDS: Field<CompactionConfig>[] = [\n   {\n-    name: 'inputSegmentSizeBytes',\n-    type: 'number',\n-    defaultValue: 419430400,\n+    name: 'skipOffsetFromLatest',\n+    type: 'string',\n+    defaultValue: 'P1D',\n     info: (\n       <p>\n-        Maximum number of total segment bytes processed per compaction task. Since a time chunk must\n-        be processed in its entirety, if the segments for a particular time chunk have a total size\n-        in bytes greater than this parameter, compaction will not run for that time chunk. Because\n-        each compaction task runs with a single thread, setting this value too far above 1\u20132GB will\n-        result in compaction tasks taking an excessive amount of time.\n+        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n+        dataSources.\n       </p>\n     ),\n   },\n   {\n-    name: 'skipOffsetFromLatest',\n+    name: 'tuningConfig.partitionsSpec.type',\n+    label: 'Partitioning type',\n     type: 'string',\n-    defaultValue: 'P1D',\n+    suggestions: ['dynamic', 'hashed', 'single_dim'],\n     info: (\n       <p>\n-        The offset for searching segments to be compacted. Strongly recommended to set for realtime\n-        dataSources.\n+        For perfect rollup, you should use either <Code>hashed</Code> (partitioning based on the\n+        hash of dimensions in each row) or <Code>single_dim</Code> (based on ranges of a single\n+        dimension. For best-effort rollup, you should use dynamic.\n       </p>\n     ),\n   },\n+  // partitionsSpec type: dynamic\n   {\n-    name: 'maxRowsPerSegment',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: DEFAULT_MAX_ROWS_PER_SEGMENT,\n-    info: <p>Determines how many rows are in each segment.</p>,\n+    defaultValue: 5000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Determines how many rows are in each segment.</>,\n   },\n   {\n-    name: 'taskContext',\n-    type: 'json',\n+    name: 'tuningConfig.partitionsSpec.maxTotalRows',\n+    label: 'Max total rows',\n+    type: 'number',\n+    defaultValue: 20000000,\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'dynamic',\n+    info: <>Total number of rows in segments waiting for being pushed.</>,\n+  },\n+  // partitionsSpec type: hashed\n+  {\n+    name: 'tuningConfig.partitionsSpec.numShards',\n+    label: 'Num shards',\n+    type: 'number',\n+    required: true, // ToDo: this will no longer be required soon\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'hashed',\n+    info: (\n+      <>\n+        Directly specify the number of shards to create. If this is specified and 'intervals' is\n+        specified in the granularitySpec, the index task can skip the determine intervals/partitions\n+        pass through the data. numShards cannot be specified if maxRowsPerSegment is set.\n+      </>\n+    ),\n+  },\n+  {\n+    name: 'tuningConfig.partitionsSpec.partitionDimensions',\n+    label: 'Partition dimensions',\n+    type: 'string-array',\n+    defined: (t: CompactionConfig) => deepGet(t, 'tuningConfig.partitionsSpec.type') === 'hashed',\n+    info: <p>The dimensions to partition on. Leave blank to select all dimensions.</p>,\n+  },\n+  // partitionsSpec type: single_dim\n+  {\n+    name: 'tuningConfig.partitionsSpec.partitionDimension',\n+    label: 'Partition dimension',\n+    type: 'string',\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: true,\n+    info: <p>The dimension to partition on.</p>,\n+  },\n+  {\n+    name: 'tuningConfig.partitionsSpec.targetRowsPerSegment',\n+    label: 'Target rows per segment',\n+    type: 'number',\n+    zeroMeansUndefined: true,\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: (t: CompactionConfig) =>\n+      !deepGet(t, 'tuningConfig.partitionsSpec.targetRowsPerSegment') &&\n+      !deepGet(t, 'tuningConfig.partitionsSpec.maxRowsPerSegment'),\n     info: (\n       <p>\n-        <ExternalLink href={`${getLink('DOCS')}/ingestion/tasks.html#task-context`}>\n-          Task context\n-        </ExternalLink>{' '}\n-        for compaction tasks.\n+        Target number of rows to include in a partition, should be a number that targets segments of\n+        500MB~1GB.\n       </p>\n     ),\n   },\n   {\n-    name: 'taskPriority',\n+    name: 'tuningConfig.partitionsSpec.maxRowsPerSegment',\n+    label: 'Max rows per segment',\n     type: 'number',\n-    defaultValue: 25,\n-    info: <p>Priority of the compaction task.</p>,\n+    zeroMeansUndefined: true,\n+    defined: (t: CompactionConfig) =>\n+      deepGet(t, 'tuningConfig.partitionsSpec.type') === 'single_dim',\n+    required: (t: CompactionConfig) =>\n+      !deepGet(t, 'tuningConfig.partitionsSpec.targetRowsPerSegment') &&\n+      !deepGet(t, 'tuningConfig.partitionsSpec.maxRowsPerSegment'),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58cc07f4b1e7e8a68a82d567bcf1a8a03ef58c1c"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4NTgxOTE0OnYy", "diffSide": "RIGHT", "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMjoyOTowM1rOHWOjSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMlQyMjoyOTowM1rOHWOjSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2OTEzMQ==", "bodyText": "I really like the new Form vs JSON tabs and the binding between the two views. Nice work!", "url": "https://github.com/apache/druid/pull/10417#discussion_r493069131", "createdAt": "2020-09-22T22:29:03Z", "author": {"login": "ccaominh"}, "path": "web-console/src/dialogs/compaction-dialog/compaction-dialog.tsx", "diffHunk": "@@ -122,25 +263,40 @@ export const CompactionDialog = React.memo(function CompactionDialog(props: Comp\n       canOutsideClickClose={false}\n       title={`Compaction config: ${datasource}`}\n     >\n-      <AutoForm\n-        fields={COMPACTION_CONFIG_FIELDS}\n-        model={currentConfig}\n-        onChange={m => setCurrentConfig(m)}\n-      />\n-      <div className={Classes.DIALOG_FOOTER}>\n-        <div className={Classes.DIALOG_FOOTER_ACTIONS}>\n+      <FormGroup className=\"tabs\">\n+        <ButtonGroup fill>\n+          <Button\n+            text=\"Form\"\n+            active={currentTab === 'form'}\n+            onClick={() => setCurrentTab('form')}\n+          />\n           <Button\n-            text=\"Delete\"\n-            intent={Intent.DANGER}\n-            onClick={onDelete}\n-            disabled={!compactionConfig}\n+            text=\"JSON\"\n+            active={currentTab === 'json'}\n+            onClick={() => setCurrentTab('json')}\n           />\n+        </ButtonGroup>\n+      </FormGroup>\n+      <div className=\"content\">\n+        {currentTab === 'form' ? (\n+          <AutoForm\n+            fields={COMPACTION_CONFIG_FIELDS}\n+            model={currentConfig}\n+            onChange={m => setCurrentConfig(m)}\n+          />\n+        ) : (\n+          <JsonInput value={currentConfig} onChange={setCurrentConfig} height=\"100%\" />\n+        )}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58cc07f4b1e7e8a68a82d567bcf1a8a03ef58c1c"}, "originalPosition": 321}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2953, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}