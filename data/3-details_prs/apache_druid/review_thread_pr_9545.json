{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxNTk2MDY2", "number": 9545, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzozODoxNlrODp9Vtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMToyMjo1MFrODqBKZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzIzMTkxOnYy", "diffSide": "RIGHT", "path": "docs/configuration/index.md", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzozODoxNlrOF5dRCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMzoyMToyMVrOF5lnoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5MjY1MA==", "bodyText": "Maybe worth to mention that there is no replacement for maxQueryCount and why.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395792650", "createdAt": "2020-03-20T17:38:16Z", "author": {"login": "jihoonson"}, "path": "docs/configuration/index.md", "diffHunk": "@@ -1632,6 +1632,10 @@ The Druid SQL server is configured through the following properties on the Broke\n |`druid.sql.planner.sqlTimeZone`|Sets the default time zone for the server, which will affect how time functions and timestamp literals behave. Should be a time zone name like \"America/Los_Angeles\" or offset like \"-08:00\".|UTC|\n |`druid.sql.planner.serializeComplexValues`|Whether to serialize \"complex\" output values, false will return the class name instead of the serialized value.|true|\n \n+> Previous versions of Druid had properties named `druid.sql.planner.maxQueryCount` and `druid.sql.planner.maxSemiJoinRowsInMemory`.\n+> These properties are no longer available. Since Druid 0.18.0, you can use `druid.server.http.maxSubqueryRows` to control the maximum\n+> number of rows permitted across all subqueries.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eeae13930d3267b6831133a875ea3c9fc6bb66a"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5MzM5Ng==", "bodyText": "Should maxSubqueryRows be added to the above table instead of maxQueryCount and maxSemiJoinRowsInMemory?", "url": "https://github.com/apache/druid/pull/9545#discussion_r395793396", "createdAt": "2020-03-20T17:39:45Z", "author": {"login": "jihoonson"}, "path": "docs/configuration/index.md", "diffHunk": "@@ -1632,6 +1632,10 @@ The Druid SQL server is configured through the following properties on the Broke\n |`druid.sql.planner.sqlTimeZone`|Sets the default time zone for the server, which will affect how time functions and timestamp literals behave. Should be a time zone name like \"America/Los_Angeles\" or offset like \"-08:00\".|UTC|\n |`druid.sql.planner.serializeComplexValues`|Whether to serialize \"complex\" output values, false will return the class name instead of the serialized value.|true|\n \n+> Previous versions of Druid had properties named `druid.sql.planner.maxQueryCount` and `druid.sql.planner.maxSemiJoinRowsInMemory`.\n+> These properties are no longer available. Since Druid 0.18.0, you can use `druid.server.http.maxSubqueryRows` to control the maximum\n+> number of rows permitted across all subqueries.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5MjY1MA=="}, "originalCommit": {"oid": "5eeae13930d3267b6831133a875ea3c9fc6bb66a"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkyOTUwNQ==", "bodyText": "I don't think so, since it's not a SQL parameter anymore. It should be added to the general Broker table though. I'll do that.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395929505", "createdAt": "2020-03-20T23:21:21Z", "author": {"login": "gianm"}, "path": "docs/configuration/index.md", "diffHunk": "@@ -1632,6 +1632,10 @@ The Druid SQL server is configured through the following properties on the Broke\n |`druid.sql.planner.sqlTimeZone`|Sets the default time zone for the server, which will affect how time functions and timestamp literals behave. Should be a time zone name like \"America/Los_Angeles\" or offset like \"-08:00\".|UTC|\n |`druid.sql.planner.serializeComplexValues`|Whether to serialize \"complex\" output values, false will return the class name instead of the serialized value.|true|\n \n+> Previous versions of Druid had properties named `druid.sql.planner.maxQueryCount` and `druid.sql.planner.maxSemiJoinRowsInMemory`.\n+> These properties are no longer available. Since Druid 0.18.0, you can use `druid.server.http.maxSubqueryRows` to control the maximum\n+> number of rows permitted across all subqueries.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5MjY1MA=="}, "originalCommit": {"oid": "5eeae13930d3267b6831133a875ea3c9fc6bb66a"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzI0MTM2OnYy", "diffSide": "RIGHT", "path": "docs/querying/sql.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzo0MToxNlrOF5dXDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQwMDoxMDoyMFrOF5mMEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5NDE5MA==", "bodyText": "Same here. Should maxSubqueryRows be added to the above table?", "url": "https://github.com/apache/druid/pull/9545#discussion_r395794190", "createdAt": "2020-03-20T17:41:16Z", "author": {"login": "jihoonson"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -949,6 +947,10 @@ The Druid SQL server is configured through the following properties on the Broke\n |`druid.sql.planner.metadataSegmentCacheEnable`|Whether to keep a cache of published segments in broker. If true, broker polls coordinator in background to get segments from metadata store and maintains a local cache. If false, coordinator's REST API will be invoked when broker needs published segments info.|false|\n |`druid.sql.planner.metadataSegmentPollPeriod`|How often to poll coordinator for published segments list if `druid.sql.planner.metadataSegmentCacheEnable` is set to true. Poll period is in milliseconds. |60000|\n \n+> Previous versions of Druid had properties named `druid.sql.planner.maxQueryCount` and `druid.sql.planner.maxSemiJoinRowsInMemory`.\n+> These properties are no longer available. Since Druid 0.18.0, you can use `druid.server.http.maxSubqueryRows` to control the maximum", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eeae13930d3267b6831133a875ea3c9fc6bb66a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkzODgzNQ==", "bodyText": "Not here, but it should be added to the other table. I'll add it.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395938835", "createdAt": "2020-03-21T00:10:20Z", "author": {"login": "gianm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -949,6 +947,10 @@ The Druid SQL server is configured through the following properties on the Broke\n |`druid.sql.planner.metadataSegmentCacheEnable`|Whether to keep a cache of published segments in broker. If true, broker polls coordinator in background to get segments from metadata store and maintains a local cache. If false, coordinator's REST API will be invoked when broker needs published segments info.|false|\n |`druid.sql.planner.metadataSegmentPollPeriod`|How often to poll coordinator for published segments list if `druid.sql.planner.metadataSegmentCacheEnable` is set to true. Poll period is in milliseconds. |60000|\n \n+> Previous versions of Druid had properties named `druid.sql.planner.maxQueryCount` and `druid.sql.planner.maxSemiJoinRowsInMemory`.\n+> These properties are no longer available. Since Druid 0.18.0, you can use `druid.server.http.maxSubqueryRows` to control the maximum", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5NDE5MA=="}, "originalCommit": {"oid": "5eeae13930d3267b6831133a875ea3c9fc6bb66a"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzQ4NDg3OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQueryRel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxODo1OTozMlrOF5f2eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMjozNjoyN1rOF5k-eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNTAwMg==", "bodyText": "Unused variable.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395835002", "createdAt": "2020-03-20T18:59:32Z", "author": {"login": "jihoonson"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQueryRel.java", "diffHunk": "@@ -34,22 +34,14 @@\n import org.apache.druid.java.util.common.guava.Sequence;\n import org.apache.druid.sql.calcite.table.DruidTable;\n \n-import javax.annotation.Nonnull;\n import java.util.Set;\n \n /**\n  * DruidRel that operates on top of a {@link DruidTable} directly (no joining or subqueries).\n  */\n public class DruidQueryRel extends DruidRel<DruidQueryRel>\n {\n-  // Factors used for computing cost (see computeSelfCost). These are intended to encourage pushing down filters\n-  // and limits through stacks of nested queries when possible.\n-  private static final double COST_BASE = 1.0;\n-  private static final double COST_PER_COLUMN = 0.001;\n-  private static final double COST_FILTER_MULTIPLIER = 0.1;\n-  private static final double COST_GROUPING_MULTIPLIER = 0.5;\n-  private static final double COST_LIMIT_MULTIPLIER = 0.5;\n-  private static final double COST_HAVING_MULTIPLIER = 5.0;\n+  static final double COST_BASE = 1.0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxODk2OA==", "bodyText": "Thanks, I'll remove it.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395918968", "createdAt": "2020-03-20T22:36:27Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQueryRel.java", "diffHunk": "@@ -34,22 +34,14 @@\n import org.apache.druid.java.util.common.guava.Sequence;\n import org.apache.druid.sql.calcite.table.DruidTable;\n \n-import javax.annotation.Nonnull;\n import java.util.Set;\n \n /**\n  * DruidRel that operates on top of a {@link DruidTable} directly (no joining or subqueries).\n  */\n public class DruidQueryRel extends DruidRel<DruidQueryRel>\n {\n-  // Factors used for computing cost (see computeSelfCost). These are intended to encourage pushing down filters\n-  // and limits through stacks of nested queries when possible.\n-  private static final double COST_BASE = 1.0;\n-  private static final double COST_PER_COLUMN = 0.001;\n-  private static final double COST_FILTER_MULTIPLIER = 0.1;\n-  private static final double COST_GROUPING_MULTIPLIER = 0.5;\n-  private static final double COST_LIMIT_MULTIPLIER = 0.5;\n-  private static final double COST_HAVING_MULTIPLIER = 5.0;\n+  static final double COST_BASE = 1.0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNTAwMg=="}, "originalCommit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzQ5MTY2OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidRel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxOTowMTo0NlrOF5f63Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMjozODoxMVrOF5lAEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNjEyNQ==", "bodyText": "This doesn't seem right since we don't have DruidSemiJoin anymore.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395836125", "createdAt": "2020-03-20T19:01:46Z", "author": {"login": "jihoonson"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidRel.java", "diffHunk": "@@ -71,17 +71,14 @@ public boolean isValidDruidQuery()\n    * Convert this DruidRel to a DruidQuery. This may be an expensive operation. For example, DruidSemiJoin needs to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxOTM3OQ==", "bodyText": "I forgot to update this javadoc! Updated.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395919379", "createdAt": "2020-03-20T22:38:11Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidRel.java", "diffHunk": "@@ -71,17 +71,14 @@ public boolean isValidDruidQuery()\n    * Convert this DruidRel to a DruidQuery. This may be an expensive operation. For example, DruidSemiJoin needs to", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNjEyNQ=="}, "originalCommit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzQ5MjM3OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidRel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxOTowMjowMlrOF5f7Vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMjozODoyMFrOF5lAOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNjI0Nw==", "bodyText": "This method does not return null?", "url": "https://github.com/apache/druid/pull/9545#discussion_r395836247", "createdAt": "2020-03-20T19:02:02Z", "author": {"login": "jihoonson"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidRel.java", "diffHunk": "@@ -71,17 +71,14 @@ public boolean isValidDruidQuery()\n    * Convert this DruidRel to a DruidQuery. This may be an expensive operation. For example, DruidSemiJoin needs to\n    * execute the right-hand side query in order to complete this method.\n    *\n-   * This method may return null if it knows that this rel will yield an empty result set.\n+   * This method may not return null.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxOTQxNw==", "bodyText": "Changed it to \"This method must not return null.\"", "url": "https://github.com/apache/druid/pull/9545#discussion_r395919417", "createdAt": "2020-03-20T22:38:20Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidRel.java", "diffHunk": "@@ -71,17 +71,14 @@ public boolean isValidDruidQuery()\n    * Convert this DruidRel to a DruidQuery. This may be an expensive operation. For example, DruidSemiJoin needs to\n    * execute the right-hand side query in order to complete this method.\n    *\n-   * This method may return null if it knows that this rel will yield an empty result set.\n+   * This method may not return null.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNjI0Nw=="}, "originalCommit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MzgxNzUwOnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteParameterQueryTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMTowNTo0MVrOF5jLMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMVQwMDo1MToxNVrOF5miGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4OTQ1Ng==", "bodyText": "This doesn't seem right.. I guess it should be always 0.\nBased on the expected results before this PR, it seems that a timeseries query was issued when useDefault = true which returns an empty result. When useDefault = false, no query was issued so probably the query computation was done by Calcite.\nSo, I guess there are two potential issues here. One is the timeseries query returning an empty result and another is Calcite returning an empty result which used to return a valid result. We may want to fix the Calcite issue in this PR. The timeseries issue seems a bug, but since it's not introduced in this PR and we are about to cut the branch for 0.18, I'm ok with merging this PR and backporting the bug fix later.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395889456", "createdAt": "2020-03-20T21:05:41Z", "author": {"login": "jihoonson"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteParameterQueryTest.java", "diffHunk": "@@ -602,14 +602,13 @@ public void testWrongTypeParameter() throws Exception\n                       and(\n                           bound(\"l1\", \"3\", null, true, false, null, StringComparators.NUMERIC),\n                           selector(\"f1\", useDefault ? \"0.0\" : null, null)\n-\n                       )\n                   )\n                   .aggregators(aggregators(new CountAggregatorFactory(\"a0\")))\n                   .context(TIMESERIES_CONTEXT_DEFAULT)\n                   .build()\n         ) : ImmutableList.of(),\n-        useDefault ? ImmutableList.of() : ImmutableList.of(new Object[]{0L}),\n+        ImmutableList.of(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk0MTA4NQ==", "bodyText": "Your analysis sounds right to me. I tracked this down to the removal of AggregateMergeRule, which I did because it was causing one of the new tests to fail (testDoubleNestedGroupBy2). Without that rule loaded, this query gets executed by a BindableAggregate, which doesn't seem to properly generate the expected row.\nSince this is a situation where two bugs are conflicting, I think it might take some time to unwind. I'd rather look into that in a future patch. My preference would be to do this:\n\nIdentify and fix the bug with AggregateMergeRule, and re-enable it. That should get us back to normal on this test.\nAfter that, stop using Bindable completely, and instead use native Druid queries for everything (even queries on literal values). We can do this by adding a few more capabilities to native Druid queries. Then we won't have to worry about it.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395941085", "createdAt": "2020-03-21T00:25:16Z", "author": {"login": "gianm"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteParameterQueryTest.java", "diffHunk": "@@ -602,14 +602,13 @@ public void testWrongTypeParameter() throws Exception\n                       and(\n                           bound(\"l1\", \"3\", null, true, false, null, StringComparators.NUMERIC),\n                           selector(\"f1\", useDefault ? \"0.0\" : null, null)\n-\n                       )\n                   )\n                   .aggregators(aggregators(new CountAggregatorFactory(\"a0\")))\n                   .context(TIMESERIES_CONTEXT_DEFAULT)\n                   .build()\n         ) : ImmutableList.of(),\n-        useDefault ? ImmutableList.of() : ImmutableList.of(new Object[]{0L}),\n+        ImmutableList.of(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4OTQ1Ng=="}, "originalCommit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk0NDQ3NQ==", "bodyText": "Sounds good to me.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395944475", "createdAt": "2020-03-21T00:51:15Z", "author": {"login": "jihoonson"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteParameterQueryTest.java", "diffHunk": "@@ -602,14 +602,13 @@ public void testWrongTypeParameter() throws Exception\n                       and(\n                           bound(\"l1\", \"3\", null, true, false, null, StringComparators.NUMERIC),\n                           selector(\"f1\", useDefault ? \"0.0\" : null, null)\n-\n                       )\n                   )\n                   .aggregators(aggregators(new CountAggregatorFactory(\"a0\")))\n                   .context(TIMESERIES_CONTEXT_DEFAULT)\n                   .build()\n         ) : ImmutableList.of(),\n-        useDefault ? ImmutableList.of() : ImmutableList.of(new Object[]{0L}),\n+        ImmutableList.of(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4OTQ1Ng=="}, "originalCommit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1Mzg1ODMxOnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMToyMjo1MFrOF5jk5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMjozODo1NlrOF5lA6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5NjAzNg==", "bodyText": "Seems like the same Calcite issue.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395896036", "createdAt": "2020-03-20T21:22:50Z", "author": {"login": "jihoonson"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -4841,10 +4982,12 @@ public void testCountStarWithDegenerateFilter() throws Exception\n   @Test\n   public void testCountStarWithNotOfDegenerateFilter() throws Exception\n   {\n+    // This query is evaluated in the planner (no native queries are issued) due to the degenerate filter.\n+\n     testQuery(\n         \"SELECT COUNT(*) FROM druid.foo WHERE dim2 = 'a' and not (dim1 > 'a' OR dim1 < 'b')\",\n         ImmutableList.of(),\n-        ImmutableList.of(new Object[]{0L})\n+        ImmutableList.of()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkxOTU5NA==", "bodyText": "Yeah, I think it is.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395919594", "createdAt": "2020-03-20T22:38:56Z", "author": {"login": "gianm"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -4841,10 +4982,12 @@ public void testCountStarWithDegenerateFilter() throws Exception\n   @Test\n   public void testCountStarWithNotOfDegenerateFilter() throws Exception\n   {\n+    // This query is evaluated in the planner (no native queries are issued) due to the degenerate filter.\n+\n     testQuery(\n         \"SELECT COUNT(*) FROM druid.foo WHERE dim2 = 'a' and not (dim1 > 'a' OR dim1 < 'b')\",\n         ImmutableList.of(),\n-        ImmutableList.of(new Object[]{0L})\n+        ImmutableList.of()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5NjAzNg=="}, "originalCommit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03"}, "originalPosition": 243}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2659, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}