{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3MjI2MzA1", "number": 10338, "title": "Vectorized ANY aggregators", "bodyText": "Description\nThis patch provides a vectorized implementation of the ANY aggregators. Since these aggregators already only read 1 value from the column, the performance gain comparing a vectorized implementation and non-vectorized implementation is expected to be minimal (maybe even slightly slower since we read a batch of values).\nHowever, providing a vectorized implementation allows for queries of the following shape to be vectorized\nSELECT id, ANY_VALUE(name), SUM(number) from datasource group by id\n\nwhere we know there is a 1:1 mapping between id and name\n\nThis PR has:\n\n been self-reviewed.\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths, ensuring the threshold for code coverage is met.\n added integration tests.\n been tested in a test Druid cluster.", "createdAt": "2020-09-01T17:23:38Z", "url": "https://github.com/apache/druid/pull/10338", "merged": true, "mergeCommit": {"oid": "f71ba6f2c202d3edc0cdf8efa2274d0e247ddca8"}, "closed": true, "closedAt": "2020-09-15T02:44:58Z", "author": {"login": "suneet-s"}, "timelineItems": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdEqsVNAH2gAyNDc3MjI2MzA1OjQ5ZTRmMGNlZDhlODFhMjQzYWZlYWNhNmQ3OTA0OGE3YzM2YmYzMGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdI-hEmAFqTQ4ODI4MjM1NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "49e4f0ced8e81a243afeaca6d79048a7c36bf30f", "author": {"user": {"login": "suneet-s", "name": "Suneet Saldanha"}}, "url": "https://github.com/apache/druid/commit/49e4f0ced8e81a243afeaca6d79048a7c36bf30f", "committedDate": "2020-09-01T17:17:22Z", "message": "WIP vectorized ANY aggregators"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5OTYzODMx", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-479963831", "createdAt": "2020-09-01T17:24:20Z", "commit": {"oid": "49e4f0ced8e81a243afeaca6d79048a7c36bf30f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzoyNDoyMVrOHLA33A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzoyNDoyMVrOHLA33A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMxMDY4NA==", "bodyText": "Should this check the columnType before offering a vectorized implementation? Similar question for other factories", "url": "https://github.com/apache/druid/pull/10338#discussion_r481310684", "createdAt": "2020-09-01T17:24:21Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -112,6 +115,18 @@ public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n     }\n   }\n \n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+    return new DoubleAnyVectorAggregator(selectorFactory.makeValueSelector(fieldName));\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49e4f0ced8e81a243afeaca6d79048a7c36bf30f"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5OTY0NjQw", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-479964640", "createdAt": "2020-09-01T17:25:36Z", "commit": {"oid": "49e4f0ced8e81a243afeaca6d79048a7c36bf30f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzoyNTozNlrOHLA6jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzoyNTozNlrOHLA6jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMxMTM3Mw==", "bodyText": "should any column type be allowed?", "url": "https://github.com/apache/druid/pull/10338#discussion_r481311373", "createdAt": "2020-09-01T17:25:36Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregatorFactory.java", "diffHunk": "@@ -77,6 +82,37 @@ public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n     return new StringAnyBufferAggregator(metricFactory.makeColumnValueSelector(fieldName), maxStringBytes);\n   }\n \n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+\n+    ColumnCapabilities capabilities = selectorFactory.getColumnCapabilities(fieldName);\n+    if (capabilities == null || capabilities.hasMultipleValues().isFalse()) {\n+      return new StringAnyVectorAggregator(\n+          selectorFactory.makeSingleValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          null,\n+          maxStringBytes\n+      );\n+    } else {\n+      return new StringAnyVectorAggregator(\n+          null,\n+          selectorFactory.makeMultiValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          maxStringBytes\n+      );\n+\n+    }\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    if (fieldName != null) {\n+      ColumnCapabilities capabilities = columnInspector.getColumnCapabilities(fieldName);\n+      return capabilities == null || capabilities.getType() == ValueType.STRING;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49e4f0ced8e81a243afeaca6d79048a7c36bf30f"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f990915a2eef8f165e3437a5f979fe894ac6924", "author": {"user": {"login": "suneet-s", "name": "Suneet Saldanha"}}, "url": "https://github.com/apache/druid/commit/7f990915a2eef8f165e3437a5f979fe894ac6924", "committedDate": "2020-09-02T22:02:18Z", "message": "Merge remote-tracking branch 'upstream/master' into vectorization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0c7aabf1d0e676ba74681865572d724be04693e", "author": {"user": {"login": "suneet-s", "name": "Suneet Saldanha"}}, "url": "https://github.com/apache/druid/commit/a0c7aabf1d0e676ba74681865572d724be04693e", "committedDate": "2020-09-03T03:35:00Z", "message": "tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ba5de97b5c4c8862ff9e36a6d801e5c482cd6be", "author": {"user": {"login": "suneet-s", "name": "Suneet Saldanha"}}, "url": "https://github.com/apache/druid/commit/8ba5de97b5c4c8862ff9e36a6d801e5c482cd6be", "committedDate": "2020-09-04T00:18:19Z", "message": "fix aggs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMjgxOTY0", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-482281964", "createdAt": "2020-09-04T00:21:20Z", "commit": {"oid": "49e4f0ced8e81a243afeaca6d79048a7c36bf30f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwMDoyMToyMFrOHM7fDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwMDoyMToyMFrOHM7fDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxOTU2Ng==", "bodyText": "This approach doesn't work, and one of the CalciteQueryTests caught it \ud83c\udf89", "url": "https://github.com/apache/druid/pull/10338#discussion_r483319566", "createdAt": "2020-09-04T00:21:20Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  private static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   * @return true if a value was put on the buffer, false otherwise.\n+   */\n+  abstract boolean putValue(ByteBuffer buf, int position, int startRow, int endRow);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putValue(buf, position, null);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      if (putValue(buf, position, startRow, endRow)) {\n+        buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(\n+      ByteBuffer buf,\n+      int numRows,\n+      int[] positions,\n+      @Nullable int[] rows,\n+      int positionOffset\n+  )\n+  {\n+    int prevPosition = -1;\n+    @Nullable Object theValue = null;\n+    boolean found = false;\n+    for (int i = 0; i < numRows; i++) {\n+      int position = positions[i] + positionOffset;\n+      int row = rows == null ? i : rows[i];\n+      // If the aggregate is not found at the position\n+      if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+        // If there's a value at the previous position, use it in this position.\n+        if (prevPosition >= 0 && (found || (buf.get(prevPosition) & BYTE_FLAG_FOUND_MASK) == BYTE_FLAG_FOUND_MASK)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49e4f0ced8e81a243afeaca6d79048a7c36bf30f"}, "originalPosition": 110}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a3bc03de282d0eca49a8bf0690a0e8222ac9356", "author": {"user": {"login": "suneet-s", "name": "Suneet Saldanha"}}, "url": "https://github.com/apache/druid/commit/0a3bc03de282d0eca49a8bf0690a0e8222ac9356", "committedDate": "2020-09-04T05:31:25Z", "message": "cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8", "author": {"user": {"login": "suneet-s", "name": "Suneet Saldanha"}}, "url": "https://github.com/apache/druid/commit/bf291df4c1122257c4a47f1e992b417800f101c8", "committedDate": "2020-09-04T05:31:53Z", "message": "Merge remote-tracking branch 'upstream/master' into vectorization"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNDQwMjA1", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-482440205", "createdAt": "2020-09-04T07:58:34Z", "commit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNzo1ODozNFrOHNDpsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNzo1ODozNFrOHNDpsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1MzM2MQ==", "bodyText": "startRow <= nulls.length is this check required? if so, it should check startRow < nulls.length", "url": "https://github.com/apache/druid/pull/10338#discussion_r483453361", "createdAt": "2020-09-04T07:58:34Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 77}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNDQ3MzM2", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-482447336", "createdAt": "2020-09-04T08:09:07Z", "commit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODowOTowOFrOHND-nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODowOTowOFrOHND-nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1ODcxOQ==", "bodyText": "should it not be aggregate(buf, position, row, row + 1) ?", "url": "https://github.com/apache/druid/pull/10338#discussion_r483458719", "createdAt": "2020-09-04T08:09:08Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putNull(buf, position);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      putValue(buf, position, startRow);\n+      buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(\n+      ByteBuffer buf,\n+      int numRows,\n+      int[] positions,\n+      @Nullable int[] rows,\n+      int positionOffset\n+  )\n+  {\n+    for (int i = 0; i < numRows; i++) {\n+      int position = positions[i] + positionOffset;\n+      int row = rows == null ? i : rows[i];\n+      aggregate(buf, position, row, row);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 104}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNDQ5NTQ3", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-482449547", "createdAt": "2020-09-04T08:12:18Z", "commit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoxMjoxOFrOHNEFPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoxMjoxOFrOHNEFPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDQxNQ==", "bodyText": "are there unit tests for this method?", "url": "https://github.com/apache/druid/pull/10338#discussion_r483460415", "createdAt": "2020-09-04T08:12:18Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putNull(buf, position);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      putValue(buf, position, startRow);\n+      buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 93}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNDUyMTcw", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-482452170", "createdAt": "2020-09-04T08:16:13Z", "commit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoxNjoxNFrOHNENPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoxNjoxNFrOHNENPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MjQ2Mw==", "bodyText": "I think it may be more efficient to not call aggregate. E.g. if a value is already found, we still iterate through the loop which could have been avoided. what do you think?", "url": "https://github.com/apache/druid/pull/10338#discussion_r483462463", "createdAt": "2020-09-04T08:16:14Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putNull(buf, position);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      putValue(buf, position, startRow);\n+      buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(\n+      ByteBuffer buf,\n+      int numRows,\n+      int[] positions,\n+      @Nullable int[] rows,\n+      int positionOffset\n+  )\n+  {\n+    for (int i = 0; i < numRows; i++) {\n+      int position = positions[i] + positionOffset;\n+      int row = rows == null ? i : rows[i];\n+      aggregate(buf, position, row, row);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 104}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNDY4NDU0", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-482468454", "createdAt": "2020-09-04T08:39:32Z", "commit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozOTozM1rOHNE-Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozOTozM1rOHNE-Dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NDk1OQ==", "bodyText": "non null", "url": "https://github.com/apache/druid/pull/10338#discussion_r483474959", "createdAt": "2020-09-04T08:39:33Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNDY5MDU4", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-482469058", "createdAt": "2020-09-04T08:40:23Z", "commit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0MDoyNFrOHNE_5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0MDoyNFrOHNE_5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NTQzMA==", "bodyText": "nit: how about putNonNullRow?", "url": "https://github.com/apache/druid/pull/10338#discussion_r483475430", "createdAt": "2020-09-04T08:40:24Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNDcwNzI3", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-482470727", "createdAt": "2020-09-04T08:42:37Z", "commit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0MjozN1rOHNFE4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0MjozN1rOHNFE4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NjcwNA==", "bodyText": "again nitpicking: but this can be made private. In inherited classes, instead of passing position, you can pass position + FOUND_VALUE_OFFSET so that those methods are free of any logic related to offset.", "url": "https://github.com/apache/druid/pull/10338#discussion_r483476704", "createdAt": "2020-09-04T08:42:37Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNDczMjg2", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-482473286", "createdAt": "2020-09-04T08:46:09Z", "commit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0NjoxMFrOHNFMwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0NjoxMFrOHNFMwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3ODcyMA==", "bodyText": "out of curiosity, when can capabilities be null?", "url": "https://github.com/apache/druid/pull/10338#discussion_r483478720", "createdAt": "2020-09-04T08:46:10Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregatorFactory.java", "diffHunk": "@@ -77,6 +81,33 @@ public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n     return new StringAnyBufferAggregator(metricFactory.makeColumnValueSelector(fieldName), maxStringBytes);\n   }\n \n+  @Override\n+  public StringAnyVectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+\n+    ColumnCapabilities capabilities = selectorFactory.getColumnCapabilities(fieldName);\n+    if (capabilities == null || capabilities.hasMultipleValues().isMaybeTrue()) {\n+      return new StringAnyVectorAggregator(\n+          null,\n+          selectorFactory.makeMultiValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          maxStringBytes\n+      );\n+    } else {\n+      return new StringAnyVectorAggregator(\n+          selectorFactory.makeSingleValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          null,\n+          maxStringBytes\n+      );\n+    }\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    ColumnCapabilities capabilities = columnInspector.getColumnCapabilities(fieldName);\n+    return capabilities == null || capabilities.getType() == ValueType.STRING;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyNzI2Mjk1", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-482726295", "createdAt": "2020-09-04T15:01:33Z", "commit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNTowMTozM1rOHNRKjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNTo0Nzo0MlrOHNTHCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3NDc2NA==", "bodyText": "Fixed.", "url": "https://github.com/apache/druid/pull/10338#discussion_r483674764", "createdAt": "2020-09-04T15:01:33Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1MzM2MQ=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3NDk4Mw==", "bodyText": "added now. Was in progress when I pushed the last patch up.", "url": "https://github.com/apache/druid/pull/10338#discussion_r483674983", "createdAt": "2020-09-04T15:01:57Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putNull(buf, position);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      putValue(buf, position, startRow);\n+      buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDQxNQ=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3NTExMw==", "bodyText": "yes \ud83d\ude2c", "url": "https://github.com/apache/druid/pull/10338#discussion_r483675113", "createdAt": "2020-09-04T15:02:11Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putNull(buf, position);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      putValue(buf, position, startRow);\n+      buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(\n+      ByteBuffer buf,\n+      int numRows,\n+      int[] positions,\n+      @Nullable int[] rows,\n+      int positionOffset\n+  )\n+  {\n+    for (int i = 0; i < numRows; i++) {\n+      int position = positions[i] + positionOffset;\n+      int row = rows == null ? i : rows[i];\n+      aggregate(buf, position, row, row);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1ODcxOQ=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3NjUyOA==", "bodyText": "I tried that earlier and it failed a test with subqueries - #10338 (comment)", "url": "https://github.com/apache/druid/pull/10338#discussion_r483676528", "createdAt": "2020-09-04T15:04:38Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putNull(buf, position);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      putValue(buf, position, startRow);\n+      buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(\n+      ByteBuffer buf,\n+      int numRows,\n+      int[] positions,\n+      @Nullable int[] rows,\n+      int positionOffset\n+  )\n+  {\n+    for (int i = 0; i < numRows; i++) {\n+      int position = positions[i] + positionOffset;\n+      int row = rows == null ? i : rows[i];\n+      aggregate(buf, position, row, row);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MjQ2Mw=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4MTUwMg==", "bodyText": "Removed this function. Realized that it was just putting 0, which is what initValue does", "url": "https://github.com/apache/druid/pull/10338#discussion_r483681502", "createdAt": "2020-09-04T15:13:45Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NDk1OQ=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwNTQxNQ==", "bodyText": "Refactored to boolean putAnyValueFromRow(ByteBuffer buf, int position, int startRow, int endRow)", "url": "https://github.com/apache/druid/pull/10338#discussion_r483705415", "createdAt": "2020-09-04T15:45:19Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NTQzMA=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwNTYxNA==", "bodyText": "good suggestion! Done.", "url": "https://github.com/apache/druid/pull/10338#discussion_r483705614", "createdAt": "2020-09-04T15:45:37Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NjcwNA=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwNjYzMg==", "bodyText": "/**\n   * Returns capabilities of a particular column, if known. May be null if the column doesn't exist, or if\n   * the column does exist but the capabilities are unknown. The latter is possible with dynamically discovered\n   * columns.\n   *\n   * Note that StorageAdapters are representations of \"real\" segments, so they are not aware of any virtual columns\n   * that may be involved in a query. In general, query engines should instead use the method\n   * {@link ColumnSelectorFactory#getColumnCapabilities(String)}, which returns capabilities for virtual columns as\n   * well.\n   *\n   * @param column column name\n   *\n   * @return capabilities, or null\n   */\n  @Override\n  @Nullable\n  ColumnCapabilities getColumnCapabilities(String column);\n\nI found this explanation in StorageAdapter#getColumnCapabilities", "url": "https://github.com/apache/druid/pull/10338#discussion_r483706632", "createdAt": "2020-09-04T15:47:42Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregatorFactory.java", "diffHunk": "@@ -77,6 +81,33 @@ public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n     return new StringAnyBufferAggregator(metricFactory.makeColumnValueSelector(fieldName), maxStringBytes);\n   }\n \n+  @Override\n+  public StringAnyVectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+\n+    ColumnCapabilities capabilities = selectorFactory.getColumnCapabilities(fieldName);\n+    if (capabilities == null || capabilities.hasMultipleValues().isMaybeTrue()) {\n+      return new StringAnyVectorAggregator(\n+          null,\n+          selectorFactory.makeMultiValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          maxStringBytes\n+      );\n+    } else {\n+      return new StringAnyVectorAggregator(\n+          selectorFactory.makeSingleValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          null,\n+          maxStringBytes\n+      );\n+    }\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    ColumnCapabilities capabilities = columnInspector.getColumnCapabilities(fieldName);\n+    return capabilities == null || capabilities.getType() == ValueType.STRING;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3ODcyMA=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 41}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d9e56f04ce7db06e0fa38b3e761072fb95289a23", "author": {"user": {"login": "suneet-s", "name": "Suneet Saldanha"}}, "url": "https://github.com/apache/druid/commit/d9e56f04ce7db06e0fa38b3e761072fb95289a23", "committedDate": "2020-09-04T17:38:00Z", "message": "code review + tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "605568eb662275cbef15ba37d6832bfac7c691f4", "author": {"user": {"login": "suneet-s", "name": "Suneet Saldanha"}}, "url": "https://github.com/apache/druid/commit/605568eb662275cbef15ba37d6832bfac7c691f4", "committedDate": "2020-09-04T18:04:58Z", "message": "docs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzMzMwNzU2", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-483330756", "createdAt": "2020-09-07T07:53:51Z", "commit": {"oid": "d9e56f04ce7db06e0fa38b3e761072fb95289a23"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwNzo1Mzo1MVrOHN0XMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwNzo1Mzo1MVrOHN0XMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI1MTQ0MA==", "bodyText": "by the way, are these checks necessary? The framework calling aggregators should be taking care of passing valid ranges. If not, its a bug and exception will be raised. I didn't notice these checks in other vector aggregation implementations.", "url": "https://github.com/apache/druid/pull/10338#discussion_r484251440", "createdAt": "2020-09-07T07:53:51Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/FloatAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Vectorized implementation of the {@link FloatAnyBufferAggregator}\n+ */\n+public class FloatAnyVectorAggregator extends NumericAnyVectorAggregator\n+{\n+  public FloatAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    super(vectorValueSelector);\n+  }\n+\n+  @Override\n+  void initValue(ByteBuffer buf, int position)\n+  {\n+    buf.putFloat(position, 0F);\n+  }\n+\n+  @Override\n+  boolean putAnyValueFromRow(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    float[] values = vectorValueSelector.getFloatVector();\n+    boolean isRowsWithinIndex = startRow < endRow && startRow < values.length;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9e56f04ce7db06e0fa38b3e761072fb95289a23"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNDA4Mzk0", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-483408394", "createdAt": "2020-09-07T09:37:22Z", "commit": {"oid": "d9e56f04ce7db06e0fa38b3e761072fb95289a23"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwOTozNzoyMlrOHN4P8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwOTozNzoyMlrOHN4P8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxNTEyMQ==", "bodyText": "this got me thinking about how did this test pass. There was no flag set in the buffer and the target still returned the value. I realized that in NumericAnyVectorAggregator, non-null is the default than null\nboolean isValueNull(ByteBuffer buf, int position)\n  {\n    return (buf.get(position) & BYTE_FLAG_NULL_MASK) == NullHandling.IS_NULL_BYTE;\n  }\n\nIt should be fine since init is always called. maybe the tests should do the same as well.", "url": "https://github.com/apache/druid/pull/10338#discussion_r484315121", "createdAt": "2020-09-07T09:37:22Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/test/java/org/apache/druid/query/aggregation/any/DoubleAnyVectorAggregatorTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+import org.apache.druid.testing.InitializedNullHandlingTest;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import static org.mockito.Mockito.spy;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class DoubleAnyVectorAggregatorTest extends InitializedNullHandlingTest\n+{\n+  private static final int NULL_POSITION = 32;\n+  private static final int POSITION = 2;\n+  private static final double EPSILON = 1e-15;\n+  private static final double[] VALUES = new double[]{7.8d, 11, 23.67, 60, 123};\n+\n+  private ByteBuffer buf;\n+  @Mock\n+  private VectorValueSelector selector;\n+\n+  private DoubleAnyVectorAggregator target;\n+\n+  @Before\n+  public void setUp()\n+  {\n+    byte[] randomBytes = new byte[128];\n+    ThreadLocalRandom.current().nextBytes(randomBytes);\n+    buf = ByteBuffer.wrap(randomBytes);\n+    Mockito.doReturn(VALUES).when(selector).getDoubleVector();\n+\n+    target = spy(new DoubleAnyVectorAggregator(selector));\n+    Mockito.when(target.isValueNull(buf, NULL_POSITION)).thenReturn(true);\n+    Mockito.when(target.isValueNull(buf, POSITION)).thenReturn(false);\n+  }\n+\n+  @Test\n+  public void initValueShouldInitZero()\n+  {\n+    target.initValue(buf, POSITION);\n+    Assert.assertEquals(0, buf.getDouble(POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void getAtPositionIsNullShouldReturnNull()\n+  {\n+    Assert.assertNull(target.get(buf, NULL_POSITION));\n+  }\n+\n+  @Test\n+  public void getAtPositionShouldReturnValue()\n+  {\n+    buf.putDouble(POSITION + 1, VALUES[3]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9e56f04ce7db06e0fa38b3e761072fb95289a23"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzNDA5NTU2", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-483409556", "createdAt": "2020-09-07T09:38:58Z", "commit": {"oid": "d9e56f04ce7db06e0fa38b3e761072fb95289a23"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwOTozODo1OFrOHN4TuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwOTozODo1OFrOHN4TuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxNjA4OA==", "bodyText": "we should be passing the delta in assertNotEquals methods too.", "url": "https://github.com/apache/druid/pull/10338#discussion_r484316088", "createdAt": "2020-09-07T09:38:58Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/test/java/org/apache/druid/query/aggregation/any/DoubleAnyVectorAggregatorTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+import org.apache.druid.testing.InitializedNullHandlingTest;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import static org.mockito.Mockito.spy;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class DoubleAnyVectorAggregatorTest extends InitializedNullHandlingTest\n+{\n+  private static final int NULL_POSITION = 32;\n+  private static final int POSITION = 2;\n+  private static final double EPSILON = 1e-15;\n+  private static final double[] VALUES = new double[]{7.8d, 11, 23.67, 60, 123};\n+\n+  private ByteBuffer buf;\n+  @Mock\n+  private VectorValueSelector selector;\n+\n+  private DoubleAnyVectorAggregator target;\n+\n+  @Before\n+  public void setUp()\n+  {\n+    byte[] randomBytes = new byte[128];\n+    ThreadLocalRandom.current().nextBytes(randomBytes);\n+    buf = ByteBuffer.wrap(randomBytes);\n+    Mockito.doReturn(VALUES).when(selector).getDoubleVector();\n+\n+    target = spy(new DoubleAnyVectorAggregator(selector));\n+    Mockito.when(target.isValueNull(buf, NULL_POSITION)).thenReturn(true);\n+    Mockito.when(target.isValueNull(buf, POSITION)).thenReturn(false);\n+  }\n+\n+  @Test\n+  public void initValueShouldInitZero()\n+  {\n+    target.initValue(buf, POSITION);\n+    Assert.assertEquals(0, buf.getDouble(POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void getAtPositionIsNullShouldReturnNull()\n+  {\n+    Assert.assertNull(target.get(buf, NULL_POSITION));\n+  }\n+\n+  @Test\n+  public void getAtPositionShouldReturnValue()\n+  {\n+    buf.putDouble(POSITION + 1, VALUES[3]);\n+    Assert.assertEquals(VALUES[3], (double) target.get(buf, POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void putValueShouldAddToBuffer()\n+  {\n+    Assert.assertTrue(target.putAnyValueFromRow(buf, POSITION, 2, 3));\n+    Assert.assertEquals(VALUES[2], buf.getDouble(POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void putValueStartAfterEndShouldNotAddToBuffer()\n+  {\n+    Assert.assertFalse(target.putAnyValueFromRow(buf, POSITION, 2, 2));\n+    Assert.assertNotEquals(VALUES[2], buf.getDouble(POSITION));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9e56f04ce7db06e0fa38b3e761072fb95289a23"}, "originalPosition": 95}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0Mjk2OTY2", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-484296966", "createdAt": "2020-09-08T16:14:37Z", "commit": {"oid": "d9e56f04ce7db06e0fa38b3e761072fb95289a23"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d5b70786c184e356d2a08d02fc3b1fbb6bd8c98a", "author": {"user": {"login": "suneet-s", "name": "Suneet Saldanha"}}, "url": "https://github.com/apache/druid/commit/d5b70786c184e356d2a08d02fc3b1fbb6bd8c98a", "committedDate": "2020-09-09T17:51:07Z", "message": "Merge remote-tracking branch 'upstream/master' into vectorization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d08da9c52d05472a916365cae38c2d496e816d1", "author": {"user": {"login": "suneet-s", "name": "Suneet Saldanha"}}, "url": "https://github.com/apache/druid/commit/6d08da9c52d05472a916365cae38c2d496e816d1", "committedDate": "2020-09-12T00:50:26Z", "message": "Merge remote-tracking branch 'upstream/master' into vectorization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0855b4a1c877b5280528c6e3ffcff28901110418", "author": {"user": {"login": "suneet-s", "name": "Suneet Saldanha"}}, "url": "https://github.com/apache/druid/commit/0855b4a1c877b5280528c6e3ffcff28901110418", "committedDate": "2020-09-12T02:13:49Z", "message": "use NilVectorSelector when needed"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MjE4NzUy", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-487218752", "createdAt": "2020-09-12T09:44:27Z", "commit": {"oid": "0855b4a1c877b5280528c6e3ffcff28901110418"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18b09faff4151969a86045770e5c1ee455f05e95", "author": {"user": {"login": "suneet-s", "name": "Suneet Saldanha"}}, "url": "https://github.com/apache/druid/commit/18b09faff4151969a86045770e5c1ee455f05e95", "committedDate": "2020-09-13T03:17:11Z", "message": "fix spellcheck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8832808a07015619ef5369adc82a20062643105b", "author": {"user": {"login": "suneet-s", "name": "Suneet Saldanha"}}, "url": "https://github.com/apache/druid/commit/8832808a07015619ef5369adc82a20062643105b", "committedDate": "2020-09-13T03:47:36Z", "message": "dont instantiate vectors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MTk1ODY5", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-488195869", "createdAt": "2020-09-14T22:22:07Z", "commit": {"oid": "8832808a07015619ef5369adc82a20062643105b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjoyMjowN1rOHRpJjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjoyMjowN1rOHRpJjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI2MjAzMA==", "bodyText": "nit: can extend NoopVectorAggregator to reduce boilerplate. I also don't think you need separate classes for each type, since the number is an object anyway, can just instantiate each singleton using NullHandling.defaultLongValue() etc.", "url": "https://github.com/apache/druid/pull/10338#discussion_r488262030", "createdAt": "2020-09-14T22:22:07Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericNilVectorAggregator.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * A vector aggregator that returns the default numeric value.\n+ */\n+public abstract class NumericNilVectorAggregator implements VectorAggregator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8832808a07015619ef5369adc82a20062643105b"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a781ec7c82de61f5f66f7c24b505ce189d61dc13", "author": {"user": {"login": "suneet-s", "name": "Suneet Saldanha"}}, "url": "https://github.com/apache/druid/commit/a781ec7c82de61f5f66f7c24b505ce189d61dc13", "committedDate": "2020-09-14T22:31:56Z", "message": "Merge remote-tracking branch 'upstream/master' into vectorization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0458395212d148303eaadf9f7d0ede3ec3314d3", "author": {"user": {"login": "suneet-s", "name": "Suneet Saldanha"}}, "url": "https://github.com/apache/druid/commit/a0458395212d148303eaadf9f7d0ede3ec3314d3", "committedDate": "2020-09-14T22:55:08Z", "message": "cleanup"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg4MjgyMzU0", "url": "https://github.com/apache/druid/pull/10338#pullrequestreview-488282354", "createdAt": "2020-09-15T02:38:52Z", "commit": {"oid": "a0458395212d148303eaadf9f7d0ede3ec3314d3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3529, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}