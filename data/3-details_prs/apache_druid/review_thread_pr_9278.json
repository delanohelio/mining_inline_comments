{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4MzE0ODkx", "number": 9278, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwNDowODowM1rODbck9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMDowNTo0MlrODc0XVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMTA2MzU2OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwNDowODowM1rOFi8D8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwNDowODowM1rOFi8D8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE3OTk1Mg==", "bodyText": "This is only safe when the selector has a 'real' dictionary, i.e. when selector.getValueCardinality() does not return DimensionSelector.CARDINALITY_UNKNOWN. If it is unknown then the ids are not valid outside the context of a specific row. So, in that case you'll need to fall back to the slower code.", "url": "https://github.com/apache/druid/pull/9278#discussion_r372179952", "createdAt": "2020-01-29T04:08:03Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -262,8 +288,9 @@ public ValueType defaultType()\n         final IndexedInts row = selector.getRow();\n \n         if (row.size() == 1) {\n-          final String key = selector.lookupName(row.get(0));\n-          return index.find(key).iterator();\n+          int dimensionId = row.get(0);\n+          //noinspection ConstantConditions (cache cannot return nulls since nulls are never stored in cache)\n+          return dimensionCaches.get(selector).get(dimensionId).iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2287bed236973da368c636e8b54c349b3eb89aba"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMTA2NTE3OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwNDowOTozOVrOFi8E7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMDowMDo1MFrOFjVwvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE4MDIwNg==", "bodyText": "For each selector, dimensionIds are contiguous and go from 0 (inclusive) to selector.getValueCardinality() (exclusive). If the cardinality is less than CACHE_MAX_SIZE then you could use an IntList[] as a cache. It should be faster.", "url": "https://github.com/apache/druid/pull/9278#discussion_r372180206", "createdAt": "2020-01-29T04:09:39Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -240,13 +243,36 @@ private void advanceCurrentRow()\n    */\n   private static class ConditionMatcherFactory implements ColumnProcessorFactory<Supplier<IntIterator>>\n   {\n+    private static final int MAX_NUM_CACHE = 10;\n+    private static final int CACHE_MAX_SIZE = 1000;\n+\n     private final ValueType keyType;\n     private final IndexedTable.Index index;\n \n+    // DimensionSelector -> (int) dimension id -> (IntList) row numbers\n+    private final LoadingCache<DimensionSelector, LoadingCache<Integer, IntList>> dimensionCaches;\n+\n     ConditionMatcherFactory(ValueType keyType, IndexedTable.Index index)\n     {\n       this.keyType = keyType;\n       this.index = index;\n+\n+      this.dimensionCaches =\n+          Caffeine.newBuilder()\n+                  .maximumSize(MAX_NUM_CACHE)\n+                  .build(\n+                      selector ->\n+                          Caffeine.newBuilder()\n+                                  .maximumSize(CACHE_MAX_SIZE)\n+                                  .build(dimensionId -> getRowNumbers(selector, dimensionId))\n+                  );\n+\n+    }\n+\n+    private IntList getRowNumbers(DimensionSelector selector, int dimensionId)\n+    {\n+      final String key = selector.lookupName(dimensionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2287bed236973da368c636e8b54c349b3eb89aba"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYwMTAyMw==", "bodyText": "(Assuming the dictionary is real, i.e., selector.getValueCardinality() != DimensionSelector.CARDINALITY_UNKNOWN)", "url": "https://github.com/apache/druid/pull/9278#discussion_r372601023", "createdAt": "2020-01-29T20:00:50Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -240,13 +243,36 @@ private void advanceCurrentRow()\n    */\n   private static class ConditionMatcherFactory implements ColumnProcessorFactory<Supplier<IntIterator>>\n   {\n+    private static final int MAX_NUM_CACHE = 10;\n+    private static final int CACHE_MAX_SIZE = 1000;\n+\n     private final ValueType keyType;\n     private final IndexedTable.Index index;\n \n+    // DimensionSelector -> (int) dimension id -> (IntList) row numbers\n+    private final LoadingCache<DimensionSelector, LoadingCache<Integer, IntList>> dimensionCaches;\n+\n     ConditionMatcherFactory(ValueType keyType, IndexedTable.Index index)\n     {\n       this.keyType = keyType;\n       this.index = index;\n+\n+      this.dimensionCaches =\n+          Caffeine.newBuilder()\n+                  .maximumSize(MAX_NUM_CACHE)\n+                  .build(\n+                      selector ->\n+                          Caffeine.newBuilder()\n+                                  .maximumSize(CACHE_MAX_SIZE)\n+                                  .build(dimensionId -> getRowNumbers(selector, dimensionId))\n+                  );\n+\n+    }\n+\n+    private IntList getRowNumbers(DimensionSelector selector, int dimensionId)\n+    {\n+      final String key = selector.lookupName(dimensionId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE4MDIwNg=="}, "originalCommit": {"oid": "2287bed236973da368c636e8b54c349b3eb89aba"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMTA2NjUwOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwNDoxMTowM1rOFi8FwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQwMjoyMDoxNlrOFkb9YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE4MDQxNw==", "bodyText": "How does this compare to the LruEvalCache in SingleStringInputCachingExpressionColumnValueSelector? I think they're trying to solve the same problem, so whichever approach works better, both that class and this one should use the best approach.", "url": "https://github.com/apache/druid/pull/9278#discussion_r372180417", "createdAt": "2020-01-29T04:11:03Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -240,13 +243,36 @@ private void advanceCurrentRow()\n    */\n   private static class ConditionMatcherFactory implements ColumnProcessorFactory<Supplier<IntIterator>>\n   {\n+    private static final int MAX_NUM_CACHE = 10;\n+    private static final int CACHE_MAX_SIZE = 1000;\n+\n     private final ValueType keyType;\n     private final IndexedTable.Index index;\n \n+    // DimensionSelector -> (int) dimension id -> (IntList) row numbers\n+    private final LoadingCache<DimensionSelector, LoadingCache<Integer, IntList>> dimensionCaches;\n+\n     ConditionMatcherFactory(ValueType keyType, IndexedTable.Index index)\n     {\n       this.keyType = keyType;\n       this.index = index;\n+\n+      this.dimensionCaches =\n+          Caffeine.newBuilder()\n+                  .maximumSize(MAX_NUM_CACHE)\n+                  .build(\n+                      selector ->\n+                          Caffeine.newBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2287bed236973da368c636e8b54c349b3eb89aba"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzc1MTEzNg==", "bodyText": "On JoinAndLookupBenchmark.joinIndexedTableStringKey, using the LruEvalCache approach is about 10% faster than using Caffeine.", "url": "https://github.com/apache/druid/pull/9278#discussion_r373751136", "createdAt": "2020-02-01T02:20:16Z", "author": {"login": "ccaominh"}, "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -240,13 +243,36 @@ private void advanceCurrentRow()\n    */\n   private static class ConditionMatcherFactory implements ColumnProcessorFactory<Supplier<IntIterator>>\n   {\n+    private static final int MAX_NUM_CACHE = 10;\n+    private static final int CACHE_MAX_SIZE = 1000;\n+\n     private final ValueType keyType;\n     private final IndexedTable.Index index;\n \n+    // DimensionSelector -> (int) dimension id -> (IntList) row numbers\n+    private final LoadingCache<DimensionSelector, LoadingCache<Integer, IntList>> dimensionCaches;\n+\n     ConditionMatcherFactory(ValueType keyType, IndexedTable.Index index)\n     {\n       this.keyType = keyType;\n       this.index = index;\n+\n+      this.dimensionCaches =\n+          Caffeine.newBuilder()\n+                  .maximumSize(MAX_NUM_CACHE)\n+                  .build(\n+                      selector ->\n+                          Caffeine.newBuilder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE4MDQxNw=="}, "originalCommit": {"oid": "2287bed236973da368c636e8b54c349b3eb89aba"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTQzODgyOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMDowMTozNFrOFlEKYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMDowMTozNFrOFlEKYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQwOTgyNg==", "bodyText": "This won't change from row to row, so it's likely going to be better to check it outside hot code (i.e. return a different Supplier<IntIterator> based on the result of calling selector.getValueCardinality()).", "url": "https://github.com/apache/druid/pull/9278#discussion_r374409826", "createdAt": "2020-02-04T00:01:34Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -263,8 +299,17 @@ public ValueType defaultType()\n         final IndexedInts row = selector.getRow();\n \n         if (row.size() == 1) {\n-          final String key = selector.lookupName(row.get(0));\n-          return index.find(key).iterator();\n+          int dimensionId = row.get(0);\n+          final IntList rowNumbers;\n+          if (selector.getValueCardinality() == DimensionDictionarySelector.CARDINALITY_UNKNOWN) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb951d204fb01fa416f0644f696463f32cc8263e"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTQ0NjYyOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMDowNTo0MlrOFlEPBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMDowNTo0MlrOFlEPBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQxMTAxMw==", "bodyText": "I thought Java guaranteed that object arrays will start with all nulls.", "url": "https://github.com/apache/druid/pull/9278#discussion_r374411013", "createdAt": "2020-02-04T00:05:42Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -308,4 +353,112 @@ public ValueType defaultType()\n       return () -> IntIterators.EMPTY_ITERATOR;\n     }\n   }\n+\n+  @VisibleForTesting\n+  static class LruLoadingHashMap<K, V> extends LinkedHashMap<K, V>\n+  {\n+    private final int maxSize;\n+    private final Function<K, V> loader;\n+\n+    LruLoadingHashMap(int maxSize, Function<K, V> loader)\n+    {\n+      super(capacity(maxSize));\n+      this.maxSize = maxSize;\n+      this.loader = loader;\n+    }\n+\n+    V getAndLoadIfAbsent(K key)\n+    {\n+      return computeIfAbsent(key, loader);\n+    }\n+\n+    @Override\n+    protected boolean removeEldestEntry(Map.Entry eldest)\n+    {\n+      return size() > maxSize;\n+    }\n+\n+    private static int capacity(int expectedSize)\n+    {\n+      // This is the calculation used in JDK8 to resize when a putAll happens; it seems to be the most conservative\n+      // calculation we can make. 0.75 is the default load factor.\n+      return (int) ((float) expectedSize / 0.75F + 1.0F);\n+    }\n+  }\n+\n+  private interface Int2IntListMap\n+  {\n+    IntList getAndLoadIfAbsent(int key);\n+  }\n+\n+  /**\n+   * Lookup table for keys in the range from 0 to maxSize - 1\n+   */\n+  @VisibleForTesting\n+  static class Int2IntListLookupTable implements Int2IntListMap\n+  {\n+    private final IntList[] lookup;\n+    private final IntFunction<IntList> loader;\n+\n+    Int2IntListLookupTable(int maxSize, IntFunction<IntList> loader)\n+    {\n+      this.loader = loader;\n+      this.lookup = new IntList[maxSize];\n+      Arrays.fill(lookup, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb951d204fb01fa416f0644f696463f32cc8263e"}, "originalPosition": 155}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2833, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}