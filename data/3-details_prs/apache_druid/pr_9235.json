{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1NDU5NjEx", "number": 9235, "title": "Add join-related DataSource types, and analysis functionality.", "bodyText": "Builds on #9111 and implements the datasource analysis mentioned in #8728. Still can't\nhandle join datasources, but we're a step closer.\nJoin-related DataSource types:\n\nAdd \"join\", \"lookup\", and \"inline\" datasources.\nAdd \"getChildren\" and \"withChildren\" methods to DataSource, which will be used\nin the future for query rewriting (e.g. inlining of subqueries).\n\nDataSource analysis functionality:\n\nAdd DataSourceAnalysis class, which breaks down datasources into three components:\nouter queries, a base datasource (left-most of the highest level left-leaning join\ntree), and other joined-in leaf datasources (the right-hand branches of the\nleft-leaning join tree).\nAdd \"isConcrete\", \"isGlobal\", and \"isCacheable\" methods to DataSource in order to\nsupport analysis.\n\nOther notes:\n\nRenamed DataSource#getNames to DataSource#getTableNames, which I think is clearer.\nAlso, made it a Set, so implementations don't need to worry about duplicates.\nThe addition of \"isCacheable\" should work around #8713, since UnionDataSource now\nreturns false for cacheability.", "createdAt": "2020-01-21T18:59:29Z", "url": "https://github.com/apache/druid/pull/9235", "merged": true, "mergeCommit": {"oid": "d886463253e1f537e32b8aedac60c8ee741f6cc7"}, "closed": true, "closedAt": "2020-01-22T22:54:48Z", "author": {"login": "gianm"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb8l4EhgH2gAyMzY1NDU5NjExOjJjZGE1YzZlMWZiMzgxZTAzYzdlOGEyNzQ3NWNjMDdkMjQ0OGVjZjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb891OmAFqTM0Njk2MDc5MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2cda5c6e1fb381e03c7e8a27475cc07d2448ecf8", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/2cda5c6e1fb381e03c7e8a27475cc07d2448ecf8", "committedDate": "2020-01-21T18:58:07Z", "message": "Add join-related DataSource types, and analysis functionality.\n\nBuilds on #9111 and implements the datasource analysis mentioned in #8728. Still can't\nhandle join datasources, but we're a step closer.\n\nJoin-related DataSource types:\n\n1) Add \"join\", \"lookup\", and \"inline\" datasources.\n2) Add \"getChildren\" and \"withChildren\" methods to DataSource, which will be used\n   in the future for query rewriting (e.g. inlining of subqueries).\n\nDataSource analysis functionality:\n\n1) Add DataSourceAnalysis class, which breaks down datasources into three components:\n   outer queries, a base datasource (left-most of the highest level left-leaning join\n   tree), and other joined-in leaf datasources (the right-hand branches of the\n   left-leaning join tree).\n2) Add \"isConcrete\", \"isGlobal\", and \"isCacheable\" methods to DataSource in order to\n   support analysis.\n\nOther notes:\n\n1) Renamed DataSource#getNames to DataSource#getTableNames, which I think is clearer.\n   Also, made it a Set, so implementations don't need to worry about duplicates.\n2) The addition of \"isCacheable\" should work around #8713, since UnionDataSource now\n   returns false for cacheability."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/0ffda6a2c80480d5cfe83e7528bfda6629806dd1", "committedDate": "2020-01-21T21:09:15Z", "message": "Remove javadoc comment."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MjUwNTc1", "url": "https://github.com/apache/druid/pull/9235#pullrequestreview-346250575", "createdAt": "2020-01-21T22:58:54Z", "commit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMjo1ODo1NVrOFgLoww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwMTowNTowOFrOFgN0XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI4OTQxMQ==", "bodyText": "Similar comment to the one I left in CacheUtil.", "url": "https://github.com/apache/druid/pull/9235#discussion_r369289411", "createdAt": "2020-01-21T22:58:55Z", "author": {"login": "ccaominh"}, "path": "server/src/main/java/org/apache/druid/client/ResultLevelCacheUtil.java", "diffHunk": "@@ -73,7 +73,8 @@ public static void populate(\n     return QueryContexts.isUseResultLevelCache(query)\n            && strategy != null\n            && cacheConfig.isUseResultLevelCache()\n-           && cacheConfig.isQueryCacheable(query);\n+           && cacheConfig.isQueryCacheable(query)\n+           && query.getDataSource().isCacheable();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI5MDY5OA==", "bodyText": "Perhaps extract these four lines should be a helper method since it's duplicated in populateResultLevelCache().\nIs there a test that is affected by the addition of isCacheable() or should one be added?", "url": "https://github.com/apache/druid/pull/9235#discussion_r369290698", "createdAt": "2020-01-21T23:02:27Z", "author": {"login": "ccaominh"}, "path": "server/src/main/java/org/apache/druid/client/CacheUtil.java", "diffHunk": "@@ -99,7 +99,8 @@\n     return QueryContexts.isUseCache(query)\n            && strategy != null\n            && cacheConfig.isUseCache()\n-           && cacheConfig.isQueryCacheable(query);\n+           && cacheConfig.isQueryCacheable(query)\n+           && query.getDataSource().isCacheable();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI5MzE0Ng==", "bodyText": "Should this be private to match the javadoc?", "url": "https://github.com/apache/druid/pull/9235#discussion_r369293146", "createdAt": "2020-01-21T23:09:53Z", "author": {"login": "ccaominh"}, "path": "processing/src/main/java/org/apache/druid/query/InlineDataSource.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.segment.RowAdapter;\n+import org.apache.druid.segment.column.ColumnHolder;\n+import org.apache.druid.segment.column.ValueType;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.ToLongFunction;\n+\n+/**\n+ * Represents an inline datasource, where the rows are embedded within the DataSource object itself.\n+ *\n+ * The rows are backed by an Iterable, which can be lazy or not. Lazy datasources will only be iterated if someone calls\n+ * {@link #getRows()} and iterates the result, or until someone calls {@link #getRowsAsList()}.\n+ */\n+public class InlineDataSource implements DataSource\n+{\n+  private final List<String> columnNames;\n+  private final List<ValueType> columnTypes;\n+  private final Iterable<Object[]> rows;\n+\n+  private InlineDataSource(\n+      final List<String> columnNames,\n+      final List<ValueType> columnTypes,\n+      final Iterable<Object[]> rows\n+  )\n+  {\n+    this.columnNames = Preconditions.checkNotNull(columnNames, \"'columnNames' must be nonnull\");\n+    this.columnTypes = Preconditions.checkNotNull(columnTypes, \"'columnTypes' must be nonnull\");\n+    this.rows = Preconditions.checkNotNull(rows, \"'rows' must be nonnull\");\n+\n+    if (columnNames.size() != columnTypes.size()) {\n+      throw new IAE(\"columnNames and columnTypes must be the same length\");\n+    }\n+  }\n+\n+  /**\n+   * Factory method for Jackson. Used for inline datasources that were originally encoded as JSON. Private because\n+   * non-Jackson callers should use {@link #fromIterable}.\n+   */\n+  @JsonCreator\n+  public static InlineDataSource fromJson(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMwMDEyNQ==", "bodyText": "Typo: stringificatione -> stringification\nIs it worth adding a test to enforce this?", "url": "https://github.com/apache/druid/pull/9235#discussion_r369300125", "createdAt": "2020-01-21T23:31:41Z", "author": {"login": "ccaominh"}, "path": "processing/src/main/java/org/apache/druid/query/InlineDataSource.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.segment.RowAdapter;\n+import org.apache.druid.segment.column.ColumnHolder;\n+import org.apache.druid.segment.column.ValueType;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.ToLongFunction;\n+\n+/**\n+ * Represents an inline datasource, where the rows are embedded within the DataSource object itself.\n+ *\n+ * The rows are backed by an Iterable, which can be lazy or not. Lazy datasources will only be iterated if someone calls\n+ * {@link #getRows()} and iterates the result, or until someone calls {@link #getRowsAsList()}.\n+ */\n+public class InlineDataSource implements DataSource\n+{\n+  private final List<String> columnNames;\n+  private final List<ValueType> columnTypes;\n+  private final Iterable<Object[]> rows;\n+\n+  private InlineDataSource(\n+      final List<String> columnNames,\n+      final List<ValueType> columnTypes,\n+      final Iterable<Object[]> rows\n+  )\n+  {\n+    this.columnNames = Preconditions.checkNotNull(columnNames, \"'columnNames' must be nonnull\");\n+    this.columnTypes = Preconditions.checkNotNull(columnTypes, \"'columnTypes' must be nonnull\");\n+    this.rows = Preconditions.checkNotNull(rows, \"'rows' must be nonnull\");\n+\n+    if (columnNames.size() != columnTypes.size()) {\n+      throw new IAE(\"columnNames and columnTypes must be the same length\");\n+    }\n+  }\n+\n+  /**\n+   * Factory method for Jackson. Used for inline datasources that were originally encoded as JSON. Private because\n+   * non-Jackson callers should use {@link #fromIterable}.\n+   */\n+  @JsonCreator\n+  public static InlineDataSource fromJson(\n+      @JsonProperty(\"columnNames\") List<String> columnNames,\n+      @JsonProperty(\"columnTypes\") List<ValueType> columnTypes,\n+      @JsonProperty(\"rows\") List<Object[]> rows\n+  )\n+  {\n+    return new InlineDataSource(columnNames, columnTypes, rows);\n+  }\n+\n+  /**\n+   * Creates an inline datasource from an Iterable. The Iterable will not be iterated until someone calls\n+   * {@link #getRows()} and iterates the result, or until someone calls {@link #getRowsAsList()}.\n+   *\n+   * @param columnNames names of each column in the rows\n+   * @param columnTypes types of each column in the rows\n+   * @param rows        rows, each of the same length as columnNames and columnTypes\n+   */\n+  public static InlineDataSource fromIterable(\n+      final List<String> columnNames,\n+      final List<ValueType> columnTypes,\n+      final Iterable<Object[]> rows\n+  )\n+  {\n+    return new InlineDataSource(columnNames, columnTypes, rows);\n+  }\n+\n+  @Override\n+  public Set<String> getTableNames()\n+  {\n+    return Collections.emptySet();\n+  }\n+\n+  @JsonProperty\n+  public List<String> getColumnNames()\n+  {\n+    return columnNames;\n+  }\n+\n+  @JsonProperty\n+  public List<ValueType> getColumnTypes()\n+  {\n+    return columnTypes;\n+  }\n+\n+  /**\n+   * Returns rows as a list. If the original Iterable behind this datasource was a List, this method will return it\n+   * as-is, without copying it. Otherwise, this method will walk the iterable and copy it into a List before returning.\n+   */\n+  @JsonProperty(\"rows\")\n+  public List<Object[]> getRowsAsList()\n+  {\n+    return rows instanceof List ? ((List<Object[]>) rows) : Lists.newArrayList(rows);\n+  }\n+\n+  /**\n+   * Returns rows as an Iterable.\n+   */\n+  @JsonIgnore\n+  public Iterable<Object[]> getRows()\n+  {\n+    return rows;\n+  }\n+\n+  @Override\n+  public List<DataSource> getChildren()\n+  {\n+    return Collections.emptyList();\n+  }\n+\n+  @Override\n+  public DataSource withChildren(List<DataSource> children)\n+  {\n+    if (!children.isEmpty()) {\n+      throw new IAE(\"Cannot accept children\");\n+    }\n+\n+    return this;\n+  }\n+\n+  @Override\n+  public boolean isCacheable()\n+  {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean isGlobal()\n+  {\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean isConcrete()\n+  {\n+    return false;\n+  }\n+\n+  public Map<String, ValueType> getRowSignature()\n+  {\n+    final ImmutableMap.Builder<String, ValueType> retVal = ImmutableMap.builder();\n+\n+    for (int i = 0; i < columnNames.size(); i++) {\n+      retVal.put(columnNames.get(i), columnTypes.get(i));\n+    }\n+\n+    return retVal.build();\n+  }\n+\n+  public RowAdapter<Object[]> rowAdapter()\n+  {\n+    return new RowAdapter<Object[]>()\n+    {\n+      @Override\n+      public ToLongFunction<Object[]> timestampFunction()\n+      {\n+        final int columnNumber = columnNames.indexOf(ColumnHolder.TIME_COLUMN_NAME);\n+\n+        if (columnNumber >= 0) {\n+          return row -> (long) row[columnNumber];\n+        } else {\n+          return row -> 0L;\n+        }\n+      }\n+\n+      @Override\n+      public Function<Object[], Object> columnFunction(String columnName)\n+      {\n+        final int columnNumber = columnNames.indexOf(columnName);\n+\n+        if (columnNumber >= 0) {\n+          return row -> row[columnNumber];\n+        } else {\n+          return row -> null;\n+        }\n+      }\n+    };\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    InlineDataSource that = (InlineDataSource) o;\n+    return Objects.equals(columnNames, that.columnNames) &&\n+           Objects.equals(columnTypes, that.columnTypes) &&\n+           Objects.equals(rows, that.rows);\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(columnNames, columnTypes, rows);\n+  }\n+\n+  @Override\n+  public String toString()\n+  {\n+    // Don't include 'rows' in stringificatione, because it might be long and/or lazy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMxMzk2Mw==", "bodyText": "Do you want to add unit tests for these methods?", "url": "https://github.com/apache/druid/pull/9235#discussion_r369313963", "createdAt": "2020-01-22T00:20:25Z", "author": {"login": "ccaominh"}, "path": "processing/src/main/java/org/apache/druid/segment/join/Joinables.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.join;\n+\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Utility methods for working with {@link Joinable} related classes.\n+ */\n+public class Joinables", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMxNzI4Ng==", "bodyText": "Nice javadoc!", "url": "https://github.com/apache/druid/pull/9235#discussion_r369317286", "createdAt": "2020-01-22T00:33:16Z", "author": {"login": "ccaominh"}, "path": "processing/src/main/java/org/apache/druid/query/planning/DataSourceAnalysis.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.planning;\n+\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.java.util.common.Pair;\n+import org.apache.druid.query.BaseQuery;\n+import org.apache.druid.query.DataSource;\n+import org.apache.druid.query.JoinDataSource;\n+import org.apache.druid.query.Query;\n+import org.apache.druid.query.QueryDataSource;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.query.UnionDataSource;\n+import org.apache.druid.query.spec.QuerySegmentSpec;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+/**\n+ * Analysis of a datasource for purposes of deciding how to execute a particular query.\n+ *\n+ * The analysis breaks a datasource down in the following way:\n+ *\n+ * <pre>\n+ *\n+ *                             Q  <-- Possible outer query datasource(s) [may be multiple stacked]\n+ *                             |\n+ *                             J  <-- Possible join tree, expected to be left-leaning\n+ *                            / \\\n+ *                           J  Dj <--  Other leaf datasources\n+ *   Base datasource        / \\         which will be joined\n+ *  (bottom-leftmost) -->  Db Dj  <---- into the base datasource\n+ *\n+ * </pre>\n+ *\n+ * The base datasource (Db) is returned by {@link #getBaseDataSource()}. The other leaf datasources are returned by\n+ * {@link #getPreJoinableClauses()}. The outer query datasources are available as part of {@link #getDataSource()},\n+ * which just returns the original datasource that was provided for analysis.\n+ *\n+ * The base datasource (Db) will never be a join, but it can be any other type of datasource (table, query, etc).\n+ * Note that join trees are only flattened if they occur at the top of the overall tree (or underneath an outer query),\n+ * and that join trees are only flattened to the degree that they are left-leaning. Due to these facts, it is possible\n+ * for the base or leaf datasources to include additional joins.\n+ *\n+ * The base datasource is the one that will be considered by the core Druid query stack for scanning via\n+ * {@link org.apache.druid.segment.Segment} and {@link org.apache.druid.segment.StorageAdapter}. The other leaf\n+ * datasources must be joinable onto the base data.\n+ *\n+ * The idea here is to keep things simple and dumb. So we focus only on identifying left-leaning join trees, which map\n+ * neatly onto a series of hash table lookups at query time. The user/system generating the queries, e.g. the druid-sql\n+ * layer (or the end user in the case of native queries), is responsible for containing the smarts to structure the\n+ * tree in a way that will lead to optimal execution.\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyMjAxNQ==", "bodyText": "Do you want to add an EqualsVerifier test?", "url": "https://github.com/apache/druid/pull/9235#discussion_r369322015", "createdAt": "2020-01-22T00:51:46Z", "author": {"login": "ccaominh"}, "path": "processing/src/test/java/org/apache/druid/query/planning/DataSourceAnalysisTest.java", "diffHunk": "@@ -0,0 +1,476 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.planning;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.druid.java.util.common.Intervals;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.granularity.Granularities;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.query.DataSource;\n+import org.apache.druid.query.InlineDataSource;\n+import org.apache.druid.query.JoinDataSource;\n+import org.apache.druid.query.LookupDataSource;\n+import org.apache.druid.query.QueryDataSource;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.query.UnionDataSource;\n+import org.apache.druid.query.groupby.GroupByQuery;\n+import org.apache.druid.query.spec.MultipleIntervalSegmentSpec;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.join.JoinConditionAnalysis;\n+import org.apache.druid.segment.join.JoinType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+public class DataSourceAnalysisTest\n+{\n+  private static final TableDataSource TABLE_FOO = new TableDataSource(\"foo\");\n+  private static final TableDataSource TABLE_BAR = new TableDataSource(\"bar\");\n+  private static final LookupDataSource LOOKUP_LOOKYLOO = new LookupDataSource(\"lookyloo\");\n+  private static final InlineDataSource INLINE = InlineDataSource.fromIterable(\n+      ImmutableList.of(\"column\"),\n+      ImmutableList.of(ValueType.STRING),\n+      ImmutableList.of(new Object[0])\n+  );\n+\n+  @Test\n+  public void testTable()\n+  {\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(TABLE_FOO);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(TABLE_FOO, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testUnion()\n+  {\n+    final UnionDataSource unionDataSource = new UnionDataSource(ImmutableList.of(TABLE_FOO, TABLE_BAR));\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(unionDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(unionDataSource, analysis.getDataSource());\n+    Assert.assertEquals(unionDataSource, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnTable()\n+  {\n+    final QueryDataSource queryDataSource = subquery(TABLE_FOO);\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnUnion()\n+  {\n+    final UnionDataSource unionDataSource = new UnionDataSource(ImmutableList.of(TABLE_FOO, TABLE_BAR));\n+    final QueryDataSource queryDataSource = subquery(unionDataSource);\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(unionDataSource, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testLookup()\n+  {\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(LOOKUP_LOOKYLOO);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnLookup()\n+  {\n+    final QueryDataSource queryDataSource = new QueryDataSource(\n+        GroupByQuery.builder()\n+                    .setDataSource(LOOKUP_LOOKYLOO)\n+                    .setInterval(new MultipleIntervalSegmentSpec(Collections.singletonList(Intervals.of(\"2000/3000\"))))\n+                    .setGranularity(Granularities.ALL)\n+                    .build()\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testInline()\n+  {\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(INLINE);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(INLINE, analysis.getDataSource());\n+    Assert.assertEquals(INLINE, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testJoinSimpleLeftLeaning()\n+  {\n+    // Join of a table onto a variety of simple joinable objects (lookup, inline, subquery) with a left-leaning\n+    // structure (no right children are joins themselves).\n+\n+    final JoinDataSource joinDataSource =\n+        join(\n+            join(\n+                join(\n+                    TABLE_FOO,\n+                    LOOKUP_LOOKYLOO,\n+                    \"1.\",\n+                    JoinType.INNER\n+                ),\n+                INLINE,\n+                \"2.\",\n+                JoinType.LEFT\n+            ),\n+            subquery(LOOKUP_LOOKYLOO),\n+            \"3.\",\n+            JoinType.FULL\n+        );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", LOOKUP_LOOKYLOO, JoinType.INNER, joinClause(\"1.\")),\n+            new PreJoinableClause(\"2.\", INLINE, JoinType.LEFT, joinClause(\"2.\")),\n+            new PreJoinableClause(\"3.\", subquery(LOOKUP_LOOKYLOO), JoinType.FULL, joinClause(\"3.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinSimpleRightLeaning()\n+  {\n+    // Join of a table onto a variety of simple joinable objects (lookup, inline, subquery) with a right-leaning\n+    // structure (no left children are joins themselves).\n+    //\n+    // Note that unlike the left-leaning stack, which is fully flattened, this one will not get flattened at all.\n+\n+    final JoinDataSource rightLeaningJoinStack =\n+        join(\n+            LOOKUP_LOOKYLOO,\n+            join(\n+                INLINE,\n+                subquery(LOOKUP_LOOKYLOO),\n+                \"1.\",\n+                JoinType.LEFT\n+            ),\n+            \"2.\",\n+            JoinType.FULL\n+        );\n+\n+    final JoinDataSource joinDataSource =\n+        join(\n+            TABLE_FOO,\n+            rightLeaningJoinStack,\n+            \"3.\",\n+            JoinType.RIGHT\n+        );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"3.\", rightLeaningJoinStack, JoinType.RIGHT, joinClause(\"3.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinOverTableSubquery()\n+  {\n+    final JoinDataSource joinDataSource = join(\n+        TABLE_FOO,\n+        subquery(TABLE_FOO),\n+        \"1.\",\n+        JoinType.INNER\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", subquery(TABLE_FOO), JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinTableUnionToLookup()\n+  {\n+    final UnionDataSource unionDataSource = new UnionDataSource(ImmutableList.of(TABLE_FOO, TABLE_BAR));\n+    final JoinDataSource joinDataSource = join(\n+        unionDataSource,\n+        LOOKUP_LOOKYLOO,\n+        \"1.\",\n+        JoinType.INNER\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(unionDataSource, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", LOOKUP_LOOKYLOO, JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinUnderTopLevelSubqueries()\n+  {\n+    final QueryDataSource queryDataSource =\n+        subquery(\n+            subquery(\n+                join(\n+                    TABLE_FOO,\n+                    LOOKUP_LOOKYLOO,\n+                    \"1.\",\n+                    JoinType.INNER\n+                )\n+            )\n+        );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", LOOKUP_LOOKYLOO, JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinLookupToLookup()\n+  {\n+    final JoinDataSource joinDataSource = join(\n+        LOOKUP_LOOKYLOO,\n+        LOOKUP_LOOKYLOO,\n+        \"1.\",\n+        JoinType.INNER\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", LOOKUP_LOOKYLOO, JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinLookupToTable()\n+  {\n+    final JoinDataSource joinDataSource = join(\n+        LOOKUP_LOOKYLOO,\n+        TABLE_FOO,\n+        \"1.\",\n+        JoinType.INNER\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", TABLE_FOO, JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "originalPosition": 427}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyMzI1MQ==", "bodyText": "Looks like you can use subquery(LOOKUP_LOOKYLOO) here instead?", "url": "https://github.com/apache/druid/pull/9235#discussion_r369323251", "createdAt": "2020-01-22T00:56:58Z", "author": {"login": "ccaominh"}, "path": "processing/src/test/java/org/apache/druid/query/planning/DataSourceAnalysisTest.java", "diffHunk": "@@ -0,0 +1,476 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.planning;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.druid.java.util.common.Intervals;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.granularity.Granularities;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.query.DataSource;\n+import org.apache.druid.query.InlineDataSource;\n+import org.apache.druid.query.JoinDataSource;\n+import org.apache.druid.query.LookupDataSource;\n+import org.apache.druid.query.QueryDataSource;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.query.UnionDataSource;\n+import org.apache.druid.query.groupby.GroupByQuery;\n+import org.apache.druid.query.spec.MultipleIntervalSegmentSpec;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.join.JoinConditionAnalysis;\n+import org.apache.druid.segment.join.JoinType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+public class DataSourceAnalysisTest\n+{\n+  private static final TableDataSource TABLE_FOO = new TableDataSource(\"foo\");\n+  private static final TableDataSource TABLE_BAR = new TableDataSource(\"bar\");\n+  private static final LookupDataSource LOOKUP_LOOKYLOO = new LookupDataSource(\"lookyloo\");\n+  private static final InlineDataSource INLINE = InlineDataSource.fromIterable(\n+      ImmutableList.of(\"column\"),\n+      ImmutableList.of(ValueType.STRING),\n+      ImmutableList.of(new Object[0])\n+  );\n+\n+  @Test\n+  public void testTable()\n+  {\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(TABLE_FOO);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(TABLE_FOO, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testUnion()\n+  {\n+    final UnionDataSource unionDataSource = new UnionDataSource(ImmutableList.of(TABLE_FOO, TABLE_BAR));\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(unionDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(unionDataSource, analysis.getDataSource());\n+    Assert.assertEquals(unionDataSource, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnTable()\n+  {\n+    final QueryDataSource queryDataSource = subquery(TABLE_FOO);\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnUnion()\n+  {\n+    final UnionDataSource unionDataSource = new UnionDataSource(ImmutableList.of(TABLE_FOO, TABLE_BAR));\n+    final QueryDataSource queryDataSource = subquery(unionDataSource);\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(unionDataSource, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testLookup()\n+  {\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(LOOKUP_LOOKYLOO);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnLookup()\n+  {\n+    final QueryDataSource queryDataSource = new QueryDataSource(\n+        GroupByQuery.builder()\n+                    .setDataSource(LOOKUP_LOOKYLOO)\n+                    .setInterval(new MultipleIntervalSegmentSpec(Collections.singletonList(Intervals.of(\"2000/3000\"))))\n+                    .setGranularity(Granularities.ALL)\n+                    .build()\n+    );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMyNTE0OQ==", "bodyText": "Perhaps create a named constant for the interval since it's in the asserts for several of the new tests", "url": "https://github.com/apache/druid/pull/9235#discussion_r369325149", "createdAt": "2020-01-22T01:05:08Z", "author": {"login": "ccaominh"}, "path": "processing/src/test/java/org/apache/druid/query/planning/DataSourceAnalysisTest.java", "diffHunk": "@@ -0,0 +1,476 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.planning;\n+\n+import com.google.common.collect.ImmutableList;\n+import org.apache.druid.java.util.common.Intervals;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.granularity.Granularities;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.query.DataSource;\n+import org.apache.druid.query.InlineDataSource;\n+import org.apache.druid.query.JoinDataSource;\n+import org.apache.druid.query.LookupDataSource;\n+import org.apache.druid.query.QueryDataSource;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.query.UnionDataSource;\n+import org.apache.druid.query.groupby.GroupByQuery;\n+import org.apache.druid.query.spec.MultipleIntervalSegmentSpec;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.join.JoinConditionAnalysis;\n+import org.apache.druid.segment.join.JoinType;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+public class DataSourceAnalysisTest\n+{\n+  private static final TableDataSource TABLE_FOO = new TableDataSource(\"foo\");\n+  private static final TableDataSource TABLE_BAR = new TableDataSource(\"bar\");\n+  private static final LookupDataSource LOOKUP_LOOKYLOO = new LookupDataSource(\"lookyloo\");\n+  private static final InlineDataSource INLINE = InlineDataSource.fromIterable(\n+      ImmutableList.of(\"column\"),\n+      ImmutableList.of(ValueType.STRING),\n+      ImmutableList.of(new Object[0])\n+  );\n+\n+  @Test\n+  public void testTable()\n+  {\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(TABLE_FOO);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(TABLE_FOO, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testUnion()\n+  {\n+    final UnionDataSource unionDataSource = new UnionDataSource(ImmutableList.of(TABLE_FOO, TABLE_BAR));\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(unionDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(unionDataSource, analysis.getDataSource());\n+    Assert.assertEquals(unionDataSource, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnTable()\n+  {\n+    final QueryDataSource queryDataSource = subquery(TABLE_FOO);\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnUnion()\n+  {\n+    final UnionDataSource unionDataSource = new UnionDataSource(ImmutableList.of(TABLE_FOO, TABLE_BAR));\n+    final QueryDataSource queryDataSource = subquery(unionDataSource);\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(unionDataSource, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testLookup()\n+  {\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(LOOKUP_LOOKYLOO);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testQueryOnLookup()\n+  {\n+    final QueryDataSource queryDataSource = new QueryDataSource(\n+        GroupByQuery.builder()\n+                    .setDataSource(LOOKUP_LOOKYLOO)\n+                    .setInterval(new MultipleIntervalSegmentSpec(Collections.singletonList(Intervals.of(\"2000/3000\"))))\n+                    .setGranularity(Granularities.ALL)\n+                    .build()\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testInline()\n+  {\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(INLINE);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(INLINE, analysis.getDataSource());\n+    Assert.assertEquals(INLINE, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(Collections.emptyList(), analysis.getPreJoinableClauses());\n+  }\n+\n+  @Test\n+  public void testJoinSimpleLeftLeaning()\n+  {\n+    // Join of a table onto a variety of simple joinable objects (lookup, inline, subquery) with a left-leaning\n+    // structure (no right children are joins themselves).\n+\n+    final JoinDataSource joinDataSource =\n+        join(\n+            join(\n+                join(\n+                    TABLE_FOO,\n+                    LOOKUP_LOOKYLOO,\n+                    \"1.\",\n+                    JoinType.INNER\n+                ),\n+                INLINE,\n+                \"2.\",\n+                JoinType.LEFT\n+            ),\n+            subquery(LOOKUP_LOOKYLOO),\n+            \"3.\",\n+            JoinType.FULL\n+        );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", LOOKUP_LOOKYLOO, JoinType.INNER, joinClause(\"1.\")),\n+            new PreJoinableClause(\"2.\", INLINE, JoinType.LEFT, joinClause(\"2.\")),\n+            new PreJoinableClause(\"3.\", subquery(LOOKUP_LOOKYLOO), JoinType.FULL, joinClause(\"3.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinSimpleRightLeaning()\n+  {\n+    // Join of a table onto a variety of simple joinable objects (lookup, inline, subquery) with a right-leaning\n+    // structure (no left children are joins themselves).\n+    //\n+    // Note that unlike the left-leaning stack, which is fully flattened, this one will not get flattened at all.\n+\n+    final JoinDataSource rightLeaningJoinStack =\n+        join(\n+            LOOKUP_LOOKYLOO,\n+            join(\n+                INLINE,\n+                subquery(LOOKUP_LOOKYLOO),\n+                \"1.\",\n+                JoinType.LEFT\n+            ),\n+            \"2.\",\n+            JoinType.FULL\n+        );\n+\n+    final JoinDataSource joinDataSource =\n+        join(\n+            TABLE_FOO,\n+            rightLeaningJoinStack,\n+            \"3.\",\n+            JoinType.RIGHT\n+        );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"3.\", rightLeaningJoinStack, JoinType.RIGHT, joinClause(\"3.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinOverTableSubquery()\n+  {\n+    final JoinDataSource joinDataSource = join(\n+        TABLE_FOO,\n+        subquery(TABLE_FOO),\n+        \"1.\",\n+        JoinType.INNER\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", subquery(TABLE_FOO), JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinTableUnionToLookup()\n+  {\n+    final UnionDataSource unionDataSource = new UnionDataSource(ImmutableList.of(TABLE_FOO, TABLE_BAR));\n+    final JoinDataSource joinDataSource = join(\n+        unionDataSource,\n+        LOOKUP_LOOKYLOO,\n+        \"1.\",\n+        JoinType.INNER\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(unionDataSource, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", LOOKUP_LOOKYLOO, JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinUnderTopLevelSubqueries()\n+  {\n+    final QueryDataSource queryDataSource =\n+        subquery(\n+            subquery(\n+                join(\n+                    TABLE_FOO,\n+                    LOOKUP_LOOKYLOO,\n+                    \"1.\",\n+                    JoinType.INNER\n+                )\n+            )\n+        );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(queryDataSource);\n+\n+    Assert.assertTrue(analysis.isConcreteBased());\n+    Assert.assertTrue(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertTrue(analysis.isQuery());\n+    Assert.assertEquals(queryDataSource, analysis.getDataSource());\n+    Assert.assertEquals(TABLE_FOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.of(TABLE_FOO), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(\n+        Optional.of(new MultipleIntervalSegmentSpec(ImmutableList.of(Intervals.of(\"2000/3000\")))),\n+        analysis.getBaseQuerySegmentSpec()\n+    );\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", LOOKUP_LOOKYLOO, JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinLookupToLookup()\n+  {\n+    final JoinDataSource joinDataSource = join(\n+        LOOKUP_LOOKYLOO,\n+        LOOKUP_LOOKYLOO,\n+        \"1.\",\n+        JoinType.INNER\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertTrue(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", LOOKUP_LOOKYLOO, JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  @Test\n+  public void testJoinLookupToTable()\n+  {\n+    final JoinDataSource joinDataSource = join(\n+        LOOKUP_LOOKYLOO,\n+        TABLE_FOO,\n+        \"1.\",\n+        JoinType.INNER\n+    );\n+\n+    final DataSourceAnalysis analysis = DataSourceAnalysis.forDataSource(joinDataSource);\n+\n+    Assert.assertFalse(analysis.isConcreteBased());\n+    Assert.assertFalse(analysis.isConcreteTableBased());\n+    Assert.assertFalse(analysis.isGlobal());\n+    Assert.assertFalse(analysis.isQuery());\n+    Assert.assertEquals(joinDataSource, analysis.getDataSource());\n+    Assert.assertEquals(LOOKUP_LOOKYLOO, analysis.getBaseDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseTableDataSource());\n+    Assert.assertEquals(Optional.empty(), analysis.getBaseQuerySegmentSpec());\n+    Assert.assertEquals(\n+        ImmutableList.of(\n+            new PreJoinableClause(\"1.\", TABLE_FOO, JoinType.INNER, joinClause(\"1.\"))\n+        ),\n+        analysis.getPreJoinableClauses()\n+    );\n+  }\n+\n+  /**\n+   * Generate a datasource that joins on a column named \"x\" on both sides.\n+   */\n+  private static JoinDataSource join(\n+      final DataSource left,\n+      final DataSource right,\n+      final String rightPrefix,\n+      final JoinType joinType\n+  )\n+  {\n+    return JoinDataSource.create(\n+        left,\n+        right,\n+        rightPrefix,\n+        joinClause(rightPrefix).getOriginalExpression(),\n+        joinType,\n+        ExprMacroTable.nil()\n+    );\n+  }\n+\n+  /**\n+   * Generate a join clause that joins on a column named \"x\" on both sides.\n+   */\n+  private static JoinConditionAnalysis joinClause(\n+      final String rightPrefix\n+  )\n+  {\n+    return JoinConditionAnalysis.forExpression(\n+        StringUtils.format(\"x == \\\"%sx\\\"\", rightPrefix),\n+        rightPrefix,\n+        ExprMacroTable.nil()\n+    );\n+  }\n+\n+  /**\n+   * Generate a datasource that does a subquery on another datasource. The specific kind of query doesn't matter\n+   * much for the purpose of this test class, so it's always the same.\n+   */\n+  private static QueryDataSource subquery(final DataSource dataSource)\n+  {\n+    return new QueryDataSource(\n+        GroupByQuery.builder()\n+                    .setDataSource(dataSource)\n+                    .setInterval(new MultipleIntervalSegmentSpec(Collections.singletonList(Intervals.of(\"2000/3000\"))))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "originalPosition": 471}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2MjA3MjQ4", "url": "https://github.com/apache/druid/pull/9235#pullrequestreview-346207248", "createdAt": "2020-01-21T21:34:29Z", "commit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMTozNDoyOVrOFgJiFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMTo0NjowNFrOFgJ1fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1NDkzNQ==", "bodyText": "\ud83d\udc4d this seems like a good intermediary solution until we fix the issue for real", "url": "https://github.com/apache/druid/pull/9235#discussion_r369254935", "createdAt": "2020-01-21T21:34:29Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/UnionDataSource.java", "diffHunk": "@@ -52,6 +57,51 @@ public UnionDataSource(@JsonProperty(\"dataSources\") List<TableDataSource> dataSo\n     return dataSources;\n   }\n \n+  @Override\n+  public List<DataSource> getChildren()\n+  {\n+    return ImmutableList.copyOf(dataSources);\n+  }\n+\n+  @Override\n+  public DataSource withChildren(List<DataSource> children)\n+  {\n+    if (children.size() != dataSources.size()) {\n+      throw new IAE(\"Expected [%d] children, got [%d]\", dataSources.size(), children.size());\n+    }\n+\n+    if (!children.stream().allMatch(dataSource -> dataSource instanceof TableDataSource)) {\n+      throw new IAE(\"All children must be tables\");\n+    }\n+\n+    return new UnionDataSource(\n+        children.stream().map(dataSource -> (TableDataSource) dataSource).collect(Collectors.toList())\n+    );\n+  }\n+\n+  @Override\n+  public boolean isCacheable()\n+  {\n+    // Disables result-level caching for 'union' datasources, which doesn't work currently.\n+    // See https://github.com/apache/druid/issues/8713 for reference.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI1OTkwMw==", "bodyText": "\ud83e\udd18", "url": "https://github.com/apache/druid/pull/9235#discussion_r369259903", "createdAt": "2020-01-21T21:46:04Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/InlineDataSource.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Lists;\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.segment.RowAdapter;\n+import org.apache.druid.segment.column.ColumnHolder;\n+import org.apache.druid.segment.column.ValueType;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.ToLongFunction;\n+\n+/**\n+ * Represents an inline datasource, where the rows are embedded within the DataSource object itself.\n+ *\n+ * The rows are backed by an Iterable, which can be lazy or not. Lazy datasources will only be iterated if someone calls\n+ * {@link #getRows()} and iterates the result, or until someone calls {@link #getRowsAsList()}.\n+ */\n+public class InlineDataSource implements DataSource", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2Mzk1NzU3", "url": "https://github.com/apache/druid/pull/9235#pullrequestreview-346395757", "createdAt": "2020-01-22T07:54:25Z", "commit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNzo1NDoyNlrOFgTDEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwNzo1NDoyNlrOFgTDEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQxMDgzMg==", "bodyText": "curious about why this change. I know this isn't really part of your change, but I've also noticed equals and hashcode for a lot of classes that extend BaseQuery have their own implementation of equals and hashCode and do not check the base class. Sounds like we should add some equalsVerifier tests for them, maybe in another patch.", "url": "https://github.com/apache/druid/pull/9235#discussion_r369410832", "createdAt": "2020-01-22T07:54:26Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/BaseQuery.java", "diffHunk": "@@ -270,14 +270,13 @@ public boolean equals(Object o)\n            Objects.equals(dataSource, baseQuery.dataSource) &&\n            Objects.equals(context, baseQuery.context) &&\n            Objects.equals(querySegmentSpec, baseQuery.querySegmentSpec) &&\n-           Objects.equals(duration, baseQuery.duration) &&\n+           Objects.equals(getDuration(), baseQuery.getDuration()) &&\n            Objects.equals(granularity, baseQuery.granularity);\n   }\n \n   @Override\n   public int hashCode()\n   {\n-\n-    return Objects.hash(dataSource, descending, context, querySegmentSpec, duration, granularity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDAzNjIy", "url": "https://github.com/apache/druid/pull/9235#pullrequestreview-346403622", "createdAt": "2020-01-22T08:13:04Z", "commit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwODozMDo0MlrOFgT1hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwODo0MToyMlrOFgUGkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQyMzc0OA==", "bodyText": "why must these sizes match?", "url": "https://github.com/apache/druid/pull/9235#discussion_r369423748", "createdAt": "2020-01-22T08:30:42Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/UnionDataSource.java", "diffHunk": "@@ -52,6 +57,51 @@ public UnionDataSource(@JsonProperty(\"dataSources\") List<TableDataSource> dataSo\n     return dataSources;\n   }\n \n+  @Override\n+  public List<DataSource> getChildren()\n+  {\n+    return ImmutableList.copyOf(dataSources);\n+  }\n+\n+  @Override\n+  public DataSource withChildren(List<DataSource> children)\n+  {\n+    if (children.size() != dataSources.size()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQyODExNA==", "bodyText": "@NonNull annotations for the parameters?", "url": "https://github.com/apache/druid/pull/9235#discussion_r369428114", "createdAt": "2020-01-22T08:41:22Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/segment/join/Joinables.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.join;\n+\n+import org.apache.druid.java.util.common.IAE;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Utility methods for working with {@link Joinable} related classes.\n+ */\n+public class Joinables\n+{\n+  /**\n+   * Checks that \"prefix\" is a valid prefix for a join clause (see {@link JoinableClause#getPrefix()}) and, if so,\n+   * returns it. Otherwise, throws an exception.\n+   */\n+  public static String validatePrefix(@Nullable final String prefix)\n+  {\n+    if (prefix == null) {\n+      throw new IAE(\"Join clause cannot have null prefix\");\n+    } else if (isPrefixedBy(ColumnHolder.TIME_COLUMN_NAME, prefix) || ColumnHolder.TIME_COLUMN_NAME.equals(prefix)) {\n+      throw new IAE(\n+          \"Join clause cannot have prefix[%s], since it would shadow %s\",\n+          prefix,\n+          ColumnHolder.TIME_COLUMN_NAME\n+      );\n+    } else {\n+      return prefix;\n+    }\n+  }\n+\n+  public static boolean isPrefixedBy(final String columnName, final String prefix)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ffda6a2c80480d5cfe83e7528bfda6629806dd1"}, "originalPosition": 51}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "385bd754bf973a5ca4d432e093f40227c8259ecf", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/385bd754bf973a5ca4d432e093f40227c8259ecf", "committedDate": "2020-01-22T17:27:19Z", "message": "Updates reflecting code review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b81140fc9ab9894c78273dfaa5684da529aa583", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/2b81140fc9ab9894c78273dfaa5684da529aa583", "committedDate": "2020-01-22T17:29:48Z", "message": "Add comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f21089a95906b80017426b98bc59e9b72f1c278", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/2f21089a95906b80017426b98bc59e9b72f1c278", "committedDate": "2020-01-22T17:31:39Z", "message": "Add more comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2OTIxMDY4", "url": "https://github.com/apache/druid/pull/9235#pullrequestreview-346921068", "createdAt": "2020-01-22T21:38:13Z", "commit": {"oid": "2f21089a95906b80017426b98bc59e9b72f1c278"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMTozODoxM1rOFgr3nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQyMTozODoxM1rOFgr3nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTgxNzUwMQ==", "bodyText": "I tried adding rows to toString and it doesn't iterate over rowsIterable (it prints an identifier for the lambda).", "url": "https://github.com/apache/druid/pull/9235#discussion_r369817501", "createdAt": "2020-01-22T21:38:13Z", "author": {"login": "ccaominh"}, "path": "processing/src/test/java/org/apache/druid/query/InlineDataSourceTest.java", "diffHunk": "@@ -225,6 +225,14 @@ public void test_equals()\n                   .verify();\n   }\n \n+  @Test\n+  public void test_toString_iterable()\n+  {\n+    // Verify that toString does not iterate the rows.\n+    final String ignored = iterableDataSource.toString();\n+    Assert.assertEquals(0, iterationCounter.get());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f21089a95906b80017426b98bc59e9b72f1c278"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2OTI5Mzk2", "url": "https://github.com/apache/druid/pull/9235#pullrequestreview-346929396", "createdAt": "2020-01-22T21:52:40Z", "commit": {"oid": "2f21089a95906b80017426b98bc59e9b72f1c278"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2OTYwNzkx", "url": "https://github.com/apache/druid/pull/9235#pullrequestreview-346960791", "createdAt": "2020-01-22T22:52:44Z", "commit": {"oid": "2f21089a95906b80017426b98bc59e9b72f1c278"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3777, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}