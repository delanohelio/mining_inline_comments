{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4MzE0ODkx", "number": 9278, "title": "Speed up joins on indexed tables with string keys", "bodyText": "Description\nWhen joining on index tables with string keys, caching the computation of row id to row numbers improves performance on the JoinAndLookupBenchmark.joinIndexTableStringKey* benchmarks by about 10% if the column cache is enabled an by about 100% if the column cache is disabled.\nBefore\nBenchmark                            (columnCacheSizeBytes)   Score   Error  Units\njoinIndexedTableStringKey                                 0  41.899 \u00b1 0.688  ms/op\njoinIndexedTableStringKey                             16384  22.707 \u00b1 0.309  ms/op\njoinIndexedTableStringKeyWithFilter                       0  41.879 \u00b1 0.507  ms/op\njoinIndexedTableStringKeyWithFilter                   16384  22.314 \u00b1 0.114  ms/op\n\nAfter\nBenchmark                            (columnCacheSizeBytes)   Score   Error  Units\njoinIndexedTableStringKey                                 0  20.527 \u00b1 0.751  ms/op\njoinIndexedTableStringKey                             16384  20.804 \u00b1 0.206  ms/op\njoinIndexedTableStringKeyWithFilter                       0  21.374 \u00b1 0.299  ms/op\njoinIndexedTableStringKeyWithFilter                   16384  19.723 \u00b1 0.390  ms/op\n\n(See #9267 for the JoinAndLookupBenchmark implementation.)\n\nThis PR has:\n\n been self-reviewed.\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.", "createdAt": "2020-01-29T00:23:29Z", "url": "https://github.com/apache/druid/pull/9278", "merged": true, "mergeCommit": {"oid": "0d2b16c1d06a46c4d862f7637f55bfc1dd1c7f41"}, "closed": true, "closedAt": "2020-02-05T01:34:56Z", "author": {"login": "ccaominh"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb-6lBfAH2gAyMzY4MzE0ODkxOjIyODdiZWQyMzY5NzNkYTM2OGM2MzZlOGI1NGMzNDliM2ViODlhYmE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcBKJFngH2gAyMzY4MzE0ODkxOjE4ZTliZjVkMTRmYmFjZWJjNmQ1ZDRlMTJjNjY2N2EwMmZiMTE2MmI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "2287bed236973da368c636e8b54c349b3eb89aba", "author": {"user": {"login": "ccaominh", "name": "Chi Cao Minh"}}, "url": "https://github.com/apache/druid/commit/2287bed236973da368c636e8b54c349b3eb89aba", "committedDate": "2020-01-29T00:13:10Z", "message": "Speed up joins on indexed tables with string keys\n\nWhen joining on index tables with string keys, caching the computation\nof row id to row numbers improves performance on the\nJoinAndLookupBenchmark.joinIndexTableStringKey* benchmarks by about 10%\nif the column cache is enabled an by about 100% if the column cache is\ndisabled."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ5ODUxMDMy", "url": "https://github.com/apache/druid/pull/9278#pullrequestreview-349851032", "createdAt": "2020-01-29T04:08:03Z", "commit": {"oid": "2287bed236973da368c636e8b54c349b3eb89aba"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwNDowODowM1rOFi8D8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwNDoxMTowM1rOFi8FwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE3OTk1Mg==", "bodyText": "This is only safe when the selector has a 'real' dictionary, i.e. when selector.getValueCardinality() does not return DimensionSelector.CARDINALITY_UNKNOWN. If it is unknown then the ids are not valid outside the context of a specific row. So, in that case you'll need to fall back to the slower code.", "url": "https://github.com/apache/druid/pull/9278#discussion_r372179952", "createdAt": "2020-01-29T04:08:03Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -262,8 +288,9 @@ public ValueType defaultType()\n         final IndexedInts row = selector.getRow();\n \n         if (row.size() == 1) {\n-          final String key = selector.lookupName(row.get(0));\n-          return index.find(key).iterator();\n+          int dimensionId = row.get(0);\n+          //noinspection ConstantConditions (cache cannot return nulls since nulls are never stored in cache)\n+          return dimensionCaches.get(selector).get(dimensionId).iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2287bed236973da368c636e8b54c349b3eb89aba"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE4MDIwNg==", "bodyText": "For each selector, dimensionIds are contiguous and go from 0 (inclusive) to selector.getValueCardinality() (exclusive). If the cardinality is less than CACHE_MAX_SIZE then you could use an IntList[] as a cache. It should be faster.", "url": "https://github.com/apache/druid/pull/9278#discussion_r372180206", "createdAt": "2020-01-29T04:09:39Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -240,13 +243,36 @@ private void advanceCurrentRow()\n    */\n   private static class ConditionMatcherFactory implements ColumnProcessorFactory<Supplier<IntIterator>>\n   {\n+    private static final int MAX_NUM_CACHE = 10;\n+    private static final int CACHE_MAX_SIZE = 1000;\n+\n     private final ValueType keyType;\n     private final IndexedTable.Index index;\n \n+    // DimensionSelector -> (int) dimension id -> (IntList) row numbers\n+    private final LoadingCache<DimensionSelector, LoadingCache<Integer, IntList>> dimensionCaches;\n+\n     ConditionMatcherFactory(ValueType keyType, IndexedTable.Index index)\n     {\n       this.keyType = keyType;\n       this.index = index;\n+\n+      this.dimensionCaches =\n+          Caffeine.newBuilder()\n+                  .maximumSize(MAX_NUM_CACHE)\n+                  .build(\n+                      selector ->\n+                          Caffeine.newBuilder()\n+                                  .maximumSize(CACHE_MAX_SIZE)\n+                                  .build(dimensionId -> getRowNumbers(selector, dimensionId))\n+                  );\n+\n+    }\n+\n+    private IntList getRowNumbers(DimensionSelector selector, int dimensionId)\n+    {\n+      final String key = selector.lookupName(dimensionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2287bed236973da368c636e8b54c349b3eb89aba"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE4MDQxNw==", "bodyText": "How does this compare to the LruEvalCache in SingleStringInputCachingExpressionColumnValueSelector? I think they're trying to solve the same problem, so whichever approach works better, both that class and this one should use the best approach.", "url": "https://github.com/apache/druid/pull/9278#discussion_r372180417", "createdAt": "2020-01-29T04:11:03Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -240,13 +243,36 @@ private void advanceCurrentRow()\n    */\n   private static class ConditionMatcherFactory implements ColumnProcessorFactory<Supplier<IntIterator>>\n   {\n+    private static final int MAX_NUM_CACHE = 10;\n+    private static final int CACHE_MAX_SIZE = 1000;\n+\n     private final ValueType keyType;\n     private final IndexedTable.Index index;\n \n+    // DimensionSelector -> (int) dimension id -> (IntList) row numbers\n+    private final LoadingCache<DimensionSelector, LoadingCache<Integer, IntList>> dimensionCaches;\n+\n     ConditionMatcherFactory(ValueType keyType, IndexedTable.Index index)\n     {\n       this.keyType = keyType;\n       this.index = index;\n+\n+      this.dimensionCaches =\n+          Caffeine.newBuilder()\n+                  .maximumSize(MAX_NUM_CACHE)\n+                  .build(\n+                      selector ->\n+                          Caffeine.newBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2287bed236973da368c636e8b54c349b3eb89aba"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc460d3ac96fbc858c5c29e82c5c08f5c4a4ccfa", "author": {"user": {"login": "ccaominh", "name": "Chi Cao Minh"}}, "url": "https://github.com/apache/druid/commit/fc460d3ac96fbc858c5c29e82c5c08f5c4a4ccfa", "committedDate": "2020-01-30T01:07:20Z", "message": "Merge remote-tracking branch 'upstream/master' into joins-index-table-join-matcher-cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6fd4707397dd92dc5d4161dc462e14f6b5d9230f", "author": {"user": {"login": "ccaominh", "name": "Chi Cao Minh"}}, "url": "https://github.com/apache/druid/commit/6fd4707397dd92dc5d4161dc462e14f6b5d9230f", "committedDate": "2020-02-01T02:14:41Z", "message": "Faster cache impl and handle unknown cardinality"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a4bc32e2c460693410f53326c5f6e410302ff0b", "author": {"user": {"login": "ccaominh", "name": "Chi Cao Minh"}}, "url": "https://github.com/apache/druid/commit/2a4bc32e2c460693410f53326c5f6e410302ff0b", "committedDate": "2020-02-01T02:24:39Z", "message": "Merge remote-tracking branch 'upstream/master' into joins-index-table-join-matcher-cache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d5b18aa52cbd8437c267800eb2901aa5ac6530e", "author": {"user": {"login": "ccaominh", "name": "Chi Cao Minh"}}, "url": "https://github.com/apache/druid/commit/6d5b18aa52cbd8437c267800eb2901aa5ac6530e", "committedDate": "2020-02-01T17:53:15Z", "message": "Remove unused dependency"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb951d204fb01fa416f0644f696463f32cc8263e", "author": {"user": {"login": "ccaominh", "name": "Chi Cao Minh"}}, "url": "https://github.com/apache/druid/commit/bb951d204fb01fa416f0644f696463f32cc8263e", "committedDate": "2020-02-01T17:53:53Z", "message": "Merge remote-tracking branch 'upstream/master' into joins-index-table-join-matcher-cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNjQ3MTY3", "url": "https://github.com/apache/druid/pull/9278#pullrequestreview-352647167", "createdAt": "2020-02-04T00:01:33Z", "commit": {"oid": "bb951d204fb01fa416f0644f696463f32cc8263e"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMDowMTozNFrOFlEKYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMDowNTo0MlrOFlEPBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQwOTgyNg==", "bodyText": "This won't change from row to row, so it's likely going to be better to check it outside hot code (i.e. return a different Supplier<IntIterator> based on the result of calling selector.getValueCardinality()).", "url": "https://github.com/apache/druid/pull/9278#discussion_r374409826", "createdAt": "2020-02-04T00:01:34Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -263,8 +299,17 @@ public ValueType defaultType()\n         final IndexedInts row = selector.getRow();\n \n         if (row.size() == 1) {\n-          final String key = selector.lookupName(row.get(0));\n-          return index.find(key).iterator();\n+          int dimensionId = row.get(0);\n+          final IntList rowNumbers;\n+          if (selector.getValueCardinality() == DimensionDictionarySelector.CARDINALITY_UNKNOWN) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb951d204fb01fa416f0644f696463f32cc8263e"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQxMTAxMw==", "bodyText": "I thought Java guaranteed that object arrays will start with all nulls.", "url": "https://github.com/apache/druid/pull/9278#discussion_r374411013", "createdAt": "2020-02-04T00:05:42Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/join/table/IndexedTableJoinMatcher.java", "diffHunk": "@@ -308,4 +353,112 @@ public ValueType defaultType()\n       return () -> IntIterators.EMPTY_ITERATOR;\n     }\n   }\n+\n+  @VisibleForTesting\n+  static class LruLoadingHashMap<K, V> extends LinkedHashMap<K, V>\n+  {\n+    private final int maxSize;\n+    private final Function<K, V> loader;\n+\n+    LruLoadingHashMap(int maxSize, Function<K, V> loader)\n+    {\n+      super(capacity(maxSize));\n+      this.maxSize = maxSize;\n+      this.loader = loader;\n+    }\n+\n+    V getAndLoadIfAbsent(K key)\n+    {\n+      return computeIfAbsent(key, loader);\n+    }\n+\n+    @Override\n+    protected boolean removeEldestEntry(Map.Entry eldest)\n+    {\n+      return size() > maxSize;\n+    }\n+\n+    private static int capacity(int expectedSize)\n+    {\n+      // This is the calculation used in JDK8 to resize when a putAll happens; it seems to be the most conservative\n+      // calculation we can make. 0.75 is the default load factor.\n+      return (int) ((float) expectedSize / 0.75F + 1.0F);\n+    }\n+  }\n+\n+  private interface Int2IntListMap\n+  {\n+    IntList getAndLoadIfAbsent(int key);\n+  }\n+\n+  /**\n+   * Lookup table for keys in the range from 0 to maxSize - 1\n+   */\n+  @VisibleForTesting\n+  static class Int2IntListLookupTable implements Int2IntListMap\n+  {\n+    private final IntList[] lookup;\n+    private final IntFunction<IntList> loader;\n+\n+    Int2IntListLookupTable(int maxSize, IntFunction<IntList> loader)\n+    {\n+      this.loader = loader;\n+      this.lookup = new IntList[maxSize];\n+      Arrays.fill(lookup, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb951d204fb01fa416f0644f696463f32cc8263e"}, "originalPosition": 155}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b8955eb00d1feda09432156c7bd3b7271c904a3", "author": {"user": {"login": "ccaominh", "name": "Chi Cao Minh"}}, "url": "https://github.com/apache/druid/commit/5b8955eb00d1feda09432156c7bd3b7271c904a3", "committedDate": "2020-02-04T21:45:40Z", "message": "Hoist cardinality check outside of hot loop"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71eab4d59c89a3d5c1af16dd58da3b5887caefca", "author": {"user": {"login": "ccaominh", "name": "Chi Cao Minh"}}, "url": "https://github.com/apache/druid/commit/71eab4d59c89a3d5c1af16dd58da3b5887caefca", "committedDate": "2020-02-04T21:46:26Z", "message": "Merge remote-tracking branch 'upstream/master' into joins-index-table-join-matcher-cache"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzcyNTMz", "url": "https://github.com/apache/druid/pull/9278#pullrequestreview-353372533", "createdAt": "2020-02-04T23:19:35Z", "commit": {"oid": "71eab4d59c89a3d5c1af16dd58da3b5887caefca"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18e9bf5d14fbacebc6d5d4e12c6667a02fb1162b", "author": {"user": {"login": "ccaominh", "name": "Chi Cao Minh"}}, "url": "https://github.com/apache/druid/commit/18e9bf5d14fbacebc6d5d4e12c6667a02fb1162b", "committedDate": "2020-02-04T23:28:59Z", "message": "Fix dummy DimensionSelector for tests"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3031, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}