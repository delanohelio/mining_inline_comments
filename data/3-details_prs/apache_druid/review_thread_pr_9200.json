{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYzODk3MzY1", "number": 9200, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMDozNzowMVrODYrxeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMDozNzozMlrODYrxrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjA5NTkzOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/join/JoinConditionAnalysis.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMDozNzowMVrOFerz2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxODo0MzoyNFrOFfB4AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcxOTM4NA==", "bodyText": "It seems like allTrueLiteralNonEquiConditions is only used here; how about caching isAlwaysTrue directly?", "url": "https://github.com/apache/druid/pull/9200#discussion_r367719384", "createdAt": "2020-01-17T00:37:01Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/join/JoinConditionAnalysis.java", "diffHunk": "@@ -133,26 +142,23 @@ public String getOriginalExpression()\n    */\n   public boolean isAlwaysFalse()\n   {\n-    return nonEquiConditions.stream()\n-                            .anyMatch(expr -> expr.isLiteral() && !expr.eval(ExprUtils.nilBindings()).asBoolean());\n+    return anyFalseLiteralNonEquiConditions;\n   }\n \n   /**\n    * Return whether this condition is a constant that is always true.\n    */\n   public boolean isAlwaysTrue()\n   {\n-    return equiConditions.isEmpty() &&\n-           nonEquiConditions.stream()\n-                            .allMatch(expr -> expr.isLiteral() && expr.eval(ExprUtils.nilBindings()).asBoolean());\n+    return equiConditions.isEmpty() && allTrueLiteralNonEquiConditions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f7e73d1c00cc4e2783ec36e444f77c2b7358be9"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4MDg5Ng==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/9200#discussion_r368080896", "createdAt": "2020-01-17T18:43:24Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/segment/join/JoinConditionAnalysis.java", "diffHunk": "@@ -133,26 +142,23 @@ public String getOriginalExpression()\n    */\n   public boolean isAlwaysFalse()\n   {\n-    return nonEquiConditions.stream()\n-                            .anyMatch(expr -> expr.isLiteral() && !expr.eval(ExprUtils.nilBindings()).asBoolean());\n+    return anyFalseLiteralNonEquiConditions;\n   }\n \n   /**\n    * Return whether this condition is a constant that is always true.\n    */\n   public boolean isAlwaysTrue()\n   {\n-    return equiConditions.isEmpty() &&\n-           nonEquiConditions.stream()\n-                            .allMatch(expr -> expr.isLiteral() && expr.eval(ExprUtils.nilBindings()).asBoolean());\n+    return equiConditions.isEmpty() && allTrueLiteralNonEquiConditions;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcxOTM4NA=="}, "originalCommit": {"oid": "1f7e73d1c00cc4e2783ec36e444f77c2b7358be9"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MjA5NjQ3OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/join/JoinConditionAnalysis.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QwMDozNzozMlrOFer0Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xN1QxODo0MzoyMFrOFfB35w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcxOTQ5OQ==", "bodyText": "Why not call this isAlwaysFalse? (It looks like it isn't used anywhere else, and it seems to me to be easier to understand the meaning of the field if it's named after what we want it to mean.)", "url": "https://github.com/apache/druid/pull/9200#discussion_r367719499", "createdAt": "2020-01-17T00:37:32Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/segment/join/JoinConditionAnalysis.java", "diffHunk": "@@ -133,26 +142,23 @@ public String getOriginalExpression()\n    */\n   public boolean isAlwaysFalse()\n   {\n-    return nonEquiConditions.stream()\n-                            .anyMatch(expr -> expr.isLiteral() && !expr.eval(ExprUtils.nilBindings()).asBoolean());\n+    return anyFalseLiteralNonEquiConditions;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f7e73d1c00cc4e2783ec36e444f77c2b7358be9"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA4MDg3MQ==", "bodyText": "yeah. I wasn't sure if isAlwaysFalse could be more complex going forward. This is clearer - it took me a while to wrap my head around what isAlwaysFalse was trying to check. Added comments, and used isAlways...", "url": "https://github.com/apache/druid/pull/9200#discussion_r368080871", "createdAt": "2020-01-17T18:43:20Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/segment/join/JoinConditionAnalysis.java", "diffHunk": "@@ -133,26 +142,23 @@ public String getOriginalExpression()\n    */\n   public boolean isAlwaysFalse()\n   {\n-    return nonEquiConditions.stream()\n-                            .anyMatch(expr -> expr.isLiteral() && !expr.eval(ExprUtils.nilBindings()).asBoolean());\n+    return anyFalseLiteralNonEquiConditions;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzcxOTQ5OQ=="}, "originalCommit": {"oid": "1f7e73d1c00cc4e2783ec36e444f77c2b7358be9"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2134, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}