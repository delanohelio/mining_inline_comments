{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyOTA3Mjkw", "number": 10120, "title": "Fix Stack overflow with infinite loop in ReduceExpressionsRule of HepProgram", "bodyText": "Fix Stack overflow with infinite loop in ReduceExpressionsRule of HepProgram\nDescription\nThis fix #9906\nDue to Calcite bug (CALCITE-3845), ReduceExpressionsRule can considered expression which is the same as the previous input expression as reduced. Basically, the expression is actually not reduced but is still considered as reduced. Hence, this resulted in an infinite loop of Calcite trying to reducing the same expression over and over in ReduceExpressionsRule. Calcite 1.23.0 fixes this issue by not consider expression as reduced if this case happens. However, while we are still using Calcite 1.21.0, a workaround is to limit the number of pattern matches to avoid infinite loop in ReduceExpressionsRule of the HepProgram. One example of this case is the query SELECT ARRAY ['Hello', NULL]\nThe matchLimit value of 1200 is chosen with suggestion by a Calcite committer, Chunwei Lei. (See: https://lists.apache.org/x/thread.html/rea7691aec3947a49faaa29cdfba4ef5d0a5e1da2c3b7546ae8dea3c8@%3Cdev.calcite.apache.org%3E). Note: Chunwei recommendation is based on MaxCompute (https://www.alibabacloud.com/product/maxcompute),  a big data computing and\nstorage platform. MaxCompute uses Calcite for cost-based query optimization. MaxCompute has similar usage of the HepProgram as Druid which is to reduce the search space (do some optimizations, such as column pruning, predicate pushdown, and so on), before entering VolcanoPlanner.\nThis PR has:\n\n been self-reviewed.\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added or updated version, license, or notice information in licenses.yaml\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths, ensuring the threshold for code coverage is met.\n added integration tests.\n been tested in a test Druid cluster.", "createdAt": "2020-07-01T19:05:08Z", "url": "https://github.com/apache/druid/pull/10120", "merged": true, "mergeCommit": {"oid": "1676ba22e300ea95cc92c0808f390aaa769546f9"}, "closed": true, "closedAt": "2020-07-02T00:48:10Z", "author": {"login": "maytasm"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwvAeLAH2gAyNDQyOTA3MjkwOmYyNDc1ZDYzN2U5YThlODZmYzAwMGZlNzBjMjE5NmZlNjZjMzgwNGU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcwz-HRgFqTQ0MTI4MDE1OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "f2475d637e9a8e86fc000fe70c2196fe66c3804e", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/f2475d637e9a8e86fc000fe70c2196fe66c3804e", "committedDate": "2020-07-01T19:00:30Z", "message": "Fix Stack overflow with SELECT ARRAY ['Hello', NULL]"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMTM4ODIy", "url": "https://github.com/apache/druid/pull/10120#pullrequestreview-441138822", "createdAt": "2020-07-01T19:25:16Z", "commit": {"oid": "f2475d637e9a8e86fc000fe70c2196fe66c3804e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxOToyNToxN1rOGrylFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQxOToyNToxN1rOGrylFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU3MDY0Nw==", "bodyText": "Is it possible to make this a system property? Having to restart the broker sounds like a lot less pain than having to make a new patch if this estimated HEP_DEFAULT_MATCH_LIMIT is incorrect for some edge case that we don't have tests for.", "url": "https://github.com/apache/druid/pull/10120#discussion_r448570647", "createdAt": "2020-07-01T19:25:17Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/planner/Rules.java", "diffHunk": "@@ -85,6 +88,13 @@\n   public static final int DRUID_CONVENTION_RULES = 0;\n   public static final int BINDABLE_CONVENTION_RULES = 1;\n \n+  // Due to Calcite bug (CALCITE-3845), ReduceExpressionsRule can considered expression which is the same as the\n+  // previous input expression as reduced. Basically, the expression is actually not reduced but is still considered as\n+  // reduced. Hence, this resulted in an infinite loop of Calcite trying to reducing the same expression over and over.\n+  // Calcite 1.23.0 fixes this issue by not consider expression as reduced if this case happens. However, while\n+  // we are still using Calcite 1.21.0, a workaround is to limit the number of pattern matches to avoid infinite loop.\n+  private static final int HEP_DEFAULT_MATCH_LIMIT = 1200;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2475d637e9a8e86fc000fe70c2196fe66c3804e"}, "originalPosition": 23}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e34ab211183edf934f553aa2c04e0a2227c89de5", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/e34ab211183edf934f553aa2c04e0a2227c89de5", "committedDate": "2020-07-01T19:58:29Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxMjgwMTU5", "url": "https://github.com/apache/druid/pull/10120#pullrequestreview-441280159", "createdAt": "2020-07-02T00:47:27Z", "commit": {"oid": "e34ab211183edf934f553aa2c04e0a2227c89de5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2228, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}