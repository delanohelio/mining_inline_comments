{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2ODQ2MjQx", "number": 10053, "title": "fix topn on string columns with non-sorted or non-unique dictionaries", "bodyText": "Description\nThis PR fixes an issue with TopN algorithm selection to make sure that string columns with dictionaries also have sorted and unique dictionaries. The off-heap pooled algorithm assumes this to be true, so we must use the heap based algorithm in cases where the column has a dictionary, but it is not unique or sorted.\nPrior to this PR, the added test produces the following incorrect results before this patch:\n2020-06-18T18:52:21,520 INFO [main] org.apache.druid.sql.calcite.BaseCalciteQueryTest - row #0: [a, 3]\n2020-06-18T18:52:21,520 INFO [main] org.apache.druid.sql.calcite.BaseCalciteQueryTest - row #1: [a, 3]\n2020-06-18T18:52:21,520 INFO [main] org.apache.druid.sql.calcite.BaseCalciteQueryTest - row #2: [a, 3]\n2020-06-18T18:52:21,520 INFO [main] org.apache.druid.sql.calcite.BaseCalciteQueryTest - row #3: [b, 3]\n\nThis test covers a ton more surface than just this condition since it tests it via a join to a broadcast GlobalTableDataSource. CalciteQueryTest may now test against an IndexedTable joinable version of the numfoo test datasource (without the metrics columns), which is wired up into the segment walker to mimic a broadcast segment that is present on the broker, so that in the DruidSchema it will be translated into a GlobalTableDataSource instead of a TableDataSource.\n\nThis PR has:\n\n been self-reviewed.\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added or updated version, license, or notice information in licenses.yaml\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths, ensuring the threshold for code coverage is met.\n added integration tests.\n been tested in a test Druid cluster.\n\n\nKey changed/added classes in this PR\n\nTopNQueryEngine", "createdAt": "2020-06-19T02:02:29Z", "url": "https://github.com/apache/druid/pull/10053", "merged": true, "mergeCommit": {"oid": "c2f5d453f87d0863fba532e9ff4f3e7369db12e3"}, "closed": true, "closedAt": "2020-06-19T18:35:19Z", "author": {"login": "clintropolis"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcspKQyAH2gAyNDM2ODQ2MjQxOjNlNWVmMTMyYjYxYTg1ZjUwOWJiY2U2NDQ1YmQ5NGUzNGY3Nzc0M2I=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcs3cN8gFqTQzNDI3MTM3NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3e5ef132b61a85f509bbce6445bd94e34f77743b", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/3e5ef132b61a85f509bbce6445bd94e34f77743b", "committedDate": "2020-06-19T01:56:04Z", "message": "fix topn on string columns with non-sorted or non-unique dictionaries"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2dfcc2b2d1514e7175e693dbc74592b83cf4d9e", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/d2dfcc2b2d1514e7175e693dbc74592b83cf4d9e", "committedDate": "2020-06-19T02:22:59Z", "message": "fix metadata tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNzcyMjU0", "url": "https://github.com/apache/druid/pull/10053#pullrequestreview-433772254", "createdAt": "2020-06-19T03:00:08Z", "commit": {"oid": "d2dfcc2b2d1514e7175e693dbc74592b83cf4d9e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMzowMDowOVrOGmGfrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMzowMDowOVrOGmGfrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNTQ4Ng==", "bodyText": "Can you update the comments and also mention why we can/want to use HeapBasedTopNAlgorithm for each of those conditions (not sorted, not unique, etc)", "url": "https://github.com/apache/druid/pull/10053#discussion_r442605486", "createdAt": "2020-06-19T03:00:09Z", "author": {"login": "maytasm"}, "path": "processing/src/main/java/org/apache/druid/query/topn/TopNQueryEngine.java", "diffHunk": "@@ -126,14 +126,20 @@ private TopNMapFn getMapFn(\n         // Once we have arbitrary dimension types following check should be replaced by checking\n         // that the column is of type long and single-value.\n         dimension.equals(ColumnHolder.TIME_COLUMN_NAME)\n-        ) {\n+    ) {\n       // A special TimeExtractionTopNAlgorithm is required, since DimExtractionTopNAlgorithm\n       // currently relies on the dimension cardinality to support lexicographic sorting\n       topNAlgorithm = new TimeExtractionTopNAlgorithm(adapter, query);\n     } else if (selector.isHasExtractionFn()) {\n       topNAlgorithm = new HeapBasedTopNAlgorithm(adapter, query);\n-    } else if (columnCapabilities == null || !(columnCapabilities.getType() == ValueType.STRING\n-                                               && columnCapabilities.isDictionaryEncoded())) {\n+    } else if (\n+        columnCapabilities == null ||\n+        !(columnCapabilities.getType() == ValueType.STRING &&\n+          columnCapabilities.isDictionaryEncoded() &&\n+          columnCapabilities.areDictionaryValuesSorted().isTrue() &&\n+          columnCapabilities.areDictionaryValuesUnique().isTrue()\n+        )\n+    ) {\n       // Use HeapBasedTopNAlgorithm for non-Strings and for non-dictionary-encoded Strings, and for things we don't know", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2dfcc2b2d1514e7175e693dbc74592b83cf4d9e"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzODAwMDA5", "url": "https://github.com/apache/druid/pull/10053#pullrequestreview-433800009", "createdAt": "2020-06-19T04:49:51Z", "commit": {"oid": "d2dfcc2b2d1514e7175e693dbc74592b83cf4d9e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "18c06a37a4975c410f80e447eeba35cecac4cb26", "author": {"user": {"login": "clintropolis", "name": "Clint Wylie"}}, "url": "https://github.com/apache/druid/commit/18c06a37a4975c410f80e447eeba35cecac4cb26", "committedDate": "2020-06-19T06:12:58Z", "message": "refactor, clarify comments and code, fix ci failures"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzODU2Mzc4", "url": "https://github.com/apache/druid/pull/10053#pullrequestreview-433856378", "createdAt": "2020-06-19T07:20:58Z", "commit": {"oid": "18c06a37a4975c410f80e447eeba35cecac4cb26"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MjcxMzc0", "url": "https://github.com/apache/druid/pull/10053#pullrequestreview-434271374", "createdAt": "2020-06-19T18:30:30Z", "commit": {"oid": "18c06a37a4975c410f80e447eeba35cecac4cb26"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxODozMDozMFrOGmd5kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxODozMDozMFrOGmd5kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk4ODk0Nw==", "bodyText": "I think this method would be easier to read if it was called canUsePooledAlgorithm and the checks were all flipped. This is because IMO it makes sense to view the heap algorithm as the base case, and the pooled algorithm as a special case, meaning the logic should be \"can we do the special case\".", "url": "https://github.com/apache/druid/pull/10053#discussion_r442988947", "createdAt": "2020-06-19T18:30:30Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/topn/TopNQueryEngine.java", "diffHunk": "@@ -158,6 +156,40 @@ private TopNMapFn getMapFn(\n     return new TopNMapFn(query, topNAlgorithm);\n   }\n \n+  /**\n+   * {@link PooledTopNAlgorithm} (and {@link AggregateTopNMetricFirstAlgorithm} which utilizes the pooled\n+   * algorithm) are optimized off-heap algorithms for aggregating dictionary encoded string columns. These algorithms\n+   * rely on dictionary ids being unique so to aggregate on the dictionary ids directly and defer\n+   * {@link org.apache.druid.segment.DimensionSelector#lookupName(int)} until as late as possible in query processing.\n+   *\n+   * When these conditions are not true, we have an on-heap fall-back algorithm, the {@link HeapBasedTopNAlgorithm}\n+   * (and {@link TimeExtractionTopNAlgorithm} for a specialized form for long columns) which aggregates on values of\n+   * selectors.\n+   */\n+  private static boolean requiresHeapAlgorithm(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18c06a37a4975c410f80e447eeba35cecac4cb26"}, "originalPosition": 77}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2125, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}