{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1OTAzMDAy", "number": 10518, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOTowMDoxMVrOEzs_mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjo1Mjo1MFrOFCd9GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjUwMDExOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/RowBasedGrouperHelper.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwOTowMDoxMVrOHrGR7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMzoxOTo0OFrOH-5omA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk1MzcwOA==", "bodyText": "It probably doesn't matter, but since this is a relatively hot path of the code, it might be worth measuring if this if statement here has any performance impact on group by queries which do not having a grouping aggregator. If it is actually visible, it might be worth pulling out a separate code path to handle the grouping sets case so that this does not negatively impact performance.", "url": "https://github.com/apache/druid/pull/10518#discussion_r514953708", "createdAt": "2020-10-30T09:00:11Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/RowBasedGrouperHelper.java", "diffHunk": "@@ -576,7 +594,12 @@ private static ValueExtractFunction makeValueExtractFunction(\n           // Add aggregations.\n           final int resultRowAggregatorStart = query.getResultRowAggregatorStart();\n           for (int i = 0; i < entry.getValues().length; i++) {\n-            resultRow.set(resultRowAggregatorStart + i, entry.getValues()[i]);\n+            if (dimsToInclude != null && groupingAggregatorsBitSet.get(i)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0NTc2Nw==", "bodyText": "Right. This is one change I am a bit anxious about. is there any existing benchmark I could use?", "url": "https://github.com/apache/druid/pull/10518#discussion_r515945767", "createdAt": "2020-11-02T12:44:21Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/RowBasedGrouperHelper.java", "diffHunk": "@@ -576,7 +594,12 @@ private static ValueExtractFunction makeValueExtractFunction(\n           // Add aggregations.\n           final int resultRowAggregatorStart = query.getResultRowAggregatorStart();\n           for (int i = 0; i < entry.getValues().length; i++) {\n-            resultRow.set(resultRowAggregatorStart + i, entry.getValues()[i]);\n+            if (dimsToInclude != null && groupingAggregatorsBitSet.get(i)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk1MzcwOA=="}, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk0MTIxNg==", "bodyText": "I think this if clause is probably fine. However, if I'm reading code correctly, the new aggregators seem to do nothing and even their result is not in use but those aggregators are still involved in hash aggregation. I'm more worrying about this because it involves serializing/deserializing the aggregator values to/from off-heap memory which is pretty expensive. Because GroupingAggregatorFactory is a special aggregator type which cannot be computed by regular aggregation, can we rewrite the query to not compute them in hash aggregation but add the aggregation results as what you do now?\n\nRight. This is one change I am a bit anxious about. is there any existing benchmark I could use?\n\nGroupByBenchmark will be the easiest place for such benchmarks, but it's not probably the best place because it benchmarks the query performance of historicals. I would like to suggest to add a new one for broker performance, but this comment is not a blocker. I'm OK with adding a new benchmark in GroupByBenchmark for now.", "url": "https://github.com/apache/druid/pull/10518#discussion_r532941216", "createdAt": "2020-11-30T22:20:31Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/RowBasedGrouperHelper.java", "diffHunk": "@@ -576,7 +594,12 @@ private static ValueExtractFunction makeValueExtractFunction(\n           // Add aggregations.\n           final int resultRowAggregatorStart = query.getResultRowAggregatorStart();\n           for (int i = 0; i < entry.getValues().length; i++) {\n-            resultRow.set(resultRowAggregatorStart + i, entry.getValues()[i]);\n+            if (dimsToInclude != null && groupingAggregatorsBitSet.get(i)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk1MzcwOA=="}, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE0MjI0Mg==", "bodyText": "In the current Long*Aggregator implementations, there is no serialization/deserialization. Aggregations are no-op and get call just returns the value passed in the constructor. am I missing any code path here?\nI also wanted to limit the places where there is special handling for GroupingAggregatorFactory.", "url": "https://github.com/apache/druid/pull/10518#discussion_r533142242", "createdAt": "2020-12-01T08:11:24Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/RowBasedGrouperHelper.java", "diffHunk": "@@ -576,7 +594,12 @@ private static ValueExtractFunction makeValueExtractFunction(\n           // Add aggregations.\n           final int resultRowAggregatorStart = query.getResultRowAggregatorStart();\n           for (int i = 0; i < entry.getValues().length; i++) {\n-            resultRow.set(resultRowAggregatorStart + i, entry.getValues()[i]);\n+            if (dimsToInclude != null && groupingAggregatorsBitSet.get(i)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk1MzcwOA=="}, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxODA0MA==", "bodyText": "I talked to @abhishekagarwal87 offline. My biggest concern is that the special handling for GroupingAggregatorFactory seems pretty magical because the behaviour of the factory and its aggregators is different from others. What I suggested above is making it more special but less magical, because I think it's less confusing. @abhishekagarwal87's concern is mostly around the complexity of query rewriting which requires adjusting result row signature (because the result of grouping function will be missing at certain points during a query after rewrite). I think we can still handle this but maybe it could be fragile because we don't have a systemic way to handle result row signature changes during a query and thus the logic to handle them will be ad-hoc. I agree with this view, so the current structure seems reasonable even though I still think, ideally, we should not involve GroupingAggregatorFactory in hash aggregation. Maybe we can do in the future once we have some better way to handle query writing and result row signature changes.", "url": "https://github.com/apache/druid/pull/10518#discussion_r535718040", "createdAt": "2020-12-03T23:19:48Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/RowBasedGrouperHelper.java", "diffHunk": "@@ -576,7 +594,12 @@ private static ValueExtractFunction makeValueExtractFunction(\n           // Add aggregations.\n           final int resultRowAggregatorStart = query.getResultRowAggregatorStart();\n           for (int i = 0; i < entry.getValues().length; i++) {\n-            resultRow.set(resultRowAggregatorStart + i, entry.getValues()[i]);\n+            if (dimsToInclude != null && groupingAggregatorsBitSet.get(i)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk1MzcwOA=="}, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjk4ODExOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMToyMzo1M1rOHrK4vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwNzoxOToxNVrOH8a9fQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyOTE4Mg==", "bodyText": "I think when other databases have differences in functionality so that there doesn't seem to be a consistent behavior, we typically follow the PostgreSQL behavior instead of others (#7950 (comment), #9337, #9488 (comment), #10006, etc), which seems to be the opposite of this where 0 means membership of the grouping set and 1 is not.\nI think we should be consistent with the PostgreSQL behavior here as well.", "url": "https://github.com/apache/druid/pull/10518#discussion_r515029182", "createdAt": "2020-10-30T11:23:53Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.annotations.EverythingIsNonnullByDefault;\n+import org.apache.druid.query.aggregation.constant.LongConstantAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantBufferAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantVectorAggregator;\n+import org.apache.druid.query.cache.CacheKeyBuilder;\n+import org.apache.druid.segment.ColumnInspector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.vector.VectorColumnSelectorFactory;\n+import org.apache.druid.utils.CollectionUtils;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@EverythingIsNonnullByDefault\n+public class GroupingAggregatorFactory extends AggregatorFactory\n+{\n+  private static final Comparator<Long> VALUE_COMPARATOR = Long::compare;\n+  private final String name;\n+  private final List<String> groupings;\n+  private final long value;\n+  @Nullable\n+  private final Set<String> keyDimensions;\n+\n+  @JsonCreator\n+  public GroupingAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"groupings\") List<String> groupings\n+  )\n+  {\n+    this(name, groupings, null);\n+  }\n+\n+  @VisibleForTesting\n+  GroupingAggregatorFactory(\n+      String name,\n+      List<String> groupings,\n+      @Nullable Set<String> keyDimensions\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    this.name = name;\n+    this.groupings = groupings;\n+    this.keyDimensions = keyDimensions;\n+    value = groupingId(groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantAggregator(value);\n+  }\n+\n+  @Override\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantBufferAggregator(value);\n+  }\n+\n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+    return new LongConstantVectorAggregator(value);\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    return true;\n+  }\n+\n+  /**\n+   * Replace the param {@code keyDimensions} with the new set of key dimensions\n+   */\n+  public GroupingAggregatorFactory withKeyDimensions(Set<String> newKeyDimensions)\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, newKeyDimensions);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return VALUE_COMPARATOR;\n+  }\n+\n+  @JsonProperty\n+  public List<String> getGroupings()\n+  {\n+    return groupings;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  public long getValue()\n+  {\n+    return value;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (null == lhs) {\n+      return rhs;\n+    }\n+    return lhs;\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new GroupingAggregatorFactory(name, groupings, keyDimensions));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    // The aggregator doesn't need to read any fields.\n+    return Collections.emptyList();\n+  }\n+\n+  @Override\n+  public ValueType getType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public ValueType getFinalizedType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Long.BYTES;\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    CacheKeyBuilder keyBuilder = new CacheKeyBuilder(AggregatorUtil.GROUPING_CACHE_TYPE_ID)\n+        .appendStrings(groupings);\n+    if (null != keyDimensions) {\n+      keyBuilder.appendStrings(keyDimensions);\n+    }\n+    return keyBuilder.build();\n+  }\n+\n+  /**\n+   * Gives the list of grouping dimensions, return a long value where each bit at position X in the returned value\n+   * corresponds to the dimension in groupings at same position X. X is the position relative to the right end. if\n+   * keyDimensions contain the grouping dimension at position X, the bit is set to 1 at position X, otherwise it is\n+   * set to 0. An example adapted from Microsoft SQL documentation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0NzYwMA==", "bodyText": "I have seen that. Though it seems weird that 0 bit indicates that dimension is present, it seems it's not just postgres. I also checked that a commercial data warehouse follows the same logic as Postgres. will change this.", "url": "https://github.com/apache/druid/pull/10518#discussion_r515947600", "createdAt": "2020-11-02T12:47:53Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.annotations.EverythingIsNonnullByDefault;\n+import org.apache.druid.query.aggregation.constant.LongConstantAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantBufferAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantVectorAggregator;\n+import org.apache.druid.query.cache.CacheKeyBuilder;\n+import org.apache.druid.segment.ColumnInspector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.vector.VectorColumnSelectorFactory;\n+import org.apache.druid.utils.CollectionUtils;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@EverythingIsNonnullByDefault\n+public class GroupingAggregatorFactory extends AggregatorFactory\n+{\n+  private static final Comparator<Long> VALUE_COMPARATOR = Long::compare;\n+  private final String name;\n+  private final List<String> groupings;\n+  private final long value;\n+  @Nullable\n+  private final Set<String> keyDimensions;\n+\n+  @JsonCreator\n+  public GroupingAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"groupings\") List<String> groupings\n+  )\n+  {\n+    this(name, groupings, null);\n+  }\n+\n+  @VisibleForTesting\n+  GroupingAggregatorFactory(\n+      String name,\n+      List<String> groupings,\n+      @Nullable Set<String> keyDimensions\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    this.name = name;\n+    this.groupings = groupings;\n+    this.keyDimensions = keyDimensions;\n+    value = groupingId(groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantAggregator(value);\n+  }\n+\n+  @Override\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantBufferAggregator(value);\n+  }\n+\n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+    return new LongConstantVectorAggregator(value);\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    return true;\n+  }\n+\n+  /**\n+   * Replace the param {@code keyDimensions} with the new set of key dimensions\n+   */\n+  public GroupingAggregatorFactory withKeyDimensions(Set<String> newKeyDimensions)\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, newKeyDimensions);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return VALUE_COMPARATOR;\n+  }\n+\n+  @JsonProperty\n+  public List<String> getGroupings()\n+  {\n+    return groupings;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  public long getValue()\n+  {\n+    return value;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (null == lhs) {\n+      return rhs;\n+    }\n+    return lhs;\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new GroupingAggregatorFactory(name, groupings, keyDimensions));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    // The aggregator doesn't need to read any fields.\n+    return Collections.emptyList();\n+  }\n+\n+  @Override\n+  public ValueType getType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public ValueType getFinalizedType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Long.BYTES;\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    CacheKeyBuilder keyBuilder = new CacheKeyBuilder(AggregatorUtil.GROUPING_CACHE_TYPE_ID)\n+        .appendStrings(groupings);\n+    if (null != keyDimensions) {\n+      keyBuilder.appendStrings(keyDimensions);\n+    }\n+    return keyBuilder.build();\n+  }\n+\n+  /**\n+   * Gives the list of grouping dimensions, return a long value where each bit at position X in the returned value\n+   * corresponds to the dimension in groupings at same position X. X is the position relative to the right end. if\n+   * keyDimensions contain the grouping dimension at position X, the bit is set to 1 at position X, otherwise it is\n+   * set to 0. An example adapted from Microsoft SQL documentation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyOTE4Mg=="}, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzg0ODM1Mg==", "bodyText": "I checked this further @clintropolis . Few things\n\nMysql and postgres don't have the grouping functions that take more than one argument.\nHere is calcite documentation\n\n* <p>Accepts 1 or more arguments.\n* Example: {@code GROUPING(deptno, gender)} returns\n* 3 if both deptno and gender are being grouped,\n* 2 if only deptno is being grouped,\n* 1 if only gender is being groped,\n* 0 if neither deptno nor gender are being grouped.\n*\n\nI am now thinking that we should stick with how calcite intends it to be.  what do you think?", "url": "https://github.com/apache/druid/pull/10518#discussion_r517848352", "createdAt": "2020-11-05T07:48:30Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.annotations.EverythingIsNonnullByDefault;\n+import org.apache.druid.query.aggregation.constant.LongConstantAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantBufferAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantVectorAggregator;\n+import org.apache.druid.query.cache.CacheKeyBuilder;\n+import org.apache.druid.segment.ColumnInspector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.vector.VectorColumnSelectorFactory;\n+import org.apache.druid.utils.CollectionUtils;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@EverythingIsNonnullByDefault\n+public class GroupingAggregatorFactory extends AggregatorFactory\n+{\n+  private static final Comparator<Long> VALUE_COMPARATOR = Long::compare;\n+  private final String name;\n+  private final List<String> groupings;\n+  private final long value;\n+  @Nullable\n+  private final Set<String> keyDimensions;\n+\n+  @JsonCreator\n+  public GroupingAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"groupings\") List<String> groupings\n+  )\n+  {\n+    this(name, groupings, null);\n+  }\n+\n+  @VisibleForTesting\n+  GroupingAggregatorFactory(\n+      String name,\n+      List<String> groupings,\n+      @Nullable Set<String> keyDimensions\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    this.name = name;\n+    this.groupings = groupings;\n+    this.keyDimensions = keyDimensions;\n+    value = groupingId(groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantAggregator(value);\n+  }\n+\n+  @Override\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantBufferAggregator(value);\n+  }\n+\n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+    return new LongConstantVectorAggregator(value);\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    return true;\n+  }\n+\n+  /**\n+   * Replace the param {@code keyDimensions} with the new set of key dimensions\n+   */\n+  public GroupingAggregatorFactory withKeyDimensions(Set<String> newKeyDimensions)\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, newKeyDimensions);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return VALUE_COMPARATOR;\n+  }\n+\n+  @JsonProperty\n+  public List<String> getGroupings()\n+  {\n+    return groupings;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  public long getValue()\n+  {\n+    return value;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (null == lhs) {\n+      return rhs;\n+    }\n+    return lhs;\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new GroupingAggregatorFactory(name, groupings, keyDimensions));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    // The aggregator doesn't need to read any fields.\n+    return Collections.emptyList();\n+  }\n+\n+  @Override\n+  public ValueType getType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public ValueType getFinalizedType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Long.BYTES;\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    CacheKeyBuilder keyBuilder = new CacheKeyBuilder(AggregatorUtil.GROUPING_CACHE_TYPE_ID)\n+        .appendStrings(groupings);\n+    if (null != keyDimensions) {\n+      keyBuilder.appendStrings(keyDimensions);\n+    }\n+    return keyBuilder.build();\n+  }\n+\n+  /**\n+   * Gives the list of grouping dimensions, return a long value where each bit at position X in the returned value\n+   * corresponds to the dimension in groupings at same position X. X is the position relative to the right end. if\n+   * keyDimensions contain the grouping dimension at position X, the bit is set to 1 at position X, otherwise it is\n+   * set to 0. An example adapted from Microsoft SQL documentation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyOTE4Mg=="}, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1MTAwMQ==", "bodyText": "MySQL and Postgres do seem to take more than one expressions. Check out the docs of postgres and mysql. Their behaviour seems consistent across popular database systems such as oracle and sql server. One exception is that sql server supports both grouping() and grouping_id() which behaves in an opposite way to each other. Calcite's behaviour is also consistent. Perhaps you were looking at an old version of the comment. I think Druid's behaviour should also match to most of other database systems.", "url": "https://github.com/apache/druid/pull/10518#discussion_r532951001", "createdAt": "2020-11-30T22:41:47Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.annotations.EverythingIsNonnullByDefault;\n+import org.apache.druid.query.aggregation.constant.LongConstantAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantBufferAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantVectorAggregator;\n+import org.apache.druid.query.cache.CacheKeyBuilder;\n+import org.apache.druid.segment.ColumnInspector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.vector.VectorColumnSelectorFactory;\n+import org.apache.druid.utils.CollectionUtils;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@EverythingIsNonnullByDefault\n+public class GroupingAggregatorFactory extends AggregatorFactory\n+{\n+  private static final Comparator<Long> VALUE_COMPARATOR = Long::compare;\n+  private final String name;\n+  private final List<String> groupings;\n+  private final long value;\n+  @Nullable\n+  private final Set<String> keyDimensions;\n+\n+  @JsonCreator\n+  public GroupingAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"groupings\") List<String> groupings\n+  )\n+  {\n+    this(name, groupings, null);\n+  }\n+\n+  @VisibleForTesting\n+  GroupingAggregatorFactory(\n+      String name,\n+      List<String> groupings,\n+      @Nullable Set<String> keyDimensions\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    this.name = name;\n+    this.groupings = groupings;\n+    this.keyDimensions = keyDimensions;\n+    value = groupingId(groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantAggregator(value);\n+  }\n+\n+  @Override\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantBufferAggregator(value);\n+  }\n+\n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+    return new LongConstantVectorAggregator(value);\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    return true;\n+  }\n+\n+  /**\n+   * Replace the param {@code keyDimensions} with the new set of key dimensions\n+   */\n+  public GroupingAggregatorFactory withKeyDimensions(Set<String> newKeyDimensions)\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, newKeyDimensions);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return VALUE_COMPARATOR;\n+  }\n+\n+  @JsonProperty\n+  public List<String> getGroupings()\n+  {\n+    return groupings;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  public long getValue()\n+  {\n+    return value;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (null == lhs) {\n+      return rhs;\n+    }\n+    return lhs;\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new GroupingAggregatorFactory(name, groupings, keyDimensions));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    // The aggregator doesn't need to read any fields.\n+    return Collections.emptyList();\n+  }\n+\n+  @Override\n+  public ValueType getType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public ValueType getFinalizedType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Long.BYTES;\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    CacheKeyBuilder keyBuilder = new CacheKeyBuilder(AggregatorUtil.GROUPING_CACHE_TYPE_ID)\n+        .appendStrings(groupings);\n+    if (null != keyDimensions) {\n+      keyBuilder.appendStrings(keyDimensions);\n+    }\n+    return keyBuilder.build();\n+  }\n+\n+  /**\n+   * Gives the list of grouping dimensions, return a long value where each bit at position X in the returned value\n+   * corresponds to the dimension in groupings at same position X. X is the position relative to the right end. if\n+   * keyDimensions contain the grouping dimension at position X, the bit is set to 1 at position X, otherwise it is\n+   * set to 0. An example adapted from Microsoft SQL documentation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyOTE4Mg=="}, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzExODMzMw==", "bodyText": "Good catch @jihoonson. The doc is fixed in the most recent version. I will change our impl as well.", "url": "https://github.com/apache/druid/pull/10518#discussion_r533118333", "createdAt": "2020-12-01T07:19:15Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.annotations.EverythingIsNonnullByDefault;\n+import org.apache.druid.query.aggregation.constant.LongConstantAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantBufferAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantVectorAggregator;\n+import org.apache.druid.query.cache.CacheKeyBuilder;\n+import org.apache.druid.segment.ColumnInspector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.vector.VectorColumnSelectorFactory;\n+import org.apache.druid.utils.CollectionUtils;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@EverythingIsNonnullByDefault\n+public class GroupingAggregatorFactory extends AggregatorFactory\n+{\n+  private static final Comparator<Long> VALUE_COMPARATOR = Long::compare;\n+  private final String name;\n+  private final List<String> groupings;\n+  private final long value;\n+  @Nullable\n+  private final Set<String> keyDimensions;\n+\n+  @JsonCreator\n+  public GroupingAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"groupings\") List<String> groupings\n+  )\n+  {\n+    this(name, groupings, null);\n+  }\n+\n+  @VisibleForTesting\n+  GroupingAggregatorFactory(\n+      String name,\n+      List<String> groupings,\n+      @Nullable Set<String> keyDimensions\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    this.name = name;\n+    this.groupings = groupings;\n+    this.keyDimensions = keyDimensions;\n+    value = groupingId(groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantAggregator(value);\n+  }\n+\n+  @Override\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantBufferAggregator(value);\n+  }\n+\n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+    return new LongConstantVectorAggregator(value);\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    return true;\n+  }\n+\n+  /**\n+   * Replace the param {@code keyDimensions} with the new set of key dimensions\n+   */\n+  public GroupingAggregatorFactory withKeyDimensions(Set<String> newKeyDimensions)\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, newKeyDimensions);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return VALUE_COMPARATOR;\n+  }\n+\n+  @JsonProperty\n+  public List<String> getGroupings()\n+  {\n+    return groupings;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  public long getValue()\n+  {\n+    return value;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (null == lhs) {\n+      return rhs;\n+    }\n+    return lhs;\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new GroupingAggregatorFactory(name, groupings, keyDimensions));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    // The aggregator doesn't need to read any fields.\n+    return Collections.emptyList();\n+  }\n+\n+  @Override\n+  public ValueType getType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public ValueType getFinalizedType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Long.BYTES;\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    CacheKeyBuilder keyBuilder = new CacheKeyBuilder(AggregatorUtil.GROUPING_CACHE_TYPE_ID)\n+        .appendStrings(groupings);\n+    if (null != keyDimensions) {\n+      keyBuilder.appendStrings(keyDimensions);\n+    }\n+    return keyBuilder.build();\n+  }\n+\n+  /**\n+   * Gives the list of grouping dimensions, return a long value where each bit at position X in the returned value\n+   * corresponds to the dimension in groupings at same position X. X is the position relative to the right end. if\n+   * keyDimensions contain the grouping dimension at position X, the bit is set to 1 at position X, otherwise it is\n+   * set to 0. An example adapted from Microsoft SQL documentation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyOTE4Mg=="}, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNzA5NjAxOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/constant/LongConstantAggregator.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxMTo1Mjo0MVrOHrL0Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMjo0NDoxMFrOH8Qz7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA0NDQ1NA==", "bodyText": "It might be worth making it so these constant aggregators use the no-op aggregators as base classes, so that only the get methods need to be overridden, to let these implementations be a bit more concise.", "url": "https://github.com/apache/druid/pull/10518#discussion_r515044454", "createdAt": "2020-10-30T11:52:41Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/constant/LongConstantAggregator.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.constant;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+\n+public class LongConstantAggregator implements Aggregator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0NzY5OQ==", "bodyText": "Ack", "url": "https://github.com/apache/druid/pull/10518#discussion_r515947699", "createdAt": "2020-11-02T12:48:08Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/constant/LongConstantAggregator.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.constant;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+\n+public class LongConstantAggregator implements Aggregator", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA0NDQ1NA=="}, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk0OTI0NQ==", "bodyText": "Those No-op aggregators are final classes so can't be extended. I don't see a clear reason why they are declared final. do you?", "url": "https://github.com/apache/druid/pull/10518#discussion_r515949245", "createdAt": "2020-11-02T12:50:46Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/constant/LongConstantAggregator.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.constant;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+\n+public class LongConstantAggregator implements Aggregator", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA0NDQ1NA=="}, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk1MjA0Nw==", "bodyText": "If we rewrite the query to not include GroupingAggregatorFactory as I commented below, these aggregators won't be no longer in use.  GroupingAggregatorFactory can throw an exception instead when factorize() is called.", "url": "https://github.com/apache/druid/pull/10518#discussion_r532952047", "createdAt": "2020-11-30T22:44:10Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/constant/LongConstantAggregator.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.constant;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+\n+public class LongConstantAggregator implements Aggregator", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA0NDQ1NA=="}, "originalCommit": {"oid": "60f1041472a1b14cfd98359fcddca27e07bd9da0"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxMDkwMzU5OnYy", "diffSide": "RIGHT", "path": "docs/querying/aggregations.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDoxMjo1NFrOH3kqGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQwMDoxMjo1NFrOH3kqGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAzNDMzMQ==", "bodyText": "typo: though -> thought", "url": "https://github.com/apache/druid/pull/10518#discussion_r528034331", "createdAt": "2020-11-21T00:12:54Z", "author": {"login": "jihoonson"}, "path": "docs/querying/aggregations.md", "diffHunk": "@@ -426,3 +426,25 @@ This makes it possible to compute the results of a filtered and an unfiltered ag\n   \"aggregator\" : <aggregation>\n }\n ```\n+\n+### Grouping Aggregator\n+\n+A grouping aggregator can only be used as part of GroupBy queries which have a subtotal spec. It returns a number for\n+each output row that lets you infer whether a particular dimension is included in the sub-grouping used for that row. You can pass\n+a *non-empty* list of dimensions to this aggregator which *must* be a subset of dimensions that you are grouping on. \n+E.g if the aggregator has `[\"dim1\", \"dim2\"]` as input dimensions and `[[\"dim1\", \"dim2\"], [\"dim1\"], [\"dim2\"], []]` as subtotals, \n+following can be the possible output of the aggregator\n+\n+| subtotal used in query | Output | (bits representation) |\n+|------------------------|--------|-----------------------|\n+| `[\"dim1\", \"dim2\"]`       | 3      | (11)                  |\n+| `[\"dim1\"]`               | 2      | (10)                  |\n+| `[\"dim2\"]`               | 1      | (01)                  |\n+| `[]`                     | 0      | (00)                  |  \n+\n+As illustrated in above example, output number can be though of as an unsigned n bit number where n is the number of dimensions passed to the aggregator. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18ec231dc043f845b884ebb7f7d4948bf08b0f37"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MTAyNzk3OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMjo0NzoyNlrOH-4kwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMjo0NzoyNlrOH-4kwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcwMDY3Mg==", "bodyText": "Please add some javadoc. It would be nice to include but not necessarily limited to the followings.\n\nThis factory is for computing grouping function.\nThis factory can create LongConstant*Aggregators. Unlike other aggregators, these LongConstant*Aggregators created by this factory does nothing with computing grouping function. Instead, they are used just to hold the positions of grouping results in the ResultRow.\nThe actual computation of grouping function is done before processing each subtotal. The result of LongConstant*Aggregators is not used but replaced with the precomputed result when iterating the result of subtotal computation. See RowBasedGrouperHelper.makeGrouperIterator() for more details.\nThere could be some different approach to implement the same functionality. We chose this approach because it seems more stable and less complex than others. See #10518 (comment) for more details.", "url": "https://github.com/apache/druid/pull/10518#discussion_r535700672", "createdAt": "2020-12-03T22:47:26Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.annotations.EverythingIsNonnullByDefault;\n+import org.apache.druid.query.aggregation.constant.LongConstantAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantBufferAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantVectorAggregator;\n+import org.apache.druid.query.cache.CacheKeyBuilder;\n+import org.apache.druid.segment.ColumnInspector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.vector.VectorColumnSelectorFactory;\n+import org.apache.druid.utils.CollectionUtils;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@EverythingIsNonnullByDefault\n+public class GroupingAggregatorFactory extends AggregatorFactory", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ae99fc38e42da00853fd9343b777f95e793df89"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MTE1NjQ4OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMzoyMjozM1rOH-5tJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMzoyMjozM1rOH-5tJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcxOTIwNg==", "bodyText": "I think we can just drop the last statement here. It's opposite to what their documentation says anyway.", "url": "https://github.com/apache/druid/pull/10518#discussion_r535719206", "createdAt": "2020-12-03T23:22:33Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.annotations.EverythingIsNonnullByDefault;\n+import org.apache.druid.query.aggregation.constant.LongConstantAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantBufferAggregator;\n+import org.apache.druid.query.aggregation.constant.LongConstantVectorAggregator;\n+import org.apache.druid.query.cache.CacheKeyBuilder;\n+import org.apache.druid.segment.ColumnInspector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.column.ValueType;\n+import org.apache.druid.segment.vector.VectorColumnSelectorFactory;\n+import org.apache.druid.utils.CollectionUtils;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+@EverythingIsNonnullByDefault\n+public class GroupingAggregatorFactory extends AggregatorFactory\n+{\n+  private static final Comparator<Long> VALUE_COMPARATOR = Long::compare;\n+  private final String name;\n+  private final List<String> groupings;\n+  private final long value;\n+  @Nullable\n+  private final Set<String> keyDimensions;\n+\n+  @JsonCreator\n+  public GroupingAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"groupings\") List<String> groupings\n+  )\n+  {\n+    this(name, groupings, null);\n+  }\n+\n+  @VisibleForTesting\n+  GroupingAggregatorFactory(\n+      String name,\n+      List<String> groupings,\n+      @Nullable Set<String> keyDimensions\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    this.name = name;\n+    this.groupings = groupings;\n+    this.keyDimensions = keyDimensions;\n+    value = groupingId(groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public Aggregator factorize(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantAggregator(value);\n+  }\n+\n+  @Override\n+  public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n+  {\n+    return new LongConstantBufferAggregator(value);\n+  }\n+\n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+    return new LongConstantVectorAggregator(value);\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    return true;\n+  }\n+\n+  /**\n+   * Replace the param {@code keyDimensions} with the new set of key dimensions\n+   */\n+  public GroupingAggregatorFactory withKeyDimensions(Set<String> newKeyDimensions)\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, newKeyDimensions);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return VALUE_COMPARATOR;\n+  }\n+\n+  @JsonProperty\n+  public List<String> getGroupings()\n+  {\n+    return groupings;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  public long getValue()\n+  {\n+    return value;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (null == lhs) {\n+      return rhs;\n+    }\n+    return lhs;\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new GroupingAggregatorFactory(name, groupings, keyDimensions);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new GroupingAggregatorFactory(name, groupings, keyDimensions));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    // The aggregator doesn't need to read any fields.\n+    return Collections.emptyList();\n+  }\n+\n+  @Override\n+  public ValueType getType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public ValueType getFinalizedType()\n+  {\n+    return ValueType.LONG;\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Long.BYTES;\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    CacheKeyBuilder keyBuilder = new CacheKeyBuilder(AggregatorUtil.GROUPING_CACHE_TYPE_ID)\n+        .appendStrings(groupings);\n+    if (null != keyDimensions) {\n+      keyBuilder.appendStrings(keyDimensions);\n+    }\n+    return keyBuilder.build();\n+  }\n+\n+  /**\n+   * Given the list of grouping dimensions, returns a long value where each bit at position X in the returned value\n+   * corresponds to the dimension in groupings at same position X. X is the position relative to the right end. if\n+   * keyDimensions contain the grouping dimension at position X, the bit is set to 0 at position X, otherwise it is\n+   * set to 1. An example adapted from Microsoft SQL documentation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ae99fc38e42da00853fd9343b777f95e793df89"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MTE2Mjk5OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/RowBasedGrouperHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMzoyNDo0N1rOH-5wyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QyMzoyNDo0N1rOH-5wyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTcyMDEzOQ==", "bodyText": "Please add some comment about what is happening here.", "url": "https://github.com/apache/druid/pull/10518#discussion_r535720139", "createdAt": "2020-12-03T23:24:47Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/RowBasedGrouperHelper.java", "diffHunk": "@@ -576,7 +594,12 @@ private static ValueExtractFunction makeValueExtractFunction(\n           // Add aggregations.\n           final int resultRowAggregatorStart = query.getResultRowAggregatorStart();\n           for (int i = 0; i < entry.getValues().length; i++) {\n-            resultRow.set(resultRowAggregatorStart + i, entry.getValues()[i]);\n+            if (dimsToInclude != null && groupingAggregatorsBitSet.get(i)) {\n+              resultRow.set(resultRowAggregatorStart + i, groupingAggregatorValues[i]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ae99fc38e42da00853fd9343b777f95e793df89"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjIxNzIwOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzo1NzozMlrOH_maUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzo1NzozMlrOH_maUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ1MTY2Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *                             {@code groupings0}. This argument cannot be passed by the user. It is set by druid engine\n          \n          \n            \n             *                             {@code groupings}. This argument cannot be passed by the user. It is set by druid engine", "url": "https://github.com/apache/druid/pull/10518#discussion_r536451667", "createdAt": "2020-12-04T23:57:32Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "diffHunk": "@@ -41,6 +41,40 @@\n import java.util.Objects;\n import java.util.Set;\n \n+/**\n+ * This class implements {@code grouping_id} function to determine the grouping that a row is part of. Different rows\n+ * in same result could have different grouping columns when subtotals are used.\n+ *\n+ * It takes following arguments\n+ *  - {@code name} - Name of aggregators\n+ *  - {code groupings} - List of dimensions that user is interested in tracking\n+ *  - {@code keyDimensions} - The list of grouping dimensions being included in the result row. This list is a subset of\n+ *                             {@code groupings0}. This argument cannot be passed by the user. It is set by druid engine", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6dd363203dd13d21657ebf38af0a837df96218e4"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjIxODcxOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzo1ODoyNFrOH_mbIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQyMzo1ODoyNFrOH_mbIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ1MTg3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *  - {code groupings} - List of dimensions that user is interested in tracking\n          \n          \n            \n             *  - {@code groupings} - List of dimensions that user is interested in tracking", "url": "https://github.com/apache/druid/pull/10518#discussion_r536451874", "createdAt": "2020-12-04T23:58:24Z", "author": {"login": "jihoonson"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/GroupingAggregatorFactory.java", "diffHunk": "@@ -41,6 +41,40 @@\n import java.util.Objects;\n import java.util.Set;\n \n+/**\n+ * This class implements {@code grouping_id} function to determine the grouping that a row is part of. Different rows\n+ * in same result could have different grouping columns when subtotals are used.\n+ *\n+ * It takes following arguments\n+ *  - {@code name} - Name of aggregators\n+ *  - {code groupings} - List of dimensions that user is interested in tracking", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6dd363203dd13d21657ebf38af0a837df96218e4"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2NjI2MDk3OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/RowBasedGrouperHelper.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMDoxODozOFrOH_mwOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMDoxODozOFrOH_mwOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ1NzI3NA==", "bodyText": "nit: javadoc comment format on inline comment", "url": "https://github.com/apache/druid/pull/10518#discussion_r536457274", "createdAt": "2020-12-05T00:18:38Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/epinephelinae/RowBasedGrouperHelper.java", "diffHunk": "@@ -534,21 +536,45 @@ private static ValueExtractFunction makeValueExtractFunction(\n   public static CloseableGrouperIterator<RowBasedKey, ResultRow> makeGrouperIterator(\n       final Grouper<RowBasedKey> grouper,\n       final GroupByQuery query,\n-      @Nullable final List<String> dimsToInclude,\n+      @Nullable final List<DimensionSpec> dimsToInclude,\n       final Closeable closeable\n   )\n   {\n     final boolean includeTimestamp = query.getResultRowHasTimestamp();\n     final BitSet dimsToIncludeBitSet = new BitSet(query.getDimensions().size());\n     final int resultRowDimensionStart = query.getResultRowDimensionStart();\n+    final BitSet groupingAggregatorsBitSet = new BitSet(query.getAggregatorSpecs().size());\n+    final Object[] groupingAggregatorValues = new Long[query.getAggregatorSpecs().size()];\n \n     if (dimsToInclude != null) {\n-      for (String dimension : dimsToInclude) {\n-        final int dimIndex = query.getResultRowSignature().indexOf(dimension);\n+      for (DimensionSpec dimensionSpec : dimsToInclude) {\n+        String outputName = dimensionSpec.getOutputName();\n+        final int dimIndex = query.getResultRowSignature().indexOf(outputName);\n         if (dimIndex >= 0) {\n           dimsToIncludeBitSet.set(dimIndex - resultRowDimensionStart);\n         }\n       }\n+\n+      /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6dd363203dd13d21657ebf38af0a837df96218e4"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MTMxNzk5OnYy", "diffSide": "RIGHT", "path": "docs/querying/sql.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjo1MjoxNFrOIBpLfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNzozODoxMFrOIBsRvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU5NDE3NA==", "bodyText": "@abhishekagarwal87 I don't think this anchor will work (our doc generators don't include spaces in anchors). Could you please double-check it?", "url": "https://github.com/apache/druid/pull/10518#discussion_r538594174", "createdAt": "2020-12-08T16:52:14Z", "author": {"login": "gianm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -337,6 +338,7 @@ Only the COUNT aggregation can accept DISTINCT.\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`ANY_VALUE(expr)`|Returns any value of `expr` including null. `expr` must be numeric. This aggregator can simplify and optimize the performance by returning the first encountered value (including null)|\n |`ANY_VALUE(expr, maxBytesPerString)`|Like `ANY_VALUE(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n+|`GROUPING(expr, expr...)`|Returns a number to indicate which groupBy dimension is included in a row, when using `GROUPING SETS`. Refer to [additional documentation](aggregations.md#Grouping Aggregator) on how to infer this number.|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8678c78d770bce2dda47a4dc15589ead42243bc4"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY0NDkyNg==", "bodyText": "Good catch. Even github doesn't render it correctly though intellij does it. Fixed in PR\n#10654", "url": "https://github.com/apache/druid/pull/10518#discussion_r538644926", "createdAt": "2020-12-08T17:38:10Z", "author": {"login": "abhishekagarwal87"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -337,6 +338,7 @@ Only the COUNT aggregation can accept DISTINCT.\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`ANY_VALUE(expr)`|Returns any value of `expr` including null. `expr` must be numeric. This aggregator can simplify and optimize the performance by returning the first encountered value (including null)|\n |`ANY_VALUE(expr, maxBytesPerString)`|Like `ANY_VALUE(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n+|`GROUPING(expr, expr...)`|Returns a number to indicate which groupBy dimension is included in a row, when using `GROUPING SETS`. Refer to [additional documentation](aggregations.md#Grouping Aggregator) on how to infer this number.|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU5NDE3NA=="}, "originalCommit": {"oid": "8678c78d770bce2dda47a4dc15589ead42243bc4"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MTMyMjQ4OnYy", "diffSide": "RIGHT", "path": "docs/querying/sql.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjo1Mjo1MFrOIBpOZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNzozODozN1rOIBsTtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU5NDkxNw==", "bodyText": "@abhishekagarwal87 Extraneous whitespace before the , might interfere with rendering. (I'm not sure, but it looks suspicious.)", "url": "https://github.com/apache/druid/pull/10518#discussion_r538594917", "createdAt": "2020-12-08T16:52:50Z", "author": {"login": "gianm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -99,7 +99,8 @@ total. Finally, GROUP BY CUBE computes a grouping set for each combination of gr\n `GROUP BY CUBE (country, city)` is equivalent to `GROUP BY GROUPING SETS ( (country, city), (country), (city), () )`.\n Grouping columns that do not apply to a particular row will contain `NULL`. For example, when computing\n `GROUP BY GROUPING SETS ( (country, city), () )`, the grand total row corresponding to `()` will have `NULL` for the\n-\"country\" and \"city\" columns.\n+\"country\" and \"city\" columns. Column may also be `NULL` if it was `NULL` in the data itself. To differentiate such rows\n+, you can use `GROUPING` aggregation. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8678c78d770bce2dda47a4dc15589ead42243bc4"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY0NTQzMA==", "bodyText": "Re-worked this a bit in #10654", "url": "https://github.com/apache/druid/pull/10518#discussion_r538645430", "createdAt": "2020-12-08T17:38:37Z", "author": {"login": "abhishekagarwal87"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -99,7 +99,8 @@ total. Finally, GROUP BY CUBE computes a grouping set for each combination of gr\n `GROUP BY CUBE (country, city)` is equivalent to `GROUP BY GROUPING SETS ( (country, city), (country), (city), () )`.\n Grouping columns that do not apply to a particular row will contain `NULL`. For example, when computing\n `GROUP BY GROUPING SETS ( (country, city), () )`, the grand total row corresponding to `()` will have `NULL` for the\n-\"country\" and \"city\" columns.\n+\"country\" and \"city\" columns. Column may also be `NULL` if it was `NULL` in the data itself. To differentiate such rows\n+, you can use `GROUPING` aggregation. ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU5NDkxNw=="}, "originalCommit": {"oid": "8678c78d770bce2dda47a4dc15589ead42243bc4"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3036, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}