{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5MDg5MDMw", "number": 9122, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODoxMTowNVrODibP6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzozNTowOFrODi5Fjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NDI0NjE2OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/groupby/GroupByQuery.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODoxMTowNVrOFtql9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOTo0ODoyNVrOFuS32g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyODA4Nw==", "bodyText": "EqualsVerifier Test for this please", "url": "https://github.com/apache/druid/pull/9122#discussion_r383428087", "createdAt": "2020-02-24T18:11:05Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/GroupByQuery.java", "diffHunk": "@@ -1236,7 +1243,8 @@ public int hashCode()\n         dimFilter,\n         dimensions,\n         aggregatorSpecs,\n-        postAggregatorSpecs\n+        postAggregatorSpecs,\n+        subtotalsSpec", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4ODAyNg==", "bodyText": "OK, I added it.", "url": "https://github.com/apache/druid/pull/9122#discussion_r384088026", "createdAt": "2020-02-25T19:48:25Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/GroupByQuery.java", "diffHunk": "@@ -1236,7 +1243,8 @@ public int hashCode()\n         dimFilter,\n         dimensions,\n         aggregatorSpecs,\n-        postAggregatorSpecs\n+        postAggregatorSpecs,\n+        subtotalsSpec", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyODA4Nw=="}, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NDI1MzQ0OnYy", "diffSide": "RIGHT", "path": "docs/querying/sql.md", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODoxMzoyN1rOFtqqbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMToyNToyNFrOFuVv0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyOTIzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When using GROUP BY GROUPING SETS, GROUP BY ROLLUP, or GROUP BY CUBE, be aware that results may not be generated in the\n          \n          \n            \n            When using `GROUP BY GROUPING SETS`, `GROUP BY ROLLUP`, or `GROUP BY CUBE`, be aware that results may not be generated in the", "url": "https://github.com/apache/druid/pull/9122#discussion_r383429231", "createdAt": "2020-02-24T18:13:27Z", "author": {"login": "suneet-s"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -86,6 +86,22 @@ trigger an aggregation query using one of Druid's [three native aggregation quer\n can refer to an expression or a select clause ordinal position (like `GROUP BY 2` to group by the second selected\n column).\n \n+The GROUP BY clause can also refer to multiple grouping sets in three ways. The most flexible is GROUP BY GROUPING SETS,\n+for example `GROUP BY GROUPING SETS ( (country, city), () )`. This example is equivalent to a `GROUP BY country, city`\n+followed by `GROUP BY ()` (a grand total). With GROUPING SETS, the underlying data is only scanned one time, leading to\n+better efficiency. Second, GROUP BY ROLLUP computes a grouping set for each level of the grouping expressions. For\n+example `GROUP BY ROLLUP (country, city)` is equivalent to `GROUP BY GROUPING SETS ( (country, city), (country), () )`\n+and will produce grouped rows for each country / city pair, along with subtotals for each country, along with a grand\n+total. Finally, GROUP BY CUBE computes a grouping set for each combination of grouping expressions. For example,\n+`GROUP BY CUBE (country, city)` is equivalent to `GROUP BY GROUPING SETS ( (country, city), (country), (city), () )`.\n+Grouping columns that do not apply to a particular row will contain `NULL`. For example, when computing\n+`GROUP BY GROUPING SETS ( (country, city), () )`, the grand total row corresponding to `()` will have `NULL` for the\n+\"country\" and \"city\" columns.\n+\n+When using GROUP BY GROUPING SETS, GROUP BY ROLLUP, or GROUP BY CUBE, be aware that results may not be generated in the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4NTIxNQ==", "bodyText": "Other paragraphs in this section use plain text for simple keywords and preformatted text for examples; see https://druid.apache.org/docs/latest/querying/sql.html.\nThis can be changed but I wanted to keep it consistent in this patch.\nWhat do you think?", "url": "https://github.com/apache/druid/pull/9122#discussion_r384085215", "createdAt": "2020-02-25T19:43:14Z", "author": {"login": "gianm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -86,6 +86,22 @@ trigger an aggregation query using one of Druid's [three native aggregation quer\n can refer to an expression or a select clause ordinal position (like `GROUP BY 2` to group by the second selected\n column).\n \n+The GROUP BY clause can also refer to multiple grouping sets in three ways. The most flexible is GROUP BY GROUPING SETS,\n+for example `GROUP BY GROUPING SETS ( (country, city), () )`. This example is equivalent to a `GROUP BY country, city`\n+followed by `GROUP BY ()` (a grand total). With GROUPING SETS, the underlying data is only scanned one time, leading to\n+better efficiency. Second, GROUP BY ROLLUP computes a grouping set for each level of the grouping expressions. For\n+example `GROUP BY ROLLUP (country, city)` is equivalent to `GROUP BY GROUPING SETS ( (country, city), (country), () )`\n+and will produce grouped rows for each country / city pair, along with subtotals for each country, along with a grand\n+total. Finally, GROUP BY CUBE computes a grouping set for each combination of grouping expressions. For example,\n+`GROUP BY CUBE (country, city)` is equivalent to `GROUP BY GROUPING SETS ( (country, city), (country), (city), () )`.\n+Grouping columns that do not apply to a particular row will contain `NULL`. For example, when computing\n+`GROUP BY GROUPING SETS ( (country, city), () )`, the grand total row corresponding to `()` will have `NULL` for the\n+\"country\" and \"city\" columns.\n+\n+When using GROUP BY GROUPING SETS, GROUP BY ROLLUP, or GROUP BY CUBE, be aware that results may not be generated in the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyOTIzMQ=="}, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwMTY5Ng==", "bodyText": "I think we can keep to the prevailing convention of plain text for inline keywords, with all caps providing the formatting distinction.\nThe underlying point is taken though\u2014a series of keywords like this makes the text a little hard to scan.  One possible workaround, if the problem warrants it, would be to restructure the sentence to put the keywords in bullet format. For example --\n\nWhen using the following, be aware that results may not be generated in the order that you specify your grouping sets in the query:\n\nGROUP BY GROUPING SETS\nGROUP BY ROLLUP\nGROUP BY CUBE\n\nIf you need results... \"", "url": "https://github.com/apache/druid/pull/9122#discussion_r384101696", "createdAt": "2020-02-25T20:15:04Z", "author": {"login": "sthetland"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -86,6 +86,22 @@ trigger an aggregation query using one of Druid's [three native aggregation quer\n can refer to an expression or a select clause ordinal position (like `GROUP BY 2` to group by the second selected\n column).\n \n+The GROUP BY clause can also refer to multiple grouping sets in three ways. The most flexible is GROUP BY GROUPING SETS,\n+for example `GROUP BY GROUPING SETS ( (country, city), () )`. This example is equivalent to a `GROUP BY country, city`\n+followed by `GROUP BY ()` (a grand total). With GROUPING SETS, the underlying data is only scanned one time, leading to\n+better efficiency. Second, GROUP BY ROLLUP computes a grouping set for each level of the grouping expressions. For\n+example `GROUP BY ROLLUP (country, city)` is equivalent to `GROUP BY GROUPING SETS ( (country, city), (country), () )`\n+and will produce grouped rows for each country / city pair, along with subtotals for each country, along with a grand\n+total. Finally, GROUP BY CUBE computes a grouping set for each combination of grouping expressions. For example,\n+`GROUP BY CUBE (country, city)` is equivalent to `GROUP BY GROUPING SETS ( (country, city), (country), (city), () )`.\n+Grouping columns that do not apply to a particular row will contain `NULL`. For example, when computing\n+`GROUP BY GROUPING SETS ( (country, city), () )`, the grand total row corresponding to `()` will have `NULL` for the\n+\"country\" and \"city\" columns.\n+\n+When using GROUP BY GROUPING SETS, GROUP BY ROLLUP, or GROUP BY CUBE, be aware that results may not be generated in the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyOTIzMQ=="}, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEzNTEyMQ==", "bodyText": "No need to change if this is an existing pattern", "url": "https://github.com/apache/druid/pull/9122#discussion_r384135121", "createdAt": "2020-02-25T21:25:24Z", "author": {"login": "suneet-s"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -86,6 +86,22 @@ trigger an aggregation query using one of Druid's [three native aggregation quer\n can refer to an expression or a select clause ordinal position (like `GROUP BY 2` to group by the second selected\n column).\n \n+The GROUP BY clause can also refer to multiple grouping sets in three ways. The most flexible is GROUP BY GROUPING SETS,\n+for example `GROUP BY GROUPING SETS ( (country, city), () )`. This example is equivalent to a `GROUP BY country, city`\n+followed by `GROUP BY ()` (a grand total). With GROUPING SETS, the underlying data is only scanned one time, leading to\n+better efficiency. Second, GROUP BY ROLLUP computes a grouping set for each level of the grouping expressions. For\n+example `GROUP BY ROLLUP (country, city)` is equivalent to `GROUP BY GROUPING SETS ( (country, city), (country), () )`\n+and will produce grouped rows for each country / city pair, along with subtotals for each country, along with a grand\n+total. Finally, GROUP BY CUBE computes a grouping set for each combination of grouping expressions. For example,\n+`GROUP BY CUBE (country, city)` is equivalent to `GROUP BY GROUPING SETS ( (country, city), (country), (city), () )`.\n+Grouping columns that do not apply to a particular row will contain `NULL`. For example, when computing\n+`GROUP BY GROUPING SETS ( (country, city), () )`, the grand total row corresponding to `()` will have `NULL` for the\n+\"country\" and \"city\" columns.\n+\n+When using GROUP BY GROUPING SETS, GROUP BY ROLLUP, or GROUP BY CUBE, be aware that results may not be generated in the", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQyOTIzMQ=="}, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NDI2Nzc1OnYy", "diffSide": "RIGHT", "path": "docs/querying/sql.md", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODoxODoxMlrOFtqzQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMToyNDoxOFrOFuVt6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzMTQ5MQ==", "bodyText": "This is cool...  I learnt some new SQL today \ud83d\udc4d\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            [ GROUP BY [ exprs | GROUPING SETS ( (exprs), ... ) | ROLLUP (exprs) | CUBE (exprs) ] ]\n          \n          \n            \n            [ GROUP BY [ exprs | GROUPING SETS ( \\(exprs\\), ... ) | ROLLUP \\(exprs\\) | CUBE \\(exprs\\) ] ]\n          \n      \n    \n    \n  \n\nBased on the examples below, the parenthesis are required correct?\nI think in other places in the docs parenthesis don't mean literal characters, but you want them to be literal characters here?", "url": "https://github.com/apache/druid/pull/9122#discussion_r383431491", "createdAt": "2020-02-24T18:18:12Z", "author": {"login": "suneet-s"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -65,7 +65,7 @@ Druid SQL supports SELECT queries with the following structure:\n SELECT [ ALL | DISTINCT ] { * | exprs }\n FROM table\n [ WHERE expr ]\n-[ GROUP BY exprs ]\n+[ GROUP BY [ exprs | GROUPING SETS ( (exprs), ... ) | ROLLUP (exprs) | CUBE (exprs) ] ]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4NTcxMw==", "bodyText": "The parentheses mean literal characters here and everywhere else they appear in this example. The brackets, however, don't.", "url": "https://github.com/apache/druid/pull/9122#discussion_r384085713", "createdAt": "2020-02-25T19:44:10Z", "author": {"login": "gianm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -65,7 +65,7 @@ Druid SQL supports SELECT queries with the following structure:\n SELECT [ ALL | DISTINCT ] { * | exprs }\n FROM table\n [ WHERE expr ]\n-[ GROUP BY exprs ]\n+[ GROUP BY [ exprs | GROUPING SETS ( (exprs), ... ) | ROLLUP (exprs) | CUBE (exprs) ] ]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzMTQ5MQ=="}, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEzNDYzMg==", "bodyText": "I was thrown off by this in the docs\n[ EXPLAIN PLAN FOR ] [ WITH tableName [ ( column1, column2, ... ) ] AS ( query ) ]\nI didn't realize the parenthesis were required in this statement . I couldn't get an EXPLAIN query to work locally for me in the UI.", "url": "https://github.com/apache/druid/pull/9122#discussion_r384134632", "createdAt": "2020-02-25T21:24:18Z", "author": {"login": "suneet-s"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -65,7 +65,7 @@ Druid SQL supports SELECT queries with the following structure:\n SELECT [ ALL | DISTINCT ] { * | exprs }\n FROM table\n [ WHERE expr ]\n-[ GROUP BY exprs ]\n+[ GROUP BY [ exprs | GROUPING SETS ( (exprs), ... ) | ROLLUP (exprs) | CUBE (exprs) ] ]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQzMTQ5MQ=="}, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NDMzMjY2OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/groupby/strategy/GroupByStrategyV2.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxODozODoxN1rOFtrasg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMToxMzozNVrOFuVZGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MTU4Ng==", "bodyText": "not really part of this change - maybe worth filing an issue for. The with... interface returns a query object, so chaining doesn't really make sense here. Maybe we should consider making that return the Builder so callers can call .build() when they're done setting all the fields. In this example it looks like it creates 4 intermediate GroupByQyery objects and a Builder for each object", "url": "https://github.com/apache/druid/pull/9122#discussion_r383441586", "createdAt": "2020-02-24T18:38:17Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/strategy/GroupByStrategyV2.java", "diffHunk": "@@ -369,13 +374,13 @@ public boolean doMergeResults(final GroupByQuery query)\n                    .map(AggregatorFactory::getCombiningFactory)\n                    .collect(Collectors.toList())\n           )\n-          .withSubtotalsSpec(null)\n-          .withDimFilter(null);\n-\n+          .withVirtualColumns(VirtualColumns.EMPTY)\n+          .withDimFilter(null)\n+          .withSubtotalsSpec(null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4NjIxMw==", "bodyText": "What do you mean by 'make sense'? It makes sense to me in that you have an immutable object (the GroupByQuery) and you are using chaining to create a derived copy.", "url": "https://github.com/apache/druid/pull/9122#discussion_r384086213", "createdAt": "2020-02-25T19:45:09Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/strategy/GroupByStrategyV2.java", "diffHunk": "@@ -369,13 +374,13 @@ public boolean doMergeResults(final GroupByQuery query)\n                    .map(AggregatorFactory::getCombiningFactory)\n                    .collect(Collectors.toList())\n           )\n-          .withSubtotalsSpec(null)\n-          .withDimFilter(null);\n-\n+          .withVirtualColumns(VirtualColumns.EMPTY)\n+          .withDimFilter(null)\n+          .withSubtotalsSpec(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MTU4Ng=="}, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyOTMwNQ==", "bodyText": "Sorry, I should have phrased that better.\nI meant that there seems to be a lot of overlap between the .with... functions and the GroupByQuery.Builder functions. When I saw that pattern, I was wondering how do you choose between the 2. And since both exist, I may not pick the correct one.\nNothing to change here - just my stream of thought while reading the code.", "url": "https://github.com/apache/druid/pull/9122#discussion_r384129305", "createdAt": "2020-02-25T21:13:35Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/strategy/GroupByStrategyV2.java", "diffHunk": "@@ -369,13 +374,13 @@ public boolean doMergeResults(final GroupByQuery query)\n                    .map(AggregatorFactory::getCombiningFactory)\n                    .collect(Collectors.toList())\n           )\n-          .withSubtotalsSpec(null)\n-          .withDimFilter(null);\n-\n+          .withVirtualColumns(VirtualColumns.EMPTY)\n+          .withDimFilter(null)\n+          .withSubtotalsSpec(null);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ0MTU4Ng=="}, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NDQwNzI2OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQuery.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxOTowMToxOFrOFtsJRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMTowODozNVrOFuVPfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1MzUwOQ==", "bodyText": "nit: it's cheaper to check if havingFilter != null before checking hasEffect", "url": "https://github.com/apache/druid/pull/9122#discussion_r383453509", "createdAt": "2020-02-24T19:01:18Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQuery.java", "diffHunk": "@@ -706,7 +722,9 @@ private Query computeQuery()\n   @Nullable\n   public TimeseriesQuery toTimeseriesQuery()\n   {\n-    if (grouping == null || grouping.getHavingFilter() != null) {\n+    if (grouping == null\n+        || grouping.getSubtotals().hasEffect(grouping.getDimensionSpecs())\n+        || grouping.getHavingFilter() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4Njc3OQ==", "bodyText": "It's probably going to be an exceedingly small effect, I'd like to leave it this way if you don't mind.", "url": "https://github.com/apache/druid/pull/9122#discussion_r384086779", "createdAt": "2020-02-25T19:46:03Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQuery.java", "diffHunk": "@@ -706,7 +722,9 @@ private Query computeQuery()\n   @Nullable\n   public TimeseriesQuery toTimeseriesQuery()\n   {\n-    if (grouping == null || grouping.getHavingFilter() != null) {\n+    if (grouping == null\n+        || grouping.getSubtotals().hasEffect(grouping.getDimensionSpecs())\n+        || grouping.getHavingFilter() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1MzUwOQ=="}, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyNjg0NA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/apache/druid/pull/9122#discussion_r384126844", "createdAt": "2020-02-25T21:08:35Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQuery.java", "diffHunk": "@@ -706,7 +722,9 @@ private Query computeQuery()\n   @Nullable\n   public TimeseriesQuery toTimeseriesQuery()\n   {\n-    if (grouping == null || grouping.getHavingFilter() != null) {\n+    if (grouping == null\n+        || grouping.getSubtotals().hasEffect(grouping.getDimensionSpecs())\n+        || grouping.getHavingFilter() != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1MzUwOQ=="}, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NDQzNDQzOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/Subtotals.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxOToxMDowM1rOFtsaSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMTowODoyMFrOFuVPBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1Nzg2Ng==", "bodyText": "equals and hashCode for List<List> can be expensive. Is this concerning? Should we create a memoized string that represents the lists  so that the check can be faster? Or is that overkill?", "url": "https://github.com/apache/druid/pull/9122#discussion_r383457866", "createdAt": "2020-02-24T19:10:03Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/Subtotals.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rel;\n+\n+\n+import it.unimi.dsi.fastutil.ints.IntList;\n+import org.apache.druid.query.dimension.DimensionSpec;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Represents the Druid groupBy query concept of subtotals, which is similar to GROUPING SETS.\n+ */\n+public class Subtotals\n+{\n+  /**\n+   * List of subtotals: each one is a list of dimension indexes. (i.e. [0, 1] means use the first and second\n+   * dimensions).\n+   */\n+  private final List<IntList> subtotals;\n+\n+  Subtotals(List<IntList> subtotals)\n+  {\n+    this.subtotals = subtotals;\n+  }\n+\n+  public List<IntList> getSubtotals()\n+  {\n+    return subtotals;\n+  }\n+\n+  @Nullable\n+  public List<List<String>> toSubtotalsSpec(final List<DimensionSpec> dimensions)\n+  {\n+    if (hasEffect(dimensions)) {\n+      return subtotals.stream()\n+                      .map(\n+                          subtotalInts -> {\n+                            final List<String> subtotalDimensionNames = new ArrayList<>();\n+                            for (int dimIndex : subtotalInts) {\n+                              subtotalDimensionNames.add(dimensions.get(dimIndex).getOutputName());\n+                            }\n+                            return subtotalDimensionNames;\n+                          }\n+                      )\n+                      .collect(Collectors.toList());\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Returns whether this subtotals spec has an effect, and cannot be ignored.\n+   */\n+  public boolean hasEffect(final List<DimensionSpec> dimensionSpecs)\n+  {\n+    if (subtotals.isEmpty() || (subtotals.size() == 1 && subtotals.get(0).size() == dimensionSpecs.size())) {\n+      return false;\n+    } else {\n+      return true;\n+    }\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    Subtotals subtotals1 = (Subtotals) o;\n+    return subtotals.equals(subtotals1.subtotals);\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(subtotals);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4NzEzMg==", "bodyText": "I don't expect them to be called very often, and usually in that case, I don't bother memoizing (extra code to get right).", "url": "https://github.com/apache/druid/pull/9122#discussion_r384087132", "createdAt": "2020-02-25T19:46:46Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/Subtotals.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rel;\n+\n+\n+import it.unimi.dsi.fastutil.ints.IntList;\n+import org.apache.druid.query.dimension.DimensionSpec;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Represents the Druid groupBy query concept of subtotals, which is similar to GROUPING SETS.\n+ */\n+public class Subtotals\n+{\n+  /**\n+   * List of subtotals: each one is a list of dimension indexes. (i.e. [0, 1] means use the first and second\n+   * dimensions).\n+   */\n+  private final List<IntList> subtotals;\n+\n+  Subtotals(List<IntList> subtotals)\n+  {\n+    this.subtotals = subtotals;\n+  }\n+\n+  public List<IntList> getSubtotals()\n+  {\n+    return subtotals;\n+  }\n+\n+  @Nullable\n+  public List<List<String>> toSubtotalsSpec(final List<DimensionSpec> dimensions)\n+  {\n+    if (hasEffect(dimensions)) {\n+      return subtotals.stream()\n+                      .map(\n+                          subtotalInts -> {\n+                            final List<String> subtotalDimensionNames = new ArrayList<>();\n+                            for (int dimIndex : subtotalInts) {\n+                              subtotalDimensionNames.add(dimensions.get(dimIndex).getOutputName());\n+                            }\n+                            return subtotalDimensionNames;\n+                          }\n+                      )\n+                      .collect(Collectors.toList());\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Returns whether this subtotals spec has an effect, and cannot be ignored.\n+   */\n+  public boolean hasEffect(final List<DimensionSpec> dimensionSpecs)\n+  {\n+    if (subtotals.isEmpty() || (subtotals.size() == 1 && subtotals.get(0).size() == dimensionSpecs.size())) {\n+      return false;\n+    } else {\n+      return true;\n+    }\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    Subtotals subtotals1 = (Subtotals) o;\n+    return subtotals.equals(subtotals1.subtotals);\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(subtotals);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1Nzg2Ng=="}, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyNjcyNA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/apache/druid/pull/9122#discussion_r384126724", "createdAt": "2020-02-25T21:08:20Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/Subtotals.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rel;\n+\n+\n+import it.unimi.dsi.fastutil.ints.IntList;\n+import org.apache.druid.query.dimension.DimensionSpec;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Represents the Druid groupBy query concept of subtotals, which is similar to GROUPING SETS.\n+ */\n+public class Subtotals\n+{\n+  /**\n+   * List of subtotals: each one is a list of dimension indexes. (i.e. [0, 1] means use the first and second\n+   * dimensions).\n+   */\n+  private final List<IntList> subtotals;\n+\n+  Subtotals(List<IntList> subtotals)\n+  {\n+    this.subtotals = subtotals;\n+  }\n+\n+  public List<IntList> getSubtotals()\n+  {\n+    return subtotals;\n+  }\n+\n+  @Nullable\n+  public List<List<String>> toSubtotalsSpec(final List<DimensionSpec> dimensions)\n+  {\n+    if (hasEffect(dimensions)) {\n+      return subtotals.stream()\n+                      .map(\n+                          subtotalInts -> {\n+                            final List<String> subtotalDimensionNames = new ArrayList<>();\n+                            for (int dimIndex : subtotalInts) {\n+                              subtotalDimensionNames.add(dimensions.get(dimIndex).getOutputName());\n+                            }\n+                            return subtotalDimensionNames;\n+                          }\n+                      )\n+                      .collect(Collectors.toList());\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Returns whether this subtotals spec has an effect, and cannot be ignored.\n+   */\n+  public boolean hasEffect(final List<DimensionSpec> dimensionSpecs)\n+  {\n+    if (subtotals.isEmpty() || (subtotals.size() == 1 && subtotals.get(0).size() == dimensionSpecs.size())) {\n+      return false;\n+    } else {\n+      return true;\n+    }\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    Subtotals subtotals1 = (Subtotals) o;\n+    return subtotals.equals(subtotals1.subtotals);\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(subtotals);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ1Nzg2Ng=="}, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NDQ1ODc5OnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxOToxODoxMlrOFtsp_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMTowODowNVrOFuVOjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MTg4NQ==", "bodyText": "\ud83d\udc4d nice tests!\nIs GROUPING SETS ( (dummy) ) === GROUPING SETS ( () ) or should it fail?", "url": "https://github.com/apache/druid/pull/9122#discussion_r383461885", "createdAt": "2020-02-24T19:18:12Z", "author": {"login": "suneet-s"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -9579,6 +9600,538 @@ public void testGroupByTimeAndOtherDimension() throws Exception\n     );\n   }\n \n+  @Test\n+  public void testGroupingSets() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (dim2, gran), (dim2), (gran), () )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v1\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithNumericDimension() throws Exception\n+  {\n+    testQuery(\n+        \"SELECT cnt, COUNT(*)\\n\"\n+        + \"FROM foo\\n\"\n+        + \"GROUP BY GROUPING SETS ( (cnt), () )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setDimensions(dimensions(new DefaultDimensionSpec(\"cnt\", \"d0\", ValueType.LONG)))\n+                        .setAggregatorSpecs(aggregators(new CountAggregatorFactory(\"a0\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"d0\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{1L, 6L},\n+            new Object[]{null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupByRollup() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY ROLLUP (dim2, gran)\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v1\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupByCube() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY CUBE (dim2, gran)\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v1\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithDummyDimension() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (dim2, 'dummy', gran), (dim2), (gran), ('dummy') )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v2\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v2\", \"v2\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v2\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(),\n+                                ImmutableList.of(\"v2\")\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, null, 6L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsNoSuperset() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    // Note: the grouping sets are reordered in the output of this query, but this is allowed.\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (), (dim2), (gran) )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithOrderByDimension() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (), (dim2), (gran) )\\n\"\n+        + \"ORDER BY gran, dim2 DESC\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setLimitSpec(\n+                            new DefaultLimitSpec(\n+                                ImmutableList.of(\n+                                    new OrderByColumnSpec(\n+                                        \"v1\",\n+                                        Direction.ASCENDING,\n+                                        StringComparators.NUMERIC\n+                                    ),\n+                                    new OrderByColumnSpec(\n+                                        \"v0\",\n+                                        Direction.DESCENDING,\n+                                        StringComparators.LEXICOGRAPHIC\n+                                    )\n+                                ),\n+                                Integer.MAX_VALUE\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{NULL_VALUE, null, 6L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithOrderByAggregator() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (), (dim2), (gran) )\\n\"\n+        + \"ORDER BY SUM(cnt)\\n\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setLimitSpec(\n+                            new DefaultLimitSpec(\n+                                ImmutableList.of(\n+                                    new OrderByColumnSpec(\n+                                        \"a0\",\n+                                        Direction.ASCENDING,\n+                                        StringComparators.NUMERIC\n+                                    )\n+                                ),\n+                                Integer.MAX_VALUE\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithOrderByAggregatorWithLimit() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (), (dim2), (gran) )\\n\"\n+        + \"ORDER BY SUM(cnt)\\n\"\n+        + \"LIMIT 1\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setLimitSpec(\n+                            new DefaultLimitSpec(\n+                                ImmutableList.of(\n+                                    new OrderByColumnSpec(\n+                                        \"a0\",\n+                                        Direction.ASCENDING,\n+                                        StringComparators.NUMERIC\n+                                    )\n+                                ),\n+                                1\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"abc\", null, 1L}\n+        )\n+    );\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 563}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA4NzQwMQ==", "bodyText": "Are you referring to a specific test case?", "url": "https://github.com/apache/druid/pull/9122#discussion_r384087401", "createdAt": "2020-02-25T19:47:20Z", "author": {"login": "gianm"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -9579,6 +9600,538 @@ public void testGroupByTimeAndOtherDimension() throws Exception\n     );\n   }\n \n+  @Test\n+  public void testGroupingSets() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (dim2, gran), (dim2), (gran), () )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v1\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithNumericDimension() throws Exception\n+  {\n+    testQuery(\n+        \"SELECT cnt, COUNT(*)\\n\"\n+        + \"FROM foo\\n\"\n+        + \"GROUP BY GROUPING SETS ( (cnt), () )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setDimensions(dimensions(new DefaultDimensionSpec(\"cnt\", \"d0\", ValueType.LONG)))\n+                        .setAggregatorSpecs(aggregators(new CountAggregatorFactory(\"a0\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"d0\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{1L, 6L},\n+            new Object[]{null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupByRollup() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY ROLLUP (dim2, gran)\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v1\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupByCube() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY CUBE (dim2, gran)\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v1\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithDummyDimension() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (dim2, 'dummy', gran), (dim2), (gran), ('dummy') )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v2\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v2\", \"v2\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v2\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(),\n+                                ImmutableList.of(\"v2\")\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, null, 6L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsNoSuperset() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    // Note: the grouping sets are reordered in the output of this query, but this is allowed.\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (), (dim2), (gran) )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithOrderByDimension() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (), (dim2), (gran) )\\n\"\n+        + \"ORDER BY gran, dim2 DESC\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setLimitSpec(\n+                            new DefaultLimitSpec(\n+                                ImmutableList.of(\n+                                    new OrderByColumnSpec(\n+                                        \"v1\",\n+                                        Direction.ASCENDING,\n+                                        StringComparators.NUMERIC\n+                                    ),\n+                                    new OrderByColumnSpec(\n+                                        \"v0\",\n+                                        Direction.DESCENDING,\n+                                        StringComparators.LEXICOGRAPHIC\n+                                    )\n+                                ),\n+                                Integer.MAX_VALUE\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{NULL_VALUE, null, 6L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithOrderByAggregator() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (), (dim2), (gran) )\\n\"\n+        + \"ORDER BY SUM(cnt)\\n\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setLimitSpec(\n+                            new DefaultLimitSpec(\n+                                ImmutableList.of(\n+                                    new OrderByColumnSpec(\n+                                        \"a0\",\n+                                        Direction.ASCENDING,\n+                                        StringComparators.NUMERIC\n+                                    )\n+                                ),\n+                                Integer.MAX_VALUE\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithOrderByAggregatorWithLimit() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (), (dim2), (gran) )\\n\"\n+        + \"ORDER BY SUM(cnt)\\n\"\n+        + \"LIMIT 1\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setLimitSpec(\n+                            new DefaultLimitSpec(\n+                                ImmutableList.of(\n+                                    new OrderByColumnSpec(\n+                                        \"a0\",\n+                                        Direction.ASCENDING,\n+                                        StringComparators.NUMERIC\n+                                    )\n+                                ),\n+                                1\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"abc\", null, 1L}\n+        )\n+    );\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MTg4NQ=="}, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 563}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEyNjYwNQ==", "bodyText": "I don't think I read a test that did this explicitly. testGroupingSetsWithDummyDimension appears to do this where the dummy column isn't included in the subTotalsSpec. I guess I was just asking - is there anything special about calling GROUPING SETS only on a non-existent column? Should it just behave like you called GROUPING SETS on nothing?", "url": "https://github.com/apache/druid/pull/9122#discussion_r384126605", "createdAt": "2020-02-25T21:08:05Z", "author": {"login": "suneet-s"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -9579,6 +9600,538 @@ public void testGroupByTimeAndOtherDimension() throws Exception\n     );\n   }\n \n+  @Test\n+  public void testGroupingSets() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (dim2, gran), (dim2), (gran), () )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v1\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithNumericDimension() throws Exception\n+  {\n+    testQuery(\n+        \"SELECT cnt, COUNT(*)\\n\"\n+        + \"FROM foo\\n\"\n+        + \"GROUP BY GROUPING SETS ( (cnt), () )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setDimensions(dimensions(new DefaultDimensionSpec(\"cnt\", \"d0\", ValueType.LONG)))\n+                        .setAggregatorSpecs(aggregators(new CountAggregatorFactory(\"a0\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"d0\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{1L, 6L},\n+            new Object[]{null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupByRollup() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY ROLLUP (dim2, gran)\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v1\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupByCube() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY CUBE (dim2, gran)\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v1\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithDummyDimension() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (dim2, 'dummy', gran), (dim2), (gran), ('dummy') )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v2\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v2\", \"v2\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v2\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(),\n+                                ImmutableList.of(\"v2\")\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, null, 6L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsNoSuperset() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    // Note: the grouping sets are reordered in the output of this query, but this is allowed.\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (), (dim2), (gran) )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithOrderByDimension() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (), (dim2), (gran) )\\n\"\n+        + \"ORDER BY gran, dim2 DESC\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setLimitSpec(\n+                            new DefaultLimitSpec(\n+                                ImmutableList.of(\n+                                    new OrderByColumnSpec(\n+                                        \"v1\",\n+                                        Direction.ASCENDING,\n+                                        StringComparators.NUMERIC\n+                                    ),\n+                                    new OrderByColumnSpec(\n+                                        \"v0\",\n+                                        Direction.DESCENDING,\n+                                        StringComparators.LEXICOGRAPHIC\n+                                    )\n+                                ),\n+                                Integer.MAX_VALUE\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{NULL_VALUE, null, 6L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithOrderByAggregator() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (), (dim2), (gran) )\\n\"\n+        + \"ORDER BY SUM(cnt)\\n\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setLimitSpec(\n+                            new DefaultLimitSpec(\n+                                ImmutableList.of(\n+                                    new OrderByColumnSpec(\n+                                        \"a0\",\n+                                        Direction.ASCENDING,\n+                                        StringComparators.NUMERIC\n+                                    )\n+                                ),\n+                                Integer.MAX_VALUE\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithOrderByAggregatorWithLimit() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (), (dim2), (gran) )\\n\"\n+        + \"ORDER BY SUM(cnt)\\n\"\n+        + \"LIMIT 1\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setLimitSpec(\n+                            new DefaultLimitSpec(\n+                                ImmutableList.of(\n+                                    new OrderByColumnSpec(\n+                                        \"a0\",\n+                                        Direction.ASCENDING,\n+                                        StringComparators.NUMERIC\n+                                    )\n+                                ),\n+                                1\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"abc\", null, 1L}\n+        )\n+    );\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2MTg4NQ=="}, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 563}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NDQ2NTU5OnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxOToyMDoxNVrOFtsuJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxOTo1NjoyNFrOFuTI5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2Mjk1MA==", "bodyText": "Maybe add a test for ROLLUP (gran, dim2) ie reverse order of the select columns. Not sure if we need the same thing for CUBE since it generates the same grouping sets with the reverse order.", "url": "https://github.com/apache/druid/pull/9122#discussion_r383462950", "createdAt": "2020-02-24T19:20:15Z", "author": {"login": "suneet-s"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -9579,6 +9600,538 @@ public void testGroupByTimeAndOtherDimension() throws Exception\n     );\n   }\n \n+  @Test\n+  public void testGroupingSets() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (dim2, gran), (dim2), (gran), () )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v1\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithNumericDimension() throws Exception\n+  {\n+    testQuery(\n+        \"SELECT cnt, COUNT(*)\\n\"\n+        + \"FROM foo\\n\"\n+        + \"GROUP BY GROUPING SETS ( (cnt), () )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setDimensions(dimensions(new DefaultDimensionSpec(\"cnt\", \"d0\", ValueType.LONG)))\n+                        .setAggregatorSpecs(aggregators(new CountAggregatorFactory(\"a0\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"d0\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{1L, 6L},\n+            new Object[]{null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupByRollup() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY ROLLUP (dim2, gran)\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA5MjM5MA==", "bodyText": "OK, I'll add it.", "url": "https://github.com/apache/druid/pull/9122#discussion_r384092390", "createdAt": "2020-02-25T19:56:24Z", "author": {"login": "gianm"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -9579,6 +9600,538 @@ public void testGroupByTimeAndOtherDimension() throws Exception\n     );\n   }\n \n+  @Test\n+  public void testGroupingSets() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY GROUPING SETS ( (dim2, gran), (dim2), (gran), () )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setVirtualColumns(\n+                            expressionVirtualColumn(\n+                                \"v0\",\n+                                \"case_searched(notnull(\\\"dim2\\\"),\\\"dim2\\\",'')\",\n+                                ValueType.STRING\n+                            ),\n+                            expressionVirtualColumn(\n+                                \"v1\",\n+                                \"timestamp_floor(\\\"__time\\\",'P1M',null,'UTC')\",\n+                                ValueType.LONG\n+                            )\n+                        )\n+                        .setDimensions(\n+                            dimensions(\n+                                new DefaultDimensionSpec(\"v0\", \"v0\"),\n+                                new DefaultDimensionSpec(\"v1\", \"v1\", ValueType.LONG)\n+                            )\n+                        )\n+                        .setAggregatorSpecs(aggregators(new LongSumAggregatorFactory(\"a0\", \"cnt\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"v0\", \"v1\"),\n+                                ImmutableList.of(\"v0\"),\n+                                ImmutableList.of(\"v1\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\", timestamp(\"2000-01-01\"), 2L},\n+            new Object[]{\"\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2000-01-01\"), 1L},\n+            new Object[]{\"a\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"abc\", timestamp(\"2001-01-01\"), 1L},\n+            new Object[]{\"\", null, 3L},\n+            new Object[]{\"a\", null, 2L},\n+            new Object[]{\"abc\", null, 1L},\n+            new Object[]{NULL_VALUE, timestamp(\"2000-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, timestamp(\"2001-01-01\"), 3L},\n+            new Object[]{NULL_VALUE, null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupingSetsWithNumericDimension() throws Exception\n+  {\n+    testQuery(\n+        \"SELECT cnt, COUNT(*)\\n\"\n+        + \"FROM foo\\n\"\n+        + \"GROUP BY GROUPING SETS ( (cnt), () )\",\n+        ImmutableList.of(\n+            GroupByQuery.builder()\n+                        .setDataSource(CalciteTests.DATASOURCE1)\n+                        .setInterval(querySegmentSpec(Filtration.eternity()))\n+                        .setGranularity(Granularities.ALL)\n+                        .setDimensions(dimensions(new DefaultDimensionSpec(\"cnt\", \"d0\", ValueType.LONG)))\n+                        .setAggregatorSpecs(aggregators(new CountAggregatorFactory(\"a0\")))\n+                        .setSubtotalsSpec(\n+                            ImmutableList.of(\n+                                ImmutableList.of(\"d0\"),\n+                                ImmutableList.of()\n+                            )\n+                        )\n+                        .setContext(QUERY_CONTEXT_DEFAULT)\n+                        .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{1L, 6L},\n+            new Object[]{null, 6L}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testGroupByRollup() throws Exception\n+  {\n+    // Cannot vectorize due to virtual columns.\n+    cannotVectorize();\n+\n+    testQuery(\n+        \"SELECT dim2, gran, SUM(cnt)\\n\"\n+        + \"FROM (SELECT FLOOR(__time TO MONTH) AS gran, COALESCE(dim2, '') dim2, cnt FROM druid.foo) AS x\\n\"\n+        + \"GROUP BY ROLLUP (dim2, gran)\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ2Mjk1MA=="}, "originalCommit": {"oid": "d68dd92c20d5b9f7ef2685ce381f145b9fb71c1f"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTEyMTg1OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/Grouping.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzozMDozN1rOFuZIOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDo0MDoxNlrOFuaiOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MDUyMQ==", "bodyText": "Should havingFilter be annotated with @Nullable for this method as well?", "url": "https://github.com/apache/druid/pull/9122#discussion_r384190521", "createdAt": "2020-02-25T23:30:37Z", "author": {"login": "ccaominh"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/Grouping.java", "diffHunk": "@@ -92,19 +104,25 @@ private Grouping(\n \n   public static Grouping create(\n       final List<DimensionExpression> dimensions,\n+      final Subtotals subtotals,\n       final List<Aggregation> aggregations,\n       final DimFilter havingFilter,\n       final RowSignature outputRowSignature\n   )\n   {\n-    return new Grouping(dimensions, aggregations, havingFilter, outputRowSignature);\n+    return new Grouping(dimensions, subtotals, aggregations, havingFilter, outputRowSignature);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "922263425044d473f919565b5e5dae2b6313d43f"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxMzU2MQ==", "bodyText": "Yes, it should, I'll add it.", "url": "https://github.com/apache/druid/pull/9122#discussion_r384213561", "createdAt": "2020-02-26T00:40:16Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/Grouping.java", "diffHunk": "@@ -92,19 +104,25 @@ private Grouping(\n \n   public static Grouping create(\n       final List<DimensionExpression> dimensions,\n+      final Subtotals subtotals,\n       final List<Aggregation> aggregations,\n       final DimFilter havingFilter,\n       final RowSignature outputRowSignature\n   )\n   {\n-    return new Grouping(dimensions, aggregations, havingFilter, outputRowSignature);\n+    return new Grouping(dimensions, subtotals, aggregations, havingFilter, outputRowSignature);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MDUyMQ=="}, "originalCommit": {"oid": "922263425044d473f919565b5e5dae2b6313d43f"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTEzNDg2OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/Grouping.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQyMzozNTowOFrOFuZPdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDo0MDoxOFrOFuaiRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MjM3Mw==", "bodyText": "Is there a test for this?", "url": "https://github.com/apache/druid/pull/9122#discussion_r384192373", "createdAt": "2020-02-25T23:35:08Z", "author": {"login": "ccaominh"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/Grouping.java", "diffHunk": "@@ -141,36 +159,95 @@ public RowSignature getOutputRowSignature()\n     return outputRowSignature;\n   }\n \n+  /**\n+   * Applies a post-grouping projection.\n+   *\n+   * @see DruidQuery#computeGrouping which uses this\n+   */\n+  public Grouping applyProject(final PlannerContext plannerContext, final Project project)\n+  {\n+    final List<DimensionExpression> newDimensions = new ArrayList<>();\n+    final List<Aggregation> newAggregations = new ArrayList<>(aggregations);\n+    final Subtotals newSubtotals;\n+\n+    final Projection postAggregationProjection = Projection.postAggregation(\n+        project,\n+        plannerContext,\n+        outputRowSignature,\n+        \"p\"\n+    );\n+\n+    postAggregationProjection.getPostAggregators().forEach(\n+        postAggregator -> newAggregations.add(Aggregation.create(postAggregator))\n+    );\n+\n+    // Remove literal dimensions that did not appear in the projection. This is useful for queries\n+    // like \"SELECT COUNT(*) FROM tbl GROUP BY 'dummy'\" which some tools can generate, and for which we don't\n+    // actually want to include a dimension 'dummy'.\n+    final ImmutableBitSet aggregateProjectBits = RelOptUtil.InputFinder.bits(project.getChildExps(), null);\n+    final int[] newDimIndexes = new int[dimensions.size()];\n+\n+    for (int i = 0; i < dimensions.size(); i++) {\n+      final DimensionExpression dimension = dimensions.get(i);\n+      if (Parser.parse(dimension.getDruidExpression().getExpression(), plannerContext.getExprMacroTable())\n+                .isLiteral() && !aggregateProjectBits.get(i)) {\n+        newDimIndexes[i] = -1;\n+      } else {\n+        newDimIndexes[i] = newDimensions.size();\n+        newDimensions.add(dimension);\n+      }\n+    }\n+\n+    // Renumber subtotals, if needed, to account for removed dummy dimensions.\n+    if (newDimensions.size() != dimensions.size()) {\n+      final List<IntList> newSubtotalsList = new ArrayList<>();\n+\n+      for (IntList subtotal : subtotals.getSubtotals()) {\n+        final IntList newSubtotal = new IntArrayList();\n+        for (int dimIndex : subtotal) {\n+          final int newDimIndex = newDimIndexes[dimIndex];\n+          if (newDimIndex >= 0) {\n+            newSubtotal.add(newDimIndex);\n+          }\n+        }\n+\n+        newSubtotalsList.add(newSubtotal);\n+      }\n+\n+      newSubtotals = new Subtotals(newSubtotalsList);\n+    } else {\n+      newSubtotals = subtotals;\n+    }\n+\n+    return Grouping.create(\n+        newDimensions,\n+        newSubtotals,\n+        newAggregations,\n+        havingFilter,\n+        postAggregationProjection.getOutputRowSignature()\n+    );\n+  }\n+\n   @Override\n-  public boolean equals(final Object o)\n+  public boolean equals(Object o)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "922263425044d473f919565b5e5dae2b6313d43f"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxMzU3Mg==", "bodyText": "I'll add one.", "url": "https://github.com/apache/druid/pull/9122#discussion_r384213572", "createdAt": "2020-02-26T00:40:18Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/Grouping.java", "diffHunk": "@@ -141,36 +159,95 @@ public RowSignature getOutputRowSignature()\n     return outputRowSignature;\n   }\n \n+  /**\n+   * Applies a post-grouping projection.\n+   *\n+   * @see DruidQuery#computeGrouping which uses this\n+   */\n+  public Grouping applyProject(final PlannerContext plannerContext, final Project project)\n+  {\n+    final List<DimensionExpression> newDimensions = new ArrayList<>();\n+    final List<Aggregation> newAggregations = new ArrayList<>(aggregations);\n+    final Subtotals newSubtotals;\n+\n+    final Projection postAggregationProjection = Projection.postAggregation(\n+        project,\n+        plannerContext,\n+        outputRowSignature,\n+        \"p\"\n+    );\n+\n+    postAggregationProjection.getPostAggregators().forEach(\n+        postAggregator -> newAggregations.add(Aggregation.create(postAggregator))\n+    );\n+\n+    // Remove literal dimensions that did not appear in the projection. This is useful for queries\n+    // like \"SELECT COUNT(*) FROM tbl GROUP BY 'dummy'\" which some tools can generate, and for which we don't\n+    // actually want to include a dimension 'dummy'.\n+    final ImmutableBitSet aggregateProjectBits = RelOptUtil.InputFinder.bits(project.getChildExps(), null);\n+    final int[] newDimIndexes = new int[dimensions.size()];\n+\n+    for (int i = 0; i < dimensions.size(); i++) {\n+      final DimensionExpression dimension = dimensions.get(i);\n+      if (Parser.parse(dimension.getDruidExpression().getExpression(), plannerContext.getExprMacroTable())\n+                .isLiteral() && !aggregateProjectBits.get(i)) {\n+        newDimIndexes[i] = -1;\n+      } else {\n+        newDimIndexes[i] = newDimensions.size();\n+        newDimensions.add(dimension);\n+      }\n+    }\n+\n+    // Renumber subtotals, if needed, to account for removed dummy dimensions.\n+    if (newDimensions.size() != dimensions.size()) {\n+      final List<IntList> newSubtotalsList = new ArrayList<>();\n+\n+      for (IntList subtotal : subtotals.getSubtotals()) {\n+        final IntList newSubtotal = new IntArrayList();\n+        for (int dimIndex : subtotal) {\n+          final int newDimIndex = newDimIndexes[dimIndex];\n+          if (newDimIndex >= 0) {\n+            newSubtotal.add(newDimIndex);\n+          }\n+        }\n+\n+        newSubtotalsList.add(newSubtotal);\n+      }\n+\n+      newSubtotals = new Subtotals(newSubtotalsList);\n+    } else {\n+      newSubtotals = subtotals;\n+    }\n+\n+    return Grouping.create(\n+        newDimensions,\n+        newSubtotals,\n+        newAggregations,\n+        havingFilter,\n+        postAggregationProjection.getOutputRowSignature()\n+    );\n+  }\n+\n   @Override\n-  public boolean equals(final Object o)\n+  public boolean equals(Object o)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MjM3Mw=="}, "originalCommit": {"oid": "922263425044d473f919565b5e5dae2b6313d43f"}, "originalPosition": 157}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2188, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}