{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk3OTQxOTU4", "number": 9610, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwNjozMjo1M1rODuqW_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMToxMjo0NFrODvTprg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMjU1MTAwOnYy", "diffSide": "RIGHT", "path": "extensions-contrib/ambari-metrics-emitter/pom.xml", "isResolved": false, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwNjozMjo1M1rOGAvmpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzoxNjo1NVrOGB2Bxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzEyNw==", "bodyText": "what is this change about, was this relying on curator providing it?", "url": "https://github.com/apache/druid/pull/9610#discussion_r403433127", "createdAt": "2020-04-04T06:32:53Z", "author": {"login": "clintropolis"}, "path": "extensions-contrib/ambari-metrics-emitter/pom.xml", "diffHunk": "@@ -48,6 +48,18 @@\n       <type>test-jar</type>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjExNQ==", "bodyText": "Yes. curator 4.1.0 was providing both org.codehaus.jackson:jackson-mapper-asl:jar:1.9.13 and org.codehaus.jackson:jackson-core-asl:jar:1.9.13. Curator 4.3.0 no longer provides those which then causes java.lang.NoClassDefFoundError: org/codehaus/jackson/map/AnnotationIntrospector.", "url": "https://github.com/apache/druid/pull/9610#discussion_r403436115", "createdAt": "2020-04-04T07:09:19Z", "author": {"login": "maytasm"}, "path": "extensions-contrib/ambari-metrics-emitter/pom.xml", "diffHunk": "@@ -48,6 +48,18 @@\n       <type>test-jar</type>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzEyNw=="}, "originalCommit": {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjEzNQ==", "bodyText": "Hence, explicitly adding dependecy on those org.codehaus.jackson:jackson-mapper-asl:jar and org.codehaus.jackson:jackson-core-asl:jar", "url": "https://github.com/apache/druid/pull/9610#discussion_r403436135", "createdAt": "2020-04-04T07:09:43Z", "author": {"login": "maytasm"}, "path": "extensions-contrib/ambari-metrics-emitter/pom.xml", "diffHunk": "@@ -48,6 +48,18 @@\n       <type>test-jar</type>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzEyNw=="}, "originalCommit": {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjE1MA==", "bodyText": "Actually I think they can be scope test", "url": "https://github.com/apache/druid/pull/9610#discussion_r403436150", "createdAt": "2020-04-04T07:09:55Z", "author": {"login": "maytasm"}, "path": "extensions-contrib/ambari-metrics-emitter/pom.xml", "diffHunk": "@@ -48,6 +48,18 @@\n       <type>test-jar</type>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzEyNw=="}, "originalCommit": {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNzk0NQ==", "bodyText": "Changed to scope test.", "url": "https://github.com/apache/druid/pull/9610#discussion_r403437945", "createdAt": "2020-04-04T07:31:45Z", "author": {"login": "maytasm"}, "path": "extensions-contrib/ambari-metrics-emitter/pom.xml", "diffHunk": "@@ -48,6 +48,18 @@\n       <type>test-jar</type>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzEyNw=="}, "originalCommit": {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNzk3MA==", "bodyText": "This was the dependency tree before the change in this PR\n[INFO] |  +- org.apache.curator:curator-x-discovery:jar:4.1.0:test\n[INFO] |  |  - org.codehaus.jackson:jackson-mapper-asl:jar:1.9.13:test\n[INFO] |  |     - org.codehaus.jackson:jackson-core-asl:jar:1.9.13:test", "url": "https://github.com/apache/druid/pull/9610#discussion_r403437970", "createdAt": "2020-04-04T07:32:01Z", "author": {"login": "maytasm"}, "path": "extensions-contrib/ambari-metrics-emitter/pom.xml", "diffHunk": "@@ -48,6 +48,18 @@\n       <type>test-jar</type>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzEyNw=="}, "originalCommit": {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDIyNjk4Mg==", "bodyText": "If jackson-mapper-asl:1.9.13 is no longer in production code, can you check if its security vulnerability suppression can be removed? https://github.com/apache/druid/blob/master/owasp-dependency-check-suppressions.xml#L125\nYou can run the security vulnerability scan by running: mvn dependency-check:check", "url": "https://github.com/apache/druid/pull/9610#discussion_r404226982", "createdAt": "2020-04-06T16:30:10Z", "author": {"login": "ccaominh"}, "path": "extensions-contrib/ambari-metrics-emitter/pom.xml", "diffHunk": "@@ -48,6 +48,18 @@\n       <type>test-jar</type>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzEyNw=="}, "originalCommit": {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM2NjkyOA==", "bodyText": "I tried to run mvn dependency-check:check but it failed on druid-console. It also fails on druid-console even on master. Am I doing something wrong? I dont think I see these failures on the cron job\nOne or more dependencies were identified with known vulnerabilities in druid-console:\npackage.json (pkg:npm/acorn@6.3.0) : 1488\npackage.json (pkg:npm/kind-of@3.2.2) : 1490\npackage.json (pkg:npm/yargs-parser@13.1.1) : CVE-2020-7608\npackage.json (pkg:npm/minimist@0.0.10) : 1179\npackage.json (pkg:npm/yargs@7.1.0) : CVE-2020-7608\npackage.json (pkg:npm/yargs-parser@5.0.0) : CVE-2020-7608\npackage.json (pkg:npm/yargs-parser@10.1.0) : CVE-2020-7608\npackage.json (pkg:npm/yargs@12.0.5) : CVE-2020-7608\npackage.json (pkg:npm/yargs-parser@11.1.1) : CVE-2020-7608", "url": "https://github.com/apache/druid/pull/9610#discussion_r404366928", "createdAt": "2020-04-06T20:27:17Z", "author": {"login": "maytasm"}, "path": "extensions-contrib/ambari-metrics-emitter/pom.xml", "diffHunk": "@@ -48,6 +48,18 @@\n       <type>test-jar</type>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzEyNw=="}, "originalCommit": {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4NjU5OA==", "bodyText": "If you skip druid console, do all the other modules pass? If so, then the suppression for jackson-mapper-asl can be removed. We'll need to fix the other issues in different PRs.", "url": "https://github.com/apache/druid/pull/9610#discussion_r404386598", "createdAt": "2020-04-06T21:03:15Z", "author": {"login": "ccaominh"}, "path": "extensions-contrib/ambari-metrics-emitter/pom.xml", "diffHunk": "@@ -48,6 +48,18 @@\n       <type>test-jar</type>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzEyNw=="}, "originalCommit": {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4Njk1MA==", "bodyText": "No. Other modules such as druid-orc-extensions and druid-hdfs-storage fails. This is because jackson-mapper-asl-1.9.13.jar is pulled in by org.apache.hadoop:hadoop-common:jar:2.8.5", "url": "https://github.com/apache/druid/pull/9610#discussion_r404586950", "createdAt": "2020-04-07T07:16:55Z", "author": {"login": "maytasm"}, "path": "extensions-contrib/ambari-metrics-emitter/pom.xml", "diffHunk": "@@ -48,6 +48,18 @@\n       <type>test-jar</type>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzEyNw=="}, "originalCommit": {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwMjU1NDg4OnYy", "diffSide": "RIGHT", "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNFQwNjozODo0MlrOGAvocA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzoyODowMVrOGB2amQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzU4NA==", "bodyText": "Per the PR description/linked javadocs, can this and other usages of event.getData() in this switch statement be null? I guess we are relying on an NPE happening and then the catch checking and handling there? It might be nicer to explicitly check and throw a more useful error about the ChildData for the event unexpectedly being null so that the alerted exception is more useful", "url": "https://github.com/apache/druid/pull/9610#discussion_r403433584", "createdAt": "2020-04-04T06:38:42Z", "author": {"login": "clintropolis"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java", "diffHunk": "@@ -1081,6 +979,117 @@ private boolean cancelWorkerCleanup(String workerHost)\n     }\n   }\n \n+  @VisibleForTesting\n+  PathChildrenCacheListener getStatusListener(final Worker worker, final ZkWorker zkWorker, final SettableFuture<ZkWorker> retVal)\n+  {\n+    return (client, event) -> {\n+      final String taskId;\n+      final RemoteTaskRunnerWorkItem taskRunnerWorkItem;\n+      synchronized (statusLock) {\n+        try {\n+          switch (event.getType()) { // lgtm [java/dereferenced-value-may-be-null]\n+            case CHILD_ADDED:\n+            case CHILD_UPDATED:\n+              taskId = ZKPaths.getNodeFromPath(event.getData().getPath()); // lgtm [java/dereferenced-value-may-be-null]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzNjQyMA==", "bodyText": "Yes. event.getData() can be null here and everywhere else in this function. I dont think we need to do anything differently in handling the null from event.getData() so I just let NPE happens and the catch will take care of logging and making sure the JVM doesnt shutdown. You can deduce that the NPE from event.getData() happens from the data map of the alert and the Exception that was produced", "url": "https://github.com/apache/druid/pull/9610#discussion_r403436420", "createdAt": "2020-04-04T07:13:34Z", "author": {"login": "maytasm"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java", "diffHunk": "@@ -1081,6 +979,117 @@ private boolean cancelWorkerCleanup(String workerHost)\n     }\n   }\n \n+  @VisibleForTesting\n+  PathChildrenCacheListener getStatusListener(final Worker worker, final ZkWorker zkWorker, final SettableFuture<ZkWorker> retVal)\n+  {\n+    return (client, event) -> {\n+      final String taskId;\n+      final RemoteTaskRunnerWorkItem taskRunnerWorkItem;\n+      synchronized (statusLock) {\n+        try {\n+          switch (event.getType()) { // lgtm [java/dereferenced-value-may-be-null]\n+            case CHILD_ADDED:\n+            case CHILD_UPDATED:\n+              taskId = ZKPaths.getNodeFromPath(event.getData().getPath()); // lgtm [java/dereferenced-value-may-be-null]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzU4NA=="}, "originalCommit": {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzODU5NA==", "bodyText": "The childData itself is null. The only other data that we have is the eventType which we can always add to the alert? or only add to alert if childData is null", "url": "https://github.com/apache/druid/pull/9610#discussion_r403438594", "createdAt": "2020-04-04T07:38:40Z", "author": {"login": "maytasm"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java", "diffHunk": "@@ -1081,6 +979,117 @@ private boolean cancelWorkerCleanup(String workerHost)\n     }\n   }\n \n+  @VisibleForTesting\n+  PathChildrenCacheListener getStatusListener(final Worker worker, final ZkWorker zkWorker, final SettableFuture<ZkWorker> retVal)\n+  {\n+    return (client, event) -> {\n+      final String taskId;\n+      final RemoteTaskRunnerWorkItem taskRunnerWorkItem;\n+      synchronized (statusLock) {\n+        try {\n+          switch (event.getType()) { // lgtm [java/dereferenced-value-may-be-null]\n+            case CHILD_ADDED:\n+            case CHILD_UPDATED:\n+              taskId = ZKPaths.getNodeFromPath(event.getData().getPath()); // lgtm [java/dereferenced-value-may-be-null]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzU4NA=="}, "originalCommit": {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5NTE5MA==", "bodyText": "Yes. event.getData() can be null here and everywhere else in this function. I dont think we need to do anything differently in handling the null from event.getData() so I just let NPE happens and the catch will take care of logging and making sure the JVM doesnt shutdown.\n\neven.getData() can be null depending on the event type; it must not be null for CHILD_ADDED, CHILD_UPDATED, and CHILD_REMOVED events. It should be null otherwise. I think it's worth checking null depending on the event type.", "url": "https://github.com/apache/druid/pull/9610#discussion_r404395190", "createdAt": "2020-04-06T21:20:08Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java", "diffHunk": "@@ -1081,6 +979,117 @@ private boolean cancelWorkerCleanup(String workerHost)\n     }\n   }\n \n+  @VisibleForTesting\n+  PathChildrenCacheListener getStatusListener(final Worker worker, final ZkWorker zkWorker, final SettableFuture<ZkWorker> retVal)\n+  {\n+    return (client, event) -> {\n+      final String taskId;\n+      final RemoteTaskRunnerWorkItem taskRunnerWorkItem;\n+      synchronized (statusLock) {\n+        try {\n+          switch (event.getType()) { // lgtm [java/dereferenced-value-may-be-null]\n+            case CHILD_ADDED:\n+            case CHILD_UPDATED:\n+              taskId = ZKPaths.getNodeFromPath(event.getData().getPath()); // lgtm [java/dereferenced-value-may-be-null]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzU4NA=="}, "originalCommit": {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5OTUxOQ==", "bodyText": "You can deduce that the NPE from event.getData() happens from the data map of the alert and the Exception that was produced\n\nAh yeah, I know I can deduce this, my point was more to be useful for operators who see an error or alert and don't want to dig through the code, which is probably most of them, that we could indicate friendlier messaging that an unexpected situation where the child data was null occurred on a zk event.", "url": "https://github.com/apache/druid/pull/9610#discussion_r404399519", "createdAt": "2020-04-06T21:28:25Z", "author": {"login": "clintropolis"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java", "diffHunk": "@@ -1081,6 +979,117 @@ private boolean cancelWorkerCleanup(String workerHost)\n     }\n   }\n \n+  @VisibleForTesting\n+  PathChildrenCacheListener getStatusListener(final Worker worker, final ZkWorker zkWorker, final SettableFuture<ZkWorker> retVal)\n+  {\n+    return (client, event) -> {\n+      final String taskId;\n+      final RemoteTaskRunnerWorkItem taskRunnerWorkItem;\n+      synchronized (statusLock) {\n+        try {\n+          switch (event.getType()) { // lgtm [java/dereferenced-value-may-be-null]\n+            case CHILD_ADDED:\n+            case CHILD_UPDATED:\n+              taskId = ZKPaths.getNodeFromPath(event.getData().getPath()); // lgtm [java/dereferenced-value-may-be-null]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzU4NA=="}, "originalCommit": {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5MzMwNQ==", "bodyText": "Confirmed that event cannot be null. Removed null check for the event.\nAdded a null check blocks for event.getData() with different alert message than the existing message for catching any Exception. This should be more helpful to operators. Let me know if you have suggestion on different wording or other KV data to add to alert. This check is for the CHILD_ADDED, CHILD_UPDATED, and CHILD_REMOVED events which even.getData() must not be null.", "url": "https://github.com/apache/druid/pull/9610#discussion_r404593305", "createdAt": "2020-04-07T07:28:01Z", "author": {"login": "maytasm"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java", "diffHunk": "@@ -1081,6 +979,117 @@ private boolean cancelWorkerCleanup(String workerHost)\n     }\n   }\n \n+  @VisibleForTesting\n+  PathChildrenCacheListener getStatusListener(final Worker worker, final ZkWorker zkWorker, final SettableFuture<ZkWorker> retVal)\n+  {\n+    return (client, event) -> {\n+      final String taskId;\n+      final RemoteTaskRunnerWorkItem taskRunnerWorkItem;\n+      synchronized (statusLock) {\n+        try {\n+          switch (event.getType()) { // lgtm [java/dereferenced-value-may-be-null]\n+            case CHILD_ADDED:\n+            case CHILD_UPDATED:\n+              taskId = ZKPaths.getNodeFromPath(event.getData().getPath()); // lgtm [java/dereferenced-value-may-be-null]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQzMzU4NA=="}, "originalCommit": {"oid": "258bfe476f5377789faec9bbf6ab9e1869110f99"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTMwNTk0OnYy", "diffSide": "RIGHT", "path": "extensions-contrib/ambari-metrics-emitter/pom.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMTowOToyM1rOGBp_IA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzozMDoxM1rOGB2fwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4OTY2NA==", "bodyText": "Please put these test dependencies with others below (at Line 133) together.", "url": "https://github.com/apache/druid/pull/9610#discussion_r404389664", "createdAt": "2020-04-06T21:09:23Z", "author": {"login": "jihoonson"}, "path": "extensions-contrib/ambari-metrics-emitter/pom.xml", "diffHunk": "@@ -48,6 +48,18 @@\n       <type>test-jar</type>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>\n+      <groupId>org.codehaus.jackson</groupId>\n+      <artifactId>jackson-core-asl</artifactId>\n+      <version>${codehaus.jackson.version}</version>\n+      <scope>test</scope>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e62d3da2abb5d05a7bf89f304c8031a2c1a5163"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NDYyNg==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/9610#discussion_r404594626", "createdAt": "2020-04-07T07:30:13Z", "author": {"login": "maytasm"}, "path": "extensions-contrib/ambari-metrics-emitter/pom.xml", "diffHunk": "@@ -48,6 +48,18 @@\n       <type>test-jar</type>\n       <scope>test</scope>\n     </dependency>\n+    <dependency>\n+      <groupId>org.codehaus.jackson</groupId>\n+      <artifactId>jackson-core-asl</artifactId>\n+      <version>${codehaus.jackson.version}</version>\n+      <scope>test</scope>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM4OTY2NA=="}, "originalCommit": {"oid": "0e62d3da2abb5d05a7bf89f304c8031a2c1a5163"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUwOTMxNjMwOnYy", "diffSide": "RIGHT", "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wNlQyMToxMjo0NFrOGBqFkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwNzozMTo0NVrOGB2jRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5MTMxMw==", "bodyText": "I don't think event can ever be null. Check out callers of PathChildrenCache.callListeners().", "url": "https://github.com/apache/druid/pull/9610#discussion_r404391313", "createdAt": "2020-04-06T21:12:44Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java", "diffHunk": "@@ -969,116 +970,129 @@ private boolean cancelWorkerCleanup(String workerHost)\n       );\n \n       // Add status listener to the watcher for status changes\n-      zkWorker.addListener(\n-          (client, event) -> {\n-            final String taskId;\n-            final RemoteTaskRunnerWorkItem taskRunnerWorkItem;\n-            synchronized (statusLock) {\n-              try {\n-                switch (event.getType()) {\n-                  case CHILD_ADDED:\n-                  case CHILD_UPDATED:\n-                    taskId = ZKPaths.getNodeFromPath(event.getData().getPath());\n-                    final TaskAnnouncement announcement = jsonMapper.readValue(\n-                        event.getData().getData(), TaskAnnouncement.class\n-                    );\n-\n-                    log.info(\n-                        \"Worker[%s] wrote %s status for task [%s] on [%s]\",\n-                        zkWorker.getWorker().getHost(),\n-                        announcement.getTaskStatus().getStatusCode(),\n-                        taskId,\n-                        announcement.getTaskLocation()\n-                    );\n-\n-                    // Synchronizing state with ZK\n-                    statusLock.notifyAll();\n-\n-                    final RemoteTaskRunnerWorkItem tmp;\n-                    if ((tmp = runningTasks.get(taskId)) != null) {\n-                      taskRunnerWorkItem = tmp;\n-                    } else {\n-                      final RemoteTaskRunnerWorkItem newTaskRunnerWorkItem = new RemoteTaskRunnerWorkItem(\n-                          taskId,\n-                          announcement.getTaskType(),\n-                          zkWorker.getWorker(),\n-                          TaskLocation.unknown(),\n-                          announcement.getTaskDataSource()\n-                      );\n-                      final RemoteTaskRunnerWorkItem existingItem = runningTasks.putIfAbsent(\n-                          taskId,\n-                          newTaskRunnerWorkItem\n-                      );\n-                      if (existingItem == null) {\n-                        log.warn(\n-                            \"Worker[%s] announced a status for a task I didn't know about, adding to runningTasks: %s\",\n-                            zkWorker.getWorker().getHost(),\n-                            taskId\n-                        );\n-                        taskRunnerWorkItem = newTaskRunnerWorkItem;\n-                      } else {\n-                        taskRunnerWorkItem = existingItem;\n-                      }\n-                    }\n-\n-                    if (!announcement.getTaskLocation().equals(taskRunnerWorkItem.getLocation())) {\n-                      taskRunnerWorkItem.setLocation(announcement.getTaskLocation());\n-                      TaskRunnerUtils.notifyLocationChanged(listeners, taskId, announcement.getTaskLocation());\n-                    }\n+      zkWorker.addListener(getStatusListener(worker, zkWorker, retVal));\n+      zkWorker.start();\n+      return retVal;\n+    }\n+    catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n \n-                    if (announcement.getTaskStatus().isComplete()) {\n-                      taskComplete(taskRunnerWorkItem, zkWorker, announcement.getTaskStatus());\n-                      runPendingTasks();\n-                    }\n-                    break;\n-                  case CHILD_REMOVED:\n-                    taskId = ZKPaths.getNodeFromPath(event.getData().getPath());\n-                    taskRunnerWorkItem = runningTasks.remove(taskId);\n-                    if (taskRunnerWorkItem != null) {\n-                      log.info(\"Task[%s] just disappeared!\", taskId);\n-                      taskRunnerWorkItem.setResult(TaskStatus.failure(taskId));\n-                      TaskRunnerUtils.notifyStatusChanged(listeners, taskId, TaskStatus.failure(taskId));\n-                    } else {\n-                      log.info(\"Task[%s] went bye bye.\", taskId);\n-                    }\n-                    break;\n-                  case INITIALIZED:\n-                    if (zkWorkers.putIfAbsent(worker.getHost(), zkWorker) == null) {\n-                      retVal.set(zkWorker);\n-                    } else {\n-                      final String message = StringUtils.format(\n-                          \"WTF?! Tried to add already-existing worker[%s]\",\n-                          worker.getHost()\n-                      );\n-                      log.makeAlert(message)\n-                         .addData(\"workerHost\", worker.getHost())\n-                         .addData(\"workerIp\", worker.getIp())\n-                         .emit();\n-                      retVal.setException(new IllegalStateException(message));\n-                    }\n-                    runPendingTasks();\n-                    break;\n-                  case CONNECTION_SUSPENDED:\n-                  case CONNECTION_RECONNECTED:\n-                  case CONNECTION_LOST:\n-                    // do nothing\n+  @VisibleForTesting\n+  PathChildrenCacheListener getStatusListener(final Worker worker, final ZkWorker zkWorker, final SettableFuture<ZkWorker> retVal)\n+  {\n+    return (client, event) -> {\n+      final String taskId;\n+      final RemoteTaskRunnerWorkItem taskRunnerWorkItem;\n+      synchronized (statusLock) {\n+        try {\n+          switch (event.getType()) { // lgtm [java/dereferenced-value-may-be-null]\n+            case CHILD_ADDED:\n+            case CHILD_UPDATED:\n+              taskId = ZKPaths.getNodeFromPath(event.getData().getPath()); // lgtm [java/dereferenced-value-may-be-null]\n+              final TaskAnnouncement announcement = jsonMapper.readValue(\n+                  event.getData().getData(), TaskAnnouncement.class // lgtm [java/dereferenced-value-may-be-null]\n+              );\n+\n+              log.info(\n+                  \"Worker[%s] wrote %s status for task [%s] on [%s]\",\n+                  zkWorker.getWorker().getHost(),\n+                  announcement.getTaskStatus().getStatusCode(),\n+                  taskId,\n+                  announcement.getTaskLocation()\n+              );\n+\n+              // Synchronizing state with ZK\n+              statusLock.notifyAll();\n+\n+              final RemoteTaskRunnerWorkItem tmp;\n+              if ((tmp = runningTasks.get(taskId)) != null) {\n+                taskRunnerWorkItem = tmp;\n+              } else {\n+                final RemoteTaskRunnerWorkItem newTaskRunnerWorkItem = new RemoteTaskRunnerWorkItem(\n+                    taskId,\n+                    announcement.getTaskType(),\n+                    zkWorker.getWorker(),\n+                    TaskLocation.unknown(),\n+                    announcement.getTaskDataSource()\n+                );\n+                final RemoteTaskRunnerWorkItem existingItem = runningTasks.putIfAbsent(\n+                    taskId,\n+                    newTaskRunnerWorkItem\n+                );\n+                if (existingItem == null) {\n+                  log.warn(\n+                      \"Worker[%s] announced a status for a task I didn't know about, adding to runningTasks: %s\",\n+                      zkWorker.getWorker().getHost(),\n+                      taskId\n+                  );\n+                  taskRunnerWorkItem = newTaskRunnerWorkItem;\n+                } else {\n+                  taskRunnerWorkItem = existingItem;\n                 }\n               }\n-              catch (Exception e) {\n-                log.makeAlert(e, \"Failed to handle new worker status\")\n-                   .addData(\"worker\", zkWorker.getWorker().getHost())\n-                   .addData(\"znode\", event.getData().getPath())\n+\n+              if (!announcement.getTaskLocation().equals(taskRunnerWorkItem.getLocation())) {\n+                taskRunnerWorkItem.setLocation(announcement.getTaskLocation());\n+                TaskRunnerUtils.notifyLocationChanged(listeners, taskId, announcement.getTaskLocation());\n+              }\n+\n+              if (announcement.getTaskStatus().isComplete()) {\n+                taskComplete(taskRunnerWorkItem, zkWorker, announcement.getTaskStatus());\n+                runPendingTasks();\n+              }\n+              break;\n+            case CHILD_REMOVED:\n+              taskId = ZKPaths.getNodeFromPath(event.getData().getPath()); // lgtm [java/dereferenced-value-may-be-null]\n+              taskRunnerWorkItem = runningTasks.remove(taskId);\n+              if (taskRunnerWorkItem != null) {\n+                log.info(\"Task[%s] just disappeared!\", taskId);\n+                taskRunnerWorkItem.setResult(TaskStatus.failure(taskId));\n+                TaskRunnerUtils.notifyStatusChanged(listeners, taskId, TaskStatus.failure(taskId));\n+              } else {\n+                log.info(\"Task[%s] went bye bye.\", taskId);\n+              }\n+              break;\n+            case INITIALIZED:\n+              if (zkWorkers.putIfAbsent(worker.getHost(), zkWorker) == null) {\n+                retVal.set(zkWorker);\n+              } else {\n+                final String message = StringUtils.format(\n+                    \"This should not happen...tried to add already-existing worker[%s]\",\n+                    worker.getHost()\n+                );\n+                log.makeAlert(message)\n+                   .addData(\"workerHost\", worker.getHost())\n+                   .addData(\"workerIp\", worker.getIp())\n                    .emit();\n+                retVal.setException(new IllegalStateException(message));\n               }\n+              runPendingTasks();\n+              break;\n+            case CONNECTION_SUSPENDED:\n+            case CONNECTION_RECONNECTED:\n+            case CONNECTION_LOST:\n+              // do nothing\n+          }\n+        }\n+        catch (Exception e) {\n+          String znode = null;\n+          String eventType = null;\n+          if (event != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e62d3da2abb5d05a7bf89f304c8031a2c1a5163"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU5NTUyNw==", "bodyText": "event cannot be null. I added the check just in case upstream and/or dependency library changes. This is to prevent the JVM from shutting down. I removed it for now.", "url": "https://github.com/apache/druid/pull/9610#discussion_r404595527", "createdAt": "2020-04-07T07:31:45Z", "author": {"login": "maytasm"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/RemoteTaskRunner.java", "diffHunk": "@@ -969,116 +970,129 @@ private boolean cancelWorkerCleanup(String workerHost)\n       );\n \n       // Add status listener to the watcher for status changes\n-      zkWorker.addListener(\n-          (client, event) -> {\n-            final String taskId;\n-            final RemoteTaskRunnerWorkItem taskRunnerWorkItem;\n-            synchronized (statusLock) {\n-              try {\n-                switch (event.getType()) {\n-                  case CHILD_ADDED:\n-                  case CHILD_UPDATED:\n-                    taskId = ZKPaths.getNodeFromPath(event.getData().getPath());\n-                    final TaskAnnouncement announcement = jsonMapper.readValue(\n-                        event.getData().getData(), TaskAnnouncement.class\n-                    );\n-\n-                    log.info(\n-                        \"Worker[%s] wrote %s status for task [%s] on [%s]\",\n-                        zkWorker.getWorker().getHost(),\n-                        announcement.getTaskStatus().getStatusCode(),\n-                        taskId,\n-                        announcement.getTaskLocation()\n-                    );\n-\n-                    // Synchronizing state with ZK\n-                    statusLock.notifyAll();\n-\n-                    final RemoteTaskRunnerWorkItem tmp;\n-                    if ((tmp = runningTasks.get(taskId)) != null) {\n-                      taskRunnerWorkItem = tmp;\n-                    } else {\n-                      final RemoteTaskRunnerWorkItem newTaskRunnerWorkItem = new RemoteTaskRunnerWorkItem(\n-                          taskId,\n-                          announcement.getTaskType(),\n-                          zkWorker.getWorker(),\n-                          TaskLocation.unknown(),\n-                          announcement.getTaskDataSource()\n-                      );\n-                      final RemoteTaskRunnerWorkItem existingItem = runningTasks.putIfAbsent(\n-                          taskId,\n-                          newTaskRunnerWorkItem\n-                      );\n-                      if (existingItem == null) {\n-                        log.warn(\n-                            \"Worker[%s] announced a status for a task I didn't know about, adding to runningTasks: %s\",\n-                            zkWorker.getWorker().getHost(),\n-                            taskId\n-                        );\n-                        taskRunnerWorkItem = newTaskRunnerWorkItem;\n-                      } else {\n-                        taskRunnerWorkItem = existingItem;\n-                      }\n-                    }\n-\n-                    if (!announcement.getTaskLocation().equals(taskRunnerWorkItem.getLocation())) {\n-                      taskRunnerWorkItem.setLocation(announcement.getTaskLocation());\n-                      TaskRunnerUtils.notifyLocationChanged(listeners, taskId, announcement.getTaskLocation());\n-                    }\n+      zkWorker.addListener(getStatusListener(worker, zkWorker, retVal));\n+      zkWorker.start();\n+      return retVal;\n+    }\n+    catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n \n-                    if (announcement.getTaskStatus().isComplete()) {\n-                      taskComplete(taskRunnerWorkItem, zkWorker, announcement.getTaskStatus());\n-                      runPendingTasks();\n-                    }\n-                    break;\n-                  case CHILD_REMOVED:\n-                    taskId = ZKPaths.getNodeFromPath(event.getData().getPath());\n-                    taskRunnerWorkItem = runningTasks.remove(taskId);\n-                    if (taskRunnerWorkItem != null) {\n-                      log.info(\"Task[%s] just disappeared!\", taskId);\n-                      taskRunnerWorkItem.setResult(TaskStatus.failure(taskId));\n-                      TaskRunnerUtils.notifyStatusChanged(listeners, taskId, TaskStatus.failure(taskId));\n-                    } else {\n-                      log.info(\"Task[%s] went bye bye.\", taskId);\n-                    }\n-                    break;\n-                  case INITIALIZED:\n-                    if (zkWorkers.putIfAbsent(worker.getHost(), zkWorker) == null) {\n-                      retVal.set(zkWorker);\n-                    } else {\n-                      final String message = StringUtils.format(\n-                          \"WTF?! Tried to add already-existing worker[%s]\",\n-                          worker.getHost()\n-                      );\n-                      log.makeAlert(message)\n-                         .addData(\"workerHost\", worker.getHost())\n-                         .addData(\"workerIp\", worker.getIp())\n-                         .emit();\n-                      retVal.setException(new IllegalStateException(message));\n-                    }\n-                    runPendingTasks();\n-                    break;\n-                  case CONNECTION_SUSPENDED:\n-                  case CONNECTION_RECONNECTED:\n-                  case CONNECTION_LOST:\n-                    // do nothing\n+  @VisibleForTesting\n+  PathChildrenCacheListener getStatusListener(final Worker worker, final ZkWorker zkWorker, final SettableFuture<ZkWorker> retVal)\n+  {\n+    return (client, event) -> {\n+      final String taskId;\n+      final RemoteTaskRunnerWorkItem taskRunnerWorkItem;\n+      synchronized (statusLock) {\n+        try {\n+          switch (event.getType()) { // lgtm [java/dereferenced-value-may-be-null]\n+            case CHILD_ADDED:\n+            case CHILD_UPDATED:\n+              taskId = ZKPaths.getNodeFromPath(event.getData().getPath()); // lgtm [java/dereferenced-value-may-be-null]\n+              final TaskAnnouncement announcement = jsonMapper.readValue(\n+                  event.getData().getData(), TaskAnnouncement.class // lgtm [java/dereferenced-value-may-be-null]\n+              );\n+\n+              log.info(\n+                  \"Worker[%s] wrote %s status for task [%s] on [%s]\",\n+                  zkWorker.getWorker().getHost(),\n+                  announcement.getTaskStatus().getStatusCode(),\n+                  taskId,\n+                  announcement.getTaskLocation()\n+              );\n+\n+              // Synchronizing state with ZK\n+              statusLock.notifyAll();\n+\n+              final RemoteTaskRunnerWorkItem tmp;\n+              if ((tmp = runningTasks.get(taskId)) != null) {\n+                taskRunnerWorkItem = tmp;\n+              } else {\n+                final RemoteTaskRunnerWorkItem newTaskRunnerWorkItem = new RemoteTaskRunnerWorkItem(\n+                    taskId,\n+                    announcement.getTaskType(),\n+                    zkWorker.getWorker(),\n+                    TaskLocation.unknown(),\n+                    announcement.getTaskDataSource()\n+                );\n+                final RemoteTaskRunnerWorkItem existingItem = runningTasks.putIfAbsent(\n+                    taskId,\n+                    newTaskRunnerWorkItem\n+                );\n+                if (existingItem == null) {\n+                  log.warn(\n+                      \"Worker[%s] announced a status for a task I didn't know about, adding to runningTasks: %s\",\n+                      zkWorker.getWorker().getHost(),\n+                      taskId\n+                  );\n+                  taskRunnerWorkItem = newTaskRunnerWorkItem;\n+                } else {\n+                  taskRunnerWorkItem = existingItem;\n                 }\n               }\n-              catch (Exception e) {\n-                log.makeAlert(e, \"Failed to handle new worker status\")\n-                   .addData(\"worker\", zkWorker.getWorker().getHost())\n-                   .addData(\"znode\", event.getData().getPath())\n+\n+              if (!announcement.getTaskLocation().equals(taskRunnerWorkItem.getLocation())) {\n+                taskRunnerWorkItem.setLocation(announcement.getTaskLocation());\n+                TaskRunnerUtils.notifyLocationChanged(listeners, taskId, announcement.getTaskLocation());\n+              }\n+\n+              if (announcement.getTaskStatus().isComplete()) {\n+                taskComplete(taskRunnerWorkItem, zkWorker, announcement.getTaskStatus());\n+                runPendingTasks();\n+              }\n+              break;\n+            case CHILD_REMOVED:\n+              taskId = ZKPaths.getNodeFromPath(event.getData().getPath()); // lgtm [java/dereferenced-value-may-be-null]\n+              taskRunnerWorkItem = runningTasks.remove(taskId);\n+              if (taskRunnerWorkItem != null) {\n+                log.info(\"Task[%s] just disappeared!\", taskId);\n+                taskRunnerWorkItem.setResult(TaskStatus.failure(taskId));\n+                TaskRunnerUtils.notifyStatusChanged(listeners, taskId, TaskStatus.failure(taskId));\n+              } else {\n+                log.info(\"Task[%s] went bye bye.\", taskId);\n+              }\n+              break;\n+            case INITIALIZED:\n+              if (zkWorkers.putIfAbsent(worker.getHost(), zkWorker) == null) {\n+                retVal.set(zkWorker);\n+              } else {\n+                final String message = StringUtils.format(\n+                    \"This should not happen...tried to add already-existing worker[%s]\",\n+                    worker.getHost()\n+                );\n+                log.makeAlert(message)\n+                   .addData(\"workerHost\", worker.getHost())\n+                   .addData(\"workerIp\", worker.getIp())\n                    .emit();\n+                retVal.setException(new IllegalStateException(message));\n               }\n+              runPendingTasks();\n+              break;\n+            case CONNECTION_SUSPENDED:\n+            case CONNECTION_RECONNECTED:\n+            case CONNECTION_LOST:\n+              // do nothing\n+          }\n+        }\n+        catch (Exception e) {\n+          String znode = null;\n+          String eventType = null;\n+          if (event != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDM5MTMxMw=="}, "originalCommit": {"oid": "0e62d3da2abb5d05a7bf89f304c8031a2c1a5163"}, "originalPosition": 217}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2709, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}