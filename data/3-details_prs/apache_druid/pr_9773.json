{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4ODc0MTA5", "number": 9773, "title": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit", "bodyText": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit\nDescription\nThe following SQL query:\nSELECT dim1\nFROM foo\nINNER JOIN lookup.lookyloo l ON foo.dim2 = l.k\nINNER JOIN lookup.lookyloo l2 ON foo.dim2 = l2.k\nWHERE l.v = 'xa'\nLIMIT 100\nPlans into the following native query:\n{\n  \"queryType\" : \"scan\",\n  \"dataSource\" : {\n    \"type\" : \"join\",\n    \"left\" : {\n      \"type\" : \"query\",\n      \"query\" : {\n        \"queryType\" : \"scan\",\n        \"dataSource\" : {\n          \"type\" : \"join\",\n          \"left\" : {\n            \"type\" : \"table\",\n            \"name\" : \"foo\"\n          },\n          \"right\" : {\n            \"type\" : \"lookup\",\n            \"lookup\" : \"lookyloo\"\n          },\n          \"rightPrefix\" : \"j0.\",\n          \"condition\" : \"(\\\"dim2\\\" == \\\"j0.k\\\")\",\n          \"joinType\" : \"INNER\"\n        },\n        \"intervals\" : {\n          \"type\" : \"intervals\",\n          \"intervals\" : [ \"-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z\" ]\n        },\n        \"virtualColumns\" : [ ],\n        \"resultFormat\" : \"compactedList\",\n        \"batchSize\" : 20480,\n        \"limit\" : 9223372036854775807,\n        \"order\" : \"none\",\n        \"filter\" : {\n          \"type\" : \"selector\",\n          \"dimension\" : \"j0.v\",\n          \"value\" : \"xa\",\n          \"extractionFn\" : null\n        },\n        \"columns\" : [ \"dim1\", \"dim2\", \"j0.k\", \"j0.v\" ],\n        \"legacy\" : false,\n        \"context\" : {\n          \"defaultTimeout\" : 300000,\n          \"maxScatterGatherBytes\" : 9223372036854775807,\n          \"sqlCurrentTimestamp\" : \"2000-01-01T00:00:00Z\",\n          \"sqlQueryId\" : \"dummy\",\n          \"vectorize\" : \"false\"\n        },\n        \"descending\" : false,\n        \"granularity\" : {\n          \"type\" : \"all\"\n        }\n      }\n    },\n    \"right\" : {\n      \"type\" : \"lookup\",\n      \"lookup\" : \"lookyloo\"\n    },\n    \"rightPrefix\" : \"_j0.\",\n    \"condition\" : \"(\\\"dim2\\\" == \\\"_j0.k\\\")\",\n    \"joinType\" : \"INNER\"\n  },\n  \"intervals\" : {\n    \"type\" : \"intervals\",\n    \"intervals\" : [ \"-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z\" ]\n  },\n  \"virtualColumns\" : [ ],\n  \"resultFormat\" : \"compactedList\",\n  \"batchSize\" : 20480,\n  \"limit\" : 100,\n  \"order\" : \"none\",\n  \"filter\" : null,\n  \"columns\" : [ \"dim1\" ],\n  \"legacy\" : false,\n  \"context\" : {\n    \"defaultTimeout\" : 300000,\n    \"maxScatterGatherBytes\" : 9223372036854775807,\n    \"sqlCurrentTimestamp\" : \"2000-01-01T00:00:00Z\",\n    \"sqlQueryId\" : \"dummy\",\n    \"vectorize\" : \"false\"\n  },\n  \"descending\" : false,\n  \"granularity\" : {\n    \"type\" : \"all\"\n  }\n}\nThe plan is bad: there isn't a need for a subquery, but one is generated anyway. Ideally the filter should be lifted above the topmost join.\nLooking at Calcite planner logs for the above,:\nDruidJoinQueryRel(subset=[rel#72:Subset#8.DRUID.[]], condition=[=($1, $4)], joinType=[inner], query=[{\"queryType\":\"scan\",\"dataSource\":{\"type\":\"table\",\"name\":\"__join__\"},\"intervals\":{\"type\":\"intervals\",\"intervals\":[\"-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z\"]},\"virtualColumns\":[],\"resultFormat\":\"compactedList\",\"batchSize\":20480,\"limit\":100,\"order\":\"none\",\"filter\":null,\"columns\":[\"dim1\"],\"legacy\":false,\"context\":{\"defaultTimeout\":300000,\"maxScatterGatherBytes\":9223372036854775807,\"sqlCurrentTimestamp\":\"2000-01-01T00:00:00Z\",\"sqlQueryId\":\"dummy\",\"vectorize\":\"false\"},\"descending\":false,\"granularity\":{\"type\":\"all\"}}], signature=[{dim1:STRING}]): rowcount = 1.0, cumulative cost = {0.525 rows, 0.0 cpu, 0.0 io}, id = 340\n  DruidJoinQueryRel(subset=[rel#175:Subset#13.DRUID.[]], condition=[=($3, $8)], joinType=[inner], query=[{\"queryType\":\"scan\",\"dataSource\":{\"type\":\"table\",\"name\":\"__join__\"},\"intervals\":{\"type\":\"intervals\",\"intervals\":[\"-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z\"]},\"virtualColumns\":[],\"resultFormat\":\"compactedList\",\"batchSize\":20480,\"limit\":9223372036854775807,\"order\":\"none\",\"filter\":{\"type\":\"selector\",\"dimension\":\"v\",\"value\":\"xa\",\"extractionFn\":null},\"columns\":[\"dim1\",\"dim2\",\"k\",\"v\"],\"legacy\":false,\"context\":{\"defaultTimeout\":300000,\"maxScatterGatherBytes\":9223372036854775807,\"sqlCurrentTimestamp\":\"2000-01-01T00:00:00Z\",\"sqlQueryId\":\"dummy\",\"vectorize\":\"false\"},\"descending\":false,\"granularity\":{\"type\":\"all\"}}], signature=[{dim1:STRING, dim2:STRING, k:STRING, v:STRING}]): rowcount = 1.0, cumulative cost = {0.12000000000000002 rows, 0.0 cpu, 0.0 io}, id = 349\n    DruidQueryRel(subset=[rel#135:Subset#0.DRUID.[]], query=[{\"queryType\":\"scan\",\"dataSource\":{\"type\":\"table\",\"name\":\"foo\"},\"intervals\":{\"type\":\"intervals\",\"intervals\":[\"-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z\"]},\"virtualColumns\":[],\"resultFormat\":\"compactedList\",\"batchSize\":20480,\"limit\":9223372036854775807,\"order\":\"none\",\"filter\":null,\"columns\":[\"__time\",\"cnt\",\"dim1\",\"dim2\",\"dim3\",\"m1\",\"m2\",\"unique_dim1\"],\"legacy\":false,\"context\":{\"defaultTimeout\":300000,\"maxScatterGatherBytes\":9223372036854775807,\"sqlCurrentTimestamp\":\"2000-01-01T00:00:00Z\",\"sqlQueryId\":\"dummy\",\"vectorize\":\"false\"},\"descending\":false,\"granularity\":{\"type\":\"all\"}}], signature=[{__time:LONG, cnt:LONG, dim1:STRING, dim2:STRING, dim3:STRING, m1:FLOAT, m2:DOUBLE, unique_dim1:COMPLEX}]): rowcount = 1.0, cumulative cost = {1.0 rows, 0.0 cpu, 0.0 io}, id = 206\n    DruidQueryRel(subset=[rel#117:Subset#2.DRUID.[]], query=[{\"queryType\":\"scan\",\"dataSource\":{\"type\":\"lookup\",\"lookup\":\"lookyloo\"},\"intervals\":{\"type\":\"intervals\",\"intervals\":[\"-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z\"]},\"virtualColumns\":[],\"resultFormat\":\"compactedList\",\"batchSize\":20480,\"limit\":9223372036854775807,\"order\":\"none\",\"filter\":null,\"columns\":[\"k\",\"v\"],\"legacy\":false,\"context\":{\"defaultTimeout\":300000,\"maxScatterGatherBytes\":9223372036854775807,\"sqlCurrentTimestamp\":\"2000-01-01T00:00:00Z\",\"sqlQueryId\":\"dummy\",\"vectorize\":\"false\"},\"descending\":false,\"granularity\":{\"type\":\"all\"}}], signature=[{k:STRING, v:STRING}]): rowcount = 1.0, cumulative cost = {1.0 rows, 0.0 cpu, 0.0 io}, id = 116\n  DruidQueryRel(subset=[rel#115:Subset#4.DRUID.[]], query=[{\"queryType\":\"scan\",\"dataSource\":{\"type\":\"lookup\",\"lookup\":\"lookyloo\"},\"intervals\":{\"type\":\"intervals\",\"intervals\":[\"-146136543-09-08T08:23:32.096Z/146140482-04-24T15:36:27.903Z\"]},\"virtualColumns\":[],\"resultFormat\":\"compactedList\",\"batchSize\":20480,\"limit\":9223372036854775807,\"order\":\"none\",\"filter\":null,\"columns\":[\"k\"],\"legacy\":false,\"context\":{\"defaultTimeout\":300000,\"maxScatterGatherBytes\":9223372036854775807,\"sqlCurrentTimestamp\":\"2000-01-01T00:00:00Z\",\"sqlQueryId\":\"dummy\",\"vectorize\":\"false\"},\"descending\":false,\"granularity\":{\"type\":\"all\"}}], signature=[{k:STRING}]): rowcount = 1.0, cumulative cost = {1.05 rows, 0.0 cpu, 0.0 io}, id = 114\n\nThe filter is now pushed down to the inner DruidJoinQueryRel making the outer join query requiring the inner join into subquery.\nAs we can see here, the cost for the outermost join (line 1 with the filter pushed down), cost = 0.525 rows,  is incorrect. This should have computeLeftRequiresSubquery return true and having cost of >1e5. However, saw that computeLeftRequiresSubquery can returns differently depending on which child we pick from the list of RelList. This then result in a very very different cost since a child that resulted in requiring subquery will have very high cost and a child that doesn't will have a much lower cost. In this case, I saw two RelNode in the list. One RelNode has a filter = null and the other has \"filter\":{\"type\":\"selector\",\"dimension\":\"v\",\"value\":\"xa\",\"extractionFn\":null}. The function getSomeDruidChild happens to return the first RelNode with filter=null resulting in computeLeftRequiresSubquery returning false.\nCalcite only guarantee that all the rel nodes in each rel subset are logically equivalent. Technically, the two rel in the rel subset I found are logically equivalent relational algebra wise. Our self cost join for join in  DruidJoinQueryRel.computeSelfCostmake further assumption outside of relational algebra equivalency. We determine cost base on the location of filter (if filter is on the node vs filter is in the node\u2019s child)\nSolution:\nSince Druid cannot reliably push up / push down filters smartly (pushing up is NOT always the best and pushing down is NOT always the best but Druid is not smart enough to figure this out), this PR disabled pushing down predicates (condition and filter) pass a Join (i.e. into Join's children) altogether. Hence, Druid now only supports pushing predicates into the join if they originated from above the join. Basically, the location of predicates and filters in your Druid SQL is very important as that will directly translate to where the it ends up in the calcite best plan / native SQL.\nThis PR has:\n\n been self-reviewed.\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added or updated version, license, or notice information in licenses.yaml\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths.\n added integration tests.\n been tested in a test Druid cluster.", "createdAt": "2020-04-25T08:50:43Z", "url": "https://github.com/apache/druid/pull/9773", "merged": true, "mergeCommit": {"oid": "0a8bf83bc589fb899a7d96e426682708c636f0eb"}, "closed": true, "closedAt": "2020-05-14T23:56:41Z", "author": {"login": "maytasm"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcbCHR-AH2gAyNDA4ODc0MTA5OjUyMzEyNGFkMmQ0NTA0OGFlY2IyZDZjOTNiNWY4MDQ3MjBkOWY0ZGQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABchWeO5gFqTQxMjI2MTI2OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "523124ad2d45048aecb2d6c93b5f804720d9f4dd", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/523124ad2d45048aecb2d6c93b5f804720d9f4dd", "committedDate": "2020-04-25T08:49:48Z", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMDM4ODM3", "url": "https://github.com/apache/druid/pull/9773#pullrequestreview-402038837", "createdAt": "2020-04-28T17:04:23Z", "commit": {"oid": "523124ad2d45048aecb2d6c93b5f804720d9f4dd"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzowNDoyM1rOGNeIbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQxNzowNDoyM1rOGNeIbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3ODM0OQ==", "bodyText": "What do you think about keeping this interface the same and instead changing the private members left and right to DruidRel<?>\nWhenever left and right is set - we can do something like this.left = getCheapestDruidRel(RelNode);\nAs it's written, I wonder if it's possible for us to estimate that a subquery is not required in the computeSelfCost function, but the DruidRel used to build the native query actually uses a subquery.", "url": "https://github.com/apache/druid/pull/9773#discussion_r416778349", "createdAt": "2020-04-28T17:04:23Z", "author": {"login": "suneet-s"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -328,17 +327,27 @@ private static JoinType toDruidJoinType(JoinRelType calciteJoinType)\n     }\n   }\n \n-  private static boolean computeLeftRequiresSubquery(final DruidRel<?> left)\n+  private static boolean computeLeftRequiresSubquery(final List<DruidRel<?>> leftList)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "523124ad2d45048aecb2d6c93b5f804720d9f4dd"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a7795b7099fd7d9650a024961c9b03ffddff521", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/5a7795b7099fd7d9650a024961c9b03ffddff521", "committedDate": "2020-05-01T01:37:23Z", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9475845bc4e2a19b02de6592adf6987ae126f61f", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/9475845bc4e2a19b02de6592adf6987ae126f61f", "committedDate": "2020-05-01T01:39:06Z", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19bb16cf4d72264fec98b8f46cc9a030956dd874", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/19bb16cf4d72264fec98b8f46cc9a030956dd874", "committedDate": "2020-05-01T02:41:24Z", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cafca0edc23339f0981b0ab3db5b2b4bd316d48a", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/cafca0edc23339f0981b0ab3db5b2b4bd316d48a", "committedDate": "2020-05-01T03:47:40Z", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7911b2096677593195cb054a2a5a8497807c6ece", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/7911b2096677593195cb054a2a5a8497807c6ece", "committedDate": "2020-05-01T22:16:39Z", "message": "Bad plan for table-lookup-lookup join with filter on first lookup and outer limit"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2OTM2ODA1", "url": "https://github.com/apache/druid/pull/9773#pullrequestreview-406936805", "createdAt": "2020-05-06T19:51:05Z", "commit": {"oid": "7911b2096677593195cb054a2a5a8497807c6ece"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOTo1MTowNVrOGRi61w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxOTo1Nzo0OVrOGRjJ6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTA5NQ==", "bodyText": "This \"due to the order of applying/popping rules\" sounds a bit sketchy. Does it mean that a good plan and bad plan will have equal cost, and we'll pick the good plan due to order-based tiebreaking? If so, I'm not sure it would be safe to rely on that. Ideally the good plans should be cheaper than the bad plans, which ensures we pick them.", "url": "https://github.com/apache/druid/pull/9773#discussion_r421051095", "createdAt": "2020-05-06T19:51:05Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -293,23 +293,17 @@ protected RelDataType deriveRowType()\n   @Override\n   public RelOptCost computeSelfCost(final RelOptPlanner planner, final RelMetadataQuery mq)\n   {\n-    double cost;\n-\n-    if (computeLeftRequiresSubquery(getSomeDruidChild(left))) {\n-      cost = CostEstimates.COST_JOIN_SUBQUERY;\n-    } else {\n-      cost = partialQuery.estimateCost();\n-    }\n-\n-    if (computeRightRequiresSubquery(getSomeDruidChild(right))) {\n-      cost += CostEstimates.COST_JOIN_SUBQUERY;\n-    }\n-\n+    double cost = partialQuery.estimateCost();\n     if (joinRel.getCondition().isA(SqlKind.LITERAL) && !joinRel.getCondition().isAlwaysFalse()) {\n       cost += CostEstimates.COST_JOIN_CROSS;\n     }\n-\n-    return planner.getCostFactory().makeCost(cost, 0, 0);\n+    // This is to cancel out the MULTIPLIER_FILTER (value=0.1) from partialQuery.estimateCost() to discourage\n+    // filter push down if pushing down the filter makes this DruidJoinQueryRel not a scan or mapping.\n+    // This will leave the filter at the topmost DruidJoinQueryRel (due to the order of applying/popping rules).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7911b2096677593195cb054a2a5a8497807c6ece"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1MTY1OQ==", "bodyText": "Could you also add a super-long version of this (just in case)? Such as:\n        \"SELECT dim1\\n\"\n        + \"FROM foo\\n\"\n        + \"INNER JOIN lookup.lookyloo l ON foo.dim2 = l.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l2 ON foo.dim2 = l2.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l3 ON foo.dim2 = l3.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l4 ON foo.dim2 = l4.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l5 ON foo.dim2 = l5.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l6 ON foo.dim2 = l6.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l7 ON foo.dim2 = l7.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l8 ON foo.dim2 = l8.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l9 ON foo.dim2 = l9.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l10 ON foo.dim2 = l10.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l11 ON foo.dim2 = l11.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l12 ON foo.dim2 = l12.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l13 ON foo.dim2 = l13.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l14 ON foo.dim2 = l14.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l15 ON foo.dim2 = l15.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l16 ON foo.dim2 = l16.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l17 ON foo.dim2 = l17.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l18 ON foo.dim2 = l18.k\\n\"\n        + \"INNER JOIN lookup.lookyloo l19 ON foo.dim2 = l19.k\\n\"\n        + \"WHERE l.v = 'xa'\\n\",\nThe reason I'm suggesting this is we want to make sure the approach we're using doesn't change behavior as the stack gets deeper.", "url": "https://github.com/apache/druid/pull/9773#discussion_r421051659", "createdAt": "2020-05-06T19:52:07Z", "author": {"login": "gianm"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -8346,6 +8346,166 @@ public void testLeftJoinTwoLookupsUsingJoinOperator() throws Exception\n     );\n   }\n \n+  @Test\n+  public void testInnerJoinTableLookupLookupWithFilterWithOuterLimit() throws Exception\n+  {\n+    testQuery(\n+        \"SELECT dim1\\n\"\n+        + \"FROM foo\\n\"\n+        + \"INNER JOIN lookup.lookyloo l ON foo.dim2 = l.k\\n\"\n+        + \"INNER JOIN lookup.lookyloo l2 ON foo.dim2 = l2.k\\n\"\n+        + \"WHERE l.v = 'xa'\\n\"\n+        + \"LIMIT 100\\n\",\n+        ImmutableList.of(\n+            newScanQueryBuilder()\n+                .dataSource(\n+                    join(\n+                        join(\n+                            new TableDataSource(CalciteTests.DATASOURCE1),\n+                            new LookupDataSource(\"lookyloo\"),\n+                            \"j0.\",\n+                            equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"j0.k\")),\n+                            JoinType.INNER\n+                        ),\n+                        new LookupDataSource(\"lookyloo\"),\n+                        \"_j0.\",\n+                        equalsCondition(DruidExpression.fromColumn(\"dim2\"), DruidExpression.fromColumn(\"_j0.k\")),\n+                        JoinType.INNER\n+                    )\n+                )\n+                .intervals(querySegmentSpec(Filtration.eternity()))\n+                .limit(100)\n+                .filters(selector(\"j0.v\", \"xa\", null))\n+                .columns(\"dim1\")\n+                .context(QUERY_CONTEXT_DEFAULT)\n+                .build()\n+        ),\n+        ImmutableList.of(\n+            new Object[]{\"\"},\n+            new Object[]{\"1\"}\n+        )\n+    );\n+  }\n+\n+  @Test\n+  public void testInnerJoinTableLookupLookupWithFilterWithoutLimit() throws Exception\n+  {\n+    testQuery(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7911b2096677593195cb054a2a5a8497807c6ece"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1NDIzOQ==", "bodyText": "Could you add a comment about why this is being done here?", "url": "https://github.com/apache/druid/pull/9773#discussion_r421054239", "createdAt": "2020-05-06T19:56:31Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQueryRel.java", "diffHunk": "@@ -183,6 +183,10 @@ public RelWriter explainTerms(final RelWriter pw)\n   @Override\n   public RelOptCost computeSelfCost(final RelOptPlanner planner, final RelMetadataQuery mq)\n   {\n-    return planner.getCostFactory().makeCost(partialQuery.estimateCost(), 0, 0);\n+    double cost = partialQuery.estimateCost();\n+    double multiplier = DruidRels.isScanOrMapping(this, true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7911b2096677593195cb054a2a5a8497807c6ece"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTA1NDk1NQ==", "bodyText": "It seems like this happens even if there is no filter. Is that right?", "url": "https://github.com/apache/druid/pull/9773#discussion_r421054955", "createdAt": "2020-05-06T19:57:49Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidJoinQueryRel.java", "diffHunk": "@@ -293,23 +293,17 @@ protected RelDataType deriveRowType()\n   @Override\n   public RelOptCost computeSelfCost(final RelOptPlanner planner, final RelMetadataQuery mq)\n   {\n-    double cost;\n-\n-    if (computeLeftRequiresSubquery(getSomeDruidChild(left))) {\n-      cost = CostEstimates.COST_JOIN_SUBQUERY;\n-    } else {\n-      cost = partialQuery.estimateCost();\n-    }\n-\n-    if (computeRightRequiresSubquery(getSomeDruidChild(right))) {\n-      cost += CostEstimates.COST_JOIN_SUBQUERY;\n-    }\n-\n+    double cost = partialQuery.estimateCost();\n     if (joinRel.getCondition().isA(SqlKind.LITERAL) && !joinRel.getCondition().isAlwaysFalse()) {\n       cost += CostEstimates.COST_JOIN_CROSS;\n     }\n-\n-    return planner.getCostFactory().makeCost(cost, 0, 0);\n+    // This is to cancel out the MULTIPLIER_FILTER (value=0.1) from partialQuery.estimateCost() to discourage\n+    // filter push down if pushing down the filter makes this DruidJoinQueryRel not a scan or mapping.\n+    // This will leave the filter at the topmost DruidJoinQueryRel (due to the order of applying/popping rules).\n+    double multiplier = DruidRels.isScanOrMapping(this, true)\n+                        ? 1\n+                        : 1 / CostEstimates.MULTIPLIER_FILTER;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7911b2096677593195cb054a2a5a8497807c6ece"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5893ab1fc2ebe88099d3c42d172043b3c8c9fc2", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/c5893ab1fc2ebe88099d3c42d172043b3c8c9fc2", "committedDate": "2020-05-08T03:34:22Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0aed7ea9f6ec4e2bd32fa3becaed8206ac74f15c", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/0aed7ea9f6ec4e2bd32fa3becaed8206ac74f15c", "committedDate": "2020-05-08T03:37:20Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3OTc3NDEy", "url": "https://github.com/apache/druid/pull/9773#pullrequestreview-407977412", "createdAt": "2020-05-08T03:45:05Z", "commit": {"oid": "0aed7ea9f6ec4e2bd32fa3becaed8206ac74f15c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMzo0NTowNVrOGSX-Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMzo0NTowNVrOGSX-Ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkyMDI5MA==", "bodyText": "These left right thing is not needed. But I copied this whole code from Calcite and made minimum change (which is just the classifyFilters method). Hence, keeping these variables here as I don't want to refactor Calcite stuff more than needed.", "url": "https://github.com/apache/druid/pull/9773#discussion_r421920290", "createdAt": "2020-05-08T03:45:05Z", "author": {"login": "maytasm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/FilterJoinExcludePushToChildRule.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import org.apache.calcite.adapter.enumerable.EnumerableConvention;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptRuleOperand;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.core.RelFactories;\n+import org.apache.calcite.rel.rules.FilterJoinRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+import org.apache.calcite.tools.RelBuilderFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.apache.calcite.plan.RelOptUtil.conjunctions;\n+\n+public abstract class FilterJoinExcludePushToChildRule extends FilterJoinRule\n+{\n+  /** Copied from {@link FilterJoinRule#NOT_ENUMERABLE} */\n+  private static final Predicate NOT_ENUMERABLE = (join, joinType, exp) ->\n+      join.getConvention() != EnumerableConvention.INSTANCE;\n+\n+  /**\n+   * Rule that pushes predicates from a Filter into the Join below them.\n+   * Similar to {@link FilterJoinRule#FILTER_ON_JOIN} but does not push predicate to the child\n+   */\n+  public static final FilterJoinRule FILTER_ON_JOIN_EXCLUDE_PUSH_TO_CHILD =\n+      new FilterIntoJoinExcludePushToChildRule(RelFactories.LOGICAL_BUILDER, NOT_ENUMERABLE);\n+\n+  FilterJoinExcludePushToChildRule(RelOptRuleOperand operand,\n+                                             String id,\n+                                             boolean smart,\n+                                             RelBuilderFactory relBuilderFactory,\n+                                             Predicate predicate) {\n+    super(operand, id, smart, relBuilderFactory, predicate);\n+  }\n+\n+  /**\n+   * Rule that tries to push filter expressions into a join\n+   * condition. Exlucde pushing into the inputs (child) of the join.\n+   */\n+  public static class FilterIntoJoinExcludePushToChildRule extends FilterJoinExcludePushToChildRule\n+  {\n+    public FilterIntoJoinExcludePushToChildRule(RelBuilderFactory relBuilderFactory, Predicate predicate) {\n+      super(\n+          operand(Filter.class,\n+                  operand(Join.class, RelOptRule.any())),\n+          \"FilterJoinExcludePushToChildRule:filter\", true, relBuilderFactory,\n+          predicate);\n+    }\n+\n+    @Override\n+    public void onMatch(RelOptRuleCall call) {\n+      Filter filter = call.rel(0);\n+      Join join = call.rel(1);\n+      perform(call, filter, join);\n+    }\n+  }\n+\n+  /**\n+   * Copied from {@link FilterJoinRule#perform}\n+   * The difference is that this method will not not push filters to the children in classifyFilters\n+   */\n+  @Override\n+  protected void perform(RelOptRuleCall call, Filter filter,\n+                         Join join) {\n+    final List<RexNode> joinFilters =\n+        RelOptUtil.conjunctions(join.getCondition());\n+    final List<RexNode> origJoinFilters = ImmutableList.copyOf(joinFilters);\n+    // If there is only the joinRel,\n+    // make sure it does not match a cartesian product joinRel\n+    // (with \"true\" condition), otherwise this rule will be applied\n+    // again on the new cartesian product joinRel.\n+    if (filter == null && joinFilters.isEmpty()) {\n+      return;\n+    }\n+\n+    final List<RexNode> aboveFilters =\n+        filter != null\n+        ? getConjunctions(filter)\n+        : new ArrayList<>();\n+    final ImmutableList<RexNode> origAboveFilters =\n+        ImmutableList.copyOf(aboveFilters);\n+\n+    // Simplify Outer Joins\n+    JoinRelType joinType = join.getJoinType();\n+    if (!origAboveFilters.isEmpty() && join.getJoinType() != JoinRelType.INNER) {\n+      joinType = RelOptUtil.simplifyJoin(join, origAboveFilters, joinType);\n+    }\n+\n+    final List<RexNode> leftFilters = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0aed7ea9f6ec4e2bd32fa3becaed8206ac74f15c"}, "originalPosition": 122}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3dc681414f9b10bc9d37805d0965d6aceba58b1", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/f3dc681414f9b10bc9d37805d0965d6aceba58b1", "committedDate": "2020-05-08T19:42:11Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExOTgyOTM0", "url": "https://github.com/apache/druid/pull/9773#pullrequestreview-411982934", "createdAt": "2020-05-14T16:32:19Z", "commit": {"oid": "f3dc681414f9b10bc9d37805d0965d6aceba58b1"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjozMjoxOVrOGVkrjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNzoxNTozMFrOGVmZVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3NDI1Mw==", "bodyText": "past a join (spelling)", "url": "https://github.com/apache/druid/pull/9773#discussion_r425274253", "createdAt": "2020-05-14T16:32:19Z", "author": {"login": "gianm"}, "path": "docs/querying/datasource.md", "diffHunk": "@@ -268,12 +268,16 @@ perform best if `d.field` is a string.\n 4. As of Druid {{DRUIDVERSION}}, the join operator must evaluate the condition for each row. In the future, we expect\n to implement both early and deferred condition evaluation, which we expect to improve performance considerably for\n common use cases.\n+5. Currently, Druid does not support pushing down predicates (condition and filter) pass a Join (i.e. into ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3dc681414f9b10bc9d37805d0965d6aceba58b1"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3NDc4MQ==", "bodyText": "The stray space shouldn't be here.", "url": "https://github.com/apache/druid/pull/9773#discussion_r425274781", "createdAt": "2020-05-14T16:33:10Z", "author": {"login": "gianm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -526,15 +526,19 @@ the way you write the filter.\n \n 2. Try to avoid subqueries underneath joins: they affect both performance and scalability. This includes implicit\n subqueries generated by conditions on mismatched types, and implicit subqueries generated by conditions that use\n-expressions to refer to the right-hand side.\n+expressions to refer to the right-hand side. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3dc681414f9b10bc9d37805d0965d6aceba58b1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3NDkwMA==", "bodyText": "past a join (spelling)", "url": "https://github.com/apache/druid/pull/9773#discussion_r425274900", "createdAt": "2020-05-14T16:33:22Z", "author": {"login": "gianm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -526,15 +526,19 @@ the way you write the filter.\n \n 2. Try to avoid subqueries underneath joins: they affect both performance and scalability. This includes implicit\n subqueries generated by conditions on mismatched types, and implicit subqueries generated by conditions that use\n-expressions to refer to the right-hand side.\n+expressions to refer to the right-hand side. \n \n-3. Read through the [Query execution](query-execution.md) page to understand how various types of native queries\n+3. Currently, Druid does not support pushing down predicates (condition and filter) pass a Join (i.e. into ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3dc681414f9b10bc9d37805d0965d6aceba58b1"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3Nzc4OA==", "bodyText": "CAST, not CASE (spelling)\npassed the check (spelling)", "url": "https://github.com/apache/druid/pull/9773#discussion_r425277788", "createdAt": "2020-05-14T16:37:48Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java", "diffHunk": "@@ -193,9 +193,16 @@ static boolean canHandleCondition(final RexNode condition, final RelDataType lef\n     final int numLeftFields = leftRowType.getFieldCount();\n \n     for (RexNode subCondition : subConditions) {\n-      if (subCondition.isA(SqlKind.LITERAL)) {\n-        // Literals are always OK.\n-        literalSubConditions.add((RexLiteral) subCondition);\n+      if (RexUtil.isLiteral(subCondition, true)) {\n+        if (subCondition instanceof RexCall) {\n+          // This is CAST(literal) which is always OK.\n+          // We know that this is CASE(literal) as it pass the check from RexUtil.isLiteral", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3dc681414f9b10bc9d37805d0965d6aceba58b1"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3ODUwMg==", "bodyText": "A bit nicer to do if (subCondition.isA(SqlKind.CAST)), since it's more explicit as to what we're actually looking for.", "url": "https://github.com/apache/druid/pull/9773#discussion_r425278502", "createdAt": "2020-05-14T16:39:01Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java", "diffHunk": "@@ -193,9 +193,16 @@ static boolean canHandleCondition(final RexNode condition, final RelDataType lef\n     final int numLeftFields = leftRowType.getFieldCount();\n \n     for (RexNode subCondition : subConditions) {\n-      if (subCondition.isA(SqlKind.LITERAL)) {\n-        // Literals are always OK.\n-        literalSubConditions.add((RexLiteral) subCondition);\n+      if (RexUtil.isLiteral(subCondition, true)) {\n+        if (subCondition instanceof RexCall) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3dc681414f9b10bc9d37805d0965d6aceba58b1"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMDg5Nw==", "bodyText": "We have to verify the types of the cast here, because if the underlying literal and the cast output type are different, then skipping the cast might change the meaning of the subcondition. Try looking at the type of the RexCall and comparing it to the type of the underlying RexLiteral. I think some logic like this would work:\n\nIf the types are the same, unwrap the cast and use the underlying literal.\nIf the types are not the same, return Optional.empty() indicating the condition is not supported.\n\nAlternatively, actually apply the cast in step (2) instead of rejecting the condition. I'm not sure how exactly you would do this or whether it is necessary. If it turns out to be necessary, perhaps check out what ReduceExpressionsRule does.", "url": "https://github.com/apache/druid/pull/9773#discussion_r425300897", "createdAt": "2020-05-14T17:13:00Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidJoinRule.java", "diffHunk": "@@ -193,9 +193,16 @@ static boolean canHandleCondition(final RexNode condition, final RelDataType lef\n     final int numLeftFields = leftRowType.getFieldCount();\n \n     for (RexNode subCondition : subConditions) {\n-      if (subCondition.isA(SqlKind.LITERAL)) {\n-        // Literals are always OK.\n-        literalSubConditions.add((RexLiteral) subCondition);\n+      if (RexUtil.isLiteral(subCondition, true)) {\n+        if (subCondition instanceof RexCall) {\n+          // This is CAST(literal) which is always OK.\n+          // We know that this is CASE(literal) as it pass the check from RexUtil.isLiteral\n+          RexCall call = (RexCall) subCondition;\n+          literalSubConditions.add((RexLiteral) call.operands.get(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3dc681414f9b10bc9d37805d0965d6aceba58b1"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMTI2Ng==", "bodyText": "Please add a javadoc here explaining where the code came from, what modifications you made, and what might need to happen to make this no longer necessary (so we can use the builtin rule instead).", "url": "https://github.com/apache/druid/pull/9773#discussion_r425301266", "createdAt": "2020-05-14T17:13:38Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/FilterJoinExcludePushToChildRule.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import org.apache.calcite.adapter.enumerable.EnumerableConvention;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.plan.RelOptRuleOperand;\n+import org.apache.calcite.plan.RelOptUtil;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Filter;\n+import org.apache.calcite.rel.core.Join;\n+import org.apache.calcite.rel.core.JoinRelType;\n+import org.apache.calcite.rel.core.RelFactories;\n+import org.apache.calcite.rel.rules.FilterJoinRule;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexBuilder;\n+import org.apache.calcite.rex.RexCall;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.rex.RexUtil;\n+import org.apache.calcite.tools.RelBuilder;\n+import org.apache.calcite.tools.RelBuilderFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public abstract class FilterJoinExcludePushToChildRule extends FilterJoinRule", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3dc681414f9b10bc9d37805d0965d6aceba58b1"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMjE0Ng==", "bodyText": "Unfortunately (spelling)", "url": "https://github.com/apache/druid/pull/9773#discussion_r425302146", "createdAt": "2020-05-14T17:15:08Z", "author": {"login": "gianm"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -8749,6 +9097,9 @@ public void testCommaJoinLeftFunction() throws Exception\n     );\n   }\n \n+  // This SQL currently does not result in an optimum plan.\n+  // Unfortunetly, we have disabled pushing down predicates (conditions and filters) due to https://github.com/apache/druid/pull/9773", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3dc681414f9b10bc9d37805d0965d6aceba58b1"}, "originalPosition": 372}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMwMjM1Ng==", "bodyText": "Please update the docs to point out that people should avoid comma joins for this reason.", "url": "https://github.com/apache/druid/pull/9773#discussion_r425302356", "createdAt": "2020-05-14T17:15:30Z", "author": {"login": "gianm"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -8749,6 +9097,9 @@ public void testCommaJoinLeftFunction() throws Exception\n     );\n   }\n \n+  // This SQL currently does not result in an optimum plan.\n+  // Unfortunetly, we have disabled pushing down predicates (conditions and filters) due to https://github.com/apache/druid/pull/9773\n+  // Hence, comma join will result in a cross join with filter on outermost", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f3dc681414f9b10bc9d37805d0965d6aceba58b1"}, "originalPosition": 373}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9926c3b92c682b2f4cf3d7ac5508482ff9374ba9", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/9926c3b92c682b2f4cf3d7ac5508482ff9374ba9", "committedDate": "2020-05-14T22:06:36Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "177e0bbf4b6537231b1f1746b212fd7de6fd2eab", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/177e0bbf4b6537231b1f1746b212fd7de6fd2eab", "committedDate": "2020-05-14T22:26:54Z", "message": "address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyMjYxMjY4", "url": "https://github.com/apache/druid/pull/9773#pullrequestreview-412261268", "createdAt": "2020-05-14T23:56:31Z", "commit": {"oid": "177e0bbf4b6537231b1f1746b212fd7de6fd2eab"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2587, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}