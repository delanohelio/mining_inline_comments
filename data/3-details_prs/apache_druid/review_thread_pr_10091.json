{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxMTU0NDM4", "number": 10091, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMzowODo0MlrOEJ3Xcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMDowMzo0N1rOEJ4I2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4Nzc5NzYyOnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/apache/druid/cli/ServerRunnable.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMzowODo0MlrOGqlmtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMDo1OToxNVrOGqnyFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMwOTQ5NQ==", "bodyText": "Is it possible to make the private constructor delegate to this one?", "url": "https://github.com/apache/druid/pull/10091#discussion_r447309495", "createdAt": "2020-06-29T23:08:42Z", "author": {"login": "ccaominh"}, "path": "services/src/main/java/org/apache/druid/cli/ServerRunnable.java", "diffHunk": "@@ -194,15 +202,40 @@ private DiscoverySideEffectsProvider(\n       this.useLegacyAnnouncer = useLegacyAnnouncer;\n     }\n \n+    @VisibleForTesting\n+    DiscoverySideEffectsProvider(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8962df87adac39ff2ac67a8eb7337994b3c72dd2"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyMzI5Mg==", "bodyText": "I'd need to refactor this to use Guice's AssistedInject Factory to avoid having 2 constructors - It's why I don't really like injected field members.\nIf you think it's worth the refactoring, I can make that change. I'll wait to see if there are any other comments before pushing up a new patch", "url": "https://github.com/apache/druid/pull/10091#discussion_r447323292", "createdAt": "2020-06-29T23:50:26Z", "author": {"login": "suneet-s"}, "path": "services/src/main/java/org/apache/druid/cli/ServerRunnable.java", "diffHunk": "@@ -194,15 +202,40 @@ private DiscoverySideEffectsProvider(\n       this.useLegacyAnnouncer = useLegacyAnnouncer;\n     }\n \n+    @VisibleForTesting\n+    DiscoverySideEffectsProvider(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMwOTQ5NQ=="}, "originalCommit": {"oid": "8962df87adac39ff2ac67a8eb7337994b3c72dd2"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNzQ2NA==", "bodyText": "Since this is a release blocker for 0.19, I don't think refactoring is necessary. FWIW I don't really like AssistedInject, it's a bit too magical for my taste.", "url": "https://github.com/apache/druid/pull/10091#discussion_r447327464", "createdAt": "2020-06-30T00:02:41Z", "author": {"login": "clintropolis"}, "path": "services/src/main/java/org/apache/druid/cli/ServerRunnable.java", "diffHunk": "@@ -194,15 +202,40 @@ private DiscoverySideEffectsProvider(\n       this.useLegacyAnnouncer = useLegacyAnnouncer;\n     }\n \n+    @VisibleForTesting\n+    DiscoverySideEffectsProvider(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMwOTQ5NQ=="}, "originalCommit": {"oid": "8962df87adac39ff2ac67a8eb7337994b3c72dd2"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyODYzNg==", "bodyText": "If it's complicated, I'm ok with doing the refactoring in a follow up PR.", "url": "https://github.com/apache/druid/pull/10091#discussion_r447328636", "createdAt": "2020-06-30T00:06:46Z", "author": {"login": "ccaominh"}, "path": "services/src/main/java/org/apache/druid/cli/ServerRunnable.java", "diffHunk": "@@ -194,15 +202,40 @@ private DiscoverySideEffectsProvider(\n       this.useLegacyAnnouncer = useLegacyAnnouncer;\n     }\n \n+    @VisibleForTesting\n+    DiscoverySideEffectsProvider(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMwOTQ5NQ=="}, "originalCommit": {"oid": "8962df87adac39ff2ac67a8eb7337994b3c72dd2"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM0NTE3Mg==", "bodyText": "I'll make this change in a follow up PR so we can push this through quickly", "url": "https://github.com/apache/druid/pull/10091#discussion_r447345172", "createdAt": "2020-06-30T00:59:15Z", "author": {"login": "suneet-s"}, "path": "services/src/main/java/org/apache/druid/cli/ServerRunnable.java", "diffHunk": "@@ -194,15 +202,40 @@ private DiscoverySideEffectsProvider(\n       this.useLegacyAnnouncer = useLegacyAnnouncer;\n     }\n \n+    @VisibleForTesting\n+    DiscoverySideEffectsProvider(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMwOTQ5NQ=="}, "originalCommit": {"oid": "8962df87adac39ff2ac67a8eb7337994b3c72dd2"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NzgzNDQxOnYy", "diffSide": "RIGHT", "path": "services/src/test/java/org/apache/druid/cli/DiscoverySideEffectsProviderTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMzoyNTowN1rOGql76Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMDo0MDoxNlrOGqncnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxNDkyMQ==", "bodyText": "Should the code that asserts isAllServicesDiscoverable be moved from setUp to here? When I was reading just this test, it was not clear to me how it was checking that the announcements were getting added.", "url": "https://github.com/apache/druid/pull/10091#discussion_r447314921", "createdAt": "2020-06-29T23:25:07Z", "author": {"login": "ccaominh"}, "path": "services/src/test/java/org/apache/druid/cli/DiscoverySideEffectsProviderTest.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.cli;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.inject.Injector;\n+import org.apache.druid.curator.discovery.ServiceAnnouncer;\n+import org.apache.druid.discovery.DiscoveryDruidNode;\n+import org.apache.druid.discovery.DruidNodeAnnouncer;\n+import org.apache.druid.discovery.DruidService;\n+import org.apache.druid.discovery.NodeRole;\n+import org.apache.druid.java.util.common.lifecycle.Lifecycle;\n+import org.apache.druid.server.DruidNode;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class DiscoverySideEffectsProviderTest\n+{\n+  private static final boolean USE_LEGACY_ANNOUNCER = true;\n+\n+  private NodeRole nodeRole;\n+  @Mock\n+  private DruidNode druidNode;\n+  @Mock\n+  private DruidNodeAnnouncer announcer;\n+  @Mock\n+  private ServiceAnnouncer legacyAnnouncer;\n+  @Mock\n+  private Lifecycle lifecycle;\n+  @Mock\n+  private Injector injector;\n+  private List<Lifecycle.Handler> lifecycleHandlers;\n+\n+  private ServerRunnable.DiscoverySideEffectsProvider target;\n+\n+  @Before\n+  public void setUp()\n+  {\n+    nodeRole = NodeRole.HISTORICAL;\n+    lifecycleHandlers = new ArrayList<>();\n+    Mockito.when(injector.getInstance(DiscoverableDruidService.class)).thenReturn(new DiscoverableDruidService());\n+    Mockito.when(injector.getInstance(UnDiscoverableDruidService.class)).thenReturn(new UnDiscoverableDruidService());\n+    Mockito.doAnswer((invocation) -> {\n+      DiscoveryDruidNode discoveryDruidNode = invocation.getArgument(0);\n+      boolean isAllServicesDiscoverable =\n+          discoveryDruidNode.getServices().values().stream().allMatch(DruidService::isDiscoverable);\n+      Assert.assertTrue(isAllServicesDiscoverable);\n+      return null;\n+    }).when(announcer).announce(ArgumentMatchers.any(DiscoveryDruidNode.class));\n+    Mockito.doAnswer((invocation) -> lifecycleHandlers.add(invocation.getArgument(0)))\n+           .when(lifecycle).addHandler(\n+        ArgumentMatchers.any(Lifecycle.Handler.class),\n+        ArgumentMatchers.eq(Lifecycle.Stage.ANNOUNCEMENTS)\n+      );\n+    target = new ServerRunnable.DiscoverySideEffectsProvider(\n+        nodeRole,\n+        ImmutableList.of(DiscoverableDruidService.class, UnDiscoverableDruidService.class),\n+        USE_LEGACY_ANNOUNCER,\n+        druidNode,\n+        announcer,\n+        legacyAnnouncer,\n+        lifecycle,\n+        injector\n+    );\n+  }\n+\n+  @Test\n+  public void testGetShouldAddAnnouncementsForDiscoverableServices() throws Exception\n+  {\n+    ServerRunnable.DiscoverySideEffectsProvider.Child child = target.get();\n+    Assert.assertNotNull(child);\n+    Assert.assertEquals(1, lifecycleHandlers.size());\n+    lifecycleHandlers.get(0).start();\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8962df87adac39ff2ac67a8eb7337994b3c72dd2"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyMjQ2Mg==", "bodyText": "Fair point. I wrote this so that the announcer is wired up to fail if it tries to announce an undiscoverable service.\nIt was tricky to wire up the validation because DiscoveryDruidNode is instantiated when the provider is called and the Child object that is returned just appears to be an empty object. I couldn't think of a better way to wire up the validations without refactoring some production code.", "url": "https://github.com/apache/druid/pull/10091#discussion_r447322462", "createdAt": "2020-06-29T23:47:41Z", "author": {"login": "suneet-s"}, "path": "services/src/test/java/org/apache/druid/cli/DiscoverySideEffectsProviderTest.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.cli;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.inject.Injector;\n+import org.apache.druid.curator.discovery.ServiceAnnouncer;\n+import org.apache.druid.discovery.DiscoveryDruidNode;\n+import org.apache.druid.discovery.DruidNodeAnnouncer;\n+import org.apache.druid.discovery.DruidService;\n+import org.apache.druid.discovery.NodeRole;\n+import org.apache.druid.java.util.common.lifecycle.Lifecycle;\n+import org.apache.druid.server.DruidNode;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class DiscoverySideEffectsProviderTest\n+{\n+  private static final boolean USE_LEGACY_ANNOUNCER = true;\n+\n+  private NodeRole nodeRole;\n+  @Mock\n+  private DruidNode druidNode;\n+  @Mock\n+  private DruidNodeAnnouncer announcer;\n+  @Mock\n+  private ServiceAnnouncer legacyAnnouncer;\n+  @Mock\n+  private Lifecycle lifecycle;\n+  @Mock\n+  private Injector injector;\n+  private List<Lifecycle.Handler> lifecycleHandlers;\n+\n+  private ServerRunnable.DiscoverySideEffectsProvider target;\n+\n+  @Before\n+  public void setUp()\n+  {\n+    nodeRole = NodeRole.HISTORICAL;\n+    lifecycleHandlers = new ArrayList<>();\n+    Mockito.when(injector.getInstance(DiscoverableDruidService.class)).thenReturn(new DiscoverableDruidService());\n+    Mockito.when(injector.getInstance(UnDiscoverableDruidService.class)).thenReturn(new UnDiscoverableDruidService());\n+    Mockito.doAnswer((invocation) -> {\n+      DiscoveryDruidNode discoveryDruidNode = invocation.getArgument(0);\n+      boolean isAllServicesDiscoverable =\n+          discoveryDruidNode.getServices().values().stream().allMatch(DruidService::isDiscoverable);\n+      Assert.assertTrue(isAllServicesDiscoverable);\n+      return null;\n+    }).when(announcer).announce(ArgumentMatchers.any(DiscoveryDruidNode.class));\n+    Mockito.doAnswer((invocation) -> lifecycleHandlers.add(invocation.getArgument(0)))\n+           .when(lifecycle).addHandler(\n+        ArgumentMatchers.any(Lifecycle.Handler.class),\n+        ArgumentMatchers.eq(Lifecycle.Stage.ANNOUNCEMENTS)\n+      );\n+    target = new ServerRunnable.DiscoverySideEffectsProvider(\n+        nodeRole,\n+        ImmutableList.of(DiscoverableDruidService.class, UnDiscoverableDruidService.class),\n+        USE_LEGACY_ANNOUNCER,\n+        druidNode,\n+        announcer,\n+        legacyAnnouncer,\n+        lifecycle,\n+        injector\n+    );\n+  }\n+\n+  @Test\n+  public void testGetShouldAddAnnouncementsForDiscoverableServices() throws Exception\n+  {\n+    ServerRunnable.DiscoverySideEffectsProvider.Child child = target.get();\n+    Assert.assertNotNull(child);\n+    Assert.assertEquals(1, lifecycleHandlers.size());\n+    lifecycleHandlers.get(0).start();\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxNDkyMQ=="}, "originalCommit": {"oid": "8962df87adac39ff2ac67a8eb7337994b3c72dd2"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzOTY3Nw==", "bodyText": "Added comments to try and describe the behavior better.", "url": "https://github.com/apache/druid/pull/10091#discussion_r447339677", "createdAt": "2020-06-30T00:40:16Z", "author": {"login": "suneet-s"}, "path": "services/src/test/java/org/apache/druid/cli/DiscoverySideEffectsProviderTest.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.cli;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.inject.Injector;\n+import org.apache.druid.curator.discovery.ServiceAnnouncer;\n+import org.apache.druid.discovery.DiscoveryDruidNode;\n+import org.apache.druid.discovery.DruidNodeAnnouncer;\n+import org.apache.druid.discovery.DruidService;\n+import org.apache.druid.discovery.NodeRole;\n+import org.apache.druid.java.util.common.lifecycle.Lifecycle;\n+import org.apache.druid.server.DruidNode;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.ArgumentMatchers;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class DiscoverySideEffectsProviderTest\n+{\n+  private static final boolean USE_LEGACY_ANNOUNCER = true;\n+\n+  private NodeRole nodeRole;\n+  @Mock\n+  private DruidNode druidNode;\n+  @Mock\n+  private DruidNodeAnnouncer announcer;\n+  @Mock\n+  private ServiceAnnouncer legacyAnnouncer;\n+  @Mock\n+  private Lifecycle lifecycle;\n+  @Mock\n+  private Injector injector;\n+  private List<Lifecycle.Handler> lifecycleHandlers;\n+\n+  private ServerRunnable.DiscoverySideEffectsProvider target;\n+\n+  @Before\n+  public void setUp()\n+  {\n+    nodeRole = NodeRole.HISTORICAL;\n+    lifecycleHandlers = new ArrayList<>();\n+    Mockito.when(injector.getInstance(DiscoverableDruidService.class)).thenReturn(new DiscoverableDruidService());\n+    Mockito.when(injector.getInstance(UnDiscoverableDruidService.class)).thenReturn(new UnDiscoverableDruidService());\n+    Mockito.doAnswer((invocation) -> {\n+      DiscoveryDruidNode discoveryDruidNode = invocation.getArgument(0);\n+      boolean isAllServicesDiscoverable =\n+          discoveryDruidNode.getServices().values().stream().allMatch(DruidService::isDiscoverable);\n+      Assert.assertTrue(isAllServicesDiscoverable);\n+      return null;\n+    }).when(announcer).announce(ArgumentMatchers.any(DiscoveryDruidNode.class));\n+    Mockito.doAnswer((invocation) -> lifecycleHandlers.add(invocation.getArgument(0)))\n+           .when(lifecycle).addHandler(\n+        ArgumentMatchers.any(Lifecycle.Handler.class),\n+        ArgumentMatchers.eq(Lifecycle.Stage.ANNOUNCEMENTS)\n+      );\n+    target = new ServerRunnable.DiscoverySideEffectsProvider(\n+        nodeRole,\n+        ImmutableList.of(DiscoverableDruidService.class, UnDiscoverableDruidService.class),\n+        USE_LEGACY_ANNOUNCER,\n+        druidNode,\n+        announcer,\n+        legacyAnnouncer,\n+        lifecycle,\n+        injector\n+    );\n+  }\n+\n+  @Test\n+  public void testGetShouldAddAnnouncementsForDiscoverableServices() throws Exception\n+  {\n+    ServerRunnable.DiscoverySideEffectsProvider.Child child = target.get();\n+    Assert.assertNotNull(child);\n+    Assert.assertEquals(1, lifecycleHandlers.size());\n+    lifecycleHandlers.get(0).start();\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMxNDkyMQ=="}, "originalCommit": {"oid": "8962df87adac39ff2ac67a8eb7337994b3c72dd2"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NzkxMzM3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/druid/guice/StorageNodeModule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMzo1OToxOFrOGqmn7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMDozNToxOFrOGqnW8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNjE4OQ==", "bodyText": "nit: this log should probably include the implications, such as it will not be assignable for segment placement.", "url": "https://github.com/apache/druid/pull/10091#discussion_r447326189", "createdAt": "2020-06-29T23:59:18Z", "author": {"login": "clintropolis"}, "path": "server/src/main/java/org/apache/druid/guice/StorageNodeModule.java", "diffHunk": "@@ -74,17 +82,36 @@ public DruidServerMetadata getMetadata(\n \n   @Provides\n   @LazySingleton\n-  public DataNodeService getDataNodeService(@Nullable ServerTypeConfig serverTypeConfig, DruidServerConfig config)\n+  public DataNodeService getDataNodeService(\n+      @Nullable ServerTypeConfig serverTypeConfig,\n+      DruidServerConfig config,\n+      @Named(IS_SEGMENT_CACHE_CONFIGURED) Boolean isSegmentCacheConfigured\n+  )\n   {\n     if (serverTypeConfig == null) {\n-      throw new ProvisionException(\"Must override the binding for ServerTypeConfig if you want a DruidServerMetadata.\");\n+      throw new ProvisionException(\"Must override the binding for ServerTypeConfig if you want a DataNodeService.\");\n+    }\n+    if (!isSegmentCacheConfigured) {\n+      log.info(\"Segment cache not configured on ServerType [%s]\", serverTypeConfig.getServerType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8962df87adac39ff2ac67a8eb7337994b3c72dd2"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzODIyNw==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/10091#discussion_r447338227", "createdAt": "2020-06-30T00:35:18Z", "author": {"login": "suneet-s"}, "path": "server/src/main/java/org/apache/druid/guice/StorageNodeModule.java", "diffHunk": "@@ -74,17 +82,36 @@ public DruidServerMetadata getMetadata(\n \n   @Provides\n   @LazySingleton\n-  public DataNodeService getDataNodeService(@Nullable ServerTypeConfig serverTypeConfig, DruidServerConfig config)\n+  public DataNodeService getDataNodeService(\n+      @Nullable ServerTypeConfig serverTypeConfig,\n+      DruidServerConfig config,\n+      @Named(IS_SEGMENT_CACHE_CONFIGURED) Boolean isSegmentCacheConfigured\n+  )\n   {\n     if (serverTypeConfig == null) {\n-      throw new ProvisionException(\"Must override the binding for ServerTypeConfig if you want a DruidServerMetadata.\");\n+      throw new ProvisionException(\"Must override the binding for ServerTypeConfig if you want a DataNodeService.\");\n+    }\n+    if (!isSegmentCacheConfigured) {\n+      log.info(\"Segment cache not configured on ServerType [%s]\", serverTypeConfig.getServerType());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNjE4OQ=="}, "originalCommit": {"oid": "8962df87adac39ff2ac67a8eb7337994b3c72dd2"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NzkyNDA4OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/apache/druid/cli/ServerRunnable.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMDowMzo0N1rOGqmuCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMDozNjoxMFrOGqnYCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNzc1NQ==", "bodyText": "nit: this log should also maybe be more informative that the service is being skipped and will not be listed as a service the node provides i think", "url": "https://github.com/apache/druid/pull/10091#discussion_r447327755", "createdAt": "2020-06-30T00:03:47Z", "author": {"login": "clintropolis"}, "path": "services/src/main/java/org/apache/druid/cli/ServerRunnable.java", "diffHunk": "@@ -194,15 +202,40 @@ private DiscoverySideEffectsProvider(\n       this.useLegacyAnnouncer = useLegacyAnnouncer;\n     }\n \n+    @VisibleForTesting\n+    DiscoverySideEffectsProvider(\n+        final NodeRole nodeRole,\n+        final List<Class<? extends DruidService>> serviceClasses,\n+        final boolean useLegacyAnnouncer,\n+        final DruidNode druidNode,\n+        final DruidNodeAnnouncer announcer,\n+        final ServiceAnnouncer legacyAnnouncer,\n+        final Lifecycle lifecycle,\n+        final Injector injector\n+    )\n+    {\n+      this.nodeRole = nodeRole;\n+      this.serviceClasses = serviceClasses;\n+      this.useLegacyAnnouncer = useLegacyAnnouncer;\n+      this.druidNode = druidNode;\n+      this.announcer = announcer;\n+      this.legacyAnnouncer = legacyAnnouncer;\n+      this.lifecycle = lifecycle;\n+      this.injector = injector;\n+    }\n+\n     @Override\n     public Child get()\n     {\n       ImmutableMap.Builder<String, DruidService> builder = new ImmutableMap.Builder<>();\n       for (Class<? extends DruidService> clazz : serviceClasses) {\n         DruidService service = injector.getInstance(clazz);\n-        builder.put(service.getName(), service);\n+        if (service.isDiscoverable()) {\n+          builder.put(service.getName(), service);\n+        } else {\n+          log.info(\"Service[%s] is not discoverable\", service.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8962df87adac39ff2ac67a8eb7337994b3c72dd2"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMzODUwNg==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/10091#discussion_r447338506", "createdAt": "2020-06-30T00:36:10Z", "author": {"login": "suneet-s"}, "path": "services/src/main/java/org/apache/druid/cli/ServerRunnable.java", "diffHunk": "@@ -194,15 +202,40 @@ private DiscoverySideEffectsProvider(\n       this.useLegacyAnnouncer = useLegacyAnnouncer;\n     }\n \n+    @VisibleForTesting\n+    DiscoverySideEffectsProvider(\n+        final NodeRole nodeRole,\n+        final List<Class<? extends DruidService>> serviceClasses,\n+        final boolean useLegacyAnnouncer,\n+        final DruidNode druidNode,\n+        final DruidNodeAnnouncer announcer,\n+        final ServiceAnnouncer legacyAnnouncer,\n+        final Lifecycle lifecycle,\n+        final Injector injector\n+    )\n+    {\n+      this.nodeRole = nodeRole;\n+      this.serviceClasses = serviceClasses;\n+      this.useLegacyAnnouncer = useLegacyAnnouncer;\n+      this.druidNode = druidNode;\n+      this.announcer = announcer;\n+      this.legacyAnnouncer = legacyAnnouncer;\n+      this.lifecycle = lifecycle;\n+      this.injector = injector;\n+    }\n+\n     @Override\n     public Child get()\n     {\n       ImmutableMap.Builder<String, DruidService> builder = new ImmutableMap.Builder<>();\n       for (Class<? extends DruidService> clazz : serviceClasses) {\n         DruidService service = injector.getInstance(clazz);\n-        builder.put(service.getName(), service);\n+        if (service.isDiscoverable()) {\n+          builder.put(service.getName(), service);\n+        } else {\n+          log.info(\"Service[%s] is not discoverable\", service.getName());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNzc1NQ=="}, "originalCommit": {"oid": "8962df87adac39ff2ac67a8eb7337994b3c72dd2"}, "originalPosition": 74}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2379, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}