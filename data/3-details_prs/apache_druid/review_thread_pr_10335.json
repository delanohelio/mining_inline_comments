{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc2MTM0ODAw", "number": 10335, "reviewThreads": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMDo0MTo1M1rOEqQsiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDo0MDozOVrOEv9_PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzQ5MTkzOnYy", "diffSide": "RIGHT", "path": "extensions-contrib/materialized-view-maintenance/src/test/java/org/apache/druid/indexing/materializedview/MaterializedViewSupervisorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMDo0MTo1M1rOHcXW_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwODoxMzoxOFrOHeS70A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwNDg5NQ==", "bodyText": "How is this test related to configurable index type?\nPlease add documentation line explaining the test", "url": "https://github.com/apache/druid/pull/10335#discussion_r499504895", "createdAt": "2020-10-05T10:41:53Z", "author": {"login": "Eshcar"}, "path": "extensions-contrib/materialized-view-maintenance/src/test/java/org/apache/druid/indexing/materializedview/MaterializedViewSupervisorTest.java", "diffHunk": "@@ -317,6 +318,32 @@ public void testCheckSegmentsAndSubmitTasks() throws IOException\n \n   }\n \n+  @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyOTU1Mg==", "bodyText": "Added", "url": "https://github.com/apache/druid/pull/10335#discussion_r501529552", "createdAt": "2020-10-08T08:13:18Z", "author": {"login": "liran-funaro"}, "path": "extensions-contrib/materialized-view-maintenance/src/test/java/org/apache/druid/indexing/materializedview/MaterializedViewSupervisorTest.java", "diffHunk": "@@ -317,6 +318,32 @@ public void testCheckSegmentsAndSubmitTasks() throws IOException\n \n   }\n \n+  @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwNDg5NQ=="}, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzUwMTc2OnYy", "diffSide": "RIGHT", "path": "extensions-core/kafka-indexing-service/src/test/java/org/apache/druid/indexing/kafka/KafkaIndexTaskTuningConfigTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMDo0NDo1OFrOHcXdCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTo1MTo0OVrOHelOuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwNjQ0MA==", "bodyText": "a way to avoid the null (in multiple places) is to add another ctor that takes additional param while supporting prev ctor", "url": "https://github.com/apache/druid/pull/10335#discussion_r499506440", "createdAt": "2020-10-05T10:44:58Z", "author": {"login": "Eshcar"}, "path": "extensions-core/kafka-indexing-service/src/test/java/org/apache/druid/indexing/kafka/KafkaIndexTaskTuningConfigTest.java", "diffHunk": "@@ -115,6 +115,7 @@ public void testSerdeWithNonDefaults() throws Exception\n   public void testConvert()\n   {\n     KafkaSupervisorTuningConfig original = new KafkaSupervisorTuningConfig(\n+        null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyOTMwNQ==", "bodyText": "I think it is best to avoid a new constructor here.\nOtherwise, each new parameter will incur a new constructor.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501829305", "createdAt": "2020-10-08T15:51:49Z", "author": {"login": "liran-funaro"}, "path": "extensions-core/kafka-indexing-service/src/test/java/org/apache/druid/indexing/kafka/KafkaIndexTaskTuningConfigTest.java", "diffHunk": "@@ -115,6 +115,7 @@ public void testSerdeWithNonDefaults() throws Exception\n   public void testConvert()\n   {\n     KafkaSupervisorTuningConfig original = new KafkaSupervisorTuningConfig(\n+        null,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwNjQ0MA=="}, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzUwNjA3OnYy", "diffSide": "RIGHT", "path": "extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMDo0NjoxNlrOHcXfsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTo1MTo1N1rOHelPAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwNzEyMQ==", "bodyText": "likewise null parameter", "url": "https://github.com/apache/druid/pull/10335#discussion_r499507121", "createdAt": "2020-10-05T10:46:16Z", "author": {"login": "Eshcar"}, "path": "extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java", "diffHunk": "@@ -2739,6 +2739,7 @@ private KinesisIndexTask createTask(\n     boolean resetOffsetAutomatically = false;\n     int maxRowsInMemory = 1000;\n     final KinesisIndexTaskTuningConfig tuningConfig = new KinesisIndexTaskTuningConfig(\n+        null,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyOTM3Nw==", "bodyText": "See above.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501829377", "createdAt": "2020-10-08T15:51:57Z", "author": {"login": "liran-funaro"}, "path": "extensions-core/kinesis-indexing-service/src/test/java/org/apache/druid/indexing/kinesis/KinesisIndexTaskTest.java", "diffHunk": "@@ -2739,6 +2739,7 @@ private KinesisIndexTask createTask(\n     boolean resetOffsetAutomatically = false;\n     int maxRowsInMemory = 1000;\n     final KinesisIndexTaskTuningConfig tuningConfig = new KinesisIndexTaskTuningConfig(\n+        null,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwNzEyMQ=="}, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzUxMjU3OnYy", "diffSide": "RIGHT", "path": "indexing-hadoop/src/main/java/org/apache/druid/indexer/HadoopTuningConfig.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMDo0ODoyNVrOHcXjvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTozODowNlrOHekojw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwODE1OQ==", "bodyText": "add comment about this being the line that sets the (configurable) I2 type", "url": "https://github.com/apache/druid/pull/10335#discussion_r499508159", "createdAt": "2020-10-05T10:48:25Z", "author": {"login": "Eshcar"}, "path": "indexing-hadoop/src/main/java/org/apache/druid/indexer/HadoopTuningConfig.java", "diffHunk": "@@ -140,6 +144,7 @@ public HadoopTuningConfig(\n     this.rowFlushBoundary = maxRowsInMemory == null ? maxRowsInMemoryCOMPAT == null\n                                                       ? DEFAULT_ROW_FLUSH_BOUNDARY\n                                                       : maxRowsInMemoryCOMPAT : maxRowsInMemory;\n+    this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc0MDEwMA==", "bodyText": "@liran-funaro Could you please address this?", "url": "https://github.com/apache/druid/pull/10335#discussion_r501740100", "createdAt": "2020-10-08T13:54:44Z", "author": {"login": "a2l007"}, "path": "indexing-hadoop/src/main/java/org/apache/druid/indexer/HadoopTuningConfig.java", "diffHunk": "@@ -140,6 +144,7 @@ public HadoopTuningConfig(\n     this.rowFlushBoundary = maxRowsInMemory == null ? maxRowsInMemoryCOMPAT == null\n                                                       ? DEFAULT_ROW_FLUSH_BOUNDARY\n                                                       : maxRowsInMemoryCOMPAT : maxRowsInMemory;\n+    this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwODE1OQ=="}, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgxOTUzNQ==", "bodyText": "I'm unsure why this line needs to be documented. It is no different from any of the other tuning configurations in this constructor.\nAppendableIndexSpec is documented, so it is self-explanatory.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501819535", "createdAt": "2020-10-08T15:38:06Z", "author": {"login": "liran-funaro"}, "path": "indexing-hadoop/src/main/java/org/apache/druid/indexer/HadoopTuningConfig.java", "diffHunk": "@@ -140,6 +144,7 @@ public HadoopTuningConfig(\n     this.rowFlushBoundary = maxRowsInMemory == null ? maxRowsInMemoryCOMPAT == null\n                                                       ? DEFAULT_ROW_FLUSH_BOUNDARY\n                                                       : maxRowsInMemoryCOMPAT : maxRowsInMemory;\n+    this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwODE1OQ=="}, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzUxOTYyOnYy", "diffSide": "RIGHT", "path": "indexing-hadoop/src/main/java/org/apache/druid/indexer/IndexGeneratorJob.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMDo1MDo0MVrOHcXoHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNjowMToyMlrOHeloZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwOTI3Ng==", "bodyText": "add comment: this is the line that makes I2 configurable", "url": "https://github.com/apache/druid/pull/10335#discussion_r499509276", "createdAt": "2020-10-05T10:50:41Z", "author": {"login": "Eshcar"}, "path": "indexing-hadoop/src/main/java/org/apache/druid/indexer/IndexGeneratorJob.java", "diffHunk": "@@ -302,11 +301,11 @@ private static IncrementalIndex makeIncrementalIndex(\n         .withRollup(config.getSchema().getDataSchema().getGranularitySpec().isRollup())\n         .build();\n \n-    IncrementalIndex newIndex = new IncrementalIndex.Builder()\n+    IncrementalIndex newIndex = tuningConfig.getAppendableIndexSpec().builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgzNTg3OA==", "bodyText": "Done", "url": "https://github.com/apache/druid/pull/10335#discussion_r501835878", "createdAt": "2020-10-08T16:01:22Z", "author": {"login": "liran-funaro"}, "path": "indexing-hadoop/src/main/java/org/apache/druid/indexer/IndexGeneratorJob.java", "diffHunk": "@@ -302,11 +301,11 @@ private static IncrementalIndex makeIncrementalIndex(\n         .withRollup(config.getSchema().getDataSchema().getGranularitySpec().isRollup())\n         .build();\n \n-    IncrementalIndex newIndex = new IncrementalIndex.Builder()\n+    IncrementalIndex newIndex = tuningConfig.getAppendableIndexSpec().builder()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwOTI3Ng=="}, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzUyMzkzOnYy", "diffSide": "RIGHT", "path": "extensions-core/kafka-indexing-service/src/main/java/org/apache/druid/indexing/kafka/supervisor/KafkaSupervisorTuningConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMDo1MjowOVrOHcXq7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMDo1MjowOVrOHcXq7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUwOTk5OQ==", "bodyText": "nice. Looks like a change in the right direction", "url": "https://github.com/apache/druid/pull/10335#discussion_r499509999", "createdAt": "2020-10-05T10:52:09Z", "author": {"login": "Eshcar"}, "path": "extensions-core/kafka-indexing-service/src/main/java/org/apache/druid/indexing/kafka/supervisor/KafkaSupervisorTuningConfig.java", "diffHunk": "@@ -193,7 +196,7 @@ public String toString()\n            \"maxRowsInMemory=\" + getMaxRowsInMemory() +\n            \", maxRowsPerSegment=\" + getMaxRowsPerSegment() +\n            \", maxTotalRows=\" + getMaxTotalRows() +\n-           \", maxBytesInMemory=\" + TuningConfigs.getMaxBytesInMemoryOrDefault(getMaxBytesInMemory()) +\n+           \", maxBytesInMemory=\" + getMaxBytesInMemoryOrDefault() +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzUzMDgzOnYy", "diffSide": "RIGHT", "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/index/RealtimeAppenderatorTuningConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMDo1NDoyM1rOHcXvHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTo1NDo0MFrOHelWMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxMTA2OA==", "bodyText": "having this code duplicated is weird\nShouldn't all these XXXTuningConfig have some common parent with the shared code?", "url": "https://github.com/apache/druid/pull/10335#discussion_r499511068", "createdAt": "2020-10-05T10:54:23Z", "author": {"login": "Eshcar"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/index/RealtimeAppenderatorTuningConfig.java", "diffHunk": "@@ -93,6 +96,7 @@ public RealtimeAppenderatorTuningConfig(\n       @JsonProperty(\"maxSavedParseExceptions\") @Nullable Integer maxSavedParseExceptions\n   )\n   {\n+    this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgzMTIxNw==", "bodyText": "I agree. But that will require a refactor to unify some of the TuningConfig implementations to one common (abstract?) implementation.\nThis can be done before or after this PR.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501831217", "createdAt": "2020-10-08T15:54:40Z", "author": {"login": "liran-funaro"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/index/RealtimeAppenderatorTuningConfig.java", "diffHunk": "@@ -93,6 +96,7 @@ public RealtimeAppenderatorTuningConfig(\n       @JsonProperty(\"maxSavedParseExceptions\") @Nullable Integer maxSavedParseExceptions\n   )\n   {\n+    this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxMTA2OA=="}, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzUzMzc3OnYy", "diffSide": "RIGHT", "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/IndexTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMDo1NToyNlrOHcXxCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNTo1NDo1NVrOHelXAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxMTU2Mg==", "bodyText": "likewise duplicate code", "url": "https://github.com/apache/druid/pull/10335#discussion_r499511562", "createdAt": "2020-10-05T10:55:26Z", "author": {"login": "Eshcar"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/IndexTask.java", "diffHunk": "@@ -1262,6 +1267,7 @@ private IndexTuningConfig(\n         @Nullable Integer maxSavedParseExceptions\n     )\n     {\n+      this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgzMTQyNA==", "bodyText": "See above.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501831424", "createdAt": "2020-10-08T15:54:55Z", "author": {"login": "liran-funaro"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/IndexTask.java", "diffHunk": "@@ -1262,6 +1267,7 @@ private IndexTuningConfig(\n         @Nullable Integer maxSavedParseExceptions\n     )\n     {\n+      this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxMTU2Mg=="}, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzU0MTM4OnYy", "diffSide": "RIGHT", "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/sampler/InputSourceSampler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMDo1Nzo0NFrOHcX1tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMDo1Nzo0NFrOHcX1tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxMjc1OA==", "bodyText": "is this down-casting required?", "url": "https://github.com/apache/druid/pull/10335#discussion_r499512758", "createdAt": "2020-10-05T10:57:44Z", "author": {"login": "Eshcar"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/overlord/sampler/InputSourceSampler.java", "diffHunk": "@@ -210,8 +211,8 @@ private InputSourceReader buildReader(\n         .withRollup(dataSchema.getGranularitySpec().isRollup())\n         .build();\n \n-    return new IncrementalIndex.Builder().setIndexSchema(schema)\n+    return (OnheapIncrementalIndex) new OnheapIncrementalIndex.Builder().setIndexSchema(schema)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzU1MTEzOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/groupby/GroupByQueryHelper.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMTowMDozMFrOHcX7aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMTowMDozMFrOHcX7aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxNDIxNw==", "bodyText": "great. reducing duplication", "url": "https://github.com/apache/druid/pull/10335#discussion_r499514217", "createdAt": "2020-10-05T11:00:30Z", "author": {"login": "Eshcar"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/GroupByQueryHelper.java", "diffHunk": "@@ -117,24 +120,24 @@ public String apply(DimensionSpec input)\n         .withMinTimestamp(granTimeStart.getMillis())\n         .build();\n \n+\n+    AppendableIndexBuilder indexBuilder;\n+\n     if (query.getContextValue(\"useOffheap\", false)) {\n-      index = new IncrementalIndex.Builder()\n-          .setIndexSchema(indexSchema)\n-          .setDeserializeComplexMetrics(false)\n-          .setConcurrentEventAdd(true)\n-          .setSortFacts(sortResults)\n-          .setMaxRowCount(querySpecificConfig.getMaxResults())\n-          .buildOffheap(bufferPool);\n+      indexBuilder = new OffheapIncrementalIndex.Builder()\n+          .setBufferPool(bufferPool);\n     } else {\n-      index = new IncrementalIndex.Builder()\n-          .setIndexSchema(indexSchema)\n-          .setDeserializeComplexMetrics(false)\n-          .setConcurrentEventAdd(true)\n-          .setSortFacts(sortResults)\n-          .setMaxRowCount(querySpecificConfig.getMaxResults())\n-          .buildOnheap();\n+      indexBuilder = new OnheapIncrementalIndex.Builder();\n     }\n \n+    index = indexBuilder", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzU3MzE0OnYy", "diffSide": "LEFT", "path": "processing/src/main/java/org/apache/druid/segment/incremental/IncrementalIndex.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMTowNzo0M1rOHcYJDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMTowNzo0M1rOHcYJDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxNzcxMA==", "bodyText": "so this static class has now changed to an abstract class with different concrete builder classes - nice", "url": "https://github.com/apache/druid/pull/10335#discussion_r499517710", "createdAt": "2020-10-05T11:07:43Z", "author": {"login": "Eshcar"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/IncrementalIndex.java", "diffHunk": "@@ -319,129 +316,6 @@ protected IncrementalIndex(\n     }\n   }\n \n-  public static class Builder", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzU3Nzg1OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMTowOTowOFrOHcYL5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMTowOTowOFrOHcYL5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxODQzOQ==", "bodyText": "nice - simpler", "url": "https://github.com/apache/druid/pull/10335#discussion_r499518439", "createdAt": "2020-10-05T11:09:08Z", "author": {"login": "Eshcar"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "diffHunk": "@@ -129,15 +136,11 @@ public FactsHolder getFacts()\n           new OnheapIncrementalIndex.CachingColumnSelectorFactory(columnSelectorFactory, concurrentEventAdd)\n       );\n \n-      if (i == 0) {\n-        aggOffsetInBuffer[i] = 0;\n-      } else {\n-        aggOffsetInBuffer[i] = aggOffsetInBuffer[i - 1] + metrics[i - 1].getMaxIntermediateSizeWithNulls();\n-      }\n+      aggOffsetInBuffer[i] = aggsCurOffsetInBuffer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzU4NjA1OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMToxMToyMlrOHcYQvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNDoxMDo1OFrOHdI34w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxOTY3OA==", "bodyText": "why is this correct?", "url": "https://github.com/apache/druid/pull/10335#discussion_r499519678", "createdAt": "2020-10-05T11:11:22Z", "author": {"login": "Eshcar"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "diffHunk": "@@ -129,15 +136,11 @@ public FactsHolder getFacts()\n           new OnheapIncrementalIndex.CachingColumnSelectorFactory(columnSelectorFactory, concurrentEventAdd)\n       );\n \n-      if (i == 0) {\n-        aggOffsetInBuffer[i] = 0;\n-      } else {\n-        aggOffsetInBuffer[i] = aggOffsetInBuffer[i - 1] + metrics[i - 1].getMaxIntermediateSizeWithNulls();\n-      }\n+      aggOffsetInBuffer[i] = aggsCurOffsetInBuffer;\n+      aggsCurOffsetInBuffer += agg.getMaxIntermediateSizeWithNulls();\n     }\n \n-    aggsTotalSize = aggOffsetInBuffer[metrics.length - 1] + metrics[metrics.length\n-                                                                    - 1].getMaxIntermediateSizeWithNulls();\n+    aggsTotalSize = aggsCurOffsetInBuffer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxNjEzMQ==", "bodyText": "After the last aggregator, the next offset in the buffer is the total size of the buffer.", "url": "https://github.com/apache/druid/pull/10335#discussion_r500316131", "createdAt": "2020-10-06T14:10:58Z", "author": {"login": "liran-funaro"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "diffHunk": "@@ -129,15 +136,11 @@ public FactsHolder getFacts()\n           new OnheapIncrementalIndex.CachingColumnSelectorFactory(columnSelectorFactory, concurrentEventAdd)\n       );\n \n-      if (i == 0) {\n-        aggOffsetInBuffer[i] = 0;\n-      } else {\n-        aggOffsetInBuffer[i] = aggOffsetInBuffer[i - 1] + metrics[i - 1].getMaxIntermediateSizeWithNulls();\n-      }\n+      aggOffsetInBuffer[i] = aggsCurOffsetInBuffer;\n+      aggsCurOffsetInBuffer += agg.getMaxIntermediateSizeWithNulls();\n     }\n \n-    aggsTotalSize = aggOffsetInBuffer[metrics.length - 1] + metrics[metrics.length\n-                                                                    - 1].getMaxIntermediateSizeWithNulls();\n+    aggsTotalSize = aggsCurOffsetInBuffer;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUxOTY3OA=="}, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzU5MDY1OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMToxMjozOVrOHcYTXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNDoxMjowMVrOHdI7ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyMDM1MA==", "bodyText": "this method should return IncrementalIndex\nIs this legal to change the signature ?", "url": "https://github.com/apache/druid/pull/10335#discussion_r499520350", "createdAt": "2020-10-05T11:12:39Z", "author": {"login": "Eshcar"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "diffHunk": "@@ -346,4 +349,99 @@ public void close()\n     }\n     aggBuffers.clear();\n   }\n+\n+  public static class Builder extends AppendableIndexBuilder\n+  {\n+    @Nullable\n+    NonBlockingPool<ByteBuffer> bufferPool = null;\n+\n+    public Builder setBufferPool(final NonBlockingPool<ByteBuffer> bufferPool)\n+    {\n+      this.bufferPool = bufferPool;\n+      return this;\n+    }\n+\n+    @Override\n+    public void validate()\n+    {\n+      super.validate();\n+      if (bufferPool == null) {\n+        throw new IllegalArgumentException(\"bufferPool cannot be null\");\n+      }\n+    }\n+\n+    @Override\n+    protected OffheapIncrementalIndex buildInner()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxNzA5MQ==", "bodyText": "It is legal for an implementation to increase the requirement, but not to lower it.\nAs long as it conforms with the interface's contract.", "url": "https://github.com/apache/druid/pull/10335#discussion_r500317091", "createdAt": "2020-10-06T14:12:01Z", "author": {"login": "liran-funaro"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "diffHunk": "@@ -346,4 +349,99 @@ public void close()\n     }\n     aggBuffers.clear();\n   }\n+\n+  public static class Builder extends AppendableIndexBuilder\n+  {\n+    @Nullable\n+    NonBlockingPool<ByteBuffer> bufferPool = null;\n+\n+    public Builder setBufferPool(final NonBlockingPool<ByteBuffer> bufferPool)\n+    {\n+      this.bufferPool = bufferPool;\n+      return this;\n+    }\n+\n+    @Override\n+    public void validate()\n+    {\n+      super.validate();\n+      if (bufferPool == null) {\n+        throw new IllegalArgumentException(\"bufferPool cannot be null\");\n+      }\n+    }\n+\n+    @Override\n+    protected OffheapIncrementalIndex buildInner()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyMDM1MA=="}, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyNzYwMDYwOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/incremental/OnheapIncrementalIndex.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMToxNToyNVrOHcYY9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMToxNToyNVrOHcYY9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTUyMTc4Mg==", "bodyText": "likewise - diff signature than parent class", "url": "https://github.com/apache/druid/pull/10335#discussion_r499521782", "createdAt": "2020-10-05T11:15:25Z", "author": {"login": "Eshcar"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/OnheapIncrementalIndex.java", "diffHunk": "@@ -434,4 +436,39 @@ public ColumnCapabilities getColumnCapabilities(String columnName)\n     }\n   }\n \n+  public static class Builder extends AppendableIndexBuilder\n+  {\n+    @Override\n+    protected OnheapIncrementalIndex buildInner()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODcxNzIzOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/incremental/AppendableIndexBuilder.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNTo0NTo0MlrOHcjGJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNzo1NDowM1rOHeSOcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5NzE5MA==", "bodyText": "Would it make sense to make this abstract instead of having a separate buildInner() method ? We could leave the validation at the implementation level.", "url": "https://github.com/apache/druid/pull/10335#discussion_r499697190", "createdAt": "2020-10-05T15:45:42Z", "author": {"login": "a2l007"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/AppendableIndexBuilder.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.incremental;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+\n+import javax.annotation.Nullable;\n+\n+public abstract class AppendableIndexBuilder\n+{\n+  @Nullable\n+  protected IncrementalIndexSchema incrementalIndexSchema = null;\n+  protected boolean deserializeComplexMetrics = true;\n+  protected boolean concurrentEventAdd = false;\n+  protected boolean sortFacts = true;\n+  protected int maxRowCount = 0;\n+  protected long maxBytesInMemory = 0;\n+\n+  protected final Logger log = new Logger(this.getClass().getName());\n+\n+  public AppendableIndexBuilder setIndexSchema(final IncrementalIndexSchema incrementalIndexSchema)\n+  {\n+    this.incrementalIndexSchema = incrementalIndexSchema;\n+    return this;\n+  }\n+\n+  /**\n+   * A helper method to set a simple index schema with only metrics and default values for the other parameters. Note\n+   * that this method is normally used for testing and benchmarking; it is unlikely that you would use it in\n+   * production settings.\n+   *\n+   * @param metrics variable array of {@link AggregatorFactory} metrics\n+   *\n+   * @return this\n+   */\n+  @VisibleForTesting\n+  public AppendableIndexBuilder setSimpleTestingIndexSchema(final AggregatorFactory... metrics)\n+  {\n+    return setSimpleTestingIndexSchema(null, metrics);\n+  }\n+\n+\n+  /**\n+   * A helper method to set a simple index schema with controllable metrics and rollup, and default values for the\n+   * other parameters. Note that this method is normally used for testing and benchmarking; it is unlikely that you\n+   * would use it in production settings.\n+   *\n+   * @param metrics variable array of {@link AggregatorFactory} metrics\n+   *\n+   * @return this\n+   */\n+  @VisibleForTesting\n+  public AppendableIndexBuilder setSimpleTestingIndexSchema(@Nullable Boolean rollup, final AggregatorFactory... metrics)\n+  {\n+    IncrementalIndexSchema.Builder builder = new IncrementalIndexSchema.Builder().withMetrics(metrics);\n+    this.incrementalIndexSchema = rollup != null ? builder.withRollup(rollup).build() : builder.build();\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setDeserializeComplexMetrics(final boolean deserializeComplexMetrics)\n+  {\n+    this.deserializeComplexMetrics = deserializeComplexMetrics;\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setConcurrentEventAdd(final boolean concurrentEventAdd)\n+  {\n+    this.concurrentEventAdd = concurrentEventAdd;\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setSortFacts(final boolean sortFacts)\n+  {\n+    this.sortFacts = sortFacts;\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setMaxRowCount(final int maxRowCount)\n+  {\n+    this.maxRowCount = maxRowCount;\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setMaxBytesInMemory(final long maxBytesInMemory)\n+  {\n+    this.maxBytesInMemory = maxBytesInMemory;\n+    return this;\n+  }\n+\n+  public void validate()\n+  {\n+    if (maxRowCount <= 0) {\n+      throw new IllegalArgumentException(\"Invalid max row count: \" + maxRowCount);\n+    }\n+\n+    if (incrementalIndexSchema == null) {\n+      throw new IllegalArgumentException(\"incrementIndexSchema cannot be null\");\n+    }\n+  }\n+\n+  public final IncrementalIndex build()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDMxMjgzMQ==", "bodyText": "You're right, it would be more elegant without this buildInner() method.\nBut I was trying to avoid code duplication: having to call validate() and log.info() in each build() implementation.\nIt is marked as final exactly to enforce this behavior.\nI could rename it to something else, instantiate() for example.\nWhat do you think?", "url": "https://github.com/apache/druid/pull/10335#discussion_r500312831", "createdAt": "2020-10-06T14:07:46Z", "author": {"login": "liran-funaro"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/AppendableIndexBuilder.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.incremental;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+\n+import javax.annotation.Nullable;\n+\n+public abstract class AppendableIndexBuilder\n+{\n+  @Nullable\n+  protected IncrementalIndexSchema incrementalIndexSchema = null;\n+  protected boolean deserializeComplexMetrics = true;\n+  protected boolean concurrentEventAdd = false;\n+  protected boolean sortFacts = true;\n+  protected int maxRowCount = 0;\n+  protected long maxBytesInMemory = 0;\n+\n+  protected final Logger log = new Logger(this.getClass().getName());\n+\n+  public AppendableIndexBuilder setIndexSchema(final IncrementalIndexSchema incrementalIndexSchema)\n+  {\n+    this.incrementalIndexSchema = incrementalIndexSchema;\n+    return this;\n+  }\n+\n+  /**\n+   * A helper method to set a simple index schema with only metrics and default values for the other parameters. Note\n+   * that this method is normally used for testing and benchmarking; it is unlikely that you would use it in\n+   * production settings.\n+   *\n+   * @param metrics variable array of {@link AggregatorFactory} metrics\n+   *\n+   * @return this\n+   */\n+  @VisibleForTesting\n+  public AppendableIndexBuilder setSimpleTestingIndexSchema(final AggregatorFactory... metrics)\n+  {\n+    return setSimpleTestingIndexSchema(null, metrics);\n+  }\n+\n+\n+  /**\n+   * A helper method to set a simple index schema with controllable metrics and rollup, and default values for the\n+   * other parameters. Note that this method is normally used for testing and benchmarking; it is unlikely that you\n+   * would use it in production settings.\n+   *\n+   * @param metrics variable array of {@link AggregatorFactory} metrics\n+   *\n+   * @return this\n+   */\n+  @VisibleForTesting\n+  public AppendableIndexBuilder setSimpleTestingIndexSchema(@Nullable Boolean rollup, final AggregatorFactory... metrics)\n+  {\n+    IncrementalIndexSchema.Builder builder = new IncrementalIndexSchema.Builder().withMetrics(metrics);\n+    this.incrementalIndexSchema = rollup != null ? builder.withRollup(rollup).build() : builder.build();\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setDeserializeComplexMetrics(final boolean deserializeComplexMetrics)\n+  {\n+    this.deserializeComplexMetrics = deserializeComplexMetrics;\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setConcurrentEventAdd(final boolean concurrentEventAdd)\n+  {\n+    this.concurrentEventAdd = concurrentEventAdd;\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setSortFacts(final boolean sortFacts)\n+  {\n+    this.sortFacts = sortFacts;\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setMaxRowCount(final int maxRowCount)\n+  {\n+    this.maxRowCount = maxRowCount;\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setMaxBytesInMemory(final long maxBytesInMemory)\n+  {\n+    this.maxBytesInMemory = maxBytesInMemory;\n+    return this;\n+  }\n+\n+  public void validate()\n+  {\n+    if (maxRowCount <= 0) {\n+      throw new IllegalArgumentException(\"Invalid max row count: \" + maxRowCount);\n+    }\n+\n+    if (incrementalIndexSchema == null) {\n+      throw new IllegalArgumentException(\"incrementIndexSchema cannot be null\");\n+    }\n+  }\n+\n+  public final IncrementalIndex build()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5NzE5MA=="}, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzMDQzNQ==", "bodyText": "buildInner should be okay.\nIt might be better to switch the log level to DEBUG though.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501130435", "createdAt": "2020-10-07T16:01:35Z", "author": {"login": "a2l007"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/AppendableIndexBuilder.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.incremental;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+\n+import javax.annotation.Nullable;\n+\n+public abstract class AppendableIndexBuilder\n+{\n+  @Nullable\n+  protected IncrementalIndexSchema incrementalIndexSchema = null;\n+  protected boolean deserializeComplexMetrics = true;\n+  protected boolean concurrentEventAdd = false;\n+  protected boolean sortFacts = true;\n+  protected int maxRowCount = 0;\n+  protected long maxBytesInMemory = 0;\n+\n+  protected final Logger log = new Logger(this.getClass().getName());\n+\n+  public AppendableIndexBuilder setIndexSchema(final IncrementalIndexSchema incrementalIndexSchema)\n+  {\n+    this.incrementalIndexSchema = incrementalIndexSchema;\n+    return this;\n+  }\n+\n+  /**\n+   * A helper method to set a simple index schema with only metrics and default values for the other parameters. Note\n+   * that this method is normally used for testing and benchmarking; it is unlikely that you would use it in\n+   * production settings.\n+   *\n+   * @param metrics variable array of {@link AggregatorFactory} metrics\n+   *\n+   * @return this\n+   */\n+  @VisibleForTesting\n+  public AppendableIndexBuilder setSimpleTestingIndexSchema(final AggregatorFactory... metrics)\n+  {\n+    return setSimpleTestingIndexSchema(null, metrics);\n+  }\n+\n+\n+  /**\n+   * A helper method to set a simple index schema with controllable metrics and rollup, and default values for the\n+   * other parameters. Note that this method is normally used for testing and benchmarking; it is unlikely that you\n+   * would use it in production settings.\n+   *\n+   * @param metrics variable array of {@link AggregatorFactory} metrics\n+   *\n+   * @return this\n+   */\n+  @VisibleForTesting\n+  public AppendableIndexBuilder setSimpleTestingIndexSchema(@Nullable Boolean rollup, final AggregatorFactory... metrics)\n+  {\n+    IncrementalIndexSchema.Builder builder = new IncrementalIndexSchema.Builder().withMetrics(metrics);\n+    this.incrementalIndexSchema = rollup != null ? builder.withRollup(rollup).build() : builder.build();\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setDeserializeComplexMetrics(final boolean deserializeComplexMetrics)\n+  {\n+    this.deserializeComplexMetrics = deserializeComplexMetrics;\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setConcurrentEventAdd(final boolean concurrentEventAdd)\n+  {\n+    this.concurrentEventAdd = concurrentEventAdd;\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setSortFacts(final boolean sortFacts)\n+  {\n+    this.sortFacts = sortFacts;\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setMaxRowCount(final int maxRowCount)\n+  {\n+    this.maxRowCount = maxRowCount;\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setMaxBytesInMemory(final long maxBytesInMemory)\n+  {\n+    this.maxBytesInMemory = maxBytesInMemory;\n+    return this;\n+  }\n+\n+  public void validate()\n+  {\n+    if (maxRowCount <= 0) {\n+      throw new IllegalArgumentException(\"Invalid max row count: \" + maxRowCount);\n+    }\n+\n+    if (incrementalIndexSchema == null) {\n+      throw new IllegalArgumentException(\"incrementIndexSchema cannot be null\");\n+    }\n+  }\n+\n+  public final IncrementalIndex build()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5NzE5MA=="}, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNzkzNg==", "bodyText": "Changed to DEBUG.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501517936", "createdAt": "2020-10-08T07:54:03Z", "author": {"login": "liran-funaro"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/AppendableIndexBuilder.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.incremental;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.java.util.common.logger.Logger;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+\n+import javax.annotation.Nullable;\n+\n+public abstract class AppendableIndexBuilder\n+{\n+  @Nullable\n+  protected IncrementalIndexSchema incrementalIndexSchema = null;\n+  protected boolean deserializeComplexMetrics = true;\n+  protected boolean concurrentEventAdd = false;\n+  protected boolean sortFacts = true;\n+  protected int maxRowCount = 0;\n+  protected long maxBytesInMemory = 0;\n+\n+  protected final Logger log = new Logger(this.getClass().getName());\n+\n+  public AppendableIndexBuilder setIndexSchema(final IncrementalIndexSchema incrementalIndexSchema)\n+  {\n+    this.incrementalIndexSchema = incrementalIndexSchema;\n+    return this;\n+  }\n+\n+  /**\n+   * A helper method to set a simple index schema with only metrics and default values for the other parameters. Note\n+   * that this method is normally used for testing and benchmarking; it is unlikely that you would use it in\n+   * production settings.\n+   *\n+   * @param metrics variable array of {@link AggregatorFactory} metrics\n+   *\n+   * @return this\n+   */\n+  @VisibleForTesting\n+  public AppendableIndexBuilder setSimpleTestingIndexSchema(final AggregatorFactory... metrics)\n+  {\n+    return setSimpleTestingIndexSchema(null, metrics);\n+  }\n+\n+\n+  /**\n+   * A helper method to set a simple index schema with controllable metrics and rollup, and default values for the\n+   * other parameters. Note that this method is normally used for testing and benchmarking; it is unlikely that you\n+   * would use it in production settings.\n+   *\n+   * @param metrics variable array of {@link AggregatorFactory} metrics\n+   *\n+   * @return this\n+   */\n+  @VisibleForTesting\n+  public AppendableIndexBuilder setSimpleTestingIndexSchema(@Nullable Boolean rollup, final AggregatorFactory... metrics)\n+  {\n+    IncrementalIndexSchema.Builder builder = new IncrementalIndexSchema.Builder().withMetrics(metrics);\n+    this.incrementalIndexSchema = rollup != null ? builder.withRollup(rollup).build() : builder.build();\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setDeserializeComplexMetrics(final boolean deserializeComplexMetrics)\n+  {\n+    this.deserializeComplexMetrics = deserializeComplexMetrics;\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setConcurrentEventAdd(final boolean concurrentEventAdd)\n+  {\n+    this.concurrentEventAdd = concurrentEventAdd;\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setSortFacts(final boolean sortFacts)\n+  {\n+    this.sortFacts = sortFacts;\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setMaxRowCount(final int maxRowCount)\n+  {\n+    this.maxRowCount = maxRowCount;\n+    return this;\n+  }\n+\n+  public AppendableIndexBuilder setMaxBytesInMemory(final long maxBytesInMemory)\n+  {\n+    this.maxBytesInMemory = maxBytesInMemory;\n+    return this;\n+  }\n+\n+  public void validate()\n+  {\n+    if (maxRowCount <= 0) {\n+      throw new IllegalArgumentException(\"Invalid max row count: \" + maxRowCount);\n+    }\n+\n+    if (incrementalIndexSchema == null) {\n+      throw new IllegalArgumentException(\"incrementIndexSchema cannot be null\");\n+    }\n+  }\n+\n+  public final IncrementalIndex build()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTY5NzE5MA=="}, "originalCommit": {"oid": "efe35fd2a69b5c2ac7ae4381df4b4ad52380d6dd"}, "originalPosition": 120}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzM5Nzk1OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/incremental/IncrementalIndex.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNDoyNDo1NFrOHd2BQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNjoyMDowNFrOHemZFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA1NTgxMQ==", "bodyText": "Do we still need this method?", "url": "https://github.com/apache/druid/pull/10335#discussion_r501055811", "createdAt": "2020-10-07T14:24:54Z", "author": {"login": "a2l007"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/IncrementalIndex.java", "diffHunk": "@@ -319,126 +316,62 @@ protected IncrementalIndex(\n     }\n   }\n \n-  public static class Builder\n+  /**\n+   * This class exists only as backward competability to reduce the number of modified lines.\n+   */\n+  public static class Builder extends OnheapIncrementalIndex.Builder\n   {\n-    @Nullable\n-    private IncrementalIndexSchema incrementalIndexSchema;\n-    private boolean deserializeComplexMetrics;\n-    private boolean concurrentEventAdd;\n-    private boolean sortFacts;\n-    private int maxRowCount;\n-    private long maxBytesInMemory;\n-\n-    public Builder()\n-    {\n-      incrementalIndexSchema = null;\n-      deserializeComplexMetrics = true;\n-      concurrentEventAdd = false;\n-      sortFacts = true;\n-      maxRowCount = 0;\n-      maxBytesInMemory = 0;\n-    }\n-\n+    @Override\n     public Builder setIndexSchema(final IncrementalIndexSchema incrementalIndexSchema)\n     {\n-      this.incrementalIndexSchema = incrementalIndexSchema;\n-      return this;\n+      return (Builder) super.setIndexSchema(incrementalIndexSchema);\n     }\n \n-    /**\n-     * A helper method to set a simple index schema with only metrics and default values for the other parameters. Note\n-     * that this method is normally used for testing and benchmarking; it is unlikely that you would use it in\n-     * production settings.\n-     *\n-     * @param metrics variable array of {@link AggregatorFactory} metrics\n-     *\n-     * @return this\n-     */\n-    @VisibleForTesting\n+    @Override\n     public Builder setSimpleTestingIndexSchema(final AggregatorFactory... metrics)\n     {\n-      return setSimpleTestingIndexSchema(null, metrics);\n+      return (Builder) super.setSimpleTestingIndexSchema(metrics);\n     }\n \n-\n-    /**\n-     * A helper method to set a simple index schema with controllable metrics and rollup, and default values for the\n-     * other parameters. Note that this method is normally used for testing and benchmarking; it is unlikely that you\n-     * would use it in production settings.\n-     *\n-     * @param metrics variable array of {@link AggregatorFactory} metrics\n-     *\n-     * @return this\n-     */\n-    @VisibleForTesting\n+    @Override\n     public Builder setSimpleTestingIndexSchema(@Nullable Boolean rollup, final AggregatorFactory... metrics)\n     {\n-      IncrementalIndexSchema.Builder builder = new IncrementalIndexSchema.Builder().withMetrics(metrics);\n-      this.incrementalIndexSchema = rollup != null ? builder.withRollup(rollup).build() : builder.build();\n-      return this;\n+      return (Builder) super.setSimpleTestingIndexSchema(rollup, metrics);\n     }\n \n+    @Override\n     public Builder setDeserializeComplexMetrics(final boolean deserializeComplexMetrics)\n     {\n-      this.deserializeComplexMetrics = deserializeComplexMetrics;\n-      return this;\n+      return (Builder) super.setDeserializeComplexMetrics(deserializeComplexMetrics);\n     }\n \n+    @Override\n     public Builder setConcurrentEventAdd(final boolean concurrentEventAdd)\n     {\n-      this.concurrentEventAdd = concurrentEventAdd;\n-      return this;\n+      return (Builder) super.setConcurrentEventAdd(concurrentEventAdd);\n     }\n \n+    @Override\n     public Builder setSortFacts(final boolean sortFacts)\n     {\n-      this.sortFacts = sortFacts;\n-      return this;\n+      return (Builder) super.setSortFacts(sortFacts);\n     }\n \n+    @Override\n     public Builder setMaxRowCount(final int maxRowCount)\n     {\n-      this.maxRowCount = maxRowCount;\n-      return this;\n+      return (Builder) super.setMaxRowCount(maxRowCount);\n     }\n \n-    //maxBytesInMemory only applies to OnHeapIncrementalIndex\n+    @Override\n     public Builder setMaxBytesInMemory(final long maxBytesInMemory)\n     {\n-      this.maxBytesInMemory = maxBytesInMemory;\n-      return this;\n+      return (Builder) super.setMaxBytesInMemory(maxBytesInMemory);\n     }\n \n     public OnheapIncrementalIndex buildOnheap()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxMDI5NQ==", "bodyText": "I leave it on to avoid changing 100+ lines of code.\nThis can be removed later in a refactor PR.\nDo you think I should remove it in this PR?", "url": "https://github.com/apache/druid/pull/10335#discussion_r501210295", "createdAt": "2020-10-07T18:06:57Z", "author": {"login": "liran-funaro"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/IncrementalIndex.java", "diffHunk": "@@ -319,126 +316,62 @@ protected IncrementalIndex(\n     }\n   }\n \n-  public static class Builder\n+  /**\n+   * This class exists only as backward competability to reduce the number of modified lines.\n+   */\n+  public static class Builder extends OnheapIncrementalIndex.Builder\n   {\n-    @Nullable\n-    private IncrementalIndexSchema incrementalIndexSchema;\n-    private boolean deserializeComplexMetrics;\n-    private boolean concurrentEventAdd;\n-    private boolean sortFacts;\n-    private int maxRowCount;\n-    private long maxBytesInMemory;\n-\n-    public Builder()\n-    {\n-      incrementalIndexSchema = null;\n-      deserializeComplexMetrics = true;\n-      concurrentEventAdd = false;\n-      sortFacts = true;\n-      maxRowCount = 0;\n-      maxBytesInMemory = 0;\n-    }\n-\n+    @Override\n     public Builder setIndexSchema(final IncrementalIndexSchema incrementalIndexSchema)\n     {\n-      this.incrementalIndexSchema = incrementalIndexSchema;\n-      return this;\n+      return (Builder) super.setIndexSchema(incrementalIndexSchema);\n     }\n \n-    /**\n-     * A helper method to set a simple index schema with only metrics and default values for the other parameters. Note\n-     * that this method is normally used for testing and benchmarking; it is unlikely that you would use it in\n-     * production settings.\n-     *\n-     * @param metrics variable array of {@link AggregatorFactory} metrics\n-     *\n-     * @return this\n-     */\n-    @VisibleForTesting\n+    @Override\n     public Builder setSimpleTestingIndexSchema(final AggregatorFactory... metrics)\n     {\n-      return setSimpleTestingIndexSchema(null, metrics);\n+      return (Builder) super.setSimpleTestingIndexSchema(metrics);\n     }\n \n-\n-    /**\n-     * A helper method to set a simple index schema with controllable metrics and rollup, and default values for the\n-     * other parameters. Note that this method is normally used for testing and benchmarking; it is unlikely that you\n-     * would use it in production settings.\n-     *\n-     * @param metrics variable array of {@link AggregatorFactory} metrics\n-     *\n-     * @return this\n-     */\n-    @VisibleForTesting\n+    @Override\n     public Builder setSimpleTestingIndexSchema(@Nullable Boolean rollup, final AggregatorFactory... metrics)\n     {\n-      IncrementalIndexSchema.Builder builder = new IncrementalIndexSchema.Builder().withMetrics(metrics);\n-      this.incrementalIndexSchema = rollup != null ? builder.withRollup(rollup).build() : builder.build();\n-      return this;\n+      return (Builder) super.setSimpleTestingIndexSchema(rollup, metrics);\n     }\n \n+    @Override\n     public Builder setDeserializeComplexMetrics(final boolean deserializeComplexMetrics)\n     {\n-      this.deserializeComplexMetrics = deserializeComplexMetrics;\n-      return this;\n+      return (Builder) super.setDeserializeComplexMetrics(deserializeComplexMetrics);\n     }\n \n+    @Override\n     public Builder setConcurrentEventAdd(final boolean concurrentEventAdd)\n     {\n-      this.concurrentEventAdd = concurrentEventAdd;\n-      return this;\n+      return (Builder) super.setConcurrentEventAdd(concurrentEventAdd);\n     }\n \n+    @Override\n     public Builder setSortFacts(final boolean sortFacts)\n     {\n-      this.sortFacts = sortFacts;\n-      return this;\n+      return (Builder) super.setSortFacts(sortFacts);\n     }\n \n+    @Override\n     public Builder setMaxRowCount(final int maxRowCount)\n     {\n-      this.maxRowCount = maxRowCount;\n-      return this;\n+      return (Builder) super.setMaxRowCount(maxRowCount);\n     }\n \n-    //maxBytesInMemory only applies to OnHeapIncrementalIndex\n+    @Override\n     public Builder setMaxBytesInMemory(final long maxBytesInMemory)\n     {\n-      this.maxBytesInMemory = maxBytesInMemory;\n-      return this;\n+      return (Builder) super.setMaxBytesInMemory(maxBytesInMemory);\n     }\n \n     public OnheapIncrementalIndex buildOnheap()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA1NTgxMQ=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1NTMzOQ==", "bodyText": "Sounds reasonable. Please create a github issue for this so that we are tracking the incremental refactor effort.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501755339", "createdAt": "2020-10-08T14:14:38Z", "author": {"login": "a2l007"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/IncrementalIndex.java", "diffHunk": "@@ -319,126 +316,62 @@ protected IncrementalIndex(\n     }\n   }\n \n-  public static class Builder\n+  /**\n+   * This class exists only as backward competability to reduce the number of modified lines.\n+   */\n+  public static class Builder extends OnheapIncrementalIndex.Builder\n   {\n-    @Nullable\n-    private IncrementalIndexSchema incrementalIndexSchema;\n-    private boolean deserializeComplexMetrics;\n-    private boolean concurrentEventAdd;\n-    private boolean sortFacts;\n-    private int maxRowCount;\n-    private long maxBytesInMemory;\n-\n-    public Builder()\n-    {\n-      incrementalIndexSchema = null;\n-      deserializeComplexMetrics = true;\n-      concurrentEventAdd = false;\n-      sortFacts = true;\n-      maxRowCount = 0;\n-      maxBytesInMemory = 0;\n-    }\n-\n+    @Override\n     public Builder setIndexSchema(final IncrementalIndexSchema incrementalIndexSchema)\n     {\n-      this.incrementalIndexSchema = incrementalIndexSchema;\n-      return this;\n+      return (Builder) super.setIndexSchema(incrementalIndexSchema);\n     }\n \n-    /**\n-     * A helper method to set a simple index schema with only metrics and default values for the other parameters. Note\n-     * that this method is normally used for testing and benchmarking; it is unlikely that you would use it in\n-     * production settings.\n-     *\n-     * @param metrics variable array of {@link AggregatorFactory} metrics\n-     *\n-     * @return this\n-     */\n-    @VisibleForTesting\n+    @Override\n     public Builder setSimpleTestingIndexSchema(final AggregatorFactory... metrics)\n     {\n-      return setSimpleTestingIndexSchema(null, metrics);\n+      return (Builder) super.setSimpleTestingIndexSchema(metrics);\n     }\n \n-\n-    /**\n-     * A helper method to set a simple index schema with controllable metrics and rollup, and default values for the\n-     * other parameters. Note that this method is normally used for testing and benchmarking; it is unlikely that you\n-     * would use it in production settings.\n-     *\n-     * @param metrics variable array of {@link AggregatorFactory} metrics\n-     *\n-     * @return this\n-     */\n-    @VisibleForTesting\n+    @Override\n     public Builder setSimpleTestingIndexSchema(@Nullable Boolean rollup, final AggregatorFactory... metrics)\n     {\n-      IncrementalIndexSchema.Builder builder = new IncrementalIndexSchema.Builder().withMetrics(metrics);\n-      this.incrementalIndexSchema = rollup != null ? builder.withRollup(rollup).build() : builder.build();\n-      return this;\n+      return (Builder) super.setSimpleTestingIndexSchema(rollup, metrics);\n     }\n \n+    @Override\n     public Builder setDeserializeComplexMetrics(final boolean deserializeComplexMetrics)\n     {\n-      this.deserializeComplexMetrics = deserializeComplexMetrics;\n-      return this;\n+      return (Builder) super.setDeserializeComplexMetrics(deserializeComplexMetrics);\n     }\n \n+    @Override\n     public Builder setConcurrentEventAdd(final boolean concurrentEventAdd)\n     {\n-      this.concurrentEventAdd = concurrentEventAdd;\n-      return this;\n+      return (Builder) super.setConcurrentEventAdd(concurrentEventAdd);\n     }\n \n+    @Override\n     public Builder setSortFacts(final boolean sortFacts)\n     {\n-      this.sortFacts = sortFacts;\n-      return this;\n+      return (Builder) super.setSortFacts(sortFacts);\n     }\n \n+    @Override\n     public Builder setMaxRowCount(final int maxRowCount)\n     {\n-      this.maxRowCount = maxRowCount;\n-      return this;\n+      return (Builder) super.setMaxRowCount(maxRowCount);\n     }\n \n-    //maxBytesInMemory only applies to OnHeapIncrementalIndex\n+    @Override\n     public Builder setMaxBytesInMemory(final long maxBytesInMemory)\n     {\n-      this.maxBytesInMemory = maxBytesInMemory;\n-      return this;\n+      return (Builder) super.setMaxBytesInMemory(maxBytesInMemory);\n     }\n \n     public OnheapIncrementalIndex buildOnheap()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA1NTgxMQ=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg0ODM0Mg==", "bodyText": "Done. See #10494", "url": "https://github.com/apache/druid/pull/10335#discussion_r501848342", "createdAt": "2020-10-08T16:20:04Z", "author": {"login": "liran-funaro"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/IncrementalIndex.java", "diffHunk": "@@ -319,126 +316,62 @@ protected IncrementalIndex(\n     }\n   }\n \n-  public static class Builder\n+  /**\n+   * This class exists only as backward competability to reduce the number of modified lines.\n+   */\n+  public static class Builder extends OnheapIncrementalIndex.Builder\n   {\n-    @Nullable\n-    private IncrementalIndexSchema incrementalIndexSchema;\n-    private boolean deserializeComplexMetrics;\n-    private boolean concurrentEventAdd;\n-    private boolean sortFacts;\n-    private int maxRowCount;\n-    private long maxBytesInMemory;\n-\n-    public Builder()\n-    {\n-      incrementalIndexSchema = null;\n-      deserializeComplexMetrics = true;\n-      concurrentEventAdd = false;\n-      sortFacts = true;\n-      maxRowCount = 0;\n-      maxBytesInMemory = 0;\n-    }\n-\n+    @Override\n     public Builder setIndexSchema(final IncrementalIndexSchema incrementalIndexSchema)\n     {\n-      this.incrementalIndexSchema = incrementalIndexSchema;\n-      return this;\n+      return (Builder) super.setIndexSchema(incrementalIndexSchema);\n     }\n \n-    /**\n-     * A helper method to set a simple index schema with only metrics and default values for the other parameters. Note\n-     * that this method is normally used for testing and benchmarking; it is unlikely that you would use it in\n-     * production settings.\n-     *\n-     * @param metrics variable array of {@link AggregatorFactory} metrics\n-     *\n-     * @return this\n-     */\n-    @VisibleForTesting\n+    @Override\n     public Builder setSimpleTestingIndexSchema(final AggregatorFactory... metrics)\n     {\n-      return setSimpleTestingIndexSchema(null, metrics);\n+      return (Builder) super.setSimpleTestingIndexSchema(metrics);\n     }\n \n-\n-    /**\n-     * A helper method to set a simple index schema with controllable metrics and rollup, and default values for the\n-     * other parameters. Note that this method is normally used for testing and benchmarking; it is unlikely that you\n-     * would use it in production settings.\n-     *\n-     * @param metrics variable array of {@link AggregatorFactory} metrics\n-     *\n-     * @return this\n-     */\n-    @VisibleForTesting\n+    @Override\n     public Builder setSimpleTestingIndexSchema(@Nullable Boolean rollup, final AggregatorFactory... metrics)\n     {\n-      IncrementalIndexSchema.Builder builder = new IncrementalIndexSchema.Builder().withMetrics(metrics);\n-      this.incrementalIndexSchema = rollup != null ? builder.withRollup(rollup).build() : builder.build();\n-      return this;\n+      return (Builder) super.setSimpleTestingIndexSchema(rollup, metrics);\n     }\n \n+    @Override\n     public Builder setDeserializeComplexMetrics(final boolean deserializeComplexMetrics)\n     {\n-      this.deserializeComplexMetrics = deserializeComplexMetrics;\n-      return this;\n+      return (Builder) super.setDeserializeComplexMetrics(deserializeComplexMetrics);\n     }\n \n+    @Override\n     public Builder setConcurrentEventAdd(final boolean concurrentEventAdd)\n     {\n-      this.concurrentEventAdd = concurrentEventAdd;\n-      return this;\n+      return (Builder) super.setConcurrentEventAdd(concurrentEventAdd);\n     }\n \n+    @Override\n     public Builder setSortFacts(final boolean sortFacts)\n     {\n-      this.sortFacts = sortFacts;\n-      return this;\n+      return (Builder) super.setSortFacts(sortFacts);\n     }\n \n+    @Override\n     public Builder setMaxRowCount(final int maxRowCount)\n     {\n-      this.maxRowCount = maxRowCount;\n-      return this;\n+      return (Builder) super.setMaxRowCount(maxRowCount);\n     }\n \n-    //maxBytesInMemory only applies to OnHeapIncrementalIndex\n+    @Override\n     public Builder setMaxBytesInMemory(final long maxBytesInMemory)\n     {\n-      this.maxBytesInMemory = maxBytesInMemory;\n-      return this;\n+      return (Builder) super.setMaxBytesInMemory(maxBytesInMemory);\n     }\n \n     public OnheapIncrementalIndex buildOnheap()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA1NTgxMQ=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzY2NTg2OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/groupby/GroupByQueryHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNToxOTo1OVrOHd4qzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxODoxMDoxOFrOHd_kgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5OTIxNQ==", "bodyText": "Can this be final?", "url": "https://github.com/apache/druid/pull/10335#discussion_r501099215", "createdAt": "2020-10-07T15:19:59Z", "author": {"login": "a2l007"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/GroupByQueryHelper.java", "diffHunk": "@@ -117,24 +120,24 @@ public String apply(DimensionSpec input)\n         .withMinTimestamp(granTimeStart.getMillis())\n         .build();\n \n+\n+    AppendableIndexBuilder indexBuilder;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxMjI4OA==", "bodyText": "Yes.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501212288", "createdAt": "2020-10-07T18:10:18Z", "author": {"login": "liran-funaro"}, "path": "processing/src/main/java/org/apache/druid/query/groupby/GroupByQueryHelper.java", "diffHunk": "@@ -117,24 +120,24 @@ public String apply(DimensionSpec input)\n         .withMinTimestamp(granTimeStart.getMillis())\n         .build();\n \n+\n+    AppendableIndexBuilder indexBuilder;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA5OTIxNQ=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzg5MzcwOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/jackson/AppendableIndexModule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjowODoxOFrOHd64Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxMDowNTozOVrOHeXRAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzNTQxMA==", "bodyText": "Could you please add a test for this module?", "url": "https://github.com/apache/druid/pull/10335#discussion_r501135410", "createdAt": "2020-10-07T16:08:18Z", "author": {"login": "a2l007"}, "path": "processing/src/main/java/org/apache/druid/jackson/AppendableIndexModule.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.jackson;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import org.apache.druid.segment.incremental.AppendableIndexSpec;\n+import org.apache.druid.segment.incremental.OffheapIncrementalIndex;\n+import org.apache.druid.segment.incremental.OnheapIncrementalIndex;\n+\n+public class AppendableIndexModule extends SimpleModule", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTYwMDUxMw==", "bodyText": "This is tested as part of the separate TuningConfig tests:\n\nHadoopTuningConfigTest\nParallelIndexTuningConfigTest\nKafkaIndexTuningConfigTest\nKafkaSupervisorTuningConfigTest\nKinesisIndexTaskTuningConfigTest\nKinesisSupervisorTuningConfigTest\nRealtimeTuningConfigTest", "url": "https://github.com/apache/druid/pull/10335#discussion_r501600513", "createdAt": "2020-10-08T10:05:39Z", "author": {"login": "liran-funaro"}, "path": "processing/src/main/java/org/apache/druid/jackson/AppendableIndexModule.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.jackson;\n+\n+import com.fasterxml.jackson.annotation.JsonSubTypes;\n+import com.fasterxml.jackson.annotation.JsonTypeInfo;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import org.apache.druid.segment.incremental.AppendableIndexSpec;\n+import org.apache.druid.segment.incremental.OffheapIncrementalIndex;\n+import org.apache.druid.segment.incremental.OnheapIncrementalIndex;\n+\n+public class AppendableIndexModule extends SimpleModule", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTEzNTQxMA=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzkyNDIzOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/incremental/AppendableIndexSpec.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjoxNTo1M1rOHd7L0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwODowMjoyNlrOHeSiNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0MDQzMw==", "bodyText": "Please add javadocs.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501140433", "createdAt": "2020-10-07T16:15:53Z", "author": {"login": "a2l007"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/AppendableIndexSpec.java", "diffHunk": "@@ -17,25 +17,16 @@\n  * under the License.\n  */\n \n-package org.apache.druid.segment.indexing;\n+package org.apache.druid.segment.incremental;\n \n-public class TuningConfigs\n+import org.apache.druid.guice.annotations.UnstableApi;\n+\n+@UnstableApi\n+public interface AppendableIndexSpec", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUyMjk5OA==", "bodyText": "Added", "url": "https://github.com/apache/druid/pull/10335#discussion_r501522998", "createdAt": "2020-10-08T08:02:26Z", "author": {"login": "liran-funaro"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/AppendableIndexSpec.java", "diffHunk": "@@ -17,25 +17,16 @@\n  * under the License.\n  */\n \n-package org.apache.druid.segment.indexing;\n+package org.apache.druid.segment.incremental;\n \n-public class TuningConfigs\n+import org.apache.druid.guice.annotations.UnstableApi;\n+\n+@UnstableApi\n+public interface AppendableIndexSpec", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0MDQzMw=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzk0NzUyOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/druid/segment/indexing/RealtimeTuningConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjoyMToyOFrOHd7ang==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNzo1MzozOVrOHeSNhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0NDIyMg==", "bodyText": "This comment is no longer valid. Please update accordingly.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501144222", "createdAt": "2020-10-07T16:21:28Z", "author": {"login": "a2l007"}, "path": "server/src/main/java/org/apache/druid/segment/indexing/RealtimeTuningConfig.java", "diffHunk": "@@ -132,6 +136,7 @@ public RealtimeTuningConfig(\n       @JsonProperty(\"dedupColumn\") @Nullable String dedupColumn\n   )\n   {\n+    this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;\n     this.maxRowsInMemory = maxRowsInMemory == null ? DEFAULT_MAX_ROWS_IN_MEMORY : maxRowsInMemory;\n     // initializing this to 0, it will be lazily initialized to a value\n     // @see server.src.main.java.org.apache.druid.segment.indexing.TuningConfigs#getMaxBytesInMemoryOrDefault(long)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNzcwMQ==", "bodyText": "Fixed", "url": "https://github.com/apache/druid/pull/10335#discussion_r501517701", "createdAt": "2020-10-08T07:53:39Z", "author": {"login": "liran-funaro"}, "path": "server/src/main/java/org/apache/druid/segment/indexing/RealtimeTuningConfig.java", "diffHunk": "@@ -132,6 +136,7 @@ public RealtimeTuningConfig(\n       @JsonProperty(\"dedupColumn\") @Nullable String dedupColumn\n   )\n   {\n+    this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;\n     this.maxRowsInMemory = maxRowsInMemory == null ? DEFAULT_MAX_ROWS_IN_MEMORY : maxRowsInMemory;\n     // initializing this to 0, it will be lazily initialized to a value\n     // @see server.src.main.java.org.apache.druid.segment.indexing.TuningConfigs#getMaxBytesInMemoryOrDefault(long)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0NDIyMg=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzk1MzE3OnYy", "diffSide": "RIGHT", "path": "indexing-hadoop/src/main/java/org/apache/druid/indexer/HadoopTuningConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjoyMjo0NFrOHd7eFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjoyMjo0NFrOHd7eFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0NTEwOA==", "bodyText": "Comment needs to be updated", "url": "https://github.com/apache/druid/pull/10335#discussion_r501145108", "createdAt": "2020-10-07T16:22:44Z", "author": {"login": "a2l007"}, "path": "indexing-hadoop/src/main/java/org/apache/druid/indexer/HadoopTuningConfig.java", "diffHunk": "@@ -140,6 +144,7 @@ public HadoopTuningConfig(\n     this.rowFlushBoundary = maxRowsInMemory == null ? maxRowsInMemoryCOMPAT == null\n                                                       ? DEFAULT_ROW_FLUSH_BOUNDARY\n                                                       : maxRowsInMemoryCOMPAT : maxRowsInMemory;\n+    this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;\n     // initializing this to 0, it will be lazily initialized to a value\n     // @see server.src.main.java.org.apache.druid.segment.indexing.TuningConfigs#getMaxBytesInMemoryOrDefault(long)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzk1ODExOnYy", "diffSide": "RIGHT", "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/index/RealtimeAppenderatorTuningConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjoyMzo1NlrOHd7hPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjoyMzo1NlrOHd7hPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0NTkxOA==", "bodyText": "Comment needs to be modified.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501145918", "createdAt": "2020-10-07T16:23:56Z", "author": {"login": "a2l007"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/index/RealtimeAppenderatorTuningConfig.java", "diffHunk": "@@ -93,6 +96,7 @@ public RealtimeAppenderatorTuningConfig(\n       @JsonProperty(\"maxSavedParseExceptions\") @Nullable Integer maxSavedParseExceptions\n   )\n   {\n+    this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;\n     this.maxRowsInMemory = maxRowsInMemory == null ? DEFAULT_MAX_ROWS_IN_MEMORY : maxRowsInMemory;\n     // initializing this to 0, it will be lazily intialized to a value\n     // @see server.src.main.java.org.apache.druid.segment.indexing.TuningConfigs#getMaxBytesInMemoryOrDefault(long)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzk1OTY3OnYy", "diffSide": "RIGHT", "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/IndexTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjoyNDoxNlrOHd7iQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNzo1MzozM1rOHeSNOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0NjE3OA==", "bodyText": "Comment needs to be modified.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501146178", "createdAt": "2020-10-07T16:24:16Z", "author": {"login": "a2l007"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/IndexTask.java", "diffHunk": "@@ -1262,6 +1267,7 @@ private IndexTuningConfig(\n         @Nullable Integer maxSavedParseExceptions\n     )\n     {\n+      this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;\n       this.maxRowsInMemory = maxRowsInMemory == null ? TuningConfig.DEFAULT_MAX_ROWS_IN_MEMORY : maxRowsInMemory;\n       // initializing this to 0, it will be lazily initialized to a value\n       // @see server.src.main.java.org.apache.druid.segment.indexing.TuningConfigs#getMaxBytesInMemoryOrDefault(long)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNzYyNw==", "bodyText": "Fixed", "url": "https://github.com/apache/druid/pull/10335#discussion_r501517627", "createdAt": "2020-10-08T07:53:33Z", "author": {"login": "liran-funaro"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/IndexTask.java", "diffHunk": "@@ -1262,6 +1267,7 @@ private IndexTuningConfig(\n         @Nullable Integer maxSavedParseExceptions\n     )\n     {\n+      this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;\n       this.maxRowsInMemory = maxRowsInMemory == null ? TuningConfig.DEFAULT_MAX_ROWS_IN_MEMORY : maxRowsInMemory;\n       // initializing this to 0, it will be lazily initialized to a value\n       // @see server.src.main.java.org.apache.druid.segment.indexing.TuningConfigs#getMaxBytesInMemoryOrDefault(long)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0NjE3OA=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNzk2MjUxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/druid/segment/indexing/TuningConfig.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjoyNDo1MlrOHd7j8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNzo1MzoyNVrOHeSM3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0NjYxMA==", "bodyText": "nit: typo for incremental", "url": "https://github.com/apache/druid/pull/10335#discussion_r501146610", "createdAt": "2020-10-07T16:24:52Z", "author": {"login": "a2l007"}, "path": "server/src/main/java/org/apache/druid/segment/indexing/TuningConfig.java", "diffHunk": "@@ -32,11 +35,43 @@\n public interface TuningConfig\n {\n   boolean DEFAULT_LOG_PARSE_EXCEPTIONS = false;\n+  AppendableIndexSpec DEFAULT_APPENDABLE_INDEX = new OnheapIncrementalIndex.Spec();\n   int DEFAULT_MAX_PARSE_EXCEPTIONS = Integer.MAX_VALUE;\n   int DEFAULT_MAX_SAVED_PARSE_EXCEPTIONS = 0;\n   int DEFAULT_MAX_ROWS_IN_MEMORY = 1_000_000;\n-  // We initially estimated this to be 1/3(max jvm memory), but bytesCurrentlyInMemory only\n-  // tracks active index and not the index being flushed to disk, to account for that\n-  // we halved default to 1/6(max jvm memory)\n-  long DEFAULT_MAX_BYTES_IN_MEMORY = JvmUtils.getRuntimeInfo().getMaxHeapSizeBytes() / 6;\n+\n+  /**\n+   * The inceremental index implementation to use", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxMzI2Mg==", "bodyText": "Nice catch", "url": "https://github.com/apache/druid/pull/10335#discussion_r501213262", "createdAt": "2020-10-07T18:12:04Z", "author": {"login": "liran-funaro"}, "path": "server/src/main/java/org/apache/druid/segment/indexing/TuningConfig.java", "diffHunk": "@@ -32,11 +35,43 @@\n public interface TuningConfig\n {\n   boolean DEFAULT_LOG_PARSE_EXCEPTIONS = false;\n+  AppendableIndexSpec DEFAULT_APPENDABLE_INDEX = new OnheapIncrementalIndex.Spec();\n   int DEFAULT_MAX_PARSE_EXCEPTIONS = Integer.MAX_VALUE;\n   int DEFAULT_MAX_SAVED_PARSE_EXCEPTIONS = 0;\n   int DEFAULT_MAX_ROWS_IN_MEMORY = 1_000_000;\n-  // We initially estimated this to be 1/3(max jvm memory), but bytesCurrentlyInMemory only\n-  // tracks active index and not the index being flushed to disk, to account for that\n-  // we halved default to 1/6(max jvm memory)\n-  long DEFAULT_MAX_BYTES_IN_MEMORY = JvmUtils.getRuntimeInfo().getMaxHeapSizeBytes() / 6;\n+\n+  /**\n+   * The inceremental index implementation to use", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0NjYxMA=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNzUzNQ==", "bodyText": "Fixed", "url": "https://github.com/apache/druid/pull/10335#discussion_r501517535", "createdAt": "2020-10-08T07:53:25Z", "author": {"login": "liran-funaro"}, "path": "server/src/main/java/org/apache/druid/segment/indexing/TuningConfig.java", "diffHunk": "@@ -32,11 +35,43 @@\n public interface TuningConfig\n {\n   boolean DEFAULT_LOG_PARSE_EXCEPTIONS = false;\n+  AppendableIndexSpec DEFAULT_APPENDABLE_INDEX = new OnheapIncrementalIndex.Spec();\n   int DEFAULT_MAX_PARSE_EXCEPTIONS = Integer.MAX_VALUE;\n   int DEFAULT_MAX_SAVED_PARSE_EXCEPTIONS = 0;\n   int DEFAULT_MAX_ROWS_IN_MEMORY = 1_000_000;\n-  // We initially estimated this to be 1/3(max jvm memory), but bytesCurrentlyInMemory only\n-  // tracks active index and not the index being flushed to disk, to account for that\n-  // we halved default to 1/6(max jvm memory)\n-  long DEFAULT_MAX_BYTES_IN_MEMORY = JvmUtils.getRuntimeInfo().getMaxHeapSizeBytes() / 6;\n+\n+  /**\n+   * The inceremental index implementation to use", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE0NjYxMA=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzODA2ODMwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/druid/segment/indexing/TuningConfig.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNjo1MDoyN1rOHd8lcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxODoyMzo1OFrOHiUq2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE2MzM3OQ==", "bodyText": "Why we do we need to move these out of AppenderatorConfig?", "url": "https://github.com/apache/druid/pull/10335#discussion_r501163379", "createdAt": "2020-10-07T16:50:27Z", "author": {"login": "a2l007"}, "path": "server/src/main/java/org/apache/druid/segment/indexing/TuningConfig.java", "diffHunk": "@@ -32,11 +35,43 @@\n public interface TuningConfig\n {\n   boolean DEFAULT_LOG_PARSE_EXCEPTIONS = false;\n+  AppendableIndexSpec DEFAULT_APPENDABLE_INDEX = new OnheapIncrementalIndex.Spec();\n   int DEFAULT_MAX_PARSE_EXCEPTIONS = Integer.MAX_VALUE;\n   int DEFAULT_MAX_SAVED_PARSE_EXCEPTIONS = 0;\n   int DEFAULT_MAX_ROWS_IN_MEMORY = 1_000_000;\n-  // We initially estimated this to be 1/3(max jvm memory), but bytesCurrentlyInMemory only\n-  // tracks active index and not the index being flushed to disk, to account for that\n-  // we halved default to 1/6(max jvm memory)\n-  long DEFAULT_MAX_BYTES_IN_MEMORY = JvmUtils.getRuntimeInfo().getMaxHeapSizeBytes() / 6;\n+\n+  /**\n+   * The inceremental index implementation to use\n+   */\n+  AppendableIndexSpec getAppendableIndexSpec();\n+\n+  /**\n+   * Maximum number of bytes (estimated) to store in memory before persisting to local storage\n+   */\n+  long getMaxBytesInMemory();\n+\n+  /**\n+   * Maximum number of bytes (estimated) to store in memory before persisting to local storage.\n+   * If getMaxBytesInMemory() returns 0, the appendable index default will be used.\n+   */\n+  default long getMaxBytesInMemoryOrDefault()\n+  {\n+    // In the main tuningConfig class constructor, we set the maxBytes to 0 if null to avoid setting\n+    // maxBytes to max jvm memory of the process that starts first. Instead we set the default based on\n+    // the actual task node's jvm memory.\n+    final long maxBytesInMemory = getMaxBytesInMemory();\n+    if (maxBytesInMemory > 0) {\n+      return maxBytesInMemory;\n+    } else if (maxBytesInMemory == 0) {\n+      return getAppendableIndexSpec().getDefaultMaxBytesInMemory();\n+    } else {\n+      return Long.MAX_VALUE;\n+    }\n+  }\n+\n+  PartitionsSpec getPartitionsSpec();\n+\n+  IndexSpec getIndexSpec();\n+\n+  IndexSpec getIndexSpecForIntermediatePersists();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxNjA5MA==", "bodyText": "We don't have to. I was wondering why they are in AppenderatorConfig in the first place.\nThe only reasoning for why AppenderatorConfig exists is because HadoopTuningConfig doesn't share all of the TuningConfig API with the rest of the \"appenderators\".\nSo I think it is best that as much of the common API as possible will be in TuningConfig.\nAnd these methods are indeed in common.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501216090", "createdAt": "2020-10-07T18:16:54Z", "author": {"login": "liran-funaro"}, "path": "server/src/main/java/org/apache/druid/segment/indexing/TuningConfig.java", "diffHunk": "@@ -32,11 +35,43 @@\n public interface TuningConfig\n {\n   boolean DEFAULT_LOG_PARSE_EXCEPTIONS = false;\n+  AppendableIndexSpec DEFAULT_APPENDABLE_INDEX = new OnheapIncrementalIndex.Spec();\n   int DEFAULT_MAX_PARSE_EXCEPTIONS = Integer.MAX_VALUE;\n   int DEFAULT_MAX_SAVED_PARSE_EXCEPTIONS = 0;\n   int DEFAULT_MAX_ROWS_IN_MEMORY = 1_000_000;\n-  // We initially estimated this to be 1/3(max jvm memory), but bytesCurrentlyInMemory only\n-  // tracks active index and not the index being flushed to disk, to account for that\n-  // we halved default to 1/6(max jvm memory)\n-  long DEFAULT_MAX_BYTES_IN_MEMORY = JvmUtils.getRuntimeInfo().getMaxHeapSizeBytes() / 6;\n+\n+  /**\n+   * The inceremental index implementation to use\n+   */\n+  AppendableIndexSpec getAppendableIndexSpec();\n+\n+  /**\n+   * Maximum number of bytes (estimated) to store in memory before persisting to local storage\n+   */\n+  long getMaxBytesInMemory();\n+\n+  /**\n+   * Maximum number of bytes (estimated) to store in memory before persisting to local storage.\n+   * If getMaxBytesInMemory() returns 0, the appendable index default will be used.\n+   */\n+  default long getMaxBytesInMemoryOrDefault()\n+  {\n+    // In the main tuningConfig class constructor, we set the maxBytes to 0 if null to avoid setting\n+    // maxBytes to max jvm memory of the process that starts first. Instead we set the default based on\n+    // the actual task node's jvm memory.\n+    final long maxBytesInMemory = getMaxBytesInMemory();\n+    if (maxBytesInMemory > 0) {\n+      return maxBytesInMemory;\n+    } else if (maxBytesInMemory == 0) {\n+      return getAppendableIndexSpec().getDefaultMaxBytesInMemory();\n+    } else {\n+      return Long.MAX_VALUE;\n+    }\n+  }\n+\n+  PartitionsSpec getPartitionsSpec();\n+\n+  IndexSpec getIndexSpec();\n+\n+  IndexSpec getIndexSpecForIntermediatePersists();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE2MzM3OQ=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc4MjM2Ng==", "bodyText": "I was wondering why they are in AppenderatorConfig in the first place.\n\nI'm not sure. Maybe @jihoonson can help answer this.\n\nSo I think it is best that as much of the common API as possible will be in TuningConfig.\nAnd these methods are indeed in common.\n\nWe should look at incrementally refactoring HadoopTuningConfig.getRowFlushBoundary into getMaxRowsInMemory so that it could be moved into TuningConfig as well.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501782366", "createdAt": "2020-10-08T14:48:41Z", "author": {"login": "a2l007"}, "path": "server/src/main/java/org/apache/druid/segment/indexing/TuningConfig.java", "diffHunk": "@@ -32,11 +35,43 @@\n public interface TuningConfig\n {\n   boolean DEFAULT_LOG_PARSE_EXCEPTIONS = false;\n+  AppendableIndexSpec DEFAULT_APPENDABLE_INDEX = new OnheapIncrementalIndex.Spec();\n   int DEFAULT_MAX_PARSE_EXCEPTIONS = Integer.MAX_VALUE;\n   int DEFAULT_MAX_SAVED_PARSE_EXCEPTIONS = 0;\n   int DEFAULT_MAX_ROWS_IN_MEMORY = 1_000_000;\n-  // We initially estimated this to be 1/3(max jvm memory), but bytesCurrentlyInMemory only\n-  // tracks active index and not the index being flushed to disk, to account for that\n-  // we halved default to 1/6(max jvm memory)\n-  long DEFAULT_MAX_BYTES_IN_MEMORY = JvmUtils.getRuntimeInfo().getMaxHeapSizeBytes() / 6;\n+\n+  /**\n+   * The inceremental index implementation to use\n+   */\n+  AppendableIndexSpec getAppendableIndexSpec();\n+\n+  /**\n+   * Maximum number of bytes (estimated) to store in memory before persisting to local storage\n+   */\n+  long getMaxBytesInMemory();\n+\n+  /**\n+   * Maximum number of bytes (estimated) to store in memory before persisting to local storage.\n+   * If getMaxBytesInMemory() returns 0, the appendable index default will be used.\n+   */\n+  default long getMaxBytesInMemoryOrDefault()\n+  {\n+    // In the main tuningConfig class constructor, we set the maxBytes to 0 if null to avoid setting\n+    // maxBytes to max jvm memory of the process that starts first. Instead we set the default based on\n+    // the actual task node's jvm memory.\n+    final long maxBytesInMemory = getMaxBytesInMemory();\n+    if (maxBytesInMemory > 0) {\n+      return maxBytesInMemory;\n+    } else if (maxBytesInMemory == 0) {\n+      return getAppendableIndexSpec().getDefaultMaxBytesInMemory();\n+    } else {\n+      return Long.MAX_VALUE;\n+    }\n+  }\n+\n+  PartitionsSpec getPartitionsSpec();\n+\n+  IndexSpec getIndexSpec();\n+\n+  IndexSpec getIndexSpecForIntermediatePersists();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE2MzM3OQ=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyMjk5Mw==", "bodyText": "We should look at incrementally refactoring HadoopTuningConfig.getRowFlushBoundary into getMaxRowsInMemory so that it could be moved into TuningConfig as well.\n\nI opened (earlier) #10478 for that. It is short.\nIf you prefer, I can apply your comments from this PR to #10478 and merge it before this one.\nIt address both HadoopTuningConfig.getRowFlushBoundary and the TuningConfig interface refactoring.\nEDIT: I already applied your comments there.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501822993", "createdAt": "2020-10-08T15:43:13Z", "author": {"login": "liran-funaro"}, "path": "server/src/main/java/org/apache/druid/segment/indexing/TuningConfig.java", "diffHunk": "@@ -32,11 +35,43 @@\n public interface TuningConfig\n {\n   boolean DEFAULT_LOG_PARSE_EXCEPTIONS = false;\n+  AppendableIndexSpec DEFAULT_APPENDABLE_INDEX = new OnheapIncrementalIndex.Spec();\n   int DEFAULT_MAX_PARSE_EXCEPTIONS = Integer.MAX_VALUE;\n   int DEFAULT_MAX_SAVED_PARSE_EXCEPTIONS = 0;\n   int DEFAULT_MAX_ROWS_IN_MEMORY = 1_000_000;\n-  // We initially estimated this to be 1/3(max jvm memory), but bytesCurrentlyInMemory only\n-  // tracks active index and not the index being flushed to disk, to account for that\n-  // we halved default to 1/6(max jvm memory)\n-  long DEFAULT_MAX_BYTES_IN_MEMORY = JvmUtils.getRuntimeInfo().getMaxHeapSizeBytes() / 6;\n+\n+  /**\n+   * The inceremental index implementation to use\n+   */\n+  AppendableIndexSpec getAppendableIndexSpec();\n+\n+  /**\n+   * Maximum number of bytes (estimated) to store in memory before persisting to local storage\n+   */\n+  long getMaxBytesInMemory();\n+\n+  /**\n+   * Maximum number of bytes (estimated) to store in memory before persisting to local storage.\n+   * If getMaxBytesInMemory() returns 0, the appendable index default will be used.\n+   */\n+  default long getMaxBytesInMemoryOrDefault()\n+  {\n+    // In the main tuningConfig class constructor, we set the maxBytes to 0 if null to avoid setting\n+    // maxBytes to max jvm memory of the process that starts first. Instead we set the default based on\n+    // the actual task node's jvm memory.\n+    final long maxBytesInMemory = getMaxBytesInMemory();\n+    if (maxBytesInMemory > 0) {\n+      return maxBytesInMemory;\n+    } else if (maxBytesInMemory == 0) {\n+      return getAppendableIndexSpec().getDefaultMaxBytesInMemory();\n+    } else {\n+      return Long.MAX_VALUE;\n+    }\n+  }\n+\n+  PartitionsSpec getPartitionsSpec();\n+\n+  IndexSpec getIndexSpec();\n+\n+  IndexSpec getIndexSpecForIntermediatePersists();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE2MzM3OQ=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU0Njg2Mg==", "bodyText": "Hi @jihoonson. Can you chime in to resolve this issue?", "url": "https://github.com/apache/druid/pull/10335#discussion_r505546862", "createdAt": "2020-10-15T13:35:31Z", "author": {"login": "liran-funaro"}, "path": "server/src/main/java/org/apache/druid/segment/indexing/TuningConfig.java", "diffHunk": "@@ -32,11 +35,43 @@\n public interface TuningConfig\n {\n   boolean DEFAULT_LOG_PARSE_EXCEPTIONS = false;\n+  AppendableIndexSpec DEFAULT_APPENDABLE_INDEX = new OnheapIncrementalIndex.Spec();\n   int DEFAULT_MAX_PARSE_EXCEPTIONS = Integer.MAX_VALUE;\n   int DEFAULT_MAX_SAVED_PARSE_EXCEPTIONS = 0;\n   int DEFAULT_MAX_ROWS_IN_MEMORY = 1_000_000;\n-  // We initially estimated this to be 1/3(max jvm memory), but bytesCurrentlyInMemory only\n-  // tracks active index and not the index being flushed to disk, to account for that\n-  // we halved default to 1/6(max jvm memory)\n-  long DEFAULT_MAX_BYTES_IN_MEMORY = JvmUtils.getRuntimeInfo().getMaxHeapSizeBytes() / 6;\n+\n+  /**\n+   * The inceremental index implementation to use\n+   */\n+  AppendableIndexSpec getAppendableIndexSpec();\n+\n+  /**\n+   * Maximum number of bytes (estimated) to store in memory before persisting to local storage\n+   */\n+  long getMaxBytesInMemory();\n+\n+  /**\n+   * Maximum number of bytes (estimated) to store in memory before persisting to local storage.\n+   * If getMaxBytesInMemory() returns 0, the appendable index default will be used.\n+   */\n+  default long getMaxBytesInMemoryOrDefault()\n+  {\n+    // In the main tuningConfig class constructor, we set the maxBytes to 0 if null to avoid setting\n+    // maxBytes to max jvm memory of the process that starts first. Instead we set the default based on\n+    // the actual task node's jvm memory.\n+    final long maxBytesInMemory = getMaxBytesInMemory();\n+    if (maxBytesInMemory > 0) {\n+      return maxBytesInMemory;\n+    } else if (maxBytesInMemory == 0) {\n+      return getAppendableIndexSpec().getDefaultMaxBytesInMemory();\n+    } else {\n+      return Long.MAX_VALUE;\n+    }\n+  }\n+\n+  PartitionsSpec getPartitionsSpec();\n+\n+  IndexSpec getIndexSpec();\n+\n+  IndexSpec getIndexSpecForIntermediatePersists();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE2MzM3OQ=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc0MDc1NQ==", "bodyText": "Oops, sorry. I missed the previous ping.\n\nI was wondering why they are in AppenderatorConfig in the first place.\n\nindexSpecForIntermediatePersists was added in #7919. I'm not aware of the exact reason, but it seems not bad to have it only in AppenderatorConfig because that parameter is coupled with how Appenderator spills intermediate segments. Hadoop task is sort of special. I think it was implemented before we added Appenderator (or at least before AppenderatorDriver), and we could implement Appenderator in a more structured way based on the lessons we learned from Hadoop task. So, it works similar to other tasks using Appenderator, but is not exactly same.\nRegarding the interface change, even though we currently have only the tasks which have the similar spilling mechanism, but it might not be true in the future. So, I would say it would be better to not modify the interface unless you have to.", "url": "https://github.com/apache/druid/pull/10335#discussion_r505740755", "createdAt": "2020-10-15T18:09:16Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/segment/indexing/TuningConfig.java", "diffHunk": "@@ -32,11 +35,43 @@\n public interface TuningConfig\n {\n   boolean DEFAULT_LOG_PARSE_EXCEPTIONS = false;\n+  AppendableIndexSpec DEFAULT_APPENDABLE_INDEX = new OnheapIncrementalIndex.Spec();\n   int DEFAULT_MAX_PARSE_EXCEPTIONS = Integer.MAX_VALUE;\n   int DEFAULT_MAX_SAVED_PARSE_EXCEPTIONS = 0;\n   int DEFAULT_MAX_ROWS_IN_MEMORY = 1_000_000;\n-  // We initially estimated this to be 1/3(max jvm memory), but bytesCurrentlyInMemory only\n-  // tracks active index and not the index being flushed to disk, to account for that\n-  // we halved default to 1/6(max jvm memory)\n-  long DEFAULT_MAX_BYTES_IN_MEMORY = JvmUtils.getRuntimeInfo().getMaxHeapSizeBytes() / 6;\n+\n+  /**\n+   * The inceremental index implementation to use\n+   */\n+  AppendableIndexSpec getAppendableIndexSpec();\n+\n+  /**\n+   * Maximum number of bytes (estimated) to store in memory before persisting to local storage\n+   */\n+  long getMaxBytesInMemory();\n+\n+  /**\n+   * Maximum number of bytes (estimated) to store in memory before persisting to local storage.\n+   * If getMaxBytesInMemory() returns 0, the appendable index default will be used.\n+   */\n+  default long getMaxBytesInMemoryOrDefault()\n+  {\n+    // In the main tuningConfig class constructor, we set the maxBytes to 0 if null to avoid setting\n+    // maxBytes to max jvm memory of the process that starts first. Instead we set the default based on\n+    // the actual task node's jvm memory.\n+    final long maxBytesInMemory = getMaxBytesInMemory();\n+    if (maxBytesInMemory > 0) {\n+      return maxBytesInMemory;\n+    } else if (maxBytesInMemory == 0) {\n+      return getAppendableIndexSpec().getDefaultMaxBytesInMemory();\n+    } else {\n+      return Long.MAX_VALUE;\n+    }\n+  }\n+\n+  PartitionsSpec getPartitionsSpec();\n+\n+  IndexSpec getIndexSpec();\n+\n+  IndexSpec getIndexSpecForIntermediatePersists();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE2MzM3OQ=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc1MjI4MA==", "bodyText": "Thanks, @jihoonson. I will revert this API change.", "url": "https://github.com/apache/druid/pull/10335#discussion_r505752280", "createdAt": "2020-10-15T18:23:58Z", "author": {"login": "liran-funaro"}, "path": "server/src/main/java/org/apache/druid/segment/indexing/TuningConfig.java", "diffHunk": "@@ -32,11 +35,43 @@\n public interface TuningConfig\n {\n   boolean DEFAULT_LOG_PARSE_EXCEPTIONS = false;\n+  AppendableIndexSpec DEFAULT_APPENDABLE_INDEX = new OnheapIncrementalIndex.Spec();\n   int DEFAULT_MAX_PARSE_EXCEPTIONS = Integer.MAX_VALUE;\n   int DEFAULT_MAX_SAVED_PARSE_EXCEPTIONS = 0;\n   int DEFAULT_MAX_ROWS_IN_MEMORY = 1_000_000;\n-  // We initially estimated this to be 1/3(max jvm memory), but bytesCurrentlyInMemory only\n-  // tracks active index and not the index being flushed to disk, to account for that\n-  // we halved default to 1/6(max jvm memory)\n-  long DEFAULT_MAX_BYTES_IN_MEMORY = JvmUtils.getRuntimeInfo().getMaxHeapSizeBytes() / 6;\n+\n+  /**\n+   * The inceremental index implementation to use\n+   */\n+  AppendableIndexSpec getAppendableIndexSpec();\n+\n+  /**\n+   * Maximum number of bytes (estimated) to store in memory before persisting to local storage\n+   */\n+  long getMaxBytesInMemory();\n+\n+  /**\n+   * Maximum number of bytes (estimated) to store in memory before persisting to local storage.\n+   * If getMaxBytesInMemory() returns 0, the appendable index default will be used.\n+   */\n+  default long getMaxBytesInMemoryOrDefault()\n+  {\n+    // In the main tuningConfig class constructor, we set the maxBytes to 0 if null to avoid setting\n+    // maxBytes to max jvm memory of the process that starts first. Instead we set the default based on\n+    // the actual task node's jvm memory.\n+    final long maxBytesInMemory = getMaxBytesInMemory();\n+    if (maxBytesInMemory > 0) {\n+      return maxBytesInMemory;\n+    } else if (maxBytesInMemory == 0) {\n+      return getAppendableIndexSpec().getDefaultMaxBytesInMemory();\n+    } else {\n+      return Long.MAX_VALUE;\n+    }\n+  }\n+\n+  PartitionsSpec getPartitionsSpec();\n+\n+  IndexSpec getIndexSpec();\n+\n+  IndexSpec getIndexSpecForIntermediatePersists();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE2MzM3OQ=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzODExMDcxOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNzowMDo0NVrOHd8_tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxODoxOToxNlrOHd_7_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE3MDEwMg==", "bodyText": "Isn't validate() already checking this?", "url": "https://github.com/apache/druid/pull/10335#discussion_r501170102", "createdAt": "2020-10-07T17:00:45Z", "author": {"login": "a2l007"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "diffHunk": "@@ -346,4 +349,99 @@ public void close()\n     }\n     aggBuffers.clear();\n   }\n+\n+  public static class Builder extends AppendableIndexBuilder\n+  {\n+    @Nullable\n+    NonBlockingPool<ByteBuffer> bufferPool = null;\n+\n+    public Builder setBufferPool(final NonBlockingPool<ByteBuffer> bufferPool)\n+    {\n+      this.bufferPool = bufferPool;\n+      return this;\n+    }\n+\n+    @Override\n+    public void validate()\n+    {\n+      super.validate();\n+      if (bufferPool == null) {\n+        throw new IllegalArgumentException(\"bufferPool cannot be null\");\n+      }\n+    }\n+\n+    @Override\n+    protected OffheapIncrementalIndex buildInner()\n+    {\n+      return new OffheapIncrementalIndex(\n+          Objects.requireNonNull(incrementalIndexSchema, \"incrementalIndexSchema is null\"),\n+          deserializeComplexMetrics,\n+          concurrentEventAdd,\n+          sortFacts,\n+          maxRowCount,\n+          Objects.requireNonNull(bufferPool, \"bufferPool is null\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIxODMwMQ==", "bodyText": "It does, but without this, Intellij warns about \"Argument might be null\".", "url": "https://github.com/apache/druid/pull/10335#discussion_r501218301", "createdAt": "2020-10-07T18:19:16Z", "author": {"login": "liran-funaro"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "diffHunk": "@@ -346,4 +349,99 @@ public void close()\n     }\n     aggBuffers.clear();\n   }\n+\n+  public static class Builder extends AppendableIndexBuilder\n+  {\n+    @Nullable\n+    NonBlockingPool<ByteBuffer> bufferPool = null;\n+\n+    public Builder setBufferPool(final NonBlockingPool<ByteBuffer> bufferPool)\n+    {\n+      this.bufferPool = bufferPool;\n+      return this;\n+    }\n+\n+    @Override\n+    public void validate()\n+    {\n+      super.validate();\n+      if (bufferPool == null) {\n+        throw new IllegalArgumentException(\"bufferPool cannot be null\");\n+      }\n+    }\n+\n+    @Override\n+    protected OffheapIncrementalIndex buildInner()\n+    {\n+      return new OffheapIncrementalIndex(\n+          Objects.requireNonNull(incrementalIndexSchema, \"incrementalIndexSchema is null\"),\n+          deserializeComplexMetrics,\n+          concurrentEventAdd,\n+          sortFacts,\n+          maxRowCount,\n+          Objects.requireNonNull(bufferPool, \"bufferPool is null\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE3MDEwMg=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzODE4Nzg3OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxNzoyMTowMVrOHd9v0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNzo1MzowMVrOHeSL7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4MjQxOQ==", "bodyText": "The changes in this class apart from conforming to the AppendableIndexSpec interface might be out of scope of this PR and it might require its own additional tests. Would it be make sense to propose these changes in an incremental PR once the AppendableIndexSpec changes are merged?", "url": "https://github.com/apache/druid/pull/10335#discussion_r501182419", "createdAt": "2020-10-07T17:21:01Z", "author": {"login": "a2l007"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "diffHunk": "@@ -346,4 +349,99 @@ public void close()\n     }\n     aggBuffers.clear();\n   }\n+\n+  public static class Builder extends AppendableIndexBuilder\n+  {\n+    @Nullable\n+    NonBlockingPool<ByteBuffer> bufferPool = null;\n+\n+    public Builder setBufferPool(final NonBlockingPool<ByteBuffer> bufferPool)\n+    {\n+      this.bufferPool = bufferPool;\n+      return this;\n+    }\n+\n+    @Override\n+    public void validate()\n+    {\n+      super.validate();\n+      if (bufferPool == null) {\n+        throw new IllegalArgumentException(\"bufferPool cannot be null\");\n+      }\n+    }\n+\n+    @Override\n+    protected OffheapIncrementalIndex buildInner()\n+    {\n+      return new OffheapIncrementalIndex(\n+          Objects.requireNonNull(incrementalIndexSchema, \"incrementalIndexSchema is null\"),\n+          deserializeComplexMetrics,\n+          concurrentEventAdd,\n+          sortFacts,\n+          maxRowCount,\n+          Objects.requireNonNull(bufferPool, \"bufferPool is null\")\n+      );\n+    }\n+  }\n+\n+  public static class Spec implements AppendableIndexSpec, Supplier<ByteBuffer>\n+  {\n+    public static final String TYPE = \"offheap\";\n+    static final int DEFAULT_BUFFER_SIZE = 1 << 23;\n+    static final int DEFAULT_CACHE_SIZE = 1 << 30;\n+\n+    final int bufferSize;\n+    final int cacheSize;\n+    final NonBlockingPool<ByteBuffer> bufferPool;\n+\n+    @JsonCreator\n+    public Spec(\n+        final @JsonProperty(\"bufferSize\") @Nullable Integer bufferSize,\n+        final @JsonProperty(\"cacheSize\") @Nullable Integer cacheSize\n+    )\n+    {\n+      this.bufferSize = bufferSize != null && bufferSize > 0 ? bufferSize : DEFAULT_BUFFER_SIZE;\n+      this.cacheSize = cacheSize != null && cacheSize > this.bufferSize ? cacheSize : DEFAULT_CACHE_SIZE;\n+      this.bufferPool = new StupidPool<>(\n+          \"Offheap incremental-index buffer pool\",\n+          this,\n+          0,\n+          this.cacheSize / this.bufferSize", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTIyMTAwMQ==", "bodyText": "Yes. That is possible. I will separate this part into a PR that will follow this one.", "url": "https://github.com/apache/druid/pull/10335#discussion_r501221001", "createdAt": "2020-10-07T18:22:06Z", "author": {"login": "liran-funaro"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "diffHunk": "@@ -346,4 +349,99 @@ public void close()\n     }\n     aggBuffers.clear();\n   }\n+\n+  public static class Builder extends AppendableIndexBuilder\n+  {\n+    @Nullable\n+    NonBlockingPool<ByteBuffer> bufferPool = null;\n+\n+    public Builder setBufferPool(final NonBlockingPool<ByteBuffer> bufferPool)\n+    {\n+      this.bufferPool = bufferPool;\n+      return this;\n+    }\n+\n+    @Override\n+    public void validate()\n+    {\n+      super.validate();\n+      if (bufferPool == null) {\n+        throw new IllegalArgumentException(\"bufferPool cannot be null\");\n+      }\n+    }\n+\n+    @Override\n+    protected OffheapIncrementalIndex buildInner()\n+    {\n+      return new OffheapIncrementalIndex(\n+          Objects.requireNonNull(incrementalIndexSchema, \"incrementalIndexSchema is null\"),\n+          deserializeComplexMetrics,\n+          concurrentEventAdd,\n+          sortFacts,\n+          maxRowCount,\n+          Objects.requireNonNull(bufferPool, \"bufferPool is null\")\n+      );\n+    }\n+  }\n+\n+  public static class Spec implements AppendableIndexSpec, Supplier<ByteBuffer>\n+  {\n+    public static final String TYPE = \"offheap\";\n+    static final int DEFAULT_BUFFER_SIZE = 1 << 23;\n+    static final int DEFAULT_CACHE_SIZE = 1 << 30;\n+\n+    final int bufferSize;\n+    final int cacheSize;\n+    final NonBlockingPool<ByteBuffer> bufferPool;\n+\n+    @JsonCreator\n+    public Spec(\n+        final @JsonProperty(\"bufferSize\") @Nullable Integer bufferSize,\n+        final @JsonProperty(\"cacheSize\") @Nullable Integer cacheSize\n+    )\n+    {\n+      this.bufferSize = bufferSize != null && bufferSize > 0 ? bufferSize : DEFAULT_BUFFER_SIZE;\n+      this.cacheSize = cacheSize != null && cacheSize > this.bufferSize ? cacheSize : DEFAULT_CACHE_SIZE;\n+      this.bufferPool = new StupidPool<>(\n+          \"Offheap incremental-index buffer pool\",\n+          this,\n+          0,\n+          this.cacheSize / this.bufferSize", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4MjQxOQ=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTUxNzI5Mw==", "bodyText": "Removed", "url": "https://github.com/apache/druid/pull/10335#discussion_r501517293", "createdAt": "2020-10-08T07:53:01Z", "author": {"login": "liran-funaro"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "diffHunk": "@@ -346,4 +349,99 @@ public void close()\n     }\n     aggBuffers.clear();\n   }\n+\n+  public static class Builder extends AppendableIndexBuilder\n+  {\n+    @Nullable\n+    NonBlockingPool<ByteBuffer> bufferPool = null;\n+\n+    public Builder setBufferPool(final NonBlockingPool<ByteBuffer> bufferPool)\n+    {\n+      this.bufferPool = bufferPool;\n+      return this;\n+    }\n+\n+    @Override\n+    public void validate()\n+    {\n+      super.validate();\n+      if (bufferPool == null) {\n+        throw new IllegalArgumentException(\"bufferPool cannot be null\");\n+      }\n+    }\n+\n+    @Override\n+    protected OffheapIncrementalIndex buildInner()\n+    {\n+      return new OffheapIncrementalIndex(\n+          Objects.requireNonNull(incrementalIndexSchema, \"incrementalIndexSchema is null\"),\n+          deserializeComplexMetrics,\n+          concurrentEventAdd,\n+          sortFacts,\n+          maxRowCount,\n+          Objects.requireNonNull(bufferPool, \"bufferPool is null\")\n+      );\n+    }\n+  }\n+\n+  public static class Spec implements AppendableIndexSpec, Supplier<ByteBuffer>\n+  {\n+    public static final String TYPE = \"offheap\";\n+    static final int DEFAULT_BUFFER_SIZE = 1 << 23;\n+    static final int DEFAULT_CACHE_SIZE = 1 << 30;\n+\n+    final int bufferSize;\n+    final int cacheSize;\n+    final NonBlockingPool<ByteBuffer> bufferPool;\n+\n+    @JsonCreator\n+    public Spec(\n+        final @JsonProperty(\"bufferSize\") @Nullable Integer bufferSize,\n+        final @JsonProperty(\"cacheSize\") @Nullable Integer cacheSize\n+    )\n+    {\n+      this.bufferSize = bufferSize != null && bufferSize > 0 ? bufferSize : DEFAULT_BUFFER_SIZE;\n+      this.cacheSize = cacheSize != null && cacheSize > this.bufferSize ? cacheSize : DEFAULT_CACHE_SIZE;\n+      this.bufferPool = new StupidPool<>(\n+          \"Offheap incremental-index buffer pool\",\n+          this,\n+          0,\n+          this.cacheSize / this.bufferSize", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4MjQxOQ=="}, "originalCommit": {"oid": "452b196493dda7dd7c558bc67fa8db56e4b33395"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2Njk1OTUyOnYy", "diffSide": "RIGHT", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/SeekableStreamIndexTaskTuningConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNDozMTo1OFrOHiK3jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQxNjo1NzoxNlrOHiRUBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU5MTY5NA==", "bodyText": "Could you please write an EqualsVerifier test for this. That should take care of the travis failures.", "url": "https://github.com/apache/druid/pull/10335#discussion_r505591694", "createdAt": "2020-10-15T14:31:58Z", "author": {"login": "a2l007"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/SeekableStreamIndexTaskTuningConfig.java", "diffHunk": "@@ -281,7 +292,8 @@ public boolean equals(Object o)\n       return false;\n     }\n     SeekableStreamIndexTaskTuningConfig that = (SeekableStreamIndexTaskTuningConfig) o;\n-    return maxRowsInMemory == that.maxRowsInMemory &&\n+    return Objects.equals(appendableIndexSpec, that.appendableIndexSpec) &&\n+           maxRowsInMemory == that.maxRowsInMemory &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "829b86f9548952795c4f3808679adfacb3f5b97a"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5NzI4Nw==", "bodyText": "@a2l007 Thanks for the tip. I wasn't aware of EqualsVerifier.\nI added it and now it passes the tests but fails some integration tests that passed before.\nI suspect there is an issue with the integration tests because sometimes the master branch also fails in these.", "url": "https://github.com/apache/druid/pull/10335#discussion_r505697287", "createdAt": "2020-10-15T16:57:16Z", "author": {"login": "liran-funaro"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/SeekableStreamIndexTaskTuningConfig.java", "diffHunk": "@@ -281,7 +292,8 @@ public boolean equals(Object o)\n       return false;\n     }\n     SeekableStreamIndexTaskTuningConfig that = (SeekableStreamIndexTaskTuningConfig) o;\n-    return maxRowsInMemory == that.maxRowsInMemory &&\n+    return Objects.equals(appendableIndexSpec, that.appendableIndexSpec) &&\n+           maxRowsInMemory == that.maxRowsInMemory &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTU5MTY5NA=="}, "originalCommit": {"oid": "829b86f9548952795c4f3808679adfacb3f5b97a"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzMxNTUxOnYy", "diffSide": "RIGHT", "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/IndexTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDozMzo0MVrOHlP-qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMTowNTozNVrOHlmXNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMTE2MQ==", "bodyText": "nit: we don't use multi-line comments.", "url": "https://github.com/apache/druid/pull/10335#discussion_r508821161", "createdAt": "2020-10-20T20:33:41Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/IndexTask.java", "diffHunk": "@@ -1262,9 +1267,10 @@ private IndexTuningConfig(\n         @Nullable Integer maxSavedParseExceptions\n     )\n     {\n+      this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;\n       this.maxRowsInMemory = maxRowsInMemory == null ? TuningConfig.DEFAULT_MAX_ROWS_IN_MEMORY : maxRowsInMemory;\n-      // initializing this to 0, it will be lazily initialized to a value\n-      // @see server.src.main.java.org.apache.druid.segment.indexing.TuningConfigs#getMaxBytesInMemoryOrDefault(long)\n+      /** initializing this to 0, it will be lazily initialized to a value\n+       * @see #getMaxBytesInMemoryOrDefault() */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c8c18f69ca287db043ceee8aed04309c1cdf6ce"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE4Nzg5Mg==", "bodyText": "Fixed.", "url": "https://github.com/apache/druid/pull/10335#discussion_r509187892", "createdAt": "2020-10-21T11:05:35Z", "author": {"login": "liran-funaro"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/common/task/IndexTask.java", "diffHunk": "@@ -1262,9 +1267,10 @@ private IndexTuningConfig(\n         @Nullable Integer maxSavedParseExceptions\n     )\n     {\n+      this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;\n       this.maxRowsInMemory = maxRowsInMemory == null ? TuningConfig.DEFAULT_MAX_ROWS_IN_MEMORY : maxRowsInMemory;\n-      // initializing this to 0, it will be lazily initialized to a value\n-      // @see server.src.main.java.org.apache.druid.segment.indexing.TuningConfigs#getMaxBytesInMemoryOrDefault(long)\n+      /** initializing this to 0, it will be lazily initialized to a value\n+       * @see #getMaxBytesInMemoryOrDefault() */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMTE2MQ=="}, "originalCommit": {"oid": "5c8c18f69ca287db043ceee8aed04309c1cdf6ce"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzMxNzM2OnYy", "diffSide": "RIGHT", "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/SeekableStreamIndexTaskTuningConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDozNDoxMlrOHlP_uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMTowNTo0MFrOHlmXaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMTQzMg==", "bodyText": "Same here.", "url": "https://github.com/apache/druid/pull/10335#discussion_r508821432", "createdAt": "2020-10-20T20:34:12Z", "author": {"login": "jihoonson"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/SeekableStreamIndexTaskTuningConfig.java", "diffHunk": "@@ -84,10 +87,11 @@ public SeekableStreamIndexTaskTuningConfig(\n     // Cannot be a static because default basePersistDirectory is unique per-instance\n     final RealtimeTuningConfig defaults = RealtimeTuningConfig.makeDefaultTuningConfig(basePersistDirectory);\n \n+    this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;\n     this.maxRowsInMemory = maxRowsInMemory == null ? defaults.getMaxRowsInMemory() : maxRowsInMemory;\n     this.partitionsSpec = new DynamicPartitionsSpec(maxRowsPerSegment, maxTotalRows);\n-    // initializing this to 0, it will be lazily initialized to a value\n-    // @see server.src.main.java.org.apache.druid.segment.indexing.TuningConfigs#getMaxBytesInMemoryOrDefault(long)\n+    /** initializing this to 0, it will be lazily initialized to a value\n+     * @see #getMaxBytesInMemoryOrDefault() */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c8c18f69ca287db043ceee8aed04309c1cdf6ce"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE4Nzk0NQ==", "bodyText": "Fixed.", "url": "https://github.com/apache/druid/pull/10335#discussion_r509187945", "createdAt": "2020-10-21T11:05:40Z", "author": {"login": "liran-funaro"}, "path": "indexing-service/src/main/java/org/apache/druid/indexing/seekablestream/SeekableStreamIndexTaskTuningConfig.java", "diffHunk": "@@ -84,10 +87,11 @@ public SeekableStreamIndexTaskTuningConfig(\n     // Cannot be a static because default basePersistDirectory is unique per-instance\n     final RealtimeTuningConfig defaults = RealtimeTuningConfig.makeDefaultTuningConfig(basePersistDirectory);\n \n+    this.appendableIndexSpec = appendableIndexSpec == null ? DEFAULT_APPENDABLE_INDEX : appendableIndexSpec;\n     this.maxRowsInMemory = maxRowsInMemory == null ? defaults.getMaxRowsInMemory() : maxRowsInMemory;\n     this.partitionsSpec = new DynamicPartitionsSpec(maxRowsPerSegment, maxTotalRows);\n-    // initializing this to 0, it will be lazily initialized to a value\n-    // @see server.src.main.java.org.apache.druid.segment.indexing.TuningConfigs#getMaxBytesInMemoryOrDefault(long)\n+    /** initializing this to 0, it will be lazily initialized to a value\n+     * @see #getMaxBytesInMemoryOrDefault() */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyMTQzMg=="}, "originalCommit": {"oid": "5c8c18f69ca287db043ceee8aed04309c1cdf6ce"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzM0MTQwOnYy", "diffSide": "RIGHT", "path": "docs/ingestion/index.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDo0MDozOVrOHlQN9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxMTowODo1NVrOHlmd1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNTA3OA==", "bodyText": "Do you think if users want to change this config ever for now? I remember @gianm mentioned that the offheap incremental index has some performance issue, which is why we don't use it for indexing. If you think this knob is useful for users, please add more details how each index type is different and when it's recommended to use what. Otherwise, I would suggest not documenting this know at least for now.", "url": "https://github.com/apache/druid/pull/10335#discussion_r508825078", "createdAt": "2020-10-20T20:40:39Z", "author": {"login": "jihoonson"}, "path": "docs/ingestion/index.md", "diffHunk": "@@ -737,3 +741,11 @@ The `indexSpec` object can include the following properties:\n \n Beyond these properties, each ingestion method has its own specific tuning properties. See the documentation for each\n [ingestion method](#ingestion-methods) for details.\n+\n+#### `appendableIndexSpec`\n+\n+|Field|Description|Default|\n+|-----|-----------|-------|\n+|type|Each in-memory index has its own tuning type code. You must specify the type code that matches your in-memory index. Common options are `onheap`, and `offheap`.|`onheap`|\n+\n+Beyond these properties, each in-memory index has its own specific tuning properties.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c8c18f69ca287db043ceee8aed04309c1cdf6ce"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE4OTU4OQ==", "bodyText": "Actually, by @a2l007 suggestion, I deferred the support for offheap ingestion to a different PR.\nSo this documentation should not include the offheap option anyway.\nI'll remove this documentation for now.", "url": "https://github.com/apache/druid/pull/10335#discussion_r509189589", "createdAt": "2020-10-21T11:08:55Z", "author": {"login": "liran-funaro"}, "path": "docs/ingestion/index.md", "diffHunk": "@@ -737,3 +741,11 @@ The `indexSpec` object can include the following properties:\n \n Beyond these properties, each ingestion method has its own specific tuning properties. See the documentation for each\n [ingestion method](#ingestion-methods) for details.\n+\n+#### `appendableIndexSpec`\n+\n+|Field|Description|Default|\n+|-----|-----------|-------|\n+|type|Each in-memory index has its own tuning type code. You must specify the type code that matches your in-memory index. Common options are `onheap`, and `offheap`.|`onheap`|\n+\n+Beyond these properties, each in-memory index has its own specific tuning properties.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgyNTA3OA=="}, "originalCommit": {"oid": "5c8c18f69ca287db043ceee8aed04309c1cdf6ce"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3136, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}