{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0NzQ1MTk3", "number": 10448, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxNjoxMzozNFrOEu-o2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNjowMjowNlrOFLj0ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3Njk2MjE3OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/druid/java/util/common/concurrent/ScheduledExecutors.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOFQxNjoxMzozNFrOHjr6Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxMToyMDoxOFrOHo3JDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MTY2Mg==", "bodyText": "I think this logic: scheduling one-shot task which reschedules itself, is problematic. I think we should remove these methods (together with the Signal enum) because they have negative utility.\nIn particular, for CronScheduler, constant rescheduling is probably prone to some drift. Instead, CronScheduler's methods like scheduleAtFixedRate() should be used directly from MonitorScheduler. The periodic task can be cancelled using the returned Future.", "url": "https://github.com/apache/druid/pull/10448#discussion_r507181662", "createdAt": "2020-10-18T16:13:34Z", "author": {"login": "leventov"}, "path": "core/src/main/java/org/apache/druid/java/util/common/concurrent/ScheduledExecutors.java", "diffHunk": "@@ -167,6 +169,50 @@ public void run()\n     );\n   }\n \n+  public static void scheduleAtFixedRate(CronScheduler exec, Duration rate, Callable<Signal> callable)\n+  {\n+    scheduleAtFixedRate(exec, rate, rate, callable);\n+  }\n+\n+  /**\n+   * Run callable once every period, after the given initial delay. Uses\n+   * {@link CronScheduler} for task scheduling. Exceptions are caught and logged\n+   * as errors.\n+   */\n+  public static void scheduleAtFixedRate(\n+      final CronScheduler exec,\n+      final Duration initialDelay,\n+      final Duration rate,\n+      final Callable<Signal> callable\n+  )\n+  {\n+    log.debug(\"Scheduling periodically: %s with period %s\", callable, rate);\n+    Instant delayInstance = Instant.now().plusMillis(initialDelay.getMillis());\n+    exec.scheduleAt(delayInstance,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20f7fe61551d1f3afeaeb06c245089aa4569f568"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4NjkyNg==", "bodyText": "That makes sense. I'll change this.", "url": "https://github.com/apache/druid/pull/10448#discussion_r507186926", "createdAt": "2020-10-18T17:02:36Z", "author": {"login": "ayushkul2910"}, "path": "core/src/main/java/org/apache/druid/java/util/common/concurrent/ScheduledExecutors.java", "diffHunk": "@@ -167,6 +169,50 @@ public void run()\n     );\n   }\n \n+  public static void scheduleAtFixedRate(CronScheduler exec, Duration rate, Callable<Signal> callable)\n+  {\n+    scheduleAtFixedRate(exec, rate, rate, callable);\n+  }\n+\n+  /**\n+   * Run callable once every period, after the given initial delay. Uses\n+   * {@link CronScheduler} for task scheduling. Exceptions are caught and logged\n+   * as errors.\n+   */\n+  public static void scheduleAtFixedRate(\n+      final CronScheduler exec,\n+      final Duration initialDelay,\n+      final Duration rate,\n+      final Callable<Signal> callable\n+  )\n+  {\n+    log.debug(\"Scheduling periodically: %s with period %s\", callable, rate);\n+    Instant delayInstance = Instant.now().plusMillis(initialDelay.getMillis());\n+    exec.scheduleAt(delayInstance,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MTY2Mg=="}, "originalCommit": {"oid": "20f7fe61551d1f3afeaeb06c245089aa4569f568"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk0MTcwMg==", "bodyText": "Hey @leventov, do you think the below implementation for startMonitor(final Monitor monitor) method in MonitorScheduler class will suffice? Also, can this cause any inconsistency  since scheduledFuture is volatile and is shared amongst all the monitors?\nsynchronized (lock) {\n  monitor.start();\n  Long rate = config.getEmitterPeriod().getMillis();\n  scheduledFuture = scheduler.scheduleAtFixedRate(\n      rate,\n      rate,\n      TimeUnit.MILLISECONDS,\n      new CronTask()\n      {\n        @Override\n        public void run(long scheduledRunTimeMillis)\n        {\n          try {\n            if (monitor.monitor(emitter) && hasMonitor(monitor)) {\n              log.trace(\"Running %s (period %s)\", this, rate);\n            } else {\n              log.debug(\"Stopping rescheduling %s (delay %s)\", this, rate);\n              removeMonitor(monitor);\n              while (scheduledFuture == null) {\n                Thread.sleep(1);\n              }\n              scheduledFuture.cancel(false);\n            }\n          } catch (Throwable e) {\n            log.error(e, \"Uncaught exception.\");\n          }\n        }\n      });\n}", "url": "https://github.com/apache/druid/pull/10448#discussion_r511941702", "createdAt": "2020-10-26T13:02:41Z", "author": {"login": "ayushkul2910"}, "path": "core/src/main/java/org/apache/druid/java/util/common/concurrent/ScheduledExecutors.java", "diffHunk": "@@ -167,6 +169,50 @@ public void run()\n     );\n   }\n \n+  public static void scheduleAtFixedRate(CronScheduler exec, Duration rate, Callable<Signal> callable)\n+  {\n+    scheduleAtFixedRate(exec, rate, rate, callable);\n+  }\n+\n+  /**\n+   * Run callable once every period, after the given initial delay. Uses\n+   * {@link CronScheduler} for task scheduling. Exceptions are caught and logged\n+   * as errors.\n+   */\n+  public static void scheduleAtFixedRate(\n+      final CronScheduler exec,\n+      final Duration initialDelay,\n+      final Duration rate,\n+      final Callable<Signal> callable\n+  )\n+  {\n+    log.debug(\"Scheduling periodically: %s with period %s\", callable, rate);\n+    Instant delayInstance = Instant.now().plusMillis(initialDelay.getMillis());\n+    exec.scheduleAt(delayInstance,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MTY2Mg=="}, "originalCommit": {"oid": "20f7fe61551d1f3afeaeb06c245089aa4569f568"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwMzE5Mw==", "bodyText": "There should be a separate future for every monitor. I also think there should be a separate executorService for running monitor.monitor(emitter), and cancelling the future from the first monitor, for two reasons:\n\nMonitor code is not guaranteed to be non-blocking and \"cheap\", which is the requirement of CronScheduler;\nYou can avoid having a race condition of cancelling a future on the first iteration when it's not yet created.", "url": "https://github.com/apache/druid/pull/10448#discussion_r512203193", "createdAt": "2020-10-26T19:07:54Z", "author": {"login": "leventov"}, "path": "core/src/main/java/org/apache/druid/java/util/common/concurrent/ScheduledExecutors.java", "diffHunk": "@@ -167,6 +169,50 @@ public void run()\n     );\n   }\n \n+  public static void scheduleAtFixedRate(CronScheduler exec, Duration rate, Callable<Signal> callable)\n+  {\n+    scheduleAtFixedRate(exec, rate, rate, callable);\n+  }\n+\n+  /**\n+   * Run callable once every period, after the given initial delay. Uses\n+   * {@link CronScheduler} for task scheduling. Exceptions are caught and logged\n+   * as errors.\n+   */\n+  public static void scheduleAtFixedRate(\n+      final CronScheduler exec,\n+      final Duration initialDelay,\n+      final Duration rate,\n+      final Callable<Signal> callable\n+  )\n+  {\n+    log.debug(\"Scheduling periodically: %s with period %s\", callable, rate);\n+    Instant delayInstance = Instant.now().plusMillis(initialDelay.getMillis());\n+    exec.scheduleAt(delayInstance,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MTY2Mg=="}, "originalCommit": {"oid": "20f7fe61551d1f3afeaeb06c245089aa4569f568"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjYwODUyNw==", "bodyText": "Keeping the above points in mind, I think this implementation will do.\nsynchronized (lock) {\n  monitor.start();\n  Long rate = config.getEmitterPeriod().getMillis();\n  Future<?> scheduledFuture = scheduler.scheduleAtFixedRate(\n      rate,\n      rate,\n      TimeUnit.MILLISECONDS,\n      new CronTask()\n      {\n        private volatile Future<Boolean> monitorFuture = null;\n        @Override\n        public void run(long scheduledRunTimeMillis)\n        {\n          try {\n            if (monitorFuture != null && monitorFuture.isDone()\n                && !(monitorFuture.get() && hasMonitor(monitor))) {\n              removeMonitor(monitor);\n              monitor.getScheduledFuture().cancel(false);\n              log.debug(\"Stopped rescheduling %s (delay %s)\", this, rate);\n              return;\n            }\n            \n            log.trace(\"Running %s (period %s)\", this, rate);\n            monitorFuture = executor.submit(new Callable<Boolean>()\n            {\n              public Boolean call()\n              {\n                try {\n                  return monitor.monitor(emitter);\n                } catch (Throwable e) {\n                  log.error(e, \"Uncaught exception.\");\n                  return false;\n                }\n              }\n            });\n          } \n          catch (Throwable e) {\n            log.error(e, \"Uncaught exception.\");\n          }\n        }\n      });\n  monitor.setScheduledFuture(scheduledFuture);\n}\n\nIn this:\n\nEach monitor has a separate future.\nCron task is cheap, it checks a boolean condition. If condition is true it cancels the scheduling process for the particular monitor, else submits a callable for monitoring to executor service\nNo race condition for cancelling scheduledFuture on first iteration.\n\nPlease let me know your thoughts on this.", "url": "https://github.com/apache/druid/pull/10448#discussion_r512608527", "createdAt": "2020-10-27T11:20:18Z", "author": {"login": "ayushkul2910"}, "path": "core/src/main/java/org/apache/druid/java/util/common/concurrent/ScheduledExecutors.java", "diffHunk": "@@ -167,6 +169,50 @@ public void run()\n     );\n   }\n \n+  public static void scheduleAtFixedRate(CronScheduler exec, Duration rate, Callable<Signal> callable)\n+  {\n+    scheduleAtFixedRate(exec, rate, rate, callable);\n+  }\n+\n+  /**\n+   * Run callable once every period, after the given initial delay. Uses\n+   * {@link CronScheduler} for task scheduling. Exceptions are caught and logged\n+   * as errors.\n+   */\n+  public static void scheduleAtFixedRate(\n+      final CronScheduler exec,\n+      final Duration initialDelay,\n+      final Duration rate,\n+      final Callable<Signal> callable\n+  )\n+  {\n+    log.debug(\"Scheduling periodically: %s with period %s\", callable, rate);\n+    Instant delayInstance = Instant.now().plusMillis(initialDelay.getMillis());\n+    exec.scheduleAt(delayInstance,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE4MTY2Mg=="}, "originalCommit": {"oid": "20f7fe61551d1f3afeaeb06c245089aa4569f568"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3NjY1NTMxOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/org/apache/druid/server/metrics/MetricsModule.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQwNjowMjowNlrOIOy-PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQxMTozMzozM1rOIQO9-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NjEwOQ==", "bodyText": "This looks like an overkill. What was the rationale for using this many threads?", "url": "https://github.com/apache/druid/pull/10448#discussion_r552386109", "createdAt": "2021-01-06T06:02:06Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/server/metrics/MetricsModule.java", "diffHunk": "@@ -108,10 +108,10 @@ public MonitorScheduler getMonitorScheduler(\n \n     return new MonitorScheduler(\n         config.get(),\n-        CronScheduler.newBuilder(Duration.ofSeconds(1L)).setThreadName(\"MonitorScheduler-%s\").build(),\n+        CronScheduler.newBuilder(Duration.ofSeconds(1L)).setThreadName(\"MonitorSchedulerThread\").build(),\n         emitter,\n         monitors,\n-        Executors.newCachedThreadPool()\n+        Execs.multiThreaded(64, \"MonitorThread-%d\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8628ad13629a4a8bbca52e3f6561276be7b5893"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzE2MjM0OQ==", "bodyText": "Hi @jihoonson , sorry for delay in response.\nI think currently there are ~20 monitors, which can run concurrently with the MonitorScheduler class. Suppose a case in which frequency of scheduling < time taken by the executor thread to do monitor.monitor(...)(Although I am not sure if this case is possible in practical, kind of edge case). This can result in queuing of the tasks if threads are very less. I think we should atleast have no. of threads equal to max number of monitors supported. I may be missing something here. What do you think?", "url": "https://github.com/apache/druid/pull/10448#discussion_r553162349", "createdAt": "2021-01-07T07:56:16Z", "author": {"login": "ayushkul2910"}, "path": "server/src/main/java/org/apache/druid/server/metrics/MetricsModule.java", "diffHunk": "@@ -108,10 +108,10 @@ public MonitorScheduler getMonitorScheduler(\n \n     return new MonitorScheduler(\n         config.get(),\n-        CronScheduler.newBuilder(Duration.ofSeconds(1L)).setThreadName(\"MonitorScheduler-%s\").build(),\n+        CronScheduler.newBuilder(Duration.ofSeconds(1L)).setThreadName(\"MonitorSchedulerThread\").build(),\n         emitter,\n         monitors,\n-        Executors.newCachedThreadPool()\n+        Execs.multiThreaded(64, \"MonitorThread-%d\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NjEwOQ=="}, "originalCommit": {"oid": "d8628ad13629a4a8bbca52e3f6561276be7b5893"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzYwNzg1NQ==", "bodyText": "The monitor usually takes less than 1 sec (probably less than 100 ms) while the emission period is large enough to run all monitors (1 min by default). So, I think the scenario you described can happen when there are some failures such as retrying metrics emission due to some network issue. However, I don't think we should handle these failures by employing multiple threads because there is nothing we can do better with more threads. I would rather not schedule a new monitor task if the previous one is still running. I implemented this in #10732.", "url": "https://github.com/apache/druid/pull/10448#discussion_r553607855", "createdAt": "2021-01-07T21:47:48Z", "author": {"login": "jihoonson"}, "path": "server/src/main/java/org/apache/druid/server/metrics/MetricsModule.java", "diffHunk": "@@ -108,10 +108,10 @@ public MonitorScheduler getMonitorScheduler(\n \n     return new MonitorScheduler(\n         config.get(),\n-        CronScheduler.newBuilder(Duration.ofSeconds(1L)).setThreadName(\"MonitorScheduler-%s\").build(),\n+        CronScheduler.newBuilder(Duration.ofSeconds(1L)).setThreadName(\"MonitorSchedulerThread\").build(),\n         emitter,\n         monitors,\n-        Executors.newCachedThreadPool()\n+        Execs.multiThreaded(64, \"MonitorThread-%d\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NjEwOQ=="}, "originalCommit": {"oid": "d8628ad13629a4a8bbca52e3f6561276be7b5893"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mzg5MzM2OQ==", "bodyText": "This makes sense, we should reduce the number of monitor threads.", "url": "https://github.com/apache/druid/pull/10448#discussion_r553893369", "createdAt": "2021-01-08T11:33:33Z", "author": {"login": "ayushkul2910"}, "path": "server/src/main/java/org/apache/druid/server/metrics/MetricsModule.java", "diffHunk": "@@ -108,10 +108,10 @@ public MonitorScheduler getMonitorScheduler(\n \n     return new MonitorScheduler(\n         config.get(),\n-        CronScheduler.newBuilder(Duration.ofSeconds(1L)).setThreadName(\"MonitorScheduler-%s\").build(),\n+        CronScheduler.newBuilder(Duration.ofSeconds(1L)).setThreadName(\"MonitorSchedulerThread\").build(),\n         emitter,\n         monitors,\n-        Executors.newCachedThreadPool()\n+        Execs.multiThreaded(64, \"MonitorThread-%d\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM4NjEwOQ=="}, "originalCommit": {"oid": "d8628ad13629a4a8bbca52e3f6561276be7b5893"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2989, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}