{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc0MjMwMzYw", "number": 10324, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwODozNToyMFrOEdHmPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwNzoxOTowOFrOFRxHvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4OTY4NjM4OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QwODozNToyMFrOHIGHTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjoxMzo0MFrOHIjDUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1MDgzMQ==", "bodyText": "nit: adding an error message will be helpful.", "url": "https://github.com/apache/druid/pull/10324#discussion_r478250831", "createdAt": "2020-08-27T08:35:20Z", "author": {"login": "abhishekagarwal87"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      Preconditions.checkState(firstDruidRel instanceof DruidQueryRel);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80502217e4eaf32ceaf360df2db1a51c3eb66c14"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUwNzU5Nw==", "bodyText": "I added a message.", "url": "https://github.com/apache/druid/pull/10324#discussion_r478507597", "createdAt": "2020-08-27T15:30:05Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      Preconditions.checkState(firstDruidRel instanceof DruidQueryRel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1MDgzMQ=="}, "originalCommit": {"oid": "80502217e4eaf32ceaf360df2db1a51c3eb66c14"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU2MTk3Mg==", "bodyText": "Thanks. There are a few more places which I have highlighted.", "url": "https://github.com/apache/druid/pull/10324#discussion_r478561972", "createdAt": "2020-08-27T16:55:07Z", "author": {"login": "abhishekagarwal87"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      Preconditions.checkState(firstDruidRel instanceof DruidQueryRel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1MDgzMQ=="}, "originalCommit": {"oid": "80502217e4eaf32ceaf360df2db1a51c3eb66c14"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODcyNDk0NQ==", "bodyText": "Those all make sense; I added some messages.", "url": "https://github.com/apache/druid/pull/10324#discussion_r478724945", "createdAt": "2020-08-27T22:13:40Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      Preconditions.checkState(firstDruidRel instanceof DruidQueryRel);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1MDgzMQ=="}, "originalCommit": {"oid": "80502217e4eaf32ceaf360df2db1a51c3eb66c14"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTY1NjMwOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjo1MToyNVrOHIY-hg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjo1MToyNVrOHIY-hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU1OTg3OA==", "bodyText": "if this ever happens, an exception containing the actual stage name will be useful in debugging.", "url": "https://github.com/apache/druid/pull/10324#discussion_r478559878", "createdAt": "2020-08-27T16:51:25Z", "author": {"login": "abhishekagarwal87"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      Preconditions.checkState(firstDruidRel instanceof DruidQueryRel, \"Expected first rel to be a DruidQueryRel\");\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              unionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    }\n+  }\n+\n+  private static boolean isUnionCompatible(final DruidRel<?> first, final DruidRel<?> second)\n+  {\n+    final Optional<List<String>> columnNames = getColumnNamesIfTableOrUnion(first);\n+    return columnNames.isPresent() && columnNames.equals(getColumnNamesIfTableOrUnion(second));\n+  }\n+\n+  static Optional<List<String>> getColumnNamesIfTableOrUnion(final DruidRel<?> druidRel)\n+  {\n+    final PartialDruidQuery partialQuery = druidRel.getPartialDruidQuery();\n+\n+    final Optional<DruidTable> druidTable =\n+        DruidRels.druidTableIfLeafRel(druidRel)\n+                 .filter(table -> table.getDataSource() instanceof TableDataSource);\n+\n+    if (druidTable.isPresent() && DruidRels.isScanOrMapping(druidRel, false)) {\n+      // This rel is a table scan or mapping.\n+\n+      if (partialQuery.stage() == PartialDruidQuery.Stage.SCAN) {\n+        return Optional.of(druidTable.get().getRowSignature().getColumnNames());\n+      } else {\n+        // Sanity check. Expected to be true due to the \"scan or mapping\" check.\n+        Preconditions.checkState(partialQuery.stage() == PartialDruidQuery.Stage.SELECT_PROJECT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6c8c9bc45ac239f8543203ee73984026509196a"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTY1NjkwOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjo1MTozNlrOHIY-5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjo1MTozNlrOHIY-5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU1OTk3Mg==", "bodyText": "same comment here. will be useful to know both the table signature size as well as source count.", "url": "https://github.com/apache/druid/pull/10324#discussion_r478559972", "createdAt": "2020-08-27T16:51:36Z", "author": {"login": "abhishekagarwal87"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      Preconditions.checkState(firstDruidRel instanceof DruidQueryRel, \"Expected first rel to be a DruidQueryRel\");\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              unionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    }\n+  }\n+\n+  private static boolean isUnionCompatible(final DruidRel<?> first, final DruidRel<?> second)\n+  {\n+    final Optional<List<String>> columnNames = getColumnNamesIfTableOrUnion(first);\n+    return columnNames.isPresent() && columnNames.equals(getColumnNamesIfTableOrUnion(second));\n+  }\n+\n+  static Optional<List<String>> getColumnNamesIfTableOrUnion(final DruidRel<?> druidRel)\n+  {\n+    final PartialDruidQuery partialQuery = druidRel.getPartialDruidQuery();\n+\n+    final Optional<DruidTable> druidTable =\n+        DruidRels.druidTableIfLeafRel(druidRel)\n+                 .filter(table -> table.getDataSource() instanceof TableDataSource);\n+\n+    if (druidTable.isPresent() && DruidRels.isScanOrMapping(druidRel, false)) {\n+      // This rel is a table scan or mapping.\n+\n+      if (partialQuery.stage() == PartialDruidQuery.Stage.SCAN) {\n+        return Optional.of(druidTable.get().getRowSignature().getColumnNames());\n+      } else {\n+        // Sanity check. Expected to be true due to the \"scan or mapping\" check.\n+        Preconditions.checkState(partialQuery.stage() == PartialDruidQuery.Stage.SELECT_PROJECT);\n+\n+        // Apply the mapping (with additional sanity checks).\n+        final RowSignature tableSignature = druidTable.get().getRowSignature();\n+        final Mappings.TargetMapping mapping = partialQuery.getSelectProject().getMapping();\n+        Preconditions.checkState(mapping.getSourceCount() == tableSignature.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6c8c9bc45ac239f8543203ee73984026509196a"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MTY1OTIwOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjo1MjoxN1rOHIZAag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjo1MjoxN1rOHIZAag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODU2MDM2Mg==", "bodyText": "maybe add the class name of firstDruidRel in exception message?", "url": "https://github.com/apache/druid/pull/10324#discussion_r478560362", "createdAt": "2020-08-27T16:52:17Z", "author": {"login": "abhishekagarwal87"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import com.google.common.base.Preconditions;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      Preconditions.checkState(firstDruidRel instanceof DruidQueryRel, \"Expected first rel to be a DruidQueryRel\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6c8c9bc45ac239f8543203ee73984026509196a"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5Mjc4NzkwOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidUnionDataSourceRel.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjo1MTowNlrOHIj2JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjo1MTowNlrOHIj2JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODczNzk1Ng==", "bodyText": "nit: this could be an else if of the previous if that assigns signature if it was previously null", "url": "https://github.com/apache/druid/pull/10324#discussion_r478737956", "createdAt": "2020-08-27T22:51:06Z", "author": {"login": "clintropolis"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidUnionDataSourceRel.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rel;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import org.apache.calcite.plan.RelOptCluster;\n+import org.apache.calcite.plan.RelOptCost;\n+import org.apache.calcite.plan.RelOptPlanner;\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelTraitSet;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.RelWriter;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.rel.metadata.RelMetadataQuery;\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.java.util.common.guava.Sequence;\n+import org.apache.druid.query.DataSource;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.query.UnionDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.table.RowSignatures;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Represents a query on top of a {@link UnionDataSource}. This is used to represent a \"UNION ALL\" of regular table\n+ * datasources.\n+ *\n+ * See {@link DruidUnionRel} for a version that can union any set of queries together (not just regular tables),\n+ * but also must be the outermost rel of a query plan. In the future we expect that {@link UnionDataSource} will gain\n+ * the ability to union query datasources together, and then this class could replace {@link DruidUnionRel}.\n+ */\n+public class DruidUnionDataSourceRel extends DruidRel<DruidUnionDataSourceRel>\n+{\n+  private static final TableDataSource DUMMY_DATA_SOURCE = new TableDataSource(\"__union__\");\n+\n+  private final Union unionRel;\n+  private final List<String> unionColumnNames;\n+  private final PartialDruidQuery partialQuery;\n+\n+  private DruidUnionDataSourceRel(\n+      final RelOptCluster cluster,\n+      final RelTraitSet traitSet,\n+      final Union unionRel,\n+      final List<String> unionColumnNames,\n+      final PartialDruidQuery partialQuery,\n+      final QueryMaker queryMaker\n+  )\n+  {\n+    super(cluster, traitSet, queryMaker);\n+    this.unionRel = unionRel;\n+    this.unionColumnNames = unionColumnNames;\n+    this.partialQuery = partialQuery;\n+  }\n+\n+  public static DruidUnionDataSourceRel create(\n+      final Union unionRel,\n+      final List<String> unionColumnNames,\n+      final QueryMaker queryMaker\n+  )\n+  {\n+    return new DruidUnionDataSourceRel(\n+        unionRel.getCluster(),\n+        unionRel.getTraitSet(),\n+        unionRel,\n+        unionColumnNames,\n+        PartialDruidQuery.create(unionRel),\n+        queryMaker\n+    );\n+  }\n+\n+  public List<String> getUnionColumnNames()\n+  {\n+    return unionColumnNames;\n+  }\n+\n+  @Override\n+  public PartialDruidQuery getPartialDruidQuery()\n+  {\n+    return partialQuery;\n+  }\n+\n+  @Override\n+  public DruidUnionDataSourceRel withPartialQuery(final PartialDruidQuery newQueryBuilder)\n+  {\n+    return new DruidUnionDataSourceRel(\n+        getCluster(),\n+        getTraitSet().plusAll(newQueryBuilder.getRelTraits()),\n+        unionRel,\n+        unionColumnNames,\n+        newQueryBuilder,\n+        getQueryMaker()\n+    );\n+  }\n+\n+  @Override\n+  public Sequence<Object[]> runQuery()\n+  {\n+    // runQuery doesn't need to finalize aggregations, because the fact that runQuery is happening suggests this\n+    // is the outermost query and it will actually get run as a native query. Druid's native query layer will\n+    // finalize aggregations for the outermost query even if we don't explicitly ask it to.\n+\n+    return getQueryMaker().runQuery(toDruidQuery(false));\n+  }\n+\n+  @Override\n+  public DruidQuery toDruidQuery(final boolean finalizeAggregations)\n+  {\n+    final List<TableDataSource> dataSources = new ArrayList<>();\n+    RowSignature signature = null;\n+\n+    for (final RelNode relNode : unionRel.getInputs()) {\n+      final DruidRel<?> druidRel = (DruidRel<?>) relNode;\n+      if (!DruidRels.isScanOrMapping(druidRel, false)) {\n+        throw new CannotBuildQueryException(druidRel);\n+      }\n+\n+      final DruidQuery query = druidRel.toDruidQuery(false);\n+      final DataSource dataSource = query.getDataSource();\n+      if (!(dataSource instanceof TableDataSource)) {\n+        throw new CannotBuildQueryException(druidRel);\n+      }\n+\n+      if (signature == null) {\n+        signature = query.getOutputRowSignature();\n+      }\n+\n+      if (signature.getColumnNames().equals(query.getOutputRowSignature().getColumnNames())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9226a449b9cdafadc583bab883f094bdbe182ed6"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjgwMzU0OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMjo1ODowOVrOHIj_fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMDoxNzoxOFrOHIlYXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MDM1MA==", "bodyText": "nit: would the signatures themselves rather than the count be more useful?", "url": "https://github.com/apache/druid/pull/10324#discussion_r478740350", "createdAt": "2020-08-27T22:58:09Z", "author": {"login": "clintropolis"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.java.util.common.ISE;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      if (!(firstDruidRel instanceof DruidQueryRel)) {\n+        throw new ISE(\"Expected first rel to be a DruidQueryRel, but it was %s\", firstDruidRel.getClass().getName());\n+      }\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              unionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    }\n+  }\n+\n+  private static boolean isUnionCompatible(final DruidRel<?> first, final DruidRel<?> second)\n+  {\n+    final Optional<List<String>> columnNames = getColumnNamesIfTableOrUnion(first);\n+    return columnNames.isPresent() && columnNames.equals(getColumnNamesIfTableOrUnion(second));\n+  }\n+\n+  static Optional<List<String>> getColumnNamesIfTableOrUnion(final DruidRel<?> druidRel)\n+  {\n+    final PartialDruidQuery partialQuery = druidRel.getPartialDruidQuery();\n+\n+    final Optional<DruidTable> druidTable =\n+        DruidRels.druidTableIfLeafRel(druidRel)\n+                 .filter(table -> table.getDataSource() instanceof TableDataSource);\n+\n+    if (druidTable.isPresent() && DruidRels.isScanOrMapping(druidRel, false)) {\n+      // This rel is a table scan or mapping.\n+\n+      if (partialQuery.stage() == PartialDruidQuery.Stage.SCAN) {\n+        return Optional.of(druidTable.get().getRowSignature().getColumnNames());\n+      } else {\n+        // Sanity check. Expected to be true due to the \"scan or mapping\" check.\n+        if (partialQuery.stage() != PartialDruidQuery.Stage.SELECT_PROJECT) {\n+          throw new ISE(\"Expected stage %s but got %s\", PartialDruidQuery.Stage.SELECT_PROJECT, partialQuery.stage());\n+        }\n+\n+        // Apply the mapping (with additional sanity checks).\n+        final RowSignature tableSignature = druidTable.get().getRowSignature();\n+        final Mappings.TargetMapping mapping = partialQuery.getSelectProject().getMapping();\n+\n+        if (mapping.getSourceCount() != tableSignature.size()) {\n+          throw new ISE(\n+              \"Expected mapping with %d columns but got %d columns\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9226a449b9cdafadc583bab883f094bdbe182ed6"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2MzEwMA==", "bodyText": "Perhaps, but so would the entire query, and you gotta stop somewhere.", "url": "https://github.com/apache/druid/pull/10324#discussion_r478763100", "createdAt": "2020-08-28T00:17:18Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.java.util.common.ISE;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }\n+\n+  @Override\n+  public void onMatch(final RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    if (firstDruidRel instanceof DruidUnionDataSourceRel) {\n+      // Unwrap and flatten the inputs to the Union.\n+      final RelNode newUnionRel = call.builder()\n+                                      .pushAll(firstDruidRel.getInputs())\n+                                      .push(secondDruidRel)\n+                                      .union(true, firstDruidRel.getInputs().size() + 1)\n+                                      .build();\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              (Union) newUnionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    } else {\n+      // Sanity check.\n+      if (!(firstDruidRel instanceof DruidQueryRel)) {\n+        throw new ISE(\"Expected first rel to be a DruidQueryRel, but it was %s\", firstDruidRel.getClass().getName());\n+      }\n+\n+      call.transformTo(\n+          DruidUnionDataSourceRel.create(\n+              unionRel,\n+              getColumnNamesIfTableOrUnion(firstDruidRel).get(),\n+              firstDruidRel.getQueryMaker()\n+          )\n+      );\n+    }\n+  }\n+\n+  private static boolean isUnionCompatible(final DruidRel<?> first, final DruidRel<?> second)\n+  {\n+    final Optional<List<String>> columnNames = getColumnNamesIfTableOrUnion(first);\n+    return columnNames.isPresent() && columnNames.equals(getColumnNamesIfTableOrUnion(second));\n+  }\n+\n+  static Optional<List<String>> getColumnNamesIfTableOrUnion(final DruidRel<?> druidRel)\n+  {\n+    final PartialDruidQuery partialQuery = druidRel.getPartialDruidQuery();\n+\n+    final Optional<DruidTable> druidTable =\n+        DruidRels.druidTableIfLeafRel(druidRel)\n+                 .filter(table -> table.getDataSource() instanceof TableDataSource);\n+\n+    if (druidTable.isPresent() && DruidRels.isScanOrMapping(druidRel, false)) {\n+      // This rel is a table scan or mapping.\n+\n+      if (partialQuery.stage() == PartialDruidQuery.Stage.SCAN) {\n+        return Optional.of(druidTable.get().getRowSignature().getColumnNames());\n+      } else {\n+        // Sanity check. Expected to be true due to the \"scan or mapping\" check.\n+        if (partialQuery.stage() != PartialDruidQuery.Stage.SELECT_PROJECT) {\n+          throw new ISE(\"Expected stage %s but got %s\", PartialDruidQuery.Stage.SELECT_PROJECT, partialQuery.stage());\n+        }\n+\n+        // Apply the mapping (with additional sanity checks).\n+        final RowSignature tableSignature = druidTable.get().getRowSignature();\n+        final Mappings.TargetMapping mapping = partialQuery.getSelectProject().getMapping();\n+\n+        if (mapping.getSourceCount() != tableSignature.size()) {\n+          throw new ISE(\n+              \"Expected mapping with %d columns but got %d columns\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0MDM1MA=="}, "originalCommit": {"oid": "9226a449b9cdafadc583bab883f094bdbe182ed6"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5MjgzNDE4OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidRels.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QyMzoxMjoxNFrOHIkRxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQwMDoyMDoxMFrOHIlbKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0NTAzMA==", "bodyText": "nit: I wonder if the instanceof checks here are something that should be pushed into a couple of methods on DruidRel (one to check if is scan/projection one to check if is 'external' (or is there a better word?) scan/projection for join/union)", "url": "https://github.com/apache/druid/pull/10324#discussion_r478745030", "createdAt": "2020-08-27T23:12:14Z", "author": {"login": "clintropolis"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidRels.java", "diffHunk": "@@ -59,12 +59,14 @@ public static boolean isScanOrMapping(final DruidRel<?> druidRel, final boolean\n   /**\n    * Check if a druidRel is a simple table scan or a scan + projection.\n    *\n-   * @param druidRel  the rel to check\n-   * @param canBeJoin consider a 'join' that doesn't do anything fancy to be a scan-or-mapping too.\n+   * @param druidRel         the rel to check\n+   * @param canBeJoinOrUnion consider a {@link DruidJoinQueryRel} or {@link DruidUnionDataSourceRel} as possible\n+   *                         scans-and-mappings too.\n    */\n-  private static boolean isScanOrProject(final DruidRel<?> druidRel, final boolean canBeJoin)\n+  private static boolean isScanOrProject(final DruidRel<?> druidRel, final boolean canBeJoinOrUnion)\n   {\n-    if (druidRel instanceof DruidQueryRel || (canBeJoin && druidRel instanceof DruidJoinQueryRel)) {\n+    if (druidRel instanceof DruidQueryRel || (canBeJoinOrUnion && (druidRel instanceof DruidJoinQueryRel", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9226a449b9cdafadc583bab883f094bdbe182ed6"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc2MzgxNg==", "bodyText": "You might be right. I have a sneaking suspicion that we'll want to redesign the DruidRel interface at some point. I was thinking we could rethink it when we create a native datasource that represents a union of queries, which would allow us to merge the two UNION ALL implementations in SQL, which would allow a single-SQL-query-to-single-native-query mapping. That would simplify a lot of stuff and would be a good catalyst for rethinking the interface.", "url": "https://github.com/apache/druid/pull/10324#discussion_r478763816", "createdAt": "2020-08-28T00:20:10Z", "author": {"login": "gianm"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidRels.java", "diffHunk": "@@ -59,12 +59,14 @@ public static boolean isScanOrMapping(final DruidRel<?> druidRel, final boolean\n   /**\n    * Check if a druidRel is a simple table scan or a scan + projection.\n    *\n-   * @param druidRel  the rel to check\n-   * @param canBeJoin consider a 'join' that doesn't do anything fancy to be a scan-or-mapping too.\n+   * @param druidRel         the rel to check\n+   * @param canBeJoinOrUnion consider a {@link DruidJoinQueryRel} or {@link DruidUnionDataSourceRel} as possible\n+   *                         scans-and-mappings too.\n    */\n-  private static boolean isScanOrProject(final DruidRel<?> druidRel, final boolean canBeJoin)\n+  private static boolean isScanOrProject(final DruidRel<?> druidRel, final boolean canBeJoinOrUnion)\n   {\n-    if (druidRel instanceof DruidQueryRel || (canBeJoin && druidRel instanceof DruidJoinQueryRel)) {\n+    if (druidRel instanceof DruidQueryRel || (canBeJoinOrUnion && (druidRel instanceof DruidJoinQueryRel", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0NTAzMA=="}, "originalCommit": {"oid": "9226a449b9cdafadc583bab883f094bdbe182ed6"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MTc0OTA5OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwNzoxOTowOFrOIYYHnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQwNzoyMDoyMVrOIYYJhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQzMTkwMw==", "bodyText": "Hi, is there a particular reason firstDruidRel is of DruidRel<?> but secondDruidRel is DruidQueryRel?\nHaving it DruidQueryRel creates issues with top level UNION ALL when the second rel contains a subquery.\nOn the same PR, matches(RelOptRuleCall call) in DruidJoinRule.java has both parts typed as DruidRel<?>\nI don't know if it's appropriate to discuss findings in closed PR, but as my issue is completely confined with changes specified here, I took the liberty to discuss them.", "url": "https://github.com/apache/druid/pull/10324#discussion_r562431903", "createdAt": "2021-01-22T07:19:08Z", "author": {"login": "laserscout"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.java.util.common.ISE;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9226a449b9cdafadc583bab883f094bdbe182ed6"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQzMjM5MQ==", "bodyText": "@gianm @clintropolis I would very much value your input here.\nThanks a lot!", "url": "https://github.com/apache/druid/pull/10324#discussion_r562432391", "createdAt": "2021-01-22T07:20:21Z", "author": {"login": "laserscout"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rule/DruidUnionDataSourceRule.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.rule;\n+\n+import org.apache.calcite.plan.RelOptRule;\n+import org.apache.calcite.plan.RelOptRuleCall;\n+import org.apache.calcite.rel.RelNode;\n+import org.apache.calcite.rel.core.Union;\n+import org.apache.calcite.util.mapping.Mappings;\n+import org.apache.druid.java.util.common.ISE;\n+import org.apache.druid.query.TableDataSource;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.rel.DruidQueryRel;\n+import org.apache.druid.sql.calcite.rel.DruidRel;\n+import org.apache.druid.sql.calcite.rel.DruidRels;\n+import org.apache.druid.sql.calcite.rel.DruidUnionDataSourceRel;\n+import org.apache.druid.sql.calcite.rel.PartialDruidQuery;\n+import org.apache.druid.sql.calcite.table.DruidTable;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Creates a {@link DruidUnionDataSourceRel} from various {@link DruidQueryRel} inputs that represent simple\n+ * table scans.\n+ */\n+public class DruidUnionDataSourceRule extends RelOptRule\n+{\n+  private static final DruidUnionDataSourceRule INSTANCE = new DruidUnionDataSourceRule();\n+\n+  private DruidUnionDataSourceRule()\n+  {\n+    super(\n+        operand(\n+            Union.class,\n+            operand(DruidRel.class, none()),\n+            operand(DruidQueryRel.class, none())\n+        )\n+    );\n+  }\n+\n+  public static DruidUnionDataSourceRule instance()\n+  {\n+    return INSTANCE;\n+  }\n+\n+  @Override\n+  public boolean matches(RelOptRuleCall call)\n+  {\n+    final Union unionRel = call.rel(0);\n+    final DruidRel<?> firstDruidRel = call.rel(1);\n+    final DruidQueryRel secondDruidRel = call.rel(2);\n+\n+    // Can only do UNION ALL of inputs that have compatible schemas (or schema mappings).\n+    return unionRel.all && isUnionCompatible(firstDruidRel, secondDruidRel);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQzMTkwMw=="}, "originalCommit": {"oid": "9226a449b9cdafadc583bab883f094bdbe182ed6"}, "originalPosition": 74}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3124, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}