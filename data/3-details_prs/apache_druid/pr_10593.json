{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzMjAzODQx", "number": 10593, "title": "IncrementalIndex Tests and Benchmarks Parametrization", "bodyText": "Fixes #10494.\nDescription\nNote: This PR only affects tests and benchmarks.\nIt would help developers evaluate incremental-index extensions, such as oak-incremental-index (#10001).\n#10335 added a per incremental-index builder, but the parent class builder (IncrementalIndex.Builder) was not removed to avoid 100+ line changes in the test code.\nThis PR removes IncrementalIndex.Builder and refactor all its usage (only in tests the test/benchmarks code).\nIn addition, where needed, a parametrization was added so it will test/benchmark both builder implementations (on-heap and off-heap).\nAdd test cases for each index type\nAll tests that are relevant to the incremental index were modified. The modifications include the parametrization of the tests for all incremental-index implementations: on-heap and off-heap. In addition, this PR includes a bug fix in OffheapIncrementalIndex that was found using these tests.\nTo support this, a new helper class was added: IncrementalIndexCreator.\nThis class handle creating the appropriate index according to its name and closing it at the end of each test.\nAdd benchmark cases for each index type\nAll the benchmarks that are relevant to the incremental index were added an incremental-index parametrization: on-heap or off-heap.\nIn addition, some of these benchmarks were modified to resolve some issues that were encountered.\nWe list here the additional modifications we made to some of the benchmarks.\n\nAdd some additional parametrization:\n\nrollup opportunity for the row generator\nnumber of rows per segment\nquery order: descending/ascending\n\n\nAdd a missing tearDown() procedure\nProperly close the queryable index in the tearDown() procedure\nMoved any temporary folder creation and deletion to the setup()/tearDown() methods so they would not affect the measurements of the results\nUse a predefined seed for reproducible results, to be compliant with most benchmarks\nAdd scopes (@State(Scope.Benchmark)) that allow us to test the incremental index without the overhead of the setup procedure of the queryable index benchmark\n\nOne scope for benchmarking queries on the incremental index\nOne scope for benchmarking queries on the queryable index\n\n\n\nIn addition, to reduce code duplications, a few methods were added to DataGenerator:\n\nvoid addToIndex(IncrementalIndex<?> index, int numOfRows): adds rows from this generator to an existing index\nList<InputRow> toList(int numOfRows): adds rows from this generator to a new list\n\nUser Experience Changes\nAfter this PR, the user should not expect changes in most benchmarks results.\nHowever, some benchmarks behavior will change as follows:\nRuntime\nExpected change: the following benchmarks will run much faster due to eliminating redundancy setup/teardown procedure calls.\nHowever, the benchmarks reported results should not change.\nFilteredAggregatorBenchmark, GroupByBenchmark, ScanBenchmark, SearchBenchmark, TimeseriesBenchmark, TopNBenchmark\nParametrization\nExpected change: the following benchmarks will have additional parametrization options, hence they might take longer to run and produce more results.\n\nindexType parametrization (will also test the off-heap implementation): FilteredAggregatorBenchmark, IncrementalIndexRowTypeBenchmark, IncrementalIndexReadBenchmark, IndexIngestionBenchmark, IndexPersistBenchmark, GroupByBenchmark, ScanBenchmark, SearchBenchmark, TimeseriesBenchmark, TopNBenchmark\ndescending query parametrization: FilteredAggregatorBenchmark, TimeseriesBenchmark\nrollupOpportunity ingestion parametrization: IndexIngestionBenchmark\n\nUnified Benchmarks Behaviour\nExpected change: these changes affect some of the benchmarks' reported results as follows:\n\nA rowsPerSegment parametrization was added to IncrementalIndexRowTypeBenchmark. Before the number of rows was not parametrized and it reported the time per single row insertion. Now it reports the total insertion time of all the rows, like the rest of the tests report.\nScanBenchmark, SearchBenchmark, GroupByBenchmark: now using a fixed seed, so the results are reproducible but might be slightly different than what was before with the random seed.\nIndexPersistBenchmark: this benchmark previously cleaned the temporary data folder inside the tested method, instead of in the teardown procedure. For large index sizes, it affected the benchmark result significantly. With this modification, the results will be different (shorter times), but it will better reflect the \"persist\" performance.\n\n\nThis PR has:\n\n been self-reviewed.\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added or updated version, license, or notice information in licenses.yaml\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths, ensuring the threshold for code coverage is met.\n added integration tests.\n been tested in a test Druid cluster.", "createdAt": "2020-11-18T13:56:44Z", "url": "https://github.com/apache/druid/pull/10593", "merged": true, "mergeCommit": {"oid": "08ab82f55ca856d60dfe1088c1c0393428b0bb6d"}, "closed": true, "closedAt": "2021-01-08T06:18:48Z", "author": {"login": "liran-funaro"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABddumO9ABqjQwMTA4MDU3MTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdor5D7gBqjQxNDA1MTE1NTc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQwNDgzMTY1", "url": "https://github.com/apache/druid/pull/10593#pullrequestreview-540483165", "createdAt": "2020-11-29T14:06:32Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQxNDowNjozM1rOH7jzKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQxNToyODo0NlrOH7kdIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIxNDU3MQ==", "bodyText": "shouldn't this method take a parameter to decide which type of index to return?\nor is this the default builder?\nthen maybe buildDefaultIncIndex and the default should be some hard coded value that can be changed over time", "url": "https://github.com/apache/druid/pull/10593#discussion_r532214571", "createdAt": "2020-11-29T14:06:33Z", "author": {"login": "Eshcar"}, "path": "benchmarks/src/test/java/org/apache/druid/benchmark/FilterPartitionBenchmark.java", "diffHunk": "@@ -227,10 +228,10 @@ public void tearDown() throws IOException\n \n   private IncrementalIndex makeIncIndex()\n   {\n-    return new IncrementalIndex.Builder()\n+    return new OnheapIncrementalIndex.Builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIxNTQ0NA==", "bodyText": "the diff here is very misleading - this line is part of a one line method tearDown that was deleted", "url": "https://github.com/apache/druid/pull/10593#discussion_r532215444", "createdAt": "2020-11-29T14:13:42Z", "author": {"login": "Eshcar"}, "path": "benchmarks/src/test/java/org/apache/druid/benchmark/FilteredAggregatorBenchmark.java", "diffHunk": "@@ -205,30 +184,106 @@ public void setup() throws IOException\n \n     GeneratorSchemaInfo basicSchema = GeneratorBasicSchemas.SCHEMA_MAP.get(\"basic\");\n     QuerySegmentSpec intervalSpec = new MultipleIntervalSegmentSpec(Collections.singletonList(basicSchema.getDataInterval()));\n-    List<AggregatorFactory> queryAggs = new ArrayList<>();\n-    queryAggs.add(filteredMetrics[0]);\n+    List<AggregatorFactory> queryAggs = Collections.singletonList(filteredMetric);\n \n     query = Druids.newTimeseriesQueryBuilder()\n                   .dataSource(\"blah\")\n                   .granularity(Granularities.ALL)\n                   .intervals(intervalSpec)\n                   .aggregators(queryAggs)\n-                  .descending(false)\n+                  .descending(descending)\n                   .build();\n   }\n \n-  @TearDown\n-  public void tearDown() throws IOException\n+  @State(Scope.Benchmark)\n+  public static class IncrementalIndexState\n+  {\n+    @Param({\"onheap\", \"offheap\"})\n+    private String indexType;\n+\n+    IncrementalIndex<?> incIndex;\n+\n+    @Setup\n+    public void setup(FilteredAggregatorBenchmark global) throws JsonProcessingException\n+    {\n+      global.appendableIndexSpec = IncrementalIndexCreator.parseIndexType(indexType);\n+      incIndex = global.makeIncIndex(global.schemaInfo.getAggsArray());\n+      global.generator.addToIndex(incIndex, global.rowsPerSegment);\n+    }\n+\n+    @TearDown\n+    public void tearDown()\n+    {\n+      incIndex.close();\n+    }\n+  }\n+\n+  @State(Scope.Benchmark)\n+  public static class IncrementalIndexIngestState\n   {\n-    FileUtils.deleteDirectory(tmpDir);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIxNTkwMw==", "bodyText": "since now there is a new extension point for incremental index, shouldn't the type be extendable as well?\nuse enum instead of string and names like defaultOnHeap and OakOffHeap so additional on/off-heap implementations can be added in the future", "url": "https://github.com/apache/druid/pull/10593#discussion_r532215903", "createdAt": "2020-11-29T14:17:21Z", "author": {"login": "Eshcar"}, "path": "benchmarks/src/test/java/org/apache/druid/benchmark/FilteredAggregatorBenchmark.java", "diffHunk": "@@ -205,30 +184,106 @@ public void setup() throws IOException\n \n     GeneratorSchemaInfo basicSchema = GeneratorBasicSchemas.SCHEMA_MAP.get(\"basic\");\n     QuerySegmentSpec intervalSpec = new MultipleIntervalSegmentSpec(Collections.singletonList(basicSchema.getDataInterval()));\n-    List<AggregatorFactory> queryAggs = new ArrayList<>();\n-    queryAggs.add(filteredMetrics[0]);\n+    List<AggregatorFactory> queryAggs = Collections.singletonList(filteredMetric);\n \n     query = Druids.newTimeseriesQueryBuilder()\n                   .dataSource(\"blah\")\n                   .granularity(Granularities.ALL)\n                   .intervals(intervalSpec)\n                   .aggregators(queryAggs)\n-                  .descending(false)\n+                  .descending(descending)\n                   .build();\n   }\n \n-  @TearDown\n-  public void tearDown() throws IOException\n+  @State(Scope.Benchmark)\n+  public static class IncrementalIndexState\n+  {\n+    @Param({\"onheap\", \"offheap\"})\n+    private String indexType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIxNjU1Nw==", "bodyText": "no option for qIndex to be null? e.g., if indexFile is empty?", "url": "https://github.com/apache/druid/pull/10593#discussion_r532216557", "createdAt": "2020-11-29T14:21:50Z", "author": {"login": "Eshcar"}, "path": "benchmarks/src/test/java/org/apache/druid/benchmark/FilteredAggregatorBenchmark.java", "diffHunk": "@@ -205,30 +184,106 @@ public void setup() throws IOException\n \n     GeneratorSchemaInfo basicSchema = GeneratorBasicSchemas.SCHEMA_MAP.get(\"basic\");\n     QuerySegmentSpec intervalSpec = new MultipleIntervalSegmentSpec(Collections.singletonList(basicSchema.getDataInterval()));\n-    List<AggregatorFactory> queryAggs = new ArrayList<>();\n-    queryAggs.add(filteredMetrics[0]);\n+    List<AggregatorFactory> queryAggs = Collections.singletonList(filteredMetric);\n \n     query = Druids.newTimeseriesQueryBuilder()\n                   .dataSource(\"blah\")\n                   .granularity(Granularities.ALL)\n                   .intervals(intervalSpec)\n                   .aggregators(queryAggs)\n-                  .descending(false)\n+                  .descending(descending)\n                   .build();\n   }\n \n-  @TearDown\n-  public void tearDown() throws IOException\n+  @State(Scope.Benchmark)\n+  public static class IncrementalIndexState\n+  {\n+    @Param({\"onheap\", \"offheap\"})\n+    private String indexType;\n+\n+    IncrementalIndex<?> incIndex;\n+\n+    @Setup\n+    public void setup(FilteredAggregatorBenchmark global) throws JsonProcessingException\n+    {\n+      global.appendableIndexSpec = IncrementalIndexCreator.parseIndexType(indexType);\n+      incIndex = global.makeIncIndex(global.schemaInfo.getAggsArray());\n+      global.generator.addToIndex(incIndex, global.rowsPerSegment);\n+    }\n+\n+    @TearDown\n+    public void tearDown()\n+    {\n+      incIndex.close();\n+    }\n+  }\n+\n+  @State(Scope.Benchmark)\n+  public static class IncrementalIndexIngestState\n   {\n-    FileUtils.deleteDirectory(tmpDir);\n+    @Param({\"onheap\", \"offheap\"})\n+    private String indexType;\n+\n+    IncrementalIndex<?> incIndex;\n+    List<InputRow> inputRows;\n+\n+    @Setup(Level.Invocation)\n+    public void setup(FilteredAggregatorBenchmark global) throws JsonProcessingException\n+    {\n+      global.appendableIndexSpec = IncrementalIndexCreator.parseIndexType(indexType);\n+      inputRows = global.generator.toList(global.rowsPerSegment);\n+      incIndex = global.makeIncIndex(new AggregatorFactory[]{global.filteredMetric});\n+    }\n+\n+    @TearDown(Level.Invocation)\n+    public void tearDown()\n+    {\n+      incIndex.close();\n+    }\n+  }\n+\n+  @State(Scope.Benchmark)\n+  public static class QueryableIndexState\n+  {\n+    private File qIndexesDir;\n+    private QueryableIndex qIndex;\n+\n+    @Setup\n+    public void setup(FilteredAggregatorBenchmark global) throws IOException\n+    {\n+      global.appendableIndexSpec = new OnheapIncrementalIndex.Spec();\n+\n+      IncrementalIndex<?> incIndex = global.makeIncIndex(global.schemaInfo.getAggsArray());\n+      global.generator.addToIndex(incIndex, global.rowsPerSegment);\n+\n+      qIndexesDir = FileUtils.createTempDir();\n+      log.info(\"Using temp dir: \" + qIndexesDir.getAbsolutePath());\n+\n+      File indexFile = INDEX_MERGER_V9.persist(\n+          incIndex,\n+          qIndexesDir,\n+          new IndexSpec(),\n+          null\n+      );\n+      incIndex.close();\n+\n+      qIndex = INDEX_IO.loadIndex(indexFile);\n+    }\n+\n+    @TearDown\n+    public void tearDown()\n+    {\n+      qIndex.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMDM5MA==", "bodyText": "Does adding all rows into one index equivalent to having 3 indices?", "url": "https://github.com/apache/druid/pull/10593#discussion_r532220390", "createdAt": "2020-11-29T14:52:36Z", "author": {"login": "Eshcar"}, "path": "benchmarks/src/test/java/org/apache/druid/benchmark/IncrementalIndexRowTypeBenchmark.java", "diffHunk": "@@ -124,46 +131,51 @@ private MapBasedInputRow getStringRow(long timestamp, int dimensionCount)\n     return new MapBasedInputRow(timestamp, dimensionList, builder.build());\n   }\n \n-  private IncrementalIndex makeIncIndex()\n+  private IncrementalIndex<?> makeIncIndex()\n   {\n-    return new IncrementalIndex.Builder()\n+    return appendableIndexSpec.builder()\n         .setSimpleTestingIndexSchema(aggs)\n         .setDeserializeComplexMetrics(false)\n-        .setMaxRowCount(MAX_ROWS)\n-        .buildOnheap();\n+        .setMaxRowCount(rowsPerSegment)\n+        .build();\n   }\n \n   @Setup\n-  public void setup()\n+  public void setup() throws JsonProcessingException\n   {\n-    for (int i = 0; i < MAX_ROWS; i++) {\n+    appendableIndexSpec = IncrementalIndexCreator.parseIndexType(indexType);\n+\n+    for (int i = 0; i < rowsPerSegment; i++) {\n       longRows.add(getLongRow(0, DIMENSION_COUNT));\n     }\n \n-    for (int i = 0; i < MAX_ROWS; i++) {\n+    for (int i = 0; i < rowsPerSegment; i++) {\n       floatRows.add(getFloatRow(0, DIMENSION_COUNT));\n     }\n \n-    for (int i = 0; i < MAX_ROWS; i++) {\n+    for (int i = 0; i < rowsPerSegment; i++) {\n       stringRows.add(getStringRow(0, DIMENSION_COUNT));\n     }\n   }\n \n-  @Setup(Level.Iteration)\n+  @Setup(Level.Invocation)\n   public void setup2()\n   {\n     incIndex = makeIncIndex();\n-    incFloatIndex = makeIncIndex();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMTM5Mg==", "bodyText": "worth mentioning that this is where the type of the index is set in the spec, and later used by the factory", "url": "https://github.com/apache/druid/pull/10593#discussion_r532221392", "createdAt": "2020-11-29T15:00:23Z", "author": {"login": "Eshcar"}, "path": "benchmarks/src/test/java/org/apache/druid/benchmark/FilteredAggregatorBenchmark.java", "diffHunk": "@@ -205,30 +184,106 @@ public void setup() throws IOException\n \n     GeneratorSchemaInfo basicSchema = GeneratorBasicSchemas.SCHEMA_MAP.get(\"basic\");\n     QuerySegmentSpec intervalSpec = new MultipleIntervalSegmentSpec(Collections.singletonList(basicSchema.getDataInterval()));\n-    List<AggregatorFactory> queryAggs = new ArrayList<>();\n-    queryAggs.add(filteredMetrics[0]);\n+    List<AggregatorFactory> queryAggs = Collections.singletonList(filteredMetric);\n \n     query = Druids.newTimeseriesQueryBuilder()\n                   .dataSource(\"blah\")\n                   .granularity(Granularities.ALL)\n                   .intervals(intervalSpec)\n                   .aggregators(queryAggs)\n-                  .descending(false)\n+                  .descending(descending)\n                   .build();\n   }\n \n-  @TearDown\n-  public void tearDown() throws IOException\n+  @State(Scope.Benchmark)\n+  public static class IncrementalIndexState\n+  {\n+    @Param({\"onheap\", \"offheap\"})\n+    private String indexType;\n+\n+    IncrementalIndex<?> incIndex;\n+\n+    @Setup\n+    public void setup(FilteredAggregatorBenchmark global) throws JsonProcessingException\n+    {\n+      global.appendableIndexSpec = IncrementalIndexCreator.parseIndexType(indexType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMjM1MA==", "bodyText": "nice handling of the file", "url": "https://github.com/apache/druid/pull/10593#discussion_r532222350", "createdAt": "2020-11-29T15:07:08Z", "author": {"login": "Eshcar"}, "path": "benchmarks/src/test/java/org/apache/druid/benchmark/indexing/IndexPersistBenchmark.java", "diffHunk": "@@ -149,39 +138,44 @@ public void teardown()\n     incIndex = null;\n   }\n \n-  private IncrementalIndex makeIncIndex()\n+  @Setup(Level.Invocation)\n+  public void setupTemp()\n+  {\n+    tmpDir = FileUtils.createTempDir();\n+    log.info(\"Using temp dir: \" + tmpDir.getAbsolutePath());\n+  }\n+\n+  @TearDown(Level.Invocation)\n+  public void teardownTemp() throws IOException\n   {\n-    return new IncrementalIndex.Builder()\n+    FileUtils.deleteDirectory(tmpDir);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMjk2Nw==", "bodyText": "from this point onward a bit hard to follow the reasoning for the changes? what part of the PR description does this relate to?", "url": "https://github.com/apache/druid/pull/10593#discussion_r532222967", "createdAt": "2020-11-29T15:11:50Z", "author": {"login": "Eshcar"}, "path": "benchmarks/src/test/java/org/apache/druid/benchmark/query/GroupByBenchmark.java", "diffHunk": "@@ -428,14 +424,12 @@ private void setupQueries()\n   }\n \n   @Setup(Level.Trial)\n-  public void setup() throws IOException\n+  public void setup()\n   {\n     log.info(\"SETUP CALLED AT \" + +System.currentTimeMillis());\n \n     ComplexMetrics.registerSerde(\"hyperUnique\", new HyperUniquesSerde());\n \n-    executorService = Execs.multiThreaded(numProcessingThreads, \"GroupByThreadPool[%d]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMzc1NA==", "bodyText": "what's the reasoning for these changes? add documentation to explain", "url": "https://github.com/apache/druid/pull/10593#discussion_r532223754", "createdAt": "2020-11-29T15:17:29Z", "author": {"login": "Eshcar"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "diffHunk": "@@ -150,18 +150,13 @@ protected AddToFactsResult addToFacts(\n       boolean skipMaxRowsInMemoryCheck // ignored, we always want to check this for offheap\n   ) throws IndexSizeExceededException\n   {\n-    ByteBuffer aggBuffer;\n-    int bufferIndex;\n-    int bufferOffset;\n-\n     synchronized (this) {\n       final AggregatorFactory[] metrics = getMetrics();\n       final int priorIndex = facts.getPriorIndex(key);\n       if (IncrementalIndexRow.EMPTY_ROW_INDEX != priorIndex) {\n         final int[] indexAndOffset = indexAndOffsets.get(priorIndex);\n-        bufferIndex = indexAndOffset[0];\n-        bufferOffset = indexAndOffset[1];\n-        aggBuffer = aggBuffers.get(bufferIndex).get();\n+        ByteBuffer aggBuffer = aggBuffers.get(indexAndOffset[0]).get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyNDA5OQ==", "bodyText": "from here on forward same 5 lines changes repeat for different tests", "url": "https://github.com/apache/druid/pull/10593#discussion_r532224099", "createdAt": "2020-11-29T15:20:03Z", "author": {"login": "Eshcar"}, "path": "processing/src/test/java/org/apache/druid/query/DoubleStorageTest.java", "diffHunk": "@@ -321,10 +322,10 @@ private static QueryableIndex buildIndex(String storeDoubleAsFloat) throws IOExc\n         )\n         .build();\n \n-    final IncrementalIndex index = new IncrementalIndex.Builder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyNDgzNA==", "bodyText": "all changes from here are due to the generic type?", "url": "https://github.com/apache/druid/pull/10593#discussion_r532224834", "createdAt": "2020-11-29T15:25:05Z", "author": {"login": "Eshcar"}, "path": "processing/src/test/java/org/apache/druid/segment/data/IncrementalIndexTest.java", "diffHunk": "@@ -268,7 +217,7 @@ private static MapBasedInputRow getLongRow(long timestamp, int dimensionCount)\n   public void testCaseSensitivity() throws Exception\n   {\n     long timestamp = System.currentTimeMillis();\n-    IncrementalIndex index = closerRule.closeLater(indexCreator.createIndex(DEFAULT_AGGREGATOR_FACTORIES));\n+    IncrementalIndex<?> index = indexCreator.createIndex((Object) DEFAULT_AGGREGATOR_FACTORIES);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyNTMxNA==", "bodyText": "add  a more general documentation of the role of this class for the time it is supported", "url": "https://github.com/apache/druid/pull/10593#discussion_r532225314", "createdAt": "2020-11-29T15:28:46Z", "author": {"login": "Eshcar"}, "path": "processing/src/test/java/org/apache/druid/segment/incremental/OffheapIncrementalIndexTestSpec.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.incremental;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Supplier;\n+import org.apache.druid.collections.CloseableStupidPool;\n+import org.apache.druid.utils.JvmUtils;\n+\n+import javax.annotation.Nullable;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Since the off-heap incremental index is not yet supported in production ingestion, we define its spec here only", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "559a9e8afcb3bf1ac42533c9c57b12d99f913eec", "author": {"user": {"login": "liran-funaro", "name": "Liran Funaro"}}, "url": "https://github.com/apache/druid/commit/559a9e8afcb3bf1ac42533c9c57b12d99f913eec", "committedDate": "2020-11-30T10:46:29Z", "message": "Fix forbiddenapis error: Forbidden method invocation: java.lang.String#format(java.lang.String,java.lang.Object[]) [Uses default locale]"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ1NjgxMzQ4", "url": "https://github.com/apache/druid/pull/10593#pullrequestreview-545681348", "createdAt": "2020-12-06T08:16:08Z", "commit": {"oid": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwODoxNjowOFrOIAG-6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQwODoxNjowOFrOIAG-6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjk4NTMyMQ==", "bodyText": "Thanks for addressing the questions and issues\nLGTM", "url": "https://github.com/apache/druid/pull/10593#discussion_r536985321", "createdAt": "2020-12-06T08:16:08Z", "author": {"login": "Eshcar"}, "path": "processing/src/test/java/org/apache/druid/segment/data/IncrementalIndexTest.java", "diffHunk": "@@ -268,7 +217,7 @@ private static MapBasedInputRow getLongRow(long timestamp, int dimensionCount)\n   public void testCaseSensitivity() throws Exception\n   {\n     long timestamp = System.currentTimeMillis();\n-    IncrementalIndex index = closerRule.closeLater(indexCreator.createIndex(DEFAULT_AGGREGATOR_FACTORIES));\n+    IncrementalIndex<?> index = indexCreator.createIndex((Object) DEFAULT_AGGREGATOR_FACTORIES);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyNDgzNA=="}, "originalCommit": null, "originalPosition": 141}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NTQ1MTg1", "url": "https://github.com/apache/druid/pull/10593#pullrequestreview-548545185", "createdAt": "2020-12-09T19:40:55Z", "commit": {"oid": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTo0MDo1NVrOICmK4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMzoyMDozM1rOICuABw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5MzQ0Mg==", "bodyText": "Typo: form -> from", "url": "https://github.com/apache/druid/pull/10593#discussion_r539593442", "createdAt": "2020-12-09T19:40:55Z", "author": {"login": "a2l007"}, "path": "processing/src/main/java/org/apache/druid/segment/generator/DataGenerator.java", "diffHunk": "@@ -143,4 +151,54 @@ private long nextTimestamp()\n     }\n   }\n \n+  /**\n+   * Initialize a Java Stream generator for InputRow from this DataGenerator.\n+   *\n+   * @param numOfRows the number of rows to generate\n+   * @return a generator\n+   */\n+  private Stream<InputRow> generator(int numOfRows)\n+  {\n+    return Stream.generate(this::nextRow).limit(numOfRows);\n+  }\n+\n+  /**\n+   * Add rows form any generator to an index.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYyMTc5MA==", "bodyText": "Can we use StringUtils.format here instead?", "url": "https://github.com/apache/druid/pull/10593#discussion_r539621790", "createdAt": "2020-12-09T20:26:14Z", "author": {"login": "a2l007"}, "path": "processing/src/test/java/org/apache/druid/segment/incremental/IncrementalIndexCreator.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.incremental;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClassResolver;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import org.apache.druid.jackson.DefaultObjectMapper;\n+import org.apache.druid.java.util.common.io.Closer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * An incremental-index creator for parameterized incremental-index tests.\n+ * It lists all the available incremental-index implementations, and responsible to create and close incremental-index\n+ * instances during the tests.\n+ */\n+public class IncrementalIndexCreator implements Closeable\n+{\n+  public static final ObjectMapper JSON_MAPPER = new DefaultObjectMapper();\n+\n+  /**\n+   * Allows adding support for testing unregistered indexes.\n+   * It is used by Druid's extensions for the incremental-index.\n+   *\n+   * @param c    an index spec class\n+   * @param name an index spec name\n+   */\n+  public static void addIndexSpec(Class<?> c, String name)\n+  {\n+    JSON_MAPPER.registerSubtypes(new NamedType(c, name));\n+  }\n+\n+  static {\n+    // The off-heap incremental-index is not registered for production, but we want to include it in the tests.\n+    IncrementalIndexCreator.addIndexSpec(OffheapIncrementalIndexTestSpec.class, OffheapIncrementalIndexTestSpec.TYPE);\n+  }\n+\n+  /**\n+   * Fetch all the available incremental-index implementations.\n+   * It can be used to parametrize the test. If more parameters are needed, use indexTypeCartesianProduct().\n+   * @see #indexTypeCartesianProduct(Collection[]).\n+   *\n+   * @return a list of all the incremental-index implementations types (String)\n+   */\n+  public static List<String> getAppendableIndexTypes()\n+  {\n+    SubtypeResolver resolver = JSON_MAPPER.getSubtypeResolver();\n+    MapperConfig<?> config = JSON_MAPPER.getDeserializationConfig();\n+    AnnotatedClass cls = AnnotatedClassResolver.resolveWithoutSuperTypes(config, AppendableIndexSpec.class);\n+    Collection<NamedType> types = resolver.collectAndResolveSubtypesByClass(config, cls);\n+    return types.stream().map(NamedType::getName).filter(Objects::nonNull).distinct().collect(Collectors.toList());\n+  }\n+\n+  public interface IndexCreator\n+  {\n+    /**\n+     * Build an index given a builder and args.\n+     *\n+     * @param builder an incremental index builder supplied by the framework\n+     * @param args a list of arguments that are used to configure the builder\n+     * @return a new instance of an incremental-index\n+     */\n+    IncrementalIndex<?> createIndex(AppendableIndexBuilder builder, Object... args);\n+  }\n+\n+  private final Closer closer = Closer.create();\n+\n+  private final AppendableIndexSpec appendableIndexSpec;\n+\n+  private final IndexCreator indexCreator;\n+\n+  /**\n+   * Initialize the creator.\n+   *\n+   * @param spec a spec that can generate a incremental-index builder\n+   * @param indexCreator a function that generate an index given a builder and arguments\n+   */\n+  public IncrementalIndexCreator(AppendableIndexSpec spec, IndexCreator indexCreator)\n+  {\n+    this.appendableIndexSpec = spec;\n+    this.indexCreator = indexCreator;\n+  }\n+\n+  /**\n+   * Initialize the creator.\n+   *\n+   * @param indexType an index type (name)\n+   * @param indexCreator a function that generate an index given a builder and arguments\n+   */\n+  public IncrementalIndexCreator(String indexType, IndexCreator indexCreator) throws JsonProcessingException\n+  {\n+    this(parseIndexType(indexType), indexCreator);\n+  }\n+\n+  /**\n+   * Generate an AppendableIndexSpec from index type.\n+   *\n+   * @param indexType an index type\n+   * @return AppendableIndexSpec instance of this type\n+   * @throws JsonProcessingException if failed to to parse the index\n+   */\n+  public static AppendableIndexSpec parseIndexType(String indexType) throws JsonProcessingException\n+  {\n+    return JSON_MAPPER.readValue(\n+        String.format(Locale.ENGLISH, \"{\\\"type\\\": \\\"%s\\\"}\", indexType),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2MDM3Ng==", "bodyText": "This method is convenient but it would be useful to add more detail on how it can be used.", "url": "https://github.com/apache/druid/pull/10593#discussion_r539660376", "createdAt": "2020-12-09T21:27:14Z", "author": {"login": "a2l007"}, "path": "processing/src/test/java/org/apache/druid/segment/incremental/IncrementalIndexCreator.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.incremental;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClassResolver;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import org.apache.druid.jackson.DefaultObjectMapper;\n+import org.apache.druid.java.util.common.io.Closer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * An incremental-index creator for parameterized incremental-index tests.\n+ * It lists all the available incremental-index implementations, and responsible to create and close incremental-index\n+ * instances during the tests.\n+ */\n+public class IncrementalIndexCreator implements Closeable\n+{\n+  public static final ObjectMapper JSON_MAPPER = new DefaultObjectMapper();\n+\n+  /**\n+   * Allows adding support for testing unregistered indexes.\n+   * It is used by Druid's extensions for the incremental-index.\n+   *\n+   * @param c    an index spec class\n+   * @param name an index spec name\n+   */\n+  public static void addIndexSpec(Class<?> c, String name)\n+  {\n+    JSON_MAPPER.registerSubtypes(new NamedType(c, name));\n+  }\n+\n+  static {\n+    // The off-heap incremental-index is not registered for production, but we want to include it in the tests.\n+    IncrementalIndexCreator.addIndexSpec(OffheapIncrementalIndexTestSpec.class, OffheapIncrementalIndexTestSpec.TYPE);\n+  }\n+\n+  /**\n+   * Fetch all the available incremental-index implementations.\n+   * It can be used to parametrize the test. If more parameters are needed, use indexTypeCartesianProduct().\n+   * @see #indexTypeCartesianProduct(Collection[]).\n+   *\n+   * @return a list of all the incremental-index implementations types (String)\n+   */\n+  public static List<String> getAppendableIndexTypes()\n+  {\n+    SubtypeResolver resolver = JSON_MAPPER.getSubtypeResolver();\n+    MapperConfig<?> config = JSON_MAPPER.getDeserializationConfig();\n+    AnnotatedClass cls = AnnotatedClassResolver.resolveWithoutSuperTypes(config, AppendableIndexSpec.class);\n+    Collection<NamedType> types = resolver.collectAndResolveSubtypesByClass(config, cls);\n+    return types.stream().map(NamedType::getName).filter(Objects::nonNull).distinct().collect(Collectors.toList());\n+  }\n+\n+  public interface IndexCreator\n+  {\n+    /**\n+     * Build an index given a builder and args.\n+     *\n+     * @param builder an incremental index builder supplied by the framework\n+     * @param args a list of arguments that are used to configure the builder\n+     * @return a new instance of an incremental-index\n+     */\n+    IncrementalIndex<?> createIndex(AppendableIndexBuilder builder, Object... args);\n+  }\n+\n+  private final Closer closer = Closer.create();\n+\n+  private final AppendableIndexSpec appendableIndexSpec;\n+\n+  private final IndexCreator indexCreator;\n+\n+  /**\n+   * Initialize the creator.\n+   *\n+   * @param spec a spec that can generate a incremental-index builder\n+   * @param indexCreator a function that generate an index given a builder and arguments\n+   */\n+  public IncrementalIndexCreator(AppendableIndexSpec spec, IndexCreator indexCreator)\n+  {\n+    this.appendableIndexSpec = spec;\n+    this.indexCreator = indexCreator;\n+  }\n+\n+  /**\n+   * Initialize the creator.\n+   *\n+   * @param indexType an index type (name)\n+   * @param indexCreator a function that generate an index given a builder and arguments\n+   */\n+  public IncrementalIndexCreator(String indexType, IndexCreator indexCreator) throws JsonProcessingException\n+  {\n+    this(parseIndexType(indexType), indexCreator);\n+  }\n+\n+  /**\n+   * Generate an AppendableIndexSpec from index type.\n+   *\n+   * @param indexType an index type\n+   * @return AppendableIndexSpec instance of this type\n+   * @throws JsonProcessingException if failed to to parse the index\n+   */\n+  public static AppendableIndexSpec parseIndexType(String indexType) throws JsonProcessingException\n+  {\n+    return JSON_MAPPER.readValue(\n+        String.format(Locale.ENGLISH, \"{\\\"type\\\": \\\"%s\\\"}\", indexType),\n+        AppendableIndexSpec.class\n+    );\n+  }\n+\n+  /**\n+   * Create an index given the input args.\n+   *\n+   * @param args The arguments for the index-generator\n+   * @return An incremental-index instance\n+   */\n+  public final IncrementalIndex<?> createIndex(Object... args)\n+  {\n+    return createIndex(indexCreator, args);\n+  }\n+\n+  /**\n+   * Create an index given the input args with a specialized index-creator.\n+   *\n+   * @param args The arguments for the index-generator\n+   * @return An incremental-index instance\n+   */\n+  public final IncrementalIndex<?> createIndex(IndexCreator indexCreator, Object... args)\n+  {\n+    return closer.register(indexCreator.createIndex(appendableIndexSpec.builder(), args));\n+  }\n+\n+  @Override\n+  public void close() throws IOException\n+  {\n+    closer.close();\n+\n+    if (appendableIndexSpec instanceof Closeable) {\n+      ((Closeable) appendableIndexSpec).close();\n+    }\n+  }\n+\n+  /**\n+   * Used to parameterize the tests with all the permutations of the parameters\n+   * together with all the incremental index implementations.\n+   *\n+   * @param c a list of collections of parameters\n+   * @return the cartesian product of all parameters\n+   */\n+  public static List<Object[]> indexTypeCartesianProduct(Collection<?>... c)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2MzE0OA==", "bodyText": "In addition to saying parameterized incremental-index tests, could you please add more info in the javadoc specifying what are the configurable parameters?", "url": "https://github.com/apache/druid/pull/10593#discussion_r539663148", "createdAt": "2020-12-09T21:31:47Z", "author": {"login": "a2l007"}, "path": "processing/src/test/java/org/apache/druid/segment/incremental/IncrementalIndexCreator.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.incremental;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClassResolver;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import org.apache.druid.jackson.DefaultObjectMapper;\n+import org.apache.druid.java.util.common.io.Closer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * An incremental-index creator for parameterized incremental-index tests.\n+ * It lists all the available incremental-index implementations, and responsible to create and close incremental-index\n+ * instances during the tests.\n+ */\n+public class IncrementalIndexCreator implements Closeable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2NDg2NA==", "bodyText": "Does this method need public visibility?", "url": "https://github.com/apache/druid/pull/10593#discussion_r539664864", "createdAt": "2020-12-09T21:34:34Z", "author": {"login": "a2l007"}, "path": "processing/src/test/java/org/apache/druid/segment/incremental/IncrementalIndexCreator.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.segment.incremental;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.cfg.MapperConfig;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClass;\n+import com.fasterxml.jackson.databind.introspect.AnnotatedClassResolver;\n+import com.fasterxml.jackson.databind.jsontype.NamedType;\n+import com.fasterxml.jackson.databind.jsontype.SubtypeResolver;\n+import org.apache.druid.jackson.DefaultObjectMapper;\n+import org.apache.druid.java.util.common.io.Closer;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * An incremental-index creator for parameterized incremental-index tests.\n+ * It lists all the available incremental-index implementations, and responsible to create and close incremental-index\n+ * instances during the tests.\n+ */\n+public class IncrementalIndexCreator implements Closeable\n+{\n+  public static final ObjectMapper JSON_MAPPER = new DefaultObjectMapper();\n+\n+  /**\n+   * Allows adding support for testing unregistered indexes.\n+   * It is used by Druid's extensions for the incremental-index.\n+   *\n+   * @param c    an index spec class\n+   * @param name an index spec name\n+   */\n+  public static void addIndexSpec(Class<?> c, String name)\n+  {\n+    JSON_MAPPER.registerSubtypes(new NamedType(c, name));\n+  }\n+\n+  static {\n+    // The off-heap incremental-index is not registered for production, but we want to include it in the tests.\n+    IncrementalIndexCreator.addIndexSpec(OffheapIncrementalIndexTestSpec.class, OffheapIncrementalIndexTestSpec.TYPE);\n+  }\n+\n+  /**\n+   * Fetch all the available incremental-index implementations.\n+   * It can be used to parametrize the test. If more parameters are needed, use indexTypeCartesianProduct().\n+   * @see #indexTypeCartesianProduct(Collection[]).\n+   *\n+   * @return a list of all the incremental-index implementations types (String)\n+   */\n+  public static List<String> getAppendableIndexTypes()\n+  {\n+    SubtypeResolver resolver = JSON_MAPPER.getSubtypeResolver();\n+    MapperConfig<?> config = JSON_MAPPER.getDeserializationConfig();\n+    AnnotatedClass cls = AnnotatedClassResolver.resolveWithoutSuperTypes(config, AppendableIndexSpec.class);\n+    Collection<NamedType> types = resolver.collectAndResolveSubtypesByClass(config, cls);\n+    return types.stream().map(NamedType::getName).filter(Objects::nonNull).distinct().collect(Collectors.toList());\n+  }\n+\n+  public interface IndexCreator\n+  {\n+    /**\n+     * Build an index given a builder and args.\n+     *\n+     * @param builder an incremental index builder supplied by the framework\n+     * @param args a list of arguments that are used to configure the builder\n+     * @return a new instance of an incremental-index\n+     */\n+    IncrementalIndex<?> createIndex(AppendableIndexBuilder builder, Object... args);\n+  }\n+\n+  private final Closer closer = Closer.create();\n+\n+  private final AppendableIndexSpec appendableIndexSpec;\n+\n+  private final IndexCreator indexCreator;\n+\n+  /**\n+   * Initialize the creator.\n+   *\n+   * @param spec a spec that can generate a incremental-index builder\n+   * @param indexCreator a function that generate an index given a builder and arguments\n+   */\n+  public IncrementalIndexCreator(AppendableIndexSpec spec, IndexCreator indexCreator)\n+  {\n+    this.appendableIndexSpec = spec;\n+    this.indexCreator = indexCreator;\n+  }\n+\n+  /**\n+   * Initialize the creator.\n+   *\n+   * @param indexType an index type (name)\n+   * @param indexCreator a function that generate an index given a builder and arguments\n+   */\n+  public IncrementalIndexCreator(String indexType, IndexCreator indexCreator) throws JsonProcessingException\n+  {\n+    this(parseIndexType(indexType), indexCreator);\n+  }\n+\n+  /**\n+   * Generate an AppendableIndexSpec from index type.\n+   *\n+   * @param indexType an index type\n+   * @return AppendableIndexSpec instance of this type\n+   * @throws JsonProcessingException if failed to to parse the index\n+   */\n+  public static AppendableIndexSpec parseIndexType(String indexType) throws JsonProcessingException\n+  {\n+    return JSON_MAPPER.readValue(\n+        String.format(Locale.ENGLISH, \"{\\\"type\\\": \\\"%s\\\"}\", indexType),\n+        AppendableIndexSpec.class\n+    );\n+  }\n+\n+  /**\n+   * Create an index given the input args.\n+   *\n+   * @param args The arguments for the index-generator\n+   * @return An incremental-index instance\n+   */\n+  public final IncrementalIndex<?> createIndex(Object... args)\n+  {\n+    return createIndex(indexCreator, args);\n+  }\n+\n+  /**\n+   * Create an index given the input args with a specialized index-creator.\n+   *\n+   * @param args The arguments for the index-generator\n+   * @return An incremental-index instance\n+   */\n+  public final IncrementalIndex<?> createIndex(IndexCreator indexCreator, Object... args)\n+  {\n+    return closer.register(indexCreator.createIndex(appendableIndexSpec.builder(), args));\n+  }\n+\n+  @Override\n+  public void close() throws IOException\n+  {\n+    closer.close();\n+\n+    if (appendableIndexSpec instanceof Closeable) {\n+      ((Closeable) appendableIndexSpec).close();\n+    }\n+  }\n+\n+  /**\n+   * Used to parameterize the tests with all the permutations of the parameters\n+   * together with all the incremental index implementations.\n+   *\n+   * @param c a list of collections of parameters\n+   * @return the cartesian product of all parameters\n+   */\n+  public static List<Object[]> indexTypeCartesianProduct(Collection<?>... c)\n+  {\n+    Collection<?>[] args = new Collection<?>[c.length + 1];\n+    args[0] = getAppendableIndexTypes();\n+    System.arraycopy(c, 0, args, 1, c.length);\n+    return cartesianProduct(args);\n+  }\n+\n+  /**\n+   * Generates all the permutations of the parameters.\n+   *\n+   * @param c a list of collections of parameters\n+   * @return the cartesian product of all parameters\n+   */\n+  public static List<Object[]> cartesianProduct(Collection<?>... c)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcwNDAwOA==", "bodyText": "Hmm I feel that this fix to OffheapIncrementalIndex can be independent in its own separate issue and PR since it is a bug and would make it easier for tracking in the future.", "url": "https://github.com/apache/druid/pull/10593#discussion_r539704008", "createdAt": "2020-12-09T22:43:35Z", "author": {"login": "a2l007"}, "path": "processing/src/main/java/org/apache/druid/segment/incremental/OffheapIncrementalIndex.java", "diffHunk": "@@ -150,18 +150,13 @@ protected AddToFactsResult addToFacts(\n       boolean skipMaxRowsInMemoryCheck // ignored, we always want to check this for offheap\n   ) throws IndexSizeExceededException\n   {\n-    ByteBuffer aggBuffer;\n-    int bufferIndex;\n-    int bufferOffset;\n-\n     synchronized (this) {\n       final AggregatorFactory[] metrics = getMetrics();\n       final int priorIndex = facts.getPriorIndex(key);\n       if (IncrementalIndexRow.EMPTY_ROW_INDEX != priorIndex) {\n         final int[] indexAndOffset = indexAndOffsets.get(priorIndex);\n-        bufferIndex = indexAndOffset[0];\n-        bufferOffset = indexAndOffset[1];\n-        aggBuffer = aggBuffers.get(bufferIndex).get();\n+        ByteBuffer aggBuffer = aggBuffers.get(indexAndOffset[0]).get();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjIyMzc1NA=="}, "originalCommit": null, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyMDMzNw==", "bodyText": "I see there are other usages of gen.nextRow() that haven't been replaced. Is the plan to replace them in an follow up PR?", "url": "https://github.com/apache/druid/pull/10593#discussion_r539720337", "createdAt": "2020-12-09T23:17:24Z", "author": {"login": "a2l007"}, "path": "benchmarks/src/test/java/org/apache/druid/benchmark/indexing/IncrementalIndexReadBenchmark.java", "diffHunk": "@@ -110,28 +119,28 @@ public void setup() throws IOException\n     );\n \n     incIndex = makeIncIndex();\n+    gen.addToIndex(incIndex, rowsPerSegment);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyMTczNQ==", "bodyText": "This logging is generally useful as it helps track the status of the benchmark run. Could this be incorporated as part of addToIndex?\nThis comment applies to the same change for the remaining places as well.", "url": "https://github.com/apache/druid/pull/10593#discussion_r539721735", "createdAt": "2020-12-09T23:20:33Z", "author": {"login": "a2l007"}, "path": "benchmarks/src/test/java/org/apache/druid/benchmark/indexing/IncrementalIndexReadBenchmark.java", "diffHunk": "@@ -110,28 +119,28 @@ public void setup() throws IOException\n     );\n \n     incIndex = makeIncIndex();\n+    gen.addToIndex(incIndex, rowsPerSegment);\n+  }\n \n-    for (int j = 0; j < rowsPerSegment; j++) {\n-      InputRow row = gen.nextRow();\n-      if (j % 10000 == 0) {\n-        log.info(j + \" rows generated.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a"}, "originalPosition": 68}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUyODE2NTUw", "url": "https://github.com/apache/druid/pull/10593#pullrequestreview-552816550", "createdAt": "2020-12-15T19:53:17Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxOTo1MzoxN1rOIGdTnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQyMDo0MDoyNFrOIGfCRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY0MjUyNA==", "bodyText": "Changing it in a follow-up PR sounds good to me.", "url": "https://github.com/apache/druid/pull/10593#discussion_r543642524", "createdAt": "2020-12-15T19:53:17Z", "author": {"login": "a2l007"}, "path": "benchmarks/src/test/java/org/apache/druid/benchmark/indexing/IncrementalIndexReadBenchmark.java", "diffHunk": "@@ -110,28 +119,28 @@ public void setup() throws IOException\n     );\n \n     incIndex = makeIncIndex();\n+    gen.addToIndex(incIndex, rowsPerSegment);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTcyMDMzNw=="}, "originalCommit": {"oid": "1f06fb2b4a8e719eff60a0a45257ff571fe1b32a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY3MDg1NA==", "bodyText": "Sorry I missed this earlier, but I feel that we should retain the textual values for rollupOpportunity as that is more user-friendly when reading the benchmark results.", "url": "https://github.com/apache/druid/pull/10593#discussion_r543670854", "createdAt": "2020-12-15T20:40:24Z", "author": {"login": "a2l007"}, "path": "benchmarks/src/test/java/org/apache/druid/benchmark/indexing/IndexPersistBenchmark.java", "diffHunk": "@@ -87,101 +90,95 @@\n   @Param({\"true\", \"false\"})\n   private boolean rollup;\n \n-  @Param({\"none\", \"moderate\", \"high\"})\n-  private String rollupOpportunity;\n+  @Param({\"0\", \"1000\", \"10000\"})\n+  private int rollupOpportunity;", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTUzOTIzMjU5", "url": "https://github.com/apache/druid/pull/10593#pullrequestreview-553923259", "createdAt": "2020-12-16T17:32:10Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1df4fecc62eb104bd19f1e21fbc970a6604ec63c", "author": {"user": {"login": "liran-funaro", "name": "Liran Funaro"}}, "url": "https://github.com/apache/druid/commit/1df4fecc62eb104bd19f1e21fbc970a6604ec63c", "committedDate": "2020-12-22T10:37:20Z", "message": "Remove redundant IncrementalIndex.Builder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4e0be979d48c14c51a952f3237e5daab8d98212", "author": {"user": {"login": "liran-funaro", "name": "Liran Funaro"}}, "url": "https://github.com/apache/druid/commit/f4e0be979d48c14c51a952f3237e5daab8d98212", "committedDate": "2020-12-22T10:37:21Z", "message": "Parametrize incremental index tests and benchmarks\n\n- Reveal and fix a bug in OffheapIncrementalIndex"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33a613f71befc23770d212b47a532c472c5055a2", "author": {"user": {"login": "liran-funaro", "name": "Liran Funaro"}}, "url": "https://github.com/apache/druid/commit/33a613f71befc23770d212b47a532c472c5055a2", "committedDate": "2020-12-22T10:37:21Z", "message": "Fix forbiddenapis error: Forbidden method invocation: java.lang.String#format(java.lang.String,java.lang.Object[]) [Uses default locale]"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d9369442d2310b4640ff5ff226e5608b1bc62d2", "author": {"user": {"login": "liran-funaro", "name": "Liran Funaro"}}, "url": "https://github.com/apache/druid/commit/0d9369442d2310b4640ff5ff226e5608b1bc62d2", "committedDate": "2020-12-22T10:37:22Z", "message": "Fix Intellij errors: declared exception is never thrown"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07a64123dc722e4e5b3050a02d2776266ec75c5f", "author": {"user": {"login": "liran-funaro", "name": "Liran Funaro"}}, "url": "https://github.com/apache/druid/commit/07a64123dc722e4e5b3050a02d2776266ec75c5f", "committedDate": "2020-12-22T10:37:22Z", "message": "Add documentation and validate before closing objects on tearDown."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ead19a14af7835b0a9a3153134afe27a75cd7fa", "author": {"user": {"login": "liran-funaro", "name": "Liran Funaro"}}, "url": "https://github.com/apache/druid/commit/1ead19a14af7835b0a9a3153134afe27a75cd7fa", "committedDate": "2020-12-22T10:37:22Z", "message": "Add documentation to OffheapIncrementalIndexTestSpec"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ffdf56a680f8a6a805b440fd75b9cb97d05b9d6", "author": {"user": {"login": "liran-funaro", "name": "Liran Funaro"}}, "url": "https://github.com/apache/druid/commit/1ffdf56a680f8a6a805b440fd75b9cb97d05b9d6", "committedDate": "2020-12-22T10:37:23Z", "message": "Doc corrections and minor changes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4ebea5236b9ca700eae84086b776af32bbeeafa", "author": {"user": {"login": "liran-funaro", "name": "Liran Funaro"}}, "url": "https://github.com/apache/druid/commit/a4ebea5236b9ca700eae84086b776af32bbeeafa", "committedDate": "2020-12-22T10:37:23Z", "message": "Add logging for generated rows."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43461f9a876880325220d1f39ebfedbc6bef9960", "author": {"user": {"login": "liran-funaro", "name": "Liran Funaro"}}, "url": "https://github.com/apache/druid/commit/43461f9a876880325220d1f39ebfedbc6bef9960", "committedDate": "2020-12-22T10:37:23Z", "message": "Refactor new tests/benchmarks."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc9037972b37621b3788e174b12fd55fe47b492c", "author": {"user": {"login": "liran-funaro", "name": "Liran Funaro"}}, "url": "https://github.com/apache/druid/commit/fc9037972b37621b3788e174b12fd55fe47b492c", "committedDate": "2020-12-22T10:37:24Z", "message": "Improve IncrementalIndexCreator documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "781871798bed88416d20d8897d635c48deb6136b", "author": {"user": {"login": "liran-funaro", "name": "Liran Funaro"}}, "url": "https://github.com/apache/druid/commit/781871798bed88416d20d8897d635c48deb6136b", "committedDate": "2020-12-22T10:37:24Z", "message": "Add required tests for DataGenerator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7527dde6471aab28b1a5ffd187b747db898b1d18", "author": {"user": {"login": "liran-funaro", "name": "Liran Funaro"}}, "url": "https://github.com/apache/druid/commit/7527dde6471aab28b1a5ffd187b747db898b1d18", "committedDate": "2020-12-22T10:37:24Z", "message": "Revert \"rollupOpportunity\" to be a string"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "7527dde6471aab28b1a5ffd187b747db898b1d18", "author": {"user": {"login": "liran-funaro", "name": "Liran Funaro"}}, "url": "https://github.com/apache/druid/commit/7527dde6471aab28b1a5ffd187b747db898b1d18", "committedDate": "2020-12-22T10:37:24Z", "message": "Revert \"rollupOpportunity\" to be a string"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3086, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}