{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2ODgzODI5", "number": 10056, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMzo1NTozOFrOEHxBJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwMjozNjozN1rOEKuU_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTc4NTk4OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/segment/join/Joinables.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMzo1NTozOFrOGnUrCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMjozODowN1rOGqpfgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg4NjM0NA==", "bodyText": "The code coverage checker is flagging this change as uncovered (by the druid-processing unit tests):\nhttps://travis-ci.org/github/apache/druid/jobs/699956397#L1415\nNote: The new CalciteQueryTest added in this PR to druid-sql does hit this code path.", "url": "https://github.com/apache/druid/pull/10056#discussion_r443886344", "createdAt": "2020-06-22T23:55:38Z", "author": {"login": "ccaominh"}, "path": "processing/src/main/java/org/apache/druid/segment/join/Joinables.java", "diffHunk": "@@ -107,8 +107,17 @@ public static boolean isPrefixedBy(final String columnName, final String prefix)\n             );\n \n             for (Query joinQuery : joinQueryLevels) {\n+              // The pre-analysis needs to apply to the optimized form of filters, as this is what will be\n+              // passed to HashJoinSegmentAdapter.makeCursors().\n+              // The optimize() call here means that the filter optimization will happen twice,\n+              // since the query toolchests will call optimize() later.\n+              // We do this for simplicity as we cannot override what query will get run later from this context.\n+              // A more complicated approach involving wrapping the query runner after the pre-merge decoration\n+              // and moving the pre-analysis might be viable.\n+              // The additional overhead of the simple approach should be low, as the additional optimize() call\n+              // on each filter will only occur once per query.\n               preAnalysisGroup.computeJoinFilterPreAnalysisIfAbsent(\n-                  joinQuery.getFilter() == null ? null : joinQuery.getFilter().toFilter(),\n+                  joinQuery.getFilter() == null ? null : joinQuery.getFilter().optimize().toFilter(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg5MzMzMQ==", "bodyText": "I'll look into moving the test into processing", "url": "https://github.com/apache/druid/pull/10056#discussion_r443893331", "createdAt": "2020-06-23T00:20:55Z", "author": {"login": "jon-wei"}, "path": "processing/src/main/java/org/apache/druid/segment/join/Joinables.java", "diffHunk": "@@ -107,8 +107,17 @@ public static boolean isPrefixedBy(final String columnName, final String prefix)\n             );\n \n             for (Query joinQuery : joinQueryLevels) {\n+              // The pre-analysis needs to apply to the optimized form of filters, as this is what will be\n+              // passed to HashJoinSegmentAdapter.makeCursors().\n+              // The optimize() call here means that the filter optimization will happen twice,\n+              // since the query toolchests will call optimize() later.\n+              // We do this for simplicity as we cannot override what query will get run later from this context.\n+              // A more complicated approach involving wrapping the query runner after the pre-merge decoration\n+              // and moving the pre-analysis might be viable.\n+              // The additional overhead of the simple approach should be low, as the additional optimize() call\n+              // on each filter will only occur once per query.\n               preAnalysisGroup.computeJoinFilterPreAnalysisIfAbsent(\n-                  joinQuery.getFilter() == null ? null : joinQuery.getFilter().toFilter(),\n+                  joinQuery.getFilter() == null ? null : joinQuery.getFilter().optimize().toFilter(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg4NjM0NA=="}, "originalCommit": null, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM3MzE4NQ==", "bodyText": "I tried to move this test into a new test class in processing, but I found that there's quite a lot of test machinery that has to be created (around making a SegmentWalker). The existing test infrastructure for that all exists outside of the processing module, so it cannot be reused.\nI don't think that's worth doing at this point for a single test with pretty special requirements.", "url": "https://github.com/apache/druid/pull/10056#discussion_r447373185", "createdAt": "2020-06-30T02:38:07Z", "author": {"login": "jon-wei"}, "path": "processing/src/main/java/org/apache/druid/segment/join/Joinables.java", "diffHunk": "@@ -107,8 +107,17 @@ public static boolean isPrefixedBy(final String columnName, final String prefix)\n             );\n \n             for (Query joinQuery : joinQueryLevels) {\n+              // The pre-analysis needs to apply to the optimized form of filters, as this is what will be\n+              // passed to HashJoinSegmentAdapter.makeCursors().\n+              // The optimize() call here means that the filter optimization will happen twice,\n+              // since the query toolchests will call optimize() later.\n+              // We do this for simplicity as we cannot override what query will get run later from this context.\n+              // A more complicated approach involving wrapping the query runner after the pre-merge decoration\n+              // and moving the pre-analysis might be viable.\n+              // The additional overhead of the simple approach should be low, as the additional optimize() call\n+              // on each filter will only occur once per query.\n               preAnalysisGroup.computeJoinFilterPreAnalysisIfAbsent(\n-                  joinQuery.getFilter() == null ? null : joinQuery.getFilter().toFilter(),\n+                  joinQuery.getFilter() == null ? null : joinQuery.getFilter().optimize().toFilter(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg4NjM0NA=="}, "originalCommit": null, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTc5ODgxOnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwMDowMjoyM1rOGnUywA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMjozNToyMlrOGqpcyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg4ODMyMA==", "bodyText": "Intellij inspection check is flagging this line since Exception is not thrown by the method body:\nhttps://travis-ci.org/github/apache/druid/jobs/699956394#L11326", "url": "https://github.com/apache/druid/pull/10056#discussion_r443888320", "createdAt": "2020-06-23T00:02:23Z", "author": {"login": "ccaominh"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -11987,6 +11992,83 @@ public void testNestedGroupByOnInlineDataSourceWithFilter(Map<String, Object> qu\n     );\n   }\n \n+  @Test\n+  @Parameters(source = QueryContextForJoinProvider.class)\n+  public void testGroupByJoinAsNativeQueryWithUnoptimizedFilter(Map<String, Object> queryContext) throws Exception", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzM3MjQ5MQ==", "bodyText": "Removed this", "url": "https://github.com/apache/druid/pull/10056#discussion_r447372491", "createdAt": "2020-06-30T02:35:22Z", "author": {"login": "jon-wei"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -11987,6 +11992,83 @@ public void testNestedGroupByOnInlineDataSourceWithFilter(Map<String, Object> qu\n     );\n   }\n \n+  @Test\n+  @Parameters(source = QueryContextForJoinProvider.class)\n+  public void testGroupByJoinAsNativeQueryWithUnoptimizedFilter(Map<String, Object> queryContext) throws Exception", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg4ODMyMA=="}, "originalCommit": null, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjA4NTMyOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/filter/AbstractOptimizableDimFilter.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMDo0NToxOVrOGr0yWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQyMToxMTo0OVrOGr1gAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYwNjgwOA==", "bodyText": "I think this is going to be called by different processing threads simultaneously, so it should be thread-safe. Perhaps use Suppliers.memoize.", "url": "https://github.com/apache/druid/pull/10056#discussion_r448606808", "createdAt": "2020-07-01T20:45:19Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/filter/AbstractOptimizableDimFilter.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.filter;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n+/**\n+ * Base class for DimFilters that support optimization.\n+ */\n+abstract class AbstractOptimizableDimFilter implements DimFilter\n+{\n+  private Filter cachedOptimizedFilter = null;\n+\n+  @JsonIgnore\n+  @Override\n+  public Filter toOptimizedFilter()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "83fd145e3fde446d088ed6c0b5ea87c4bd426c8e"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxMTQxNg==", "bodyText": "Ah, I was originally thinking of just letting the processing threads for non-joins possibly do some redundant computation (for joins, the pre-analysis would call toOptimizedFilter before the processing threads run the query), but I can adjust it.", "url": "https://github.com/apache/druid/pull/10056#discussion_r448611416", "createdAt": "2020-07-01T20:55:23Z", "author": {"login": "jon-wei"}, "path": "processing/src/main/java/org/apache/druid/query/filter/AbstractOptimizableDimFilter.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.filter;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n+/**\n+ * Base class for DimFilters that support optimization.\n+ */\n+abstract class AbstractOptimizableDimFilter implements DimFilter\n+{\n+  private Filter cachedOptimizedFilter = null;\n+\n+  @JsonIgnore\n+  @Override\n+  public Filter toOptimizedFilter()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYwNjgwOA=="}, "originalCommit": {"oid": "83fd145e3fde446d088ed6c0b5ea87c4bd426c8e"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYxODQ5Nw==", "bodyText": "I think it'd be good to adjust it; it shouldn't hurt and would save some work.", "url": "https://github.com/apache/druid/pull/10056#discussion_r448618497", "createdAt": "2020-07-01T21:11:49Z", "author": {"login": "gianm"}, "path": "processing/src/main/java/org/apache/druid/query/filter/AbstractOptimizableDimFilter.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.filter;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+\n+/**\n+ * Base class for DimFilters that support optimization.\n+ */\n+abstract class AbstractOptimizableDimFilter implements DimFilter\n+{\n+  private Filter cachedOptimizedFilter = null;\n+\n+  @JsonIgnore\n+  @Override\n+  public Filter toOptimizedFilter()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODYwNjgwOA=="}, "originalCommit": {"oid": "83fd145e3fde446d088ed6c0b5ea87c4bd426c8e"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NjgwMjU1OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/filter/DimFilter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwMjozNjozN1rOGr7arA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwMjozNjozN1rOGr7arA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODcxNTQzNg==", "bodyText": "CI is flagging these 4 as unused imports", "url": "https://github.com/apache/druid/pull/10056#discussion_r448715436", "createdAt": "2020-07-02T02:36:37Z", "author": {"login": "ccaominh"}, "path": "processing/src/main/java/org/apache/druid/query/filter/DimFilter.java", "diffHunk": "@@ -23,7 +23,11 @@\n import com.fasterxml.jackson.annotation.JsonTypeInfo;\n import com.google.common.collect.RangeSet;\n import org.apache.druid.java.util.common.Cacheable;\n+import org.apache.druid.java.util.common.granularity.Granularity;\n+import org.apache.druid.query.QueryMetrics;\n import org.apache.druid.query.extraction.ExtractionFn;\n+import org.apache.druid.segment.VirtualColumns;\n+import org.joda.time.Interval;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d32bbdad32346c9189dba05495985710dd5b334"}, "originalPosition": 8}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2354, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}