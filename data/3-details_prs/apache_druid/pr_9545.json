{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxNTk2MDY2", "number": 9545, "title": "SQL support for joins on subqueries.", "bodyText": "Changes to SQL module:\n\nDruidJoinRule: Allow joins on subqueries (left/right are no longer\nrequired to be scans or mappings).\nDruidJoinRel: Add cost estimation code for joins on subqueries.\nDruidSemiJoinRule, DruidSemiJoinRel: Removed, since DruidJoinRule can\nhandle this case now.\nDruidRel: Remove Nullable annotation from toDruidQuery, because\nit is no longer needed (it was used by DruidSemiJoinRel).\nUpdate Rules constants to reflect new rules available in our current\nversion of Calcite. Some of these are useful for optimizing joins on\nsubqueries.\nRework cost estimation to be in terms of cost per row, and place all\nrelevant constants in CostEstimates.\nRemove maxQueryCount and maxSemiJoinRowsInMemory properties\nfrom the SQL layer, since the responsibility for handling subqueries has\nmoved down into the native query layer. There's no replacement for\nmaxQueryCount (I don't think it's necessary). The replacement for\nmaxSemiJoinRowsInMemory is maxSubqueryRows.\n\nOther changes:\n\nRowBasedColumnSelectorFactory: Don't set hasMultipleValues. The lack\nof isComplete is enough to let callers know that columns might have\nmultiple values, and explicitly setting it to true causes\nExpressionSelectors to think it definitely has multiple values, and\ntreat the inputs as arrays. This behavior interfered with some of the\nnew tests that involved queries on lookups.\nQueryContexts: Add maxSubqueryRows parameter, and use it in druid-sql\ntests.", "createdAt": "2020-03-20T15:32:37Z", "url": "https://github.com/apache/druid/pull/9545", "merged": true, "mergeCommit": {"oid": "54c9325256c33622bc8d198dc0252a157f68f196"}, "closed": true, "closedAt": "2020-03-22T23:43:56Z", "author": {"login": "gianm"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcPiLTiAH2gAyMzkxNTk2MDY2OjVlZWFlMTM5MzBkMzI2N2I2ODMxMTMzYTg3NWVhM2M5ZmM2YmI2NmE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPqfgFAFqTM3ODg3NzgyOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5eeae13930d3267b6831133a875ea3c9fc6bb66a", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/5eeae13930d3267b6831133a875ea3c9fc6bb66a", "committedDate": "2020-03-20T15:24:04Z", "message": "SQL support for joins on subqueries.\n\nChanges to SQL module:\n\n- DruidJoinRule: Allow joins on subqueries (left/right are no longer\n  required to be scans or mappings).\n- DruidJoinRel: Add cost estimation code for joins on subqueries.\n- DruidSemiJoinRule, DruidSemiJoinRel: Removed, since DruidJoinRule can\n  handle this case now.\n- DruidRel: Remove Nullable annotation from toDruidQuery, because\n  it is no longer needed (it was used by DruidSemiJoinRel).\n- Update Rules constants to reflect new rules available in our current\n  version of Calcite. Some of these are useful for optimizing joins on\n  subqueries.\n- Rework cost estimation to be in terms of cost per row, and place all\n  relevant constants in CostEstimates.\n\nOther changes:\n\n- RowBasedColumnSelectorFactory: Don't set hasMultipleValues. The lack\n  of isComplete is enough to let callers know that columns might have\n  multiple values, and explicitly setting it to true causes\n  ExpressionSelectors to think it definitely has multiple values, and\n  treat the inputs as arrays. This behavior interfered with some of the\n  new tests that involved queries on lookups.\n- QueryContexts: Add maxSubqueryRows parameter, and use it in druid-sql\n  tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/36619ca428280448a8a5dde06277c828863e8a03", "committedDate": "2020-03-20T17:49:54Z", "message": "Fixes for tests."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4Njg2MDE0", "url": "https://github.com/apache/druid/pull/9545#pullrequestreview-378686014", "createdAt": "2020-03-20T17:38:15Z", "commit": {"oid": "5eeae13930d3267b6831133a875ea3c9fc6bb66a"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxNzozODoxNlrOF5dRCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMToyMjo1MFrOF5jk5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5MjY1MA==", "bodyText": "Maybe worth to mention that there is no replacement for maxQueryCount and why.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395792650", "createdAt": "2020-03-20T17:38:16Z", "author": {"login": "jihoonson"}, "path": "docs/configuration/index.md", "diffHunk": "@@ -1632,6 +1632,10 @@ The Druid SQL server is configured through the following properties on the Broke\n |`druid.sql.planner.sqlTimeZone`|Sets the default time zone for the server, which will affect how time functions and timestamp literals behave. Should be a time zone name like \"America/Los_Angeles\" or offset like \"-08:00\".|UTC|\n |`druid.sql.planner.serializeComplexValues`|Whether to serialize \"complex\" output values, false will return the class name instead of the serialized value.|true|\n \n+> Previous versions of Druid had properties named `druid.sql.planner.maxQueryCount` and `druid.sql.planner.maxSemiJoinRowsInMemory`.\n+> These properties are no longer available. Since Druid 0.18.0, you can use `druid.server.http.maxSubqueryRows` to control the maximum\n+> number of rows permitted across all subqueries.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eeae13930d3267b6831133a875ea3c9fc6bb66a"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5MzM5Ng==", "bodyText": "Should maxSubqueryRows be added to the above table instead of maxQueryCount and maxSemiJoinRowsInMemory?", "url": "https://github.com/apache/druid/pull/9545#discussion_r395793396", "createdAt": "2020-03-20T17:39:45Z", "author": {"login": "jihoonson"}, "path": "docs/configuration/index.md", "diffHunk": "@@ -1632,6 +1632,10 @@ The Druid SQL server is configured through the following properties on the Broke\n |`druid.sql.planner.sqlTimeZone`|Sets the default time zone for the server, which will affect how time functions and timestamp literals behave. Should be a time zone name like \"America/Los_Angeles\" or offset like \"-08:00\".|UTC|\n |`druid.sql.planner.serializeComplexValues`|Whether to serialize \"complex\" output values, false will return the class name instead of the serialized value.|true|\n \n+> Previous versions of Druid had properties named `druid.sql.planner.maxQueryCount` and `druid.sql.planner.maxSemiJoinRowsInMemory`.\n+> These properties are no longer available. Since Druid 0.18.0, you can use `druid.server.http.maxSubqueryRows` to control the maximum\n+> number of rows permitted across all subqueries.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5MjY1MA=="}, "originalCommit": {"oid": "5eeae13930d3267b6831133a875ea3c9fc6bb66a"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTc5NDE5MA==", "bodyText": "Same here. Should maxSubqueryRows be added to the above table?", "url": "https://github.com/apache/druid/pull/9545#discussion_r395794190", "createdAt": "2020-03-20T17:41:16Z", "author": {"login": "jihoonson"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -949,6 +947,10 @@ The Druid SQL server is configured through the following properties on the Broke\n |`druid.sql.planner.metadataSegmentCacheEnable`|Whether to keep a cache of published segments in broker. If true, broker polls coordinator in background to get segments from metadata store and maintains a local cache. If false, coordinator's REST API will be invoked when broker needs published segments info.|false|\n |`druid.sql.planner.metadataSegmentPollPeriod`|How often to poll coordinator for published segments list if `druid.sql.planner.metadataSegmentCacheEnable` is set to true. Poll period is in milliseconds. |60000|\n \n+> Previous versions of Druid had properties named `druid.sql.planner.maxQueryCount` and `druid.sql.planner.maxSemiJoinRowsInMemory`.\n+> These properties are no longer available. Since Druid 0.18.0, you can use `druid.server.http.maxSubqueryRows` to control the maximum", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5eeae13930d3267b6831133a875ea3c9fc6bb66a"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNTAwMg==", "bodyText": "Unused variable.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395835002", "createdAt": "2020-03-20T18:59:32Z", "author": {"login": "jihoonson"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidQueryRel.java", "diffHunk": "@@ -34,22 +34,14 @@\n import org.apache.druid.java.util.common.guava.Sequence;\n import org.apache.druid.sql.calcite.table.DruidTable;\n \n-import javax.annotation.Nonnull;\n import java.util.Set;\n \n /**\n  * DruidRel that operates on top of a {@link DruidTable} directly (no joining or subqueries).\n  */\n public class DruidQueryRel extends DruidRel<DruidQueryRel>\n {\n-  // Factors used for computing cost (see computeSelfCost). These are intended to encourage pushing down filters\n-  // and limits through stacks of nested queries when possible.\n-  private static final double COST_BASE = 1.0;\n-  private static final double COST_PER_COLUMN = 0.001;\n-  private static final double COST_FILTER_MULTIPLIER = 0.1;\n-  private static final double COST_GROUPING_MULTIPLIER = 0.5;\n-  private static final double COST_LIMIT_MULTIPLIER = 0.5;\n-  private static final double COST_HAVING_MULTIPLIER = 5.0;\n+  static final double COST_BASE = 1.0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNjEyNQ==", "bodyText": "This doesn't seem right since we don't have DruidSemiJoin anymore.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395836125", "createdAt": "2020-03-20T19:01:46Z", "author": {"login": "jihoonson"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidRel.java", "diffHunk": "@@ -71,17 +71,14 @@ public boolean isValidDruidQuery()\n    * Convert this DruidRel to a DruidQuery. This may be an expensive operation. For example, DruidSemiJoin needs to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTgzNjI0Nw==", "bodyText": "This method does not return null?", "url": "https://github.com/apache/druid/pull/9545#discussion_r395836247", "createdAt": "2020-03-20T19:02:02Z", "author": {"login": "jihoonson"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/rel/DruidRel.java", "diffHunk": "@@ -71,17 +71,14 @@ public boolean isValidDruidQuery()\n    * Convert this DruidRel to a DruidQuery. This may be an expensive operation. For example, DruidSemiJoin needs to\n    * execute the right-hand side query in order to complete this method.\n    *\n-   * This method may return null if it knows that this rel will yield an empty result set.\n+   * This method may not return null.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg4OTQ1Ng==", "bodyText": "This doesn't seem right.. I guess it should be always 0.\nBased on the expected results before this PR, it seems that a timeseries query was issued when useDefault = true which returns an empty result. When useDefault = false, no query was issued so probably the query computation was done by Calcite.\nSo, I guess there are two potential issues here. One is the timeseries query returning an empty result and another is Calcite returning an empty result which used to return a valid result. We may want to fix the Calcite issue in this PR. The timeseries issue seems a bug, but since it's not introduced in this PR and we are about to cut the branch for 0.18, I'm ok with merging this PR and backporting the bug fix later.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395889456", "createdAt": "2020-03-20T21:05:41Z", "author": {"login": "jihoonson"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteParameterQueryTest.java", "diffHunk": "@@ -602,14 +602,13 @@ public void testWrongTypeParameter() throws Exception\n                       and(\n                           bound(\"l1\", \"3\", null, true, false, null, StringComparators.NUMERIC),\n                           selector(\"f1\", useDefault ? \"0.0\" : null, null)\n-\n                       )\n                   )\n                   .aggregators(aggregators(new CountAggregatorFactory(\"a0\")))\n                   .context(TIMESERIES_CONTEXT_DEFAULT)\n                   .build()\n         ) : ImmutableList.of(),\n-        useDefault ? ImmutableList.of() : ImmutableList.of(new Object[]{0L}),\n+        ImmutableList.of(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTg5NjAzNg==", "bodyText": "Seems like the same Calcite issue.", "url": "https://github.com/apache/druid/pull/9545#discussion_r395896036", "createdAt": "2020-03-20T21:22:50Z", "author": {"login": "jihoonson"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -4841,10 +4982,12 @@ public void testCountStarWithDegenerateFilter() throws Exception\n   @Test\n   public void testCountStarWithNotOfDegenerateFilter() throws Exception\n   {\n+    // This query is evaluated in the planner (no native queries are issued) due to the degenerate filter.\n+\n     testQuery(\n         \"SELECT COUNT(*) FROM druid.foo WHERE dim2 = 'a' and not (dim1 > 'a' OR dim1 < 'b')\",\n         ImmutableList.of(),\n-        ImmutableList.of(new Object[]{0L})\n+        ImmutableList.of()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36619ca428280448a8a5dde06277c828863e8a03"}, "originalPosition": 243}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5176b4f754b99c30b0893eb84ae850690426e166", "author": {"user": {"login": "gianm", "name": "Gian Merlino"}}, "url": "https://github.com/apache/druid/commit/5176b4f754b99c30b0893eb84ae850690426e166", "committedDate": "2020-03-21T00:27:04Z", "message": "Adjustments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4ODc2MTg2", "url": "https://github.com/apache/druid/pull/9545#pullrequestreview-378876186", "createdAt": "2020-03-21T00:50:58Z", "commit": {"oid": "5176b4f754b99c30b0893eb84ae850690426e166"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4ODc3ODI5", "url": "https://github.com/apache/druid/pull/9545#pullrequestreview-378877829", "createdAt": "2020-03-21T01:05:22Z", "commit": {"oid": "5176b4f754b99c30b0893eb84ae850690426e166"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2695, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}