{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyOTAzOTE0", "number": 9187, "title": "Implement ANY aggregator", "bodyText": "Implement ANY aggregator\nDescription\nImplement ANY function that returns the first value that we can find\n\n\nAnySqlAggregator can reuse a lot of code in EarliestLatestSqlAggregator. Hence, added ANY to EarliestLatestSqlAggregator and rename EarliestLatestSqlAggregator to EarliestLatestAnySqlAggregator. (Maybe there can be a better name for that)\n\n\nSQL function keyword is ANY_VALUE since ANY is SQL reserved already.\n\n\nCreate LongAnyAggregatorFactory, FloatAnyAggregatorFactory, DoubleAnyAggregatorFactory, StringAnyAggregatorFactory. The combine logic will just return lhs if not null otherwise return rhs. (lhs, rhs are just the column value)\n\n\nCreate LongAnyAggregator, FloatAnyAggregator, DoubleAnyAggregator, StringAnyAggregator, LongAnyBufferAggregator, FloatAnyBufferAggregator, DoubleAnyBufferAggregator, StringAnyBufferAggregator. Aggregate logic will just return value if we already see non-null value without getObject from selector. LongAnyBufferAggregator, FloatAnyBufferAggregator, and DoubleAnyBufferAggregator have 0 as default values.\n\n\nThis PR has:\n\n been self-reviewed.\n added documentation for new or modified features or behaviors.\n added Javadocs for most classes and all non-trivial methods. Linked related entities via Javadoc links.\n added or updated version, license, or notice information in licenses.yaml\n added comments explaining the \"why\" and the intent of the code wherever would not be obvious for an unfamiliar reader.\n added unit tests or modified existing tests to cover new code paths.\n added integration tests.\n been tested in a test Druid cluster.", "createdAt": "2020-01-15T00:38:15Z", "url": "https://github.com/apache/druid/pull/9187", "merged": true, "mergeCommit": {"oid": "42359c93dd53f16e52ed79dcd8b63829f4bf2f7b"}, "closed": true, "closedAt": "2020-01-16T22:40:33Z", "author": {"login": "maytasm"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb6aiotAH2gAyMzYyOTAzOTE0OjVkYTcyYTA3YTM0Mzg0MjM2ZjZkNzIyMGU1M2Y0NGQxODJkZTMyN2Q=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb7A_HaAFqTM0NDIyNjU0Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5da72a07a34384236f6d7220e53f44d182de327d", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/5da72a07a34384236f6d7220e53f44d182de327d", "committedDate": "2020-01-15T00:37:54Z", "message": "Implement ANY aggregator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57dd3cb426c713ba91aee41a974ad08a784bf92c", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/57dd3cb426c713ba91aee41a974ad08a784bf92c", "committedDate": "2020-01-15T01:28:21Z", "message": "Add copyright headers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6d1dbb790311a995457f48f8f1e50b9f00226a2", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/b6d1dbb790311a995457f48f8f1e50b9f00226a2", "committedDate": "2020-01-15T03:27:40Z", "message": "Add unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebd8fc0b75cd3269ab54863bd71b9224263d580d", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/ebd8fc0b75cd3269ab54863bd71b9224263d580d", "committedDate": "2020-01-15T05:39:21Z", "message": "fix BufferAggregator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e3579d34d2ff0bb2bdc3f85950067d6564147339", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/e3579d34d2ff0bb2bdc3f85950067d6564147339", "committedDate": "2020-01-15T06:45:46Z", "message": "Fix bug in BufferAggregator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/d27db11b6db196d2f09295a6419fb593a8ddbffa", "committedDate": "2020-01-15T17:20:15Z", "message": "hook up the SQL command"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDA1MjM1", "url": "https://github.com/apache/druid/pull/9187#pullrequestreview-343005235", "createdAt": "2020-01-15T06:14:09Z", "commit": {"oid": "ebd8fc0b75cd3269ab54863bd71b9224263d580d"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwNjoxNDowOVrOFduLtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQxODo1MjoyN1rOFeCyMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcwOTY4NQ==", "bodyText": "I think you need a different byte for each type id here.\nAlso nitpicking here - can you add a comment above the group saying this is for the any aggregators", "url": "https://github.com/apache/druid/pull/9187#discussion_r366709685", "createdAt": "2020-01-15T06:14:09Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/AggregatorUtil.java", "diffHunk": "@@ -121,6 +121,11 @@\n \n   public static final byte MEAN_CACHE_TYPE_ID = 0x41;\n \n+  public static final byte LONG_ANY_CACHE_TYPE_ID = 0x42;\n+  public static final byte DOUBLE_ANY_CACHE_TYPE_ID = 0x42;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ebd8fc0b75cd3269ab54863bd71b9224263d580d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyMDIxMA==", "bodyText": "nit: javadocs please - I know most of the aggregators don't have docs, but I think explaining how nulls should be handled in this class is valuable", "url": "https://github.com/apache/druid/pull/9187#discussion_r367020210", "createdAt": "2020-01-15T17:53:42Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNDAxNA==", "bodyText": "I think you should store this as a primitive so we don't have to do un-necessary boxing. Also I think we need another variable in here to track whether the value is null or not. We would need to implement isNull for the aggregator.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367024014", "createdAt": "2020-01-15T18:01:49Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNjE2Nw==", "bodyText": "This can throw an NPE if isNull is true. I can't tell if this is called from a hot loop or not. @clintropolis or @jon-wei might know how we should deal with this. I see this potential NPE in other aggregators as well.\nIf you switch to using a primitive in the class, then all these getters can simply cast the local variable", "url": "https://github.com/apache/druid/pull/9187#discussion_r367026167", "createdAt": "2020-01-15T18:06:41Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;\n+\n+  public DoubleAnyAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+    foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null && !valueSelector.isNull()) {\n+      foundValue = valueSelector.getDouble();\n+    }\n+  }\n+\n+  @Override\n+  public Object get()\n+  {\n+    return foundValue;\n+  }\n+\n+  @Override\n+  public float getFloat()\n+  {\n+    return foundValue.floatValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNjU5Mg==", "bodyText": "nit: Add a comment explaining why this function is empty to indicate it is intentional", "url": "https://github.com/apache/druid/pull/9187#discussion_r367026592", "createdAt": "2020-01-15T18:07:43Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;\n+\n+  public DoubleAnyAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+    foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null && !valueSelector.isNull()) {\n+      foundValue = valueSelector.getDouble();\n+    }\n+  }\n+\n+  @Override\n+  public Object get()\n+  {\n+    return foundValue;\n+  }\n+\n+  @Override\n+  public float getFloat()\n+  {\n+    return foundValue.floatValue();\n+  }\n+\n+  @Override\n+  public long getLong()\n+  {\n+    return foundValue.longValue();\n+  }\n+\n+  @Override\n+  public double getDouble()\n+  {\n+    return foundValue;\n+  }\n+\n+  @Override\n+  public void close()\n+  {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMDk2NQ==", "bodyText": "Shouldn't we be looking at storeDoubleAsFloat  as well for equalsAndHashCode?\nCan we add an EqualsVerifierTest for this?", "url": "https://github.com/apache/druid/pull/9187#discussion_r367030965", "createdAt": "2020-01-15T18:17:21Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8(fieldName);\n+\n+    return ByteBuffer.allocate(1 + fieldNameBytes.length)\n+                     .put(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n+                     .put(fieldNameBytes)\n+                     .array();\n+  }\n+\n+  @Override\n+  public String getTypeName()\n+  {\n+    if (storeDoubleAsFloat) {\n+      return \"float\";\n+    }\n+    return \"double\";\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Double.BYTES;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    DoubleAnyAggregatorFactory that = (DoubleAnyAggregatorFactory) o;\n+\n+    return name.equals(that.name) && fieldName.equals(that.fieldName);\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(name, fieldName);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMTI1Nw==", "bodyText": "Similar comment to above...\nUgh I can't wait till we can hide all of this away with lombok", "url": "https://github.com/apache/druid/pull/9187#discussion_r367031257", "createdAt": "2020-01-15T18:17:57Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8(fieldName);\n+\n+    return ByteBuffer.allocate(1 + fieldNameBytes.length)\n+                     .put(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n+                     .put(fieldNameBytes)\n+                     .array();\n+  }\n+\n+  @Override\n+  public String getTypeName()\n+  {\n+    if (storeDoubleAsFloat) {\n+      return \"float\";\n+    }\n+    return \"double\";\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Double.BYTES;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o)\n+  {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+\n+    DoubleAnyAggregatorFactory that = (DoubleAnyAggregatorFactory) o;\n+\n+    return name.equals(that.name) && fieldName.equals(that.fieldName);\n+  }\n+\n+  @Override\n+  public int hashCode()\n+  {\n+    return Objects.hash(name, fieldName);\n+  }\n+\n+  @Override\n+  public String toString()\n+  {\n+    return \"DoubleAnyAggregatorFactory{\" +\n+           \"name='\" + name + '\\'' +\n+           \", fieldName='\" + fieldName + '\\'' +\n+           '}';\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 199}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMjY4Ng==", "bodyText": "not sure if this makes a difference or not, but won't the max size be Float.BYTES if storeDoubleAsFloat is true?\nI see the pattern you used is the same as what's used in DoubleFirstAggregatorFactory - probably a bug in both?", "url": "https://github.com/apache/druid/pull/9187#discussion_r367032686", "createdAt": "2020-01-15T18:21:01Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8(fieldName);\n+\n+    return ByteBuffer.allocate(1 + fieldNameBytes.length)\n+                     .put(AggregatorUtil.DOUBLE_ANY_CACHE_TYPE_ID)\n+                     .put(fieldNameBytes)\n+                     .array();\n+  }\n+\n+  @Override\n+  public String getTypeName()\n+  {\n+    if (storeDoubleAsFloat) {\n+      return \"float\";\n+    }\n+    return \"double\";\n+  }\n+\n+  @Override\n+  public int getMaxIntermediateSize()\n+  {\n+    return Double.BYTES;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzMzMyNg==", "bodyText": "nit: Collections.singletonList(fieldName)", "url": "https://github.com/apache/druid/pull/9187#discussion_r367033326", "createdAt": "2020-01-15T18:22:11Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));\n+  }\n+\n+  @Override\n+  public Object deserialize(Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object finalizeComputation(@Nullable Object object)\n+  {\n+    return object;\n+  }\n+\n+  @Override\n+  @JsonProperty\n+  public String getName()\n+  {\n+    return name;\n+  }\n+\n+  @JsonProperty\n+  public String getFieldName()\n+  {\n+    return fieldName;\n+  }\n+\n+  @Override\n+  public List<String> requiredFields()\n+  {\n+    return Arrays.asList(fieldName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAzNjg1Nw==", "bodyText": "I don't understand why both the parameters here are fieldName and both the parameters in getCombiningFactory are name - I see this pattern used in all the aggregators", "url": "https://github.com/apache/druid/pull/9187#discussion_r367036857", "createdAt": "2020-01-15T18:29:31Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0MDIwNQ==", "bodyText": "Is this so that missing values show up first? Is that the behavior we want? I don't know the answer...", "url": "https://github.com/apache/druid/pull/9187#discussion_r367040205", "createdAt": "2020-01-15T18:36:34Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }\n+\n+  @Override\n+  protected ColumnValueSelector selector(ColumnSelectorFactory metricFactory)\n+  {\n+    return metricFactory.makeColumnValueSelector(fieldName);\n+  }\n+\n+  @Override\n+  protected Aggregator factorize(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory, ColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  public Comparator getComparator()\n+  {\n+    return DoubleAnyAggregatorFactory.VALUE_COMPARATOR;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0MjQ0MQ==", "bodyText": "I know this is an existing pattern, but I prefer having a package private all args constructor to make unit testing easier and have the JsonCreator constructor call the all args constructor. Otherwise the tests need to rely on the static implementation of ColumnHolder#storeDoubleAsFloat which can be a huge pain to try and mock correctly.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367042441", "createdAt": "2020-01-15T18:41:43Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>\n+{\n+  private static final Comparator<Number> VALUE_COMPARATOR = Comparator.nullsFirst(\n+      Comparator.comparingDouble(Number::doubleValue)\n+  );\n+\n+  private final String fieldName;\n+  private final String name;\n+  private final boolean storeDoubleAsFloat;\n+\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName\n+  )\n+  {\n+    Preconditions.checkNotNull(name, \"Must have a valid, non-null aggregator name\");\n+    Preconditions.checkNotNull(fieldName, \"Must have a valid, non-null fieldName\");\n+    this.name = name;\n+    this.fieldName = fieldName;\n+    this.storeDoubleAsFloat = ColumnHolder.storeDoubleAsFloat();\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0Mjc1Ng==", "bodyText": "nit: Comment for empty function please", "url": "https://github.com/apache/druid/pull/9187#discussion_r367042756", "createdAt": "2020-01-15T18:42:25Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final double NULL_VALUE = 0;\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  public DoubleAnyBufferAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.putDouble(position, NULL_VALUE);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position)\n+  {\n+    if (buf.getDouble(position) == NULL_VALUE && !valueSelector.isNull()) {\n+      buf.putDouble(position, valueSelector.getDouble());\n+    }\n+  }\n+\n+  @Override\n+  public Object get(ByteBuffer buf, int position)\n+  {\n+    return buf.getDouble(position);\n+  }\n+\n+  @Override\n+  public float getFloat(ByteBuffer buf, int position)\n+  {\n+    return (float) buf.getDouble(position);\n+  }\n+\n+  @Override\n+  public long getLong(ByteBuffer buf, int position)\n+  {\n+    return (long) buf.getDouble(position);\n+  }\n+\n+  @Override\n+  public double getDouble(ByteBuffer buf, int position)\n+  {\n+    return buf.getDouble(position);\n+  }\n+\n+  @Override\n+  public void close()\n+  {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0Mzk3OQ==", "bodyText": "0 is a valid value for a double. I think Double.NaN is safer to indicate that the value is not found.\nSimilar comments to DoubleAnyAggregator - I think you need to store a byte to indicate whether or not the value has been found since 0, NaN, etc. are all valid values that can show up in a double column.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367043979", "createdAt": "2020-01-15T18:45:21Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final double NULL_VALUE = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA0NzIxNg==", "bodyText": "Why was this change needed?", "url": "https://github.com/apache/druid/pull/9187#discussion_r367047216", "createdAt": "2020-01-15T18:52:27Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/first/StringAggregatorUtils.java", "diffHunk": "@@ -87,7 +87,7 @@ public static void writePair(\n \n     if (pair.rhs != null) {\n       mutationBuffer.position(position + Long.BYTES + Integer.BYTES);\n-      mutationBuffer.limit(maxStringBytes);\n+      mutationBuffer.limit(position + Long.BYTES + Integer.BYTES + maxStringBytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9b71131991216c9265af15e72407159825762b8", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/a9b71131991216c9265af15e72407159825762b8", "committedDate": "2020-01-15T21:15:04Z", "message": "add check for buffer aggregator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNTI2Mjc0", "url": "https://github.com/apache/druid/pull/9187#pullrequestreview-343526274", "createdAt": "2020-01-15T21:16:03Z", "commit": {"oid": "a9b71131991216c9265af15e72407159825762b8"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMToxNjowM1rOFeGqzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQyMTozODowOVrOFeHQQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExMDg2MQ==", "bodyText": "yes these need to be different values", "url": "https://github.com/apache/druid/pull/9187#discussion_r367110861", "createdAt": "2020-01-15T21:16:03Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/AggregatorUtil.java", "diffHunk": "@@ -121,6 +121,11 @@\n \n   public static final byte MEAN_CACHE_TYPE_ID = 0x41;\n \n+  public static final byte LONG_ANY_CACHE_TYPE_ID = 0x42;\n+  public static final byte DOUBLE_ANY_CACHE_TYPE_ID = 0x42;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjcwOTY4NQ=="}, "originalCommit": {"oid": "ebd8fc0b75cd3269ab54863bd71b9224263d580d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExNjA0OQ==", "bodyText": "valueSelector.isNull() will never be true since this the factory is NullableNumericAggregatorFactory", "url": "https://github.com/apache/druid/pull/9187#discussion_r367116049", "createdAt": "2020-01-15T21:27:44Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;\n+\n+  public DoubleAnyAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+    foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null && !valueSelector.isNull()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9b71131991216c9265af15e72407159825762b8"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzExOTk3Nw==", "bodyText": "Since this is created by NullableNumericAggregatorFactory it can be a primitive. NullableNumericAggregator and NullableNumericBufferAggregator will initialize to a null value, so aggregate will never be called unless you encounter a not null value.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367119977", "createdAt": "2020-01-15T21:36:58Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+public class DoubleAnyAggregator implements Aggregator\n+{\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  private Double foundValue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzAyNDAxNA=="}, "originalCommit": {"oid": "d27db11b6db196d2f09295a6419fb593a8ddbffa"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEyMDQ0OQ==", "bodyText": "I think this could be SimpleDoubleAggregatorFactory", "url": "https://github.com/apache/druid/pull/9187#discussion_r367120449", "createdAt": "2020-01-15T21:38:09Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends NullableNumericAggregatorFactory<ColumnValueSelector>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9b71131991216c9265af15e72407159825762b8"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fa5a515e3d0e2f7a428e76af3f5a0481ea74333", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/2fa5a515e3d0e2f7a428e76af3f5a0481ea74333", "committedDate": "2020-01-15T23:55:10Z", "message": "Address comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e20a74392835b7a80078d3d22f3d86731f0a1958", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/e20a74392835b7a80078d3d22f3d86731f0a1958", "committedDate": "2020-01-16T01:17:29Z", "message": "address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/3436332501a9374b3bc657b19a7d754a06a4d372", "committedDate": "2020-01-16T01:30:26Z", "message": "add docs"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNjQyNTk0", "url": "https://github.com/apache/druid/pull/9187#pullrequestreview-343642594", "createdAt": "2020-01-16T02:31:44Z", "commit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMjozMTo0NFrOFeMYxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwMjo0OTo0NlrOFeMmjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNDU1MA==", "bodyText": "This method and similar could use CacheKeyBuilder instead", "url": "https://github.com/apache/druid/pull/9187#discussion_r367204550", "createdAt": "2020-01-16T02:31:44Z", "author": {"login": "jon-wei"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.fasterxml.jackson.annotation.JacksonInject;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.Preconditions;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.math.expr.ExprMacroTable;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.AggregatorFactory;\n+import org.apache.druid.query.aggregation.AggregatorUtil;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.DoubleMaxAggregator;\n+import org.apache.druid.query.aggregation.DoubleMaxBufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.query.aggregation.SimpleDoubleAggregatorFactory;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+import org.apache.druid.segment.ColumnSelectorFactory;\n+import org.apache.druid.segment.ColumnValueSelector;\n+import org.apache.druid.segment.column.ColumnHolder;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+public class DoubleAnyAggregatorFactory extends SimpleDoubleAggregatorFactory\n+{\n+  @JsonCreator\n+  public DoubleAnyAggregatorFactory(\n+      @JsonProperty(\"name\") String name,\n+      @JsonProperty(\"fieldName\") final String fieldName,\n+      @JsonProperty(\"expression\") @Nullable String expression,\n+      @JacksonInject ExprMacroTable macroTable\n+  )\n+  {\n+    super(macroTable, name, fieldName, expression);\n+  }\n+\n+  public DoubleAnyAggregatorFactory(String name, String fieldName)\n+  {\n+    this(name, fieldName, null, ExprMacroTable.nil());\n+  }\n+\n+  @Override\n+  protected double nullValue()\n+  {\n+    return Double.NaN;\n+  }\n+\n+  @Override\n+  protected Aggregator buildAggregator(BaseDoubleColumnValueSelector selector)\n+  {\n+    return new DoubleAnyAggregator(selector);\n+  }\n+\n+  @Override\n+  protected BufferAggregator buildBufferAggregator(BaseDoubleColumnValueSelector selector)\n+  {\n+    return new DoubleAnyBufferAggregator(selector);\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Object combine(@Nullable Object lhs, @Nullable Object rhs)\n+  {\n+    if (lhs != null) {\n+      return lhs;\n+    } else {\n+      return rhs;\n+    }\n+  }\n+\n+  @Override\n+  public AggregatorFactory getCombiningFactory()\n+  {\n+    return new DoubleAnyAggregatorFactory(name, name, null, macroTable);\n+  }\n+\n+  @Override\n+  public List<AggregatorFactory> getRequiredColumns()\n+  {\n+    return Collections.singletonList(new DoubleAnyAggregatorFactory(fieldName, fieldName, expression, macroTable));\n+  }\n+\n+  @Override\n+  public byte[] getCacheKey()\n+  {\n+    byte[] fieldNameBytes = StringUtils.toUtf8WithNullToEmpty(fieldName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNDczOA==", "bodyText": "nit: suggest setting the IS_SET byte first before the double value, since that's the order they appear in the buffer", "url": "https://github.com/apache/druid/pull/9187#discussion_r367204738", "createdAt": "2020-01-16T02:32:45Z", "author": {"login": "jon-wei"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which extends from\n+ * {@link NullableNumericAggregatorFactory}. If null needs to be handle, then {@link NullableNumericAggregatorFactory}\n+ * will wrap this aggregator in {@link NullableNumericAggregator} and can handle all null in that class.\n+ * Hence, no null will ever be pass into this aggregator from the valueSelector.\n+ */\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final double NULL_VALUE = 0;\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  public DoubleAnyBufferAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, BYTE_FLAG_IS_NOT_SET);\n+    buf.putDouble(position + Byte.BYTES, NULL_VALUE);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position)\n+  {\n+    if (buf.get(position) == BYTE_FLAG_IS_NOT_SET) {\n+      buf.putDouble(position + Byte.BYTES, valueSelector.getDouble());\n+      buf.put(position, BYTE_FLAG_IS_SET);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNzc5NQ==", "bodyText": "\"this can returns the default\" -> \"this can return the default\", similarly for \"then this will returns\"", "url": "https://github.com/apache/druid/pull/9187#discussion_r367207795", "createdAt": "2020-01-16T02:48:11Z", "author": {"login": "jon-wei"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -203,6 +203,10 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest non-null value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will returns any non-null value of `expr`|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNzk2MQ==", "bodyText": "This should mention that the default maxBytesPerString is 1024", "url": "https://github.com/apache/druid/pull/9187#discussion_r367207961", "createdAt": "2020-01-16T02:49:05Z", "author": {"login": "jon-wei"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -203,6 +203,10 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest non-null value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will returns any non-null value of `expr`|\n+|`ANY_VALUE(expr, maxBytesPerString)`|Like `ANY_VALUE(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwODA3OA==", "bodyText": "Can you also add entries for the new aggregators under docs/querying/aggregations.md?", "url": "https://github.com/apache/druid/pull/9187#discussion_r367208078", "createdAt": "2020-01-16T02:49:46Z", "author": {"login": "jon-wei"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -203,6 +203,10 @@ Only the COUNT aggregation can accept DISTINCT.\n |`EARLIEST(expr, maxBytesPerString)`|Like `EARLIEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n |`LATEST(expr)`|Returns the latest non-null value of `expr`, which must be numeric. If `expr` comes from a relation with a timestamp column (like a Druid datasource) then \"latest\" is the value last encountered with the maximum overall timestamp of all values being aggregated. If `expr` does not come from a relation with a timestamp, then it is simply the last value encountered.|\n |`LATEST(expr, maxBytesPerString)`|Like `LATEST(expr)`, but for strings. The `maxBytesPerString` parameter determines how much aggregation space to allocate per string. Strings longer than this limit will be truncated. This parameter should be set as low as possible, since high values will lead to wasted memory.|\n+|`ANY_VALUE(expr)`|Returns any value of `expr`, which must be numeric. If `druid.generic.useDefaultValueForNull=true` this can returns the default value for null and does not prefer \"non-null\" values over the default value for null. If `druid.generic.useDefaultValueForNull=false`, then this will returns any non-null value of `expr`|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNjczMTUx", "url": "https://github.com/apache/druid/pull/9187#pullrequestreview-343673151", "createdAt": "2020-01-16T04:55:28Z", "commit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNDo1NToyOVrOFeN-Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwNToxMDoyNlrOFeOI4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMDQ4Mw==", "bodyText": "instead of NULL_VALUE maybe use NullHandling.ZERO_DOUBLE or like just 0 since this is the only place this is used", "url": "https://github.com/apache/druid/pull/9187#discussion_r367230483", "createdAt": "2020-01-16T04:55:29Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which extends from\n+ * {@link NullableNumericAggregatorFactory}. If null needs to be handle, then {@link NullableNumericAggregatorFactory}\n+ * will wrap this aggregator in {@link NullableNumericAggregator} and can handle all null in that class.\n+ * Hence, no null will ever be pass into this aggregator from the valueSelector.\n+ */\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final double NULL_VALUE = 0;\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  public DoubleAnyBufferAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, BYTE_FLAG_IS_NOT_SET);\n+    buf.putDouble(position + Byte.BYTES, NULL_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMTAzMA==", "bodyText": "I agree on put ordering", "url": "https://github.com/apache/druid/pull/9187#discussion_r367231030", "createdAt": "2020-01-16T04:58:47Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregator;\n+import org.apache.druid.query.aggregation.NullableNumericAggregatorFactory;\n+import org.apache.druid.query.monomorphicprocessing.RuntimeShapeInspector;\n+import org.apache.druid.segment.BaseDoubleColumnValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * This Aggregator is created by the {@link DoubleAnyAggregatorFactory} which extends from\n+ * {@link NullableNumericAggregatorFactory}. If null needs to be handle, then {@link NullableNumericAggregatorFactory}\n+ * will wrap this aggregator in {@link NullableNumericAggregator} and can handle all null in that class.\n+ * Hence, no null will ever be pass into this aggregator from the valueSelector.\n+ */\n+public class DoubleAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final byte BYTE_FLAG_IS_NOT_SET = 0;\n+  private static final byte BYTE_FLAG_IS_SET = 1;\n+  private static final double NULL_VALUE = 0;\n+  private final BaseDoubleColumnValueSelector valueSelector;\n+\n+  public DoubleAnyBufferAggregator(BaseDoubleColumnValueSelector valueSelector)\n+  {\n+    this.valueSelector = valueSelector;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, BYTE_FLAG_IS_NOT_SET);\n+    buf.putDouble(position + Byte.BYTES, NULL_VALUE);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position)\n+  {\n+    if (buf.get(position) == BYTE_FLAG_IS_NOT_SET) {\n+      buf.putDouble(position + Byte.BYTES, valueSelector.getDouble());\n+      buf.put(position, BYTE_FLAG_IS_SET);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNDczOA=="}, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMjI0Nw==", "bodyText": "nit: It is probably worth pushing chop down into StringUtils rather than renaming and widening the usage of StringAggregatorUtils", "url": "https://github.com/apache/druid/pull/9187#discussion_r367232247", "createdAt": "2020-01-16T05:05:27Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.query.aggregation.first.StringAggregatorUtils;\n+import org.apache.druid.segment.BaseObjectColumnValueSelector;\n+import org.apache.druid.segment.DimensionHandlerUtils;\n+\n+public class StringAnyAggregator implements Aggregator\n+{\n+  private final BaseObjectColumnValueSelector valueSelector;\n+  private final int maxStringBytes;\n+\n+  private String foundValue;\n+\n+  public StringAnyAggregator(BaseObjectColumnValueSelector valueSelector, int maxStringBytes)\n+  {\n+    this.valueSelector = valueSelector;\n+    this.maxStringBytes = maxStringBytes;\n+    this.foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null) {\n+      final Object object = valueSelector.getObject();\n+      if (object != null) {\n+        foundValue = DimensionHandlerUtils.convertObjectToString(object);\n+        if (foundValue != null && foundValue.length() > maxStringBytes) {\n+          foundValue = foundValue.substring(0, maxStringBytes);\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public Object get()\n+  {\n+    return StringAggregatorUtils.chop(foundValue, maxStringBytes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMjU1NA==", "bodyText": "If you decide to end up moving chop to StringUtils, please revert this rename", "url": "https://github.com/apache/druid/pull/9187#discussion_r367232554", "createdAt": "2020-01-16T05:06:47Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/first/StringAggregatorUtils.java", "diffHunk": "@@ -29,7 +29,7 @@\n import java.nio.ByteBuffer;\n import java.nio.charset.StandardCharsets;\n \n-public class StringFirstLastUtils\n+public class StringAggregatorUtils", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIzMzI1MA==", "bodyText": "nit: It would probably be worth adding an additional test that tests numeric columns agains druid.numfoo table since it contains numeric columns that have null values when run in sql compatible null mode, and also tests for ordering by each 'any' aggregator.", "url": "https://github.com/apache/druid/pull/9187#discussion_r367233250", "createdAt": "2020-01-16T05:10:26Z", "author": {"login": "clintropolis"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -1297,6 +1301,46 @@ public void testLatestAggregators() throws Exception\n     );\n   }\n \n+  // This test the on-heap version of the AnyAggregator (Double/Float/Long/String)\n+  @Test\n+  public void testAnyAggregator() throws Exception", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3436332501a9374b3bc657b19a7d754a06a4d372"}, "originalPosition": 17}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a370ffc182da3019c5e070e13b9da4e66738c4f6", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/a370ffc182da3019c5e070e13b9da4e66738c4f6", "committedDate": "2020-01-16T07:21:25Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bcae86e41dbf0d5650fb24b09cc77b57ed77795d", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/bcae86e41dbf0d5650fb24b09cc77b57ed77795d", "committedDate": "2020-01-16T08:00:35Z", "message": "add more tests for numeric columns that have null values when run in sql compatible null mode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6f954355ed3455f529507da578e903930bec1b9", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/d6f954355ed3455f529507da578e903930bec1b9", "committedDate": "2020-01-16T08:12:20Z", "message": "fix checkstyle errors"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzNzYwMjM5", "url": "https://github.com/apache/druid/pull/9187#pullrequestreview-343760239", "createdAt": "2020-01-16T09:05:43Z", "commit": {"oid": "d6f954355ed3455f529507da578e903930bec1b9"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOTowNTo0M1rOFeSTfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOToxMDo1NFrOFeSdDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMTUwMg==", "bodyText": "sorry I missed this earlier, this check isn't necessary, DimensionHandlerUtils.convertObjectToString has it's own null check", "url": "https://github.com/apache/druid/pull/9187#discussion_r367301502", "createdAt": "2020-01-16T09:05:43Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregator.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.Aggregator;\n+import org.apache.druid.segment.BaseObjectColumnValueSelector;\n+import org.apache.druid.segment.DimensionHandlerUtils;\n+\n+public class StringAnyAggregator implements Aggregator\n+{\n+  private final BaseObjectColumnValueSelector valueSelector;\n+  private final int maxStringBytes;\n+\n+  private String foundValue;\n+\n+  public StringAnyAggregator(BaseObjectColumnValueSelector valueSelector, int maxStringBytes)\n+  {\n+    this.valueSelector = valueSelector;\n+    this.maxStringBytes = maxStringBytes;\n+    this.foundValue = null;\n+  }\n+\n+  @Override\n+  public void aggregate()\n+  {\n+    if (foundValue == null) {\n+      final Object object = valueSelector.getObject();\n+      if (object != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6f954355ed3455f529507da578e903930bec1b9"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMjAwNg==", "bodyText": "same comment about unnecessary check", "url": "https://github.com/apache/druid/pull/9187#discussion_r367302006", "createdAt": "2020-01-16T09:06:53Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyBufferAggregator.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.query.aggregation.BufferAggregator;\n+import org.apache.druid.segment.BaseObjectColumnValueSelector;\n+import org.apache.druid.segment.DimensionHandlerUtils;\n+\n+import java.nio.ByteBuffer;\n+\n+public class StringAnyBufferAggregator implements BufferAggregator\n+{\n+  private static final int NULL_STRING_LENGTH = -1;\n+  private final BaseObjectColumnValueSelector valueSelector;\n+  private final int maxStringBytes;\n+\n+  public StringAnyBufferAggregator(BaseObjectColumnValueSelector valueSelector, int maxStringBytes)\n+  {\n+    this.valueSelector = valueSelector;\n+    this.maxStringBytes = maxStringBytes;\n+  }\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.putInt(position, NULL_STRING_LENGTH);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position)\n+  {\n+    int stringSizeBytes = buf.getInt(position);\n+    if (stringSizeBytes < 0) {\n+      final Object object = valueSelector.getObject();\n+      if (object != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6f954355ed3455f529507da578e903930bec1b9"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMzk1MA==", "bodyText": "Hmm, it seems like this change is causing some unrelated test failures", "url": "https://github.com/apache/druid/pull/9187#discussion_r367303950", "createdAt": "2020-01-16T09:10:54Z", "author": {"login": "clintropolis"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/util/CalciteTests.java", "diffHunk": "@@ -377,6 +377,15 @@ public AuthenticationResult createEscalatedAuthenticationResult()\n   );\n \n   public static final List<InputRow> ROWS1_WITH_NUMERIC_DIMS = ImmutableList.of(\n+      createRow(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6f954355ed3455f529507da578e903930bec1b9"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9532752229330d5e4b0504f90479b473685faf58", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/9532752229330d5e4b0504f90479b473685faf58", "committedDate": "2020-01-16T19:21:40Z", "message": "fix failing tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3925dcfcc638100dfdd1df17d2a8653219cdf9c", "author": {"user": {"login": "maytasm", "name": "Maytas Monsereenusorn"}}, "url": "https://github.com/apache/druid/commit/a3925dcfcc638100dfdd1df17d2a8653219cdf9c", "committedDate": "2020-01-16T20:15:28Z", "message": "fix failing tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MjI0NDc4", "url": "https://github.com/apache/druid/pull/9187#pullrequestreview-344224478", "createdAt": "2020-01-16T21:21:50Z", "commit": {"oid": "a3925dcfcc638100dfdd1df17d2a8653219cdf9c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ0MjI2NTQy", "url": "https://github.com/apache/druid/pull/9187#pullrequestreview-344226542", "createdAt": "2020-01-16T21:25:24Z", "commit": {"oid": "a3925dcfcc638100dfdd1df17d2a8653219cdf9c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3740, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}