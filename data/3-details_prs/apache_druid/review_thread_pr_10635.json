{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyMzk3ODM3", "number": 10635, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTo1MzoyN1rOFAuATA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yOVQwOToxNjoyNlrOGQDqqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Mjk4MDYwOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/SizeFormatOperatorConversion.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTo1MzoyN1rOH_JRTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwNTozODozN1rOIAWwgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3NDIyMg==", "bodyText": "shouldn't there be a check on precision as well?", "url": "https://github.com/apache/druid/pull/10635#discussion_r535974222", "createdAt": "2020-12-04T09:53:27Z", "author": {"login": "abhishekagarwal87"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/SizeFormatOperatorConversion.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.OperatorConversions;\n+import org.apache.druid.sql.calcite.expression.SqlOperatorConversion;\n+import org.apache.druid.sql.calcite.planner.PlannerContext;\n+\n+public class SizeFormatOperatorConversion implements SqlOperatorConversion\n+{\n+  public static final SqlOperatorConversion BINARY_BYTE_FORMAT = new SizeFormatOperatorConversion(\"binary_byte_format\");\n+  public static final SqlOperatorConversion DECIMAL_BYTE_FORMAT = new SizeFormatOperatorConversion(\"decimal_byte_format\");\n+  public static final SqlOperatorConversion DECIMAL_FORMAT = new SizeFormatOperatorConversion(\"decimal_format\");\n+\n+  private final String name;\n+  private final SqlFunction sqlFunction;\n+\n+  private SizeFormatOperatorConversion(String name)\n+  {\n+    this.sqlFunction = OperatorConversions\n+        .operatorBuilder(StringUtils.toUpperCase(name))\n+        .operandTypeChecker(new StringFormatOperandTypeChecker())\n+        .functionCategory(SqlFunctionCategory.STRING)\n+        .returnTypeNonNull(SqlTypeName.VARCHAR)\n+        .build();\n+\n+    this.name = name;\n+  }\n+\n+  @Override\n+  public SqlOperator calciteOperator()\n+  {\n+    return sqlFunction;\n+  }\n+\n+  @Override\n+  public DruidExpression toDruidExpression(\n+      final PlannerContext plannerContext,\n+      final RowSignature rowSignature,\n+      final RexNode rexNode\n+  )\n+  {\n+    return OperatorConversions.convertCall(plannerContext, rowSignature, rexNode, name);\n+  }\n+\n+  private static class StringFormatOperandTypeChecker implements SqlOperandTypeChecker\n+  {\n+    @Override\n+    public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure)\n+    {\n+      final RelDataType firstArgType = callBinding.getOperandType(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI0Mzc3OA==", "bodyText": "Fixed", "url": "https://github.com/apache/druid/pull/10635#discussion_r537243778", "createdAt": "2020-12-07T05:38:37Z", "author": {"login": "FrankChen021"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/SizeFormatOperatorConversion.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.OperatorConversions;\n+import org.apache.druid.sql.calcite.expression.SqlOperatorConversion;\n+import org.apache.druid.sql.calcite.planner.PlannerContext;\n+\n+public class SizeFormatOperatorConversion implements SqlOperatorConversion\n+{\n+  public static final SqlOperatorConversion BINARY_BYTE_FORMAT = new SizeFormatOperatorConversion(\"binary_byte_format\");\n+  public static final SqlOperatorConversion DECIMAL_BYTE_FORMAT = new SizeFormatOperatorConversion(\"decimal_byte_format\");\n+  public static final SqlOperatorConversion DECIMAL_FORMAT = new SizeFormatOperatorConversion(\"decimal_format\");\n+\n+  private final String name;\n+  private final SqlFunction sqlFunction;\n+\n+  private SizeFormatOperatorConversion(String name)\n+  {\n+    this.sqlFunction = OperatorConversions\n+        .operatorBuilder(StringUtils.toUpperCase(name))\n+        .operandTypeChecker(new StringFormatOperandTypeChecker())\n+        .functionCategory(SqlFunctionCategory.STRING)\n+        .returnTypeNonNull(SqlTypeName.VARCHAR)\n+        .build();\n+\n+    this.name = name;\n+  }\n+\n+  @Override\n+  public SqlOperator calciteOperator()\n+  {\n+    return sqlFunction;\n+  }\n+\n+  @Override\n+  public DruidExpression toDruidExpression(\n+      final PlannerContext plannerContext,\n+      final RowSignature rowSignature,\n+      final RexNode rexNode\n+  )\n+  {\n+    return OperatorConversions.convertCall(plannerContext, rowSignature, rexNode, name);\n+  }\n+\n+  private static class StringFormatOperandTypeChecker implements SqlOperandTypeChecker\n+  {\n+    @Override\n+    public boolean checkOperandTypes(SqlCallBinding callBinding, boolean throwOnFailure)\n+    {\n+      final RelDataType firstArgType = callBinding.getOperandType(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3NDIyMg=="}, "originalCommit": null, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2Mjk5NjkxOnYy", "diffSide": "RIGHT", "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwOTo1NzoxMVrOH_Jazw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwNzoyMzowM1rOIAZDcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3NjY1NQ==", "bodyText": "should this be?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .virtualColumns(expressionVirtualColumn(\"v0\", \"'44.61KiB'\", ValueType.STRING),\n          \n          \n            \n                            .virtualColumns(expressionVirtualColumn(\"v0\", \"binary_date_format(45678)\", ValueType.STRING),", "url": "https://github.com/apache/druid/pull/10635#discussion_r535976655", "createdAt": "2020-12-04T09:57:11Z", "author": {"login": "abhishekagarwal87"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -16153,6 +16161,44 @@ public void testTimeStampAddConversion() throws Exception\n     );\n   }\n \n+  public void testSizeFormatFunction() throws Exception\n+  {\n+    testQuery(\n+        \"SELECT m1, \"\n+        + \"BINARY_BYTE_FORMAT(45678),\"\n+        + \"BINARY_BYTE_FORMAT(m1*12345),\"\n+        + \"BINARY_BYTE_FORMAT(m1*12345, 0), \"\n+        + \"DECIMAL_BYTE_FORMAT(m1*12345), \"\n+        + \"DECIMAL_FORMAT(m1*12345) \"\n+        + \"FROM numfoo WHERE f1 = 0.1 LIMIT 1\",\n+        ImmutableList.of(\n+            newScanQueryBuilder()\n+                .dataSource(CalciteTests.DATASOURCE3)\n+                .intervals(querySegmentSpec(Filtration.eternity()))\n+                .virtualColumns(expressionVirtualColumn(\"v0\", \"'44.61KiB'\", ValueType.STRING),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI0MzY1MA==", "bodyText": "This is a special case. I also thought it should a function call expression here. But because the given argument is a constant, this function call has been calculated during SQL parsing phase before converting to native sql. I've added some comments in the latest commit here.", "url": "https://github.com/apache/druid/pull/10635#discussion_r537243650", "createdAt": "2020-12-07T05:38:14Z", "author": {"login": "FrankChen021"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -16153,6 +16161,44 @@ public void testTimeStampAddConversion() throws Exception\n     );\n   }\n \n+  public void testSizeFormatFunction() throws Exception\n+  {\n+    testQuery(\n+        \"SELECT m1, \"\n+        + \"BINARY_BYTE_FORMAT(45678),\"\n+        + \"BINARY_BYTE_FORMAT(m1*12345),\"\n+        + \"BINARY_BYTE_FORMAT(m1*12345, 0), \"\n+        + \"DECIMAL_BYTE_FORMAT(m1*12345), \"\n+        + \"DECIMAL_FORMAT(m1*12345) \"\n+        + \"FROM numfoo WHERE f1 = 0.1 LIMIT 1\",\n+        ImmutableList.of(\n+            newScanQueryBuilder()\n+                .dataSource(CalciteTests.DATASOURCE3)\n+                .intervals(querySegmentSpec(Filtration.eternity()))\n+                .virtualColumns(expressionVirtualColumn(\"v0\", \"'44.61KiB'\", ValueType.STRING),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3NjY1NQ=="}, "originalCommit": null, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI4MTM5NA==", "bodyText": "\ud83d\udc4d  Thanks for clarifying", "url": "https://github.com/apache/druid/pull/10635#discussion_r537281394", "createdAt": "2020-12-07T07:23:03Z", "author": {"login": "abhishekagarwal87"}, "path": "sql/src/test/java/org/apache/druid/sql/calcite/CalciteQueryTest.java", "diffHunk": "@@ -16153,6 +16161,44 @@ public void testTimeStampAddConversion() throws Exception\n     );\n   }\n \n+  public void testSizeFormatFunction() throws Exception\n+  {\n+    testQuery(\n+        \"SELECT m1, \"\n+        + \"BINARY_BYTE_FORMAT(45678),\"\n+        + \"BINARY_BYTE_FORMAT(m1*12345),\"\n+        + \"BINARY_BYTE_FORMAT(m1*12345, 0), \"\n+        + \"DECIMAL_BYTE_FORMAT(m1*12345), \"\n+        + \"DECIMAL_FORMAT(m1*12345) \"\n+        + \"FROM numfoo WHERE f1 = 0.1 LIMIT 1\",\n+        ImmutableList.of(\n+            newScanQueryBuilder()\n+                .dataSource(CalciteTests.DATASOURCE3)\n+                .intervals(querySegmentSpec(Filtration.eternity()))\n+                .virtualColumns(expressionVirtualColumn(\"v0\", \"'44.61KiB'\", ValueType.STRING),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk3NjY1NQ=="}, "originalCommit": null, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzA1NjU3OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/druid/java/util/common/HumanReadableBytesTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMDoxMToxOFrOH_J94w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwNTozOTo0N1rOIAWyBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NTYzNQ==", "bodyText": "in this particular scenario, should space be appended?", "url": "https://github.com/apache/druid/pull/10635#discussion_r535985635", "createdAt": "2020-12-04T10:11:18Z", "author": {"login": "abhishekagarwal87"}, "path": "core/src/test/java/org/apache/druid/java/util/common/HumanReadableBytesTest.java", "diffHunk": "@@ -395,6 +395,107 @@ public void testBytesRange()\n     Assert.assertEquals(\"value must be in the range of [0, 5]\", message);\n   }\n \n+  @Test\n+  public void testFormatInBinaryByte()\n+  {\n+    Assert.assertEquals(\"-8.00 EiB\", HumanReadableBytes.format(Long.MIN_VALUE, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"-8.000 EiB\", HumanReadableBytes.format(Long.MIN_VALUE, 3, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+\n+    Assert.assertEquals(\"-2.00 GiB\", HumanReadableBytes.format(Integer.MIN_VALUE, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"-32.00 KiB\", HumanReadableBytes.format(Short.MIN_VALUE, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"-128.00 B\", HumanReadableBytes.format(Byte.MIN_VALUE, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"-1.00 B\", HumanReadableBytes.format(-1, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"0.00 B\", HumanReadableBytes.format(0, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 B\", HumanReadableBytes.format(1, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 KiB\", HumanReadableBytes.format(1024L, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 MiB\", HumanReadableBytes.format(1024L * 1024, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 GiB\", HumanReadableBytes.format(1024L * 1024 * 1024, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 TiB\", HumanReadableBytes.format(1024L * 1024 * 1024 * 1024, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 PiB\", HumanReadableBytes.format(1024L * 1024 * 1024 * 1024 * 1024, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"8.00 EiB\", HumanReadableBytes.format(Long.MAX_VALUE, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+  }\n+\n+  @Test\n+  public void testPrecisionInBinaryFormat()\n+  {\n+    Assert.assertEquals(\"1 KiB\", HumanReadableBytes.format(1500, 0, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.5 KiB\", HumanReadableBytes.format(1500, 1, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.46 KiB\", HumanReadableBytes.format(1500, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.465 KiB\", HumanReadableBytes.format(1500, 3, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+  }\n+\n+  @Test\n+  public void testPrecisionInDecimalFormat()\n+  {\n+    Assert.assertEquals(\"1 KB\", HumanReadableBytes.format(1456, 0, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.5 KB\", HumanReadableBytes.format(1456, 1, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.46 KB\", HumanReadableBytes.format(1456, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.456 KB\", HumanReadableBytes.format(1456, 3, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+  }\n+\n+  @Test\n+  public void testFormatInDecimalByte()\n+  {\n+    Assert.assertEquals(\"1.00 B\", HumanReadableBytes.format(1, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.00 KB\", HumanReadableBytes.format(1000L, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.00 MB\", HumanReadableBytes.format(1000L * 1000, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.00 GB\", HumanReadableBytes.format(1000L * 1000 * 1000, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.00 TB\", HumanReadableBytes.format(1000L * 1000 * 1000 * 1000, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.00 PB\", HumanReadableBytes.format(1000L * 1000 * 1000 * 1000 * 1000, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"9.22 EB\", HumanReadableBytes.format(Long.MAX_VALUE, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+\n+    Assert.assertEquals(\"100.00 KB\", HumanReadableBytes.format(99999, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"99.999 KB\", HumanReadableBytes.format(99999, 3, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+\n+    Assert.assertEquals(\"999.9 PB\", HumanReadableBytes.format(999_949_999_999_999_999L, 1, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"999.95 PB\", HumanReadableBytes.format(999_949_999_999_999_999L, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"999.949 PB\", HumanReadableBytes.format(999_949_999_999_999_999L, 3, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+  }\n+\n+  @Test\n+  public void testFormatInDecimal()\n+  {\n+    Assert.assertEquals(\"1.00 \", HumanReadableBytes.format(1, 2, HumanReadableBytes.UnitSystem.DECIMAL, true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI0NDE2NQ==", "bodyText": "This special case has been handled in the latest commit.", "url": "https://github.com/apache/druid/pull/10635#discussion_r537244165", "createdAt": "2020-12-07T05:39:47Z", "author": {"login": "FrankChen021"}, "path": "core/src/test/java/org/apache/druid/java/util/common/HumanReadableBytesTest.java", "diffHunk": "@@ -395,6 +395,107 @@ public void testBytesRange()\n     Assert.assertEquals(\"value must be in the range of [0, 5]\", message);\n   }\n \n+  @Test\n+  public void testFormatInBinaryByte()\n+  {\n+    Assert.assertEquals(\"-8.00 EiB\", HumanReadableBytes.format(Long.MIN_VALUE, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"-8.000 EiB\", HumanReadableBytes.format(Long.MIN_VALUE, 3, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+\n+    Assert.assertEquals(\"-2.00 GiB\", HumanReadableBytes.format(Integer.MIN_VALUE, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"-32.00 KiB\", HumanReadableBytes.format(Short.MIN_VALUE, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"-128.00 B\", HumanReadableBytes.format(Byte.MIN_VALUE, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"-1.00 B\", HumanReadableBytes.format(-1, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"0.00 B\", HumanReadableBytes.format(0, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 B\", HumanReadableBytes.format(1, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 KiB\", HumanReadableBytes.format(1024L, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 MiB\", HumanReadableBytes.format(1024L * 1024, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 GiB\", HumanReadableBytes.format(1024L * 1024 * 1024, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 TiB\", HumanReadableBytes.format(1024L * 1024 * 1024 * 1024, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.00 PiB\", HumanReadableBytes.format(1024L * 1024 * 1024 * 1024 * 1024, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"8.00 EiB\", HumanReadableBytes.format(Long.MAX_VALUE, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+  }\n+\n+  @Test\n+  public void testPrecisionInBinaryFormat()\n+  {\n+    Assert.assertEquals(\"1 KiB\", HumanReadableBytes.format(1500, 0, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.5 KiB\", HumanReadableBytes.format(1500, 1, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.46 KiB\", HumanReadableBytes.format(1500, 2, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+    Assert.assertEquals(\"1.465 KiB\", HumanReadableBytes.format(1500, 3, HumanReadableBytes.UnitSystem.BINARY_BYTE, true));\n+  }\n+\n+  @Test\n+  public void testPrecisionInDecimalFormat()\n+  {\n+    Assert.assertEquals(\"1 KB\", HumanReadableBytes.format(1456, 0, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.5 KB\", HumanReadableBytes.format(1456, 1, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.46 KB\", HumanReadableBytes.format(1456, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.456 KB\", HumanReadableBytes.format(1456, 3, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+  }\n+\n+  @Test\n+  public void testFormatInDecimalByte()\n+  {\n+    Assert.assertEquals(\"1.00 B\", HumanReadableBytes.format(1, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.00 KB\", HumanReadableBytes.format(1000L, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.00 MB\", HumanReadableBytes.format(1000L * 1000, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.00 GB\", HumanReadableBytes.format(1000L * 1000 * 1000, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.00 TB\", HumanReadableBytes.format(1000L * 1000 * 1000 * 1000, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"1.00 PB\", HumanReadableBytes.format(1000L * 1000 * 1000 * 1000 * 1000, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"9.22 EB\", HumanReadableBytes.format(Long.MAX_VALUE, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+\n+    Assert.assertEquals(\"100.00 KB\", HumanReadableBytes.format(99999, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"99.999 KB\", HumanReadableBytes.format(99999, 3, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+\n+    Assert.assertEquals(\"999.9 PB\", HumanReadableBytes.format(999_949_999_999_999_999L, 1, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"999.95 PB\", HumanReadableBytes.format(999_949_999_999_999_999L, 2, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+    Assert.assertEquals(\"999.949 PB\", HumanReadableBytes.format(999_949_999_999_999_999L, 3, HumanReadableBytes.UnitSystem.DECIMAL_BYTE, true));\n+  }\n+\n+  @Test\n+  public void testFormatInDecimal()\n+  {\n+    Assert.assertEquals(\"1.00 \", HumanReadableBytes.format(1, 2, HumanReadableBytes.UnitSystem.DECIMAL, true));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NTYzNQ=="}, "originalCommit": null, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MzA2MzQyOnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/druid/java/util/common/HumanReadableBytes.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQxMDoxMjo0NFrOH_KBvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwOTo0NTo1N1rOIAeMMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NjYyMg==", "bodyText": "is the hasSpace customizable from outside? May be it can be just hard-coded to true.", "url": "https://github.com/apache/druid/pull/10635#discussion_r535986622", "createdAt": "2020-12-04T10:12:44Z", "author": {"login": "abhishekagarwal87"}, "path": "core/src/main/java/org/apache/druid/java/util/common/HumanReadableBytes.java", "diffHunk": "@@ -208,4 +208,108 @@ private static long parseInner(String rawNumber)\n       throw new IAE(\"Invalid format or out of range of long: %s\", rawNumber);\n     }\n   }\n+\n+  public enum UnitSystem\n+  {\n+    /**\n+     * also known as IEC format\n+     * eg: B, KiB, MiB, GiB ...\n+     */\n+    BINARY_BYTE,\n+\n+    /**\n+     * also known as SI format\n+     * eg: B, KB, MB ...\n+     */\n+    DECIMAL_BYTE,\n+\n+    /**\n+     * simplified SI format without 'B' indicator\n+     * eg: K, M, G ...\n+     */\n+    DECIMAL\n+  }\n+\n+  /**\n+   * Returns a human-readable string version of input value\n+   *\n+   * @param bytes      input value. Negative value is also allowed\n+   * @param precision  [0,3]\n+   * @param unitSystem which unit system is adopted to format the input value, see {@link UnitSystem}\n+   * @param hasSpace   if it's true, there's an extra space between the number and the unit suffix\n+   */\n+  public static String format(long bytes, int precision, UnitSystem unitSystem, boolean hasSpace)", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI0NDk3Mw==", "bodyText": "We intended to expose this parameter at the SQL/native query level at first, but found that this parameter is not so vital. So we still keep it in the underlying implementation but hide it from the SQL level.", "url": "https://github.com/apache/druid/pull/10635#discussion_r537244973", "createdAt": "2020-12-07T05:42:21Z", "author": {"login": "FrankChen021"}, "path": "core/src/main/java/org/apache/druid/java/util/common/HumanReadableBytes.java", "diffHunk": "@@ -208,4 +208,108 @@ private static long parseInner(String rawNumber)\n       throw new IAE(\"Invalid format or out of range of long: %s\", rawNumber);\n     }\n   }\n+\n+  public enum UnitSystem\n+  {\n+    /**\n+     * also known as IEC format\n+     * eg: B, KiB, MiB, GiB ...\n+     */\n+    BINARY_BYTE,\n+\n+    /**\n+     * also known as SI format\n+     * eg: B, KB, MB ...\n+     */\n+    DECIMAL_BYTE,\n+\n+    /**\n+     * simplified SI format without 'B' indicator\n+     * eg: K, M, G ...\n+     */\n+    DECIMAL\n+  }\n+\n+  /**\n+   * Returns a human-readable string version of input value\n+   *\n+   * @param bytes      input value. Negative value is also allowed\n+   * @param precision  [0,3]\n+   * @param unitSystem which unit system is adopted to format the input value, see {@link UnitSystem}\n+   * @param hasSpace   if it's true, there's an extra space between the number and the unit suffix\n+   */\n+  public static String format(long bytes, int precision, UnitSystem unitSystem, boolean hasSpace)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NjYyMg=="}, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzI4MDc0Mg==", "bodyText": "IMO it's more of a dead param then and should be removed. It can be added back if druid ever exposes hasSpace to user in future.", "url": "https://github.com/apache/druid/pull/10635#discussion_r537280742", "createdAt": "2020-12-07T07:21:37Z", "author": {"login": "abhishekagarwal87"}, "path": "core/src/main/java/org/apache/druid/java/util/common/HumanReadableBytes.java", "diffHunk": "@@ -208,4 +208,108 @@ private static long parseInner(String rawNumber)\n       throw new IAE(\"Invalid format or out of range of long: %s\", rawNumber);\n     }\n   }\n+\n+  public enum UnitSystem\n+  {\n+    /**\n+     * also known as IEC format\n+     * eg: B, KiB, MiB, GiB ...\n+     */\n+    BINARY_BYTE,\n+\n+    /**\n+     * also known as SI format\n+     * eg: B, KB, MB ...\n+     */\n+    DECIMAL_BYTE,\n+\n+    /**\n+     * simplified SI format without 'B' indicator\n+     * eg: K, M, G ...\n+     */\n+    DECIMAL\n+  }\n+\n+  /**\n+   * Returns a human-readable string version of input value\n+   *\n+   * @param bytes      input value. Negative value is also allowed\n+   * @param precision  [0,3]\n+   * @param unitSystem which unit system is adopted to format the input value, see {@link UnitSystem}\n+   * @param hasSpace   if it's true, there's an extra space between the number and the unit suffix\n+   */\n+  public static String format(long bytes, int precision, UnitSystem unitSystem, boolean hasSpace)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NjYyMg=="}, "originalCommit": null, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM2NTU1NQ==", "bodyText": "OK. It's been deleted.", "url": "https://github.com/apache/druid/pull/10635#discussion_r537365555", "createdAt": "2020-12-07T09:45:57Z", "author": {"login": "FrankChen021"}, "path": "core/src/main/java/org/apache/druid/java/util/common/HumanReadableBytes.java", "diffHunk": "@@ -208,4 +208,108 @@ private static long parseInner(String rawNumber)\n       throw new IAE(\"Invalid format or out of range of long: %s\", rawNumber);\n     }\n   }\n+\n+  public enum UnitSystem\n+  {\n+    /**\n+     * also known as IEC format\n+     * eg: B, KiB, MiB, GiB ...\n+     */\n+    BINARY_BYTE,\n+\n+    /**\n+     * also known as SI format\n+     * eg: B, KB, MB ...\n+     */\n+    DECIMAL_BYTE,\n+\n+    /**\n+     * simplified SI format without 'B' indicator\n+     * eg: K, M, G ...\n+     */\n+    DECIMAL\n+  }\n+\n+  /**\n+   * Returns a human-readable string version of input value\n+   *\n+   * @param bytes      input value. Negative value is also allowed\n+   * @param precision  [0,3]\n+   * @param unitSystem which unit system is adopted to format the input value, see {@link UnitSystem}\n+   * @param hasSpace   if it's true, there's an extra space between the number and the unit suffix\n+   */\n+  public static String format(long bytes, int precision, UnitSystem unitSystem, boolean hasSpace)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NjYyMg=="}, "originalCommit": null, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Nzg4MzI1OnYy", "diffSide": "RIGHT", "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNjowMjo1M1rOIBIeZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxMDo1NjowMFrOICOlEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1ODM0Mg==", "bodyText": "Since we are calling asLong without checking isNumericNull of the ExprEval, we are ignoring the value of druid.generic.useDefaultValueForNull here, which I think is incorrect and this should return null instead.\nThinking out loud, how should this function behave with non-long inputs?\nThe way this is currently implement:\n\nInputs of ExprType.DOUBLE will be cast to a ExprType.LONG before conversion.\nFor ExprType.STRING inputs, if they are number-ish strings, they will be parsed into long values, but if not asLong will always be 0.\n\nI don't know that this behavior is incorrect, I just wanted to call it out to think about it.\nI do think we want to check for isNumericNull and return ExprEval.of(null) if NullHandling.sqlCompatible() is set, for any input types.\nI see in the SQL operator it looks like it strictly validates that the inputs are numeric, while Druid native expressions have traditionally been a bit fast and loose about the inputs they accept and tend to be rather forgiving, so perhaps this is ok that the behavior here doesn't quite match.", "url": "https://github.com/apache/druid/pull/10635#discussion_r538058342", "createdAt": "2020-12-08T06:02:53Z", "author": {"login": "clintropolis"}, "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -3275,4 +3276,86 @@ public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n       return l.stream();\n     }\n   }\n+\n+  abstract class SizeFormatFunc implements Function\n+  {\n+    protected abstract HumanReadableBytes.UnitSystem getUnitSystem();\n+\n+    /**\n+     * Evaluate given expression\n+     * By default, 'precision' is 2 and 'hasSpace' is false\n+     */\n+    @Override\n+    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n+    {\n+      final long bytes = args.get(0).eval(bindings).asLong();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE1MDUxMg==", "bodyText": "good point. I'll make some improvement here.", "url": "https://github.com/apache/druid/pull/10635#discussion_r538150512", "createdAt": "2020-12-08T08:54:21Z", "author": {"login": "FrankChen021"}, "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -3275,4 +3276,86 @@ public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n       return l.stream();\n     }\n   }\n+\n+  abstract class SizeFormatFunc implements Function\n+  {\n+    protected abstract HumanReadableBytes.UnitSystem getUnitSystem();\n+\n+    /**\n+     * Evaluate given expression\n+     * By default, 'precision' is 2 and 'hasSpace' is false\n+     */\n+    @Override\n+    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n+    {\n+      final long bytes = args.get(0).eval(bindings).asLong();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1ODM0Mg=="}, "originalCommit": null, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTIwNjkzMQ==", "bodyText": "Hi @clintropolis , null and type handling has been improved in the latest commit. Please check it at your convenience.", "url": "https://github.com/apache/druid/pull/10635#discussion_r539206931", "createdAt": "2020-12-09T10:56:00Z", "author": {"login": "FrankChen021"}, "path": "core/src/main/java/org/apache/druid/math/expr/Function.java", "diffHunk": "@@ -3275,4 +3276,86 @@ public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n       return l.stream();\n     }\n   }\n+\n+  abstract class SizeFormatFunc implements Function\n+  {\n+    protected abstract HumanReadableBytes.UnitSystem getUnitSystem();\n+\n+    /**\n+     * Evaluate given expression\n+     * By default, 'precision' is 2 and 'hasSpace' is false\n+     */\n+    @Override\n+    public ExprEval apply(List<Expr> args, Expr.ObjectBinding bindings)\n+    {\n+      final long bytes = args.get(0).eval(bindings).asLong();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1ODM0Mg=="}, "originalCommit": null, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3Nzg5MjkyOnYy", "diffSide": "RIGHT", "path": "docs/querying/sql.md", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwNjowNjo1N1rOIBIjqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOFQyMjozMDowMFrOIQjZ0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1OTY5MQ==", "bodyText": "Should these docs live with the 'numeric' functions? I suppose here is ok too...", "url": "https://github.com/apache/druid/pull/10635#discussion_r538059691", "createdAt": "2020-12-08T06:06:57Z", "author": {"login": "clintropolis"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -563,6 +563,9 @@ The [DataSketches extension](../development/extensions-core/datasketches-extensi\n |`COALESCE(value1, value2, ...)`|Returns the first value that is neither NULL nor empty string.|\n |`NVL(expr,expr-for-null)`|Returns 'expr-for-null' if 'expr' is null (or empty string for string type).|\n |`BLOOM_FILTER_TEST(<expr>, <serialized-filter>)`|Returns true if the value is contained in a Base64-serialized bloom filter. See the [Bloom filter extension](../development/extensions-core/bloom-filter.html) documentation for additional details.|\n+|`BINARY_BYTE_FORMAT(value, [precision])`|Returns the value in human-readable [IEC](https://en.wikipedia.org/wiki/Binary_prefix) format. Supported unit suffix: `B`, `KiB`, `MiB`, `GiB`, `TiB`, `PiB`, `EiB`. `precision` must be in the range of [0,3] (default: 2).|\n+|`DECIMAL_BYTE_FORMAT(value, [precision])`|Returns the value in human-readable [SI](https://en.wikipedia.org/wiki/Binary_prefix) format. Supported unit suffix: `B`, `KB`, `MB`, `GB`, `TB`, `PB`, `EB`. `precision` must be in the range of [0,3] (default: 2).|\n+|`DECIMAL_FORMAT(value, [precision])`|Returns the value in human-readable SI format. Supported unit suffix: `K`, `M`, `G`, `T`, `P`, `E`. `precision` must be in the range of [0,3] (default: 2).|", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE0ODc0MA==", "bodyText": "I see all existing numeric functions are all about mathematical computation, the input parameter and output result are all type of integer or float.  The new functions in this PR are a little bit different from those, I don't whether it's suitable to put them in 'numeric function' section, so I put them in a separated section.", "url": "https://github.com/apache/druid/pull/10635#discussion_r538148740", "createdAt": "2020-12-08T08:51:42Z", "author": {"login": "FrankChen021"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -563,6 +563,9 @@ The [DataSketches extension](../development/extensions-core/datasketches-extensi\n |`COALESCE(value1, value2, ...)`|Returns the first value that is neither NULL nor empty string.|\n |`NVL(expr,expr-for-null)`|Returns 'expr-for-null' if 'expr' is null (or empty string for string type).|\n |`BLOOM_FILTER_TEST(<expr>, <serialized-filter>)`|Returns true if the value is contained in a Base64-serialized bloom filter. See the [Bloom filter extension](../development/extensions-core/bloom-filter.html) documentation for additional details.|\n+|`BINARY_BYTE_FORMAT(value, [precision])`|Returns the value in human-readable [IEC](https://en.wikipedia.org/wiki/Binary_prefix) format. Supported unit suffix: `B`, `KiB`, `MiB`, `GiB`, `TiB`, `PiB`, `EiB`. `precision` must be in the range of [0,3] (default: 2).|\n+|`DECIMAL_BYTE_FORMAT(value, [precision])`|Returns the value in human-readable [SI](https://en.wikipedia.org/wiki/Binary_prefix) format. Supported unit suffix: `B`, `KB`, `MB`, `GB`, `TB`, `PB`, `EB`. `precision` must be in the range of [0,3] (default: 2).|\n+|`DECIMAL_FORMAT(value, [precision])`|Returns the value in human-readable SI format. Supported unit suffix: `K`, `M`, `G`, `T`, `P`, `E`. `precision` must be in the range of [0,3] (default: 2).|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1OTY5MQ=="}, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE1NTEyMg==", "bodyText": "yeah, i guess in the native expression version of this document the section is called math functions or something like that", "url": "https://github.com/apache/druid/pull/10635#discussion_r538155122", "createdAt": "2020-12-08T09:00:52Z", "author": {"login": "clintropolis"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -563,6 +563,9 @@ The [DataSketches extension](../development/extensions-core/datasketches-extensi\n |`COALESCE(value1, value2, ...)`|Returns the first value that is neither NULL nor empty string.|\n |`NVL(expr,expr-for-null)`|Returns 'expr-for-null' if 'expr' is null (or empty string for string type).|\n |`BLOOM_FILTER_TEST(<expr>, <serialized-filter>)`|Returns true if the value is contained in a Base64-serialized bloom filter. See the [Bloom filter extension](../development/extensions-core/bloom-filter.html) documentation for additional details.|\n+|`BINARY_BYTE_FORMAT(value, [precision])`|Returns the value in human-readable [IEC](https://en.wikipedia.org/wiki/Binary_prefix) format. Supported unit suffix: `B`, `KiB`, `MiB`, `GiB`, `TiB`, `PiB`, `EiB`. `precision` must be in the range of [0,3] (default: 2).|\n+|`DECIMAL_BYTE_FORMAT(value, [precision])`|Returns the value in human-readable [SI](https://en.wikipedia.org/wiki/Binary_prefix) format. Supported unit suffix: `B`, `KB`, `MB`, `GB`, `TB`, `PB`, `EB`. `precision` must be in the range of [0,3] (default: 2).|\n+|`DECIMAL_FORMAT(value, [precision])`|Returns the value in human-readable SI format. Supported unit suffix: `K`, `M`, `G`, `T`, `P`, `E`. `precision` must be in the range of [0,3] (default: 2).|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1OTY5MQ=="}, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDIyODE3OA==", "bodyText": "I think they make sense in the numeric section, because they accept numbers. It's OK that they don't return numbers. It's analogous to TIME_FORMAT, which still belongs in the time section.", "url": "https://github.com/apache/druid/pull/10635#discussion_r554228178", "createdAt": "2021-01-08T22:30:00Z", "author": {"login": "gianm"}, "path": "docs/querying/sql.md", "diffHunk": "@@ -563,6 +563,9 @@ The [DataSketches extension](../development/extensions-core/datasketches-extensi\n |`COALESCE(value1, value2, ...)`|Returns the first value that is neither NULL nor empty string.|\n |`NVL(expr,expr-for-null)`|Returns 'expr-for-null' if 'expr' is null (or empty string for string type).|\n |`BLOOM_FILTER_TEST(<expr>, <serialized-filter>)`|Returns true if the value is contained in a Base64-serialized bloom filter. See the [Bloom filter extension](../development/extensions-core/bloom-filter.html) documentation for additional details.|\n+|`BINARY_BYTE_FORMAT(value, [precision])`|Returns the value in human-readable [IEC](https://en.wikipedia.org/wiki/Binary_prefix) format. Supported unit suffix: `B`, `KiB`, `MiB`, `GiB`, `TiB`, `PiB`, `EiB`. `precision` must be in the range of [0,3] (default: 2).|\n+|`DECIMAL_BYTE_FORMAT(value, [precision])`|Returns the value in human-readable [SI](https://en.wikipedia.org/wiki/Binary_prefix) format. Supported unit suffix: `B`, `KB`, `MB`, `GB`, `TB`, `PB`, `EB`. `precision` must be in the range of [0,3] (default: 2).|\n+|`DECIMAL_FORMAT(value, [precision])`|Returns the value in human-readable SI format. Supported unit suffix: `K`, `M`, `G`, `T`, `P`, `E`. `precision` must be in the range of [0,3] (default: 2).|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODA1OTY5MQ=="}, "originalCommit": null, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MjU0NDg3OnYy", "diffSide": "RIGHT", "path": "core/src/test/java/org/apache/druid/math/expr/FunctionTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMToyODo1NlrOIKJthg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwNTo0MTowMVrOIOKwbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxNTc4Mg==", "bodyText": "All unit tests are run with both values of druid.generic.useDefaultValueForNull, so it isn't necessary to explicitly configure it. What we typically do is try to just write the test to check for the mode and adjust the expectation accordingly, e.g. to use another example from this file\nassertExpr(\"lpad(x, 2, '')\", NullHandling.replaceWithDefault() ? null : \"fo\");", "url": "https://github.com/apache/druid/pull/10635#discussion_r547515782", "createdAt": "2020-12-22T21:28:56Z", "author": {"login": "clintropolis"}, "path": "core/src/test/java/org/apache/druid/math/expr/FunctionTest.java", "diffHunk": "@@ -519,6 +525,203 @@ public void testLeast()\n     assertExpr(\"least(1, null, 'A')\", \"1\");\n   }\n \n+  @Test\n+  public void testSizeFormat()\n+  {\n+    assertExpr(\"binary_byte_format(-1024)\", \"-1.00 KiB\");\n+    assertExpr(\"binary_byte_format(1024)\", \"1.00 KiB\");\n+    assertExpr(\"binary_byte_format(1024*1024)\", \"1.00 MiB\");\n+    assertExpr(\"binary_byte_format(1024*1024*1024)\", \"1.00 GiB\");\n+    assertExpr(\"binary_byte_format(1024*1024*1024*1024)\", \"1.00 TiB\");\n+    assertExpr(\"binary_byte_format(1024*1024*1024*1024*1024)\", \"1.00 PiB\");\n+\n+    assertExpr(\"decimal_byte_format(-1000)\", \"-1.00 KB\");\n+    assertExpr(\"decimal_byte_format(1000)\", \"1.00 KB\");\n+    assertExpr(\"decimal_byte_format(1000*1000)\", \"1.00 MB\");\n+    assertExpr(\"decimal_byte_format(1000*1000*1000)\", \"1.00 GB\");\n+    assertExpr(\"decimal_byte_format(1000*1000*1000*1000)\", \"1.00 TB\");\n+\n+    assertExpr(\"decimal_format(-1000)\", \"-1.00 K\");\n+    assertExpr(\"decimal_format(1000)\", \"1.00 K\");\n+    assertExpr(\"decimal_format(1000*1000)\", \"1.00 M\");\n+    assertExpr(\"decimal_format(1000*1000*1000)\", \"1.00 G\");\n+    assertExpr(\"decimal_format(1000*1000*1000*1000)\", \"1.00 T\");\n+  }\n+\n+  @Test\n+  public void testSizeFormatWithDifferentPrecision()\n+  {\n+    assertExpr(\"binary_byte_format(1024, 0)\", \"1 KiB\");\n+    assertExpr(\"binary_byte_format(1024*1024, 1)\", \"1.0 MiB\");\n+    assertExpr(\"binary_byte_format(1024*1024*1024, 2)\", \"1.00 GiB\");\n+    assertExpr(\"binary_byte_format(1024*1024*1024*1024, 3)\", \"1.000 TiB\");\n+\n+    assertExpr(\"decimal_byte_format(1234, 0)\", \"1 KB\");\n+    assertExpr(\"decimal_byte_format(1234*1000, 1)\", \"1.2 MB\");\n+    assertExpr(\"decimal_byte_format(1234*1000*1000, 2)\", \"1.23 GB\");\n+    assertExpr(\"decimal_byte_format(1234*1000*1000*1000, 3)\", \"1.234 TB\");\n+\n+    assertExpr(\"decimal_format(1234, 0)\", \"1 K\");\n+    assertExpr(\"decimal_format(1234*1000,1)\", \"1.2 M\");\n+    assertExpr(\"decimal_format(1234*1000*1000,2)\", \"1.23 G\");\n+    assertExpr(\"decimal_format(1234*1000*1000*1000,3)\", \"1.234 T\");\n+  }\n+\n+  @Test\n+  public void testSizeFormatWithEdgeCases()\n+  {\n+    //a nonexist value is null which is treated as 0\n+    assertExpr(\"binary_byte_format(nonexist)\", \"0 B\");\n+\n+    //f = 12.34\n+    assertExpr(\"binary_byte_format(f)\", \"12 B\");\n+\n+    //nan is Double.NaN\n+    assertExpr(\"binary_byte_format(nan)\", \"0 B\");\n+\n+    //inf = Double.POSITIVE_INFINITY\n+    assertExpr(\"binary_byte_format(inf)\", \"8.00 EiB\");\n+\n+    //inf = Double.NEGATIVE_INFINITY\n+    assertExpr(\"binary_byte_format(-inf)\", \"-8.00 EiB\");\n+\n+    // o = 0\n+    assertExpr(\"binary_byte_format(o)\", \"0 B\");\n+\n+    // od = 0D\n+    assertExpr(\"binary_byte_format(od)\", \"0 B\");\n+\n+    // of = 0F\n+    assertExpr(\"binary_byte_format(of)\", \"0 B\");\n+  }\n+\n+  @Test\n+  public void testSizeForatInvalidArgumentType()\n+  {\n+    try {\n+      //x = \"foo\"\n+      Parser.parse(\"binary_byte_format(x)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+\n+      //must not go to here\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Function[binary_byte_format] needs a number as its first argument\", e.getMessage());\n+    }\n+\n+    try {\n+      //x = \"foo\"\n+      Parser.parse(\"binary_byte_format(1024, x)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+\n+      //must not go to here\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Function[binary_byte_format] needs an integer as its second argument\", e.getMessage());\n+    }\n+\n+    try {\n+      //of = 0F\n+      Parser.parse(\"binary_byte_format(1024, of)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+\n+      //must not go to here\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Function[binary_byte_format] needs an integer as its second argument\", e.getMessage());\n+    }\n+\n+    try {\n+      //of = 0F\n+      Parser.parse(\"binary_byte_format(1024, nonexist)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+\n+      //must not go to here\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Function[binary_byte_format] needs an integer as its second argument\", e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testSizeFormatInvalidPrecision()\n+  {\n+    try {\n+      Parser.parse(\"binary_byte_format(1024, maxLong)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Given precision[9223372036854775807] of Function[binary_byte_format] must be in the range of [0,3]\", e.getMessage());\n+    }\n+\n+    try {\n+      Parser.parse(\"binary_byte_format(1024, minLong)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Given precision[-9223372036854775808] of Function[binary_byte_format] must be in the range of [0,3]\", e.getMessage());\n+    }\n+\n+    try {\n+      Parser.parse(\"binary_byte_format(1024, -1)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Given precision[-1] of Function[binary_byte_format] must be in the range of [0,3]\", e.getMessage());\n+    }\n+\n+    try {\n+      Parser.parse(\"binary_byte_format(1024, 4)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Given precision[4] of Function[binary_byte_format] must be in the range of [0,3]\", e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testSizeFormatInvalidArgumentSize()\n+  {\n+    expectedException.expect(IAE.class);\n+    expectedException.expectMessage(\"Function[binary_byte_format] needs 1 or 2 arguments\");\n+    Parser.parse(\"binary_byte_format(1024, 2, 3)\", ExprMacroTable.nil())\n+          .eval(bindings);\n+  }\n+\n+  @Test\n+  public void testSizeFormatWithNoDefaultValueForNull()\n+  {\n+    NullHandling.updateForTests(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91e6a550ff8dbacae2d6da91262784df0a52d6c5"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTcyNzIxMw==", "bodyText": "MySQL ships a similar function format_bytes\nI struggled the two different approaches at first. And at last I chose to do it by 3 different functions. The reasons are,\n\n\ndifferent function names are more meaningful than different arguments for one function. Since there're 3 different unit systems in this PR, how to name them in a short enough way and without ambiguity is a big challenge. For example,  FORMAT(number, 'si'), FORMAT(number, 'dec'), si and dec are standard abbreviation and short enough but they're hard to understand; FORMAT(number, 'binary_byte'), it's clear enough, but it's not so simple compared to binary_byte_format(number)\n\n\nat the underlying layer, there are always different format functions, and if we provide one function at the user side, we have to do some checks on the format specifier and dispatch calls to those different functions. It's a little bit simple if different functions are provided.\n\n\nBut as you mentioned, there are also some drawbacks in this way. If the standard is to keep consistent with other databases or keep less numbers of functions exposed to users, maybe we need to combine these functions together.", "url": "https://github.com/apache/druid/pull/10635#discussion_r551727213", "createdAt": "2021-01-05T05:41:01Z", "author": {"login": "FrankChen021"}, "path": "core/src/test/java/org/apache/druid/math/expr/FunctionTest.java", "diffHunk": "@@ -519,6 +525,203 @@ public void testLeast()\n     assertExpr(\"least(1, null, 'A')\", \"1\");\n   }\n \n+  @Test\n+  public void testSizeFormat()\n+  {\n+    assertExpr(\"binary_byte_format(-1024)\", \"-1.00 KiB\");\n+    assertExpr(\"binary_byte_format(1024)\", \"1.00 KiB\");\n+    assertExpr(\"binary_byte_format(1024*1024)\", \"1.00 MiB\");\n+    assertExpr(\"binary_byte_format(1024*1024*1024)\", \"1.00 GiB\");\n+    assertExpr(\"binary_byte_format(1024*1024*1024*1024)\", \"1.00 TiB\");\n+    assertExpr(\"binary_byte_format(1024*1024*1024*1024*1024)\", \"1.00 PiB\");\n+\n+    assertExpr(\"decimal_byte_format(-1000)\", \"-1.00 KB\");\n+    assertExpr(\"decimal_byte_format(1000)\", \"1.00 KB\");\n+    assertExpr(\"decimal_byte_format(1000*1000)\", \"1.00 MB\");\n+    assertExpr(\"decimal_byte_format(1000*1000*1000)\", \"1.00 GB\");\n+    assertExpr(\"decimal_byte_format(1000*1000*1000*1000)\", \"1.00 TB\");\n+\n+    assertExpr(\"decimal_format(-1000)\", \"-1.00 K\");\n+    assertExpr(\"decimal_format(1000)\", \"1.00 K\");\n+    assertExpr(\"decimal_format(1000*1000)\", \"1.00 M\");\n+    assertExpr(\"decimal_format(1000*1000*1000)\", \"1.00 G\");\n+    assertExpr(\"decimal_format(1000*1000*1000*1000)\", \"1.00 T\");\n+  }\n+\n+  @Test\n+  public void testSizeFormatWithDifferentPrecision()\n+  {\n+    assertExpr(\"binary_byte_format(1024, 0)\", \"1 KiB\");\n+    assertExpr(\"binary_byte_format(1024*1024, 1)\", \"1.0 MiB\");\n+    assertExpr(\"binary_byte_format(1024*1024*1024, 2)\", \"1.00 GiB\");\n+    assertExpr(\"binary_byte_format(1024*1024*1024*1024, 3)\", \"1.000 TiB\");\n+\n+    assertExpr(\"decimal_byte_format(1234, 0)\", \"1 KB\");\n+    assertExpr(\"decimal_byte_format(1234*1000, 1)\", \"1.2 MB\");\n+    assertExpr(\"decimal_byte_format(1234*1000*1000, 2)\", \"1.23 GB\");\n+    assertExpr(\"decimal_byte_format(1234*1000*1000*1000, 3)\", \"1.234 TB\");\n+\n+    assertExpr(\"decimal_format(1234, 0)\", \"1 K\");\n+    assertExpr(\"decimal_format(1234*1000,1)\", \"1.2 M\");\n+    assertExpr(\"decimal_format(1234*1000*1000,2)\", \"1.23 G\");\n+    assertExpr(\"decimal_format(1234*1000*1000*1000,3)\", \"1.234 T\");\n+  }\n+\n+  @Test\n+  public void testSizeFormatWithEdgeCases()\n+  {\n+    //a nonexist value is null which is treated as 0\n+    assertExpr(\"binary_byte_format(nonexist)\", \"0 B\");\n+\n+    //f = 12.34\n+    assertExpr(\"binary_byte_format(f)\", \"12 B\");\n+\n+    //nan is Double.NaN\n+    assertExpr(\"binary_byte_format(nan)\", \"0 B\");\n+\n+    //inf = Double.POSITIVE_INFINITY\n+    assertExpr(\"binary_byte_format(inf)\", \"8.00 EiB\");\n+\n+    //inf = Double.NEGATIVE_INFINITY\n+    assertExpr(\"binary_byte_format(-inf)\", \"-8.00 EiB\");\n+\n+    // o = 0\n+    assertExpr(\"binary_byte_format(o)\", \"0 B\");\n+\n+    // od = 0D\n+    assertExpr(\"binary_byte_format(od)\", \"0 B\");\n+\n+    // of = 0F\n+    assertExpr(\"binary_byte_format(of)\", \"0 B\");\n+  }\n+\n+  @Test\n+  public void testSizeForatInvalidArgumentType()\n+  {\n+    try {\n+      //x = \"foo\"\n+      Parser.parse(\"binary_byte_format(x)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+\n+      //must not go to here\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Function[binary_byte_format] needs a number as its first argument\", e.getMessage());\n+    }\n+\n+    try {\n+      //x = \"foo\"\n+      Parser.parse(\"binary_byte_format(1024, x)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+\n+      //must not go to here\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Function[binary_byte_format] needs an integer as its second argument\", e.getMessage());\n+    }\n+\n+    try {\n+      //of = 0F\n+      Parser.parse(\"binary_byte_format(1024, of)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+\n+      //must not go to here\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Function[binary_byte_format] needs an integer as its second argument\", e.getMessage());\n+    }\n+\n+    try {\n+      //of = 0F\n+      Parser.parse(\"binary_byte_format(1024, nonexist)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+\n+      //must not go to here\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Function[binary_byte_format] needs an integer as its second argument\", e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testSizeFormatInvalidPrecision()\n+  {\n+    try {\n+      Parser.parse(\"binary_byte_format(1024, maxLong)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Given precision[9223372036854775807] of Function[binary_byte_format] must be in the range of [0,3]\", e.getMessage());\n+    }\n+\n+    try {\n+      Parser.parse(\"binary_byte_format(1024, minLong)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Given precision[-9223372036854775808] of Function[binary_byte_format] must be in the range of [0,3]\", e.getMessage());\n+    }\n+\n+    try {\n+      Parser.parse(\"binary_byte_format(1024, -1)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Given precision[-1] of Function[binary_byte_format] must be in the range of [0,3]\", e.getMessage());\n+    }\n+\n+    try {\n+      Parser.parse(\"binary_byte_format(1024, 4)\", ExprMacroTable.nil())\n+            .eval(bindings);\n+      Assert.assertTrue(false);\n+    }\n+    catch (IAE e) {\n+      Assert.assertEquals(\"Given precision[4] of Function[binary_byte_format] must be in the range of [0,3]\", e.getMessage());\n+    }\n+  }\n+\n+  @Test\n+  public void testSizeFormatInvalidArgumentSize()\n+  {\n+    expectedException.expect(IAE.class);\n+    expectedException.expectMessage(\"Function[binary_byte_format] needs 1 or 2 arguments\");\n+    Parser.parse(\"binary_byte_format(1024, 2, 3)\", ExprMacroTable.nil())\n+          .eval(bindings);\n+  }\n+\n+  @Test\n+  public void testSizeFormatWithNoDefaultValueForNull()\n+  {\n+    NullHandling.updateForTests(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUxNTc4Mg=="}, "originalCommit": {"oid": "91e6a550ff8dbacae2d6da91262784df0a52d6c5"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE2NjE2ODc2OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/HumanReadableFormatOperatorConversion.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yMlQxMDo0NToxOVrOJxtKDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yM1QwODo1MjowOVrOJydnzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NjA5OTg1Mg==", "bodyText": "this should use the recently added returnTypeCascadeNullable since it returns null if the input is null (see #11327)", "url": "https://github.com/apache/druid/pull/10635#discussion_r656099852", "createdAt": "2021-06-22T10:45:19Z", "author": {"login": "clintropolis"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/HumanReadableFormatOperatorConversion.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.OperatorConversions;\n+import org.apache.druid.sql.calcite.expression.SqlOperatorConversion;\n+import org.apache.druid.sql.calcite.planner.PlannerContext;\n+\n+public class HumanReadableFormatOperatorConversion implements SqlOperatorConversion\n+{\n+  public static final SqlOperatorConversion BINARY_BYTE_FORMAT = new HumanReadableFormatOperatorConversion(\"human_readable_binary_byte_format\");\n+  public static final SqlOperatorConversion DECIMAL_BYTE_FORMAT = new HumanReadableFormatOperatorConversion(\"human_readable_decimal_byte_format\");\n+  public static final SqlOperatorConversion DECIMAL_FORMAT = new HumanReadableFormatOperatorConversion(\"human_readable_decimal_format\");\n+\n+  private final String name;\n+  private final SqlFunction sqlFunction;\n+\n+  private HumanReadableFormatOperatorConversion(String name)\n+  {\n+    this.sqlFunction = OperatorConversions\n+        .operatorBuilder(StringUtils.toUpperCase(name))\n+        .operandTypeChecker(new HumanReadableFormatOperandTypeChecker())\n+        .functionCategory(SqlFunctionCategory.STRING)\n+        .returnTypeNonNull(SqlTypeName.VARCHAR)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81195458fda6bb3f1ff2f1d918d5bf87568e2699"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1Njg5MzkwMg==", "bodyText": "Fixed", "url": "https://github.com/apache/druid/pull/10635#discussion_r656893902", "createdAt": "2021-06-23T08:52:09Z", "author": {"login": "FrankChen021"}, "path": "sql/src/main/java/org/apache/druid/sql/calcite/expression/builtin/HumanReadableFormatOperatorConversion.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.sql.calcite.expression.builtin;\n+\n+import org.apache.calcite.rel.type.RelDataType;\n+import org.apache.calcite.rex.RexNode;\n+import org.apache.calcite.sql.SqlCallBinding;\n+import org.apache.calcite.sql.SqlFunction;\n+import org.apache.calcite.sql.SqlFunctionCategory;\n+import org.apache.calcite.sql.SqlOperandCountRange;\n+import org.apache.calcite.sql.SqlOperator;\n+import org.apache.calcite.sql.type.SqlOperandCountRanges;\n+import org.apache.calcite.sql.type.SqlOperandTypeChecker;\n+import org.apache.calcite.sql.type.SqlTypeName;\n+import org.apache.druid.java.util.common.StringUtils;\n+import org.apache.druid.segment.column.RowSignature;\n+import org.apache.druid.sql.calcite.expression.DruidExpression;\n+import org.apache.druid.sql.calcite.expression.OperatorConversions;\n+import org.apache.druid.sql.calcite.expression.SqlOperatorConversion;\n+import org.apache.druid.sql.calcite.planner.PlannerContext;\n+\n+public class HumanReadableFormatOperatorConversion implements SqlOperatorConversion\n+{\n+  public static final SqlOperatorConversion BINARY_BYTE_FORMAT = new HumanReadableFormatOperatorConversion(\"human_readable_binary_byte_format\");\n+  public static final SqlOperatorConversion DECIMAL_BYTE_FORMAT = new HumanReadableFormatOperatorConversion(\"human_readable_decimal_byte_format\");\n+  public static final SqlOperatorConversion DECIMAL_FORMAT = new HumanReadableFormatOperatorConversion(\"human_readable_decimal_format\");\n+\n+  private final String name;\n+  private final SqlFunction sqlFunction;\n+\n+  private HumanReadableFormatOperatorConversion(String name)\n+  {\n+    this.sqlFunction = OperatorConversions\n+        .operatorBuilder(StringUtils.toUpperCase(name))\n+        .operandTypeChecker(new HumanReadableFormatOperandTypeChecker())\n+        .functionCategory(SqlFunctionCategory.STRING)\n+        .returnTypeNonNull(SqlTypeName.VARCHAR)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1NjA5OTg1Mg=="}, "originalCommit": {"oid": "81195458fda6bb3f1ff2f1d918d5bf87568e2699"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE5NDQwOTA3OnYy", "diffSide": "RIGHT", "path": "docs/misc/math-expr.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yOVQwNzozNTo0OVrOJ1w-ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yOVQwNzozNTo0OVrOJ1w-ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDM1NjcxNA==", "bodyText": "@FrankChen021  can you add one example with a custom precision value? Maybe, one of these examples can be modified itself.", "url": "https://github.com/apache/druid/pull/10635#discussion_r660356714", "createdAt": "2021-06-29T07:35:49Z", "author": {"login": "abhishekagarwal87"}, "path": "docs/misc/math-expr.md", "diffHunk": "@@ -258,3 +258,12 @@ supported features:\n * math functions: `abs`, `acos`, `asin`, `atan`, `cbrt`, `ceil`, `cos`, `cosh`, `cot`, `exp`, `expm1`, `floor`, `getExponent`, `log`, `log10`, `log1p`, `nextUp`, `rint`, `signum`, `sin`, `sinh`, `sqrt`, `tan`, `tanh`, `toDegrees`, `toRadians`, `ulp`, `atan2`, `copySign`, `div`, `hypot`, `max`, `min`, `nextAfter`,  `pow`, `remainder`, `scalb` are supported for numeric types\n * time functions: `timestamp_floor` (with constant granularity argument) is supported for numeric types\n * other: `parse_long` is supported for numeric and string types\n+\n+\n+## Other functions\n+\n+| function | description |\n+| --- | --- |\n+| human_readable_binary_byte_format(value[, precision]) | Format a number in human-readable [IEC](https://en.wikipedia.org/wiki/Binary_prefix) format. For example, human_readable_binary_byte_format(1048576) returns `1.00 MiB`. `precision` must be in the range of [0,3] (default: 2). |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "27d9a41ade079ea807650adebf3fa5b6dbe806ba"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkNDE5NDkwNDcyOnYy", "diffSide": "RIGHT", "path": "docs/misc/math-expr.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yOVQwOToxNjoyNlrOJ11qsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNi0yOVQwOToxNzozOVrOJ11uTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDQzMzU4NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | human_readable_binary_byte_format(value[, precision]) | Format a number in human-readable [IEC](https://en.wikipedia.org/wiki/Binary_prefix) format. `precision` must be in the range of [0,3] (default: 2). For example:<li> human_readable_binary_byte_format(1048576) returns `1.00 MiB`</li><li>human_readable_binary_byte_format(1048576, 1) returns `1.000 MiB`</li> |\n          \n          \n            \n            | human_readable_binary_byte_format(value[, precision]) | Format a number in human-readable [IEC](https://en.wikipedia.org/wiki/Binary_prefix) format. `precision` must be in the range of [0,3] (default: 2). For example:<li> human_readable_binary_byte_format(1048576) returns `1.00 MiB`</li><li>human_readable_binary_byte_format(1048576, 1) returns `1.0 MiB`</li> |", "url": "https://github.com/apache/druid/pull/10635#discussion_r660433584", "createdAt": "2021-06-29T09:16:26Z", "author": {"login": "abhishekagarwal87"}, "path": "docs/misc/math-expr.md", "diffHunk": "@@ -258,3 +258,12 @@ supported features:\n * math functions: `abs`, `acos`, `asin`, `atan`, `cbrt`, `ceil`, `cos`, `cosh`, `cot`, `exp`, `expm1`, `floor`, `getExponent`, `log`, `log10`, `log1p`, `nextUp`, `rint`, `signum`, `sin`, `sinh`, `sqrt`, `tan`, `tanh`, `toDegrees`, `toRadians`, `ulp`, `atan2`, `copySign`, `div`, `hypot`, `max`, `min`, `nextAfter`,  `pow`, `remainder`, `scalb` are supported for numeric types\n * time functions: `timestamp_floor` (with constant granularity argument) is supported for numeric types\n * other: `parse_long` is supported for numeric and string types\n+\n+\n+## Other functions\n+\n+| function | description |\n+| --- | --- |\n+| human_readable_binary_byte_format(value[, precision]) | Format a number in human-readable [IEC](https://en.wikipedia.org/wiki/Binary_prefix) format. `precision` must be in the range of [0,3] (default: 2). For example:<li> human_readable_binary_byte_format(1048576) returns `1.00 MiB`</li><li>human_readable_binary_byte_format(1048576, 1) returns `1.000 MiB`</li> |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "30eb6eda3c521dc65bc36ef5f607332cee074bd2"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDQzNDUwOQ==", "bodyText": "Thanks for your quick review. I found this bug and fixed it.", "url": "https://github.com/apache/druid/pull/10635#discussion_r660434509", "createdAt": "2021-06-29T09:17:39Z", "author": {"login": "FrankChen021"}, "path": "docs/misc/math-expr.md", "diffHunk": "@@ -258,3 +258,12 @@ supported features:\n * math functions: `abs`, `acos`, `asin`, `atan`, `cbrt`, `ceil`, `cos`, `cosh`, `cot`, `exp`, `expm1`, `floor`, `getExponent`, `log`, `log10`, `log1p`, `nextUp`, `rint`, `signum`, `sin`, `sinh`, `sqrt`, `tan`, `tanh`, `toDegrees`, `toRadians`, `ulp`, `atan2`, `copySign`, `div`, `hypot`, `max`, `min`, `nextAfter`,  `pow`, `remainder`, `scalb` are supported for numeric types\n * time functions: `timestamp_floor` (with constant granularity argument) is supported for numeric types\n * other: `parse_long` is supported for numeric and string types\n+\n+\n+## Other functions\n+\n+| function | description |\n+| --- | --- |\n+| human_readable_binary_byte_format(value[, precision]) | Format a number in human-readable [IEC](https://en.wikipedia.org/wiki/Binary_prefix) format. `precision` must be in the range of [0,3] (default: 2). For example:<li> human_readable_binary_byte_format(1048576) returns `1.00 MiB`</li><li>human_readable_binary_byte_format(1048576, 1) returns `1.000 MiB`</li> |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDQzMzU4NA=="}, "originalCommit": {"oid": "30eb6eda3c521dc65bc36ef5f607332cee074bd2"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2884, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}