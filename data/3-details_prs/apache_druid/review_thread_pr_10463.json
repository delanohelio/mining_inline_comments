{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk2NzAyNjQx", "number": 10463, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDo1NDo1NVrOEp2Dcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDo1ODowOFrOEp2Iag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzEyNjkwOnYy", "diffSide": "RIGHT", "path": "integration-tests/src/main/java/org/apache/druid/testing/DockerConfigProvider.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDo1NDo1NVrOHbwyiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wM1QxNTozMTozN1rOHcCJ5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3Mjk2OQ==", "bodyText": "How does this flatten the map? It looks like it's just ignoring any value that isn't a String?", "url": "https://github.com/apache/druid/pull/10463#discussion_r498872969", "createdAt": "2020-10-02T14:54:55Z", "author": {"login": "suneet-s"}, "path": "integration-tests/src/main/java/org/apache/druid/testing/DockerConfigProvider.java", "diffHunk": "@@ -260,4 +269,32 @@ public String getStreamEndpoint()\n       }\n     };\n   }\n+\n+  // there is probably a better way to do this...\n+  static class ArbitraryPropertiesJsonDeserializer extends JsonDeserializer<Map<String, String>>\n+  {\n+    @Override\n+    public Map<String, String> deserialize(JsonParser jsonParser, DeserializationContext deserializationContext)\n+        throws IOException\n+    {\n+      // reading like this results in a map that has both nested objects and also flattened string pairs\n+      // so the map looks something like this:\n+\n+      //    {\n+      //      \"a\" : { \"b\": { \"c\" : \"d\" }}},\n+      //      \"a.b.c\":\"d\"\n+      //    }\n+\n+      // filtering out the top level keys which do not have string values produces what we want here that\n+      // '-Ddruid.test.config.properites.some.property.key=foo' -> { \"some.property.key\":\"foo\"}\n+      Map<String, Object> parsed = jsonParser.readValueAs(Map.class);\n+      Map<String, String> flat = new HashMap<>();\n+      for (Map.Entry<String, Object> entry : parsed.entrySet()) {\n+        if (entry.getValue() instanceof String) {\n+          flat.put(entry.getKey(), (String) entry.getValue());\n+        }\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ad8a54673505c4e0696abc2618fb4fc2b01b01"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzMTAzOQ==", "bodyText": "TBH I'm not entirely sure why the map ends up like it does coming from jackson, but I tried to explain what is going on here in the comments above. This block is just filtering out non-string values, leaving only the flat map after it is done.", "url": "https://github.com/apache/druid/pull/10463#discussion_r499031039", "createdAt": "2020-10-02T20:16:39Z", "author": {"login": "clintropolis"}, "path": "integration-tests/src/main/java/org/apache/druid/testing/DockerConfigProvider.java", "diffHunk": "@@ -260,4 +269,32 @@ public String getStreamEndpoint()\n       }\n     };\n   }\n+\n+  // there is probably a better way to do this...\n+  static class ArbitraryPropertiesJsonDeserializer extends JsonDeserializer<Map<String, String>>\n+  {\n+    @Override\n+    public Map<String, String> deserialize(JsonParser jsonParser, DeserializationContext deserializationContext)\n+        throws IOException\n+    {\n+      // reading like this results in a map that has both nested objects and also flattened string pairs\n+      // so the map looks something like this:\n+\n+      //    {\n+      //      \"a\" : { \"b\": { \"c\" : \"d\" }}},\n+      //      \"a.b.c\":\"d\"\n+      //    }\n+\n+      // filtering out the top level keys which do not have string values produces what we want here that\n+      // '-Ddruid.test.config.properites.some.property.key=foo' -> { \"some.property.key\":\"foo\"}\n+      Map<String, Object> parsed = jsonParser.readValueAs(Map.class);\n+      Map<String, String> flat = new HashMap<>();\n+      for (Map.Entry<String, Object> entry : parsed.entrySet()) {\n+        if (entry.getValue() instanceof String) {\n+          flat.put(entry.getKey(), (String) entry.getValue());\n+        }\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3Mjk2OQ=="}, "originalCommit": {"oid": "d0ad8a54673505c4e0696abc2618fb4fc2b01b01"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTAzNDQzNA==", "bodyText": "I misread your comment earlier I thought an input of\n{\"a\" : { \"b\": { \"c\" : \"d\" }}}}\nwould be converted to a map with an entry like\n\"a.b.c\":\"d\"\n\nTo help me understand, could you describe an example (sample input + expected output) where the default Deserializer would produce a different output from what this deserializer does?", "url": "https://github.com/apache/druid/pull/10463#discussion_r499034434", "createdAt": "2020-10-02T20:25:27Z", "author": {"login": "suneet-s"}, "path": "integration-tests/src/main/java/org/apache/druid/testing/DockerConfigProvider.java", "diffHunk": "@@ -260,4 +269,32 @@ public String getStreamEndpoint()\n       }\n     };\n   }\n+\n+  // there is probably a better way to do this...\n+  static class ArbitraryPropertiesJsonDeserializer extends JsonDeserializer<Map<String, String>>\n+  {\n+    @Override\n+    public Map<String, String> deserialize(JsonParser jsonParser, DeserializationContext deserializationContext)\n+        throws IOException\n+    {\n+      // reading like this results in a map that has both nested objects and also flattened string pairs\n+      // so the map looks something like this:\n+\n+      //    {\n+      //      \"a\" : { \"b\": { \"c\" : \"d\" }}},\n+      //      \"a.b.c\":\"d\"\n+      //    }\n+\n+      // filtering out the top level keys which do not have string values produces what we want here that\n+      // '-Ddruid.test.config.properites.some.property.key=foo' -> { \"some.property.key\":\"foo\"}\n+      Map<String, Object> parsed = jsonParser.readValueAs(Map.class);\n+      Map<String, String> flat = new HashMap<>();\n+      for (Map.Entry<String, Object> entry : parsed.entrySet()) {\n+        if (entry.getValue() instanceof String) {\n+          flat.put(entry.getKey(), (String) entry.getValue());\n+        }\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3Mjk2OQ=="}, "originalCommit": {"oid": "d0ad8a54673505c4e0696abc2618fb4fc2b01b01"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTE1NzQ3Nw==", "bodyText": "If its not been discussed before, its the org.apache.druid.guice.JsonConfigurator#hieraricalPutValue behind such kind of duplicate values. Its possible that passing properties such as below may work\ndruid.test.config.properties={\"kafka.test.property.security.protocol\": \"SASL_SSL\", \"kafka.test.property.sasl.mechanism\":\"PLAIN\"}", "url": "https://github.com/apache/druid/pull/10463#discussion_r499157477", "createdAt": "2020-10-03T15:31:37Z", "author": {"login": "abhishekagarwal87"}, "path": "integration-tests/src/main/java/org/apache/druid/testing/DockerConfigProvider.java", "diffHunk": "@@ -260,4 +269,32 @@ public String getStreamEndpoint()\n       }\n     };\n   }\n+\n+  // there is probably a better way to do this...\n+  static class ArbitraryPropertiesJsonDeserializer extends JsonDeserializer<Map<String, String>>\n+  {\n+    @Override\n+    public Map<String, String> deserialize(JsonParser jsonParser, DeserializationContext deserializationContext)\n+        throws IOException\n+    {\n+      // reading like this results in a map that has both nested objects and also flattened string pairs\n+      // so the map looks something like this:\n+\n+      //    {\n+      //      \"a\" : { \"b\": { \"c\" : \"d\" }}},\n+      //      \"a.b.c\":\"d\"\n+      //    }\n+\n+      // filtering out the top level keys which do not have string values produces what we want here that\n+      // '-Ddruid.test.config.properites.some.property.key=foo' -> { \"some.property.key\":\"foo\"}\n+      Map<String, Object> parsed = jsonParser.readValueAs(Map.class);\n+      Map<String, String> flat = new HashMap<>();\n+      for (Map.Entry<String, Object> entry : parsed.entrySet()) {\n+        if (entry.getValue() instanceof String) {\n+          flat.put(entry.getKey(), (String) entry.getValue());\n+        }\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3Mjk2OQ=="}, "originalCommit": {"oid": "d0ad8a54673505c4e0696abc2618fb4fc2b01b01"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyMzEzOTYyOnYy", "diffSide": "RIGHT", "path": "integration-tests/src/main/java/org/apache/druid/testing/utils/KafkaEventWriter.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDo1ODowOFrOHbw6hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMlQxNDo1ODowOFrOHbw6hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg3NTAxMg==", "bodyText": "Maybe move this to line 56 so that the config can override other properties like acks if needed in the future", "url": "https://github.com/apache/druid/pull/10463#discussion_r498875012", "createdAt": "2020-10-02T14:58:08Z", "author": {"login": "suneet-s"}, "path": "integration-tests/src/main/java/org/apache/druid/testing/utils/KafkaEventWriter.java", "diffHunk": "@@ -42,8 +42,8 @@\n   public KafkaEventWriter(IntegrationTestingConfig config, boolean txnEnabled)\n   {\n     Properties properties = new Properties();\n-    KafkaUtil.addPropertiesFromTestConfig(config, properties);\n     properties.setProperty(\"bootstrap.servers\", config.getKafkaHost());\n+    KafkaUtil.addPropertiesFromTestConfig(config, properties);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0ad8a54673505c4e0696abc2618fb4fc2b01b01"}, "originalPosition": 6}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2999, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}