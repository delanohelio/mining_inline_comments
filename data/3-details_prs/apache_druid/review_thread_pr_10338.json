{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3MjI2MzA1", "number": 10338, "reviewThreads": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzoyNDoyMVrOEfAdnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjoyMjowN1rOEjVz5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwOTQ4ODkzOnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzoyNDoyMVrOHLA33A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzoyNDoyMVrOHLA33A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMxMDY4NA==", "bodyText": "Should this check the columnType before offering a vectorized implementation? Similar question for other factories", "url": "https://github.com/apache/druid/pull/10338#discussion_r481310684", "createdAt": "2020-09-01T17:24:21Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/DoubleAnyAggregatorFactory.java", "diffHunk": "@@ -112,6 +115,18 @@ public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n     }\n   }\n \n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+    return new DoubleAnyVectorAggregator(selectorFactory.makeValueSelector(fieldName));\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49e4f0ced8e81a243afeaca6d79048a7c36bf30f"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwOTQ5MzQ5OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregatorFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzoyNTozNlrOHLA6jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNzoyNTozNlrOHLA6jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTMxMTM3Mw==", "bodyText": "should any column type be allowed?", "url": "https://github.com/apache/druid/pull/10338#discussion_r481311373", "createdAt": "2020-09-01T17:25:36Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregatorFactory.java", "diffHunk": "@@ -77,6 +82,37 @@ public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n     return new StringAnyBufferAggregator(metricFactory.makeColumnValueSelector(fieldName), maxStringBytes);\n   }\n \n+  @Override\n+  public VectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+\n+    ColumnCapabilities capabilities = selectorFactory.getColumnCapabilities(fieldName);\n+    if (capabilities == null || capabilities.hasMultipleValues().isFalse()) {\n+      return new StringAnyVectorAggregator(\n+          selectorFactory.makeSingleValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          null,\n+          maxStringBytes\n+      );\n+    } else {\n+      return new StringAnyVectorAggregator(\n+          null,\n+          selectorFactory.makeMultiValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          maxStringBytes\n+      );\n+\n+    }\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    if (fieldName != null) {\n+      ColumnCapabilities capabilities = columnInspector.getColumnCapabilities(fieldName);\n+      return capabilities == null || capabilities.getType() == ValueType.STRING;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49e4f0ced8e81a243afeaca6d79048a7c36bf30f"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTk2ODY5OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwMDoyMToyMFrOHM7fDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwMDoyMToyMFrOHM7fDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxOTU2Ng==", "bodyText": "This approach doesn't work, and one of the CalciteQueryTests caught it \ud83c\udf89", "url": "https://github.com/apache/druid/pull/10338#discussion_r483319566", "createdAt": "2020-09-04T00:21:20Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  private static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   * @return true if a value was put on the buffer, false otherwise.\n+   */\n+  abstract boolean putValue(ByteBuffer buf, int position, int startRow, int endRow);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putValue(buf, position, null);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      if (putValue(buf, position, startRow, endRow)) {\n+        buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(\n+      ByteBuffer buf,\n+      int numRows,\n+      int[] positions,\n+      @Nullable int[] rows,\n+      int positionOffset\n+  )\n+  {\n+    int prevPosition = -1;\n+    @Nullable Object theValue = null;\n+    boolean found = false;\n+    for (int i = 0; i < numRows; i++) {\n+      int position = positions[i] + positionOffset;\n+      int row = rows == null ? i : rows[i];\n+      // If the aggregate is not found at the position\n+      if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+        // If there's a value at the previous position, use it in this position.\n+        if (prevPosition >= 0 && (found || (buf.get(prevPosition) & BYTE_FLAG_FOUND_MASK) == BYTE_FLAG_FOUND_MASK)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49e4f0ced8e81a243afeaca6d79048a7c36bf30f"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjg2MzY1OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwNzo1ODozNFrOHNDpsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNTowMTozM1rOHNRKjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1MzM2MQ==", "bodyText": "startRow <= nulls.length is this check required? if so, it should check startRow < nulls.length", "url": "https://github.com/apache/druid/pull/10338#discussion_r483453361", "createdAt": "2020-09-04T07:58:34Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1MzkzNw==", "bodyText": "or endRow <= nulls.length", "url": "https://github.com/apache/druid/pull/10338#discussion_r483453937", "createdAt": "2020-09-04T07:59:32Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1MzM2MQ=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3NDc2NA==", "bodyText": "Fixed.", "url": "https://github.com/apache/druid/pull/10338#discussion_r483674764", "createdAt": "2020-09-04T15:01:33Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1MzM2MQ=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjg5ODE0OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODowOTowOFrOHND-nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNTowMjoxMVrOHNRL6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1ODcxOQ==", "bodyText": "should it not be aggregate(buf, position, row, row + 1) ?", "url": "https://github.com/apache/druid/pull/10338#discussion_r483458719", "createdAt": "2020-09-04T08:09:08Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putNull(buf, position);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      putValue(buf, position, startRow);\n+      buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(\n+      ByteBuffer buf,\n+      int numRows,\n+      int[] positions,\n+      @Nullable int[] rows,\n+      int positionOffset\n+  )\n+  {\n+    for (int i = 0; i < numRows; i++) {\n+      int position = positions[i] + positionOffset;\n+      int row = rows == null ? i : rows[i];\n+      aggregate(buf, position, row, row);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3NTExMw==", "bodyText": "yes \ud83d\ude2c", "url": "https://github.com/apache/druid/pull/10338#discussion_r483675113", "createdAt": "2020-09-04T15:02:11Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putNull(buf, position);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      putValue(buf, position, startRow);\n+      buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(\n+      ByteBuffer buf,\n+      int numRows,\n+      int[] positions,\n+      @Nullable int[] rows,\n+      int positionOffset\n+  )\n+  {\n+    for (int i = 0; i < numRows; i++) {\n+      int position = positions[i] + positionOffset;\n+      int row = rows == null ? i : rows[i];\n+      aggregate(buf, position, row, row);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ1ODcxOQ=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjkwOTY1OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoxMjoxOFrOHNEFPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNTowMTo1N1rOHNRLZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDQxNQ==", "bodyText": "are there unit tests for this method?", "url": "https://github.com/apache/druid/pull/10338#discussion_r483460415", "createdAt": "2020-09-04T08:12:18Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putNull(buf, position);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      putValue(buf, position, startRow);\n+      buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3NDk4Mw==", "bodyText": "added now. Was in progress when I pushed the last patch up.", "url": "https://github.com/apache/druid/pull/10338#discussion_r483674983", "createdAt": "2020-09-04T15:01:57Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putNull(buf, position);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      putValue(buf, position, startRow);\n+      buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MDQxNQ=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMjkyMzA1OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODoxNjoxNFrOHNENPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNTowNDozOFrOHNRRcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MjQ2Mw==", "bodyText": "I think it may be more efficient to not call aggregate. E.g. if a value is already found, we still iterate through the loop which could have been avoided. what do you think?", "url": "https://github.com/apache/druid/pull/10338#discussion_r483462463", "createdAt": "2020-09-04T08:16:14Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putNull(buf, position);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      putValue(buf, position, startRow);\n+      buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(\n+      ByteBuffer buf,\n+      int numRows,\n+      int[] positions,\n+      @Nullable int[] rows,\n+      int positionOffset\n+  )\n+  {\n+    for (int i = 0; i < numRows; i++) {\n+      int position = positions[i] + positionOffset;\n+      int row = rows == null ? i : rows[i];\n+      aggregate(buf, position, row, row);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY3NjUyOA==", "bodyText": "I tried that earlier and it failed a test with subqueries - #10338 (comment)", "url": "https://github.com/apache/druid/pull/10338#discussion_r483676528", "createdAt": "2020-09-04T15:04:38Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putNonNullValue(ByteBuffer buf, int position, Object value);\n+\n+  @Override\n+  public void init(ByteBuffer buf, int position)\n+  {\n+    buf.put(position, replaceWithDefault ? NullHandling.IS_NOT_NULL_BYTE : NullHandling.IS_NULL_BYTE);\n+    initValue(buf, position);\n+  }\n+\n+  @Override\n+  public void aggregate(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    if ((buf.get(position) & BYTE_FLAG_FOUND_MASK) != BYTE_FLAG_FOUND_MASK) {\n+      boolean[] nulls = vectorValueSelector.getNullVector();\n+      // check if there are any nulls\n+      if (nulls != null && startRow <= nulls.length) {\n+        for (int i = startRow; i < endRow; i++) {\n+          // And there is actually a null\n+          if (nulls[i]) {\n+            putNull(buf, position);\n+            return;\n+          }\n+        }\n+      }\n+      // There are no nulls, so put a value from the value selector\n+      putValue(buf, position, startRow);\n+      buf.put(position, (byte) (BYTE_FLAG_FOUND_MASK | NullHandling.IS_NOT_NULL_BYTE));\n+    }\n+  }\n+\n+  @Override\n+  public void aggregate(\n+      ByteBuffer buf,\n+      int numRows,\n+      int[] positions,\n+      @Nullable int[] rows,\n+      int positionOffset\n+  )\n+  {\n+    for (int i = 0; i < numRows; i++) {\n+      int position = positions[i] + positionOffset;\n+      int row = rows == null ? i : rows[i];\n+      aggregate(buf, position, row, row);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2MjQ2Mw=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzAwMzY0OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODozOTozM1rOHNE-Dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNToxMzo0NVrOHNRk3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NDk1OQ==", "bodyText": "non null", "url": "https://github.com/apache/druid/pull/10338#discussion_r483474959", "createdAt": "2020-09-04T08:39:33Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY4MTUwMg==", "bodyText": "Removed this function. Realized that it was just putting 0, which is what initValue does", "url": "https://github.com/apache/druid/pull/10338#discussion_r483681502", "createdAt": "2020-09-04T15:13:45Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);\n+\n+  /**\n+   * Place the primitive null value in the buffer, fiven the initial offset position within the byte buffer", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NDk1OQ=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzAwNjc5OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0MDoyNFrOHNE_5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNTo0NToxOVrOHNTCRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NTQzMA==", "bodyText": "nit: how about putNonNullRow?", "url": "https://github.com/apache/druid/pull/10338#discussion_r483475430", "createdAt": "2020-09-04T08:40:24Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwNTQxNQ==", "bodyText": "Refactored to boolean putAnyValueFromRow(ByteBuffer buf, int position, int startRow, int endRow)", "url": "https://github.com/apache/druid/pull/10338#discussion_r483705415", "createdAt": "2020-09-04T15:45:19Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;\n+\n+  private final boolean replaceWithDefault = NullHandling.replaceWithDefault();\n+  protected final VectorValueSelector vectorValueSelector;\n+\n+  public NumericAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    this.vectorValueSelector = vectorValueSelector;\n+  }\n+\n+  /**\n+   * Initialize the buffer value given the initial offset position within the byte buffer for initialization\n+   */\n+  abstract void initValue(ByteBuffer buf, int position);\n+\n+  /**\n+   * Place the primitive value in the buffer given the initial offset position within the byte buffer\n+   * at which the current aggregate value is stored.\n+   */\n+  abstract void putValue(ByteBuffer buf, int position, int row);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NTQzMA=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzAxNTQ4OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0MjozN1rOHNFE4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNTo0NTozN1rOHNTDDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NjcwNA==", "bodyText": "again nitpicking: but this can be made private. In inherited classes, instead of passing position, you can pass position + FOUND_VALUE_OFFSET so that those methods are free of any logic related to offset.", "url": "https://github.com/apache/druid/pull/10338#discussion_r483476704", "createdAt": "2020-09-04T08:42:37Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NzIyMw==", "bodyText": "they would also be free of any null handling", "url": "https://github.com/apache/druid/pull/10338#discussion_r483477223", "createdAt": "2020-09-04T08:43:35Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NjcwNA=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwNTYxNA==", "bodyText": "good suggestion! Done.", "url": "https://github.com/apache/druid/pull/10338#discussion_r483705614", "createdAt": "2020-09-04T15:45:37Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+public abstract class NumericAnyVectorAggregator implements VectorAggregator\n+{\n+  // Rightmost bit for is null check (0 for is null and 1 for not null)\n+  // Second rightmost bit for is found check (0 for not found and 1 for found)\n+  @VisibleForTesting\n+  static final byte BYTE_FLAG_FOUND_MASK = 0x02;\n+  private static final byte BYTE_FLAG_NULL_MASK = 0x01;\n+  protected static final int FOUND_VALUE_OFFSET = Byte.BYTES;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3NjcwNA=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMzAyODM3OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregatorFactory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQwODo0NjoxMFrOHNFMwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNjoxMjoyMFrOHNT4vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3ODcyMA==", "bodyText": "out of curiosity, when can capabilities be null?", "url": "https://github.com/apache/druid/pull/10338#discussion_r483478720", "createdAt": "2020-09-04T08:46:10Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregatorFactory.java", "diffHunk": "@@ -77,6 +81,33 @@ public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n     return new StringAnyBufferAggregator(metricFactory.makeColumnValueSelector(fieldName), maxStringBytes);\n   }\n \n+  @Override\n+  public StringAnyVectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+\n+    ColumnCapabilities capabilities = selectorFactory.getColumnCapabilities(fieldName);\n+    if (capabilities == null || capabilities.hasMultipleValues().isMaybeTrue()) {\n+      return new StringAnyVectorAggregator(\n+          null,\n+          selectorFactory.makeMultiValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          maxStringBytes\n+      );\n+    } else {\n+      return new StringAnyVectorAggregator(\n+          selectorFactory.makeSingleValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          null,\n+          maxStringBytes\n+      );\n+    }\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    ColumnCapabilities capabilities = columnInspector.getColumnCapabilities(fieldName);\n+    return capabilities == null || capabilities.getType() == ValueType.STRING;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwNjYzMg==", "bodyText": "/**\n   * Returns capabilities of a particular column, if known. May be null if the column doesn't exist, or if\n   * the column does exist but the capabilities are unknown. The latter is possible with dynamically discovered\n   * columns.\n   *\n   * Note that StorageAdapters are representations of \"real\" segments, so they are not aware of any virtual columns\n   * that may be involved in a query. In general, query engines should instead use the method\n   * {@link ColumnSelectorFactory#getColumnCapabilities(String)}, which returns capabilities for virtual columns as\n   * well.\n   *\n   * @param column column name\n   *\n   * @return capabilities, or null\n   */\n  @Override\n  @Nullable\n  ColumnCapabilities getColumnCapabilities(String column);\n\nI found this explanation in StorageAdapter#getColumnCapabilities", "url": "https://github.com/apache/druid/pull/10338#discussion_r483706632", "createdAt": "2020-09-04T15:47:42Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregatorFactory.java", "diffHunk": "@@ -77,6 +81,33 @@ public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n     return new StringAnyBufferAggregator(metricFactory.makeColumnValueSelector(fieldName), maxStringBytes);\n   }\n \n+  @Override\n+  public StringAnyVectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+\n+    ColumnCapabilities capabilities = selectorFactory.getColumnCapabilities(fieldName);\n+    if (capabilities == null || capabilities.hasMultipleValues().isMaybeTrue()) {\n+      return new StringAnyVectorAggregator(\n+          null,\n+          selectorFactory.makeMultiValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          maxStringBytes\n+      );\n+    } else {\n+      return new StringAnyVectorAggregator(\n+          selectorFactory.makeSingleValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          null,\n+          maxStringBytes\n+      );\n+    }\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    ColumnCapabilities capabilities = columnInspector.getColumnCapabilities(fieldName);\n+    return capabilities == null || capabilities.getType() == ValueType.STRING;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3ODcyMA=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxOTM1Nw==", "bodyText": "Thanks \ud83d\udc4d", "url": "https://github.com/apache/druid/pull/10338#discussion_r483719357", "createdAt": "2020-09-04T16:12:20Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/StringAnyAggregatorFactory.java", "diffHunk": "@@ -77,6 +81,33 @@ public BufferAggregator factorizeBuffered(ColumnSelectorFactory metricFactory)\n     return new StringAnyBufferAggregator(metricFactory.makeColumnValueSelector(fieldName), maxStringBytes);\n   }\n \n+  @Override\n+  public StringAnyVectorAggregator factorizeVector(VectorColumnSelectorFactory selectorFactory)\n+  {\n+\n+    ColumnCapabilities capabilities = selectorFactory.getColumnCapabilities(fieldName);\n+    if (capabilities == null || capabilities.hasMultipleValues().isMaybeTrue()) {\n+      return new StringAnyVectorAggregator(\n+          null,\n+          selectorFactory.makeMultiValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          maxStringBytes\n+      );\n+    } else {\n+      return new StringAnyVectorAggregator(\n+          selectorFactory.makeSingleValueDimensionSelector(DefaultDimensionSpec.of(fieldName)),\n+          null,\n+          maxStringBytes\n+      );\n+    }\n+  }\n+\n+  @Override\n+  public boolean canVectorize(ColumnInspector columnInspector)\n+  {\n+    ColumnCapabilities capabilities = columnInspector.getColumnCapabilities(fieldName);\n+    return capabilities == null || capabilities.getType() == ValueType.STRING;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ3ODcyMA=="}, "originalCommit": {"oid": "bf291df4c1122257c4a47f1e992b417800f101c8"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyODUzNzI2OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/FloatAnyVectorAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwNzo1Mzo1MVrOHN0XMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNTo0MzozNlrOHOjSVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI1MTQ0MA==", "bodyText": "by the way, are these checks necessary? The framework calling aggregators should be taking care of passing valid ranges. If not, its a bug and exception will be raised. I didn't notice these checks in other vector aggregation implementations.", "url": "https://github.com/apache/druid/pull/10338#discussion_r484251440", "createdAt": "2020-09-07T07:53:51Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/FloatAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Vectorized implementation of the {@link FloatAnyBufferAggregator}\n+ */\n+public class FloatAnyVectorAggregator extends NumericAnyVectorAggregator\n+{\n+  public FloatAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    super(vectorValueSelector);\n+  }\n+\n+  @Override\n+  void initValue(ByteBuffer buf, int position)\n+  {\n+    buf.putFloat(position, 0F);\n+  }\n+\n+  @Override\n+  boolean putAnyValueFromRow(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    float[] values = vectorValueSelector.getFloatVector();\n+    boolean isRowsWithinIndex = startRow < endRow && startRow < values.length;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9e56f04ce7db06e0fa38b3e761072fb95289a23"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyMDI0NQ==", "bodyText": "I wasn't sure if it's needed or not. The other aggregators have these checks implicitly within the for loops I think", "url": "https://github.com/apache/druid/pull/10338#discussion_r485020245", "createdAt": "2020-09-08T15:43:36Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/FloatAnyVectorAggregator.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Vectorized implementation of the {@link FloatAnyBufferAggregator}\n+ */\n+public class FloatAnyVectorAggregator extends NumericAnyVectorAggregator\n+{\n+  public FloatAnyVectorAggregator(VectorValueSelector vectorValueSelector)\n+  {\n+    super(vectorValueSelector);\n+  }\n+\n+  @Override\n+  void initValue(ByteBuffer buf, int position)\n+  {\n+    buf.putFloat(position, 0F);\n+  }\n+\n+  @Override\n+  boolean putAnyValueFromRow(ByteBuffer buf, int position, int startRow, int endRow)\n+  {\n+    float[] values = vectorValueSelector.getFloatVector();\n+    boolean isRowsWithinIndex = startRow < endRow && startRow < values.length;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDI1MTQ0MA=="}, "originalCommit": {"oid": "d9e56f04ce7db06e0fa38b3e761072fb95289a23"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyODk1NDE5OnYy", "diffSide": "RIGHT", "path": "processing/src/test/java/org/apache/druid/query/aggregation/any/DoubleAnyVectorAggregatorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwOTozNzoyMlrOHN4P8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwOTo0MjoyOFrOHN4cMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxNTEyMQ==", "bodyText": "this got me thinking about how did this test pass. There was no flag set in the buffer and the target still returned the value. I realized that in NumericAnyVectorAggregator, non-null is the default than null\nboolean isValueNull(ByteBuffer buf, int position)\n  {\n    return (buf.get(position) & BYTE_FLAG_NULL_MASK) == NullHandling.IS_NULL_BYTE;\n  }\n\nIt should be fine since init is always called. maybe the tests should do the same as well.", "url": "https://github.com/apache/druid/pull/10338#discussion_r484315121", "createdAt": "2020-09-07T09:37:22Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/test/java/org/apache/druid/query/aggregation/any/DoubleAnyVectorAggregatorTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+import org.apache.druid.testing.InitializedNullHandlingTest;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import static org.mockito.Mockito.spy;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class DoubleAnyVectorAggregatorTest extends InitializedNullHandlingTest\n+{\n+  private static final int NULL_POSITION = 32;\n+  private static final int POSITION = 2;\n+  private static final double EPSILON = 1e-15;\n+  private static final double[] VALUES = new double[]{7.8d, 11, 23.67, 60, 123};\n+\n+  private ByteBuffer buf;\n+  @Mock\n+  private VectorValueSelector selector;\n+\n+  private DoubleAnyVectorAggregator target;\n+\n+  @Before\n+  public void setUp()\n+  {\n+    byte[] randomBytes = new byte[128];\n+    ThreadLocalRandom.current().nextBytes(randomBytes);\n+    buf = ByteBuffer.wrap(randomBytes);\n+    Mockito.doReturn(VALUES).when(selector).getDoubleVector();\n+\n+    target = spy(new DoubleAnyVectorAggregator(selector));\n+    Mockito.when(target.isValueNull(buf, NULL_POSITION)).thenReturn(true);\n+    Mockito.when(target.isValueNull(buf, POSITION)).thenReturn(false);\n+  }\n+\n+  @Test\n+  public void initValueShouldInitZero()\n+  {\n+    target.initValue(buf, POSITION);\n+    Assert.assertEquals(0, buf.getDouble(POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void getAtPositionIsNullShouldReturnNull()\n+  {\n+    Assert.assertNull(target.get(buf, NULL_POSITION));\n+  }\n+\n+  @Test\n+  public void getAtPositionShouldReturnValue()\n+  {\n+    buf.putDouble(POSITION + 1, VALUES[3]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9e56f04ce7db06e0fa38b3e761072fb95289a23"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxODI1Ng==", "bodyText": "Mockito.when(target.isValueNull(buf, POSITION)).thenReturn(false); should be taking care of it.", "url": "https://github.com/apache/druid/pull/10338#discussion_r484318256", "createdAt": "2020-09-07T09:42:28Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/test/java/org/apache/druid/query/aggregation/any/DoubleAnyVectorAggregatorTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+import org.apache.druid.testing.InitializedNullHandlingTest;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import static org.mockito.Mockito.spy;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class DoubleAnyVectorAggregatorTest extends InitializedNullHandlingTest\n+{\n+  private static final int NULL_POSITION = 32;\n+  private static final int POSITION = 2;\n+  private static final double EPSILON = 1e-15;\n+  private static final double[] VALUES = new double[]{7.8d, 11, 23.67, 60, 123};\n+\n+  private ByteBuffer buf;\n+  @Mock\n+  private VectorValueSelector selector;\n+\n+  private DoubleAnyVectorAggregator target;\n+\n+  @Before\n+  public void setUp()\n+  {\n+    byte[] randomBytes = new byte[128];\n+    ThreadLocalRandom.current().nextBytes(randomBytes);\n+    buf = ByteBuffer.wrap(randomBytes);\n+    Mockito.doReturn(VALUES).when(selector).getDoubleVector();\n+\n+    target = spy(new DoubleAnyVectorAggregator(selector));\n+    Mockito.when(target.isValueNull(buf, NULL_POSITION)).thenReturn(true);\n+    Mockito.when(target.isValueNull(buf, POSITION)).thenReturn(false);\n+  }\n+\n+  @Test\n+  public void initValueShouldInitZero()\n+  {\n+    target.initValue(buf, POSITION);\n+    Assert.assertEquals(0, buf.getDouble(POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void getAtPositionIsNullShouldReturnNull()\n+  {\n+    Assert.assertNull(target.get(buf, NULL_POSITION));\n+  }\n+\n+  @Test\n+  public void getAtPositionShouldReturnValue()\n+  {\n+    buf.putDouble(POSITION + 1, VALUES[3]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxNTEyMQ=="}, "originalCommit": {"oid": "d9e56f04ce7db06e0fa38b3e761072fb95289a23"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyODk2MDMwOnYy", "diffSide": "RIGHT", "path": "processing/src/test/java/org/apache/druid/query/aggregation/any/DoubleAnyVectorAggregatorTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QwOTozODo1OFrOHN4TuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQxNjoxNDoyM1rOHOkhng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxNjA4OA==", "bodyText": "we should be passing the delta in assertNotEquals methods too.", "url": "https://github.com/apache/druid/pull/10338#discussion_r484316088", "createdAt": "2020-09-07T09:38:58Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/test/java/org/apache/druid/query/aggregation/any/DoubleAnyVectorAggregatorTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+import org.apache.druid.testing.InitializedNullHandlingTest;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import static org.mockito.Mockito.spy;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class DoubleAnyVectorAggregatorTest extends InitializedNullHandlingTest\n+{\n+  private static final int NULL_POSITION = 32;\n+  private static final int POSITION = 2;\n+  private static final double EPSILON = 1e-15;\n+  private static final double[] VALUES = new double[]{7.8d, 11, 23.67, 60, 123};\n+\n+  private ByteBuffer buf;\n+  @Mock\n+  private VectorValueSelector selector;\n+\n+  private DoubleAnyVectorAggregator target;\n+\n+  @Before\n+  public void setUp()\n+  {\n+    byte[] randomBytes = new byte[128];\n+    ThreadLocalRandom.current().nextBytes(randomBytes);\n+    buf = ByteBuffer.wrap(randomBytes);\n+    Mockito.doReturn(VALUES).when(selector).getDoubleVector();\n+\n+    target = spy(new DoubleAnyVectorAggregator(selector));\n+    Mockito.when(target.isValueNull(buf, NULL_POSITION)).thenReturn(true);\n+    Mockito.when(target.isValueNull(buf, POSITION)).thenReturn(false);\n+  }\n+\n+  @Test\n+  public void initValueShouldInitZero()\n+  {\n+    target.initValue(buf, POSITION);\n+    Assert.assertEquals(0, buf.getDouble(POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void getAtPositionIsNullShouldReturnNull()\n+  {\n+    Assert.assertNull(target.get(buf, NULL_POSITION));\n+  }\n+\n+  @Test\n+  public void getAtPositionShouldReturnValue()\n+  {\n+    buf.putDouble(POSITION + 1, VALUES[3]);\n+    Assert.assertEquals(VALUES[3], (double) target.get(buf, POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void putValueShouldAddToBuffer()\n+  {\n+    Assert.assertTrue(target.putAnyValueFromRow(buf, POSITION, 2, 3));\n+    Assert.assertEquals(VALUES[2], buf.getDouble(POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void putValueStartAfterEndShouldNotAddToBuffer()\n+  {\n+    Assert.assertFalse(target.putAnyValueFromRow(buf, POSITION, 2, 2));\n+    Assert.assertNotEquals(VALUES[2], buf.getDouble(POSITION));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d9e56f04ce7db06e0fa38b3e761072fb95289a23"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAyMzc2MA==", "bodyText": "will add in the next patch. waiting to see if any other changes are needed", "url": "https://github.com/apache/druid/pull/10338#discussion_r485023760", "createdAt": "2020-09-08T15:48:44Z", "author": {"login": "suneet-s"}, "path": "processing/src/test/java/org/apache/druid/query/aggregation/any/DoubleAnyVectorAggregatorTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+import org.apache.druid.testing.InitializedNullHandlingTest;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import static org.mockito.Mockito.spy;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class DoubleAnyVectorAggregatorTest extends InitializedNullHandlingTest\n+{\n+  private static final int NULL_POSITION = 32;\n+  private static final int POSITION = 2;\n+  private static final double EPSILON = 1e-15;\n+  private static final double[] VALUES = new double[]{7.8d, 11, 23.67, 60, 123};\n+\n+  private ByteBuffer buf;\n+  @Mock\n+  private VectorValueSelector selector;\n+\n+  private DoubleAnyVectorAggregator target;\n+\n+  @Before\n+  public void setUp()\n+  {\n+    byte[] randomBytes = new byte[128];\n+    ThreadLocalRandom.current().nextBytes(randomBytes);\n+    buf = ByteBuffer.wrap(randomBytes);\n+    Mockito.doReturn(VALUES).when(selector).getDoubleVector();\n+\n+    target = spy(new DoubleAnyVectorAggregator(selector));\n+    Mockito.when(target.isValueNull(buf, NULL_POSITION)).thenReturn(true);\n+    Mockito.when(target.isValueNull(buf, POSITION)).thenReturn(false);\n+  }\n+\n+  @Test\n+  public void initValueShouldInitZero()\n+  {\n+    target.initValue(buf, POSITION);\n+    Assert.assertEquals(0, buf.getDouble(POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void getAtPositionIsNullShouldReturnNull()\n+  {\n+    Assert.assertNull(target.get(buf, NULL_POSITION));\n+  }\n+\n+  @Test\n+  public void getAtPositionShouldReturnValue()\n+  {\n+    buf.putDouble(POSITION + 1, VALUES[3]);\n+    Assert.assertEquals(VALUES[3], (double) target.get(buf, POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void putValueShouldAddToBuffer()\n+  {\n+    Assert.assertTrue(target.putAnyValueFromRow(buf, POSITION, 2, 3));\n+    Assert.assertEquals(VALUES[2], buf.getDouble(POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void putValueStartAfterEndShouldNotAddToBuffer()\n+  {\n+    Assert.assertFalse(target.putAnyValueFromRow(buf, POSITION, 2, 2));\n+    Assert.assertNotEquals(VALUES[2], buf.getDouble(POSITION));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxNjA4OA=="}, "originalCommit": {"oid": "d9e56f04ce7db06e0fa38b3e761072fb95289a23"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA0MDU0Mg==", "bodyText": "Looks good to me otherwise.", "url": "https://github.com/apache/druid/pull/10338#discussion_r485040542", "createdAt": "2020-09-08T16:14:23Z", "author": {"login": "abhishekagarwal87"}, "path": "processing/src/test/java/org/apache/druid/query/aggregation/any/DoubleAnyVectorAggregatorTest.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.segment.vector.VectorValueSelector;\n+import org.apache.druid.testing.InitializedNullHandlingTest;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+import java.nio.ByteBuffer;\n+import java.util.concurrent.ThreadLocalRandom;\n+\n+import static org.mockito.Mockito.spy;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class DoubleAnyVectorAggregatorTest extends InitializedNullHandlingTest\n+{\n+  private static final int NULL_POSITION = 32;\n+  private static final int POSITION = 2;\n+  private static final double EPSILON = 1e-15;\n+  private static final double[] VALUES = new double[]{7.8d, 11, 23.67, 60, 123};\n+\n+  private ByteBuffer buf;\n+  @Mock\n+  private VectorValueSelector selector;\n+\n+  private DoubleAnyVectorAggregator target;\n+\n+  @Before\n+  public void setUp()\n+  {\n+    byte[] randomBytes = new byte[128];\n+    ThreadLocalRandom.current().nextBytes(randomBytes);\n+    buf = ByteBuffer.wrap(randomBytes);\n+    Mockito.doReturn(VALUES).when(selector).getDoubleVector();\n+\n+    target = spy(new DoubleAnyVectorAggregator(selector));\n+    Mockito.when(target.isValueNull(buf, NULL_POSITION)).thenReturn(true);\n+    Mockito.when(target.isValueNull(buf, POSITION)).thenReturn(false);\n+  }\n+\n+  @Test\n+  public void initValueShouldInitZero()\n+  {\n+    target.initValue(buf, POSITION);\n+    Assert.assertEquals(0, buf.getDouble(POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void getAtPositionIsNullShouldReturnNull()\n+  {\n+    Assert.assertNull(target.get(buf, NULL_POSITION));\n+  }\n+\n+  @Test\n+  public void getAtPositionShouldReturnValue()\n+  {\n+    buf.putDouble(POSITION + 1, VALUES[3]);\n+    Assert.assertEquals(VALUES[3], (double) target.get(buf, POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void putValueShouldAddToBuffer()\n+  {\n+    Assert.assertTrue(target.putAnyValueFromRow(buf, POSITION, 2, 3));\n+    Assert.assertEquals(VALUES[2], buf.getDouble(POSITION), EPSILON);\n+  }\n+\n+  @Test\n+  public void putValueStartAfterEndShouldNotAddToBuffer()\n+  {\n+    Assert.assertFalse(target.putAnyValueFromRow(buf, POSITION, 2, 2));\n+    Assert.assertNotEquals(VALUES[2], buf.getDouble(POSITION));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDMxNjA4OA=="}, "originalCommit": {"oid": "d9e56f04ce7db06e0fa38b3e761072fb95289a23"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1NDkyOTY2OnYy", "diffSide": "RIGHT", "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericNilVectorAggregator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjoyMjowN1rOHRpJjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMjo0OTowMVrOHRqSew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI2MjAzMA==", "bodyText": "nit: can extend NoopVectorAggregator to reduce boilerplate. I also don't think you need separate classes for each type, since the number is an object anyway, can just instantiate each singleton using NullHandling.defaultLongValue() etc.", "url": "https://github.com/apache/druid/pull/10338#discussion_r488262030", "createdAt": "2020-09-14T22:22:07Z", "author": {"login": "clintropolis"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericNilVectorAggregator.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * A vector aggregator that returns the default numeric value.\n+ */\n+public abstract class NumericNilVectorAggregator implements VectorAggregator", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8832808a07015619ef5369adc82a20062643105b"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4MDY5OQ==", "bodyText": "I decided not to extend NoopVectorAggregator since it's constructor was private, and I didn't want to think through what the right inheritance model should be. I did take your suggestion on just instantiating 1 singleton for each numeric type to reduce the boiler plate code. New patch incoming...", "url": "https://github.com/apache/druid/pull/10338#discussion_r488280699", "createdAt": "2020-09-14T22:49:01Z", "author": {"login": "suneet-s"}, "path": "processing/src/main/java/org/apache/druid/query/aggregation/any/NumericNilVectorAggregator.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.apache.druid.query.aggregation.any;\n+\n+import org.apache.druid.common.config.NullHandling;\n+import org.apache.druid.query.aggregation.VectorAggregator;\n+\n+import javax.annotation.Nullable;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * A vector aggregator that returns the default numeric value.\n+ */\n+public abstract class NumericNilVectorAggregator implements VectorAggregator", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI2MjAzMA=="}, "originalCommit": {"oid": "8832808a07015619ef5369adc82a20062643105b"}, "originalPosition": 31}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3144, "cost": 1, "resetAt": "2021-11-12T11:18:39Z"}}}